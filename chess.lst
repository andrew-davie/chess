------- FILE ./chess.asm LEVEL 1 PASS 4
      1  6c00 ????						; Chess
      2  6c00 ????						; Atari 2600 Chess display system
      3  6c00 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  6c00 ????						; andrew@taswegian.com
      5  6c00 ????
      6  6c00 ????
      7  6c00 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  6c00 ????
      9  6c00 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  6c00 ????				      include	"vcs.h"
      1  6c00 ????						; VCS.H
      2  6c00 ????						; Version 1.05, 13/November/2003
      3  6c00 ????
      4  6c00 ????	       00 69	   VERSION_VCS =	105
      5  6c00 ????
      6  6c00 ????						; This file defines hardware registers and memory mapping for the
      7  6c00 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  6c00 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  6c00 ????						; available at at http://www.atari2600.org/dasm
     10  6c00 ????						;
     11  6c00 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  6c00 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  6c00 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  6c00 ????						; with your views.  Please contribute, if you think you can improve this
     15  6c00 ????						; file!
     16  6c00 ????						;
     17  6c00 ????						; Latest Revisions...
     18  6c00 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  6c00 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  6c00 ????						;			    This will allow conditional code to verify VCS.H being
     21  6c00 ????						;			    used for code assembly.
     22  6c00 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  6c00 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  6c00 ????						;			 mirrored reading/writing differences.	This is more a
     25  6c00 ????						;			 readability issue, and binary compatibility with disassembled
     26  6c00 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  6c00 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  6c00 ????						;			 which was broken by the use of segments in this file, as
     29  6c00 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  6c00 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  6c00 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  6c00 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  6c00 ????						;						   it is safe to leave it undefined, and the base address will
     34  6c00 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  6c00 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  6c00 ????						;			  - register definitions are now generated through assignment
     37  6c00 ????						;			    in uninitialised segments.	This allows a changeable base
     38  6c00 ????						;			    address architecture.
     39  6c00 ????						; 1.0	22/MAR/2003		Initial release
     40  6c00 ????
     41  6c00 ????
     42  6c00 ????						;-------------------------------------------------------------------------------
     43  6c00 ????
     44  6c00 ????						; TIA_BASE_ADDRESS
     45  6c00 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  6c00 ????						; Normally 0, the base address should (externally, before including this file)
     47  6c00 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  6c00 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  6c00 ????						; < $40 as a bankswitch.
     50  6c00 ????
     51  6c00 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  6c00 ????			  -TIA_BASE_ADDRESS =	0
     53  6c00 ????				      ENDIF
     54  6c00 ????
     55  6c00 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  6c00 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  6c00 ????						; *OR* by declaring the label before including this file, eg:
     58  6c00 ????						; TIA_BASE_ADDRESS = $40
     59  6c00 ????						;   include "vcs.h"
     60  6c00 ????
     61  6c00 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  6c00 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  6c00 ????						; for the mirrored ROM hardware registers.
     64  6c00 ????
     65  6c00 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  6c00 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  6c00 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  6c00 ????
     69  6c00 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  6c00 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  6c00 ????				      ENDIF
     72  6c00 ????
     73  6c00 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  6c00 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  6c00 ????				      ENDIF
     76  6c00 ????
     77  6c00 ????						;-------------------------------------------------------------------------------
     78  6c00 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
     19  0000 ????						;include "segtime.asm"
     20  0000 ????
     21  0000 ????
     22  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     23  0000 ????
     24  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     25  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     26  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     27  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????
     35  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     36  0000 ????
     37  0000 ????
     38  0000 ????						; assemble diagnostics. Remove for release.
     39  0000 ????
     40  0000 ????	       00 01	   TEST_POSITION =	1	; 0=normal, 1 = setup test position
     41  0000 ????	       00 01	   DIAGNOSTICS =	1
     42  0000 ????	       00 01	   QUIESCENCE =	1
     43  0000 ????	       00 00	   ASSERTS    =	0
     44  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     45  0000 ????	       00 00	   ENPASSANT_ENABLED =	0
     46  0000 ????	       00 01	   CASTLING_ENABLED =	1
     47  0000 ????
     48  0000 ????						; NOTE: SEARCH_DEPTH cannot be < 3, because the player's moves are generated from PLY+1, and use
     49  0000 ????						; PLY+2 for computer response (thus, 3). The bank allocation gets stomped!
     50  0000 ????
     51  0000 ????
     52  0000 ????	       00 03	   SEARCH_DEPTH =	3
     53  0000 ????	       00 06	   QUIESCE_EXTRA_DEPTH =	6
     54  0000 ????
     55  0000 ????
     56  0000 ????			  -	      IF	SEARCH_DEPTH < 3
     57  0000 ????			  -	      ECHO	"ERROR: Search depth nust be >= 3"
     58  0000 ????			  -	      ERR
     59  0000 ????				      ENDIF
     60  0000 ????
     61  0000 ????
     62  0000 ????
     63  0000 ????	       00 09	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     64  0000 ????	       00 09	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     65  0000 ????
     66  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     67  0000 ????						;    ERR "Not enough RAM for PLY banks"
     68  0000 ????						;ENDIF
     69  0000 ????
     70  0000 ????
     71  0000 ????
     72  0000 ????
     73  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     74  0000 ????
     75  0000 ????
     76  0000 ????
     77  0000 ????						; DELAYS
     78  0000 ????
     79  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     80  0000 ????
     81  0000 ????						;===================================
     82  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     83  0000 ????						;===================================
     84  0000 ????
     85  0000 ????						;-------------------------------------------------------------------------------
     86  0000 ????						; The following are optional YES/NO depending on phase of the moon
     87  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     88  0000 ????						;-------------------------------------------------------------------------------
     89  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     90  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     91  0000 ????			  -	      IF	FINAL_VERSION = YES
     92  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     93  0000 ????				      ENDIF
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????
     97  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     98  0000 ????
     99  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    100  0000 ????
    101  0000 ????						;------------------------------------------------------------------------------
    102  0000 ????
    103  0000 ????	       00 01	   PLUSCART   =	YES
    104  0000 ????
    105  0000 ????						;------------------------------------------------------------------------------
    106  0000 ????
    107  0000 ????
    108  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
    109  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    110  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    111  0000 ????
    112  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    113  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    114  0000 ????
    115  0000 ????
    116  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    117  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    118  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    119  0000 ????
    120  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    121  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    122  0000 ????
    123  0000 ????
    124  0000 ????						; Platform constants:
    125  0000 ????	       00 02	   PAL	      =	%10
    126  0000 ????	       00 02	   PAL_50     =	PAL|0
    127  0000 ????	       00 03	   PAL_60     =	PAL|1
    128  0000 ????
    129  0000 ????
    130  0000 ????				      IF	L276
    131  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    132  0000 ????			  -	      ELSE
    133  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    134  0000 ????				      ENDIF
    135  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    136  0000 ????
    137  0000 ????				      IF	L276
    138  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    139  0000 ????			  -	      ELSE
    140  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    141  0000 ????				      ENDIF
    142  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    143  0000 ????
    144  0000 ????				      IF	L276
    145  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    146  0000 ????			  -	      ELSE
    147  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    148  0000 ????				      ENDIF
    149  0000 ????	       01 38	   SCANLINES_PAL =	312
    150  0000 ????
    151  0000 ????
    152  0000 ????	       00 2e	   TIME_PART_2 =	46
    153  0000 ????	       00 2e	   TIME_PART_1 =	46
    154  0000 ????
    155  0000 ????
    156  0000 ????	       00 00	   SLOT0      =	0
    157  0000 ????	       00 40	   SLOT1      =	64
    158  0000 ????	       00 80	   SLOT2      =	128
    159  0000 ????	       00 c0	   SLOT3      =	192
    160  0000 ????
    161  0000 ????						;------------------------------------------------------------------------------
    162  0000 ????						; MACRO definitions
    163  0000 ????
    164  0000 ????
    165  0000 ????
    166  0000 ????				      MAC	newbank
    167  0000 ????				      SEG	{1}
    168  0000 ????				      ORG	_ORIGIN
    169  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    170  0000 ????			   _BANK_START SET	*
    171  0000 ????			   {1}_START  SET	*
    172  0000 ????			   _CURRENT_BANK SET	_ORIGIN/1024
    173  0000 ????			   {1}	      SET	_BANK_SLOT + _CURRENT_BANK
    174  0000 ????			   _ORIGIN    SET	_ORIGIN + 1024
    175  0000 ????				      ENDM		; bank name
    176  0000 ????
    177  0000 ????						;	      MAC DEFINE_1K_SEGMENT ; {seg name}
    178  0000 ????						;		  ALIGN $400
    179  0000 ????						;SEGMENT_{1}	  SET *
    180  0000 ????						;BANK_{1}	  SET _CURRENT_BANK
    181  0000 ????						;	      ENDM
    182  0000 ????
    183  0000 ????				      MAC	check_bank_size
    184  0000 ????			   .TEMP      =	* - _BANK_START
    185  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    186  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    187  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    188  0000 ????				      ERR
    189  0000 ????				      ENDIF
    190  0000 ????				      ENDM		; name
    191  0000 ????
    192  0000 ????				      MAC	check_ram_bank_size
    193  0000 ????			   .TEMP      =	* - _BANK_START
    194  0000 ????				      ECHO	{1}, "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    195  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    196  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    197  0000 ????				      ERR
    198  0000 ????				      ENDIF
    199  0000 ????				      ENDM		; name
    200  0000 ????
    201  0000 ????						;---------------------------------------------------------------------------------------------------
    202  0000 ????
    203  0000 ????						; Macro inserts a page break if the object would overlap a page
    204  0000 ????
    205  0000 ????				      MAC	optional_pagebreak
    206  0000 ????				      LIST	OFF
    207  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    208  0000 ????			   EARLY_LOCATION SET	*
    209  0000 ????				      ALIGN	256
    210  0000 ????				      IF	VERBOSE=1
    211  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    212  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    213  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    214  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    215  0000 ????				      ENDIF
    216  0000 ????				      ENDIF
    217  0000 ????				      LIST	ON
    218  0000 ????				      ENDM		; { string, size }
    219  0000 ????
    220  0000 ????
    221  0000 ????				      MAC	check_page_crossing
    222  0000 ????				      LIST	OFF
    223  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    224  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    225  0000 ????				      ENDIF
    226  0000 ????				      LIST	ON
    227  0000 ????				      ENDM
    228  0000 ????
    229  0000 ????				      MAC	checkpage
    230  0000 ????				      LIST	OFF
    231  0000 ????				      IF	>. != >{1}
    232  0000 ????				      ECHO	""
    233  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    234  0000 ????				      ECHO	""
    235  0000 ????				      ERR
    236  0000 ????				      ENDIF
    237  0000 ????				      LIST	ON
    238  0000 ????				      ENDM
    239  0000 ????
    240  0000 ????				      MAC	checkpagex
    241  0000 ????				      LIST	OFF
    242  0000 ????				      IF	>. != >{1}
    243  0000 ????				      ECHO	""
    244  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    245  0000 ????				      ECHO	{2}
    246  0000 ????				      ECHO	""
    247  0000 ????				      ERR
    248  0000 ????				      ENDIF
    249  0000 ????				      LIST	ON
    250  0000 ????				      ENDM
    251  0000 ????
    252  0000 ????						;---------------------------------------------------------------------------------------------------
    253  0000 ????
    254  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    255  0000 ????				      MAC	variable
    256  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    257  0000 ????			   {1}	      ds	{2}
    258  0000 ????				      ENDM		; {name, size}
    259  0000 ????
    260  0000 ????
    261  0000 ????						;---------------------------------------------------------------------------------------------------
    262  0000 ????
    263  0000 ????				      MAC	def
    264  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
    265  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
    266  0000 ????			   {1}			; entry point
    267  0000 ????			   TEMPORARY_VAR SET	Overlay
    268  0000 ????			   TEMPORARY_OFFSET SET	0
    269  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    270  0000 ????			   FUNCTION_NAME SET	{1}
    271  0000 ????				      ENDM		; name of subroutine
    272  0000 ????
    273  0000 ????
    274  0000 ????						;---------------------------------------------------------------------------------------------------
    275  0000 ????
    276  0000 ????				      MAC	allocate
    277  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    278  0000 ????				      DEF	{1}
    279  0000 ????				      ENDM
    280  0000 ????
    281  0000 ????						;---------------------------------------------------------------------------------------------------
    282  0000 ????
    283  0000 ????				      MAC	slot
    284  0000 ????				      IF	({1} < 0) || ({1} > 3)
    285  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
    286  0000 ????				      ERR
    287  0000 ????				      ENDIF
    288  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
    289  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
    290  0000 ????				      ENDM		; {1}
    291  0000 ????
    292  0000 ????
    293  0000 ????						;---------------------------------------------------------------------------------------------------
    294  0000 ????
    295  0000 ????				      MAC	negeval
    296  0000 ????
    297  0000 ????				      sec
    298  0000 ????				      lda	#0
    299  0000 ????				      sbc	Evaluation
    300  0000 ????				      sta	Evaluation
    301  0000 ????				      lda	#0
    302  0000 ????				      sbc	Evaluation+1
    303  0000 ????				      sta	Evaluation+1
    304  0000 ????				      ENDM
    305  0000 ????
    306  0000 ????
    307  0000 ????				      MAC	swap
    308  0000 ????				      lda	sideToMove
    309  0000 ????				      eor	#SWAP_SIDE
    310  0000 ????				      sta	sideToMove
    311  0000 ????
    312  0000 ????						;NEGEVAL
    313  0000 ????				      ENDM
    314  0000 ????
    315  0000 ????
    316  0000 ????						;---------------------------------------------------------------------------------------------------
    317  0000 ????
    318  0000 ????			   TEMPORARY_OFFSET SET	0
    319  0000 ????
    320  0000 ????
    321  0000 ????				      MAC	vend
    322  0000 ????				      IFNCONST	{1}
    323  0000 ????				      ECHO	"Incorrect VEND label", {1}
    324  0000 ????				      ERR
    325  0000 ????				      ENDIF
    326  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    327  0000 ????				      ENDM		; {1}
    328  0000 ????
    329  0000 ????
    330  0000 ????				      MAC	refer
    331  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    332  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    333  0000 ????				      ENDIF
    334  0000 ????				      ENDM		; {1}
    335  0000 ????
    336  0000 ????
    337  0000 ????
    338  0000 ????						; Define a temporary variable for use in a subroutine
    339  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    340  0000 ????
    341  0000 ????				      MAC	var
    342  0000 ????			   {1}	      =	TEMPORARY_VAR
    343  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    344  0000 ????
    345  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    346  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    347  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    348  0000 ????				      ENDIF
    349  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    350  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    351  0000 ????				      ERR
    352  0000 ????				      ENDIF
    353  0000 ????				      LIST	ON
    354  0000 ????				      ENDM		; { name, size }
    355  0000 ????
    356  0000 ????
    357  0000 ????						;---------------------------------------------------------------------------------------------------
    358  0000 ????
    359  0000 ????				      MAC	tag
    360  0000 ????						; {0}
    361  0000 ????				      ENDM		; {ident/tag}
    362  0000 ????
    363  0000 ????						;---------------------------------------------------------------------------------------------------
    364  0000 ????
    365  0000 ????				      MAC	sta@ram
    366  0000 ????				      sta	[RAM]+{0}
    367  0000 ????				      ENDM		;{}
    368  0000 ????
    369  0000 ????				      MAC	stx@ram
    370  0000 ????				      stx	[RAM]+{0}
    371  0000 ????				      ENDM
    372  0000 ????
    373  0000 ????				      MAC	sty@ram
    374  0000 ????				      sty	[RAM]+{0}
    375  0000 ????				      ENDM
    376  0000 ????
    377  0000 ????				      MAC	sta@ply
    378  0000 ????				      sta	[RAM]+{0}
    379  0000 ????				      ENDM		;{}
    380  0000 ????
    381  0000 ????				      MAC	stx@ply
    382  0000 ????				      stx	[RAM]+{0}
    383  0000 ????				      ENDM
    384  0000 ????
    385  0000 ????				      MAC	sty@ply
    386  0000 ????				      sty	[RAM]+{0}
    387  0000 ????				      ENDM
    388  0000 ????
    389  0000 ????
    390  0000 ????				      MAC	lda@ram
    391  0000 ????				      lda	{0}
    392  0000 ????				      ENDM		;{}
    393  0000 ????
    394  0000 ????				      MAC	ldx@ram
    395  0000 ????				      ldx	{0}
    396  0000 ????				      ENDM		;{}
    397  0000 ????
    398  0000 ????				      MAC	ldy@ram
    399  0000 ????				      ldy	{0}
    400  0000 ????				      ENDM		;{}
    401  0000 ????
    402  0000 ????
    403  0000 ????				      MAC	lda@ply
    404  0000 ????				      lda	{0}
    405  0000 ????				      ENDM		;{}
    406  0000 ????
    407  0000 ????				      MAC	ldx@ply
    408  0000 ????				      ldx	{0}
    409  0000 ????				      ENDM		;{}
    410  0000 ????
    411  0000 ????				      MAC	ldy@ply
    412  0000 ????				      ldy	{0}
    413  0000 ????				      ENDM		;{}
    414  0000 ????
    415  0000 ????
    416  0000 ????				      MAC	adc@ply
    417  0000 ????				      adc	{0}
    418  0000 ????				      ENDM		;{}
    419  0000 ????
    420  0000 ????				      MAC	sbc@ply
    421  0000 ????				      sbc	{0}
    422  0000 ????				      ENDM		;{}
    423  0000 ????
    424  0000 ????				      MAC	cmp@ply
    425  0000 ????				      cmp	{0}
    426  0000 ????				      ENDM		;{}
    427  0000 ????
    428  0000 ????						;---------------------------------------------------------------------------------------------------
    429  0000 ????
    430  0000 ????				      MAC	newrambank
    431  0000 ????						; {1}	     bank name
    432  0000 ????						; {2}	     RAM bank number
    433  0000 ????
    434  0000 ????				      SEG.U	{1}
    435  0000 ????				      ORG	ORIGIN_RAM
    436  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    437  0000 ????			   _BANK_START SET	*
    438  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
    439  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    440  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    441  0000 ????				      ENDM		; bank name
    442  0000 ????
    443  0000 ????						;---------------------------------------------------------------------------------------------------
    444  0000 ????
    445  0000 ????				      MAC	resync
    446  0000 ????						; resync screen, X and Y == 0 afterwards
    447  0000 ????				      lda	#%10	; make sure VBLANK is ON
    448  0000 ????				      sta	VBLANK
    449  0000 ????
    450  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    451  0000 ????			   .loopResync
    452  0000 ????				      VERTICAL_SYNC
    453  0000 ????
    454  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    455  0000 ????				      lda	Platform
    456  0000 ????				      eor	#PAL_50	; PAL-50?
    457  0000 ????				      bne	.ntsc
    458  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    459  0000 ????			   .ntsc
    460  0000 ????			   .loopWait
    461  0000 ????				      sta	WSYNC
    462  0000 ????				      sta	WSYNC
    463  0000 ????				      dey
    464  0000 ????				      bne	.loopWait
    465  0000 ????				      dex
    466  0000 ????				      bne	.loopResync
    467  0000 ????				      ENDM
    468  0000 ????
    469  0000 ????				      MAC	set_platform
    470  0000 ????						; 00 = NTSC
    471  0000 ????						; 01 = NTSC
    472  0000 ????						; 10 = PAL-50
    473  0000 ????						; 11 = PAL-60
    474  0000 ????				      lda	SWCHB
    475  0000 ????				      rol
    476  0000 ????				      rol
    477  0000 ????				      rol
    478  0000 ????				      and	#%11
    479  0000 ????				      eor	#PAL
    480  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    481  0000 ????				      ENDM
    482  0000 ????
    483  0000 ????
    484  0000 ????						;---------------------------------------------------------------------------------------------------
    485  0000 ????
    486  0000 ????						;    MAC JSROM_SAFE ; {routine}
    487  0000 ????						;    ; Saves bank of routine to variable for later restore.
    488  0000 ????						;    ; Switches to the bank and does a JSR to the routine.
    489  0000 ????
    490  0000 ????						;		  lda #BANK_{1}
    491  0000 ????						;		  sta savedBank
    492  0000 ????						;		  sta SET_BANK
    493  0000 ????						;		  jsr {1}
    494  0000 ????						;    ENDM
    495  0000 ????
    496  0000 ????
    497  0000 ????						;    MAC JSROM ; {routine}
    498  0000 ????
    499  0000 ????						;		  lda #BANK_{1}
    500  0000 ????						;		  sta SET_BANK
    501  0000 ????						;		  jsr {1}
    502  0000 ????						;    ENDM
    503  0000 ????
    504  0000 ????
    505  0000 ????						;    MAC JSRAM
    506  0000 ????						;		  lda #BANK_{1}
    507  0000 ????						;		  sta SET_BANK_RAM
    508  0000 ????						;		  jsr {1}
    509  0000 ????						;    ENDM
    510  0000 ????
    511  0000 ????
    512  0000 ????
    513  0000 ????				      MAC	timecheck
    514  0000 ????				      lda	INTIM
    515  0000 ????				      cmp	#SPEEDOF_{1}
    516  0000 ????				      bcc	{2}
    517  0000 ????				      ENDM		; {ident}, {branch if out of time}
    518  0000 ????
    519  0000 ????
    520  0000 ????				      MAC	timing
    521  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    522  0000 ????				      ENDM		; {label}, {cycles}
    523  0000 ????
    524  0000 ????
    525  0000 ????						;---------------------------------------------------------------------------------------------------
    526  0000 ????
    527  0000 ????						; Failsafe call of function in another bank
    528  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    529  0000 ????
    530  0000 ????				      MAC	call
    531  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    532  0000 ????				      ECHO	"ERROR: Incompatible call to function requiring same slot..."
    533  0000 ????				      ECHO	"Cannot switch bank in use for", {0}
    534  0000 ????				      ERR
    535  0000 ????				      ENDIF
    536  0000 ????				      lda	#BANK_{1}
    537  0000 ????				      sta	SET_BANK
    538  0000 ????				      jsr	{1}
    539  0000 ????				      ENDM		; function name
    540  0000 ????
    541  0000 ????
    542  0000 ????
    543  0000 ????						;---------------------------------------------------------------------------------------------------
    544  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00ff ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   aiState    ds	1	; state
     24 U008c		       00	   aiFlashDelay ds	1
     25 U008d
     26 U008d		       00	   aiMoveIndex ds	1
     27 U008e
     28 U008e		       00	   aiFlashPhase ds	1
     29 U008f
     30 U008f		       00 00	   Evaluation ds	2	; tracks value of the board position
     31 U0091
     32 U0091		       00	   currentPiece ds	1
     33 U0092		       00	   currentSquare ds	1
     34 U0093		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     35 U0094		       00	   currentPly ds	1
     36 U0095
     37 U0095		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     38 U0096		       00	   fromPiece  ds	1
     39 U0097		       00	   lastPiece  ds	1
     40 U0098		       00	   previousPiece ds	1
     41 U0099
     42 U0099		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U009a		       00 00	   speech_addr ds	2
     44 U009c							;bg				  ds 1
     45 U009c
     46 U009c		       00	   capture    ds	1
     47 U009d
     48 U009d					      IF	DIAGNOSTICS
     49 U009d		       00 00 00    positionCount ds	3
     50 U00a0					      ENDIF
     51 U00a0
     52 U00a0							;maxPly			  ds 1
     53 U00a0		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     54 U00a1		       00	   protecting ds	1
     55 U00a2		       00	   randomness ds	1
     56 U00a3		       00 00	   __psb      ds	2
     57 U00a5
     58 U00a5		       00 00	   vkSquare   ds	2	; current move's king traversal squares during castling
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a7					      include	"overlays.asm"
      1 U00a7							; Chess
      2 U00a7							; Atari 2600 Chess display system
      3 U00a7							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a7							; andrew@taswegian.com
      5 U00a7
      6 U00a7							;---------------------------------------------------------------------------------------------------
      7 U00a7							; OVERLAYS!
      8 U00a7							; These variables are overlays, and should be managed with care
      9 U00a7							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a7							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a7							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a7							; overlay #2
     13 U00a7
     14 U00a7							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a7
     16 U00a7							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a7							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a7							;---------------------------------------------------------------------------------------------------
     19 U00a7
     20 U00a7					      MAC	overlay
     21 U00a7				   OVERLAY_NAME SET	{1}
     22 U00a7					      SEG.U	OVERLAY_{1}
     23 U00a7					      org	Overlay
     24 U00a7					      ENDM		; {name}
     25 U00a7
     26 U00a7							;---------------------------------------------------------------------------------------------------
     27 U00a7
     28 U00a7					      MAC	validate_overlay
     29 U00a7					      LIST	OFF
     30 U00a7				   OVERLAY_DELTA SET	* - Overlay
     31 U00a7					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a7					      ENDIF
     34 U00a7					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a7					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a7					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a7					      ERR
     38 U00a7					      ENDIF
     39 U00a7					      LIST	ON
     40 U00a7					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a7					      ENDM
     42 U00a7
     43 U00a7							;---------------------------------------------------------------------------------------------------
     44 U00a7
     45 U00a7				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a7
     48 U00a7
     49 U00a7							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a7							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a7							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a7							; (especially the latter ones) are only used in rare occasions.
     53 U00a7
     54 U00a7							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a7							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a7
      0 U00a7					      DEF	Overlay
      1 U00a7				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a7				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a7				   Overlay
      4 U00a7				   TEMPORARY_VAR SET	Overlay
      5 U00a7				   TEMPORARY_OFFSET SET	0
      6 U00a7				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a7				   FUNCTION_NAME SET	Overlay
     58 U00a7		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00f3				   END_OF_OVERLAY
     60 U00f3
     61 U00f3							;---------------------------------------------------------------------------------------------------
     62 U00f3							; And now... the overlays....
     63 U00f3
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00f3					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00f3
     66 U00f3							;---------------------------------------------------------------------------------------------------
     67 U00f3
     68 U00f3		       00 a7	   __pieceShapeBuffer =	Overlay	; size = PIECE_SHAPE_SIZE
     69 U00f3
     70 U00f3							;---------------------------------------------------------------------------------------------------
     71 U00f3
     72 U00f3
     73 U00f3					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     74 U00f3					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $0
     75 U00f3					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     76 U00f3
     77 U00f3							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00f3					      include	"stack.asm"
      1 U00f3							; Chess
      2 U00f3							; Atari 2600 Chess display system
      3 U00f3							; Copyright (c) 2019-2020 Andrew Davie
      4 U00f3							; andrew@taswegian.com
      5 U00f3
      6 U00f3
      7 U00f3		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00f3
      9 U00f3		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00ff
     11 U00ff							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00ff							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00ff							;  but since overlay is not generally stressed during alphabeta, we're good.
     14 U00ff
     15 U00ff							; Ensure there isn't any stomping of stack/overlay excess usage
     16 U00ff
 Overlay boundary:  $a7
     17 U00ff					      ECHO	"Overlay boundary: ", Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE
 Stack boundary:  $ed
     18 U00ff					      ECHO	"Stack boundary: ", $FF- PLY_BANKS*2
     19 U00ff
     20 U00ff				  -	      IF	($FF - PLY_BANKS*2) < (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     21 U00ff				  -	      ECHO	"ERROR: Not enough reserved space for stack with given #PLY"
     22 U00ff				  -	      ERR
     23 U00ff					      ENDIF
     24 U00ff
     25 U00ff
------- FILE ./chess.asm
    548 U00ff
 FREE BYTES IN ZERO PAGE =  $0
    549 U00ff					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    550 U00ff				  -	      IF	* > $FF
    551 U00ff				  -	      ERR	"Zero Page overflow!"
    552 U00ff					      ENDIF
    553 U00ff
    554 U00ff							;------------------------------------------------------------------------------
    555 U00ff							;##############################################################################
    556 U00ff							;------------------------------------------------------------------------------
    557 U00ff
    558 U00ff							; NOW THE VERY INTERESTING '3E' RAM BANKS
    559 U00ff							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    560 U00ff							; IN A 1K MEMORY SPACE
    561 U00ff
      0 U00ff					      SLOT	0
      1 U00ff				  -	      IF	(0 < 0) || (0 > 3)
      2 U00ff				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U00ff				  -	      ERR
      4 U00ff					      ENDIF
      5 U00ff				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U00ff				   _BANK_SLOT SET	0 * 64
      0 U00ff					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00ff
      2 U00ff
      3 U00ff
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0000				   _BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0400				   _BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0800				   _BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0c00				   _BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1000				   _BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1400				   _BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1800				   _BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1c00				   _BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    566 U1c00					      REPEND
    567 U1c00
    568 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    569 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    570 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    571 U1c00
    572 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    573 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    574 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    575 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    576 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    577 U1c00
    578 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    579 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    580 U1c00
    581 U1c00							;---------------------------------------------------------------------------------------------------
    582 U1c00
    583 U1c00
    584 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    585 U1c00
    586 U1c00					      MAC	next_random
    587 U1c00					      lda	rnd
    588 U1c00					      lsr
    589 U1c00					      bcc	.skipEOR
    590 U1c00					      eor	#RND_EOR_VAL
    591 U1c00				   .skipEOR   sta	rnd
    592 U1c00					      ENDM
    593 U1c00
    594 U1c00							;--------------------------------------------------------------------------------
    595 U1c00
    596 U1c00					      MAC	phase
    597 U1c00					      lda	#{1}
    598 U1c00					      sta	aiState
    599 U1c00					      ENDM		;#
    600 U1c00
    601 U1c00
    602 U1c00							;--------------------------------------------------------------------------------
    603 U1c00
    604 U1c00					      MAC	common_vars
    605 U1c00
    606 U1c00					      VAR	__thinkbar, 1
    607 U1c00					      VAR	__toggle, 1
    608 U1c00
    609 U1c00					      VAR	__bestMove, 1
    610 U1c00					      VAR	__alpha, 2
    611 U1c00					      VAR	__beta, 2
    612 U1c00					      VAR	__negaMax, 2
    613 U1c00					      VAR	__value, 2
    614 U1c00
    615 U1c00					      VAR	__quiesceCapOnly, 1
    616 U1c00
    617 U1c00					      VAR	__originalPiece, 1
    618 U1c00					      VAR	__capturedPiece, 1
    619 U1c00
    620 U1c00					      ENDM
    621 U1c00							;---------------------------------------------------------------------------------------------------
    622 U1c00
------- FILE BANK_FIRST@0.asm LEVEL 2 PASS 4
      0 U1c00					      include	"BANK_FIRST@0.asm"	; MUST be first in ROM - contains reset vectors
      1 U1c00							; Chess
      2 U1c00							; Copyright (c) 2019-2020 Andrew Davie
      3 U1c00							; andrew@taswegian.com
      4 U1c00
      5 U1c00
      6 U1c00							; SLOT0 - screen draw, state machine dispatcher
      7 U1c00							; SLOT1 - anything
      8 U1c00							; SLOT2 - moves/ply
      9 U1c00							; SLOT3 - board
     10 U1c00
     11 U1c00
     12 U1c00
     13 U1c00
     14 U1c00
     15 U1c00
      0 U1c00					      SLOT	0
      1 U1c00				  -	      IF	(0 < 0) || (0 > 3)
      2 U1c00				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U1c00				  -	      ERR
      4 U1c00					      ENDIF
      5 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U1c00				   _BANK_SLOT SET	0 * 64
     17 U1c00
     18 U1c00							;---------------------------------------------------------------------------------------------------
     19 U1c00							;#########################################  FIXED BANK  ############################################
     20 U1c00							;---------------------------------------------------------------------------------------------------
     21 U1c00
     22 U1c00				   _ORIGIN    SET	_FIRST_BANK
     23 U1c00
      0 U1c00					      NEWBANK	THE_FIRST_BANK
      1  0388 ????				      SEG	THE_FIRST_BANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   THE_FIRST_BANK_START SET	*
      6  0000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0000				   THE_FIRST_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + 1024
     25  0000					      RORG	$f000
     26  0000
     27  0000							;---------------------------------------------------------------------------------------------------
     28  0000
      0  0000					      DEF	StartupBankReset
      1  0000				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0000				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0000				   StartupBankReset
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartupBankReset
     30  0000					      SUBROUTINE
     31  0000
      0  0000					      VEND	StartupBankReset
      1  0000				  -	      IFNCONST	StartupBankReset
      2  0000				  -	      ECHO	"Incorrect VEND label", StartupBankReset
      3  0000				  -	      ERR
      4  0000					      ENDIF
      5  0000		       00 a7	   VAREND_StartupBankReset =	TEMPORARY_VAR
     33  0000
     34  0000							; On startup, 3E+ switches banks 0 and 3 to the 1st ROM bank (1K), from which the reset
     35  0000							; vector is obtained from bank 0 (+$FFC). Chess3E+ (maybe) will leave this bank (3) alone
     36  0000							; so that a system reset will always have the reset vectors available at FFFC, where expected
     37  0000
     38  0000		       a2 ff		      ldx	#$FF
     39  0002		       9a		      txs
     40  0003
      0  0003					      CALL	CartInit
      1  0003				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0003				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0003				  -	      ECHO	"Cannot switch bank in use for", CartInit
      4  0003				  -	      ERR
      5  0003					      ENDIF
      6  0003		       a9 41		      lda	#BANK_CartInit
      7  0005		       85 3f		      sta	SET_BANK
      8  0007		       20 00 f4 	      jsr	CartInit
      0  000a					      CALL	SetupBanks
      1  000a				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  000a				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  000a				  -	      ECHO	"Cannot switch bank in use for", SetupBanks
      4  000a				  -	      ERR
      5  000a					      ENDIF
      6  000a		       a9 41		      lda	#BANK_SetupBanks
      7  000c		       85 3f		      sta	SET_BANK
      8  000e		       20 28 f4 	      jsr	SetupBanks
      0  0011					      CALL	InitialisePieceSquares
      1  0011				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  0011				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0011				  -	      ECHO	"Cannot switch bank in use for", InitialisePieceSquares
      4  0011				  -	      ERR
      5  0011					      ENDIF
      6  0011		       a9 41		      lda	#BANK_InitialisePieceSquares
      7  0013		       85 3f		      sta	SET_BANK
      8  0015		       20 88 f4 	      jsr	InitialisePieceSquares
     44  0018		       20 35 f2 	      jsr	ListPlayerMoves	;@0
     45  001b
     46  001b
     47  001b				   .StartFrame
     48  001b
     49  001b
     50  001b							; START OF FRAME
     51  001b
     52  001b		       a9 0e		      lda	#%1110	; VSYNC ON
     53  001d		       85 42	   .loopVSync3 sta	WSYNC
     54  001f		       85 40		      sta	VSYNC
     55  0021		       4a		      lsr
     56  0022		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     57  0024
     58  0024		       85 41		      sta	VBLANK
     59  0026
     60  0026		       a0 2e		      ldy	#TIME_PART_1
     61  0028		       8c 96 02 	      sty	TIM64T
     62  002b
     63  002b							; LOTS OF PROCESSING TIME - USE IT
     64  002b
     65  002b
     66  002b
     67  002b		       20 74 f1 	      jsr	AiStateMachine
     68  002e
     69  002e				  -	      IF	ASSERTS
     70  002e				  -			; Catch timer expired already
     71  002e				  -			;		      bit TIMINT
     72  002e				  -			;.whoops	      bmi .whoops
     73  002e					      ENDIF
     74  002e
     75  002e
     76  002e		       2c 85 02    .wait      bit	TIMINT
     77  0031		       10 fb		      bpl	.wait
     78  0033
     79  0033
     80  0033							; START OF VISIBLE SCANLINES
     81  0033
     82  0033
      0  0033					      CALL	longD
      1  0033				  -	      IF	SLOT_longD == _BANK_SLOT
      2  0033				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0033				  -	      ECHO	"Cannot switch bank in use for", longD
      4  0033				  -	      ERR
      5  0033					      ENDIF
      6  0033		       a9 91		      lda	#BANK_longD
      7  0035		       85 3f		      sta	SET_BANK
      8  0037		       20 18 f8 	      jsr	longD
     84  003a
     85  003a
     86  003a		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     87  003c		       86 3e		      stx	SET_BANK_RAM
     88  003e		       20 03 f9 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     89  0041
      0  0041					      CALL	tidySc
      1  0041				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  0041				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0041				  -	      ECHO	"Cannot switch bank in use for", tidySc
      4  0041				  -	      ERR
      5  0041					      ENDIF
      6  0041		       a9 91		      lda	#BANK_tidySc
      7  0043		       85 3f		      sta	SET_BANK
      8  0045		       20 04 f8 	      jsr	tidySc
     91  0048
     92  0048		       20 74 f1 	      jsr	AiStateMachine
     93  004b
     94  004b		       ad 84 02 	      lda	INTIM
     95  004e		       c9 14		      cmp	#20
     96  0050		       90 20		      bcc	.notnow
     97  0052
     98  0052							;CALL GameSpeak
      0  0052					      CALL	PositionSprites
      1  0052				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  0052				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0052				  -	      ECHO	"Cannot switch bank in use for", PositionSprites
      4  0052				  -	      ERR
      5  0052					      ENDIF
      6  0052		       a9 47		      lda	#BANK_PositionSprites
      7  0054		       85 3f		      sta	SET_BANK
      8  0056		       20 00 f5 	      jsr	PositionSprites
    100  0059
    101  0059
    102  0059					      IF	1
    103  0059							; "draw" sprite shapes into row banks
    104  0059
    105  0059		       a2 07		      ldx	#7
    106  005b		       8a	   zapem      txa
    107  005c		       18		      clc
    108  005d		       69 80		      adc	#SLOT_DrawRow
    109  005f		       85 3e		      sta	SET_BANK_RAM
      0  0061					      CALL	WriteBlank	;@3
      1  0061				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  0061				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0061				  -	      ECHO	"Cannot switch bank in use for", WriteBlank
      4  0061				  -	      ERR
      5  0061					      ENDIF
      6  0061		       a9 c3		      lda	#BANK_WriteBlank
      7  0063		       85 3f		      sta	SET_BANK
      8  0065		       20 0b fc 	      jsr	WriteBlank
    111  0068		       ca		      dex
    112  0069		       10 f0		      bpl	zapem
    113  006b
      0  006b					      CALL	WriteCursor	;@3
      1  006b				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  006b				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  006b				  -	      ECHO	"Cannot switch bank in use for", WriteCursor
      4  006b				  -	      ERR
      5  006b					      ENDIF
      6  006b		       a9 c3		      lda	#BANK_WriteCursor
      7  006d		       85 3f		      sta	SET_BANK
      8  006f		       20 34 fc 	      jsr	WriteCursor
    115  0072					      ENDIF
    116  0072
    117  0072				   .notnow
    118  0072
    119  0072		       2c 85 02    .waitTime  bit	TIMINT
    120  0075		       10 fb		      bpl	.waitTime
    121  0077
    122  0077		       4c 1b f0 	      jmp	.StartFrame
    123  007a
    124  007a
    125  007a							;---------------------------------------------------------------------------------------------------
    126  007a
      0  007a					      DEF	ThinkBar
      1  007a				   SLOT_ThinkBar SET	_BANK_SLOT
      2  007a				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  007a				   ThinkBar
      4  007a				   TEMPORARY_VAR SET	Overlay
      5  007a				   TEMPORARY_OFFSET SET	0
      6  007a				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  007a				   FUNCTION_NAME SET	ThinkBar
    128  007a					      SUBROUTINE
    129  007a
      0  007a					      COMMON_VARS
      1  007a
      0  007a					      VAR	__thinkbar, 1
      1  007a		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__toggle, 1
      1  007a		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      4  007a
      0  007a					      VAR	__bestMove, 1
      1  007a		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__alpha, 2
      1  007a		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__beta, 2
      1  007a		       00 ac	   __beta     =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__negaMax, 2
      1  007a		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__value, 2
      1  007a		       00 b0	   __value    =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
     10  007a
      0  007a					      VAR	__quiesceCapOnly, 1
      1  007a		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
     12  007a
      0  007a					      VAR	__originalPiece, 1
      1  007a		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__capturedPiece, 1
      1  007a		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
     15  007a
      0  007a					      REFER	negaMax	;✅
      1  007a				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  007a				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  007a					      ENDIF
      0  007a					      REFER	quiesce	;✅
      1  007a				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  007a				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  007a					      ENDIF
      0  007a					      VEND	ThinkBar
      1  007a				  -	      IFNCONST	ThinkBar
      2  007a				  -	      ECHO	"Incorrect VEND label", ThinkBar
      3  007a				  -	      ERR
      4  007a					      ENDIF
      5  007a		       00 b5	   VAREND_ThinkBar =	TEMPORARY_VAR
    134  007a
    135  007a					      IF	DIAGNOSTICS
    136  007a
    137  007a		       e6 9d		      inc	positionCount
    138  007c		       d0 06		      bne	.p1
    139  007e		       e6 9e		      inc	positionCount+1
    140  0080		       d0 02		      bne	.p1
    141  0082		       e6 9f		      inc	positionCount+2
    142  0084				   .p1
    143  0084					      ENDIF
    144  0084
    145  0084							; The 'thinkbar' pattern...
    146  0084
    147  0084		       a9 00		      lda	#0
    148  0086		       a4 4c		      ldy	INPT4
    149  0088		       30 0f		      bmi	.doThink
    150  008a
    151  008a		       e6 a7		      inc	__thinkbar
    152  008c		       a5 a7		      lda	__thinkbar
    153  008e		       29 0f		      and	#15
    154  0090		       a8		      tay
    155  0091		       b9 9e f0 	      lda	TBcol,y
    156  0094		       85 48		      sta	COLUPF
    157  0096
    158  0096		       b9 ae f0 	      lda	SynapsePattern,y
    159  0099		       85 4f	   .doThink   sta	PF2
    160  009b		       85 4e		      sta	PF1
    161  009d		       60		      rts
    162  009e
    163  009e
    164  009e				   TBcol
    165  009e				   .TBC       SET	2
    166  009e					      REPEAT	16
    167  009e		       02		      .byte.b	.TBC
    168  009e				   .TBC       SET	.TBC + 16
    166  009e					      REPEND
    167  009f		       12		      .byte.b	.TBC
    168  009f				   .TBC       SET	.TBC + 16
    166  009f					      REPEND
    167  00a0		       22		      .byte.b	.TBC
    168  00a0				   .TBC       SET	.TBC + 16
    166  00a0					      REPEND
    167  00a1		       32		      .byte.b	.TBC
    168  00a1				   .TBC       SET	.TBC + 16
    166  00a1					      REPEND
    167  00a2		       42		      .byte.b	.TBC
    168  00a2				   .TBC       SET	.TBC + 16
    166  00a2					      REPEND
    167  00a3		       52		      .byte.b	.TBC
    168  00a3				   .TBC       SET	.TBC + 16
    166  00a3					      REPEND
    167  00a4		       62		      .byte.b	.TBC
    168  00a4				   .TBC       SET	.TBC + 16
    166  00a4					      REPEND
    167  00a5		       72		      .byte.b	.TBC
    168  00a5				   .TBC       SET	.TBC + 16
    166  00a5					      REPEND
    167  00a6		       82		      .byte.b	.TBC
    168  00a6				   .TBC       SET	.TBC + 16
    166  00a6					      REPEND
    167  00a7		       92		      .byte.b	.TBC
    168  00a7				   .TBC       SET	.TBC + 16
    166  00a7					      REPEND
    167  00a8		       a2		      .byte.b	.TBC
    168  00a8				   .TBC       SET	.TBC + 16
    166  00a8					      REPEND
    167  00a9		       b2		      .byte.b	.TBC
    168  00a9				   .TBC       SET	.TBC + 16
    166  00a9					      REPEND
    167  00aa		       c2		      .byte.b	.TBC
    168  00aa				   .TBC       SET	.TBC + 16
    166  00aa					      REPEND
    167  00ab		       d2		      .byte.b	.TBC
    168  00ab				   .TBC       SET	.TBC + 16
    166  00ab					      REPEND
    167  00ac		       e2		      .byte.b	.TBC
    168  00ac				   .TBC       SET	.TBC + 16
    166  00ac					      REPEND
    167  00ad		       f2		      .byte.b	.TBC
    168  00ad				   .TBC       SET	.TBC + 16
    169  00ae					      REPEND
    170  00ae
    171  00ae				   SynapsePattern
    172  00ae
    173  00ae		       c1		      .byte.b	%11000001
    174  00af		       60		      .byte.b	%01100000
    175  00b0		       30		      .byte.b	%00110000
    176  00b1		       18		      .byte.b	%00011000
    177  00b2		       0c		      .byte.b	%00001100
    178  00b3		       06		      .byte.b	%00000110
    179  00b4		       83		      .byte.b	%10000011
    180  00b5		       c1		      .byte.b	%11000001
    181  00b6
    182  00b6		       83		      .byte.b	%10000011
    183  00b7		       06		      .byte.b	%00000110
    184  00b8		       0c		      .byte.b	%00001100
    185  00b9		       18		      .byte.b	%00011000
    186  00ba		       30		      .byte.b	%00110000
    187  00bb		       60		      .byte.b	%01100000
    188  00bc		       c1		      .byte.b	%11000001
    189  00bd		       83		      .byte.b	%10000011
    190  00be
    191  00be
    192  00be							;---------------------------------------------------------------------------------------------------
    193  00be
      0  00be					      DEF	CopySinglePiece
      1  00be				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  00be				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  00be				   CopySinglePiece
      4  00be				   TEMPORARY_VAR SET	Overlay
      5  00be				   TEMPORARY_OFFSET SET	0
      6  00be				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  00be				   FUNCTION_NAME SET	CopySinglePiece
    195  00be					      SUBROUTINE
    196  00be
      0  00be					      TIMING	COPYSINGLEPIECE, (2600)
      1  00be		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    198  00be
      0  00be					      REFER	showMoveCaptures	;✅
      1  00be					      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  00be				   TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  00be					      ENDIF
      0  00be					      REFER	aiDrawEntireBoard	;✅
      1  00be				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  00be					      ENDIF
      0  00be					      REFER	aiDrawPart2	;✅
      1  00be				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  00be					      ENDIF
      0  00be					      REFER	aiMarchB	;✅
      1  00be				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  00be					      ENDIF
      0  00be					      REFER	aiFlashComputerMove	;✅
      1  00be				  -	      IF	VAREND_aiFlashComputerMove > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiFlashComputerMove
      3  00be					      ENDIF
      0  00be					      REFER	aiSelectDestinationSquare	;✅
      1  00be				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  00be					      ENDIF
      0  00be					      REFER	aiMarchA2	;✅
      1  00be				  -	      IF	VAREND_aiMarchA2 > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiMarchA2
      3  00be					      ENDIF
      0  00be					      REFER	aiMarchB2	;✅
      1  00be				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  00be					      ENDIF
      0  00be					      REFER	aiWriteStartPieceBlank	;✅
      1  00be				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  00be					      ENDIF
      0  00be					      REFER	aiChoosePromotePiece	;✅
      1  00be				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  00be					      ENDIF
      0  00be					      REFER	aiMarchToTargetB	;✅
      1  00be				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  00be					      ENDIF
      0  00be					      REFER	aiPromotePawnStart	;✅
      1  00be				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  00be					      ENDIF
      0  00be					      REFER	aiFinalFlash	;✅
      1  00be				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  00be					      ENDIF
    212  00be
    213  00be
      0  00be					      VEND	CopySinglePiece
      1  00be				  -	      IFNCONST	CopySinglePiece
      2  00be				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  00be				  -	      ERR
      4  00be					      ENDIF
      5  00be		       00 ac	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    215  00be
    216  00be							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    217  00be							; ALSO CAN'T USE IN THIS ROUTINE
    218  00be							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    219  00be							; @2150 max
    220  00be							; = 33 TIM64T
    221  00be
      0  00be					      CALL	CopySetup	;@2
      1  00be				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  00be				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  00be				  -	      ECHO	"Cannot switch bank in use for", CopySetup
      4  00be				  -	      ERR
      5  00be					      ENDIF
      6  00be		       a9 91		      lda	#BANK_CopySetup
      7  00c0		       85 3f		      sta	SET_BANK
      8  00c2		       20 6a f8 	      jsr	CopySetup
    223  00c5
    224  00c5
      0  00c5					      DEF	InterceptMarkerCopy
      1  00c5				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  00c5				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  00c5				   InterceptMarkerCopy
      4  00c5				   TEMPORARY_VAR SET	Overlay
      5  00c5				   TEMPORARY_OFFSET SET	0
      6  00c5				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  00c5				   FUNCTION_NAME SET	InterceptMarkerCopy
    226  00c5					      SUBROUTINE
    227  00c5
      0  00c5					      REFER	CopySinglePiece	;✅
      1  00c5					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  00c5				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  00c5					      ENDIF
      0  00c5					      REFER	showPromoteOptions	;✅
      1  00c5				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  00c5				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  00c5					      ENDIF
      0  00c5					      REFER	showMoveOptions	;✅
      1  00c5				  -	      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  00c5				  -TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  00c5					      ENDIF
      0  00c5					      VEND	InterceptMarkerCopy
      1  00c5				  -	      IFNCONST	InterceptMarkerCopy
      2  00c5				  -	      ECHO	"Incorrect VEND label", InterceptMarkerCopy
      3  00c5				  -	      ERR
      4  00c5					      ENDIF
      5  00c5		       00 ac	   VAREND_InterceptMarkerCopy =	TEMPORARY_VAR
    232  00c5
    233  00c5							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    234  00c5							; y = piece index
    235  00c5
    236  00c5		       a9 91		      lda	#BANK_PIECE_VECTOR_BANK
    237  00c7		       85 3f		      sta	SET_BANK	;@2
    238  00c9
    239  00c9		       b9 c5 f9 	      lda	PIECE_VECTOR_LO,y
    240  00cc		       85 a3		      sta	__psb
    241  00ce		       b9 55 fa 	      lda	PIECE_VECTOR_HI,y
    242  00d1		       85 a4		      sta	__psb+1
    243  00d3		       b9 e5 fa 	      lda	PIECE_VECTOR_BANK,y
    244  00d6		       85 3f		      sta	SET_BANK	;@2
    245  00d8
    246  00d8		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    247  00da		       b1 a3	   .copy      lda	(__psb),y
    248  00dc		       99 a7 00 	      sta	__pieceShapeBuffer,y
    249  00df		       88		      dey
    250  00e0		       10 f8		      bpl	.copy
    251  00e2
    252  00e2		       a5 80		      lda	squareToDraw
    253  00e4		       38		      sec
    254  00e5		       a2 0a		      ldx	#10
    255  00e7		       e9 0a	   .sub10     sbc	#10
    256  00e9		       ca		      dex
    257  00ea		       b0 fb		      bcs	.sub10
    258  00ec
    259  00ec		       69 08		      adc	#8
    260  00ee		       c9 04		      cmp	#4	; CS = right side of screen
    261  00f0
    262  00f0		       8a		      txa
    263  00f1		       09 80		      ora	#[SLOT2]
    264  00f3		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    265  00f5
    266  00f5		       20 24 f3 	      jsr	CopyPieceToRowBitmap	;@3
    267  00f8		       60		      rts
    268  00f9
    269  00f9
    270  00f9							;---------------------------------------------------------------------------------------------------
    271  00f9
    272  00f9				   P	      SET	0
    273  00f9					      MAC	ain
    274  00f9				   AI_{1}     SET	P
    275  00f9				   P	      SET	P+1
    276  00f9					      ENDM
    277  00f9
    278  00f9					      MAC	lo
    279  00f9					      .byte	<ai{1}
    280  00f9					      ENDM
    281  00f9
    282  00f9					      MAC	hi
    283  00f9					      .byte	>ai{1}
    284  00f9					      ENDM
    285  00f9
    286  00f9					      MAC	bk
    287  00f9					      .byte	BANK_ai{1}
    288  00f9					      ENDM
    289  00f9
    290  00f9
    291  00f9		       00 28	   ONCEPERFRAME =	40
    292  00f9
    293  00f9					      MAC	tabdef
    294  00f9
    295  00f9					      {1}	FlashComputerMove	; 0
    296  00f9					      {1}	BeginSelectMovePhase	; 1
    297  00f9					      {1}	SelectStartSquare	; 2
    298  00f9					      {1}	StartSquareSelected	; 3
    299  00f9					      {1}	DrawMoves	; 4
    300  00f9					      {1}	ShowMoveCaptures	; 5
    301  00f9					      {1}	SlowFlash	; 6
    302  00f9					      {1}	UnDrawTargetSquares	; 7
    303  00f9					      {1}	SelectDestinationSquare	; 8
    304  00f9					      {1}	Quiescent	; 9
    305  00f9					      {1}	ReselectDebounce	; 10
    306  00f9					      {1}	StartMoveGen	; 11
    307  00f9					      {1}	StepMoveGen	; 12
    308  00f9					      {1}	StartClearBoard	; 13
    309  00f9					      {1}	ClearEachRow	; 14
    310  00f9					      {1}	DrawEntireBoard	; 15
    311  00f9					      {1}	DrawPart2	; 16
    312  00f9					      {1}	DrawPart3	; 17
    313  00f9					      {1}	GenerateMoves	; 18
    314  00f9					      {1}	ComputerMove	; 19
    315  00f9					      {1}	MoveIsSelected	; 20
    316  00f9					      {1}	WriteStartPieceBlank	; 21
    317  00f9					      {1}	MarchToTargetA	; 22
    318  00f9					      {1}	MarchA2	; 23
    319  00f9					      {1}	MarchB	; 24
    320  00f9					      {1}	MarchToTargetB	; 25
    321  00f9					      {1}	MarchB2	; 26
    322  00f9					      {1}	FinalFlash	; 27
    323  00f9					      {1}	SpecialMoveFixup	; 28
    324  00f9					      {1}	InCheckBackup	; 29
    325  00f9					      {1}	InCheckDelay	; 30
    326  00f9					      {1}	PromotePawnStart	; 31
    327  00f9					      {1}	RollPromotionPiece	; 32
    328  00f9					      {1}	ChoosePromotePiece	; 33
    329  00f9					      {1}	ChooseDebounce	; 34
    330  00f9					      {1}	CheckMate	; 35
    331  00f9					      {1}	Draw	; 36
    332  00f9					      {1}	DelayAfterMove	; 37
    333  00f9					      {1}	DelayAfterMove2	; 38
    334  00f9					      {1}	DelayAfterPlaced	; 39
    335  00f9					      {1}	DelayAfterPlaced2	; 40
    336  00f9
    337  00f9					      ENDM		; {1} = macro to use
    338  00f9
      0  00f9					      TABDEF	AIN
      1  00f9
      0  00f9					      AIN	FlashComputerMove
      1  00f9				   AI_FlashComputerMove SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	BeginSelectMovePhase
      1  00f9				   AI_BeginSelectMovePhase SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	SelectStartSquare
      1  00f9				   AI_SelectStartSquare SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	StartSquareSelected
      1  00f9				   AI_StartSquareSelected SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DrawMoves
      1  00f9				   AI_DrawMoves SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ShowMoveCaptures
      1  00f9				   AI_ShowMoveCaptures SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	SlowFlash
      1  00f9				   AI_SlowFlash SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	UnDrawTargetSquares
      1  00f9				   AI_UnDrawTargetSquares SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	SelectDestinationSquare
      1  00f9				   AI_SelectDestinationSquare SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	Quiescent
      1  00f9				   AI_Quiescent SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ReselectDebounce
      1  00f9				   AI_ReselectDebounce SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	StartMoveGen
      1  00f9				   AI_StartMoveGen SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	StepMoveGen
      1  00f9				   AI_StepMoveGen SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	StartClearBoard
      1  00f9				   AI_StartClearBoard SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ClearEachRow
      1  00f9				   AI_ClearEachRow SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DrawEntireBoard
      1  00f9				   AI_DrawEntireBoard SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DrawPart2
      1  00f9				   AI_DrawPart2 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DrawPart3
      1  00f9				   AI_DrawPart3 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	GenerateMoves
      1  00f9				   AI_GenerateMoves SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ComputerMove
      1  00f9				   AI_ComputerMove SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MoveIsSelected
      1  00f9				   AI_MoveIsSelected SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	WriteStartPieceBlank
      1  00f9				   AI_WriteStartPieceBlank SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchToTargetA
      1  00f9				   AI_MarchToTargetA SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchA2
      1  00f9				   AI_MarchA2 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchB
      1  00f9				   AI_MarchB  SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchToTargetB
      1  00f9				   AI_MarchToTargetB SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchB2
      1  00f9				   AI_MarchB2 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	FinalFlash
      1  00f9				   AI_FinalFlash SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	SpecialMoveFixup
      1  00f9				   AI_SpecialMoveFixup SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	InCheckBackup
      1  00f9				   AI_InCheckBackup SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	InCheckDelay
      1  00f9				   AI_InCheckDelay SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	PromotePawnStart
      1  00f9				   AI_PromotePawnStart SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	RollPromotionPiece
      1  00f9				   AI_RollPromotionPiece SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ChoosePromotePiece
      1  00f9				   AI_ChoosePromotePiece SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ChooseDebounce
      1  00f9				   AI_ChooseDebounce SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	CheckMate
      1  00f9				   AI_CheckMate SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	Draw
      1  00f9				   AI_Draw    SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DelayAfterMove
      1  00f9				   AI_DelayAfterMove SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DelayAfterMove2
      1  00f9				   AI_DelayAfterMove2 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DelayAfterPlaced
      1  00f9				   AI_DelayAfterPlaced SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DelayAfterPlaced2
      1  00f9				   AI_DelayAfterPlaced2 SET	P
      2  00f9				   P	      SET	P+1
     43  00f9
    340  00f9
      0  00f9					      DEF	AiVectorLO
      1  00f9				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  00f9				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  00f9				   AiVectorLO
      4  00f9				   TEMPORARY_VAR SET	Overlay
      5  00f9				   TEMPORARY_OFFSET SET	0
      6  00f9				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  00f9				   FUNCTION_NAME SET	AiVectorLO
      0  00f9					      TABDEF	LO
      1  00f9
      0  00f9					      LO	FlashComputerMove
      1  00f9		       3c		      .byte.b	<aiFlashComputerMove
      0  00fa					      LO	BeginSelectMovePhase
      1  00fa		       1d		      .byte.b	<aiBeginSelectMovePhase
      0  00fb					      LO	SelectStartSquare
      1  00fb		       64		      .byte.b	<aiSelectStartSquare
      0  00fc					      LO	StartSquareSelected
      1  00fc		       b4		      .byte.b	<aiStartSquareSelected
      0  00fd					      LO	DrawMoves
      1  00fd		       e4		      .byte.b	<aiDrawMoves
      0  00fe					      LO	ShowMoveCaptures
      1  00fe		       d0		      .byte.b	<aiShowMoveCaptures
      0  00ff					      LO	SlowFlash
      1  00ff		       f2		      .byte.b	<aiSlowFlash
      0  0100					      LO	UnDrawTargetSquares
      1  0100		       aa		      .byte.b	<aiUnDrawTargetSquares
      0  0101					      LO	SelectDestinationSquare
      1  0101		       49		      .byte.b	<aiSelectDestinationSquare
      0  0102					      LO	Quiescent
      1  0102		       b4		      .byte.b	<aiQuiescent
      0  0103					      LO	ReselectDebounce
      1  0103		       14		      .byte.b	<aiReselectDebounce
      0  0104					      LO	StartMoveGen
      1  0104		       00		      .byte.b	<aiStartMoveGen
      0  0105					      LO	StepMoveGen
      1  0105		       9f		      .byte.b	<aiStepMoveGen
      0  0106					      LO	StartClearBoard
      1  0106		       2c		      .byte.b	<aiStartClearBoard
      0  0107					      LO	ClearEachRow
      1  0107		       39		      .byte.b	<aiClearEachRow
      0  0108					      LO	DrawEntireBoard
      1  0108		       49		      .byte.b	<aiDrawEntireBoard
      0  0109					      LO	DrawPart2
      1  0109		       7d		      .byte.b	<aiDrawPart2
      0  010a					      LO	DrawPart3
      1  010a		       80		      .byte.b	<aiDrawPart3
      0  010b					      LO	GenerateMoves
      1  010b		       8d		      .byte.b	<aiGenerateMoves
      0  010c					      LO	ComputerMove
      1  010c		       00		      .byte.b	<aiComputerMove
      0  010d					      LO	MoveIsSelected
      1  010d		       46		      .byte.b	<aiMoveIsSelected
      0  010e					      LO	WriteStartPieceBlank
      1  010e		       cb		      .byte.b	<aiWriteStartPieceBlank
      0  010f					      LO	MarchToTargetA
      1  010f		       38		      .byte.b	<aiMarchToTargetA
      0  0110					      LO	MarchA2
      1  0110		       72		      .byte.b	<aiMarchA2
      0  0111					      LO	MarchB
      1  0111		       9a		      .byte.b	<aiMarchB
      0  0112					      LO	MarchToTargetB
      1  0112		       47		      .byte.b	<aiMarchToTargetB
      0  0113					      LO	MarchB2
      1  0113		       9f		      .byte.b	<aiMarchB2
      0  0114					      LO	FinalFlash
      1  0114		       92		      .byte.b	<aiFinalFlash
      0  0115					      LO	SpecialMoveFixup
      1  0115		       18		      .byte.b	<aiSpecialMoveFixup
      0  0116					      LO	InCheckBackup
      1  0116		       05		      .byte.b	<aiInCheckBackup
      0  0117					      LO	InCheckDelay
      1  0117		       10		      .byte.b	<aiInCheckDelay
      0  0118					      LO	PromotePawnStart
      1  0118		       69		      .byte.b	<aiPromotePawnStart
      0  0119					      LO	RollPromotionPiece
      1  0119		       a2		      .byte.b	<aiRollPromotionPiece
      0  011a					      LO	ChoosePromotePiece
      1  011a		       f5		      .byte.b	<aiChoosePromotePiece
      0  011b					      LO	ChooseDebounce
      1  011b		       00		      .byte.b	<aiChooseDebounce
      0  011c					      LO	CheckMate
      1  011c		       af		      .byte.b	<aiCheckMate
      0  011d					      LO	Draw
      1  011d		       aa		      .byte.b	<aiDraw
      0  011e					      LO	DelayAfterMove
      1  011e		       1d		      .byte.b	<aiDelayAfterMove
      0  011f					      LO	DelayAfterMove2
      1  011f		       26		      .byte.b	<aiDelayAfterMove2
      0  0120					      LO	DelayAfterPlaced
      1  0120		       2f		      .byte.b	<aiDelayAfterPlaced
      0  0121					      LO	DelayAfterPlaced2
      1  0121		       3e		      .byte.b	<aiDelayAfterPlaced2
     43  0122
    343  0122
      0  0122					      DEF	AiVectorHI
      1  0122				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  0122				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  0122				   AiVectorHI
      4  0122				   TEMPORARY_VAR SET	Overlay
      5  0122				   TEMPORARY_OFFSET SET	0
      6  0122				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  0122				   FUNCTION_NAME SET	AiVectorHI
      0  0122					      TABDEF	HI
      1  0122
      0  0122					      HI	FlashComputerMove
      1  0122		       f4		      .byte.b	>aiFlashComputerMove
      0  0123					      HI	BeginSelectMovePhase
      1  0123		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0124					      HI	SelectStartSquare
      1  0124		       f4		      .byte.b	>aiSelectStartSquare
      0  0125					      HI	StartSquareSelected
      1  0125		       f5		      .byte.b	>aiStartSquareSelected
      0  0126					      HI	DrawMoves
      1  0126		       f4		      .byte.b	>aiDrawMoves
      0  0127					      HI	ShowMoveCaptures
      1  0127		       f5		      .byte.b	>aiShowMoveCaptures
      0  0128					      HI	SlowFlash
      1  0128		       f5		      .byte.b	>aiSlowFlash
      0  0129					      HI	UnDrawTargetSquares
      1  0129		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  012a					      HI	SelectDestinationSquare
      1  012a		       f6		      .byte.b	>aiSelectDestinationSquare
      0  012b					      HI	Quiescent
      1  012b		       f5		      .byte.b	>aiQuiescent
      0  012c					      HI	ReselectDebounce
      1  012c		       f4		      .byte.b	>aiReselectDebounce
      0  012d					      HI	StartMoveGen
      1  012d		       f4		      .byte.b	>aiStartMoveGen
      0  012e					      HI	StepMoveGen
      1  012e		       f4		      .byte.b	>aiStepMoveGen
      0  012f					      HI	StartClearBoard
      1  012f		       f8		      .byte.b	>aiStartClearBoard
      0  0130					      HI	ClearEachRow
      1  0130		       f8		      .byte.b	>aiClearEachRow
      0  0131					      HI	DrawEntireBoard
      1  0131		       f5		      .byte.b	>aiDrawEntireBoard
      0  0132					      HI	DrawPart2
      1  0132		       f5		      .byte.b	>aiDrawPart2
      0  0133					      HI	DrawPart3
      1  0133		       f5		      .byte.b	>aiDrawPart3
      0  0134					      HI	GenerateMoves
      1  0134		       f4		      .byte.b	>aiGenerateMoves
      0  0135					      HI	ComputerMove
      1  0135		       f4		      .byte.b	>aiComputerMove
      0  0136					      HI	MoveIsSelected
      1  0136		       f8		      .byte.b	>aiMoveIsSelected
      0  0137					      HI	WriteStartPieceBlank
      1  0137		       f7		      .byte.b	>aiWriteStartPieceBlank
      0  0138					      HI	MarchToTargetA
      1  0138		       f5		      .byte.b	>aiMarchToTargetA
      0  0139					      HI	MarchA2
      1  0139		       f7		      .byte.b	>aiMarchA2
      0  013a					      HI	MarchB
      1  013a		       f5		      .byte.b	>aiMarchB
      0  013b					      HI	MarchToTargetB
      1  013b		       f4		      .byte.b	>aiMarchToTargetB
      0  013c					      HI	MarchB2
      1  013c		       f7		      .byte.b	>aiMarchB2
      0  013d					      HI	FinalFlash
      1  013d		       f5		      .byte.b	>aiFinalFlash
      0  013e					      HI	SpecialMoveFixup
      1  013e		       f5		      .byte.b	>aiSpecialMoveFixup
      0  013f					      HI	InCheckBackup
      1  013f		       f4		      .byte.b	>aiInCheckBackup
      0  0140					      HI	InCheckDelay
      1  0140		       f4		      .byte.b	>aiInCheckDelay
      0  0141					      HI	PromotePawnStart
      1  0141		       f4		      .byte.b	>aiPromotePawnStart
      0  0142					      HI	RollPromotionPiece
      1  0142		       f6		      .byte.b	>aiRollPromotionPiece
      0  0143					      HI	ChoosePromotePiece
      1  0143		       f6		      .byte.b	>aiChoosePromotePiece
      0  0144					      HI	ChooseDebounce
      1  0144		       f4		      .byte.b	>aiChooseDebounce
      0  0145					      HI	CheckMate
      1  0145		       f5		      .byte.b	>aiCheckMate
      0  0146					      HI	Draw
      1  0146		       f5		      .byte.b	>aiDraw
      0  0147					      HI	DelayAfterMove
      1  0147		       f4		      .byte.b	>aiDelayAfterMove
      0  0148					      HI	DelayAfterMove2
      1  0148		       f4		      .byte.b	>aiDelayAfterMove2
      0  0149					      HI	DelayAfterPlaced
      1  0149		       f4		      .byte.b	>aiDelayAfterPlaced
      0  014a					      HI	DelayAfterPlaced2
      1  014a		       f4		      .byte.b	>aiDelayAfterPlaced2
     43  014b
    346  014b
      0  014b					      DEF	AiVectorBANK
      1  014b				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  014b				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  014b				   AiVectorBANK
      4  014b				   TEMPORARY_VAR SET	Overlay
      5  014b				   TEMPORARY_OFFSET SET	0
      6  014b				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  014b				   FUNCTION_NAME SET	AiVectorBANK
      0  014b					      TABDEF	BK
      1  014b
      0  014b					      BK	FlashComputerMove
      1  014b		       46		      .byte.b	BANK_aiFlashComputerMove
      0  014c					      BK	BeginSelectMovePhase
      1  014c		       46		      .byte.b	BANK_aiBeginSelectMovePhase
      0  014d					      BK	SelectStartSquare
      1  014d		       46		      .byte.b	BANK_aiSelectStartSquare
      0  014e					      BK	StartSquareSelected
      1  014e		       47		      .byte.b	BANK_aiStartSquareSelected
      0  014f					      BK	DrawMoves
      1  014f		       46		      .byte.b	BANK_aiDrawMoves
      0  0150					      BK	ShowMoveCaptures
      1  0150		       46		      .byte.b	BANK_aiShowMoveCaptures
      0  0151					      BK	SlowFlash
      1  0151		       46		      .byte.b	BANK_aiSlowFlash
      0  0152					      BK	UnDrawTargetSquares
      1  0152		       46		      .byte.b	BANK_aiUnDrawTargetSquares
      0  0153					      BK	SelectDestinationSquare
      1  0153		       46		      .byte.b	BANK_aiSelectDestinationSquare
      0  0154					      BK	Quiescent
      1  0154		       41		      .byte.b	BANK_aiQuiescent
      0  0155					      BK	ReselectDebounce
      1  0155		       47		      .byte.b	BANK_aiReselectDebounce
      0  0156					      BK	StartMoveGen
      1  0156		       46		      .byte.b	BANK_aiStartMoveGen
      0  0157					      BK	StepMoveGen
      1  0157		       47		      .byte.b	BANK_aiStepMoveGen
      0  0158					      BK	StartClearBoard
      1  0158		       91		      .byte.b	BANK_aiStartClearBoard
      0  0159					      BK	ClearEachRow
      1  0159		       91		      .byte.b	BANK_aiClearEachRow
      0  015a					      BK	DrawEntireBoard
      1  015a		       41		      .byte.b	BANK_aiDrawEntireBoard
      0  015b					      BK	DrawPart2
      1  015b		       41		      .byte.b	BANK_aiDrawPart2
      0  015c					      BK	DrawPart3
      1  015c		       41		      .byte.b	BANK_aiDrawPart3
      0  015d					      BK	GenerateMoves
      1  015d		       47		      .byte.b	BANK_aiGenerateMoves
      0  015e					      BK	ComputerMove
      1  015e		       56		      .byte.b	BANK_aiComputerMove
      0  015f					      BK	MoveIsSelected
      1  015f		       91		      .byte.b	BANK_aiMoveIsSelected
      0  0160					      BK	WriteStartPieceBlank
      1  0160		       46		      .byte.b	BANK_aiWriteStartPieceBlank
      0  0161					      BK	MarchToTargetA
      1  0161		       47		      .byte.b	BANK_aiMarchToTargetA
      0  0162					      BK	MarchA2
      1  0162		       46		      .byte.b	BANK_aiMarchA2
      0  0163					      BK	MarchB
      1  0163		       41		      .byte.b	BANK_aiMarchB
      0  0164					      BK	MarchToTargetB
      1  0164		       47		      .byte.b	BANK_aiMarchToTargetB
      0  0165					      BK	MarchB2
      1  0165		       46		      .byte.b	BANK_aiMarchB2
      0  0166					      BK	FinalFlash
      1  0166		       47		      .byte.b	BANK_aiFinalFlash
      0  0167					      BK	SpecialMoveFixup
      1  0167		       41		      .byte.b	BANK_aiSpecialMoveFixup
      0  0168					      BK	InCheckBackup
      1  0168		       46		      .byte.b	BANK_aiInCheckBackup
      0  0169					      BK	InCheckDelay
      1  0169		       46		      .byte.b	BANK_aiInCheckDelay
      0  016a					      BK	PromotePawnStart
      1  016a		       47		      .byte.b	BANK_aiPromotePawnStart
      0  016b					      BK	RollPromotionPiece
      1  016b		       46		      .byte.b	BANK_aiRollPromotionPiece
      0  016c					      BK	ChoosePromotePiece
      1  016c		       46		      .byte.b	BANK_aiChoosePromotePiece
      0  016d					      BK	ChooseDebounce
      1  016d		       47		      .byte.b	BANK_aiChooseDebounce
      0  016e					      BK	CheckMate
      1  016e		       41		      .byte.b	BANK_aiCheckMate
      0  016f					      BK	Draw
      1  016f		       41		      .byte.b	BANK_aiDraw
      0  0170					      BK	DelayAfterMove
      1  0170		       47		      .byte.b	BANK_aiDelayAfterMove
      0  0171					      BK	DelayAfterMove2
      1  0171		       47		      .byte.b	BANK_aiDelayAfterMove2
      0  0172					      BK	DelayAfterPlaced
      1  0172		       47		      .byte.b	BANK_aiDelayAfterPlaced
      0  0173					      BK	DelayAfterPlaced2
      1  0173		       47		      .byte.b	BANK_aiDelayAfterPlaced2
     43  0174
    349  0174
    350  0174
    351  0174							;---------------------------------------------------------------------------------------------------
    352  0174
      0  0174					      DEF	AiStateMachine
      1  0174				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0174				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0174				   AiStateMachine
      4  0174				   TEMPORARY_VAR SET	Overlay
      5  0174				   TEMPORARY_OFFSET SET	0
      6  0174				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0174				   FUNCTION_NAME SET	AiStateMachine
    354  0174					      SUBROUTINE
    355  0174
      0  0174					      REFER	StartupBankReset	;✅
      1  0174				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0174				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0174					      ENDIF
      0  0174					      VAR	__aiVec, 2
      1  0174		       00 a7	   __aiVec    =	TEMPORARY_VAR
      2  0174				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0174
      4  0174				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0174				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0174				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0174					      ENDIF
      8  0174				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0174				  -	      ECHO	"Temporary Variable", __aiVec, "overflow!"
     10  0174				  -	      ERR
     11  0174					      ENDIF
     12  0174					      LIST	ON
      0  0174					      VEND	AiStateMachine
      1  0174				  -	      IFNCONST	AiStateMachine
      2  0174				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  0174				  -	      ERR
      4  0174					      ENDIF
      5  0174		       00 a9	   VAREND_AiStateMachine =	TEMPORARY_VAR
    359  0174
    360  0174
    361  0174							; State machine vector setup - points to current routine to execute
    362  0174
    363  0174		       a6 8b		      ldx	aiState
    364  0176		       bd f9 f0 	      lda	AiVectorLO,x
    365  0179		       85 a7		      sta	__aiVec
    366  017b		       bd 22 f1 	      lda	AiVectorHI,x
    367  017e		       85 a8		      sta	__aiVec+1
    368  0180
    369  0180		       bd 4b f1 	      lda	AiVectorBANK,x
    370  0183		       85 3f		      sta	SET_BANK
    371  0185		       6c a7 00 	      jmp	(__aiVec)	; NOTE: could branch back to squeeze cycles
    372  0188
    373  0188
    374  0188							;---------------------------------------------------------------------------------------------------
    375  0188
      0  0188					      DEF	GenerateAllMoves
      1  0188				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  0188				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  0188				   GenerateAllMoves
      4  0188				   TEMPORARY_VAR SET	Overlay
      5  0188				   TEMPORARY_OFFSET SET	0
      6  0188				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  0188				   FUNCTION_NAME SET	GenerateAllMoves
    377  0188					      SUBROUTINE
    378  0188
      0  0188					      REFER	ListPlayerMoves	;✅
      1  0188					      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0188				   TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0188					      ENDIF
      0  0188					      REFER	aiComputerMove	;✅
      1  0188				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  0188				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  0188					      ENDIF
      0  0188					      REFER	quiesce	;✅
      1  0188				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0188				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0188					      ENDIF
      0  0188					      REFER	negaMax	;✅
      1  0188				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0188				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0188					      ENDIF
    383  0188
      0  0188					      VAR	__vector, 2
      1  0188		       00 b5	   __vector   =	TEMPORARY_VAR
      2  0188				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0188
      4  0188				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0188					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0188				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0188					      ENDIF
      8  0188				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0188				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  0188				  -	      ERR
     11  0188					      ENDIF
     12  0188					      LIST	ON
      0  0188					      VAR	__pieceFilter, 1
      1  0188		       00 b7	   __pieceFilter =	TEMPORARY_VAR
      2  0188				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0188
      4  0188				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0188					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0188				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0188					      ENDIF
      8  0188				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0188				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  0188				  -	      ERR
     11  0188					      ENDIF
     12  0188					      LIST	ON
    386  0188
      0  0188					      VEND	GenerateAllMoves
      1  0188				  -	      IFNCONST	GenerateAllMoves
      2  0188				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  0188				  -	      ERR
      4  0188					      ENDIF
      5  0188		       00 b8	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    388  0188
    389  0188							; Do the move generation in two passes - pawns then pieces
    390  0188							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    391  0188
    392  0188							;...
    393  0188							; This MUST be called at the start of a new ply
    394  0188							; It initialises the movelist to empty
    395  0188							; x must be preserved
    396  0188
    397  0188		       a5 94		      lda	currentPly
    398  018a		       85 3e		      sta	SET_BANK_RAM	;@2
    399  018c
    400  018c							; note that 'alpha' and 'beta' are set externally!!
    401  018c
    402  018c		       a9 ff		      lda	#-1
      0  018e					      sta@PLY	moveIndex	; no valid moves
      1  018e		       8d cf fb 	      sta	[RAM]+moveIndex
      0  0191					      sta@PLY	bestMove
      1  0191		       8d d1 fb 	      sta	[RAM]+bestMove
    405  0194
    406  0194		       a5 93		      lda	enPassantPawn	; flag/square from last actual move made
      0  0196					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  0196		       8d ca fb 	      sta	[RAM]+enPassantSquare
    408  0199
    409  0199		       a5 a5		      lda	vkSquare
      0  019b					      sta@PLY	virtualKingSquare
      1  019b		       8d da fb 	      sta	[RAM]+virtualKingSquare
    411  019e		       a5 a6		      lda	vkSquare+1
      0  01a0					      sta@PLY	virtualKingSquare+1	; traversal squares of king for castling
      1  01a0		       8d db fb 	      sta	[RAM]+virtualKingSquare+1
    413  01a3
    414  01a3		       20 91 f2 	      jsr	debug
    415  01a6
    416  01a6							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    417  01a6							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    418  01a6							; start of each new ply.
    419  01a6
    420  01a6		       a5 8f		      lda	Evaluation
      0  01a8					      sta@PLY	savedEvaluation
      1  01a8		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    422  01ab		       a5 90		      lda	Evaluation+1
      0  01ad					      sta@PLY	savedEvaluation+1
      1  01ad		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    424  01b0							;^
    425  01b0
    426  01b0
    427  01b0
    428  01b0		       a9 08		      lda	#8	; pawns
    429  01b2		       85 b7		      sta	__pieceFilter
    430  01b4		       20 c5 f1 	      jsr	MoveGenX
    431  01b7							;lda #99
    432  01b7							;sta currentSquare
    433  01b7		       a9 00		      lda	#0
    434  01b9		       85 b7		      sta	__pieceFilter
    435  01bb		       20 c5 f1 	      jsr	MoveGenX
    436  01be
    437  01be		       a9 56		      lda	#BANK_Sort
    438  01c0		       85 3f		      sta	SET_BANK
    439  01c2		       4c 27 f6 	      jmp	Sort	;@1
    440  01c5
    441  01c5
    442  01c5
      0  01c5					      DEF	MoveGenX
      1  01c5				   SLOT_MoveGenX SET	_BANK_SLOT
      2  01c5				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  01c5				   MoveGenX
      4  01c5				   TEMPORARY_VAR SET	Overlay
      5  01c5				   TEMPORARY_OFFSET SET	0
      6  01c5				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  01c5				   FUNCTION_NAME SET	MoveGenX
    444  01c5					      SUBROUTINE
    445  01c5
    446  01c5		       a9 d1		      lda	#RAMBANK_BOARD
    447  01c7		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    448  01c9
    449  01c9		       a2 64		      ldx	#100
    450  01cb		       d0 02		      bne	.next
    451  01cd
      0  01cd					      DEF	MoveReturn
      1  01cd				   SLOT_MoveReturn SET	_BANK_SLOT
      2  01cd				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  01cd				   MoveReturn
      4  01cd				   TEMPORARY_VAR SET	Overlay
      5  01cd				   TEMPORARY_OFFSET SET	0
      6  01cd				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  01cd				   FUNCTION_NAME SET	MoveReturn
    453  01cd
    454  01cd		       a6 92		      ldx	currentSquare
    455  01cf		       ca	   .next      dex
    456  01d0		       e0 16		      cpx	#22
    457  01d2		       90 2c		      bcc	.exit
    458  01d4
    459  01d4		       bd 79 fc 	      lda	Board,x
    460  01d7		       f0 f6		      beq	.next
    461  01d9		       c9 ff		      cmp	#-1
    462  01db		       f0 f2		      beq	.next
    463  01dd		       45 95		      eor	sideToMove
    464  01df		       30 ee		      bmi	.next
    465  01e1
    466  01e1		       86 92		      stx	currentSquare
    467  01e3
    468  01e3		       45 95		      eor	sideToMove
    469  01e5		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    470  01e7		       85 91		      sta	currentPiece
    471  01e9		       29 0f		      and	#PIECE_MASK
    472  01eb		       05 b7		      ora	__pieceFilter
    473  01ed		       a8		      tay
    474  01ee
    475  01ee		       b9 15 f2 	      lda	HandlerVectorHI,y
    476  01f1		       85 b6		      sta	__vector+1
    477  01f3		       b9 05 f2 	      lda	HandlerVectorLO,y
    478  01f6		       85 b5		      sta	__vector
    479  01f8
    480  01f8		       b9 25 f2 	      lda	HandlerVectorBANK,y
    481  01fb		       85 3f		      sta	SET_BANK	;@1
    482  01fd
    483  01fd		       6c b5 00 	      jmp	(__vector)
    484  0200
    485  0200
    486  0200		       a9 56	   .exit      lda	#BANK_negaMax
    487  0202		       85 3f		      sta	SET_BANK
    488  0204		       60		      rts
    489  0205
    490  0205					      MAC	handlevec
    491  0205
    492  0205					      .byte	{1}MoveReturn
    493  0205					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
    494  0205					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
    495  0205					      .byte	{1}Handle_KNIGHT	; 3
    496  0205					      .byte	{1}Handle_BISHOP	; 4
    497  0205					      .byte	{1}Handle_ROOK	; 5
    498  0205					      .byte	{1}Handle_QUEEN	; 6
    499  0205					      .byte	{1}Handle_KING	; 7
    500  0205
    501  0205					      .byte	{1}MoveReturn
    502  0205					      .byte	{1}Handle_WHITE_PAWN	; 1
    503  0205					      .byte	{1}Handle_BLACK_PAWN	; 2
    504  0205					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
    505  0205					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
    506  0205					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
    507  0205					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
    508  0205					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
    509  0205					      ENDM
    510  0205
    511  0205
    512  0205							;    .byte 0	  ; dummy to prevent page cross access on index 0
    513  0205
      0  0205					      DEF	HandlerVectorLO
      1  0205				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  0205				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  0205				   HandlerVectorLO
      4  0205				   TEMPORARY_VAR SET	Overlay
      5  0205				   TEMPORARY_OFFSET SET	0
      6  0205				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  0205				   FUNCTION_NAME SET	HandlerVectorLO
      0  0205					      HANDLEVEC	<
      1  0205
      2  0205		       cd		      .byte.b	<MoveReturn
      3  0206		       cd		      .byte.b	<MoveReturn
      4  0207		       cd		      .byte.b	<MoveReturn
      5  0208		       44		      .byte.b	<Handle_KNIGHT
      6  0209		       ed		      .byte.b	<Handle_BISHOP
      7  020a		       00		      .byte.b	<Handle_ROOK
      8  020b		       7b		      .byte.b	<Handle_QUEEN
      9  020c		       6e		      .byte.b	<Handle_KING
     10  020d
     11  020d		       cd		      .byte.b	<MoveReturn
     12  020e		       29		      .byte.b	<Handle_WHITE_PAWN
     13  020f		       cb		      .byte.b	<Handle_BLACK_PAWN
     14  0210		       cd		      .byte.b	<MoveReturn
     15  0211		       cd		      .byte.b	<MoveReturn
     16  0212		       cd		      .byte.b	<MoveReturn
     17  0213		       cd		      .byte.b	<MoveReturn
     18  0214		       cd		      .byte.b	<MoveReturn
      0  0215					      DEF	HandlerVectorHI
      1  0215				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  0215				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  0215				   HandlerVectorHI
      4  0215				   TEMPORARY_VAR SET	Overlay
      5  0215				   TEMPORARY_OFFSET SET	0
      6  0215				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  0215				   FUNCTION_NAME SET	HandlerVectorHI
      0  0215					      HANDLEVEC	>
      1  0215
      2  0215		       f1		      .byte.b	>MoveReturn
      3  0216		       f1		      .byte.b	>MoveReturn
      4  0217		       f1		      .byte.b	>MoveReturn
      5  0218		       f5		      .byte.b	>Handle_KNIGHT
      6  0219		       f5		      .byte.b	>Handle_BISHOP
      7  021a		       f4		      .byte.b	>Handle_ROOK
      8  021b		       f4		      .byte.b	>Handle_QUEEN
      9  021c		       f5		      .byte.b	>Handle_KING
     10  021d
     11  021d		       f1		      .byte.b	>MoveReturn
     12  021e		       f4		      .byte.b	>Handle_WHITE_PAWN
     13  021f		       f4		      .byte.b	>Handle_BLACK_PAWN
     14  0220		       f1		      .byte.b	>MoveReturn
     15  0221		       f1		      .byte.b	>MoveReturn
     16  0222		       f1		      .byte.b	>MoveReturn
     17  0223		       f1		      .byte.b	>MoveReturn
     18  0224		       f1		      .byte.b	>MoveReturn
      0  0225					      DEF	HandlerVectorBANK
      1  0225				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  0225				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  0225				   HandlerVectorBANK
      4  0225				   TEMPORARY_VAR SET	Overlay
      5  0225				   TEMPORARY_OFFSET SET	0
      6  0225				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  0225				   FUNCTION_NAME SET	HandlerVectorBANK
      0  0225					      HANDLEVEC	BANK_
      1  0225
      2  0225		       00		      .byte.b	BANK_MoveReturn
      3  0226		       00		      .byte.b	BANK_MoveReturn
      4  0227		       00		      .byte.b	BANK_MoveReturn
      5  0228		       57		      .byte.b	BANK_Handle_KNIGHT
      6  0229		       57		      .byte.b	BANK_Handle_BISHOP
      7  022a		       58		      .byte.b	BANK_Handle_ROOK
      8  022b		       58		      .byte.b	BANK_Handle_QUEEN
      9  022c		       58		      .byte.b	BANK_Handle_KING
     10  022d
     11  022d		       00		      .byte.b	BANK_MoveReturn
     12  022e		       57		      .byte.b	BANK_Handle_WHITE_PAWN
     13  022f		       57		      .byte.b	BANK_Handle_BLACK_PAWN
     14  0230		       00		      .byte.b	BANK_MoveReturn
     15  0231		       00		      .byte.b	BANK_MoveReturn
     16  0232		       00		      .byte.b	BANK_MoveReturn
     17  0233		       00		      .byte.b	BANK_MoveReturn
     18  0234		       00		      .byte.b	BANK_MoveReturn
    520  0235
    521  0235
    522  0235							;---------------------------------------------------------------------------------------------------
    523  0235
      0  0235					      DEF	ListPlayerMoves
      1  0235				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  0235				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  0235				   ListPlayerMoves
      4  0235				   TEMPORARY_VAR SET	Overlay
      5  0235				   TEMPORARY_OFFSET SET	0
      6  0235				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  0235				   FUNCTION_NAME SET	ListPlayerMoves
    525  0235					      SUBROUTINE
    526  0235
    527  0235							; Build a list of (mostly) valid player moves. The list of all moves is generated, and then
    528  0235							; these are each verified by making the move and listing all opponent moves. If the opponent
    529  0235							; can capture the king, the move is invalidated by setting its "from" square to zero.
    530  0235
    531  0235							; The movelist is built in the second ply so as not to stomp on the movelist from the computer
    532  0235							; on the previous response. This allows the player movelist to be generated BEFORE the
    533  0235							; computer's move has been visually shown on the screen.
    534  0235
    535  0235							; This in turn requires the minimum memory for PLY banks to be 3 (computer, player, response)
    536  0235
      0  0235					      COMMON_VARS
      1  0235
      0  0235					      VAR	__thinkbar, 1
      1  0235		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
      0  0235					      VAR	__toggle, 1
      1  0235		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
      4  0235
      0  0235					      VAR	__bestMove, 1
      1  0235		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
      0  0235					      VAR	__alpha, 2
      1  0235		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
      0  0235					      VAR	__beta, 2
      1  0235		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
      0  0235					      VAR	__negaMax, 2
      1  0235		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
      0  0235					      VAR	__value, 2
      1  0235		       00 b0	   __value    =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
     10  0235
      0  0235					      VAR	__quiesceCapOnly, 1
      1  0235		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
     12  0235
      0  0235					      VAR	__originalPiece, 1
      1  0235		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
      0  0235					      VAR	__capturedPiece, 1
      1  0235		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0235				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0235
      4  0235				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0235				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0235				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0235					      ENDIF
      8  0235				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0235				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0235				  -	      ERR
     11  0235					      ENDIF
     12  0235					      LIST	ON
     15  0235
      0  0235					      REFER	selectmove	;✅
      1  0235				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0235				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0235					      ENDIF
      0  0235					      REFER	StartupBankReset	;✅
      1  0235				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0235				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0235					      ENDIF
    540  0235
      0  0235					      VEND	ListPlayerMoves
      1  0235				  -	      IFNCONST	ListPlayerMoves
      2  0235				  -	      ECHO	"Incorrect VEND label", ListPlayerMoves
      3  0235				  -	      ERR
      4  0235					      ENDIF
      5  0235		       00 b5	   VAREND_ListPlayerMoves =	TEMPORARY_VAR
    542  0235
    543  0235
    544  0235		       a9 00		      lda	#0
    545  0237		       85 b2		      sta	__quiesceCapOnly	; gen ALL moves
    546  0239
    547  0239		       a9 89		      lda	#RAMBANK_PLY+1
    548  023b		       85 94		      sta	currentPly
    549  023d
    550  023d		       20 88 f1 	      jsr	GenerateAllMoves	;@this
    551  0240
      0  0240					      ldx@PLY	moveIndex
      1  0240		       ae cf f9 	      ldx	moveIndex
      0  0243				   .scan      stx@PLY	movePtr
      1  0243		       8e d0 fb 	      stx	[RAM]+movePtr
    554  0246
      0  0246					      CALL	MakeMove	;@1
      1  0246				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  0246				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0246				  -	      ECHO	"Cannot switch bank in use for", MakeMove
      4  0246				  -	      ERR
      5  0246					      ENDIF
      6  0246		       a9 56		      lda	#BANK_MakeMove
      7  0248		       85 3f		      sta	SET_BANK
      8  024a		       20 87 f4 	      jsr	MakeMove
    556  024d
    557  024d		       e6 94		      inc	currentPly
    558  024f		       20 88 f1 	      jsr	GenerateAllMoves	;@this
    559  0252
    560  0252		       c6 94		      dec	currentPly
    561  0254
    562  0254		       20 92 f2 	      jsr	unmakeMove	;@this
    563  0257
    564  0257		       a5 a0		      lda	flagCheck
    565  0259		       f0 08		      beq	.next
    566  025b
      0  025b					      ldx@PLY	movePtr
      1  025b		       ae d0 f9 	      ldx	movePtr
    568  025e		       a9 00		      lda	#0
      0  0260					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  0260		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    570  0263
      0  0263				   .next      ldx@PLY	movePtr
      1  0263		       ae d0 f9 	      ldx	movePtr
    572  0266		       ca		      dex
    573  0267		       10 da		      bpl	.scan
    574  0269
    575  0269		       60		      rts
    576  026a
    577  026a
    578  026a							;---------------------------------------------------------------------------------------------------
    579  026a
      0  026a					      DEF	AddMove
      1  026a				   SLOT_AddMove SET	_BANK_SLOT
      2  026a				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  026a				   AddMove
      4  026a				   TEMPORARY_VAR SET	Overlay
      5  026a				   TEMPORARY_OFFSET SET	0
      6  026a				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  026a				   FUNCTION_NAME SET	AddMove
    581  026a					      SUBROUTINE
    582  026a
      0  026a					      REFER	Handle_KING	;✅
      1  026a					      IF	VAREND_Handle_KING > TEMPORARY_VAR
      2  026a				   TEMPORARY_VAR SET	VAREND_Handle_KING
      3  026a					      ENDIF
      0  026a					      REFER	Handle_QUEEN	;✅
      1  026a				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  026a				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  026a					      ENDIF
      0  026a					      REFER	Handle_ROOK	;✅
      1  026a				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  026a				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  026a					      ENDIF
      0  026a					      REFER	Handle_BISHOP	;✅
      1  026a				  -	      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  026a				  -TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  026a					      ENDIF
      0  026a					      REFER	Handle_KNIGHT	;✅
      1  026a				  -	      IF	VAREND_Handle_KNIGHT > TEMPORARY_VAR
      2  026a				  -TEMPORARY_VAR SET	VAREND_Handle_KNIGHT
      3  026a					      ENDIF
      0  026a					      REFER	Handle_WHITE_PAWN	;✅
      1  026a				  -	      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  026a				  -TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  026a					      ENDIF
      0  026a					      REFER	Handle_BLACK_PAWN	;✅
      1  026a				  -	      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  026a				  -TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  026a					      ENDIF
    590  026a
      0  026a					      VEND	AddMove
      1  026a				  -	      IFNCONST	AddMove
      2  026a				  -	      ECHO	"Incorrect VEND label", AddMove
      3  026a				  -	      ERR
      4  026a					      ENDIF
      5  026a		       00 b8	   VAREND_AddMove =	TEMPORARY_VAR
    592  026a
    593  026a							; add square in y register to movelist as destination (X12 format)
    594  026a							; [y]		     to square (X12)
    595  026a							; currentSquare     from square (X12)
    596  026a							; currentPiece      piece.
    597  026a							;   ENPASSANT flag set if pawn double-moving off opening rank
    598  026a							; capture	     captured piece
    599  026a
    600  026a
    601  026a		       a5 9c		      lda	capture
    602  026c		       d0 04		      bne	.always
    603  026e		       a5 b2		      lda	__quiesceCapOnly
    604  0270		       d0 1c		      bne	.abort
    605  0272
    606  0272		       98	   .always    tya
    607  0273		       aa		      tax
    608  0274
      0  0274					      ldy@PLY	moveIndex
      1  0274		       ac cf f9 	      ldy	moveIndex
    610  0277		       c8		      iny
      0  0278					      sty@PLY	moveIndex
      1  0278		       8c cf fb 	      sty	[RAM]+moveIndex
    612  027b
      0  027b					      sta@PLY	MoveTo,y
      1  027b		       99 64 fa 	      sta	[RAM]+MoveTo,y
    614  027e		       a5 92		      lda	currentSquare
      0  0280					      sta@PLY	MoveFrom,y
      1  0280		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    616  0283		       a5 91		      lda	currentPiece
      0  0285					      sta@PLY	MovePiece,y
      1  0285		       99 00 fb 	      sta	[RAM]+MovePiece,y
    618  0288		       a5 9c		      lda	capture
      0  028a					      sta@PLY	MoveCapture,y
      1  028a		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    620  028d		       60		      rts
    621  028e
    622  028e		       98	   .abort     tya
    623  028f		       aa		      tax
    624  0290		       60		      rts
    625  0291
    626  0291
    627  0291
    628  0291							;---------------------------------------------------------------------------------------------------
    629  0291
      0  0291					      DEF	debug
      1  0291				   SLOT_debug SET	_BANK_SLOT
      2  0291				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  0291				   debug
      4  0291				   TEMPORARY_VAR SET	Overlay
      5  0291				   TEMPORARY_OFFSET SET	0
      6  0291				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  0291				   FUNCTION_NAME SET	debug
    631  0291					      SUBROUTINE
    632  0291		       60		      rts
    633  0292
    634  0292
    635  0292							;---------------------------------------------------------------------------------------------------
    636  0292
      0  0292					      DEF	unmakeMove
      1  0292				   SLOT_unmakeMove SET	_BANK_SLOT
      2  0292				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  0292				   unmakeMove
      4  0292				   TEMPORARY_VAR SET	Overlay
      5  0292				   TEMPORARY_OFFSET SET	0
      6  0292				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  0292				   FUNCTION_NAME SET	unmakeMove
    638  0292					      SUBROUTINE
    639  0292
      0  0292					      REFER	selectmove	;✅
      1  0292					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0292				   TEMPORARY_VAR SET	VAREND_selectmove
      3  0292					      ENDIF
      0  0292					      REFER	ListPlayerMoves	;✅
      1  0292				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0292				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0292					      ENDIF
      0  0292					      REFER	quiesce	;✅
      1  0292				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0292				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0292					      ENDIF
      0  0292					      REFER	negaMax	;✅
      1  0292				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0292				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0292					      ENDIF
      0  0292					      VEND	unmakeMove
      1  0292				  -	      IFNCONST	unmakeMove
      2  0292				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  0292				  -	      ERR
      4  0292					      ENDIF
      5  0292		       00 b5	   VAREND_unmakeMove =	TEMPORARY_VAR
    645  0292
    646  0292							; restore the board evaluation to what it was at the start of this ply
    647  0292							; TODO: note: moved flag seems wrong on restoration??
    648  0292
    649  0292		       a5 94		      lda	currentPly
    650  0294		       85 3e		      sta	SET_BANK_RAM	;@2
    651  0296		       a2 d1		      ldx	#RAMBANK_BOARD
    652  0298		       86 3e		      stx	SET_BANK_RAM	;@3
    653  029a
      0  029a					      lda@PLY	savedEvaluation
      1  029a		       ad c8 f9 	      lda	savedEvaluation
    655  029d		       85 8f		      sta	Evaluation
      0  029f					      lda@PLY	savedEvaluation+1
      1  029f		       ad c9 f9 	      lda	savedEvaluation+1
    657  02a2		       85 90		      sta	Evaluation+1
    658  02a4
      0  02a4					      ldx@PLY	movePtr
      1  02a4		       ae d0 f9 	      ldx	movePtr
      0  02a7					      ldy@PLY	MoveFrom,x
      1  02a7		       bc 00 f8 	      ldy	MoveFrom,x
      0  02aa					      lda@PLY	restorePiece
      1  02aa		       ad d9 f9 	      lda	restorePiece
      0  02ad					      sta@RAM	Board,y
      1  02ad		       99 79 fe 	      sta	[RAM]+Board,y
    663  02b0
      0  02b0					      ldy@PLY	MoveTo,x
      1  02b0		       bc 64 f8 	      ldy	MoveTo,x
      0  02b3					      lda@PLY	capturedPiece
      1  02b3		       ad cb f9 	      lda	capturedPiece
      0  02b6					      sta@RAM	Board,y
      1  02b6		       99 79 fe 	      sta	[RAM]+Board,y
    667  02b9
    668  02b9
    669  02b9							; See if there are any 'secondary' pieces that moved
    670  02b9							; here we're dealing with reverting a castling or enPassant move
    671  02b9
      0  02b9					      lda@PLY	secondaryPiece
      1  02b9		       ad cc f9 	      lda	secondaryPiece
    673  02bc		       f0 0e		      beq	.noSecondary
      0  02be					      ldx@PLY	secondarySquare
      1  02be		       ae cd f9 	      ldx	secondarySquare
      0  02c1					      sta@RAM	Board,x	; put piece back
      1  02c1		       9d 79 fe 	      sta	[RAM]+Board,x
      0  02c4					      ldy@PLY	secondaryBlank
      1  02c4		       ac ce f9 	      ldy	secondaryBlank
    677  02c7		       a9 00		      lda	#0
      0  02c9					      sta@RAM	Board,y	; blank piece origin
      1  02c9		       99 79 fe 	      sta	[RAM]+Board,y
    679  02cc
      0  02cc				   .noSecondary SWAP
      1  02cc		       a5 95		      lda	sideToMove
      2  02ce		       49 80		      eor	#SWAP_SIDE
      3  02d0		       85 95		      sta	sideToMove
      4  02d2
      5  02d2
    681  02d2		       60		      rts
    682  02d3
    683  02d3
    684  02d3							;---------------------------------------------------------------------------------------------------
    685  02d3
      0  02d3					      DEF	showMoveCaptures
      1  02d3				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  02d3				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  02d3				   showMoveCaptures
      4  02d3				   TEMPORARY_VAR SET	Overlay
      5  02d3				   TEMPORARY_OFFSET SET	0
      6  02d3				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  02d3				   FUNCTION_NAME SET	showMoveCaptures
    687  02d3					      SUBROUTINE
    688  02d3
      0  02d3					      REFER	aiShowMoveCaptures	;✅
      1  02d3					      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  02d3				   TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  02d3					      ENDIF
    690  02d3
      0  02d3					      VAR	__toSquareX12, 1
      1  02d3		       00 a9	   __toSquareX12 =	TEMPORARY_VAR
      2  02d3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02d3
      4  02d3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02d3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02d3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02d3					      ENDIF
      8  02d3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02d3				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  02d3				  -	      ERR
     11  02d3					      ENDIF
     12  02d3					      LIST	ON
      0  02d3					      VAR	__fromPiece, 1
      1  02d3		       00 aa	   __fromPiece =	TEMPORARY_VAR
      2  02d3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02d3
      4  02d3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02d3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02d3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02d3					      ENDIF
      8  02d3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02d3				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  02d3				  -	      ERR
     11  02d3					      ENDIF
     12  02d3					      LIST	ON
      0  02d3					      VAR	__aiMoveIndex, 1
      1  02d3		       00 ab	   __aiMoveIndex =	TEMPORARY_VAR
      2  02d3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02d3
      4  02d3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02d3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02d3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02d3					      ENDIF
      8  02d3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02d3				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  02d3				  -	      ERR
     11  02d3					      ENDIF
     12  02d3					      LIST	ON
    694  02d3
      0  02d3					      VEND	showMoveCaptures
      1  02d3				  -	      IFNCONST	showMoveCaptures
      2  02d3				  -	      ECHO	"Incorrect VEND label", showMoveCaptures
      3  02d3				  -	      ERR
      4  02d3					      ENDIF
      5  02d3		       00 ac	   VAREND_showMoveCaptures =	TEMPORARY_VAR
    696  02d3
    697  02d3							; place a marker on the board for any square matching the piece
    698  02d3							; EXCEPT for squares which are occupied (we'll flash those later)
    699  02d3							; x = movelist item # being checked
    700  02d3
    701  02d3
    702  02d3		       a6 8d	   .next      ldx	aiMoveIndex
    703  02d5		       86 ab		      stx	__aiMoveIndex
    704  02d7		       30 4a		      bmi	.skip	; no moves in list
    705  02d9
    706  02d9		       ad 84 02 	      lda	INTIM
    707  02dc		       c9 14		      cmp	#20
    708  02de		       90 43		      bcc	.skip
    709  02e0
    710  02e0		       c6 8d		      dec	aiMoveIndex
    711  02e2
    712  02e2		       a9 89		      lda	#RAMBANK_PLY+1
    713  02e4		       85 3e		      sta	SET_BANK_RAM
      0  02e6					      lda@PLY	MoveFrom,x
      1  02e6		       bd 00 f8 	      lda	MoveFrom,x
    715  02e9		       c5 85		      cmp	fromX12
    716  02eb		       d0 e6		      bne	.next
    717  02ed
      0  02ed					      lda@PLY	MoveTo,x
      1  02ed		       bd 64 f8 	      lda	MoveTo,x
    719  02f0		       85 a9		      sta	__toSquareX12
    720  02f2		       a8		      tay
    721  02f3
    722  02f3		       a9 d1		      lda	#RAMBANK_BOARD
    723  02f5		       85 3e		      sta	SET_BANK_RAM	;@3
    724  02f7		       b9 79 fc 	      lda	Board,y
    725  02fa		       29 0f		      and	#PIECE_MASK
    726  02fc		       f0 d5		      beq	.next
    727  02fe
    728  02fe							; There's something on the board at destination, so it's a capture
    729  02fe							; Let's see if we are doing a pawn promote...
    730  02fe
    731  02fe		       a4 85		      ldy	fromX12
    732  0300
    733  0300		       a9 d1		      lda	#RAMBANK_BOARD
    734  0302		       85 3e		      sta	SET_BANK_RAM	;@3
    735  0304		       b9 79 fc 	      lda	Board,y
    736  0307		       85 aa		      sta	__fromPiece
    737  0309
    738  0309		       a9 89		      lda	#RAMBANK_PLY+1
    739  030b		       85 3e		      sta	SET_BANK_RAM
      0  030d					      lda@PLY	MovePiece,x
      1  030d		       bd 00 f9 	      lda	MovePiece,x
    741  0310		       45 aa		      eor	__fromPiece
    742  0312		       29 0f		      and	#PIECE_MASK
    743  0314		       f0 06		      beq	.legit	; from == to, so not a promote
    744  0316
    745  0316							; Have detected a promotion duplicate - skip all 3 of them
    746  0316
    747  0316		       c6 8d		      dec	aiMoveIndex	; skip "KBRQ" promotes
    748  0318		       c6 8d		      dec	aiMoveIndex
    749  031a		       c6 8d		      dec	aiMoveIndex
    750  031c
    751  031c				   .legit
    752  031c
    753  031c							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
    754  031c
    755  031c		       a5 a9		      lda	__toSquareX12
    756  031e		       85 80		      sta	squareToDraw
    757  0320
    758  0320							; WARNING - local variables will not survive the following call...!
    759  0320		       20 be f0 	      jsr	CopySinglePiece	;@0
    760  0323
    761  0323		       60	   .skip      rts
    762  0324
    763  0324
    764  0324							;---------------------------------------------------------------------------------------------------
    765  0324
      0  0324					      DEF	CopyPieceToRowBitmap
      1  0324				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  0324				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  0324				   CopyPieceToRowBitmap
      4  0324				   TEMPORARY_VAR SET	Overlay
      5  0324				   TEMPORARY_OFFSET SET	0
      6  0324				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  0324				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    767  0324					      SUBROUTINE
    768  0324
      0  0324					      REFER	InterceptMarkerCopy	;✅
      1  0324					      IF	VAREND_InterceptMarkerCopy > TEMPORARY_VAR
      2  0324				   TEMPORARY_VAR SET	VAREND_InterceptMarkerCopy
      3  0324					      ENDIF
    770  0324
      0  0324					      VEND	CopyPieceToRowBitmap
      1  0324				  -	      IFNCONST	CopyPieceToRowBitmap
      2  0324				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  0324				  -	      ERR
      4  0324					      ENDIF
      5  0324		       00 ac	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
    772  0324
    773  0324		       a0 11		      ldy	#17
    774  0326		       b0 30		      bcs	.rightSide
    775  0328
    776  0328		       b9 a7 00    .copyPiece lda	__pieceShapeBuffer,y
    777  032b		       f0 06		      beq	.blank1
    778  032d		       59 00 f8 	      eor	ChessBitmap,y
      0  0330					      sta@RAM	ChessBitmap,y
      1  0330		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    780  0333
    781  0333		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    782  0336		       f0 06		      beq	.blank2
    783  0338		       59 12 f8 	      eor	ChessBitmap+18,y
      0  033b					      sta@RAM	ChessBitmap+18,y
      1  033b		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    785  033e
    786  033e		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    787  0341		       f0 06		      beq	.blank3
    788  0343		       59 24 f8 	      eor	ChessBitmap+36,y
      0  0346					      sta@RAM	ChessBitmap+36,y
      1  0346		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    790  0349
    791  0349		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    792  034c		       f0 06		      beq	.blank4
    793  034e		       59 36 f8 	      eor	ChessBitmap+54,y
      0  0351					      sta@RAM	ChessBitmap+54,y
      1  0351		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    795  0354
    796  0354		       88	   .blank4    dey
    797  0355		       10 d1		      bpl	.copyPiece
    798  0357		       60		      rts
    799  0358
    800  0358				   .rightSide
    801  0358
    802  0358					      SUBROUTINE
    803  0358
    804  0358		       b9 a7 00    .copyPieceR lda	__pieceShapeBuffer,y
    805  035b		       f0 06		      beq	.blank1
    806  035d		       59 48 f8 	      eor	ChessBitmap+72,y
      0  0360					      sta@RAM	ChessBitmap+72,y
      1  0360		       99 48 fa 	      sta	[RAM]+ChessBitmap+72,y
    808  0363
    809  0363		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    810  0366		       f0 06		      beq	.blank2
    811  0368		       59 5a f8 	      eor	ChessBitmap+72+18,y
      0  036b					      sta@RAM	ChessBitmap+72+18,y
      1  036b		       99 5a fa 	      sta	[RAM]+ChessBitmap+72+18,y
    813  036e
    814  036e		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    815  0371		       f0 06		      beq	.blank3
    816  0373		       59 6c f8 	      eor	ChessBitmap+72+36,y
      0  0376					      sta@RAM	ChessBitmap+72+36,y
      1  0376		       99 6c fa 	      sta	[RAM]+ChessBitmap+72+36,y
    818  0379
    819  0379		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    820  037c		       f0 06		      beq	.blank4
    821  037e		       59 7e f8 	      eor	ChessBitmap+72+54,y
      0  0381					      sta@RAM	ChessBitmap+72+54,y
      1  0381		       99 7e fa 	      sta	[RAM]+ChessBitmap+72+54,y
    823  0384
    824  0384		       88	   .blank4    dey
    825  0385		       10 d1		      bpl	.copyPieceR
    826  0387		       60		      rts
    827  0388
    828  0388							;---------------------------------------------------------------------------------------------------
    829  0388
 FREE BYTES IN BANK_FIRST@0 BANK =  $74
    830  0388					      ECHO	"FREE BYTES IN BANK_FIRST@0 BANK = ", $F3FC - *
    831  0388
    832  0388							;---------------------------------------------------------------------------------------------------
    833  0388							; The reset vectors
    834  0388							; these must live in the first 1K bank of the ROM
    835  0388
    836  0400 ????				      SEG	StartupInterruptVectors
    837  03fc					      ORG	_FIRST_BANK + $3FC
    838  03fc
    839  03fc		       00 f0		      .word.w	StartupBankReset	; RESET
    840  03fe		       00 f0		      .word.w	StartupBankReset	; IRQ	      (not used)
    841  0400
    842  0400							;---------------------------------------------------------------------------------------------------
    843  0400
    844  0400
    845  0400							; EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#1.asm LEVEL 2 PASS 4
      0  0400					      include	"BANK_GENERIC@1#1.asm"
      1  0400							; Chess
      2  0400							; Copyright (c) 2019-2020 Andrew Davie
      3  0400							; andrew@taswegian.com
      4  0400
      0  0400					      SLOT	1	; which bank this code switches to
      1  0400				  -	      IF	(1 < 0) || (1 > 3)
      2  0400				  -	      ECHO	"Illegal bank address/segment location", 1
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  0400				   _BANK_SLOT SET	1 * 64
      0  0400					      NEWBANK	ONE
      1  05dc ????				      SEG	ONE
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   ONE_START  SET	*
      6  0400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0400				   ONE	      SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + 1024
      7  0400
      8  0400
      9  0400							;---------------------------------------------------------------------------------------------------
     10  0400							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     11  0400							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     12  0400							; bank finishes.  Just continue on from where it left off...
     13  0400							;---------------------------------------------------------------------------------------------------
     14  0400
      0  0400					      DEF	CartInit
      1  0400				   SLOT_CartInit SET	_BANK_SLOT
      2  0400				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0400				   CartInit
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	CartInit
     16  0400					      SUBROUTINE
     17  0400
      0  0400					      REFER	StartupBankReset	;✅
      1  0400				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0400				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0400					      ENDIF
     19  0400
      0  0400					      VEND	CartInit
      1  0400				  -	      IFNCONST	CartInit
      2  0400				  -	      ECHO	"Incorrect VEND label", CartInit
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400		       00 a7	   VAREND_CartInit =	TEMPORARY_VAR
     21  0400
     22  0400		       78		      sei
     23  0401		       d8		      cld
     24  0402							; See if we can come up with something 'random' for startup
     25  0402
     26  0402		       ac 84 02 	      ldy	INTIM
     27  0405		       d0 02		      bne	.toR
     28  0407		       a0 9a		      ldy	#$9A
     29  0409		       84 81	   .toR       sty	rnd
     30  040b
     31  040b		       a9 1f		      lda	#31
     32  040d		       85 a2		      sta	randomness
     33  040f
     34  040f		       a9 00		      lda	#0
     35  0411		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     36  0414		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     37  0417		       85 6b		      sta	HMCLR
     38  0419
     39  0419							; cleanup remains of title screen
     40  0419							;sta GRP0
     41  0419							;sta GRP1
     42  0419
     43  0419		       a9 07		      lda	#%111
     44  041b		       85 44		      sta	NUSIZ0
     45  041d		       85 45		      sta	NUSIZ1	; quad-width
     46  041f
     47  041f							;lda #%00000100
     48  041f							;sta CTRLPF
     49  041f		       a9 00		      lda	#BACKGCOL
     50  0421		       85 49		      sta	COLUBK
     51  0423
     52  0423
     53  0423		       a9 00		      lda	#WHITE	;tmp+RAMBANK_PLY
     54  0425		       85 95		      sta	sideToMove
     55  0427
     56  0427		       60		      rts
     57  0428
     58  0428
     59  0428							;---------------------------------------------------------------------------------------------------
     60  0428
      0  0428					      DEF	SetupBanks
      1  0428				   SLOT_SetupBanks SET	_BANK_SLOT
      2  0428				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  0428				   SetupBanks
      4  0428				   TEMPORARY_VAR SET	Overlay
      5  0428				   TEMPORARY_OFFSET SET	0
      6  0428				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  0428				   FUNCTION_NAME SET	SetupBanks
     62  0428					      SUBROUTINE
     63  0428
     64  0428							; Move a copy of the row bank template to the first 8 banks of RAM
     65  0428							; and then terminate the draw subroutine by substituting in a RTS on the last one
     66  0428
      0  0428					      REFER	StartupBankReset	;✅
      1  0428				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0428				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0428					      ENDIF
      0  0428					      VEND	SetupBanks
      1  0428				  -	      IFNCONST	SetupBanks
      2  0428				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  0428				  -	      ERR
      4  0428					      ENDIF
      5  0428		       00 a7	   VAREND_SetupBanks =	TEMPORARY_VAR
     69  0428
     70  0428							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     71  0428
     72  0428				   .ROWBANK   SET	0
     73  0428					      REPEAT	8
     74  0428		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  042a		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     76  042c		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  042c				   .ROWBANK   SET	.ROWBANK+1
     73  042c					      REPEND
     74  042f		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  0431		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     76  0433		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  0433				   .ROWBANK   SET	.ROWBANK+1
     73  0433					      REPEND
     74  0436		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  0438		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     76  043a		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  043a				   .ROWBANK   SET	.ROWBANK+1
     73  043a					      REPEND
     74  043d		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  043f		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     76  0441		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  0441				   .ROWBANK   SET	.ROWBANK+1
     73  0441					      REPEND
     74  0444		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  0446		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     76  0448		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  0448				   .ROWBANK   SET	.ROWBANK+1
     73  0448					      REPEND
     74  044b		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  044d		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     76  044f		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  044f				   .ROWBANK   SET	.ROWBANK+1
     73  044f					      REPEND
     74  0452		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  0454		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     76  0456		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  0456				   .ROWBANK   SET	.ROWBANK+1
     73  0456					      REPEND
     74  0459		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  045b		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     76  045d		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  045d				   .ROWBANK   SET	.ROWBANK+1
     78  0460					      REPEND
     79  0460
     80  0460
     81  0460							; Patch the final row's "loop" to a RTS
     82  0460
     83  0460		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     84  0462		       86 3e		      stx	SET_BANK_RAM
     85  0464		       a9 60		      lda	#$60	; "rts"
      0  0466					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0466		       8d 00 fb 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     87  0469
     88  0469
     89  0469
     90  0469							; copy the BOARD/MOVES bank
     91  0469
     92  0469		       a2 84		      ldx	#SHADOW_BOARD
     93  046b		       a0 d1		      ldy	#RAMBANK_BOARD
     94  046d		       20 71 f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
     95  0470
     96  0470
     97  0470							; copy the PLY banks
     98  0470							; If there's no content (only variable decs) then we don't really need to do this.
     99  0470
    100  0470							;.PLY SET 0
    101  0470							;    REPEAT PLY_BANKS
    102  0470
    103  0470							;		      ldx #SHADOW_PLY
    104  0470							;		      ldy #RAMBANK_PLY + .PLY
    105  0470							;jsr CopyShadowROMtoRAM
    106  0470							;.PLY SET .PLY + 1
    107  0470							;    REPEND
    108  0470
    109  0470							; copy the evaluation code/tables
    110  0470							; 3E+ moved from RAM to ROM
    111  0470
    112  0470							;		      ldx #[SLOT2] + SHADOW_EVAL
    113  0470							;		      ldy #[SLOT3] + EVAL
    114  0470							;		      jsr CopyShadowROMtoRAM
    115  0470
    116  0470
    117  0470							;		      ldy #RAMBANK_RAM_PIECELIST
    118  0470							;		      ldx #ROM_PIECELIST
    119  0470							;		      jsr CopyShadowROMtoRAM
    120  0470
    121  0470		       60		      rts
    122  0471
    123  0471
    124  0471							;---------------------------------------------------------------------------------------------------
    125  0471
      0  0471					      DEF	CopyShadowROMtoRAM
      1  0471				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  0471				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  0471				   CopyShadowROMtoRAM
      4  0471				   TEMPORARY_VAR SET	Overlay
      5  0471				   TEMPORARY_OFFSET SET	0
      6  0471				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  0471				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    127  0471					      SUBROUTINE
    128  0471
      0  0471					      REFER	SetupBanks	;✅
      1  0471				  -	      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  0471				  -TEMPORARY_VAR SET	VAREND_SetupBanks
      3  0471					      ENDIF
    130  0471
      0  0471					      VEND	CopyShadowROMtoRAM
      1  0471				  -	      IFNCONST	CopyShadowROMtoRAM
      2  0471				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  0471				  -	      ERR
      4  0471					      ENDIF
      5  0471		       00 a7	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    132  0471
    133  0471							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    134  0471							; used to setup callable RAM code from ROM templates
    135  0471
    136  0471							; x = source ROM bank
    137  0471							; y = destination RAM bank (preserved)
    138  0471
    139  0471		       86 3f		      stx	SET_BANK
    140  0473		       84 3e		      sty	SET_BANK_RAM
    141  0475
    142  0475		       a2 00		      ldx	#0
    143  0477		       bd 00 f8    .copyPage  lda	$F800,x
      0  047a					      sta@RAM	$FC00,x
      1  047a		       9d 00 fe 	      sta	[RAM]+$FC00,x
    145  047d		       bd 00 f9 	      lda	$F900,x
      0  0480					      sta@RAM	$FD00,x
      1  0480		       9d 00 ff 	      sta	[RAM]+$FD00,x
    147  0483		       ca		      dex
    148  0484		       d0 f1		      bne	.copyPage
    149  0486		       60		      rts
    150  0487
    151  0487
    152  0487							;---------------------------------------------------------------------------------------------------
    153  0487
      0  0487					      DEF	CallClear
      1  0487				   SLOT_CallClear SET	_BANK_SLOT
      2  0487				   BANK_CallClear SET	SLOT_CallClear + _CURRENT_BANK
      3  0487				   CallClear
      4  0487				   TEMPORARY_VAR SET	Overlay
      5  0487				   TEMPORARY_OFFSET SET	0
      6  0487				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      7  0487				   FUNCTION_NAME SET	CallClear
    155  0487					      SUBROUTINE
    156  0487
    157  0487				  -	      IF	0
    158  0487				  -	      REFER	aiClearEachRow	;TODO
    159  0487					      ENDIF
    160  0487
      0  0487					      VEND	CallClear
      1  0487				  -	      IFNCONST	CallClear
      2  0487				  -	      ECHO	"Incorrect VEND label", CallClear
      3  0487				  -	      ERR
      4  0487					      ENDIF
      5  0487		       00 a7	   VAREND_CallClear =	TEMPORARY_VAR
    162  0487
    163  0487				  -	      IF	0
    164  0487				  -			; No transient variable dependencies/calls
    165  0487				  -
    166  0487				  -	      sty	SET_BANK_RAM
    167  0487				  -	      jsr	ClearRowBitmap
    168  0487					      ENDIF
    169  0487		       60		      rts
    170  0488
    171  0488
    172  0488							;---------------------------------------------------------------------------------------------------
    173  0488
      0  0488					      DEF	InitialisePieceSquares
      1  0488				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  0488				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  0488				   InitialisePieceSquares
      4  0488				   TEMPORARY_VAR SET	Overlay
      5  0488				   TEMPORARY_OFFSET SET	0
      6  0488				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  0488				   FUNCTION_NAME SET	InitialisePieceSquares
    175  0488					      SUBROUTINE
    176  0488
      0  0488					      COMMON_VARS
      1  0488
      0  0488					      VAR	__thinkbar, 1
      1  0488		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__toggle, 1
      1  0488		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      4  0488
      0  0488					      VAR	__bestMove, 1
      1  0488		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__alpha, 2
      1  0488		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__beta, 2
      1  0488		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__negaMax, 2
      1  0488		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__value, 2
      1  0488		       00 b0	   __value    =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
     10  0488
      0  0488					      VAR	__quiesceCapOnly, 1
      1  0488		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
     12  0488
      0  0488					      VAR	__originalPiece, 1
      1  0488		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__capturedPiece, 1
      1  0488		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
     15  0488
      0  0488					      REFER	StartupBankReset	;✅
      1  0488				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0488				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0488					      ENDIF
    179  0488
      0  0488					      VAR	__initPiece, 1
      1  0488		       00 b5	   __initPiece =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__initSquare, 1
      1  0488		       00 b6	   __initSquare =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__initListPtr, 1
      1  0488		       00 b7	   __initListPtr =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__op, 1
      1  0488		       00 b8	   __op       =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __op, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
    184  0488
      0  0488					      VEND	InitialisePieceSquares
      1  0488				  -	      IFNCONST	InitialisePieceSquares
      2  0488				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  0488				  -	      ERR
      4  0488					      ENDIF
      5  0488		       00 b9	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    186  0488
    187  0488		       a9 00		      lda	#0
    188  048a		       85 8f		      sta	Evaluation
    189  048c		       85 90		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    190  048e		       85 93		      sta	enPassantPawn	; no en-passant
    191  0490
    192  0490
      0  0490					      PHASE	AI_StartClearBoard
      1  0490		       a9 0d		      lda	#AI_StartClearBoard
      2  0492		       85 8b		      sta	aiState
    194  0494
    195  0494		       a2 00		      ldx	#0
    196  0496				   .fillPieceLists
    197  0496
    198  0496
    199  0496		       bd e8 f4 	      lda	InitPieceList,x	; colour/-1
    200  0499		       f0 4c		      beq	.exit
    201  049b		       85 b8		      sta	__op	; type
    202  049d		       bc e9 f4 	      ldy	InitPieceList+1,x	; square
    203  04a0		       84 b6		      sty	__initSquare
    204  04a2
    205  04a2		       a9 d1		      lda	#RAMBANK_BOARD
    206  04a4		       85 3e		      sta	SET_BANK_RAM
    207  04a6		       a5 b8		      lda	__op
      0  04a8					      sta@RAM	Board,y
      1  04a8		       99 79 fe 	      sta	[RAM]+Board,y
    209  04ab		       10 0d		      bpl	.white
    210  04ad
      0  04ad					      NEGEVAL
      1  04ad
      2  04ad		       38		      sec
      3  04ae		       a9 00		      lda	#0
      4  04b0		       e5 8f		      sbc	Evaluation
      5  04b2		       85 8f		      sta	Evaluation
      6  04b4		       a9 00		      lda	#0
      7  04b6		       e5 90		      sbc	Evaluation+1
      8  04b8		       85 90		      sta	Evaluation+1
    212  04ba				   .white
    213  04ba
    214  04ba		       86 b7		      stx	__initListPtr
    215  04bc
    216  04bc							; Add the material value of the piece to the evaluation
    217  04bc
    218  04bc		       a5 b8		      lda	__op
    219  04be		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    220  04c0		       86 3f		      stx	SET_BANK	;@2
    221  04c2		       20 11 f9 	      jsr	AddPieceMaterialValue
    222  04c5
    223  04c5
    224  04c5							; add the positional value of the piece to the evaluation
    225  04c5
    226  04c5		       a4 b6		      ldy	__initSquare
    227  04c7		       a5 b8		      lda	__op
    228  04c9		       a2 91		      ldx	#BANK_AddPiecePositionValue
    229  04cb		       86 3f		      stx	SET_BANK
    230  04cd		       20 34 f9 	      jsr	AddPiecePositionValue
    231  04d0
    232  04d0		       a5 b8		      lda	__op	; type/colour
    233  04d2		       10 0d		      bpl	.white2
      0  04d4					      NEGEVAL
      1  04d4
      2  04d4		       38		      sec
      3  04d5		       a9 00		      lda	#0
      4  04d7		       e5 8f		      sbc	Evaluation
      5  04d9		       85 8f		      sta	Evaluation
      6  04db		       a9 00		      lda	#0
      7  04dd		       e5 90		      sbc	Evaluation+1
      8  04df		       85 90		      sta	Evaluation+1
    235  04e1				   .white2
    236  04e1
    237  04e1		       a6 b7		      ldx	__initListPtr
    238  04e3		       e8		      inx
    239  04e4		       e8		      inx
    240  04e5		       10 af		      bpl	.fillPieceLists
    241  04e7
    242  04e7				   .exit
    243  04e7		       60		      rts
    244  04e8
    245  04e8
    246  04e8				   InitPieceList
    247  04e8
    248  04e8
    249  04e8				  -	      IF	!TEST_POSITION
    250  04e8				  -
    251  04e8				  -	      .byte	WHITE|Q, 25
    252  04e8				  -	      .byte	WHITE|B, 24
    253  04e8				  -	      .byte	WHITE|B, 27
    254  04e8				  -	      .byte	WHITE|R, 22
    255  04e8				  -	      .byte	WHITE|R, 29
    256  04e8				  -	      .byte	WHITE|N, 23
    257  04e8				  -	      .byte	WHITE|N, 28
    258  04e8				  -
    259  04e8				  -	      .byte	WHITE|WP, 35
    260  04e8				  -	      .byte	WHITE|WP, 36
    261  04e8				  -	      .byte	WHITE|WP, 34
    262  04e8				  -	      .byte	WHITE|WP, 37
    263  04e8				  -	      .byte	WHITE|WP, 33
    264  04e8				  -	      .byte	WHITE|WP, 38
    265  04e8				  -	      .byte	WHITE|WP, 32
    266  04e8				  -	      .byte	WHITE|WP, 39
    267  04e8				  -
    268  04e8				  -	      .byte	WHITE|K, 26
    269  04e8				  -
    270  04e8				  -	      .byte	BLACK|Q, 95
    271  04e8				  -	      .byte	BLACK|B, 94
    272  04e8				  -	      .byte	BLACK|B, 97
    273  04e8				  -	      .byte	BLACK|R, 92
    274  04e8				  -	      .byte	BLACK|R, 99
    275  04e8				  -	      .byte	BLACK|N, 93
    276  04e8				  -	      .byte	BLACK|N, 98
    277  04e8				  -
    278  04e8				  -	      .byte	BLACK|BP, 85
    279  04e8				  -	      .byte	BLACK|BP, 86
    280  04e8				  -	      .byte	BLACK|BP, 84
    281  04e8				  -	      .byte	BLACK|BP, 87
    282  04e8				  -	      .byte	BLACK|BP, 83
    283  04e8				  -	      .byte	BLACK|BP, 88
    284  04e8				  -	      .byte	BLACK|BP, 82
    285  04e8				  -	      .byte	BLACK|BP, 89
    286  04e8				  -
    287  04e8				  -	      .byte	BLACK|K, 96
    288  04e8				  -
    289  04e8				  -	      .byte	0	;end
    290  04e8				  -
    291  04e8					      ELSE		; test position...
    292  04e8
    293  04e8				  -	      IF	0
    294  04e8				  -			; make sure illegal moves leaving K in check are removed
    295  04e8				  -
    296  04e8				  -	      .byte	WHITE|N, 28
    297  04e8				  -	      .byte	WHITE|K, 26
    298  04e8				  -
    299  04e8				  -	      .byte	BLACK|Q, 29
    300  04e8				  -
    301  04e8				  -	      .byte	0	;end
    302  04e8				  -
    303  04e8					      ENDIF
    304  04e8
    305  04e8				  -	      IF	0
    306  04e8				  -
    307  04e8				  -	      .byte	WHITE|K, 28
    308  04e8				  -	      .byte	WHITE|WP, 37
    309  04e8				  -	      .byte	WHITE|WP, 38
    310  04e8				  -	      .byte	WHITE|WP, 53
    311  04e8				  -	      .byte	WHITE|WP, 49
    312  04e8				  -	      .byte	WHITE|WP, 32
    313  04e8				  -	      .byte	WHITE|R, 27
    314  04e8				  -	      .byte	WHITE|B, 46
    315  04e8				  -	      .byte	WHITE|R, 54
    316  04e8				  -
    317  04e8				  -	      .byte	BLACK|BP, 56
    318  04e8				  -	      .byte	BLACK|BP, 87
    319  04e8				  -	      .byte	BLACK|BP, 88
    320  04e8				  -	      .byte	BLACK|BP, 89
    321  04e8				  -	      .byte	BLACK|BP, 84
    322  04e8				  -	      .byte	BLACK|B, 66
    323  04e8				  -	      .byte	BLACK|R, 69
    324  04e8				  -	      .byte	BLACK|K, 98
    325  04e8				  -
    326  04e8				  -	      .byte	BLACK|R, 92
    327  04e8				  -
    328  04e8				  -
    329  04e8				  -
    330  04e8					      ENDIF
    331  04e8
    332  04e8					      IF	TEST_POSITION & 1
    333  04e8							; Castling across/into check
    334  04e8
    335  04e8		       07 1a		      .byte.b	WHITE|K, 26
    336  04ea		       05 1d		      .byte.b	WHITE|R, 29
    337  04ec		       84 2d		      .byte.b	BLACK|B, 45
    338  04ee		       06 48		      .byte.b	WHITE|Q, 72
    339  04f0		       83 54		      .byte.b	BLACK|N, 84
    340  04f2		       01 59		      .byte.b	WHITE|WP,89
    341  04f4
    342  04f4					      ENDIF
    343  04f4
    344  04f4
    345  04f4
    346  04f4				  -	      IF	TEST_POSITION & 0
    347  04f4				  -			; En passant test
    348  04f4				  -
    349  04f4				  -	      .byte	BLACK|BP, 88
    350  04f4				  -	      .byte	BLACK|BP, 86
    351  04f4				  -
    352  04f4				  -	      .byte	WHITE|WP, 67
    353  04f4				  -	      .byte	WHITE|K, 52
    354  04f4				  -
    355  04f4				  -
    356  04f4					      ENDIF
    357  04f4
    358  04f4				  -	      IF	TEST_POSITION & 0
    359  04f4				  -			; promote test
    360  04f4				  -
    361  04f4				  -	      .byte	BLACK|K, 22
    362  04f4				  -	      .byte	BLACK|N, 96
    363  04f4				  -
    364  04f4				  -	      .byte	WHITE|WP, 87
    365  04f4				  -	      .byte	WHITE|R,95
    366  04f4				  -	      .byte	WHITE|R,94
    367  04f4				  -	      .byte	WHITE|K, 52
    368  04f4				  -
    369  04f4				  -
    370  04f4					      ENDIF
    371  04f4
    372  04f4
    373  04f4
    374  04f4				  -	      IF	0
    375  04f4				  -
    376  04f4				  -
    377  04f4				  -			;.byte BLACK|R, 97
    378  04f4				  -	      .byte	BLACK|K, 98
    379  04f4				  -	      .byte	BLACK|BP, 87
    380  04f4				  -	      .byte	BLACK|BP, 88
    381  04f4				  -	      .byte	BLACK|BP, 89
    382  04f4				  -			;    .byte BLACK|B, 76
    383  04f4				  -
    384  04f4				  -
    385  04f4				  -	      .byte	WHITE|R,28
    386  04f4				  -	      .byte	WHITE|Q,58
    387  04f4				  -			;   .byte WHITE|N,65
    388  04f4					      ENDIF
    389  04f4
    390  04f4				  -	      IF	0
    391  04f4				  -			;.byte WHITE|WP, 56
    392  04f4				  -
    393  04f4				  -
    394  04f4				  -	      .byte	BLACK|K, 98
    395  04f4				  -
    396  04f4				  -
    397  04f4				  -	      .byte	WHITE|R,29
    398  04f4				  -	      .byte	WHITE|Q,49
    399  04f4				  -	      .byte	WHITE|N,65
    400  04f4					      ENDIF
    401  04f4		       00		      .byte.b	0	;end
    402  04f5
    403  04f5					      ENDIF
    404  04f5
    405  04f5
    406  04f5							;---------------------------------------------------------------------------------------------------
    407  04f5
    408  04f5							;---------------------------------------------------------------------------------------------------
    409  04f5
    410  04f5				  -	      IF	0
    411  04f5				  -	      DEF	SAFE_BackupBitmaps
    412  04f5				  -	      SUBROUTINE
    413  04f5				  -
    414  04f5				  -	      REFER	aiInCheckBackup
    415  04f5				  -	      VEND	SAFE_BackupBitmaps
    416  04f5				  -
    417  04f5				  -	      sty	SET_BANK_RAM
    418  04f5				  -	      jsr	SaveBitmap
    419  04f5				  -	      rts
    420  04f5					      ENDIF
    421  04f5
    422  04f5
    423  04f5							;---------------------------------------------------------------------------------------------------
    424  04f5
      0  04f5					      DEF	AddMoveSimple
      1  04f5				   SLOT_AddMoveSimple SET	_BANK_SLOT
      2  04f5				   BANK_AddMoveSimple SET	SLOT_AddMoveSimple + _CURRENT_BANK
      3  04f5				   AddMoveSimple
      4  04f5				   TEMPORARY_VAR SET	Overlay
      5  04f5				   TEMPORARY_OFFSET SET	0
      6  04f5				   VAR_BOUNDARY_AddMoveSimple SET	TEMPORARY_OFFSET
      7  04f5				   FUNCTION_NAME SET	AddMoveSimple
    426  04f5					      SUBROUTINE
    427  04f5
      0  04f5					      VEND	AddMoveSimple
      1  04f5				  -	      IFNCONST	AddMoveSimple
      2  04f5				  -	      ECHO	"Incorrect VEND label", AddMoveSimple
      3  04f5				  -	      ERR
      4  04f5					      ENDIF
      5  04f5		       00 a7	   VAREND_AddMoveSimple =	TEMPORARY_VAR
    429  04f5
    430  04f5							; add square in y register to movelist as destination (X12 format)
    431  04f5							; [y]		     to square (X12)
    432  04f5							; currentSquare     from square (X12)
    433  04f5							; currentPiece      piece.
    434  04f5							;   ENPASSANT flag set if pawn double-moving off opening rank
    435  04f5							; capture	     captured piece
    436  04f5
    437  04f5		       a5 9c		      lda	capture
    438  04f7		       d0 04		      bne	.always
    439  04f9		       a5 b2		      lda	__quiesceCapOnly
    440  04fb		       d0 1a		      bne	.abort
    441  04fd
    442  04fd		       98	   .always    tya
    443  04fe
      0  04fe					      ldy@PLY	moveIndex
      1  04fe		       ac cf f9 	      ldy	moveIndex
    445  0501		       c8		      iny
      0  0502					      sty@PLY	moveIndex
      1  0502		       8c cf fb 	      sty	[RAM]+moveIndex
    447  0505
      0  0505					      sta@PLY	MoveTo,y
      1  0505		       99 64 fa 	      sta	[RAM]+MoveTo,y
    449  0508		       a5 92		      lda	currentSquare
      0  050a					      sta@PLY	MoveFrom,y
      1  050a		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    451  050d		       a5 91		      lda	currentPiece
      0  050f					      sta@PLY	MovePiece,y
      1  050f		       99 00 fb 	      sta	[RAM]+MovePiece,y
    453  0512		       a5 9c		      lda	capture
      0  0514					      sta@PLY	MoveCapture,y
      1  0514		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    455  0517
    456  0517		       60	   .abort     rts
    457  0518
    458  0518
    459  0518							;---------------------------------------------------------------------------------------------------
    460  0518
      0  0518					      DEF	aiSpecialMoveFixup
      1  0518				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  0518				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  0518				   aiSpecialMoveFixup
      4  0518				   TEMPORARY_VAR SET	Overlay
      5  0518				   TEMPORARY_OFFSET SET	0
      6  0518				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  0518				   FUNCTION_NAME SET	aiSpecialMoveFixup
    462  0518					      SUBROUTINE
    463  0518
      0  0518					      COMMON_VARS
      1  0518
      0  0518					      VAR	__thinkbar, 1
      1  0518		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
      0  0518					      VAR	__toggle, 1
      1  0518		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
      4  0518
      0  0518					      VAR	__bestMove, 1
      1  0518		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
      0  0518					      VAR	__alpha, 2
      1  0518		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
      0  0518					      VAR	__beta, 2
      1  0518		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
      0  0518					      VAR	__negaMax, 2
      1  0518		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
      0  0518					      VAR	__value, 2
      1  0518		       00 b0	   __value    =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
     10  0518
      0  0518					      VAR	__quiesceCapOnly, 1
      1  0518		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
     12  0518
      0  0518					      VAR	__originalPiece, 1
      1  0518		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
      0  0518					      VAR	__capturedPiece, 1
      1  0518		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0518				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0518
      4  0518				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0518				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0518				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0518					      ENDIF
      8  0518				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0518				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0518				  -	      ERR
     11  0518					      ENDIF
     12  0518					      LIST	ON
     15  0518
      0  0518					      REFER	AiStateMachine	;✅
      1  0518				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0518				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0518					      ENDIF
      0  0518					      VEND	aiSpecialMoveFixup
      1  0518				  -	      IFNCONST	aiSpecialMoveFixup
      2  0518				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  0518				  -	      ERR
      4  0518					      ENDIF
      5  0518		       00 b5	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    467  0518
    468  0518		       ad 84 02 	      lda	INTIM
    469  051b		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    470  051d		       b0 01		      bcs	.cont
    471  051f		       60		      rts
    472  0520
    473  0520
    474  0520				   .cont
    475  0520
      0  0520					      PHASE	AI_DelayAfterPlaced
      1  0520		       a9 27		      lda	#AI_DelayAfterPlaced
      2  0522		       85 8b		      sta	aiState
    477  0524
    478  0524
    479  0524							; Special move fixup
    480  0524
    481  0524		       a5 94		      lda	currentPly
    482  0526		       85 3e		      sta	SET_BANK_RAM
    483  0528
    484  0528		       20 34 f5 	      jsr	CastleFixupDraw
    485  052b		       20 33 f5 	      jsr	CastleFixupDraw_ENPASSANT
    486  052e
    487  052e		       a5 85		      lda	fromX12
    488  0530		       85 80		      sta	squareToDraw
    489  0532
    490  0532		       60		      rts
    491  0533
    492  0533							;---------------------------------------------------------------------------------------------------
    493  0533
      0  0533					      DEF	CastleFixupDraw_ENPASSANT
      1  0533				   SLOT_CastleFixupDraw_ENPASSANT SET	_BANK_SLOT
      2  0533				   BANK_CastleFixupDraw_ENPASSANT SET	SLOT_CastleFixupDraw_ENPASSANT + _CURRENT_BANK
      3  0533				   CastleFixupDraw_ENPASSANT
      4  0533				   TEMPORARY_VAR SET	Overlay
      5  0533				   TEMPORARY_OFFSET SET	0
      6  0533				   VAR_BOUNDARY_CastleFixupDraw_ENPASSANT SET	TEMPORARY_OFFSET
      7  0533				   FUNCTION_NAME SET	CastleFixupDraw_ENPASSANT
    495  0533					      SUBROUTINE
    496  0533
      0  0533					      REFER	aiSpecialMoveFixup	;✅
      1  0533					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0533				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0533					      ENDIF
      0  0533					      VEND	CastleFixupDraw_ENPASSANT
      1  0533				  -	      IFNCONST	CastleFixupDraw_ENPASSANT
      2  0533				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw_ENPASSANT
      3  0533				  -	      ERR
      4  0533					      ENDIF
      5  0533		       00 b5	   VAREND_CastleFixupDraw_ENPASSANT =	TEMPORARY_VAR
    499  0533
    500  0533		       60		      rts
    501  0534
    502  0534							;---------------------------------------------------------------------------------------------------
    503  0534
      0  0534					      DEF	CastleFixupDraw
      1  0534				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  0534				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  0534				   CastleFixupDraw
      4  0534				   TEMPORARY_VAR SET	Overlay
      5  0534				   TEMPORARY_OFFSET SET	0
      6  0534				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  0534				   FUNCTION_NAME SET	CastleFixupDraw
    505  0534					      SUBROUTINE
    506  0534
      0  0534					      REFER	aiSpecialMoveFixup	;✅
      1  0534					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0534				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0534					      ENDIF
      0  0534					      VEND	CastleFixupDraw
      1  0534				  -	      IFNCONST	CastleFixupDraw
      2  0534				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  0534				  -	      ERR
      4  0534					      ENDIF
      5  0534		       00 b5	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    509  0534
    510  0534							; fixup any castling issues
    511  0534							; at this point the king has finished his two-square march
    512  0534							; based on the finish square, we determine which rook we're interacting with
    513  0534							; and generate a 'move' for the rook to position on the other side of the king
    514  0534
    515  0534
    516  0534					      IF	CASTLING_ENABLED
      0  0534					      CALL	GenCastleMoveForRook	;@3
      1  0534				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  0534				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0534				  -	      ECHO	"Cannot switch bank in use for", GenCastleMoveForRook
      4  0534				  -	      ERR
      5  0534					      ENDIF
      6  0534		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      7  0536		       85 3f		      sta	SET_BANK
      8  0538		       20 21 fc 	      jsr	GenCastleMoveForRook
    518  053b		       b0 07		      bcs	.phase
    519  053d					      ENDIF
    520  053d
      0  053d					      SWAP
      1  053d		       a5 95		      lda	sideToMove
      2  053f		       49 80		      eor	#SWAP_SIDE
      3  0541		       85 95		      sta	sideToMove
      4  0543
      5  0543
    522  0543		       60		      rts
    523  0544
    524  0544				   .phase
    525  0544
    526  0544							; in this siutation (castle, rook moving) we do not change sides yet!
    527  0544
      0  0544					      PHASE	AI_MoveIsSelected
      1  0544		       a9 14		      lda	#AI_MoveIsSelected
      2  0546		       85 8b		      sta	aiState
    529  0548		       60		      rts
    530  0549
    531  0549
    532  0549
    533  0549							;---------------------------------------------------------------------------------------------------
    534  0549
      0  0549					      DEF	aiDrawEntireBoard
      1  0549				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  0549				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  0549				   aiDrawEntireBoard
      4  0549				   TEMPORARY_VAR SET	Overlay
      5  0549				   TEMPORARY_OFFSET SET	0
      6  0549				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  0549				   FUNCTION_NAME SET	aiDrawEntireBoard
    536  0549					      SUBROUTINE
    537  0549
      0  0549					      REFER	AiStateMachine	;✅
      1  0549					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0549				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0549					      ENDIF
    539  0549
      0  0549					      VEND	aiDrawEntireBoard
      1  0549				  -	      IFNCONST	aiDrawEntireBoard
      2  0549				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  0549				  -	      ERR
      4  0549					      ENDIF
      5  0549		       00 a9	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    541  0549
    542  0549
    543  0549		       ad 84 02 	      lda	INTIM
    544  054c		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    545  054e		       90 2c		      bcc	.exit
    546  0550
    547  0550							; We use [SLOT3] for accessing board
    548  0550
    549  0550		       a9 d1		      lda	#RAMBANK_BOARD
    550  0552		       85 3e		      sta	SET_BANK_RAM
    551  0554		       a4 80		      ldy	squareToDraw
    552  0556		       b9 15 fc 	      lda	ValidSquare,y
    553  0559		       30 1d		      bmi	.isablank2
    554  055b
    555  055b		       b9 79 fc 	      lda	Board,y
    556  055e		       f0 13		      beq	.isablank
    557  0560		       48		      pha
    558  0561		       a9 00		      lda	#BLANK
      0  0563					      sta@RAM	Board,y
      1  0563		       99 79 fe 	      sta	[RAM]+Board,y
    560  0566
    561  0566							; WARNING - local variables will not survive the following call...!
    562  0566		       20 be f0 	      jsr	CopySinglePiece	;@0
    563  0569
    564  0569		       a9 d1		      lda	#RAMBANK_BOARD
    565  056b		       85 3e		      sta	SET_BANK_RAM
    566  056d
    567  056d		       a4 80		      ldy	squareToDraw
    568  056f		       68		      pla
      0  0570					      sta@RAM	Board,y
      1  0570		       99 79 fe 	      sta	[RAM]+Board,y
    570  0573
      0  0573				   .isablank  PHASE	AI_DrawPart2
      1  0573		       a9 10		      lda	#AI_DrawPart2
      2  0575		       85 8b		      sta	aiState
    572  0577		       60		      rts
    573  0578
      0  0578				   .isablank2 PHASE	AI_DrawPart3
      1  0578		       a9 11		      lda	#AI_DrawPart3
      2  057a		       85 8b		      sta	aiState
    575  057c		       60	   .exit      rts
    576  057d
    577  057d
    578  057d							;---------------------------------------------------------------------------------------------------
    579  057d
      0  057d					      DEF	aiDrawPart2
      1  057d				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  057d				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  057d				   aiDrawPart2
      4  057d				   TEMPORARY_VAR SET	Overlay
      5  057d				   TEMPORARY_OFFSET SET	0
      6  057d				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  057d				   FUNCTION_NAME SET	aiDrawPart2
    581  057d					      SUBROUTINE
    582  057d
      0  057d					      REFER	AiStateMachine
      1  057d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  057d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  057d					      ENDIF
      0  057d					      VEND	aiDrawPart2
      1  057d				  -	      IFNCONST	aiDrawPart2
      2  057d				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  057d				  -	      ERR
      4  057d					      ENDIF
      5  057d		       00 a9	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
    585  057d
    586  057d							; WARNING - local variables will not survive the following call...!
    587  057d		       20 be f0 	      jsr	CopySinglePiece	;@0
    588  0580
      0  0580					      DEF	aiDrawPart3
      1  0580				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  0580				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  0580				   aiDrawPart3
      4  0580				   TEMPORARY_VAR SET	Overlay
      5  0580				   TEMPORARY_OFFSET SET	0
      6  0580				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  0580				   FUNCTION_NAME SET	aiDrawPart3
    590  0580					      SUBROUTINE
    591  0580
    592  0580		       c6 80		      dec	squareToDraw
    593  0582		       a5 80		      lda	squareToDraw
    594  0584		       c9 16		      cmp	#22
    595  0586		       90 05		      bcc	.comp
    596  0588
      0  0588					      PHASE	AI_DrawEntireBoard
      1  0588		       a9 0f		      lda	#AI_DrawEntireBoard
      2  058a		       85 8b		      sta	aiState
    598  058c		       60		      rts
    599  058d
    600  058d				   .comp
    601  058d
    602  058d		       a9 ff		      lda	#-1
    603  058f		       85 86		      sta	toX12	; becomes startup flash square
    604  0591		       a9 24		      lda	#36	; becomes cursor position
    605  0593		       85 87		      sta	originX12
    606  0595
    607  0595
      0  0595					      PHASE	AI_GenerateMoves
      1  0595		       a9 12		      lda	#AI_GenerateMoves
      2  0597		       85 8b		      sta	aiState
    609  0599		       60		      rts
    610  059a
    611  059a
    612  059a							;---------------------------------------------------------------------------------------------------
    613  059a
      0  059a					      DEF	aiMarchB
      1  059a				   SLOT_aiMarchB SET	_BANK_SLOT
      2  059a				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  059a				   aiMarchB
      4  059a				   TEMPORARY_VAR SET	Overlay
      5  059a				   TEMPORARY_OFFSET SET	0
      6  059a				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  059a				   FUNCTION_NAME SET	aiMarchB
    615  059a					      SUBROUTINE
    616  059a
      0  059a					      REFER	AiStateMachine
      1  059a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  059a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  059a					      ENDIF
      0  059a					      VEND	aiMarchB
      1  059a				  -	      IFNCONST	aiMarchB
      2  059a				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  059a				  -	      ERR
      4  059a					      ENDIF
      5  059a		       00 a9	   VAREND_aiMarchB =	TEMPORARY_VAR
    619  059a
    620  059a							; Draw the piece in the new square
    621  059a
    622  059a		       a5 85		      lda	fromX12
    623  059c		       85 80		      sta	squareToDraw
    624  059e
    625  059e							; WARNING - local variables will not survive the following call...!
    626  059e		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
    627  05a1
    628  05a1		       a9 02		      lda	#2	; snail trail delay
    629  05a3		       85 82		      sta	drawDelay
    630  05a5
      0  05a5					      PHASE	AI_MarchToTargetB
      1  05a5		       a9 19		      lda	#AI_MarchToTargetB
      2  05a7		       85 8b		      sta	aiState
    632  05a9		       60		      rts
    633  05aa
    634  05aa
    635  05aa							;---------------------------------------------------------------------------------------------------
    636  05aa
      0  05aa					      DEF	aiDraw
      1  05aa				   SLOT_aiDraw SET	_BANK_SLOT
      2  05aa				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  05aa				   aiDraw
      4  05aa				   TEMPORARY_VAR SET	Overlay
      5  05aa				   TEMPORARY_OFFSET SET	0
      6  05aa				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  05aa				   FUNCTION_NAME SET	aiDraw
    638  05aa					      SUBROUTINE
    639  05aa		       a9 c0		      lda	#$C0
    640  05ac		       85 49		      sta	COLUBK
    641  05ae		       60		      rts
    642  05af
    643  05af
    644  05af							;---------------------------------------------------------------------------------------------------
    645  05af
      0  05af					      DEF	aiCheckMate
      1  05af				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  05af				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  05af				   aiCheckMate
      4  05af				   TEMPORARY_VAR SET	Overlay
      5  05af				   TEMPORARY_OFFSET SET	0
      6  05af				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  05af				   FUNCTION_NAME SET	aiCheckMate
    647  05af					      SUBROUTINE
    648  05af		       a9 44		      lda	#$44
    649  05b1		       85 49		      sta	COLUBK
    650  05b3		       60		      rts
    651  05b4
    652  05b4
    653  05b4							;---------------------------------------------------------------------------------------------------
    654  05b4
      0  05b4					      DEF	aiQuiescent
      1  05b4				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  05b4				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  05b4				   aiQuiescent
      4  05b4				   TEMPORARY_VAR SET	Overlay
      5  05b4				   TEMPORARY_OFFSET SET	0
      6  05b4				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  05b4				   FUNCTION_NAME SET	aiQuiescent
    656  05b4					      SUBROUTINE
    657  05b4
      0  05b4					      REFER	AiStateMachine
      1  05b4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  05b4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  05b4					      ENDIF
      0  05b4					      VEND	aiQuiescent
      1  05b4				  -	      IFNCONST	aiQuiescent
      2  05b4				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  05b4				  -	      ERR
      4  05b4					      ENDIF
      5  05b4		       00 a9	   VAREND_aiQuiescent =	TEMPORARY_VAR
    660  05b4
    661  05b4							; Move has been selected
    662  05b4
    663  05b4		       a9 ff		      lda	#-1
    664  05b6		       85 88		      sta	cursorX12
    665  05b8
    666  05b8		       a5 85		      lda	fromX12
    667  05ba		       85 87		      sta	originX12
      0  05bc					      CALL	GetPiece	;@3		    ; from the movelist
      1  05bc				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  05bc				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  05bc				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  05bc				  -	      ERR
      5  05bc					      ENDIF
      6  05bc		       a9 d9		      lda	#BANK_GetPiece
      7  05be		       85 3f		      sta	SET_BANK
      8  05c0		       20 00 fc 	      jsr	GetPiece
    669  05c3
    670  05c3		       a4 85		      ldy	fromX12
    671  05c5		       a9 d1		      lda	#RAMBANK_BOARD
    672  05c7		       85 3e		      sta	SET_BANK_RAM	;@3
    673  05c9		       b9 79 fc 	      lda	Board,y
    674  05cc		       45 96		      eor	fromPiece
    675  05ce		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    676  05d0		       d0 05		      bne	.promote	; promote a pawn
    677  05d2
      0  05d2					      PHASE	AI_MoveIsSelected
      1  05d2		       a9 14		      lda	#AI_MoveIsSelected
      2  05d4		       85 8b		      sta	aiState
    679  05d6		       60		      rts
    680  05d7
      0  05d7				   .promote   PHASE	AI_PromotePawnStart
      1  05d7		       a9 1f		      lda	#AI_PromotePawnStart
      2  05d9		       85 8b		      sta	aiState
    682  05db		       60		      rts
    683  05dc
    684  05dc
    685  05dc							;---------------------------------------------------------------------------------------------------
    686  05dc
      0  05dc					      CHECK_BANK_SIZE	"BANK_GENERIC@1#1"
      1  05dc		       01 dc	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@1#1 (1K) SIZE =  $1dc , FREE= $224
      2  05dc					      ECHO	"BANK_GENERIC@1#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  05dc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  05dc				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@1#1", " size=", * - ORIGIN
      5  05dc				  -	      ERR
      6  05dc					      ENDIF
    688  05dc
    689  05dc							;---------------------------------------------------------------------------------------------------
    690  05dc							; EOF
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 4
      0  05dc					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  05dc
      0  05dc					      SLOT	2
      1  05dc				  -	      IF	(2 < 0) || (2 > 3)
      2  05dc				  -	      ECHO	"Illegal bank address/segment location", 2
      3  05dc				  -	      ERR
      4  05dc					      ENDIF
      5  05dc				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  05dc				   _BANK_SLOT SET	2 * 64
      0  05dc					      NEWBANK	BITMAP
      1  09a6 ????				      SEG	BITMAP
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   BITMAP_START SET	*
      6  0800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0800				   BITMAP     SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + 1024
      4  0800
      5  0800							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
      6  0800
      7  0800		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
      8  0800
      9  0800		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     10  0800		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     11  0800		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     12  0800		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     13  0800		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     14  0800		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     15  0800
     16  0800							; Template bank for a SINGLE ROW of the chessboard display.
     17  0800							; There are 8x of these.
     18  0800							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     19  0800							; The bank is copied from ROM into RAM at startup.
     20  0800							; The draw switches between consecutive row banks, with the last returning
     21  0800							; we effectively have 1K
     22  0800							;---------------------------------------------------------------------------------------------------
     23  0800
     24  0800		       00 84	   COLOUR_LINE_1 =	$84
     25  0800		       00 36	   COLOUR_LINE_2 =	$36
     26  0800		       00 28	   COLOUR_LINE_3 =	$28
     27  0800		       00 00	   BACKGCOL   =	$00
     28  0800
     29  0800
     30  0800		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     31  0800
     32  0800
      0  0800					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      0  0800					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0800					      LIST	ON
      0  0800					      DEF	SHADOW_ChessBitmap
      1  0800				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  0800				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  0800				   SHADOW_ChessBitmap
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	SHADOW_ChessBitmap
     34  0800		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     35  0818		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     36  0830		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     37  0848		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     38  0860		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     39  0878		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     40  0890
      0  0890					      ALLOCATE	BlankSprite, 8
      0  0890					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0890					      LIST	ON
      0  0890					      DEF	BlankSprite
      1  0890				   SLOT_BlankSprite SET	_BANK_SLOT
      2  0890				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  0890				   BlankSprite
      4  0890				   TEMPORARY_VAR SET	Overlay
      5  0890				   TEMPORARY_OFFSET SET	0
      6  0890				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  0890				   FUNCTION_NAME SET	BlankSprite
     42  0890		       00 00 00 00*	      ds	8, 0
     43  0898
      0  0898					      ALLOCATE	SpriteBuffer, 8
      0  0898					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0898					      LIST	ON
      0  0898					      DEF	SpriteBuffer
      1  0898				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  0898				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  0898				   SpriteBuffer
      4  0898				   TEMPORARY_VAR SET	Overlay
      5  0898				   TEMPORARY_OFFSET SET	0
      6  0898				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  0898				   FUNCTION_NAME SET	SpriteBuffer
     45  0898				   SpriteBuffer2
     46  0898		       f8		      .byte.b	%11111000
     47  0899		       f8		      .byte.b	%11111000
     48  089a		       f8		      .byte.b	%11111000
     49  089b		       f8		      .byte.b	%11111000
     50  089c		       f8		      .byte.b	%11111000
     51  089d		       f8		      .byte.b	%11111000
     52  089e		       f8		      .byte.b	%11111000
     53  089f		       f8		      .byte.b	%11111000
     54  08a0
     55  08a0				  -	      IF	0
     56  08a0				  -	      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
     57  08a0				  -	      ds	ROW_BITMAP_SIZE, 0
     58  08a0					      ENDIF
     59  08a0
     60  08a0							;---------------------------------------------------------------------------------------------------
     61  08a0
     62  0900		       00 00 00 00*	      ALIGN	256
     63  0900					      SUBROUTINE
     64  0900
      0  0900					      REFER	StartupBankReset
      1  0900				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0900				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0900					      ENDIF
     66  0900				   __dummy
      0  0900					      VEND	__dummy
      1  0900				  -	      IFNCONST	__dummy
      2  0900				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0900				  -	      ERR
      4  0900					      ENDIF
      5  0900		       00 a7	   VAREND___dummy =	TEMPORARY_VAR
     68  0900
     69  0900							; x = row # (and bank#)
     70  0900
     71  0900				   .endline
     72  0900
     73  0900							;@59
     74  0900
     75  0900							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
     76  0900							; Note that the other 7 row banks are unmodified (keeping the 'inx')
     77  0900				   SELFMOD_RTS_ON_LAST_ROW
     78  0900
     79  0900		       e8		      inx		; 2
     80  0901		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
     81  0903
      0  0903					      DEF	DrawRow
      1  0903				   SLOT_DrawRow SET	_BANK_SLOT
      2  0903				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  0903				   DrawRow
      4  0903				   TEMPORARY_VAR SET	Overlay
      5  0903				   TEMPORARY_OFFSET SET	0
      6  0903				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  0903				   FUNCTION_NAME SET	DrawRow
     83  0903
     84  0903							;@64
     85  0903		       a0 07		      ldy	#7	; 2
     86  0905		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
     87  0907
     88  0907							;@58...
     89  0907
     90  0907				   .l3
     91  0907
     92  0907		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
     93  090a		       85 5b		      sta	GRP0	; 3
     94  090c		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
     95  090f		       85 5c		      sta	GRP1	; 3
     96  0911
     97  0911							;@-4
     98  0911
     99  0911		       a9 84		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    100  0913		       85 48		      sta	COLUPF	; 3 @1
    101  0915
    102  0915		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    103  0918		       85 4d		      sta	PF0	; 3
    104  091a		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    105  091d		       85 4e		      sta	PF1	; 3
    106  091f		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    107  0922		       85 4f		      sta	PF2	; 3 @22
    108  0924
      0  0924					      SLEEP	6	; 6 @28
      1  0924				   .CYCLES    SET	6
      2  0924
      3  0924				  -	      IF	.CYCLES < 2
      4  0924				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0924				  -	      ERR
      6  0924					      ENDIF
      7  0924
      8  0924				  -	      IF	.CYCLES & 1
      9  0924				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0924				  -	      nop	0
     11  0924				  -	      ELSE
     12  0924				  -	      bit	VSYNC
     13  0924				  -	      ENDIF
     14  0924				  -.CYCLES    SET	.CYCLES - 3
     15  0924					      ENDIF
     16  0924
     17  0924					      REPEAT	.CYCLES / 2
     18  0924		       ea		      nop
     17  0924					      REPEND
     18  0925		       ea		      nop
     17  0925					      REPEND
     18  0926		       ea		      nop
     19  0927					      REPEND
    110  0927
    111  0927		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    112  092a		       85 4d		      sta	PF0	; 3
    113  092c		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    114  092f		       85 4e		      sta	PF1	; 3
    115  0931		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    116  0934		       8d 4f 00 	      sta.w	PF2	; 4 @50
    117  0937
      0  0937					      SLEEP	4	; 4
      1  0937				   .CYCLES    SET	4
      2  0937
      3  0937				  -	      IF	.CYCLES < 2
      4  0937				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0937				  -	      ERR
      6  0937					      ENDIF
      7  0937
      8  0937				  -	      IF	.CYCLES & 1
      9  0937				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0937				  -	      nop	0
     11  0937				  -	      ELSE
     12  0937				  -	      bit	VSYNC
     13  0937				  -	      ENDIF
     14  0937				  -.CYCLES    SET	.CYCLES - 3
     15  0937					      ENDIF
     16  0937
     17  0937					      REPEAT	.CYCLES / 2
     18  0937		       ea		      nop
     17  0937					      REPEND
     18  0938		       ea		      nop
     19  0939					      REPEND
    119  0939
    120  0939		       88		      dey		; 2
    121  093a		       30 c4		      bmi	.endline	; 2 (3)
    122  093c
    123  093c							;@57
    124  093c				   .drawLine
    125  093c
      0  093c					      SLEEP	11
      1  093c				   .CYCLES    SET	11
      2  093c
      3  093c				  -	      IF	.CYCLES < 2
      4  093c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  093c				  -	      ERR
      6  093c					      ENDIF
      7  093c
      8  093c					      IF	.CYCLES & 1
      9  093c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  093c		       04 00		      nop	0
     11  093e				  -	      ELSE
     12  093e				  -	      bit	VSYNC
     13  093e					      ENDIF
     14  093e				   .CYCLES    SET	.CYCLES - 3
     15  093e					      ENDIF
     16  093e
     17  093e					      REPEAT	.CYCLES / 2
     18  093e		       ea		      nop
     17  093e					      REPEND
     18  093f		       ea		      nop
     17  093f					      REPEND
     18  0940		       ea		      nop
     17  0940					      REPEND
     18  0941		       ea		      nop
     19  0942					      REPEND
    127  0942
    128  0942				   .dl2
    129  0942		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    130  0945		       85 5b		      sta	GRP0	; 3
    131  0947		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    132  094a		       85 5c		      sta	GRP1	; 3
    133  094c
    134  094c							;@7
    135  094c
    136  094c		       a9 36		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    137  094e		       85 48		      sta	COLUPF	; 3 @12
    138  0950
    139  0950		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    140  0953		       85 4d		      sta	PF0	; 3
    141  0955		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    142  0958		       85 4e		      sta	PF1	; 3
    143  095a		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    144  095d		       85 4f		      sta	PF2	; 3 @33
    145  095f
      0  095f					      SLEEP	3	; 3 @36
      1  095f				   .CYCLES    SET	3
      2  095f
      3  095f				  -	      IF	.CYCLES < 2
      4  095f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  095f				  -	      ERR
      6  095f					      ENDIF
      7  095f
      8  095f					      IF	.CYCLES & 1
      9  095f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  095f		       04 00		      nop	0
     11  0961				  -	      ELSE
     12  0961				  -	      bit	VSYNC
     13  0961					      ENDIF
     14  0961				   .CYCLES    SET	.CYCLES - 3
     15  0961					      ENDIF
     16  0961
     17  0961				  -	      REPEAT	.CYCLES / 2
     18  0961				  -	      nop
     19  0961					      REPEND
    147  0961
    148  0961		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    149  0964		       85 4d		      sta	PF0	; 3
    150  0966		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    151  0969		       85 4e		      sta	PF1	; 3
    152  096b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    153  096e		       85 4f		      sta	PF2	; 3 @57
    154  0970
      0  0970					      SLEEP	5
      1  0970				   .CYCLES    SET	5
      2  0970
      3  0970				  -	      IF	.CYCLES < 2
      4  0970				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0970				  -	      ERR
      6  0970					      ENDIF
      7  0970
      8  0970					      IF	.CYCLES & 1
      9  0970					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0970		       04 00		      nop	0
     11  0972				  -	      ELSE
     12  0972				  -	      bit	VSYNC
     13  0972					      ENDIF
     14  0972				   .CYCLES    SET	.CYCLES - 3
     15  0972					      ENDIF
     16  0972
     17  0972					      REPEAT	.CYCLES / 2
     18  0972		       ea		      nop
     19  0973					      REPEND
    156  0973
    157  0973		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    158  0976		       85 5b		      sta	GRP0	; 3
    159  0978		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    160  097b		       85 5c		      sta	GRP1	; 3
    161  097d
    162  097d							;@0
    163  097d		       a9 28		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    164  097f		       85 48		      sta	COLUPF	; 3 @5
    165  0981
    166  0981		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    167  0984		       85 4d		      sta	PF0	; 3
    168  0986		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    169  0989		       85 4e		      sta	PF1	; 3
    170  098b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    171  098e		       85 4f		      sta	PF2	; 3 @26
    172  0990
      0  0990					      SLEEP	8	; 6 @34
      1  0990				   .CYCLES    SET	8
      2  0990
      3  0990				  -	      IF	.CYCLES < 2
      4  0990				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0990				  -	      ERR
      6  0990					      ENDIF
      7  0990
      8  0990				  -	      IF	.CYCLES & 1
      9  0990				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0990				  -	      nop	0
     11  0990				  -	      ELSE
     12  0990				  -	      bit	VSYNC
     13  0990				  -	      ENDIF
     14  0990				  -.CYCLES    SET	.CYCLES - 3
     15  0990					      ENDIF
     16  0990
     17  0990					      REPEAT	.CYCLES / 2
     18  0990		       ea		      nop
     17  0990					      REPEND
     18  0991		       ea		      nop
     17  0991					      REPEND
     18  0992		       ea		      nop
     17  0992					      REPEND
     18  0993		       ea		      nop
     19  0994					      REPEND
    174  0994
    175  0994		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    176  0997		       85 4d		      sta	PF0	; 3
    177  0999		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    178  099c		       85 4e		      sta	PF1	; 3
    179  099e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    180  09a1		       85 4f		      sta	PF2	; 3 @55
    181  09a3
    182  09a3		       4c 07 f9 	      jmp	.l3	; 3 @58
    183  09a6
    184  09a6
    185  09a6
    186  09a6							;---------------------------------------------------------------------------------------------------
    187  09a6
      0  09a6					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  09a6		       01 a6	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $1a6 , FREE= $5a
      2  09a6					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  09a6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  09a6				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  09a6				  -	      ERR
      6  09a6					      ENDIF
    189  09a6
    190  09a6							;---------------------------------------------------------------------------------------------------
    191  09a6							;EOF
------- FILE ./chess.asm
------- FILE ROM_SCREEN@3.asm LEVEL 2 PASS 4
      0  09a6					      include	"ROM_SCREEN@3.asm"
      1  09a6
      0  09a6					      SLOT	3
      1  09a6				  -	      IF	(3 < 0) || (3 > 3)
      2  09a6				  -	      ECHO	"Illegal bank address/segment location", 3
      3  09a6				  -	      ERR
      4  09a6					      ENDIF
      5  09a6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  09a6				   _BANK_SLOT SET	3 * 64
      0  09a6					      NEWBANK	ROM_SCREEN
      1  0c5c ????				      SEG	ROM_SCREEN
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   ROM_SCREEN_START SET	*
      6  0c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0c00				   ROM_SCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  0c00
      5  0c00							;---------------------------------------------------------------------------------------------------
      6  0c00
      0  0c00					      DEF	ClearRowBitmap
      1  0c00				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  0c00				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  0c00				   ClearRowBitmap
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	ClearRowBitmap
      8  0c00					      SUBROUTINE
      9  0c00
      0  0c00					      REFER	CallClear	;✅
      1  0c00				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  0c00				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  0c00					      ENDIF
      0  0c00					      VEND	ClearRowBitmap
      1  0c00				  -	      IFNCONST	ClearRowBitmap
      2  0c00				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  0c00				  -	      ERR
      4  0c00					      ENDIF
      5  0c00		       00 a7	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     12  0c00
     13  0c00							; No transient variable dependencies/calls
     14  0c00
     15  0c00		       a9 00		      lda	#0
     16  0c02		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  0c04				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  0c04		       99 ff f9 	      sta	[RAM]+ChessBitmap-1,y
     18  0c07		       88		      dey
     19  0c08		       d0 fa		      bne	.clearRow
     20  0c0a		       60		      rts
     21  0c0b
     22  0c0b
     23  0c0b							;---------------------------------------------------------------------------------------------------
     24  0c0b
     25  0c0b					      IF	1
      0  0c0b					      DEF	WriteBlank
      1  0c0b				   SLOT_WriteBlank SET	_BANK_SLOT
      2  0c0b				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  0c0b				   WriteBlank
      4  0c0b				   TEMPORARY_VAR SET	Overlay
      5  0c0b				   TEMPORARY_OFFSET SET	0
      6  0c0b				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  0c0b				   FUNCTION_NAME SET	WriteBlank
     27  0c0b					      SUBROUTINE
     28  0c0b
      0  0c0b					      REFER	StartupBankReset	;✅
      1  0c0b				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c0b				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c0b					      ENDIF
      0  0c0b					      VEND	WriteBlank
      1  0c0b				  -	      IFNCONST	WriteBlank
      2  0c0b				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  0c0b				  -	      ERR
      4  0c0b					      ENDIF
      5  0c0b		       00 a7	   VAREND_WriteBlank =	TEMPORARY_VAR
     31  0c0b
     32  0c0b		       a9 90		      lda	#<BlankSprite
      0  0c0d					      sta@RAM	SMSPRITE0_0+1
      1  0c0d		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c10					      sta@RAM	SMSPRITE8_0+1
      1  0c10		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c13					      sta@RAM	SMSPRITE16_0+1
      1  0c13		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
      0  0c16					      sta@RAM	SMSPRITE0_1+1
      1  0c16		       8d 48 fb 	      sta	[RAM]+SMSPRITE0_1+1
      0  0c19					      sta@RAM	SMSPRITE8_1+1
      1  0c19		       8d 79 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  0c1c					      sta@RAM	SMSPRITE16_1+1
      1  0c1c		       8d 0d fb 	      sta	[RAM]+SMSPRITE16_1+1
     39  0c1f
     40  0c1f		       a9 f8		      lda	#>BlankSprite
      0  0c21					      sta@RAM	SMSPRITE0_0+2
      1  0c21		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c24					      sta@RAM	SMSPRITE8_0+2
      1  0c24		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c27					      sta@RAM	SMSPRITE16_0+2
      1  0c27		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
      0  0c2a					      sta@RAM	SMSPRITE0_1+2
      1  0c2a		       8d 49 fb 	      sta	[RAM]+SMSPRITE0_1+2
      0  0c2d					      sta@RAM	SMSPRITE8_1+2
      1  0c2d		       8d 7a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  0c30					      sta@RAM	SMSPRITE16_1+2
      1  0c30		       8d 0e fb 	      sta	[RAM]+SMSPRITE16_1+2
     47  0c33
     48  0c33		       60		      rts
     49  0c34					      ENDIF
     50  0c34
     51  0c34							;---------------------------------------------------------------------------------------------------
     52  0c34
     53  0c34					      IF	1
      0  0c34					      DEF	WriteCursor
      1  0c34				   SLOT_WriteCursor SET	_BANK_SLOT
      2  0c34				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  0c34				   WriteCursor
      4  0c34				   TEMPORARY_VAR SET	Overlay
      5  0c34				   TEMPORARY_OFFSET SET	0
      6  0c34				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  0c34				   FUNCTION_NAME SET	WriteCursor
     55  0c34					      SUBROUTINE
     56  0c34
      0  0c34					      REFER	StartupBankReset	;✅
      1  0c34				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c34				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c34					      ENDIF
      0  0c34					      VEND	WriteCursor
      1  0c34				  -	      IFNCONST	WriteCursor
      2  0c34				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  0c34				  -	      ERR
      4  0c34					      ENDIF
      5  0c34		       00 a7	   VAREND_WriteCursor =	TEMPORARY_VAR
     59  0c34
     60  0c34		       38		      sec
     61  0c35		       a5 88		      lda	cursorX12
     62  0c37		       30 22		      bmi	.exit
     63  0c39		       a2 0a		      ldx	#10
     64  0c3b		       e9 0a	   .sub10     sbc	#10
     65  0c3d		       ca		      dex
     66  0c3e		       b0 fb		      bcs	.sub10
     67  0c40
     68  0c40		       8a		      txa
     69  0c41		       69 80		      adc	#SLOT_DrawRow	;cc implied
     70  0c43		       85 3e		      sta	SET_BANK_RAM
     71  0c45
     72  0c45		       a9 98		      lda	#<SpriteBuffer
      0  0c47					      sta@RAM	SMSPRITE0_0+1
      1  0c47		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c4a					      sta@RAM	SMSPRITE8_0+1
      1  0c4a		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c4d					      sta@RAM	SMSPRITE16_0+1
      1  0c4d		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
     76  0c50		       a9 f8		      lda	#>SpriteBuffer
      0  0c52					      sta@RAM	SMSPRITE0_0+2
      1  0c52		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c55					      sta@RAM	SMSPRITE8_0+2
      1  0c55		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c58					      sta@RAM	SMSPRITE16_0+2
      1  0c58		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
     80  0c5b
     81  0c5b		       60	   .exit      rts
     82  0c5c					      ENDIF
     83  0c5c
     84  0c5c
     85  0c5c							;---------------------------------------------------------------------------------------------------
     86  0c5c
     87  0c5c				  -	      IF	0
     88  0c5c				  -	      DEF	SaveBitmap
     89  0c5c				  -	      SUBROUTINE
     90  0c5c				  -
     91  0c5c				  -	      REFER	SAFE_BackupBitmaps	;✅
     92  0c5c				  -	      VEND	SaveBitmap
     93  0c5c				  -
     94  0c5c				  -	      ldy	#71
     95  0c5c				  -.fromTo    lda	ChessBitmap,y
     96  0c5c				  -	      sta@RAM	BackupBitmap,y
     97  0c5c				  -	      lda	ChessBitmap+72,y
     98  0c5c				  -	      sta@RAM	BackupBitmap+72,y
     99  0c5c				  -	      dey
    100  0c5c				  -	      bpl	.fromTo
    101  0c5c				  -	      rts
    102  0c5c					      ENDIF
    103  0c5c
    104  0c5c							;---------------------------------------------------------------------------------------------------
    105  0c5c
    106  0c5c				  -	      IF	0
    107  0c5c				  -
    108  0c5c				  -	      DEF	RestoreBitmap
    109  0c5c				  -	      SUBROUTINE
    110  0c5c				  -
    111  0c5c				  -	      VEND	RestoreBitmap
    112  0c5c				  -
    113  0c5c				  -	      ldy	#71
    114  0c5c				  -.fromTo    lda	BackupBitmap,y
    115  0c5c				  -	      sta@RAM	ChessBitmap,y
    116  0c5c				  -	      lda	BackupBitmap+72,y
    117  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    118  0c5c				  -	      dey
    119  0c5c				  -	      bpl	.fromTo
    120  0c5c				  -	      rts
    121  0c5c					      ENDIF
    122  0c5c
    123  0c5c							;---------------------------------------------------------------------------------------------------
    124  0c5c
    125  0c5c				  -	      IF	0
    126  0c5c				  -
    127  0c5c				  -	      DEF	CopyTextToRowBitmap
    128  0c5c				  -	      SUBROUTINE
    129  0c5c				  -
    130  0c5c				  -	      VEND	CopyTextToRowBitmap
    131  0c5c				  -
    132  0c5c				  -			; An OR-draw, used for placing matricies/text onscreen
    133  0c5c				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    134  0c5c				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    135  0c5c				  -			; in original state once text disappears
    136  0c5c				  -
    137  0c5c				  -	      ldy	#71
    138  0c5c				  -	      bcs	.rightSide
    139  0c5c				  -
    140  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    141  0c5c				  -	      ora	ChessBitmap,y
    142  0c5c				  -	      sta@RAM	ChessBitmap,y
    143  0c5c				  -	      dey
    144  0c5c				  -	      bpl	.copy
    145  0c5c				  -
    146  0c5c				  -	      rts
    147  0c5c				  -
    148  0c5c				  -.rightSide
    149  0c5c				  -
    150  0c5c				  -	      SUBROUTINE
    151  0c5c				  -
    152  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    153  0c5c				  -	      ora	ChessBitmap+72,y
    154  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    155  0c5c				  -	      dey
    156  0c5c				  -	      bpl	.copy
    157  0c5c				  -
    158  0c5c				  -	      rts
    159  0c5c				  -
    160  0c5c					      ENDIF
    161  0c5c
    162  0c5c							;---------------------------------------------------------------------------------------------------
    163  0c5c
      0  0c5c					      CHECK_RAM_BANK_SIZE	"ROM_SCREEN@3"
      1  0c5c		       00 5c	   .TEMP      =	* - _BANK_START
 ROM_SCREEN@3 (512 byte) SIZE =  $5c , FREE= $1a4
      2  0c5c					      ECHO	"ROM_SCREEN@3", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  0c5c				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  0c5c				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SCREEN@3", " size=", * - ORIGIN
      5  0c5c				  -	      ERR
      6  0c5c					      ENDIF
    165  0c5c
    166  0c5c							;---------------------------------------------------------------------------------------------------
    167  0c5c							;EOF
------- FILE ./chess.asm
------- FILE SHADOW_PLY.asm LEVEL 2 PASS 4
      0  0c5c					      include	"SHADOW_PLY.asm"
      1  0c5c							; Chess
      2  0c5c							; Copyright (c) 2019-2020 Andrew Davie
      3  0c5c							; andrew@taswegian.com
      4  0c5c
      5  0c5c
      6  0c5c							;---------------------------------------------------------------------------------------------------
      7  0c5c							; Define the RAM banks
      8  0c5c							; A "PLY" bank represents all the data required on any single ply of the search tree.
      9  0c5c							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     10  0c5c							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     11  0c5c							; they act as independant switchable banks usable for data on each ply during the search.
     12  0c5c							; A ply will hold the move list for that position
     13  0c5c
     14  0c5c
      0  0c5c					      SLOT	2
      1  0c5c				  -	      IF	(2 < 0) || (2 > 3)
      2  0c5c				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0c5c				  -	      ERR
      4  0c5c					      ENDIF
      5  0c5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0c5c				   _BANK_SLOT SET	2 * 64
      0  0c5c					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  0c5c
      2  0c5c
      3  0c5c
      4 U21dc ????				      SEG.U	PLY
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2000				   _BANK_START SET	*
      8 U2000				   RAMBANK_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U2000
     18 U2000							;---------------------------------------------------------------------------------------------------
     19 U2000
     20 U2000		       00 64	   MAX_MOVES  =	100	; big is good
     21 U2000
      0 U2000					      VARIABLE	MoveFrom, MAX_MOVES
      0 U2000					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2000					      LIST	ON
      2 U2000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0 U2064					      VARIABLE	MoveTo, MAX_MOVES
      0 U2064					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2064					      LIST	ON
      2 U2064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0 U20c8					      VARIABLE	MovePiece, MAX_MOVES
      0 U20c8					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2100					      LIST	ON
      2 U2100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0 U2164					      VARIABLE	MoveCapture, MAX_MOVES
      0 U2164					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2164					      LIST	ON
      2 U2164		       00 00 00 00*MoveCapture ds	MAX_MOVES
     26 U21c8
     27 U21c8
     28 U21c8							;---------------------------------------------------------------------------------------------------
     29 U21c8
     30 U21c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     31 U21c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     32 U21c8
      0 U21c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0 U21c8					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21c8					      LIST	ON
      2 U21c8		       00 00	   savedEvaluation ds	2
      0 U21ca					      VARIABLE	enPassantSquare, 1
      0 U21ca					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ca					      LIST	ON
      2 U21ca		       00	   enPassantSquare ds	1
      0 U21cb					      VARIABLE	capturedPiece, 1
      0 U21cb					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cb					      LIST	ON
      2 U21cb		       00	   capturedPiece ds	1
     36 U21cc							;VARIABLE originalPiece, 1
      0 U21cc					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0 U21cc					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cc					      LIST	ON
      2 U21cc		       00	   secondaryPiece ds	1
      0 U21cd					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0 U21cd					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cd					      LIST	ON
      2 U21cd		       00	   secondarySquare ds	1
      0 U21ce					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0 U21ce					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ce					      LIST	ON
      2 U21ce		       00	   secondaryBlank ds	1
      0 U21cf					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0 U21cf					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cf					      LIST	ON
      2 U21cf		       00	   moveIndex  ds	1
      0 U21d0					      VARIABLE	movePtr, 1
      0 U21d0					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d0					      LIST	ON
      2 U21d0		       00	   movePtr    ds	1
      0 U21d1					      VARIABLE	bestMove, 1
      0 U21d1					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d1					      LIST	ON
      2 U21d1		       00	   bestMove   ds	1
      0 U21d2					      VARIABLE	alpha, 2
      0 U21d2					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d2					      LIST	ON
      2 U21d2		       00 00	   alpha      ds	2
      0 U21d4					      VARIABLE	beta, 2
      0 U21d4					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d4					      LIST	ON
      2 U21d4		       00 00	   beta       ds	2
      0 U21d6					      VARIABLE	value, 2
      0 U21d6					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d6					      LIST	ON
      2 U21d6		       00 00	   value      ds	2
      0 U21d8					      VARIABLE	depthLeft, 1
      0 U21d8					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d8					      LIST	ON
      2 U21d8		       00	   depthLeft  ds	1
      0 U21d9					      VARIABLE	restorePiece, 1
      0 U21d9					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d9					      LIST	ON
      2 U21d9		       00	   restorePiece ds	1
      0 U21da					      VARIABLE	virtualKingSquare, 2	; traversing squares for castle/check
      0 U21da					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21da					      LIST	ON
      2 U21da		       00 00	   virtualKingSquare ds	2
     49 U21dc
     50 U21dc
      0 U21dc					      CHECK_RAM_BANK_SIZE	"SHADOW_PLY"
      1 U21dc		       01 dc	   .TEMP      =	* - _BANK_START
 SHADOW_PLY (512 byte) SIZE =  $1dc , FREE= $24
      2 U21dc					      ECHO	"SHADOW_PLY", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3 U21dc				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U21dc				  -	      ECHO	"BANK OVERFLOW @ ", "SHADOW_PLY", " size=", * - ORIGIN
      5 U21dc				  -	      ERR
      6 U21dc					      ENDIF
     52 U21dc
     53 U21dc					      REPEAT	PLY_BANKS-1
      0 U21dc					      NEWRAMBANK	.DUMMY_PLY
      1 U21dc
      2 U21dc
      3 U21dc
      4 U4000 ????				      SEG.U	.DUMMY_PLY
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2400				   _BANK_START SET	*
      8 U2400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2400					      REPEND
      0 U2400					      NEWRAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400
      3 U2400
      4 U2400					      SEG.U	.DUMMY_PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2800				   _BANK_START SET	*
      8 U2800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2800					      REPEND
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U2800					      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2c00				   _BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2c00					      REPEND
      0 U2c00					      NEWRAMBANK	.DUMMY_PLY
      1 U2c00
      2 U2c00
      3 U2c00
      4 U2c00					      SEG.U	.DUMMY_PLY
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3000				   _BANK_START SET	*
      8 U3000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3000					      REPEND
      0 U3000					      NEWRAMBANK	.DUMMY_PLY
      1 U3000
      2 U3000
      3 U3000
      4 U3000					      SEG.U	.DUMMY_PLY
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3400				   _BANK_START SET	*
      8 U3400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3400					      REPEND
      0 U3400					      NEWRAMBANK	.DUMMY_PLY
      1 U3400
      2 U3400
      3 U3400
      4 U3400					      SEG.U	.DUMMY_PLY
      5 U3800					      ORG	ORIGIN_RAM
      6 U3800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3800				   _BANK_START SET	*
      8 U3800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3800					      REPEND
      0 U3800					      NEWRAMBANK	.DUMMY_PLY
      1 U3800
      2 U3800
      3 U3800
      4 U3800					      SEG.U	.DUMMY_PLY
      5 U3c00					      ORG	ORIGIN_RAM
      6 U3c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3c00				   _BANK_START SET	*
      8 U3c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3c00					      REPEND
      0 U3c00					      NEWRAMBANK	.DUMMY_PLY
      1 U3c00
      2 U3c00
      3 U3c00
      4 U3c00					      SEG.U	.DUMMY_PLY
      5 U4000					      ORG	ORIGIN_RAM
      6 U4000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4000				   _BANK_START SET	*
      8 U4000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     55 U4000					      REPEND
     56 U4000
     57 U4000
     58 U4000							;---------------------------------------------------------------------------------------------------
     59 U4000							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0 U4000					      include	"SHADOW_BOARD.asm"
      1 U4000							; Copyright (C)2020 Andrew Davie
      2 U4000
      3 U4000
      4 U4000							;---------------------------------------------------------------------------------------------------
      0 U4000					      SLOT	3
      1 U4000				  -	      IF	(3 < 0) || (3 > 3)
      2 U4000				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U4000				  -	      ERR
      4 U4000					      ENDIF
      5 U4000				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U4000				   _BANK_SLOT SET	3 * 64
      0 U4000					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1 U4000
      2 U4000
      3 U4000
      4 U4400 ????				      SEG.U	BOARD
      5 U4400					      ORG	ORIGIN_RAM
      6 U4400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4400				   _BANK_START SET	*
      8 U4400				   RAMBANK_BOARD SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4400				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U4400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      7 U4400
      8 U4400		       fc 15	   ValidSquare =	ShadowValidSquare + $400
      9 U4400		       fc 79	   Board      =	ShadowBoard + $400
     10 U4400
      0 U4400					      SLOT	2
      1 U4400				  -	      IF	(2 < 0) || (2 > 3)
      2 U4400				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U4400				  -	      ERR
      4 U4400					      ENDIF
      5 U4400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U4400				   _BANK_SLOT SET	2 * 64
      0 U4400					      NEWBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  10dd ????				      SEG	SHADOW_BOARD
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   SHADOW_BOARD_START SET	*
      6  1000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1000				   SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + 1024
     13  1000
     14  1000							; Board is a 10 x 12 object which simplifies the generation of moves
     15  1000							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     16  1000							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     17  1000
     18  1000							;     X12 numbering
     19  1000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     20  1000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     21  1000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     22  1000							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     23  1000							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     24  1000							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     25  1000							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     26  1000							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     27  1000							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     28  1000							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     29  1000							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     30  1000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     31  1000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     32  1000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     33  1000							;	0   1	2   3	4   5	6   7	8   9
     34  1000							;		A   B	C   D	E   F	G   H
     35  1000
     36  1000							;     HEX X12
     37  1000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     38  1000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     39  1000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     40  1000							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     41  1000							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     42  1000							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     43  1000							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     44  1000							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     45  1000							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     46  1000							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     47  1000							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     48  1000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     49  1000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     50  1000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     51  1000							;	0   1	2   3	4   5	6   7	8   9
     52  1000							;		A   B	C   D	E   F	G   H
     53  1000
     54  1000
     55  1000							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     56  1000							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     57  1000							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     58  1000							; be re-used for something else - we just need to guarantee there are 21 of them there
     59  1000
      0  1000					      ALLOCATE	Valid, 120 + 80 + 21
      0  1000					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  1000					      LIST	ON
      0  1000					      DEF	Valid
      1  1000				   SLOT_Valid SET	_BANK_SLOT
      2  1000				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  1000				   Valid
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	Valid
     61  1000		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     62  1015							; Note, we will never index INTO the above bytes - x will always be >= 21
     63  1015							; We just need to make sure that the actual indexing will not have an address before
     64  1015							; the index of outside the page.
     65  1015
      0  1015					      DEF	ShadowValidSquare
      1  1015				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  1015				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  1015				   ShadowValidSquare
      4  1015				   TEMPORARY_VAR SET	Overlay
      5  1015				   TEMPORARY_OFFSET SET	0
      6  1015				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  1015				   FUNCTION_NAME SET	ShadowValidSquare
     67  1015
     68  1015
     69  1015							; Use this table to
     70  1015							;   a) Determine if a square is valid (-1 = NO)
     71  1015							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     72  1015							;	if a white pawn on square "x" can move "up" the board.
     73  1015
     74  1015		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     75  101f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     76  1029		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     77  1033		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     78  103d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     79  1047		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     80  1051		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     81  105b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     82  1065		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     83  106f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     84  1079
      0  1079					      DEF	ShadowBoard
      1  1079				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  1079				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  1079				   ShadowBoard
      4  1079				   TEMPORARY_VAR SET	Overlay
      5  1079				   TEMPORARY_OFFSET SET	0
      6  1079				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  1079				   FUNCTION_NAME SET	ShadowBoard
     86  1079
     87  1079							; A 10X10... we should never write using invalid square
     88  1079							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     89  1079							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     90  1079
     91  1079		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     92  1083		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     93  108d
     94  108d					      REPEAT	8
     95  108d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  108d					      REPEND
     95  1097		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  1097					      REPEND
     95  10a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10a1					      REPEND
     95  10ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10ab					      REPEND
     95  10b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10b5					      REPEND
     95  10bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10bf					      REPEND
     95  10c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10c9					      REPEND
     95  10d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     96  10dd					      REPEND
     97  10dd
     98  10dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     99  10dd
    100  10dd
    101  10dd							;---------------------------------------------------------------------------------------------------
    102  10dd							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 4
      0  10dd					      include	"BANK_EVAL.asm"
      1  10dd
      0  10dd					      SLOT	3
      1  10dd				  -	      IF	(3 < 0) || (3 > 3)
      2  10dd				  -	      ECHO	"Illegal bank address/segment location", 3
      3  10dd				  -	      ERR
      4  10dd					      ENDIF
      5  10dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  10dd				   _BANK_SLOT SET	3 * 64
      3  10dd
      4  10dd
      0  10dd					      NEWRAMBANK	BANK_EVAL
      1  10dd
      2  10dd
      3  10dd
      4 U4800 ????				      SEG.U	BANK_EVAL
      5 U4800					      ORG	ORIGIN_RAM
      6 U4800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4800				   _BANK_START SET	*
      8 U4800				   RAMBANK_BANK_EVAL SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4800				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U4800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U4800					      NEWBANK	EVAL
      1  1640 ????				      SEG	EVAL
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   EVAL_START SET	*
      6  1400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1400				   EVAL       SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + 1024
      7  1400
      8  1400
      9  1400							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     10  1400
     11  1400
     12  1400
     13  1400							;---------------------------------------------------------------------------------------------------
     14  1400							; Vectors to the position value tables for each piece
     15  1400
     16  1400							;---------------------------------------------------------------------------------------------------
     17  1400							; Vectors to the position value tables for each piece
     18  1400
     19  1400					      MAC	posval
     20  1400					      .byte	0
     21  1400					      .byte	{1}(PositionalValue_PAWN - 22)
     22  1400					      .byte	{1}(PositionalValue_PAWN - 22)
     23  1400					      .byte	{1}(PositionalValue_KNIGHT - 22)
     24  1400					      .byte	{1}(PositionalValue_BISHOP - 22)
     25  1400					      .byte	{1}(PositionalValue_ROOK - 22)
     26  1400					      .byte	{1}(PositionalValue_QUEEN - 22)
     27  1400					      .byte	{1}(PositionalValue_KING_ENDGAME - 22)
     28  1400					      ENDM
     29  1400
      0  1400					      ALLOCATE	PosValVecLO, 8
      0  1400					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1400					      LIST	ON
      0  1400					      DEF	PosValVecLO
      1  1400				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  1400				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  1400				   PosValVecLO
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	PosValVecLO
      0  1400					      POSVAL	<
      1  1400		       00		      .byte.b	0
      2  1401		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      3  1402		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      4  1403		       4a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  1404		       9a		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  1405		       ea		      .byte.b	<(PositionalValue_ROOK - 22)
      7  1406		       3a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  1407		       da		      .byte.b	<(PositionalValue_KING_ENDGAME - 22)
      0  1408					      ALLOCATE	PosValVecHI, 8
      0  1408					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1408					      LIST	ON
      0  1408					      DEF	PosValVecHI
      1  1408				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  1408				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  1408				   PosValVecHI
      4  1408				   TEMPORARY_VAR SET	Overlay
      5  1408				   TEMPORARY_OFFSET SET	0
      6  1408				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  1408				   FUNCTION_NAME SET	PosValVecHI
      0  1408					      POSVAL	>
      1  1408		       00		      .byte.b	0
      2  1409		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      3  140a		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      4  140b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  140c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  140d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  140e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  140f		       fd		      .byte.b	>(PositionalValue_KING_ENDGAME - 22)
     34  1410
     35  1410
     36  1410					      MAC	eval8
     37  1410					      IF	({1} > 127) || ({1} < -128)
     38  1410					      ECHO	"Erroneous position value", {1}
     39  1410					      ERR
     40  1410					      ENDIF
     41  1410					      .byte	{1}
     42  1410					      ENDM
     43  1410
     44  1410
     45  1410					      MAC	pval
     46  1410					      EVAL8	{1}
     47  1410					      EVAL8	{2}
     48  1410					      EVAL8	{3}
     49  1410					      EVAL8	{4}
     50  1410					      EVAL8	{5}
     51  1410					      EVAL8	{6}
     52  1410					      EVAL8	{7}
     53  1410					      EVAL8	{8}
     54  1410					      EVAL8	0
     55  1410					      EVAL8	0
     56  1410					      ENDM		;{ 10 entries }
     57  1410
     58  1410
     59  1410				  -	      IF	0
     69  1410				  -	      ENDM
     70  1410				  -
     71  1410				  -	      ALLOCATE	PosValVecLO, 8
     72  1410				  -	      POSVAL	<
     73  1410				  -	      ALLOCATE	PosValVecHI, 8
     74  1410				  -	      POSVAL	>
     75  1410				  -
     76  1410				  -BZ	      =	0
     77  1410				  -
     89  1410				  -	      ENDM		;{ 10 entries }
     90  1410					      ENDIF
     91  1410
     92  1410							;---------------------------------------------------------------------------------------------------
     93  1410
     94  1410				   PositionalValue_PAWN
     95  1410
      0  1410					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  1410					      EVAL8	0
      1  1410				  -	      IF	(0 > 127) || (0 < -128)
      2  1410				  -	      ECHO	"Erroneous position value", 0
      3  1410				  -	      ERR
      4  1410					      ENDIF
      5  1410		       00		      .byte.b	0
      0  1411					      EVAL8	0
      1  1411				  -	      IF	(0 > 127) || (0 < -128)
      2  1411				  -	      ECHO	"Erroneous position value", 0
      3  1411				  -	      ERR
      4  1411					      ENDIF
      5  1411		       00		      .byte.b	0
      0  1412					      EVAL8	0
      1  1412				  -	      IF	(0 > 127) || (0 < -128)
      2  1412				  -	      ECHO	"Erroneous position value", 0
      3  1412				  -	      ERR
      4  1412					      ENDIF
      5  1412		       00		      .byte.b	0
      0  1413					      EVAL8	0
      1  1413				  -	      IF	(0 > 127) || (0 < -128)
      2  1413				  -	      ECHO	"Erroneous position value", 0
      3  1413				  -	      ERR
      4  1413					      ENDIF
      5  1413		       00		      .byte.b	0
      0  1414					      EVAL8	0
      1  1414				  -	      IF	(0 > 127) || (0 < -128)
      2  1414				  -	      ECHO	"Erroneous position value", 0
      3  1414				  -	      ERR
      4  1414					      ENDIF
      5  1414		       00		      .byte.b	0
      0  1415					      EVAL8	0
      1  1415				  -	      IF	(0 > 127) || (0 < -128)
      2  1415				  -	      ECHO	"Erroneous position value", 0
      3  1415				  -	      ERR
      4  1415					      ENDIF
      5  1415		       00		      .byte.b	0
      0  1416					      EVAL8	0
      1  1416				  -	      IF	(0 > 127) || (0 < -128)
      2  1416				  -	      ECHO	"Erroneous position value", 0
      3  1416				  -	      ERR
      4  1416					      ENDIF
      5  1416		       00		      .byte.b	0
      0  1417					      EVAL8	0
      1  1417				  -	      IF	(0 > 127) || (0 < -128)
      2  1417				  -	      ECHO	"Erroneous position value", 0
      3  1417				  -	      ERR
      4  1417					      ENDIF
      5  1417		       00		      .byte.b	0
      0  1418					      EVAL8	0
      1  1418				  -	      IF	(0 > 127) || (0 < -128)
      2  1418				  -	      ECHO	"Erroneous position value", 0
      3  1418				  -	      ERR
      4  1418					      ENDIF
      5  1418		       00		      .byte.b	0
      0  1419					      EVAL8	0
      1  1419				  -	      IF	(0 > 127) || (0 < -128)
      2  1419				  -	      ECHO	"Erroneous position value", 0
      3  1419				  -	      ERR
      4  1419					      ENDIF
      5  1419		       00		      .byte.b	0
      0  141a					      PVAL	15, 20, 0, -10, -10, 0, 20, 15
      0  141a					      EVAL8	15
      1  141a				  -	      IF	(15 > 127) || (15 < -128)
      2  141a				  -	      ECHO	"Erroneous position value", 15
      3  141a				  -	      ERR
      4  141a					      ENDIF
      5  141a		       0f		      .byte.b	15
      0  141b					      EVAL8	20
      1  141b				  -	      IF	(20 > 127) || (20 < -128)
      2  141b				  -	      ECHO	"Erroneous position value", 20
      3  141b				  -	      ERR
      4  141b					      ENDIF
      5  141b		       14		      .byte.b	20
      0  141c					      EVAL8	0
      1  141c				  -	      IF	(0 > 127) || (0 < -128)
      2  141c				  -	      ECHO	"Erroneous position value", 0
      3  141c				  -	      ERR
      4  141c					      ENDIF
      5  141c		       00		      .byte.b	0
      0  141d					      EVAL8	-10
      1  141d				  -	      IF	(-10 > 127) || (-10 < -128)
      2  141d				  -	      ECHO	"Erroneous position value", -10
      3  141d				  -	      ERR
      4  141d					      ENDIF
      5  141d		       f6		      .byte.b	-10
      0  141e					      EVAL8	-10
      1  141e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  141e				  -	      ECHO	"Erroneous position value", -10
      3  141e				  -	      ERR
      4  141e					      ENDIF
      5  141e		       f6		      .byte.b	-10
      0  141f					      EVAL8	0
      1  141f				  -	      IF	(0 > 127) || (0 < -128)
      2  141f				  -	      ECHO	"Erroneous position value", 0
      3  141f				  -	      ERR
      4  141f					      ENDIF
      5  141f		       00		      .byte.b	0
      0  1420					      EVAL8	20
      1  1420				  -	      IF	(20 > 127) || (20 < -128)
      2  1420				  -	      ECHO	"Erroneous position value", 20
      3  1420				  -	      ERR
      4  1420					      ENDIF
      5  1420		       14		      .byte.b	20
      0  1421					      EVAL8	15
      1  1421				  -	      IF	(15 > 127) || (15 < -128)
      2  1421				  -	      ECHO	"Erroneous position value", 15
      3  1421				  -	      ERR
      4  1421					      ENDIF
      5  1421		       0f		      .byte.b	15
      0  1422					      EVAL8	0
      1  1422				  -	      IF	(0 > 127) || (0 < -128)
      2  1422				  -	      ECHO	"Erroneous position value", 0
      3  1422				  -	      ERR
      4  1422					      ENDIF
      5  1422		       00		      .byte.b	0
      0  1423					      EVAL8	0
      1  1423				  -	      IF	(0 > 127) || (0 < -128)
      2  1423				  -	      ECHO	"Erroneous position value", 0
      3  1423				  -	      ERR
      4  1423					      ENDIF
      5  1423		       00		      .byte.b	0
      0  1424					      PVAL	5, -5, 20, 0, 0, 20, -5, 5
      0  1424					      EVAL8	5
      1  1424				  -	      IF	(5 > 127) || (5 < -128)
      2  1424				  -	      ECHO	"Erroneous position value", 5
      3  1424				  -	      ERR
      4  1424					      ENDIF
      5  1424		       05		      .byte.b	5
      0  1425					      EVAL8	-5
      1  1425				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1425				  -	      ECHO	"Erroneous position value", -5
      3  1425				  -	      ERR
      4  1425					      ENDIF
      5  1425		       fb		      .byte.b	-5
      0  1426					      EVAL8	20
      1  1426				  -	      IF	(20 > 127) || (20 < -128)
      2  1426				  -	      ECHO	"Erroneous position value", 20
      3  1426				  -	      ERR
      4  1426					      ENDIF
      5  1426		       14		      .byte.b	20
      0  1427					      EVAL8	0
      1  1427				  -	      IF	(0 > 127) || (0 < -128)
      2  1427				  -	      ECHO	"Erroneous position value", 0
      3  1427				  -	      ERR
      4  1427					      ENDIF
      5  1427		       00		      .byte.b	0
      0  1428					      EVAL8	0
      1  1428				  -	      IF	(0 > 127) || (0 < -128)
      2  1428				  -	      ECHO	"Erroneous position value", 0
      3  1428				  -	      ERR
      4  1428					      ENDIF
      5  1428		       00		      .byte.b	0
      0  1429					      EVAL8	20
      1  1429				  -	      IF	(20 > 127) || (20 < -128)
      2  1429				  -	      ECHO	"Erroneous position value", 20
      3  1429				  -	      ERR
      4  1429					      ENDIF
      5  1429		       14		      .byte.b	20
      0  142a					      EVAL8	-5
      1  142a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  142a				  -	      ECHO	"Erroneous position value", -5
      3  142a				  -	      ERR
      4  142a					      ENDIF
      5  142a		       fb		      .byte.b	-5
      0  142b					      EVAL8	5
      1  142b				  -	      IF	(5 > 127) || (5 < -128)
      2  142b				  -	      ECHO	"Erroneous position value", 5
      3  142b				  -	      ERR
      4  142b					      ENDIF
      5  142b		       05		      .byte.b	5
      0  142c					      EVAL8	0
      1  142c				  -	      IF	(0 > 127) || (0 < -128)
      2  142c				  -	      ECHO	"Erroneous position value", 0
      3  142c				  -	      ERR
      4  142c					      ENDIF
      5  142c		       00		      .byte.b	0
      0  142d					      EVAL8	0
      1  142d				  -	      IF	(0 > 127) || (0 < -128)
      2  142d				  -	      ECHO	"Erroneous position value", 0
      3  142d				  -	      ERR
      4  142d					      ENDIF
      5  142d		       00		      .byte.b	0
      0  142e					      PVAL	5, 5, 10, 20, 40, 20, 5, 5
      0  142e					      EVAL8	5
      1  142e				  -	      IF	(5 > 127) || (5 < -128)
      2  142e				  -	      ECHO	"Erroneous position value", 5
      3  142e				  -	      ERR
      4  142e					      ENDIF
      5  142e		       05		      .byte.b	5
      0  142f					      EVAL8	5
      1  142f				  -	      IF	(5 > 127) || (5 < -128)
      2  142f				  -	      ECHO	"Erroneous position value", 5
      3  142f				  -	      ERR
      4  142f					      ENDIF
      5  142f		       05		      .byte.b	5
      0  1430					      EVAL8	10
      1  1430				  -	      IF	(10 > 127) || (10 < -128)
      2  1430				  -	      ECHO	"Erroneous position value", 10
      3  1430				  -	      ERR
      4  1430					      ENDIF
      5  1430		       0a		      .byte.b	10
      0  1431					      EVAL8	20
      1  1431				  -	      IF	(20 > 127) || (20 < -128)
      2  1431				  -	      ECHO	"Erroneous position value", 20
      3  1431				  -	      ERR
      4  1431					      ENDIF
      5  1431		       14		      .byte.b	20
      0  1432					      EVAL8	40
      1  1432				  -	      IF	(40 > 127) || (40 < -128)
      2  1432				  -	      ECHO	"Erroneous position value", 40
      3  1432				  -	      ERR
      4  1432					      ENDIF
      5  1432		       28		      .byte.b	40
      0  1433					      EVAL8	20
      1  1433				  -	      IF	(20 > 127) || (20 < -128)
      2  1433				  -	      ECHO	"Erroneous position value", 20
      3  1433				  -	      ERR
      4  1433					      ENDIF
      5  1433		       14		      .byte.b	20
      0  1434					      EVAL8	5
      1  1434				  -	      IF	(5 > 127) || (5 < -128)
      2  1434				  -	      ECHO	"Erroneous position value", 5
      3  1434				  -	      ERR
      4  1434					      ENDIF
      5  1434		       05		      .byte.b	5
      0  1435					      EVAL8	5
      1  1435				  -	      IF	(5 > 127) || (5 < -128)
      2  1435				  -	      ECHO	"Erroneous position value", 5
      3  1435				  -	      ERR
      4  1435					      ENDIF
      5  1435		       05		      .byte.b	5
      0  1436					      EVAL8	0
      1  1436				  -	      IF	(0 > 127) || (0 < -128)
      2  1436				  -	      ECHO	"Erroneous position value", 0
      3  1436				  -	      ERR
      4  1436					      ENDIF
      5  1436		       00		      .byte.b	0
      0  1437					      EVAL8	0
      1  1437				  -	      IF	(0 > 127) || (0 < -128)
      2  1437				  -	      ECHO	"Erroneous position value", 0
      3  1437				  -	      ERR
      4  1437					      ENDIF
      5  1437		       00		      .byte.b	0
      0  1438					      PVAL	15, 15, 20, 40, 50, 20, 15, 15
      0  1438					      EVAL8	15
      1  1438				  -	      IF	(15 > 127) || (15 < -128)
      2  1438				  -	      ECHO	"Erroneous position value", 15
      3  1438				  -	      ERR
      4  1438					      ENDIF
      5  1438		       0f		      .byte.b	15
      0  1439					      EVAL8	15
      1  1439				  -	      IF	(15 > 127) || (15 < -128)
      2  1439				  -	      ECHO	"Erroneous position value", 15
      3  1439				  -	      ERR
      4  1439					      ENDIF
      5  1439		       0f		      .byte.b	15
      0  143a					      EVAL8	20
      1  143a				  -	      IF	(20 > 127) || (20 < -128)
      2  143a				  -	      ECHO	"Erroneous position value", 20
      3  143a				  -	      ERR
      4  143a					      ENDIF
      5  143a		       14		      .byte.b	20
      0  143b					      EVAL8	40
      1  143b				  -	      IF	(40 > 127) || (40 < -128)
      2  143b				  -	      ECHO	"Erroneous position value", 40
      3  143b				  -	      ERR
      4  143b					      ENDIF
      5  143b		       28		      .byte.b	40
      0  143c					      EVAL8	50
      1  143c				  -	      IF	(50 > 127) || (50 < -128)
      2  143c				  -	      ECHO	"Erroneous position value", 50
      3  143c				  -	      ERR
      4  143c					      ENDIF
      5  143c		       32		      .byte.b	50
      0  143d					      EVAL8	20
      1  143d				  -	      IF	(20 > 127) || (20 < -128)
      2  143d				  -	      ECHO	"Erroneous position value", 20
      3  143d				  -	      ERR
      4  143d					      ENDIF
      5  143d		       14		      .byte.b	20
      0  143e					      EVAL8	15
      1  143e				  -	      IF	(15 > 127) || (15 < -128)
      2  143e				  -	      ECHO	"Erroneous position value", 15
      3  143e				  -	      ERR
      4  143e					      ENDIF
      5  143e		       0f		      .byte.b	15
      0  143f					      EVAL8	15
      1  143f				  -	      IF	(15 > 127) || (15 < -128)
      2  143f				  -	      ECHO	"Erroneous position value", 15
      3  143f				  -	      ERR
      4  143f					      ENDIF
      5  143f		       0f		      .byte.b	15
      0  1440					      EVAL8	0
      1  1440				  -	      IF	(0 > 127) || (0 < -128)
      2  1440				  -	      ECHO	"Erroneous position value", 0
      3  1440				  -	      ERR
      4  1440					      ENDIF
      5  1440		       00		      .byte.b	0
      0  1441					      EVAL8	0
      1  1441				  -	      IF	(0 > 127) || (0 < -128)
      2  1441				  -	      ECHO	"Erroneous position value", 0
      3  1441				  -	      ERR
      4  1441					      ENDIF
      5  1441		       00		      .byte.b	0
      0  1442					      PVAL	60, 60, 80, 80, 80, 80, 60, 60
      0  1442					      EVAL8	60
      1  1442				  -	      IF	(60 > 127) || (60 < -128)
      2  1442				  -	      ECHO	"Erroneous position value", 60
      3  1442				  -	      ERR
      4  1442					      ENDIF
      5  1442		       3c		      .byte.b	60
      0  1443					      EVAL8	60
      1  1443				  -	      IF	(60 > 127) || (60 < -128)
      2  1443				  -	      ECHO	"Erroneous position value", 60
      3  1443				  -	      ERR
      4  1443					      ENDIF
      5  1443		       3c		      .byte.b	60
      0  1444					      EVAL8	80
      1  1444				  -	      IF	(80 > 127) || (80 < -128)
      2  1444				  -	      ECHO	"Erroneous position value", 80
      3  1444				  -	      ERR
      4  1444					      ENDIF
      5  1444		       50		      .byte.b	80
      0  1445					      EVAL8	80
      1  1445				  -	      IF	(80 > 127) || (80 < -128)
      2  1445				  -	      ECHO	"Erroneous position value", 80
      3  1445				  -	      ERR
      4  1445					      ENDIF
      5  1445		       50		      .byte.b	80
      0  1446					      EVAL8	80
      1  1446				  -	      IF	(80 > 127) || (80 < -128)
      2  1446				  -	      ECHO	"Erroneous position value", 80
      3  1446				  -	      ERR
      4  1446					      ENDIF
      5  1446		       50		      .byte.b	80
      0  1447					      EVAL8	80
      1  1447				  -	      IF	(80 > 127) || (80 < -128)
      2  1447				  -	      ECHO	"Erroneous position value", 80
      3  1447				  -	      ERR
      4  1447					      ENDIF
      5  1447		       50		      .byte.b	80
      0  1448					      EVAL8	60
      1  1448				  -	      IF	(60 > 127) || (60 < -128)
      2  1448				  -	      ECHO	"Erroneous position value", 60
      3  1448				  -	      ERR
      4  1448					      ENDIF
      5  1448		       3c		      .byte.b	60
      0  1449					      EVAL8	60
      1  1449				  -	      IF	(60 > 127) || (60 < -128)
      2  1449				  -	      ECHO	"Erroneous position value", 60
      3  1449				  -	      ERR
      4  1449					      ENDIF
      5  1449		       3c		      .byte.b	60
      0  144a					      EVAL8	0
      1  144a				  -	      IF	(0 > 127) || (0 < -128)
      2  144a				  -	      ECHO	"Erroneous position value", 0
      3  144a				  -	      ERR
      4  144a					      ENDIF
      5  144a		       00		      .byte.b	0
      0  144b					      EVAL8	0
      1  144b				  -	      IF	(0 > 127) || (0 < -128)
      2  144b				  -	      ECHO	"Erroneous position value", 0
      3  144b				  -	      ERR
      4  144b					      ENDIF
      5  144b		       00		      .byte.b	0
      0  144c					      PVAL	100, 100, 120, 120, 120, 120, 100, 100
      0  144c					      EVAL8	100
      1  144c				  -	      IF	(100 > 127) || (100 < -128)
      2  144c				  -	      ECHO	"Erroneous position value", 100
      3  144c				  -	      ERR
      4  144c					      ENDIF
      5  144c		       64		      .byte.b	100
      0  144d					      EVAL8	100
      1  144d				  -	      IF	(100 > 127) || (100 < -128)
      2  144d				  -	      ECHO	"Erroneous position value", 100
      3  144d				  -	      ERR
      4  144d					      ENDIF
      5  144d		       64		      .byte.b	100
      0  144e					      EVAL8	120
      1  144e				  -	      IF	(120 > 127) || (120 < -128)
      2  144e				  -	      ECHO	"Erroneous position value", 120
      3  144e				  -	      ERR
      4  144e					      ENDIF
      5  144e		       78		      .byte.b	120
      0  144f					      EVAL8	120
      1  144f				  -	      IF	(120 > 127) || (120 < -128)
      2  144f				  -	      ECHO	"Erroneous position value", 120
      3  144f				  -	      ERR
      4  144f					      ENDIF
      5  144f		       78		      .byte.b	120
      0  1450					      EVAL8	120
      1  1450				  -	      IF	(120 > 127) || (120 < -128)
      2  1450				  -	      ECHO	"Erroneous position value", 120
      3  1450				  -	      ERR
      4  1450					      ENDIF
      5  1450		       78		      .byte.b	120
      0  1451					      EVAL8	120
      1  1451				  -	      IF	(120 > 127) || (120 < -128)
      2  1451				  -	      ECHO	"Erroneous position value", 120
      3  1451				  -	      ERR
      4  1451					      ENDIF
      5  1451		       78		      .byte.b	120
      0  1452					      EVAL8	100
      1  1452				  -	      IF	(100 > 127) || (100 < -128)
      2  1452				  -	      ECHO	"Erroneous position value", 100
      3  1452				  -	      ERR
      4  1452					      ENDIF
      5  1452		       64		      .byte.b	100
      0  1453					      EVAL8	100
      1  1453				  -	      IF	(100 > 127) || (100 < -128)
      2  1453				  -	      ECHO	"Erroneous position value", 100
      3  1453				  -	      ERR
      4  1453					      ENDIF
      5  1453		       64		      .byte.b	100
      0  1454					      EVAL8	0
      1  1454				  -	      IF	(0 > 127) || (0 < -128)
      2  1454				  -	      ECHO	"Erroneous position value", 0
      3  1454				  -	      ERR
      4  1454					      ENDIF
      5  1454		       00		      .byte.b	0
      0  1455					      EVAL8	0
      1  1455				  -	      IF	(0 > 127) || (0 < -128)
      2  1455				  -	      ECHO	"Erroneous position value", 0
      3  1455				  -	      ERR
      4  1455					      ENDIF
      5  1455		       00		      .byte.b	0
      0  1456					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  1456					      EVAL8	0
      1  1456				  -	      IF	(0 > 127) || (0 < -128)
      2  1456				  -	      ECHO	"Erroneous position value", 0
      3  1456				  -	      ERR
      4  1456					      ENDIF
      5  1456		       00		      .byte.b	0
      0  1457					      EVAL8	0
      1  1457				  -	      IF	(0 > 127) || (0 < -128)
      2  1457				  -	      ECHO	"Erroneous position value", 0
      3  1457				  -	      ERR
      4  1457					      ENDIF
      5  1457		       00		      .byte.b	0
      0  1458					      EVAL8	0
      1  1458				  -	      IF	(0 > 127) || (0 < -128)
      2  1458				  -	      ECHO	"Erroneous position value", 0
      3  1458				  -	      ERR
      4  1458					      ENDIF
      5  1458		       00		      .byte.b	0
      0  1459					      EVAL8	0
      1  1459				  -	      IF	(0 > 127) || (0 < -128)
      2  1459				  -	      ECHO	"Erroneous position value", 0
      3  1459				  -	      ERR
      4  1459					      ENDIF
      5  1459		       00		      .byte.b	0
      0  145a					      EVAL8	0
      1  145a				  -	      IF	(0 > 127) || (0 < -128)
      2  145a				  -	      ECHO	"Erroneous position value", 0
      3  145a				  -	      ERR
      4  145a					      ENDIF
      5  145a		       00		      .byte.b	0
      0  145b					      EVAL8	0
      1  145b				  -	      IF	(0 > 127) || (0 < -128)
      2  145b				  -	      ECHO	"Erroneous position value", 0
      3  145b				  -	      ERR
      4  145b					      ENDIF
      5  145b		       00		      .byte.b	0
      0  145c					      EVAL8	0
      1  145c				  -	      IF	(0 > 127) || (0 < -128)
      2  145c				  -	      ECHO	"Erroneous position value", 0
      3  145c				  -	      ERR
      4  145c					      ENDIF
      5  145c		       00		      .byte.b	0
      0  145d					      EVAL8	0
      1  145d				  -	      IF	(0 > 127) || (0 < -128)
      2  145d				  -	      ECHO	"Erroneous position value", 0
      3  145d				  -	      ERR
      4  145d					      ENDIF
      5  145d		       00		      .byte.b	0
      0  145e					      EVAL8	0
      1  145e				  -	      IF	(0 > 127) || (0 < -128)
      2  145e				  -	      ECHO	"Erroneous position value", 0
      3  145e				  -	      ERR
      4  145e					      ENDIF
      5  145e		       00		      .byte.b	0
      0  145f					      EVAL8	0
      1  145f				  -	      IF	(0 > 127) || (0 < -128)
      2  145f				  -	      ECHO	"Erroneous position value", 0
      3  145f				  -	      ERR
      4  145f					      ENDIF
      5  145f		       00		      .byte.b	0
    104  1460
    105  1460							;---------------------------------------------------------------------------------------------------
    106  1460
    107  1460				   PositionalValue_KNIGHT
    108  1460
      0  1460					      PVAL	-50, -30, -30, -30, -30, -30, -22, -50
      0  1460					      EVAL8	-50
      1  1460				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1460				  -	      ECHO	"Erroneous position value", -50
      3  1460				  -	      ERR
      4  1460					      ENDIF
      5  1460		       ce		      .byte.b	-50
      0  1461					      EVAL8	-30
      1  1461				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1461				  -	      ECHO	"Erroneous position value", -30
      3  1461				  -	      ERR
      4  1461					      ENDIF
      5  1461		       e2		      .byte.b	-30
      0  1462					      EVAL8	-30
      1  1462				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1462				  -	      ECHO	"Erroneous position value", -30
      3  1462				  -	      ERR
      4  1462					      ENDIF
      5  1462		       e2		      .byte.b	-30
      0  1463					      EVAL8	-30
      1  1463				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1463				  -	      ECHO	"Erroneous position value", -30
      3  1463				  -	      ERR
      4  1463					      ENDIF
      5  1463		       e2		      .byte.b	-30
      0  1464					      EVAL8	-30
      1  1464				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1464				  -	      ECHO	"Erroneous position value", -30
      3  1464				  -	      ERR
      4  1464					      ENDIF
      5  1464		       e2		      .byte.b	-30
      0  1465					      EVAL8	-30
      1  1465				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1465				  -	      ECHO	"Erroneous position value", -30
      3  1465				  -	      ERR
      4  1465					      ENDIF
      5  1465		       e2		      .byte.b	-30
      0  1466					      EVAL8	-22
      1  1466				  -	      IF	(-22 > 127) || (-22 < -128)
      2  1466				  -	      ECHO	"Erroneous position value", -22
      3  1466				  -	      ERR
      4  1466					      ENDIF
      5  1466		       ea		      .byte.b	-22
      0  1467					      EVAL8	-50
      1  1467				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1467				  -	      ECHO	"Erroneous position value", -50
      3  1467				  -	      ERR
      4  1467					      ENDIF
      5  1467		       ce		      .byte.b	-50
      0  1468					      EVAL8	0
      1  1468				  -	      IF	(0 > 127) || (0 < -128)
      2  1468				  -	      ECHO	"Erroneous position value", 0
      3  1468				  -	      ERR
      4  1468					      ENDIF
      5  1468		       00		      .byte.b	0
      0  1469					      EVAL8	0
      1  1469				  -	      IF	(0 > 127) || (0 < -128)
      2  1469				  -	      ECHO	"Erroneous position value", 0
      3  1469				  -	      ERR
      4  1469					      ENDIF
      5  1469		       00		      .byte.b	0
      0  146a					      PVAL	-40, -20, 0, -5, -25, 0, -20, -40
      0  146a					      EVAL8	-40
      1  146a				  -	      IF	(-40 > 127) || (-40 < -128)
      2  146a				  -	      ECHO	"Erroneous position value", -40
      3  146a				  -	      ERR
      4  146a					      ENDIF
      5  146a		       d8		      .byte.b	-40
      0  146b					      EVAL8	-20
      1  146b				  -	      IF	(-20 > 127) || (-20 < -128)
      2  146b				  -	      ECHO	"Erroneous position value", -20
      3  146b				  -	      ERR
      4  146b					      ENDIF
      5  146b		       ec		      .byte.b	-20
      0  146c					      EVAL8	0
      1  146c				  -	      IF	(0 > 127) || (0 < -128)
      2  146c				  -	      ECHO	"Erroneous position value", 0
      3  146c				  -	      ERR
      4  146c					      ENDIF
      5  146c		       00		      .byte.b	0
      0  146d					      EVAL8	-5
      1  146d				  -	      IF	(-5 > 127) || (-5 < -128)
      2  146d				  -	      ECHO	"Erroneous position value", -5
      3  146d				  -	      ERR
      4  146d					      ENDIF
      5  146d		       fb		      .byte.b	-5
      0  146e					      EVAL8	-25
      1  146e				  -	      IF	(-25 > 127) || (-25 < -128)
      2  146e				  -	      ECHO	"Erroneous position value", -25
      3  146e				  -	      ERR
      4  146e					      ENDIF
      5  146e		       e7		      .byte.b	-25
      0  146f					      EVAL8	0
      1  146f				  -	      IF	(0 > 127) || (0 < -128)
      2  146f				  -	      ECHO	"Erroneous position value", 0
      3  146f				  -	      ERR
      4  146f					      ENDIF
      5  146f		       00		      .byte.b	0
      0  1470					      EVAL8	-20
      1  1470				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1470				  -	      ECHO	"Erroneous position value", -20
      3  1470				  -	      ERR
      4  1470					      ENDIF
      5  1470		       ec		      .byte.b	-20
      0  1471					      EVAL8	-40
      1  1471				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1471				  -	      ECHO	"Erroneous position value", -40
      3  1471				  -	      ERR
      4  1471					      ENDIF
      5  1471		       d8		      .byte.b	-40
      0  1472					      EVAL8	0
      1  1472				  -	      IF	(0 > 127) || (0 < -128)
      2  1472				  -	      ECHO	"Erroneous position value", 0
      3  1472				  -	      ERR
      4  1472					      ENDIF
      5  1472		       00		      .byte.b	0
      0  1473					      EVAL8	0
      1  1473				  -	      IF	(0 > 127) || (0 < -128)
      2  1473				  -	      ECHO	"Erroneous position value", 0
      3  1473				  -	      ERR
      4  1473					      ENDIF
      5  1473		       00		      .byte.b	0
      0  1474					      PVAL	-30, 0, 18, 15, 15, 18, 0, -30
      0  1474					      EVAL8	-30
      1  1474				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1474				  -	      ECHO	"Erroneous position value", -30
      3  1474				  -	      ERR
      4  1474					      ENDIF
      5  1474		       e2		      .byte.b	-30
      0  1475					      EVAL8	0
      1  1475				  -	      IF	(0 > 127) || (0 < -128)
      2  1475				  -	      ECHO	"Erroneous position value", 0
      3  1475				  -	      ERR
      4  1475					      ENDIF
      5  1475		       00		      .byte.b	0
      0  1476					      EVAL8	18
      1  1476				  -	      IF	(18 > 127) || (18 < -128)
      2  1476				  -	      ECHO	"Erroneous position value", 18
      3  1476				  -	      ERR
      4  1476					      ENDIF
      5  1476		       12		      .byte.b	18
      0  1477					      EVAL8	15
      1  1477				  -	      IF	(15 > 127) || (15 < -128)
      2  1477				  -	      ECHO	"Erroneous position value", 15
      3  1477				  -	      ERR
      4  1477					      ENDIF
      5  1477		       0f		      .byte.b	15
      0  1478					      EVAL8	15
      1  1478				  -	      IF	(15 > 127) || (15 < -128)
      2  1478				  -	      ECHO	"Erroneous position value", 15
      3  1478				  -	      ERR
      4  1478					      ENDIF
      5  1478		       0f		      .byte.b	15
      0  1479					      EVAL8	18
      1  1479				  -	      IF	(18 > 127) || (18 < -128)
      2  1479				  -	      ECHO	"Erroneous position value", 18
      3  1479				  -	      ERR
      4  1479					      ENDIF
      5  1479		       12		      .byte.b	18
      0  147a					      EVAL8	0
      1  147a				  -	      IF	(0 > 127) || (0 < -128)
      2  147a				  -	      ECHO	"Erroneous position value", 0
      3  147a				  -	      ERR
      4  147a					      ENDIF
      5  147a		       00		      .byte.b	0
      0  147b					      EVAL8	-30
      1  147b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  147b				  -	      ECHO	"Erroneous position value", -30
      3  147b				  -	      ERR
      4  147b					      ENDIF
      5  147b		       e2		      .byte.b	-30
      0  147c					      EVAL8	0
      1  147c				  -	      IF	(0 > 127) || (0 < -128)
      2  147c				  -	      ECHO	"Erroneous position value", 0
      3  147c				  -	      ERR
      4  147c					      ENDIF
      5  147c		       00		      .byte.b	0
      0  147d					      EVAL8	0
      1  147d				  -	      IF	(0 > 127) || (0 < -128)
      2  147d				  -	      ECHO	"Erroneous position value", 0
      3  147d				  -	      ERR
      4  147d					      ENDIF
      5  147d		       00		      .byte.b	0
      0  147e					      PVAL	-40, 0, 15, 30, 30, 15, 0, -40
      0  147e					      EVAL8	-40
      1  147e				  -	      IF	(-40 > 127) || (-40 < -128)
      2  147e				  -	      ECHO	"Erroneous position value", -40
      3  147e				  -	      ERR
      4  147e					      ENDIF
      5  147e		       d8		      .byte.b	-40
      0  147f					      EVAL8	0
      1  147f				  -	      IF	(0 > 127) || (0 < -128)
      2  147f				  -	      ECHO	"Erroneous position value", 0
      3  147f				  -	      ERR
      4  147f					      ENDIF
      5  147f		       00		      .byte.b	0
      0  1480					      EVAL8	15
      1  1480				  -	      IF	(15 > 127) || (15 < -128)
      2  1480				  -	      ECHO	"Erroneous position value", 15
      3  1480				  -	      ERR
      4  1480					      ENDIF
      5  1480		       0f		      .byte.b	15
      0  1481					      EVAL8	30
      1  1481				  -	      IF	(30 > 127) || (30 < -128)
      2  1481				  -	      ECHO	"Erroneous position value", 30
      3  1481				  -	      ERR
      4  1481					      ENDIF
      5  1481		       1e		      .byte.b	30
      0  1482					      EVAL8	30
      1  1482				  -	      IF	(30 > 127) || (30 < -128)
      2  1482				  -	      ECHO	"Erroneous position value", 30
      3  1482				  -	      ERR
      4  1482					      ENDIF
      5  1482		       1e		      .byte.b	30
      0  1483					      EVAL8	15
      1  1483				  -	      IF	(15 > 127) || (15 < -128)
      2  1483				  -	      ECHO	"Erroneous position value", 15
      3  1483				  -	      ERR
      4  1483					      ENDIF
      5  1483		       0f		      .byte.b	15
      0  1484					      EVAL8	0
      1  1484				  -	      IF	(0 > 127) || (0 < -128)
      2  1484				  -	      ECHO	"Erroneous position value", 0
      3  1484				  -	      ERR
      4  1484					      ENDIF
      5  1484		       00		      .byte.b	0
      0  1485					      EVAL8	-40
      1  1485				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1485				  -	      ECHO	"Erroneous position value", -40
      3  1485				  -	      ERR
      4  1485					      ENDIF
      5  1485		       d8		      .byte.b	-40
      0  1486					      EVAL8	0
      1  1486				  -	      IF	(0 > 127) || (0 < -128)
      2  1486				  -	      ECHO	"Erroneous position value", 0
      3  1486				  -	      ERR
      4  1486					      ENDIF
      5  1486		       00		      .byte.b	0
      0  1487					      EVAL8	0
      1  1487				  -	      IF	(0 > 127) || (0 < -128)
      2  1487				  -	      ECHO	"Erroneous position value", 0
      3  1487				  -	      ERR
      4  1487					      ENDIF
      5  1487		       00		      .byte.b	0
      0  1488					      PVAL	-40, 5, 15, 30, 30, 15, 5, -40
      0  1488					      EVAL8	-40
      1  1488				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1488				  -	      ECHO	"Erroneous position value", -40
      3  1488				  -	      ERR
      4  1488					      ENDIF
      5  1488		       d8		      .byte.b	-40
      0  1489					      EVAL8	5
      1  1489				  -	      IF	(5 > 127) || (5 < -128)
      2  1489				  -	      ECHO	"Erroneous position value", 5
      3  1489				  -	      ERR
      4  1489					      ENDIF
      5  1489		       05		      .byte.b	5
      0  148a					      EVAL8	15
      1  148a				  -	      IF	(15 > 127) || (15 < -128)
      2  148a				  -	      ECHO	"Erroneous position value", 15
      3  148a				  -	      ERR
      4  148a					      ENDIF
      5  148a		       0f		      .byte.b	15
      0  148b					      EVAL8	30
      1  148b				  -	      IF	(30 > 127) || (30 < -128)
      2  148b				  -	      ECHO	"Erroneous position value", 30
      3  148b				  -	      ERR
      4  148b					      ENDIF
      5  148b		       1e		      .byte.b	30
      0  148c					      EVAL8	30
      1  148c				  -	      IF	(30 > 127) || (30 < -128)
      2  148c				  -	      ECHO	"Erroneous position value", 30
      3  148c				  -	      ERR
      4  148c					      ENDIF
      5  148c		       1e		      .byte.b	30
      0  148d					      EVAL8	15
      1  148d				  -	      IF	(15 > 127) || (15 < -128)
      2  148d				  -	      ECHO	"Erroneous position value", 15
      3  148d				  -	      ERR
      4  148d					      ENDIF
      5  148d		       0f		      .byte.b	15
      0  148e					      EVAL8	5
      1  148e				  -	      IF	(5 > 127) || (5 < -128)
      2  148e				  -	      ECHO	"Erroneous position value", 5
      3  148e				  -	      ERR
      4  148e					      ENDIF
      5  148e		       05		      .byte.b	5
      0  148f					      EVAL8	-40
      1  148f				  -	      IF	(-40 > 127) || (-40 < -128)
      2  148f				  -	      ECHO	"Erroneous position value", -40
      3  148f				  -	      ERR
      4  148f					      ENDIF
      5  148f		       d8		      .byte.b	-40
      0  1490					      EVAL8	0
      1  1490				  -	      IF	(0 > 127) || (0 < -128)
      2  1490				  -	      ECHO	"Erroneous position value", 0
      3  1490				  -	      ERR
      4  1490					      ENDIF
      5  1490		       00		      .byte.b	0
      0  1491					      EVAL8	0
      1  1491				  -	      IF	(0 > 127) || (0 < -128)
      2  1491				  -	      ECHO	"Erroneous position value", 0
      3  1491				  -	      ERR
      4  1491					      ENDIF
      5  1491		       00		      .byte.b	0
      0  1492					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      0  1492					      EVAL8	-30
      1  1492				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1492				  -	      ECHO	"Erroneous position value", -30
      3  1492				  -	      ERR
      4  1492					      ENDIF
      5  1492		       e2		      .byte.b	-30
      0  1493					      EVAL8	0
      1  1493				  -	      IF	(0 > 127) || (0 < -128)
      2  1493				  -	      ECHO	"Erroneous position value", 0
      3  1493				  -	      ERR
      4  1493					      ENDIF
      5  1493		       00		      .byte.b	0
      0  1494					      EVAL8	10
      1  1494				  -	      IF	(10 > 127) || (10 < -128)
      2  1494				  -	      ECHO	"Erroneous position value", 10
      3  1494				  -	      ERR
      4  1494					      ENDIF
      5  1494		       0a		      .byte.b	10
      0  1495					      EVAL8	15
      1  1495				  -	      IF	(15 > 127) || (15 < -128)
      2  1495				  -	      ECHO	"Erroneous position value", 15
      3  1495				  -	      ERR
      4  1495					      ENDIF
      5  1495		       0f		      .byte.b	15
      0  1496					      EVAL8	15
      1  1496				  -	      IF	(15 > 127) || (15 < -128)
      2  1496				  -	      ECHO	"Erroneous position value", 15
      3  1496				  -	      ERR
      4  1496					      ENDIF
      5  1496		       0f		      .byte.b	15
      0  1497					      EVAL8	10
      1  1497				  -	      IF	(10 > 127) || (10 < -128)
      2  1497				  -	      ECHO	"Erroneous position value", 10
      3  1497				  -	      ERR
      4  1497					      ENDIF
      5  1497		       0a		      .byte.b	10
      0  1498					      EVAL8	0
      1  1498				  -	      IF	(0 > 127) || (0 < -128)
      2  1498				  -	      ECHO	"Erroneous position value", 0
      3  1498				  -	      ERR
      4  1498					      ENDIF
      5  1498		       00		      .byte.b	0
      0  1499					      EVAL8	-30
      1  1499				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1499				  -	      ECHO	"Erroneous position value", -30
      3  1499				  -	      ERR
      4  1499					      ENDIF
      5  1499		       e2		      .byte.b	-30
      0  149a					      EVAL8	0
      1  149a				  -	      IF	(0 > 127) || (0 < -128)
      2  149a				  -	      ECHO	"Erroneous position value", 0
      3  149a				  -	      ERR
      4  149a					      ENDIF
      5  149a		       00		      .byte.b	0
      0  149b					      EVAL8	0
      1  149b				  -	      IF	(0 > 127) || (0 < -128)
      2  149b				  -	      ECHO	"Erroneous position value", 0
      3  149b				  -	      ERR
      4  149b					      ENDIF
      5  149b		       00		      .byte.b	0
      0  149c					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      0  149c					      EVAL8	-40
      1  149c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  149c				  -	      ECHO	"Erroneous position value", -40
      3  149c				  -	      ERR
      4  149c					      ENDIF
      5  149c		       d8		      .byte.b	-40
      0  149d					      EVAL8	-20
      1  149d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  149d				  -	      ECHO	"Erroneous position value", -20
      3  149d				  -	      ERR
      4  149d					      ENDIF
      5  149d		       ec		      .byte.b	-20
      0  149e					      EVAL8	30
      1  149e				  -	      IF	(30 > 127) || (30 < -128)
      2  149e				  -	      ECHO	"Erroneous position value", 30
      3  149e				  -	      ERR
      4  149e					      ENDIF
      5  149e		       1e		      .byte.b	30
      0  149f					      EVAL8	0
      1  149f				  -	      IF	(0 > 127) || (0 < -128)
      2  149f				  -	      ECHO	"Erroneous position value", 0
      3  149f				  -	      ERR
      4  149f					      ENDIF
      5  149f		       00		      .byte.b	0
      0  14a0					      EVAL8	0
      1  14a0				  -	      IF	(0 > 127) || (0 < -128)
      2  14a0				  -	      ECHO	"Erroneous position value", 0
      3  14a0				  -	      ERR
      4  14a0					      ENDIF
      5  14a0		       00		      .byte.b	0
      0  14a1					      EVAL8	30
      1  14a1				  -	      IF	(30 > 127) || (30 < -128)
      2  14a1				  -	      ECHO	"Erroneous position value", 30
      3  14a1				  -	      ERR
      4  14a1					      ENDIF
      5  14a1		       1e		      .byte.b	30
      0  14a2					      EVAL8	-20
      1  14a2				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14a2				  -	      ECHO	"Erroneous position value", -20
      3  14a2				  -	      ERR
      4  14a2					      ENDIF
      5  14a2		       ec		      .byte.b	-20
      0  14a3					      EVAL8	-40
      1  14a3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  14a3				  -	      ECHO	"Erroneous position value", -40
      3  14a3				  -	      ERR
      4  14a3					      ENDIF
      5  14a3		       d8		      .byte.b	-40
      0  14a4					      EVAL8	0
      1  14a4				  -	      IF	(0 > 127) || (0 < -128)
      2  14a4				  -	      ECHO	"Erroneous position value", 0
      3  14a4				  -	      ERR
      4  14a4					      ENDIF
      5  14a4		       00		      .byte.b	0
      0  14a5					      EVAL8	0
      1  14a5				  -	      IF	(0 > 127) || (0 < -128)
      2  14a5				  -	      ECHO	"Erroneous position value", 0
      3  14a5				  -	      ERR
      4  14a5					      ENDIF
      5  14a5		       00		      .byte.b	0
      0  14a6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      0  14a6					      EVAL8	-50
      1  14a6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  14a6				  -	      ECHO	"Erroneous position value", -50
      3  14a6				  -	      ERR
      4  14a6					      ENDIF
      5  14a6		       ce		      .byte.b	-50
      0  14a7					      EVAL8	-20
      1  14a7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14a7				  -	      ECHO	"Erroneous position value", -20
      3  14a7				  -	      ERR
      4  14a7					      ENDIF
      5  14a7		       ec		      .byte.b	-20
      0  14a8					      EVAL8	-30
      1  14a8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  14a8				  -	      ECHO	"Erroneous position value", -30
      3  14a8				  -	      ERR
      4  14a8					      ENDIF
      5  14a8		       e2		      .byte.b	-30
      0  14a9					      EVAL8	-30
      1  14a9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  14a9				  -	      ECHO	"Erroneous position value", -30
      3  14a9				  -	      ERR
      4  14a9					      ENDIF
      5  14a9		       e2		      .byte.b	-30
      0  14aa					      EVAL8	-30
      1  14aa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  14aa				  -	      ECHO	"Erroneous position value", -30
      3  14aa				  -	      ERR
      4  14aa					      ENDIF
      5  14aa		       e2		      .byte.b	-30
      0  14ab					      EVAL8	-30
      1  14ab				  -	      IF	(-30 > 127) || (-30 < -128)
      2  14ab				  -	      ECHO	"Erroneous position value", -30
      3  14ab				  -	      ERR
      4  14ab					      ENDIF
      5  14ab		       e2		      .byte.b	-30
      0  14ac					      EVAL8	-20
      1  14ac				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14ac				  -	      ECHO	"Erroneous position value", -20
      3  14ac				  -	      ERR
      4  14ac					      ENDIF
      5  14ac		       ec		      .byte.b	-20
      0  14ad					      EVAL8	-50
      1  14ad				  -	      IF	(-50 > 127) || (-50 < -128)
      2  14ad				  -	      ECHO	"Erroneous position value", -50
      3  14ad				  -	      ERR
      4  14ad					      ENDIF
      5  14ad		       ce		      .byte.b	-50
      0  14ae					      EVAL8	0
      1  14ae				  -	      IF	(0 > 127) || (0 < -128)
      2  14ae				  -	      ECHO	"Erroneous position value", 0
      3  14ae				  -	      ERR
      4  14ae					      ENDIF
      5  14ae		       00		      .byte.b	0
      0  14af					      EVAL8	0
      1  14af				  -	      IF	(0 > 127) || (0 < -128)
      2  14af				  -	      ECHO	"Erroneous position value", 0
      3  14af				  -	      ERR
      4  14af					      ENDIF
      5  14af		       00		      .byte.b	0
    117  14b0
    118  14b0
    119  14b0							;---------------------------------------------------------------------------------------------------
    120  14b0
    121  14b0				   PositionalValue_BISHOP
    122  14b0
      0  14b0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      0  14b0					      EVAL8	-20
      1  14b0				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14b0				  -	      ECHO	"Erroneous position value", -20
      3  14b0				  -	      ERR
      4  14b0					      ENDIF
      5  14b0		       ec		      .byte.b	-20
      0  14b1					      EVAL8	-10
      1  14b1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14b1				  -	      ECHO	"Erroneous position value", -10
      3  14b1				  -	      ERR
      4  14b1					      ENDIF
      5  14b1		       f6		      .byte.b	-10
      0  14b2					      EVAL8	-50
      1  14b2				  -	      IF	(-50 > 127) || (-50 < -128)
      2  14b2				  -	      ECHO	"Erroneous position value", -50
      3  14b2				  -	      ERR
      4  14b2					      ENDIF
      5  14b2		       ce		      .byte.b	-50
      0  14b3					      EVAL8	-10
      1  14b3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14b3				  -	      ECHO	"Erroneous position value", -10
      3  14b3				  -	      ERR
      4  14b3					      ENDIF
      5  14b3		       f6		      .byte.b	-10
      0  14b4					      EVAL8	-10
      1  14b4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14b4				  -	      ECHO	"Erroneous position value", -10
      3  14b4				  -	      ERR
      4  14b4					      ENDIF
      5  14b4		       f6		      .byte.b	-10
      0  14b5					      EVAL8	-50
      1  14b5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  14b5				  -	      ECHO	"Erroneous position value", -50
      3  14b5				  -	      ERR
      4  14b5					      ENDIF
      5  14b5		       ce		      .byte.b	-50
      0  14b6					      EVAL8	-10
      1  14b6				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14b6				  -	      ECHO	"Erroneous position value", -10
      3  14b6				  -	      ERR
      4  14b6					      ENDIF
      5  14b6		       f6		      .byte.b	-10
      0  14b7					      EVAL8	-20
      1  14b7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14b7				  -	      ECHO	"Erroneous position value", -20
      3  14b7				  -	      ERR
      4  14b7					      ENDIF
      5  14b7		       ec		      .byte.b	-20
      0  14b8					      EVAL8	0
      1  14b8				  -	      IF	(0 > 127) || (0 < -128)
      2  14b8				  -	      ECHO	"Erroneous position value", 0
      3  14b8				  -	      ERR
      4  14b8					      ENDIF
      5  14b8		       00		      .byte.b	0
      0  14b9					      EVAL8	0
      1  14b9				  -	      IF	(0 > 127) || (0 < -128)
      2  14b9				  -	      ECHO	"Erroneous position value", 0
      3  14b9				  -	      ERR
      4  14b9					      ENDIF
      5  14b9		       00		      .byte.b	0
      0  14ba					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      0  14ba					      EVAL8	-10
      1  14ba				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14ba				  -	      ECHO	"Erroneous position value", -10
      3  14ba				  -	      ERR
      4  14ba					      ENDIF
      5  14ba		       f6		      .byte.b	-10
      0  14bb					      EVAL8	5
      1  14bb				  -	      IF	(5 > 127) || (5 < -128)
      2  14bb				  -	      ECHO	"Erroneous position value", 5
      3  14bb				  -	      ERR
      4  14bb					      ENDIF
      5  14bb		       05		      .byte.b	5
      0  14bc					      EVAL8	0
      1  14bc				  -	      IF	(0 > 127) || (0 < -128)
      2  14bc				  -	      ECHO	"Erroneous position value", 0
      3  14bc				  -	      ERR
      4  14bc					      ENDIF
      5  14bc		       00		      .byte.b	0
      0  14bd					      EVAL8	0
      1  14bd				  -	      IF	(0 > 127) || (0 < -128)
      2  14bd				  -	      ECHO	"Erroneous position value", 0
      3  14bd				  -	      ERR
      4  14bd					      ENDIF
      5  14bd		       00		      .byte.b	0
      0  14be					      EVAL8	0
      1  14be				  -	      IF	(0 > 127) || (0 < -128)
      2  14be				  -	      ECHO	"Erroneous position value", 0
      3  14be				  -	      ERR
      4  14be					      ENDIF
      5  14be		       00		      .byte.b	0
      0  14bf					      EVAL8	0
      1  14bf				  -	      IF	(0 > 127) || (0 < -128)
      2  14bf				  -	      ECHO	"Erroneous position value", 0
      3  14bf				  -	      ERR
      4  14bf					      ENDIF
      5  14bf		       00		      .byte.b	0
      0  14c0					      EVAL8	5
      1  14c0				  -	      IF	(5 > 127) || (5 < -128)
      2  14c0				  -	      ECHO	"Erroneous position value", 5
      3  14c0				  -	      ERR
      4  14c0					      ENDIF
      5  14c0		       05		      .byte.b	5
      0  14c1					      EVAL8	-10
      1  14c1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14c1				  -	      ECHO	"Erroneous position value", -10
      3  14c1				  -	      ERR
      4  14c1					      ENDIF
      5  14c1		       f6		      .byte.b	-10
      0  14c2					      EVAL8	0
      1  14c2				  -	      IF	(0 > 127) || (0 < -128)
      2  14c2				  -	      ECHO	"Erroneous position value", 0
      3  14c2				  -	      ERR
      4  14c2					      ENDIF
      5  14c2		       00		      .byte.b	0
      0  14c3					      EVAL8	0
      1  14c3				  -	      IF	(0 > 127) || (0 < -128)
      2  14c3				  -	      ECHO	"Erroneous position value", 0
      3  14c3				  -	      ERR
      4  14c3					      ENDIF
      5  14c3		       00		      .byte.b	0
      0  14c4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      0  14c4					      EVAL8	-10
      1  14c4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14c4				  -	      ECHO	"Erroneous position value", -10
      3  14c4				  -	      ERR
      4  14c4					      ENDIF
      5  14c4		       f6		      .byte.b	-10
      0  14c5					      EVAL8	10
      1  14c5				  -	      IF	(10 > 127) || (10 < -128)
      2  14c5				  -	      ECHO	"Erroneous position value", 10
      3  14c5				  -	      ERR
      4  14c5					      ENDIF
      5  14c5		       0a		      .byte.b	10
      0  14c6					      EVAL8	10
      1  14c6				  -	      IF	(10 > 127) || (10 < -128)
      2  14c6				  -	      ECHO	"Erroneous position value", 10
      3  14c6				  -	      ERR
      4  14c6					      ENDIF
      5  14c6		       0a		      .byte.b	10
      0  14c7					      EVAL8	10
      1  14c7				  -	      IF	(10 > 127) || (10 < -128)
      2  14c7				  -	      ECHO	"Erroneous position value", 10
      3  14c7				  -	      ERR
      4  14c7					      ENDIF
      5  14c7		       0a		      .byte.b	10
      0  14c8					      EVAL8	10
      1  14c8				  -	      IF	(10 > 127) || (10 < -128)
      2  14c8				  -	      ECHO	"Erroneous position value", 10
      3  14c8				  -	      ERR
      4  14c8					      ENDIF
      5  14c8		       0a		      .byte.b	10
      0  14c9					      EVAL8	10
      1  14c9				  -	      IF	(10 > 127) || (10 < -128)
      2  14c9				  -	      ECHO	"Erroneous position value", 10
      3  14c9				  -	      ERR
      4  14c9					      ENDIF
      5  14c9		       0a		      .byte.b	10
      0  14ca					      EVAL8	10
      1  14ca				  -	      IF	(10 > 127) || (10 < -128)
      2  14ca				  -	      ECHO	"Erroneous position value", 10
      3  14ca				  -	      ERR
      4  14ca					      ENDIF
      5  14ca		       0a		      .byte.b	10
      0  14cb					      EVAL8	-10
      1  14cb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14cb				  -	      ECHO	"Erroneous position value", -10
      3  14cb				  -	      ERR
      4  14cb					      ENDIF
      5  14cb		       f6		      .byte.b	-10
      0  14cc					      EVAL8	0
      1  14cc				  -	      IF	(0 > 127) || (0 < -128)
      2  14cc				  -	      ECHO	"Erroneous position value", 0
      3  14cc				  -	      ERR
      4  14cc					      ENDIF
      5  14cc		       00		      .byte.b	0
      0  14cd					      EVAL8	0
      1  14cd				  -	      IF	(0 > 127) || (0 < -128)
      2  14cd				  -	      ECHO	"Erroneous position value", 0
      3  14cd				  -	      ERR
      4  14cd					      ENDIF
      5  14cd		       00		      .byte.b	0
      0  14ce					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      0  14ce					      EVAL8	-10
      1  14ce				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14ce				  -	      ECHO	"Erroneous position value", -10
      3  14ce				  -	      ERR
      4  14ce					      ENDIF
      5  14ce		       f6		      .byte.b	-10
      0  14cf					      EVAL8	0
      1  14cf				  -	      IF	(0 > 127) || (0 < -128)
      2  14cf				  -	      ECHO	"Erroneous position value", 0
      3  14cf				  -	      ERR
      4  14cf					      ENDIF
      5  14cf		       00		      .byte.b	0
      0  14d0					      EVAL8	10
      1  14d0				  -	      IF	(10 > 127) || (10 < -128)
      2  14d0				  -	      ECHO	"Erroneous position value", 10
      3  14d0				  -	      ERR
      4  14d0					      ENDIF
      5  14d0		       0a		      .byte.b	10
      0  14d1					      EVAL8	20
      1  14d1				  -	      IF	(20 > 127) || (20 < -128)
      2  14d1				  -	      ECHO	"Erroneous position value", 20
      3  14d1				  -	      ERR
      4  14d1					      ENDIF
      5  14d1		       14		      .byte.b	20
      0  14d2					      EVAL8	20
      1  14d2				  -	      IF	(20 > 127) || (20 < -128)
      2  14d2				  -	      ECHO	"Erroneous position value", 20
      3  14d2				  -	      ERR
      4  14d2					      ENDIF
      5  14d2		       14		      .byte.b	20
      0  14d3					      EVAL8	10
      1  14d3				  -	      IF	(10 > 127) || (10 < -128)
      2  14d3				  -	      ECHO	"Erroneous position value", 10
      3  14d3				  -	      ERR
      4  14d3					      ENDIF
      5  14d3		       0a		      .byte.b	10
      0  14d4					      EVAL8	0
      1  14d4				  -	      IF	(0 > 127) || (0 < -128)
      2  14d4				  -	      ECHO	"Erroneous position value", 0
      3  14d4				  -	      ERR
      4  14d4					      ENDIF
      5  14d4		       00		      .byte.b	0
      0  14d5					      EVAL8	-10
      1  14d5				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14d5				  -	      ECHO	"Erroneous position value", -10
      3  14d5				  -	      ERR
      4  14d5					      ENDIF
      5  14d5		       f6		      .byte.b	-10
      0  14d6					      EVAL8	0
      1  14d6				  -	      IF	(0 > 127) || (0 < -128)
      2  14d6				  -	      ECHO	"Erroneous position value", 0
      3  14d6				  -	      ERR
      4  14d6					      ENDIF
      5  14d6		       00		      .byte.b	0
      0  14d7					      EVAL8	0
      1  14d7				  -	      IF	(0 > 127) || (0 < -128)
      2  14d7				  -	      ECHO	"Erroneous position value", 0
      3  14d7				  -	      ERR
      4  14d7					      ENDIF
      5  14d7		       00		      .byte.b	0
      0  14d8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      0  14d8					      EVAL8	-10
      1  14d8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14d8				  -	      ECHO	"Erroneous position value", -10
      3  14d8				  -	      ERR
      4  14d8					      ENDIF
      5  14d8		       f6		      .byte.b	-10
      0  14d9					      EVAL8	5
      1  14d9				  -	      IF	(5 > 127) || (5 < -128)
      2  14d9				  -	      ECHO	"Erroneous position value", 5
      3  14d9				  -	      ERR
      4  14d9					      ENDIF
      5  14d9		       05		      .byte.b	5
      0  14da					      EVAL8	5
      1  14da				  -	      IF	(5 > 127) || (5 < -128)
      2  14da				  -	      ECHO	"Erroneous position value", 5
      3  14da				  -	      ERR
      4  14da					      ENDIF
      5  14da		       05		      .byte.b	5
      0  14db					      EVAL8	20
      1  14db				  -	      IF	(20 > 127) || (20 < -128)
      2  14db				  -	      ECHO	"Erroneous position value", 20
      3  14db				  -	      ERR
      4  14db					      ENDIF
      5  14db		       14		      .byte.b	20
      0  14dc					      EVAL8	20
      1  14dc				  -	      IF	(20 > 127) || (20 < -128)
      2  14dc				  -	      ECHO	"Erroneous position value", 20
      3  14dc				  -	      ERR
      4  14dc					      ENDIF
      5  14dc		       14		      .byte.b	20
      0  14dd					      EVAL8	5
      1  14dd				  -	      IF	(5 > 127) || (5 < -128)
      2  14dd				  -	      ECHO	"Erroneous position value", 5
      3  14dd				  -	      ERR
      4  14dd					      ENDIF
      5  14dd		       05		      .byte.b	5
      0  14de					      EVAL8	5
      1  14de				  -	      IF	(5 > 127) || (5 < -128)
      2  14de				  -	      ECHO	"Erroneous position value", 5
      3  14de				  -	      ERR
      4  14de					      ENDIF
      5  14de		       05		      .byte.b	5
      0  14df					      EVAL8	-10
      1  14df				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14df				  -	      ECHO	"Erroneous position value", -10
      3  14df				  -	      ERR
      4  14df					      ENDIF
      5  14df		       f6		      .byte.b	-10
      0  14e0					      EVAL8	0
      1  14e0				  -	      IF	(0 > 127) || (0 < -128)
      2  14e0				  -	      ECHO	"Erroneous position value", 0
      3  14e0				  -	      ERR
      4  14e0					      ENDIF
      5  14e0		       00		      .byte.b	0
      0  14e1					      EVAL8	0
      1  14e1				  -	      IF	(0 > 127) || (0 < -128)
      2  14e1				  -	      ECHO	"Erroneous position value", 0
      3  14e1				  -	      ERR
      4  14e1					      ENDIF
      5  14e1		       00		      .byte.b	0
      0  14e2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      0  14e2					      EVAL8	-10
      1  14e2				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14e2				  -	      ECHO	"Erroneous position value", -10
      3  14e2				  -	      ERR
      4  14e2					      ENDIF
      5  14e2		       f6		      .byte.b	-10
      0  14e3					      EVAL8	0
      1  14e3				  -	      IF	(0 > 127) || (0 < -128)
      2  14e3				  -	      ECHO	"Erroneous position value", 0
      3  14e3				  -	      ERR
      4  14e3					      ENDIF
      5  14e3		       00		      .byte.b	0
      0  14e4					      EVAL8	5
      1  14e4				  -	      IF	(5 > 127) || (5 < -128)
      2  14e4				  -	      ECHO	"Erroneous position value", 5
      3  14e4				  -	      ERR
      4  14e4					      ENDIF
      5  14e4		       05		      .byte.b	5
      0  14e5					      EVAL8	10
      1  14e5				  -	      IF	(10 > 127) || (10 < -128)
      2  14e5				  -	      ECHO	"Erroneous position value", 10
      3  14e5				  -	      ERR
      4  14e5					      ENDIF
      5  14e5		       0a		      .byte.b	10
      0  14e6					      EVAL8	10
      1  14e6				  -	      IF	(10 > 127) || (10 < -128)
      2  14e6				  -	      ECHO	"Erroneous position value", 10
      3  14e6				  -	      ERR
      4  14e6					      ENDIF
      5  14e6		       0a		      .byte.b	10
      0  14e7					      EVAL8	5
      1  14e7				  -	      IF	(5 > 127) || (5 < -128)
      2  14e7				  -	      ECHO	"Erroneous position value", 5
      3  14e7				  -	      ERR
      4  14e7					      ENDIF
      5  14e7		       05		      .byte.b	5
      0  14e8					      EVAL8	0
      1  14e8				  -	      IF	(0 > 127) || (0 < -128)
      2  14e8				  -	      ECHO	"Erroneous position value", 0
      3  14e8				  -	      ERR
      4  14e8					      ENDIF
      5  14e8		       00		      .byte.b	0
      0  14e9					      EVAL8	-10
      1  14e9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14e9				  -	      ECHO	"Erroneous position value", -10
      3  14e9				  -	      ERR
      4  14e9					      ENDIF
      5  14e9		       f6		      .byte.b	-10
      0  14ea					      EVAL8	0
      1  14ea				  -	      IF	(0 > 127) || (0 < -128)
      2  14ea				  -	      ECHO	"Erroneous position value", 0
      3  14ea				  -	      ERR
      4  14ea					      ENDIF
      5  14ea		       00		      .byte.b	0
      0  14eb					      EVAL8	0
      1  14eb				  -	      IF	(0 > 127) || (0 < -128)
      2  14eb				  -	      ECHO	"Erroneous position value", 0
      3  14eb				  -	      ERR
      4  14eb					      ENDIF
      5  14eb		       00		      .byte.b	0
      0  14ec					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  14ec					      EVAL8	-10
      1  14ec				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14ec				  -	      ECHO	"Erroneous position value", -10
      3  14ec				  -	      ERR
      4  14ec					      ENDIF
      5  14ec		       f6		      .byte.b	-10
      0  14ed					      EVAL8	0
      1  14ed				  -	      IF	(0 > 127) || (0 < -128)
      2  14ed				  -	      ECHO	"Erroneous position value", 0
      3  14ed				  -	      ERR
      4  14ed					      ENDIF
      5  14ed		       00		      .byte.b	0
      0  14ee					      EVAL8	0
      1  14ee				  -	      IF	(0 > 127) || (0 < -128)
      2  14ee				  -	      ECHO	"Erroneous position value", 0
      3  14ee				  -	      ERR
      4  14ee					      ENDIF
      5  14ee		       00		      .byte.b	0
      0  14ef					      EVAL8	0
      1  14ef				  -	      IF	(0 > 127) || (0 < -128)
      2  14ef				  -	      ECHO	"Erroneous position value", 0
      3  14ef				  -	      ERR
      4  14ef					      ENDIF
      5  14ef		       00		      .byte.b	0
      0  14f0					      EVAL8	0
      1  14f0				  -	      IF	(0 > 127) || (0 < -128)
      2  14f0				  -	      ECHO	"Erroneous position value", 0
      3  14f0				  -	      ERR
      4  14f0					      ENDIF
      5  14f0		       00		      .byte.b	0
      0  14f1					      EVAL8	0
      1  14f1				  -	      IF	(0 > 127) || (0 < -128)
      2  14f1				  -	      ECHO	"Erroneous position value", 0
      3  14f1				  -	      ERR
      4  14f1					      ENDIF
      5  14f1		       00		      .byte.b	0
      0  14f2					      EVAL8	0
      1  14f2				  -	      IF	(0 > 127) || (0 < -128)
      2  14f2				  -	      ECHO	"Erroneous position value", 0
      3  14f2				  -	      ERR
      4  14f2					      ENDIF
      5  14f2		       00		      .byte.b	0
      0  14f3					      EVAL8	-10
      1  14f3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14f3				  -	      ECHO	"Erroneous position value", -10
      3  14f3				  -	      ERR
      4  14f3					      ENDIF
      5  14f3		       f6		      .byte.b	-10
      0  14f4					      EVAL8	0
      1  14f4				  -	      IF	(0 > 127) || (0 < -128)
      2  14f4				  -	      ECHO	"Erroneous position value", 0
      3  14f4				  -	      ERR
      4  14f4					      ENDIF
      5  14f4		       00		      .byte.b	0
      0  14f5					      EVAL8	0
      1  14f5				  -	      IF	(0 > 127) || (0 < -128)
      2  14f5				  -	      ECHO	"Erroneous position value", 0
      3  14f5				  -	      ERR
      4  14f5					      ENDIF
      5  14f5		       00		      .byte.b	0
      0  14f6					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      0  14f6					      EVAL8	-20
      1  14f6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14f6				  -	      ECHO	"Erroneous position value", -20
      3  14f6				  -	      ERR
      4  14f6					      ENDIF
      5  14f6		       ec		      .byte.b	-20
      0  14f7					      EVAL8	-10
      1  14f7				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14f7				  -	      ECHO	"Erroneous position value", -10
      3  14f7				  -	      ERR
      4  14f7					      ENDIF
      5  14f7		       f6		      .byte.b	-10
      0  14f8					      EVAL8	-10
      1  14f8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14f8				  -	      ECHO	"Erroneous position value", -10
      3  14f8				  -	      ERR
      4  14f8					      ENDIF
      5  14f8		       f6		      .byte.b	-10
      0  14f9					      EVAL8	-10
      1  14f9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14f9				  -	      ECHO	"Erroneous position value", -10
      3  14f9				  -	      ERR
      4  14f9					      ENDIF
      5  14f9		       f6		      .byte.b	-10
      0  14fa					      EVAL8	-10
      1  14fa				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14fa				  -	      ECHO	"Erroneous position value", -10
      3  14fa				  -	      ERR
      4  14fa					      ENDIF
      5  14fa		       f6		      .byte.b	-10
      0  14fb					      EVAL8	-10
      1  14fb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14fb				  -	      ECHO	"Erroneous position value", -10
      3  14fb				  -	      ERR
      4  14fb					      ENDIF
      5  14fb		       f6		      .byte.b	-10
      0  14fc					      EVAL8	-10
      1  14fc				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14fc				  -	      ECHO	"Erroneous position value", -10
      3  14fc				  -	      ERR
      4  14fc					      ENDIF
      5  14fc		       f6		      .byte.b	-10
      0  14fd					      EVAL8	-20
      1  14fd				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14fd				  -	      ECHO	"Erroneous position value", -20
      3  14fd				  -	      ERR
      4  14fd					      ENDIF
      5  14fd		       ec		      .byte.b	-20
      0  14fe					      EVAL8	0
      1  14fe				  -	      IF	(0 > 127) || (0 < -128)
      2  14fe				  -	      ECHO	"Erroneous position value", 0
      3  14fe				  -	      ERR
      4  14fe					      ENDIF
      5  14fe		       00		      .byte.b	0
      0  14ff					      EVAL8	0
      1  14ff				  -	      IF	(0 > 127) || (0 < -128)
      2  14ff				  -	      ECHO	"Erroneous position value", 0
      3  14ff				  -	      ERR
      4  14ff					      ENDIF
      5  14ff		       00		      .byte.b	0
    131  1500
    132  1500
    133  1500							;---------------------------------------------------------------------------------------------------
    134  1500
    135  1500				   PositionalValue_ROOK
    136  1500
      0  1500					      PVAL	-25, -20, 10, 55, 55, 50, -20, -25
      0  1500					      EVAL8	-25
      1  1500				  -	      IF	(-25 > 127) || (-25 < -128)
      2  1500				  -	      ECHO	"Erroneous position value", -25
      3  1500				  -	      ERR
      4  1500					      ENDIF
      5  1500		       e7		      .byte.b	-25
      0  1501					      EVAL8	-20
      1  1501				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1501				  -	      ECHO	"Erroneous position value", -20
      3  1501				  -	      ERR
      4  1501					      ENDIF
      5  1501		       ec		      .byte.b	-20
      0  1502					      EVAL8	10
      1  1502				  -	      IF	(10 > 127) || (10 < -128)
      2  1502				  -	      ECHO	"Erroneous position value", 10
      3  1502				  -	      ERR
      4  1502					      ENDIF
      5  1502		       0a		      .byte.b	10
      0  1503					      EVAL8	55
      1  1503				  -	      IF	(55 > 127) || (55 < -128)
      2  1503				  -	      ECHO	"Erroneous position value", 55
      3  1503				  -	      ERR
      4  1503					      ENDIF
      5  1503		       37		      .byte.b	55
      0  1504					      EVAL8	55
      1  1504				  -	      IF	(55 > 127) || (55 < -128)
      2  1504				  -	      ECHO	"Erroneous position value", 55
      3  1504				  -	      ERR
      4  1504					      ENDIF
      5  1504		       37		      .byte.b	55
      0  1505					      EVAL8	50
      1  1505				  -	      IF	(50 > 127) || (50 < -128)
      2  1505				  -	      ECHO	"Erroneous position value", 50
      3  1505				  -	      ERR
      4  1505					      ENDIF
      5  1505		       32		      .byte.b	50
      0  1506					      EVAL8	-20
      1  1506				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1506				  -	      ECHO	"Erroneous position value", -20
      3  1506				  -	      ERR
      4  1506					      ENDIF
      5  1506		       ec		      .byte.b	-20
      0  1507					      EVAL8	-25
      1  1507				  -	      IF	(-25 > 127) || (-25 < -128)
      2  1507				  -	      ECHO	"Erroneous position value", -25
      3  1507				  -	      ERR
      4  1507					      ENDIF
      5  1507		       e7		      .byte.b	-25
      0  1508					      EVAL8	0
      1  1508				  -	      IF	(0 > 127) || (0 < -128)
      2  1508				  -	      ECHO	"Erroneous position value", 0
      3  1508				  -	      ERR
      4  1508					      ENDIF
      5  1508		       00		      .byte.b	0
      0  1509					      EVAL8	0
      1  1509				  -	      IF	(0 > 127) || (0 < -128)
      2  1509				  -	      ECHO	"Erroneous position value", 0
      3  1509				  -	      ERR
      4  1509					      ENDIF
      5  1509		       00		      .byte.b	0
      0  150a					      PVAL	-120, 0, 0, 0, 0, 0, 0, -128
      0  150a					      EVAL8	-120
      1  150a				  -	      IF	(-120 > 127) || (-120 < -128)
      2  150a				  -	      ECHO	"Erroneous position value", -120
      3  150a				  -	      ERR
      4  150a					      ENDIF
      5  150a		       88		      .byte.b	-120
      0  150b					      EVAL8	0
      1  150b				  -	      IF	(0 > 127) || (0 < -128)
      2  150b				  -	      ECHO	"Erroneous position value", 0
      3  150b				  -	      ERR
      4  150b					      ENDIF
      5  150b		       00		      .byte.b	0
      0  150c					      EVAL8	0
      1  150c				  -	      IF	(0 > 127) || (0 < -128)
      2  150c				  -	      ECHO	"Erroneous position value", 0
      3  150c				  -	      ERR
      4  150c					      ENDIF
      5  150c		       00		      .byte.b	0
      0  150d					      EVAL8	0
      1  150d				  -	      IF	(0 > 127) || (0 < -128)
      2  150d				  -	      ECHO	"Erroneous position value", 0
      3  150d				  -	      ERR
      4  150d					      ENDIF
      5  150d		       00		      .byte.b	0
      0  150e					      EVAL8	0
      1  150e				  -	      IF	(0 > 127) || (0 < -128)
      2  150e				  -	      ECHO	"Erroneous position value", 0
      3  150e				  -	      ERR
      4  150e					      ENDIF
      5  150e		       00		      .byte.b	0
      0  150f					      EVAL8	0
      1  150f				  -	      IF	(0 > 127) || (0 < -128)
      2  150f				  -	      ECHO	"Erroneous position value", 0
      3  150f				  -	      ERR
      4  150f					      ENDIF
      5  150f		       00		      .byte.b	0
      0  1510					      EVAL8	0
      1  1510				  -	      IF	(0 > 127) || (0 < -128)
      2  1510				  -	      ECHO	"Erroneous position value", 0
      3  1510				  -	      ERR
      4  1510					      ENDIF
      5  1510		       00		      .byte.b	0
      0  1511					      EVAL8	-128
      1  1511				  -	      IF	(-128 > 127) || (-128 < -128)
      2  1511				  -	      ECHO	"Erroneous position value", -128
      3  1511				  -	      ERR
      4  1511					      ENDIF
      5  1511		       80		      .byte.b	-128
      0  1512					      EVAL8	0
      1  1512				  -	      IF	(0 > 127) || (0 < -128)
      2  1512				  -	      ECHO	"Erroneous position value", 0
      3  1512				  -	      ERR
      4  1512					      ENDIF
      5  1512		       00		      .byte.b	0
      0  1513					      EVAL8	0
      1  1513				  -	      IF	(0 > 127) || (0 < -128)
      2  1513				  -	      ECHO	"Erroneous position value", 0
      3  1513				  -	      ERR
      4  1513					      ENDIF
      5  1513		       00		      .byte.b	0
      0  1514					      PVAL	-128, 0, 0, 0, 0, 0, 0, -100
      0  1514					      EVAL8	-128
      1  1514				  -	      IF	(-128 > 127) || (-128 < -128)
      2  1514				  -	      ECHO	"Erroneous position value", -128
      3  1514				  -	      ERR
      4  1514					      ENDIF
      5  1514		       80		      .byte.b	-128
      0  1515					      EVAL8	0
      1  1515				  -	      IF	(0 > 127) || (0 < -128)
      2  1515				  -	      ECHO	"Erroneous position value", 0
      3  1515				  -	      ERR
      4  1515					      ENDIF
      5  1515		       00		      .byte.b	0
      0  1516					      EVAL8	0
      1  1516				  -	      IF	(0 > 127) || (0 < -128)
      2  1516				  -	      ECHO	"Erroneous position value", 0
      3  1516				  -	      ERR
      4  1516					      ENDIF
      5  1516		       00		      .byte.b	0
      0  1517					      EVAL8	0
      1  1517				  -	      IF	(0 > 127) || (0 < -128)
      2  1517				  -	      ECHO	"Erroneous position value", 0
      3  1517				  -	      ERR
      4  1517					      ENDIF
      5  1517		       00		      .byte.b	0
      0  1518					      EVAL8	0
      1  1518				  -	      IF	(0 > 127) || (0 < -128)
      2  1518				  -	      ECHO	"Erroneous position value", 0
      3  1518				  -	      ERR
      4  1518					      ENDIF
      5  1518		       00		      .byte.b	0
      0  1519					      EVAL8	0
      1  1519				  -	      IF	(0 > 127) || (0 < -128)
      2  1519				  -	      ECHO	"Erroneous position value", 0
      3  1519				  -	      ERR
      4  1519					      ENDIF
      5  1519		       00		      .byte.b	0
      0  151a					      EVAL8	0
      1  151a				  -	      IF	(0 > 127) || (0 < -128)
      2  151a				  -	      ECHO	"Erroneous position value", 0
      3  151a				  -	      ERR
      4  151a					      ENDIF
      5  151a		       00		      .byte.b	0
      0  151b					      EVAL8	-100
      1  151b				  -	      IF	(-100 > 127) || (-100 < -128)
      2  151b				  -	      ECHO	"Erroneous position value", -100
      3  151b				  -	      ERR
      4  151b					      ENDIF
      5  151b		       9c		      .byte.b	-100
      0  151c					      EVAL8	0
      1  151c				  -	      IF	(0 > 127) || (0 < -128)
      2  151c				  -	      ECHO	"Erroneous position value", 0
      3  151c				  -	      ERR
      4  151c					      ENDIF
      5  151c		       00		      .byte.b	0
      0  151d					      EVAL8	0
      1  151d				  -	      IF	(0 > 127) || (0 < -128)
      2  151d				  -	      ECHO	"Erroneous position value", 0
      3  151d				  -	      ERR
      4  151d					      ENDIF
      5  151d		       00		      .byte.b	0
      0  151e					      PVAL	-100, 0, 0, 0, 0, 0, 0, -100
      0  151e					      EVAL8	-100
      1  151e				  -	      IF	(-100 > 127) || (-100 < -128)
      2  151e				  -	      ECHO	"Erroneous position value", -100
      3  151e				  -	      ERR
      4  151e					      ENDIF
      5  151e		       9c		      .byte.b	-100
      0  151f					      EVAL8	0
      1  151f				  -	      IF	(0 > 127) || (0 < -128)
      2  151f				  -	      ECHO	"Erroneous position value", 0
      3  151f				  -	      ERR
      4  151f					      ENDIF
      5  151f		       00		      .byte.b	0
      0  1520					      EVAL8	0
      1  1520				  -	      IF	(0 > 127) || (0 < -128)
      2  1520				  -	      ECHO	"Erroneous position value", 0
      3  1520				  -	      ERR
      4  1520					      ENDIF
      5  1520		       00		      .byte.b	0
      0  1521					      EVAL8	0
      1  1521				  -	      IF	(0 > 127) || (0 < -128)
      2  1521				  -	      ECHO	"Erroneous position value", 0
      3  1521				  -	      ERR
      4  1521					      ENDIF
      5  1521		       00		      .byte.b	0
      0  1522					      EVAL8	0
      1  1522				  -	      IF	(0 > 127) || (0 < -128)
      2  1522				  -	      ECHO	"Erroneous position value", 0
      3  1522				  -	      ERR
      4  1522					      ENDIF
      5  1522		       00		      .byte.b	0
      0  1523					      EVAL8	0
      1  1523				  -	      IF	(0 > 127) || (0 < -128)
      2  1523				  -	      ECHO	"Erroneous position value", 0
      3  1523				  -	      ERR
      4  1523					      ENDIF
      5  1523		       00		      .byte.b	0
      0  1524					      EVAL8	0
      1  1524				  -	      IF	(0 > 127) || (0 < -128)
      2  1524				  -	      ECHO	"Erroneous position value", 0
      3  1524				  -	      ERR
      4  1524					      ENDIF
      5  1524		       00		      .byte.b	0
      0  1525					      EVAL8	-100
      1  1525				  -	      IF	(-100 > 127) || (-100 < -128)
      2  1525				  -	      ECHO	"Erroneous position value", -100
      3  1525				  -	      ERR
      4  1525					      ENDIF
      5  1525		       9c		      .byte.b	-100
      0  1526					      EVAL8	0
      1  1526				  -	      IF	(0 > 127) || (0 < -128)
      2  1526				  -	      ECHO	"Erroneous position value", 0
      3  1526				  -	      ERR
      4  1526					      ENDIF
      5  1526		       00		      .byte.b	0
      0  1527					      EVAL8	0
      1  1527				  -	      IF	(0 > 127) || (0 < -128)
      2  1527				  -	      ECHO	"Erroneous position value", 0
      3  1527				  -	      ERR
      4  1527					      ENDIF
      5  1527		       00		      .byte.b	0
      0  1528					      PVAL	-50, 0, 0, 0, 0, 0, 0, -50
      0  1528					      EVAL8	-50
      1  1528				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1528				  -	      ECHO	"Erroneous position value", -50
      3  1528				  -	      ERR
      4  1528					      ENDIF
      5  1528		       ce		      .byte.b	-50
      0  1529					      EVAL8	0
      1  1529				  -	      IF	(0 > 127) || (0 < -128)
      2  1529				  -	      ECHO	"Erroneous position value", 0
      3  1529				  -	      ERR
      4  1529					      ENDIF
      5  1529		       00		      .byte.b	0
      0  152a					      EVAL8	0
      1  152a				  -	      IF	(0 > 127) || (0 < -128)
      2  152a				  -	      ECHO	"Erroneous position value", 0
      3  152a				  -	      ERR
      4  152a					      ENDIF
      5  152a		       00		      .byte.b	0
      0  152b					      EVAL8	0
      1  152b				  -	      IF	(0 > 127) || (0 < -128)
      2  152b				  -	      ECHO	"Erroneous position value", 0
      3  152b				  -	      ERR
      4  152b					      ENDIF
      5  152b		       00		      .byte.b	0
      0  152c					      EVAL8	0
      1  152c				  -	      IF	(0 > 127) || (0 < -128)
      2  152c				  -	      ECHO	"Erroneous position value", 0
      3  152c				  -	      ERR
      4  152c					      ENDIF
      5  152c		       00		      .byte.b	0
      0  152d					      EVAL8	0
      1  152d				  -	      IF	(0 > 127) || (0 < -128)
      2  152d				  -	      ECHO	"Erroneous position value", 0
      3  152d				  -	      ERR
      4  152d					      ENDIF
      5  152d		       00		      .byte.b	0
      0  152e					      EVAL8	0
      1  152e				  -	      IF	(0 > 127) || (0 < -128)
      2  152e				  -	      ECHO	"Erroneous position value", 0
      3  152e				  -	      ERR
      4  152e					      ENDIF
      5  152e		       00		      .byte.b	0
      0  152f					      EVAL8	-50
      1  152f				  -	      IF	(-50 > 127) || (-50 < -128)
      2  152f				  -	      ECHO	"Erroneous position value", -50
      3  152f				  -	      ERR
      4  152f					      ENDIF
      5  152f		       ce		      .byte.b	-50
      0  1530					      EVAL8	0
      1  1530				  -	      IF	(0 > 127) || (0 < -128)
      2  1530				  -	      ECHO	"Erroneous position value", 0
      3  1530				  -	      ERR
      4  1530					      ENDIF
      5  1530		       00		      .byte.b	0
      0  1531					      EVAL8	0
      1  1531				  -	      IF	(0 > 127) || (0 < -128)
      2  1531				  -	      ECHO	"Erroneous position value", 0
      3  1531				  -	      ERR
      4  1531					      ENDIF
      5  1531		       00		      .byte.b	0
      0  1532					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      0  1532					      EVAL8	-5
      1  1532				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1532				  -	      ECHO	"Erroneous position value", -5
      3  1532				  -	      ERR
      4  1532					      ENDIF
      5  1532		       fb		      .byte.b	-5
      0  1533					      EVAL8	0
      1  1533				  -	      IF	(0 > 127) || (0 < -128)
      2  1533				  -	      ECHO	"Erroneous position value", 0
      3  1533				  -	      ERR
      4  1533					      ENDIF
      5  1533		       00		      .byte.b	0
      0  1534					      EVAL8	30
      1  1534				  -	      IF	(30 > 127) || (30 < -128)
      2  1534				  -	      ECHO	"Erroneous position value", 30
      3  1534				  -	      ERR
      4  1534					      ENDIF
      5  1534		       1e		      .byte.b	30
      0  1535					      EVAL8	30
      1  1535				  -	      IF	(30 > 127) || (30 < -128)
      2  1535				  -	      ECHO	"Erroneous position value", 30
      3  1535				  -	      ERR
      4  1535					      ENDIF
      5  1535		       1e		      .byte.b	30
      0  1536					      EVAL8	30
      1  1536				  -	      IF	(30 > 127) || (30 < -128)
      2  1536				  -	      ECHO	"Erroneous position value", 30
      3  1536				  -	      ERR
      4  1536					      ENDIF
      5  1536		       1e		      .byte.b	30
      0  1537					      EVAL8	30
      1  1537				  -	      IF	(30 > 127) || (30 < -128)
      2  1537				  -	      ECHO	"Erroneous position value", 30
      3  1537				  -	      ERR
      4  1537					      ENDIF
      5  1537		       1e		      .byte.b	30
      0  1538					      EVAL8	0
      1  1538				  -	      IF	(0 > 127) || (0 < -128)
      2  1538				  -	      ECHO	"Erroneous position value", 0
      3  1538				  -	      ERR
      4  1538					      ENDIF
      5  1538		       00		      .byte.b	0
      0  1539					      EVAL8	-5
      1  1539				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1539				  -	      ECHO	"Erroneous position value", -5
      3  1539				  -	      ERR
      4  1539					      ENDIF
      5  1539		       fb		      .byte.b	-5
      0  153a					      EVAL8	0
      1  153a				  -	      IF	(0 > 127) || (0 < -128)
      2  153a				  -	      ECHO	"Erroneous position value", 0
      3  153a				  -	      ERR
      4  153a					      ENDIF
      5  153a		       00		      .byte.b	0
      0  153b					      EVAL8	0
      1  153b				  -	      IF	(0 > 127) || (0 < -128)
      2  153b				  -	      ECHO	"Erroneous position value", 0
      3  153b				  -	      ERR
      4  153b					      ENDIF
      5  153b		       00		      .byte.b	0
      0  153c					      PVAL	55, 80, 90, 90, 90, 90, 80, 55
      0  153c					      EVAL8	55
      1  153c				  -	      IF	(55 > 127) || (55 < -128)
      2  153c				  -	      ECHO	"Erroneous position value", 55
      3  153c				  -	      ERR
      4  153c					      ENDIF
      5  153c		       37		      .byte.b	55
      0  153d					      EVAL8	80
      1  153d				  -	      IF	(80 > 127) || (80 < -128)
      2  153d				  -	      ECHO	"Erroneous position value", 80
      3  153d				  -	      ERR
      4  153d					      ENDIF
      5  153d		       50		      .byte.b	80
      0  153e					      EVAL8	90
      1  153e				  -	      IF	(90 > 127) || (90 < -128)
      2  153e				  -	      ECHO	"Erroneous position value", 90
      3  153e				  -	      ERR
      4  153e					      ENDIF
      5  153e		       5a		      .byte.b	90
      0  153f					      EVAL8	90
      1  153f				  -	      IF	(90 > 127) || (90 < -128)
      2  153f				  -	      ECHO	"Erroneous position value", 90
      3  153f				  -	      ERR
      4  153f					      ENDIF
      5  153f		       5a		      .byte.b	90
      0  1540					      EVAL8	90
      1  1540				  -	      IF	(90 > 127) || (90 < -128)
      2  1540				  -	      ECHO	"Erroneous position value", 90
      3  1540				  -	      ERR
      4  1540					      ENDIF
      5  1540		       5a		      .byte.b	90
      0  1541					      EVAL8	90
      1  1541				  -	      IF	(90 > 127) || (90 < -128)
      2  1541				  -	      ECHO	"Erroneous position value", 90
      3  1541				  -	      ERR
      4  1541					      ENDIF
      5  1541		       5a		      .byte.b	90
      0  1542					      EVAL8	80
      1  1542				  -	      IF	(80 > 127) || (80 < -128)
      2  1542				  -	      ECHO	"Erroneous position value", 80
      3  1542				  -	      ERR
      4  1542					      ENDIF
      5  1542		       50		      .byte.b	80
      0  1543					      EVAL8	55
      1  1543				  -	      IF	(55 > 127) || (55 < -128)
      2  1543				  -	      ECHO	"Erroneous position value", 55
      3  1543				  -	      ERR
      4  1543					      ENDIF
      5  1543		       37		      .byte.b	55
      0  1544					      EVAL8	0
      1  1544				  -	      IF	(0 > 127) || (0 < -128)
      2  1544				  -	      ECHO	"Erroneous position value", 0
      3  1544				  -	      ERR
      4  1544					      ENDIF
      5  1544		       00		      .byte.b	0
      0  1545					      EVAL8	0
      1  1545				  -	      IF	(0 > 127) || (0 < -128)
      2  1545				  -	      ECHO	"Erroneous position value", 0
      3  1545				  -	      ERR
      4  1545					      ENDIF
      5  1545		       00		      .byte.b	0
      0  1546					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  1546					      EVAL8	0
      1  1546				  -	      IF	(0 > 127) || (0 < -128)
      2  1546				  -	      ECHO	"Erroneous position value", 0
      3  1546				  -	      ERR
      4  1546					      ENDIF
      5  1546		       00		      .byte.b	0
      0  1547					      EVAL8	0
      1  1547				  -	      IF	(0 > 127) || (0 < -128)
      2  1547				  -	      ECHO	"Erroneous position value", 0
      3  1547				  -	      ERR
      4  1547					      ENDIF
      5  1547		       00		      .byte.b	0
      0  1548					      EVAL8	0
      1  1548				  -	      IF	(0 > 127) || (0 < -128)
      2  1548				  -	      ECHO	"Erroneous position value", 0
      3  1548				  -	      ERR
      4  1548					      ENDIF
      5  1548		       00		      .byte.b	0
      0  1549					      EVAL8	0
      1  1549				  -	      IF	(0 > 127) || (0 < -128)
      2  1549				  -	      ECHO	"Erroneous position value", 0
      3  1549				  -	      ERR
      4  1549					      ENDIF
      5  1549		       00		      .byte.b	0
      0  154a					      EVAL8	0
      1  154a				  -	      IF	(0 > 127) || (0 < -128)
      2  154a				  -	      ECHO	"Erroneous position value", 0
      3  154a				  -	      ERR
      4  154a					      ENDIF
      5  154a		       00		      .byte.b	0
      0  154b					      EVAL8	0
      1  154b				  -	      IF	(0 > 127) || (0 < -128)
      2  154b				  -	      ECHO	"Erroneous position value", 0
      3  154b				  -	      ERR
      4  154b					      ENDIF
      5  154b		       00		      .byte.b	0
      0  154c					      EVAL8	0
      1  154c				  -	      IF	(0 > 127) || (0 < -128)
      2  154c				  -	      ECHO	"Erroneous position value", 0
      3  154c				  -	      ERR
      4  154c					      ENDIF
      5  154c		       00		      .byte.b	0
      0  154d					      EVAL8	0
      1  154d				  -	      IF	(0 > 127) || (0 < -128)
      2  154d				  -	      ECHO	"Erroneous position value", 0
      3  154d				  -	      ERR
      4  154d					      ENDIF
      5  154d		       00		      .byte.b	0
      0  154e					      EVAL8	0
      1  154e				  -	      IF	(0 > 127) || (0 < -128)
      2  154e				  -	      ECHO	"Erroneous position value", 0
      3  154e				  -	      ERR
      4  154e					      ENDIF
      5  154e		       00		      .byte.b	0
      0  154f					      EVAL8	0
      1  154f				  -	      IF	(0 > 127) || (0 < -128)
      2  154f				  -	      ECHO	"Erroneous position value", 0
      3  154f				  -	      ERR
      4  154f					      ENDIF
      5  154f		       00		      .byte.b	0
    145  1550
    146  1550
    147  1550							;---------------------------------------------------------------------------------------------------
    148  1550
    149  1550				   PositionalValue_QUEEN
    150  1550
      0  1550					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      0  1550					      EVAL8	-20
      1  1550				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1550				  -	      ECHO	"Erroneous position value", -20
      3  1550				  -	      ERR
      4  1550					      ENDIF
      5  1550		       ec		      .byte.b	-20
      0  1551					      EVAL8	-10
      1  1551				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1551				  -	      ECHO	"Erroneous position value", -10
      3  1551				  -	      ERR
      4  1551					      ENDIF
      5  1551		       f6		      .byte.b	-10
      0  1552					      EVAL8	-5
      1  1552				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1552				  -	      ECHO	"Erroneous position value", -5
      3  1552				  -	      ERR
      4  1552					      ENDIF
      5  1552		       fb		      .byte.b	-5
      0  1553					      EVAL8	-5
      1  1553				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1553				  -	      ECHO	"Erroneous position value", -5
      3  1553				  -	      ERR
      4  1553					      ENDIF
      5  1553		       fb		      .byte.b	-5
      0  1554					      EVAL8	-5
      1  1554				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1554				  -	      ECHO	"Erroneous position value", -5
      3  1554				  -	      ERR
      4  1554					      ENDIF
      5  1554		       fb		      .byte.b	-5
      0  1555					      EVAL8	-10
      1  1555				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1555				  -	      ECHO	"Erroneous position value", -10
      3  1555				  -	      ERR
      4  1555					      ENDIF
      5  1555		       f6		      .byte.b	-10
      0  1556					      EVAL8	-10
      1  1556				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1556				  -	      ECHO	"Erroneous position value", -10
      3  1556				  -	      ERR
      4  1556					      ENDIF
      5  1556		       f6		      .byte.b	-10
      0  1557					      EVAL8	-20
      1  1557				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1557				  -	      ECHO	"Erroneous position value", -20
      3  1557				  -	      ERR
      4  1557					      ENDIF
      5  1557		       ec		      .byte.b	-20
      0  1558					      EVAL8	0
      1  1558				  -	      IF	(0 > 127) || (0 < -128)
      2  1558				  -	      ECHO	"Erroneous position value", 0
      3  1558				  -	      ERR
      4  1558					      ENDIF
      5  1558		       00		      .byte.b	0
      0  1559					      EVAL8	0
      1  1559				  -	      IF	(0 > 127) || (0 < -128)
      2  1559				  -	      ECHO	"Erroneous position value", 0
      3  1559				  -	      ERR
      4  1559					      ENDIF
      5  1559		       00		      .byte.b	0
      0  155a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      0  155a					      EVAL8	-10
      1  155a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  155a				  -	      ECHO	"Erroneous position value", -10
      3  155a				  -	      ERR
      4  155a					      ENDIF
      5  155a		       f6		      .byte.b	-10
      0  155b					      EVAL8	0
      1  155b				  -	      IF	(0 > 127) || (0 < -128)
      2  155b				  -	      ECHO	"Erroneous position value", 0
      3  155b				  -	      ERR
      4  155b					      ENDIF
      5  155b		       00		      .byte.b	0
      0  155c					      EVAL8	5
      1  155c				  -	      IF	(5 > 127) || (5 < -128)
      2  155c				  -	      ECHO	"Erroneous position value", 5
      3  155c				  -	      ERR
      4  155c					      ENDIF
      5  155c		       05		      .byte.b	5
      0  155d					      EVAL8	0
      1  155d				  -	      IF	(0 > 127) || (0 < -128)
      2  155d				  -	      ECHO	"Erroneous position value", 0
      3  155d				  -	      ERR
      4  155d					      ENDIF
      5  155d		       00		      .byte.b	0
      0  155e					      EVAL8	0
      1  155e				  -	      IF	(0 > 127) || (0 < -128)
      2  155e				  -	      ECHO	"Erroneous position value", 0
      3  155e				  -	      ERR
      4  155e					      ENDIF
      5  155e		       00		      .byte.b	0
      0  155f					      EVAL8	0
      1  155f				  -	      IF	(0 > 127) || (0 < -128)
      2  155f				  -	      ECHO	"Erroneous position value", 0
      3  155f				  -	      ERR
      4  155f					      ENDIF
      5  155f		       00		      .byte.b	0
      0  1560					      EVAL8	0
      1  1560				  -	      IF	(0 > 127) || (0 < -128)
      2  1560				  -	      ECHO	"Erroneous position value", 0
      3  1560				  -	      ERR
      4  1560					      ENDIF
      5  1560		       00		      .byte.b	0
      0  1561					      EVAL8	-10
      1  1561				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1561				  -	      ECHO	"Erroneous position value", -10
      3  1561				  -	      ERR
      4  1561					      ENDIF
      5  1561		       f6		      .byte.b	-10
      0  1562					      EVAL8	0
      1  1562				  -	      IF	(0 > 127) || (0 < -128)
      2  1562				  -	      ECHO	"Erroneous position value", 0
      3  1562				  -	      ERR
      4  1562					      ENDIF
      5  1562		       00		      .byte.b	0
      0  1563					      EVAL8	0
      1  1563				  -	      IF	(0 > 127) || (0 < -128)
      2  1563				  -	      ECHO	"Erroneous position value", 0
      3  1563				  -	      ERR
      4  1563					      ENDIF
      5  1563		       00		      .byte.b	0
      0  1564					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      0  1564					      EVAL8	-10
      1  1564				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1564				  -	      ECHO	"Erroneous position value", -10
      3  1564				  -	      ERR
      4  1564					      ENDIF
      5  1564		       f6		      .byte.b	-10
      0  1565					      EVAL8	5
      1  1565				  -	      IF	(5 > 127) || (5 < -128)
      2  1565				  -	      ECHO	"Erroneous position value", 5
      3  1565				  -	      ERR
      4  1565					      ENDIF
      5  1565		       05		      .byte.b	5
      0  1566					      EVAL8	5
      1  1566				  -	      IF	(5 > 127) || (5 < -128)
      2  1566				  -	      ECHO	"Erroneous position value", 5
      3  1566				  -	      ERR
      4  1566					      ENDIF
      5  1566		       05		      .byte.b	5
      0  1567					      EVAL8	5
      1  1567				  -	      IF	(5 > 127) || (5 < -128)
      2  1567				  -	      ECHO	"Erroneous position value", 5
      3  1567				  -	      ERR
      4  1567					      ENDIF
      5  1567		       05		      .byte.b	5
      0  1568					      EVAL8	5
      1  1568				  -	      IF	(5 > 127) || (5 < -128)
      2  1568				  -	      ECHO	"Erroneous position value", 5
      3  1568				  -	      ERR
      4  1568					      ENDIF
      5  1568		       05		      .byte.b	5
      0  1569					      EVAL8	25
      1  1569				  -	      IF	(25 > 127) || (25 < -128)
      2  1569				  -	      ECHO	"Erroneous position value", 25
      3  1569				  -	      ERR
      4  1569					      ENDIF
      5  1569		       19		      .byte.b	25
      0  156a					      EVAL8	0
      1  156a				  -	      IF	(0 > 127) || (0 < -128)
      2  156a				  -	      ECHO	"Erroneous position value", 0
      3  156a				  -	      ERR
      4  156a					      ENDIF
      5  156a		       00		      .byte.b	0
      0  156b					      EVAL8	-10
      1  156b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  156b				  -	      ECHO	"Erroneous position value", -10
      3  156b				  -	      ERR
      4  156b					      ENDIF
      5  156b		       f6		      .byte.b	-10
      0  156c					      EVAL8	0
      1  156c				  -	      IF	(0 > 127) || (0 < -128)
      2  156c				  -	      ECHO	"Erroneous position value", 0
      3  156c				  -	      ERR
      4  156c					      ENDIF
      5  156c		       00		      .byte.b	0
      0  156d					      EVAL8	0
      1  156d				  -	      IF	(0 > 127) || (0 < -128)
      2  156d				  -	      ECHO	"Erroneous position value", 0
      3  156d				  -	      ERR
      4  156d					      ENDIF
      5  156d		       00		      .byte.b	0
      0  156e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      0  156e					      EVAL8	-10
      1  156e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  156e				  -	      ECHO	"Erroneous position value", -10
      3  156e				  -	      ERR
      4  156e					      ENDIF
      5  156e		       f6		      .byte.b	-10
      0  156f					      EVAL8	0
      1  156f				  -	      IF	(0 > 127) || (0 < -128)
      2  156f				  -	      ECHO	"Erroneous position value", 0
      3  156f				  -	      ERR
      4  156f					      ENDIF
      5  156f		       00		      .byte.b	0
      0  1570					      EVAL8	5
      1  1570				  -	      IF	(5 > 127) || (5 < -128)
      2  1570				  -	      ECHO	"Erroneous position value", 5
      3  1570				  -	      ERR
      4  1570					      ENDIF
      5  1570		       05		      .byte.b	5
      0  1571					      EVAL8	25
      1  1571				  -	      IF	(25 > 127) || (25 < -128)
      2  1571				  -	      ECHO	"Erroneous position value", 25
      3  1571				  -	      ERR
      4  1571					      ENDIF
      5  1571		       19		      .byte.b	25
      0  1572					      EVAL8	25
      1  1572				  -	      IF	(25 > 127) || (25 < -128)
      2  1572				  -	      ECHO	"Erroneous position value", 25
      3  1572				  -	      ERR
      4  1572					      ENDIF
      5  1572		       19		      .byte.b	25
      0  1573					      EVAL8	25
      1  1573				  -	      IF	(25 > 127) || (25 < -128)
      2  1573				  -	      ECHO	"Erroneous position value", 25
      3  1573				  -	      ERR
      4  1573					      ENDIF
      5  1573		       19		      .byte.b	25
      0  1574					      EVAL8	0
      1  1574				  -	      IF	(0 > 127) || (0 < -128)
      2  1574				  -	      ECHO	"Erroneous position value", 0
      3  1574				  -	      ERR
      4  1574					      ENDIF
      5  1574		       00		      .byte.b	0
      0  1575					      EVAL8	-10
      1  1575				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1575				  -	      ECHO	"Erroneous position value", -10
      3  1575				  -	      ERR
      4  1575					      ENDIF
      5  1575		       f6		      .byte.b	-10
      0  1576					      EVAL8	0
      1  1576				  -	      IF	(0 > 127) || (0 < -128)
      2  1576				  -	      ECHO	"Erroneous position value", 0
      3  1576				  -	      ERR
      4  1576					      ENDIF
      5  1576		       00		      .byte.b	0
      0  1577					      EVAL8	0
      1  1577				  -	      IF	(0 > 127) || (0 < -128)
      2  1577				  -	      ECHO	"Erroneous position value", 0
      3  1577				  -	      ERR
      4  1577					      ENDIF
      5  1577		       00		      .byte.b	0
      0  1578					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      0  1578					      EVAL8	-5
      1  1578				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1578				  -	      ECHO	"Erroneous position value", -5
      3  1578				  -	      ERR
      4  1578					      ENDIF
      5  1578		       fb		      .byte.b	-5
      0  1579					      EVAL8	0
      1  1579				  -	      IF	(0 > 127) || (0 < -128)
      2  1579				  -	      ECHO	"Erroneous position value", 0
      3  1579				  -	      ERR
      4  1579					      ENDIF
      5  1579		       00		      .byte.b	0
      0  157a					      EVAL8	15
      1  157a				  -	      IF	(15 > 127) || (15 < -128)
      2  157a				  -	      ECHO	"Erroneous position value", 15
      3  157a				  -	      ERR
      4  157a					      ENDIF
      5  157a		       0f		      .byte.b	15
      0  157b					      EVAL8	55
      1  157b				  -	      IF	(55 > 127) || (55 < -128)
      2  157b				  -	      ECHO	"Erroneous position value", 55
      3  157b				  -	      ERR
      4  157b					      ENDIF
      5  157b		       37		      .byte.b	55
      0  157c					      EVAL8	55
      1  157c				  -	      IF	(55 > 127) || (55 < -128)
      2  157c				  -	      ECHO	"Erroneous position value", 55
      3  157c				  -	      ERR
      4  157c					      ENDIF
      5  157c		       37		      .byte.b	55
      0  157d					      EVAL8	55
      1  157d				  -	      IF	(55 > 127) || (55 < -128)
      2  157d				  -	      ECHO	"Erroneous position value", 55
      3  157d				  -	      ERR
      4  157d					      ENDIF
      5  157d		       37		      .byte.b	55
      0  157e					      EVAL8	0
      1  157e				  -	      IF	(0 > 127) || (0 < -128)
      2  157e				  -	      ECHO	"Erroneous position value", 0
      3  157e				  -	      ERR
      4  157e					      ENDIF
      5  157e		       00		      .byte.b	0
      0  157f					      EVAL8	-5
      1  157f				  -	      IF	(-5 > 127) || (-5 < -128)
      2  157f				  -	      ECHO	"Erroneous position value", -5
      3  157f				  -	      ERR
      4  157f					      ENDIF
      5  157f		       fb		      .byte.b	-5
      0  1580					      EVAL8	0
      1  1580				  -	      IF	(0 > 127) || (0 < -128)
      2  1580				  -	      ECHO	"Erroneous position value", 0
      3  1580				  -	      ERR
      4  1580					      ENDIF
      5  1580		       00		      .byte.b	0
      0  1581					      EVAL8	0
      1  1581				  -	      IF	(0 > 127) || (0 < -128)
      2  1581				  -	      ECHO	"Erroneous position value", 0
      3  1581				  -	      ERR
      4  1581					      ENDIF
      5  1581		       00		      .byte.b	0
      0  1582					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      0  1582					      EVAL8	-10
      1  1582				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1582				  -	      ECHO	"Erroneous position value", -10
      3  1582				  -	      ERR
      4  1582					      ENDIF
      5  1582		       f6		      .byte.b	-10
      0  1583					      EVAL8	0
      1  1583				  -	      IF	(0 > 127) || (0 < -128)
      2  1583				  -	      ECHO	"Erroneous position value", 0
      3  1583				  -	      ERR
      4  1583					      ENDIF
      5  1583		       00		      .byte.b	0
      0  1584					      EVAL8	25
      1  1584				  -	      IF	(25 > 127) || (25 < -128)
      2  1584				  -	      ECHO	"Erroneous position value", 25
      3  1584				  -	      ERR
      4  1584					      ENDIF
      5  1584		       19		      .byte.b	25
      0  1585					      EVAL8	75
      1  1585				  -	      IF	(75 > 127) || (75 < -128)
      2  1585				  -	      ECHO	"Erroneous position value", 75
      3  1585				  -	      ERR
      4  1585					      ENDIF
      5  1585		       4b		      .byte.b	75
      0  1586					      EVAL8	75
      1  1586				  -	      IF	(75 > 127) || (75 < -128)
      2  1586				  -	      ECHO	"Erroneous position value", 75
      3  1586				  -	      ERR
      4  1586					      ENDIF
      5  1586		       4b		      .byte.b	75
      0  1587					      EVAL8	75
      1  1587				  -	      IF	(75 > 127) || (75 < -128)
      2  1587				  -	      ECHO	"Erroneous position value", 75
      3  1587				  -	      ERR
      4  1587					      ENDIF
      5  1587		       4b		      .byte.b	75
      0  1588					      EVAL8	0
      1  1588				  -	      IF	(0 > 127) || (0 < -128)
      2  1588				  -	      ECHO	"Erroneous position value", 0
      3  1588				  -	      ERR
      4  1588					      ENDIF
      5  1588		       00		      .byte.b	0
      0  1589					      EVAL8	-10
      1  1589				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1589				  -	      ECHO	"Erroneous position value", -10
      3  1589				  -	      ERR
      4  1589					      ENDIF
      5  1589		       f6		      .byte.b	-10
      0  158a					      EVAL8	0
      1  158a				  -	      IF	(0 > 127) || (0 < -128)
      2  158a				  -	      ECHO	"Erroneous position value", 0
      3  158a				  -	      ERR
      4  158a					      ENDIF
      5  158a		       00		      .byte.b	0
      0  158b					      EVAL8	0
      1  158b				  -	      IF	(0 > 127) || (0 < -128)
      2  158b				  -	      ECHO	"Erroneous position value", 0
      3  158b				  -	      ERR
      4  158b					      ENDIF
      5  158b		       00		      .byte.b	0
      0  158c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  158c					      EVAL8	-10
      1  158c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  158c				  -	      ECHO	"Erroneous position value", -10
      3  158c				  -	      ERR
      4  158c					      ENDIF
      5  158c		       f6		      .byte.b	-10
      0  158d					      EVAL8	0
      1  158d				  -	      IF	(0 > 127) || (0 < -128)
      2  158d				  -	      ECHO	"Erroneous position value", 0
      3  158d				  -	      ERR
      4  158d					      ENDIF
      5  158d		       00		      .byte.b	0
      0  158e					      EVAL8	0
      1  158e				  -	      IF	(0 > 127) || (0 < -128)
      2  158e				  -	      ECHO	"Erroneous position value", 0
      3  158e				  -	      ERR
      4  158e					      ENDIF
      5  158e		       00		      .byte.b	0
      0  158f					      EVAL8	0
      1  158f				  -	      IF	(0 > 127) || (0 < -128)
      2  158f				  -	      ECHO	"Erroneous position value", 0
      3  158f				  -	      ERR
      4  158f					      ENDIF
      5  158f		       00		      .byte.b	0
      0  1590					      EVAL8	0
      1  1590				  -	      IF	(0 > 127) || (0 < -128)
      2  1590				  -	      ECHO	"Erroneous position value", 0
      3  1590				  -	      ERR
      4  1590					      ENDIF
      5  1590		       00		      .byte.b	0
      0  1591					      EVAL8	0
      1  1591				  -	      IF	(0 > 127) || (0 < -128)
      2  1591				  -	      ECHO	"Erroneous position value", 0
      3  1591				  -	      ERR
      4  1591					      ENDIF
      5  1591		       00		      .byte.b	0
      0  1592					      EVAL8	0
      1  1592				  -	      IF	(0 > 127) || (0 < -128)
      2  1592				  -	      ECHO	"Erroneous position value", 0
      3  1592				  -	      ERR
      4  1592					      ENDIF
      5  1592		       00		      .byte.b	0
      0  1593					      EVAL8	-10
      1  1593				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1593				  -	      ECHO	"Erroneous position value", -10
      3  1593				  -	      ERR
      4  1593					      ENDIF
      5  1593		       f6		      .byte.b	-10
      0  1594					      EVAL8	0
      1  1594				  -	      IF	(0 > 127) || (0 < -128)
      2  1594				  -	      ECHO	"Erroneous position value", 0
      3  1594				  -	      ERR
      4  1594					      ENDIF
      5  1594		       00		      .byte.b	0
      0  1595					      EVAL8	0
      1  1595				  -	      IF	(0 > 127) || (0 < -128)
      2  1595				  -	      ECHO	"Erroneous position value", 0
      3  1595				  -	      ERR
      4  1595					      ENDIF
      5  1595		       00		      .byte.b	0
      0  1596					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      0  1596					      EVAL8	-20
      1  1596				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1596				  -	      ECHO	"Erroneous position value", -20
      3  1596				  -	      ERR
      4  1596					      ENDIF
      5  1596		       ec		      .byte.b	-20
      0  1597					      EVAL8	-10
      1  1597				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1597				  -	      ECHO	"Erroneous position value", -10
      3  1597				  -	      ERR
      4  1597					      ENDIF
      5  1597		       f6		      .byte.b	-10
      0  1598					      EVAL8	-10
      1  1598				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1598				  -	      ECHO	"Erroneous position value", -10
      3  1598				  -	      ERR
      4  1598					      ENDIF
      5  1598		       f6		      .byte.b	-10
      0  1599					      EVAL8	-5
      1  1599				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1599				  -	      ECHO	"Erroneous position value", -5
      3  1599				  -	      ERR
      4  1599					      ENDIF
      5  1599		       fb		      .byte.b	-5
      0  159a					      EVAL8	-5
      1  159a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  159a				  -	      ECHO	"Erroneous position value", -5
      3  159a				  -	      ERR
      4  159a					      ENDIF
      5  159a		       fb		      .byte.b	-5
      0  159b					      EVAL8	-10
      1  159b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  159b				  -	      ECHO	"Erroneous position value", -10
      3  159b				  -	      ERR
      4  159b					      ENDIF
      5  159b		       f6		      .byte.b	-10
      0  159c					      EVAL8	-10
      1  159c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  159c				  -	      ECHO	"Erroneous position value", -10
      3  159c				  -	      ERR
      4  159c					      ENDIF
      5  159c		       f6		      .byte.b	-10
      0  159d					      EVAL8	-20
      1  159d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  159d				  -	      ECHO	"Erroneous position value", -20
      3  159d				  -	      ERR
      4  159d					      ENDIF
      5  159d		       ec		      .byte.b	-20
      0  159e					      EVAL8	0
      1  159e				  -	      IF	(0 > 127) || (0 < -128)
      2  159e				  -	      ECHO	"Erroneous position value", 0
      3  159e				  -	      ERR
      4  159e					      ENDIF
      5  159e		       00		      .byte.b	0
      0  159f					      EVAL8	0
      1  159f				  -	      IF	(0 > 127) || (0 < -128)
      2  159f				  -	      ECHO	"Erroneous position value", 0
      3  159f				  -	      ERR
      4  159f					      ENDIF
      5  159f		       00		      .byte.b	0
    159  15a0
    160  15a0
    161  15a0							;---------------------------------------------------------------------------------------------------
    162  15a0
    163  15a0				   PositionalValue_KING_MIDGAME
    164  15a0
      0  15a0					      PVAL	0, 0, 40, -60, -30, 0, 50, 0
      0  15a0					      EVAL8	0
      1  15a0				  -	      IF	(0 > 127) || (0 < -128)
      2  15a0				  -	      ECHO	"Erroneous position value", 0
      3  15a0				  -	      ERR
      4  15a0					      ENDIF
      5  15a0		       00		      .byte.b	0
      0  15a1					      EVAL8	0
      1  15a1				  -	      IF	(0 > 127) || (0 < -128)
      2  15a1				  -	      ECHO	"Erroneous position value", 0
      3  15a1				  -	      ERR
      4  15a1					      ENDIF
      5  15a1		       00		      .byte.b	0
      0  15a2					      EVAL8	40
      1  15a2				  -	      IF	(40 > 127) || (40 < -128)
      2  15a2				  -	      ECHO	"Erroneous position value", 40
      3  15a2				  -	      ERR
      4  15a2					      ENDIF
      5  15a2		       28		      .byte.b	40
      0  15a3					      EVAL8	-60
      1  15a3				  -	      IF	(-60 > 127) || (-60 < -128)
      2  15a3				  -	      ECHO	"Erroneous position value", -60
      3  15a3				  -	      ERR
      4  15a3					      ENDIF
      5  15a3		       c4		      .byte.b	-60
      0  15a4					      EVAL8	-30
      1  15a4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15a4				  -	      ECHO	"Erroneous position value", -30
      3  15a4				  -	      ERR
      4  15a4					      ENDIF
      5  15a4		       e2		      .byte.b	-30
      0  15a5					      EVAL8	0
      1  15a5				  -	      IF	(0 > 127) || (0 < -128)
      2  15a5				  -	      ECHO	"Erroneous position value", 0
      3  15a5				  -	      ERR
      4  15a5					      ENDIF
      5  15a5		       00		      .byte.b	0
      0  15a6					      EVAL8	50
      1  15a6				  -	      IF	(50 > 127) || (50 < -128)
      2  15a6				  -	      ECHO	"Erroneous position value", 50
      3  15a6				  -	      ERR
      4  15a6					      ENDIF
      5  15a6		       32		      .byte.b	50
      0  15a7					      EVAL8	0
      1  15a7				  -	      IF	(0 > 127) || (0 < -128)
      2  15a7				  -	      ECHO	"Erroneous position value", 0
      3  15a7				  -	      ERR
      4  15a7					      ENDIF
      5  15a7		       00		      .byte.b	0
      0  15a8					      EVAL8	0
      1  15a8				  -	      IF	(0 > 127) || (0 < -128)
      2  15a8				  -	      ECHO	"Erroneous position value", 0
      3  15a8				  -	      ERR
      4  15a8					      ENDIF
      5  15a8		       00		      .byte.b	0
      0  15a9					      EVAL8	0
      1  15a9				  -	      IF	(0 > 127) || (0 < -128)
      2  15a9				  -	      ECHO	"Erroneous position value", 0
      3  15a9				  -	      ERR
      4  15a9					      ENDIF
      5  15a9		       00		      .byte.b	0
      0  15aa					      PVAL	0, 0, -80, -80, -70, -70, 0, 0
      0  15aa					      EVAL8	0
      1  15aa				  -	      IF	(0 > 127) || (0 < -128)
      2  15aa				  -	      ECHO	"Erroneous position value", 0
      3  15aa				  -	      ERR
      4  15aa					      ENDIF
      5  15aa		       00		      .byte.b	0
      0  15ab					      EVAL8	0
      1  15ab				  -	      IF	(0 > 127) || (0 < -128)
      2  15ab				  -	      ECHO	"Erroneous position value", 0
      3  15ab				  -	      ERR
      4  15ab					      ENDIF
      5  15ab		       00		      .byte.b	0
      0  15ac					      EVAL8	-80
      1  15ac				  -	      IF	(-80 > 127) || (-80 < -128)
      2  15ac				  -	      ECHO	"Erroneous position value", -80
      3  15ac				  -	      ERR
      4  15ac					      ENDIF
      5  15ac		       b0		      .byte.b	-80
      0  15ad					      EVAL8	-80
      1  15ad				  -	      IF	(-80 > 127) || (-80 < -128)
      2  15ad				  -	      ECHO	"Erroneous position value", -80
      3  15ad				  -	      ERR
      4  15ad					      ENDIF
      5  15ad		       b0		      .byte.b	-80
      0  15ae					      EVAL8	-70
      1  15ae				  -	      IF	(-70 > 127) || (-70 < -128)
      2  15ae				  -	      ECHO	"Erroneous position value", -70
      3  15ae				  -	      ERR
      4  15ae					      ENDIF
      5  15ae		       ba		      .byte.b	-70
      0  15af					      EVAL8	-70
      1  15af				  -	      IF	(-70 > 127) || (-70 < -128)
      2  15af				  -	      ECHO	"Erroneous position value", -70
      3  15af				  -	      ERR
      4  15af					      ENDIF
      5  15af		       ba		      .byte.b	-70
      0  15b0					      EVAL8	0
      1  15b0				  -	      IF	(0 > 127) || (0 < -128)
      2  15b0				  -	      ECHO	"Erroneous position value", 0
      3  15b0				  -	      ERR
      4  15b0					      ENDIF
      5  15b0		       00		      .byte.b	0
      0  15b1					      EVAL8	0
      1  15b1				  -	      IF	(0 > 127) || (0 < -128)
      2  15b1				  -	      ECHO	"Erroneous position value", 0
      3  15b1				  -	      ERR
      4  15b1					      ENDIF
      5  15b1		       00		      .byte.b	0
      0  15b2					      EVAL8	0
      1  15b2				  -	      IF	(0 > 127) || (0 < -128)
      2  15b2				  -	      ECHO	"Erroneous position value", 0
      3  15b2				  -	      ERR
      4  15b2					      ENDIF
      5  15b2		       00		      .byte.b	0
      0  15b3					      EVAL8	0
      1  15b3				  -	      IF	(0 > 127) || (0 < -128)
      2  15b3				  -	      ECHO	"Erroneous position value", 0
      3  15b3				  -	      ERR
      4  15b3					      ENDIF
      5  15b3		       00		      .byte.b	0
      0  15b4					      PVAL	-10, -20, -20, -50, -60, -60, -20, -10
      0  15b4					      EVAL8	-10
      1  15b4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  15b4				  -	      ECHO	"Erroneous position value", -10
      3  15b4				  -	      ERR
      4  15b4					      ENDIF
      5  15b4		       f6		      .byte.b	-10
      0  15b5					      EVAL8	-20
      1  15b5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15b5				  -	      ECHO	"Erroneous position value", -20
      3  15b5				  -	      ERR
      4  15b5					      ENDIF
      5  15b5		       ec		      .byte.b	-20
      0  15b6					      EVAL8	-20
      1  15b6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15b6				  -	      ECHO	"Erroneous position value", -20
      3  15b6				  -	      ERR
      4  15b6					      ENDIF
      5  15b6		       ec		      .byte.b	-20
      0  15b7					      EVAL8	-50
      1  15b7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15b7				  -	      ECHO	"Erroneous position value", -50
      3  15b7				  -	      ERR
      4  15b7					      ENDIF
      5  15b7		       ce		      .byte.b	-50
      0  15b8					      EVAL8	-60
      1  15b8				  -	      IF	(-60 > 127) || (-60 < -128)
      2  15b8				  -	      ECHO	"Erroneous position value", -60
      3  15b8				  -	      ERR
      4  15b8					      ENDIF
      5  15b8		       c4		      .byte.b	-60
      0  15b9					      EVAL8	-60
      1  15b9				  -	      IF	(-60 > 127) || (-60 < -128)
      2  15b9				  -	      ECHO	"Erroneous position value", -60
      3  15b9				  -	      ERR
      4  15b9					      ENDIF
      5  15b9		       c4		      .byte.b	-60
      0  15ba					      EVAL8	-20
      1  15ba				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15ba				  -	      ECHO	"Erroneous position value", -20
      3  15ba				  -	      ERR
      4  15ba					      ENDIF
      5  15ba		       ec		      .byte.b	-20
      0  15bb					      EVAL8	-10
      1  15bb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  15bb				  -	      ECHO	"Erroneous position value", -10
      3  15bb				  -	      ERR
      4  15bb					      ENDIF
      5  15bb		       f6		      .byte.b	-10
      0  15bc					      EVAL8	0
      1  15bc				  -	      IF	(0 > 127) || (0 < -128)
      2  15bc				  -	      ECHO	"Erroneous position value", 0
      3  15bc				  -	      ERR
      4  15bc					      ENDIF
      5  15bc		       00		      .byte.b	0
      0  15bd					      EVAL8	0
      1  15bd				  -	      IF	(0 > 127) || (0 < -128)
      2  15bd				  -	      ECHO	"Erroneous position value", 0
      3  15bd				  -	      ERR
      4  15bd					      ENDIF
      5  15bd		       00		      .byte.b	0
      0  15be					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      0  15be					      EVAL8	-20
      1  15be				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15be				  -	      ECHO	"Erroneous position value", -20
      3  15be				  -	      ERR
      4  15be					      ENDIF
      5  15be		       ec		      .byte.b	-20
      0  15bf					      EVAL8	-30
      1  15bf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15bf				  -	      ECHO	"Erroneous position value", -30
      3  15bf				  -	      ERR
      4  15bf					      ENDIF
      5  15bf		       e2		      .byte.b	-30
      0  15c0					      EVAL8	-30
      1  15c0				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15c0				  -	      ECHO	"Erroneous position value", -30
      3  15c0				  -	      ERR
      4  15c0					      ENDIF
      5  15c0		       e2		      .byte.b	-30
      0  15c1					      EVAL8	-40
      1  15c1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15c1				  -	      ECHO	"Erroneous position value", -40
      3  15c1				  -	      ERR
      4  15c1					      ENDIF
      5  15c1		       d8		      .byte.b	-40
      0  15c2					      EVAL8	-40
      1  15c2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15c2				  -	      ECHO	"Erroneous position value", -40
      3  15c2				  -	      ERR
      4  15c2					      ENDIF
      5  15c2		       d8		      .byte.b	-40
      0  15c3					      EVAL8	-30
      1  15c3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15c3				  -	      ECHO	"Erroneous position value", -30
      3  15c3				  -	      ERR
      4  15c3					      ENDIF
      5  15c3		       e2		      .byte.b	-30
      0  15c4					      EVAL8	-30
      1  15c4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15c4				  -	      ECHO	"Erroneous position value", -30
      3  15c4				  -	      ERR
      4  15c4					      ENDIF
      5  15c4		       e2		      .byte.b	-30
      0  15c5					      EVAL8	-20
      1  15c5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15c5				  -	      ECHO	"Erroneous position value", -20
      3  15c5				  -	      ERR
      4  15c5					      ENDIF
      5  15c5		       ec		      .byte.b	-20
      0  15c6					      EVAL8	0
      1  15c6				  -	      IF	(0 > 127) || (0 < -128)
      2  15c6				  -	      ECHO	"Erroneous position value", 0
      3  15c6				  -	      ERR
      4  15c6					      ENDIF
      5  15c6		       00		      .byte.b	0
      0  15c7					      EVAL8	0
      1  15c7				  -	      IF	(0 > 127) || (0 < -128)
      2  15c7				  -	      ECHO	"Erroneous position value", 0
      3  15c7				  -	      ERR
      4  15c7					      ENDIF
      5  15c7		       00		      .byte.b	0
      0  15c8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  15c8					      EVAL8	-30
      1  15c8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15c8				  -	      ECHO	"Erroneous position value", -30
      3  15c8				  -	      ERR
      4  15c8					      ENDIF
      5  15c8		       e2		      .byte.b	-30
      0  15c9					      EVAL8	-40
      1  15c9				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15c9				  -	      ECHO	"Erroneous position value", -40
      3  15c9				  -	      ERR
      4  15c9					      ENDIF
      5  15c9		       d8		      .byte.b	-40
      0  15ca					      EVAL8	-40
      1  15ca				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15ca				  -	      ECHO	"Erroneous position value", -40
      3  15ca				  -	      ERR
      4  15ca					      ENDIF
      5  15ca		       d8		      .byte.b	-40
      0  15cb					      EVAL8	-50
      1  15cb				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15cb				  -	      ECHO	"Erroneous position value", -50
      3  15cb				  -	      ERR
      4  15cb					      ENDIF
      5  15cb		       ce		      .byte.b	-50
      0  15cc					      EVAL8	-50
      1  15cc				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15cc				  -	      ECHO	"Erroneous position value", -50
      3  15cc				  -	      ERR
      4  15cc					      ENDIF
      5  15cc		       ce		      .byte.b	-50
      0  15cd					      EVAL8	-40
      1  15cd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15cd				  -	      ECHO	"Erroneous position value", -40
      3  15cd				  -	      ERR
      4  15cd					      ENDIF
      5  15cd		       d8		      .byte.b	-40
      0  15ce					      EVAL8	-40
      1  15ce				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15ce				  -	      ECHO	"Erroneous position value", -40
      3  15ce				  -	      ERR
      4  15ce					      ENDIF
      5  15ce		       d8		      .byte.b	-40
      0  15cf					      EVAL8	-30
      1  15cf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15cf				  -	      ECHO	"Erroneous position value", -30
      3  15cf				  -	      ERR
      4  15cf					      ENDIF
      5  15cf		       e2		      .byte.b	-30
      0  15d0					      EVAL8	0
      1  15d0				  -	      IF	(0 > 127) || (0 < -128)
      2  15d0				  -	      ECHO	"Erroneous position value", 0
      3  15d0				  -	      ERR
      4  15d0					      ENDIF
      5  15d0		       00		      .byte.b	0
      0  15d1					      EVAL8	0
      1  15d1				  -	      IF	(0 > 127) || (0 < -128)
      2  15d1				  -	      ECHO	"Erroneous position value", 0
      3  15d1				  -	      ERR
      4  15d1					      ENDIF
      5  15d1		       00		      .byte.b	0
      0  15d2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  15d2					      EVAL8	-30
      1  15d2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15d2				  -	      ECHO	"Erroneous position value", -30
      3  15d2				  -	      ERR
      4  15d2					      ENDIF
      5  15d2		       e2		      .byte.b	-30
      0  15d3					      EVAL8	-40
      1  15d3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15d3				  -	      ECHO	"Erroneous position value", -40
      3  15d3				  -	      ERR
      4  15d3					      ENDIF
      5  15d3		       d8		      .byte.b	-40
      0  15d4					      EVAL8	-40
      1  15d4				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15d4				  -	      ECHO	"Erroneous position value", -40
      3  15d4				  -	      ERR
      4  15d4					      ENDIF
      5  15d4		       d8		      .byte.b	-40
      0  15d5					      EVAL8	-50
      1  15d5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15d5				  -	      ECHO	"Erroneous position value", -50
      3  15d5				  -	      ERR
      4  15d5					      ENDIF
      5  15d5		       ce		      .byte.b	-50
      0  15d6					      EVAL8	-50
      1  15d6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15d6				  -	      ECHO	"Erroneous position value", -50
      3  15d6				  -	      ERR
      4  15d6					      ENDIF
      5  15d6		       ce		      .byte.b	-50
      0  15d7					      EVAL8	-40
      1  15d7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15d7				  -	      ECHO	"Erroneous position value", -40
      3  15d7				  -	      ERR
      4  15d7					      ENDIF
      5  15d7		       d8		      .byte.b	-40
      0  15d8					      EVAL8	-40
      1  15d8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15d8				  -	      ECHO	"Erroneous position value", -40
      3  15d8				  -	      ERR
      4  15d8					      ENDIF
      5  15d8		       d8		      .byte.b	-40
      0  15d9					      EVAL8	-30
      1  15d9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15d9				  -	      ECHO	"Erroneous position value", -30
      3  15d9				  -	      ERR
      4  15d9					      ENDIF
      5  15d9		       e2		      .byte.b	-30
      0  15da					      EVAL8	0
      1  15da				  -	      IF	(0 > 127) || (0 < -128)
      2  15da				  -	      ECHO	"Erroneous position value", 0
      3  15da				  -	      ERR
      4  15da					      ENDIF
      5  15da		       00		      .byte.b	0
      0  15db					      EVAL8	0
      1  15db				  -	      IF	(0 > 127) || (0 < -128)
      2  15db				  -	      ECHO	"Erroneous position value", 0
      3  15db				  -	      ERR
      4  15db					      ENDIF
      5  15db		       00		      .byte.b	0
      0  15dc					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  15dc					      EVAL8	-30
      1  15dc				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15dc				  -	      ECHO	"Erroneous position value", -30
      3  15dc				  -	      ERR
      4  15dc					      ENDIF
      5  15dc		       e2		      .byte.b	-30
      0  15dd					      EVAL8	-40
      1  15dd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15dd				  -	      ECHO	"Erroneous position value", -40
      3  15dd				  -	      ERR
      4  15dd					      ENDIF
      5  15dd		       d8		      .byte.b	-40
      0  15de					      EVAL8	-40
      1  15de				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15de				  -	      ECHO	"Erroneous position value", -40
      3  15de				  -	      ERR
      4  15de					      ENDIF
      5  15de		       d8		      .byte.b	-40
      0  15df					      EVAL8	-50
      1  15df				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15df				  -	      ECHO	"Erroneous position value", -50
      3  15df				  -	      ERR
      4  15df					      ENDIF
      5  15df		       ce		      .byte.b	-50
      0  15e0					      EVAL8	-50
      1  15e0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15e0				  -	      ECHO	"Erroneous position value", -50
      3  15e0				  -	      ERR
      4  15e0					      ENDIF
      5  15e0		       ce		      .byte.b	-50
      0  15e1					      EVAL8	-40
      1  15e1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15e1				  -	      ECHO	"Erroneous position value", -40
      3  15e1				  -	      ERR
      4  15e1					      ENDIF
      5  15e1		       d8		      .byte.b	-40
      0  15e2					      EVAL8	-40
      1  15e2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15e2				  -	      ECHO	"Erroneous position value", -40
      3  15e2				  -	      ERR
      4  15e2					      ENDIF
      5  15e2		       d8		      .byte.b	-40
      0  15e3					      EVAL8	-30
      1  15e3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15e3				  -	      ECHO	"Erroneous position value", -30
      3  15e3				  -	      ERR
      4  15e3					      ENDIF
      5  15e3		       e2		      .byte.b	-30
      0  15e4					      EVAL8	0
      1  15e4				  -	      IF	(0 > 127) || (0 < -128)
      2  15e4				  -	      ECHO	"Erroneous position value", 0
      3  15e4				  -	      ERR
      4  15e4					      ENDIF
      5  15e4		       00		      .byte.b	0
      0  15e5					      EVAL8	0
      1  15e5				  -	      IF	(0 > 127) || (0 < -128)
      2  15e5				  -	      ECHO	"Erroneous position value", 0
      3  15e5				  -	      ERR
      4  15e5					      ENDIF
      5  15e5		       00		      .byte.b	0
      0  15e6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  15e6					      EVAL8	-30
      1  15e6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15e6				  -	      ECHO	"Erroneous position value", -30
      3  15e6				  -	      ERR
      4  15e6					      ENDIF
      5  15e6		       e2		      .byte.b	-30
      0  15e7					      EVAL8	-40
      1  15e7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15e7				  -	      ECHO	"Erroneous position value", -40
      3  15e7				  -	      ERR
      4  15e7					      ENDIF
      5  15e7		       d8		      .byte.b	-40
      0  15e8					      EVAL8	-40
      1  15e8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15e8				  -	      ECHO	"Erroneous position value", -40
      3  15e8				  -	      ERR
      4  15e8					      ENDIF
      5  15e8		       d8		      .byte.b	-40
      0  15e9					      EVAL8	-50
      1  15e9				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15e9				  -	      ECHO	"Erroneous position value", -50
      3  15e9				  -	      ERR
      4  15e9					      ENDIF
      5  15e9		       ce		      .byte.b	-50
      0  15ea					      EVAL8	-50
      1  15ea				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15ea				  -	      ECHO	"Erroneous position value", -50
      3  15ea				  -	      ERR
      4  15ea					      ENDIF
      5  15ea		       ce		      .byte.b	-50
      0  15eb					      EVAL8	-40
      1  15eb				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15eb				  -	      ECHO	"Erroneous position value", -40
      3  15eb				  -	      ERR
      4  15eb					      ENDIF
      5  15eb		       d8		      .byte.b	-40
      0  15ec					      EVAL8	-40
      1  15ec				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15ec				  -	      ECHO	"Erroneous position value", -40
      3  15ec				  -	      ERR
      4  15ec					      ENDIF
      5  15ec		       d8		      .byte.b	-40
      0  15ed					      EVAL8	-30
      1  15ed				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15ed				  -	      ECHO	"Erroneous position value", -30
      3  15ed				  -	      ERR
      4  15ed					      ENDIF
      5  15ed		       e2		      .byte.b	-30
      0  15ee					      EVAL8	0
      1  15ee				  -	      IF	(0 > 127) || (0 < -128)
      2  15ee				  -	      ECHO	"Erroneous position value", 0
      3  15ee				  -	      ERR
      4  15ee					      ENDIF
      5  15ee		       00		      .byte.b	0
      0  15ef					      EVAL8	0
      1  15ef				  -	      IF	(0 > 127) || (0 < -128)
      2  15ef				  -	      ECHO	"Erroneous position value", 0
      3  15ef				  -	      ERR
      4  15ef					      ENDIF
      5  15ef		       00		      .byte.b	0
    173  15f0
    174  15f0
    175  15f0							;---------------------------------------------------------------------------------------------------
    176  15f0
    177  15f0				   PositionalValue_KING_ENDGAME
    178  15f0
      0  15f0					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      0  15f0					      EVAL8	-50
      1  15f0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15f0				  -	      ECHO	"Erroneous position value", -50
      3  15f0				  -	      ERR
      4  15f0					      ENDIF
      5  15f0		       ce		      .byte.b	-50
      0  15f1					      EVAL8	-30
      1  15f1				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f1				  -	      ECHO	"Erroneous position value", -30
      3  15f1				  -	      ERR
      4  15f1					      ENDIF
      5  15f1		       e2		      .byte.b	-30
      0  15f2					      EVAL8	-30
      1  15f2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f2				  -	      ECHO	"Erroneous position value", -30
      3  15f2				  -	      ERR
      4  15f2					      ENDIF
      5  15f2		       e2		      .byte.b	-30
      0  15f3					      EVAL8	-30
      1  15f3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f3				  -	      ECHO	"Erroneous position value", -30
      3  15f3				  -	      ERR
      4  15f3					      ENDIF
      5  15f3		       e2		      .byte.b	-30
      0  15f4					      EVAL8	-30
      1  15f4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f4				  -	      ECHO	"Erroneous position value", -30
      3  15f4				  -	      ERR
      4  15f4					      ENDIF
      5  15f4		       e2		      .byte.b	-30
      0  15f5					      EVAL8	-30
      1  15f5				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f5				  -	      ECHO	"Erroneous position value", -30
      3  15f5				  -	      ERR
      4  15f5					      ENDIF
      5  15f5		       e2		      .byte.b	-30
      0  15f6					      EVAL8	-30
      1  15f6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f6				  -	      ECHO	"Erroneous position value", -30
      3  15f6				  -	      ERR
      4  15f6					      ENDIF
      5  15f6		       e2		      .byte.b	-30
      0  15f7					      EVAL8	-50
      1  15f7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15f7				  -	      ECHO	"Erroneous position value", -50
      3  15f7				  -	      ERR
      4  15f7					      ENDIF
      5  15f7		       ce		      .byte.b	-50
      0  15f8					      EVAL8	0
      1  15f8				  -	      IF	(0 > 127) || (0 < -128)
      2  15f8				  -	      ECHO	"Erroneous position value", 0
      3  15f8				  -	      ERR
      4  15f8					      ENDIF
      5  15f8		       00		      .byte.b	0
      0  15f9					      EVAL8	0
      1  15f9				  -	      IF	(0 > 127) || (0 < -128)
      2  15f9				  -	      ECHO	"Erroneous position value", 0
      3  15f9				  -	      ERR
      4  15f9					      ENDIF
      5  15f9		       00		      .byte.b	0
      0  15fa					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      0  15fa					      EVAL8	-30
      1  15fa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15fa				  -	      ECHO	"Erroneous position value", -30
      3  15fa				  -	      ERR
      4  15fa					      ENDIF
      5  15fa		       e2		      .byte.b	-30
      0  15fb					      EVAL8	-30
      1  15fb				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15fb				  -	      ECHO	"Erroneous position value", -30
      3  15fb				  -	      ERR
      4  15fb					      ENDIF
      5  15fb		       e2		      .byte.b	-30
      0  15fc					      EVAL8	0
      1  15fc				  -	      IF	(0 > 127) || (0 < -128)
      2  15fc				  -	      ECHO	"Erroneous position value", 0
      3  15fc				  -	      ERR
      4  15fc					      ENDIF
      5  15fc		       00		      .byte.b	0
      0  15fd					      EVAL8	0
      1  15fd				  -	      IF	(0 > 127) || (0 < -128)
      2  15fd				  -	      ECHO	"Erroneous position value", 0
      3  15fd				  -	      ERR
      4  15fd					      ENDIF
      5  15fd		       00		      .byte.b	0
      0  15fe					      EVAL8	0
      1  15fe				  -	      IF	(0 > 127) || (0 < -128)
      2  15fe				  -	      ECHO	"Erroneous position value", 0
      3  15fe				  -	      ERR
      4  15fe					      ENDIF
      5  15fe		       00		      .byte.b	0
      0  15ff					      EVAL8	0
      1  15ff				  -	      IF	(0 > 127) || (0 < -128)
      2  15ff				  -	      ECHO	"Erroneous position value", 0
      3  15ff				  -	      ERR
      4  15ff					      ENDIF
      5  15ff		       00		      .byte.b	0
      0  1600					      EVAL8	-30
      1  1600				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1600				  -	      ECHO	"Erroneous position value", -30
      3  1600				  -	      ERR
      4  1600					      ENDIF
      5  1600		       e2		      .byte.b	-30
      0  1601					      EVAL8	-30
      1  1601				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1601				  -	      ECHO	"Erroneous position value", -30
      3  1601				  -	      ERR
      4  1601					      ENDIF
      5  1601		       e2		      .byte.b	-30
      0  1602					      EVAL8	0
      1  1602				  -	      IF	(0 > 127) || (0 < -128)
      2  1602				  -	      ECHO	"Erroneous position value", 0
      3  1602				  -	      ERR
      4  1602					      ENDIF
      5  1602		       00		      .byte.b	0
      0  1603					      EVAL8	0
      1  1603				  -	      IF	(0 > 127) || (0 < -128)
      2  1603				  -	      ECHO	"Erroneous position value", 0
      3  1603				  -	      ERR
      4  1603					      ENDIF
      5  1603		       00		      .byte.b	0
      0  1604					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  1604					      EVAL8	-30
      1  1604				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1604				  -	      ECHO	"Erroneous position value", -30
      3  1604				  -	      ERR
      4  1604					      ENDIF
      5  1604		       e2		      .byte.b	-30
      0  1605					      EVAL8	-10
      1  1605				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1605				  -	      ECHO	"Erroneous position value", -10
      3  1605				  -	      ERR
      4  1605					      ENDIF
      5  1605		       f6		      .byte.b	-10
      0  1606					      EVAL8	20
      1  1606				  -	      IF	(20 > 127) || (20 < -128)
      2  1606				  -	      ECHO	"Erroneous position value", 20
      3  1606				  -	      ERR
      4  1606					      ENDIF
      5  1606		       14		      .byte.b	20
      0  1607					      EVAL8	30
      1  1607				  -	      IF	(30 > 127) || (30 < -128)
      2  1607				  -	      ECHO	"Erroneous position value", 30
      3  1607				  -	      ERR
      4  1607					      ENDIF
      5  1607		       1e		      .byte.b	30
      0  1608					      EVAL8	30
      1  1608				  -	      IF	(30 > 127) || (30 < -128)
      2  1608				  -	      ECHO	"Erroneous position value", 30
      3  1608				  -	      ERR
      4  1608					      ENDIF
      5  1608		       1e		      .byte.b	30
      0  1609					      EVAL8	20
      1  1609				  -	      IF	(20 > 127) || (20 < -128)
      2  1609				  -	      ECHO	"Erroneous position value", 20
      3  1609				  -	      ERR
      4  1609					      ENDIF
      5  1609		       14		      .byte.b	20
      0  160a					      EVAL8	-10
      1  160a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  160a				  -	      ECHO	"Erroneous position value", -10
      3  160a				  -	      ERR
      4  160a					      ENDIF
      5  160a		       f6		      .byte.b	-10
      0  160b					      EVAL8	-30
      1  160b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  160b				  -	      ECHO	"Erroneous position value", -30
      3  160b				  -	      ERR
      4  160b					      ENDIF
      5  160b		       e2		      .byte.b	-30
      0  160c					      EVAL8	0
      1  160c				  -	      IF	(0 > 127) || (0 < -128)
      2  160c				  -	      ECHO	"Erroneous position value", 0
      3  160c				  -	      ERR
      4  160c					      ENDIF
      5  160c		       00		      .byte.b	0
      0  160d					      EVAL8	0
      1  160d				  -	      IF	(0 > 127) || (0 < -128)
      2  160d				  -	      ECHO	"Erroneous position value", 0
      3  160d				  -	      ERR
      4  160d					      ENDIF
      5  160d		       00		      .byte.b	0
      0  160e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  160e					      EVAL8	-30
      1  160e				  -	      IF	(-30 > 127) || (-30 < -128)
      2  160e				  -	      ECHO	"Erroneous position value", -30
      3  160e				  -	      ERR
      4  160e					      ENDIF
      5  160e		       e2		      .byte.b	-30
      0  160f					      EVAL8	-10
      1  160f				  -	      IF	(-10 > 127) || (-10 < -128)
      2  160f				  -	      ECHO	"Erroneous position value", -10
      3  160f				  -	      ERR
      4  160f					      ENDIF
      5  160f		       f6		      .byte.b	-10
      0  1610					      EVAL8	30
      1  1610				  -	      IF	(30 > 127) || (30 < -128)
      2  1610				  -	      ECHO	"Erroneous position value", 30
      3  1610				  -	      ERR
      4  1610					      ENDIF
      5  1610		       1e		      .byte.b	30
      0  1611					      EVAL8	40
      1  1611				  -	      IF	(40 > 127) || (40 < -128)
      2  1611				  -	      ECHO	"Erroneous position value", 40
      3  1611				  -	      ERR
      4  1611					      ENDIF
      5  1611		       28		      .byte.b	40
      0  1612					      EVAL8	40
      1  1612				  -	      IF	(40 > 127) || (40 < -128)
      2  1612				  -	      ECHO	"Erroneous position value", 40
      3  1612				  -	      ERR
      4  1612					      ENDIF
      5  1612		       28		      .byte.b	40
      0  1613					      EVAL8	30
      1  1613				  -	      IF	(30 > 127) || (30 < -128)
      2  1613				  -	      ECHO	"Erroneous position value", 30
      3  1613				  -	      ERR
      4  1613					      ENDIF
      5  1613		       1e		      .byte.b	30
      0  1614					      EVAL8	-10
      1  1614				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1614				  -	      ECHO	"Erroneous position value", -10
      3  1614				  -	      ERR
      4  1614					      ENDIF
      5  1614		       f6		      .byte.b	-10
      0  1615					      EVAL8	-30
      1  1615				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1615				  -	      ECHO	"Erroneous position value", -30
      3  1615				  -	      ERR
      4  1615					      ENDIF
      5  1615		       e2		      .byte.b	-30
      0  1616					      EVAL8	0
      1  1616				  -	      IF	(0 > 127) || (0 < -128)
      2  1616				  -	      ECHO	"Erroneous position value", 0
      3  1616				  -	      ERR
      4  1616					      ENDIF
      5  1616		       00		      .byte.b	0
      0  1617					      EVAL8	0
      1  1617				  -	      IF	(0 > 127) || (0 < -128)
      2  1617				  -	      ECHO	"Erroneous position value", 0
      3  1617				  -	      ERR
      4  1617					      ENDIF
      5  1617		       00		      .byte.b	0
      0  1618					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  1618					      EVAL8	-30
      1  1618				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1618				  -	      ECHO	"Erroneous position value", -30
      3  1618				  -	      ERR
      4  1618					      ENDIF
      5  1618		       e2		      .byte.b	-30
      0  1619					      EVAL8	-10
      1  1619				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1619				  -	      ECHO	"Erroneous position value", -10
      3  1619				  -	      ERR
      4  1619					      ENDIF
      5  1619		       f6		      .byte.b	-10
      0  161a					      EVAL8	30
      1  161a				  -	      IF	(30 > 127) || (30 < -128)
      2  161a				  -	      ECHO	"Erroneous position value", 30
      3  161a				  -	      ERR
      4  161a					      ENDIF
      5  161a		       1e		      .byte.b	30
      0  161b					      EVAL8	40
      1  161b				  -	      IF	(40 > 127) || (40 < -128)
      2  161b				  -	      ECHO	"Erroneous position value", 40
      3  161b				  -	      ERR
      4  161b					      ENDIF
      5  161b		       28		      .byte.b	40
      0  161c					      EVAL8	40
      1  161c				  -	      IF	(40 > 127) || (40 < -128)
      2  161c				  -	      ECHO	"Erroneous position value", 40
      3  161c				  -	      ERR
      4  161c					      ENDIF
      5  161c		       28		      .byte.b	40
      0  161d					      EVAL8	30
      1  161d				  -	      IF	(30 > 127) || (30 < -128)
      2  161d				  -	      ECHO	"Erroneous position value", 30
      3  161d				  -	      ERR
      4  161d					      ENDIF
      5  161d		       1e		      .byte.b	30
      0  161e					      EVAL8	-10
      1  161e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  161e				  -	      ECHO	"Erroneous position value", -10
      3  161e				  -	      ERR
      4  161e					      ENDIF
      5  161e		       f6		      .byte.b	-10
      0  161f					      EVAL8	-30
      1  161f				  -	      IF	(-30 > 127) || (-30 < -128)
      2  161f				  -	      ECHO	"Erroneous position value", -30
      3  161f				  -	      ERR
      4  161f					      ENDIF
      5  161f		       e2		      .byte.b	-30
      0  1620					      EVAL8	0
      1  1620				  -	      IF	(0 > 127) || (0 < -128)
      2  1620				  -	      ECHO	"Erroneous position value", 0
      3  1620				  -	      ERR
      4  1620					      ENDIF
      5  1620		       00		      .byte.b	0
      0  1621					      EVAL8	0
      1  1621				  -	      IF	(0 > 127) || (0 < -128)
      2  1621				  -	      ECHO	"Erroneous position value", 0
      3  1621				  -	      ERR
      4  1621					      ENDIF
      5  1621		       00		      .byte.b	0
      0  1622					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  1622					      EVAL8	-30
      1  1622				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1622				  -	      ECHO	"Erroneous position value", -30
      3  1622				  -	      ERR
      4  1622					      ENDIF
      5  1622		       e2		      .byte.b	-30
      0  1623					      EVAL8	-10
      1  1623				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1623				  -	      ECHO	"Erroneous position value", -10
      3  1623				  -	      ERR
      4  1623					      ENDIF
      5  1623		       f6		      .byte.b	-10
      0  1624					      EVAL8	20
      1  1624				  -	      IF	(20 > 127) || (20 < -128)
      2  1624				  -	      ECHO	"Erroneous position value", 20
      3  1624				  -	      ERR
      4  1624					      ENDIF
      5  1624		       14		      .byte.b	20
      0  1625					      EVAL8	30
      1  1625				  -	      IF	(30 > 127) || (30 < -128)
      2  1625				  -	      ECHO	"Erroneous position value", 30
      3  1625				  -	      ERR
      4  1625					      ENDIF
      5  1625		       1e		      .byte.b	30
      0  1626					      EVAL8	30
      1  1626				  -	      IF	(30 > 127) || (30 < -128)
      2  1626				  -	      ECHO	"Erroneous position value", 30
      3  1626				  -	      ERR
      4  1626					      ENDIF
      5  1626		       1e		      .byte.b	30
      0  1627					      EVAL8	20
      1  1627				  -	      IF	(20 > 127) || (20 < -128)
      2  1627				  -	      ECHO	"Erroneous position value", 20
      3  1627				  -	      ERR
      4  1627					      ENDIF
      5  1627		       14		      .byte.b	20
      0  1628					      EVAL8	-10
      1  1628				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1628				  -	      ECHO	"Erroneous position value", -10
      3  1628				  -	      ERR
      4  1628					      ENDIF
      5  1628		       f6		      .byte.b	-10
      0  1629					      EVAL8	-30
      1  1629				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1629				  -	      ECHO	"Erroneous position value", -30
      3  1629				  -	      ERR
      4  1629					      ENDIF
      5  1629		       e2		      .byte.b	-30
      0  162a					      EVAL8	0
      1  162a				  -	      IF	(0 > 127) || (0 < -128)
      2  162a				  -	      ECHO	"Erroneous position value", 0
      3  162a				  -	      ERR
      4  162a					      ENDIF
      5  162a		       00		      .byte.b	0
      0  162b					      EVAL8	0
      1  162b				  -	      IF	(0 > 127) || (0 < -128)
      2  162b				  -	      ECHO	"Erroneous position value", 0
      3  162b				  -	      ERR
      4  162b					      ENDIF
      5  162b		       00		      .byte.b	0
      0  162c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      0  162c					      EVAL8	-30
      1  162c				  -	      IF	(-30 > 127) || (-30 < -128)
      2  162c				  -	      ECHO	"Erroneous position value", -30
      3  162c				  -	      ERR
      4  162c					      ENDIF
      5  162c		       e2		      .byte.b	-30
      0  162d					      EVAL8	-20
      1  162d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  162d				  -	      ECHO	"Erroneous position value", -20
      3  162d				  -	      ERR
      4  162d					      ENDIF
      5  162d		       ec		      .byte.b	-20
      0  162e					      EVAL8	-10
      1  162e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  162e				  -	      ECHO	"Erroneous position value", -10
      3  162e				  -	      ERR
      4  162e					      ENDIF
      5  162e		       f6		      .byte.b	-10
      0  162f					      EVAL8	0
      1  162f				  -	      IF	(0 > 127) || (0 < -128)
      2  162f				  -	      ECHO	"Erroneous position value", 0
      3  162f				  -	      ERR
      4  162f					      ENDIF
      5  162f		       00		      .byte.b	0
      0  1630					      EVAL8	0
      1  1630				  -	      IF	(0 > 127) || (0 < -128)
      2  1630				  -	      ECHO	"Erroneous position value", 0
      3  1630				  -	      ERR
      4  1630					      ENDIF
      5  1630		       00		      .byte.b	0
      0  1631					      EVAL8	-10
      1  1631				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1631				  -	      ECHO	"Erroneous position value", -10
      3  1631				  -	      ERR
      4  1631					      ENDIF
      5  1631		       f6		      .byte.b	-10
      0  1632					      EVAL8	-20
      1  1632				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1632				  -	      ECHO	"Erroneous position value", -20
      3  1632				  -	      ERR
      4  1632					      ENDIF
      5  1632		       ec		      .byte.b	-20
      0  1633					      EVAL8	-30
      1  1633				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1633				  -	      ECHO	"Erroneous position value", -30
      3  1633				  -	      ERR
      4  1633					      ENDIF
      5  1633		       e2		      .byte.b	-30
      0  1634					      EVAL8	0
      1  1634				  -	      IF	(0 > 127) || (0 < -128)
      2  1634				  -	      ECHO	"Erroneous position value", 0
      3  1634				  -	      ERR
      4  1634					      ENDIF
      5  1634		       00		      .byte.b	0
      0  1635					      EVAL8	0
      1  1635				  -	      IF	(0 > 127) || (0 < -128)
      2  1635				  -	      ECHO	"Erroneous position value", 0
      3  1635				  -	      ERR
      4  1635					      ENDIF
      5  1635		       00		      .byte.b	0
      0  1636					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      0  1636					      EVAL8	-50
      1  1636				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1636				  -	      ECHO	"Erroneous position value", -50
      3  1636				  -	      ERR
      4  1636					      ENDIF
      5  1636		       ce		      .byte.b	-50
      0  1637					      EVAL8	-40
      1  1637				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1637				  -	      ECHO	"Erroneous position value", -40
      3  1637				  -	      ERR
      4  1637					      ENDIF
      5  1637		       d8		      .byte.b	-40
      0  1638					      EVAL8	-30
      1  1638				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1638				  -	      ECHO	"Erroneous position value", -30
      3  1638				  -	      ERR
      4  1638					      ENDIF
      5  1638		       e2		      .byte.b	-30
      0  1639					      EVAL8	-20
      1  1639				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1639				  -	      ECHO	"Erroneous position value", -20
      3  1639				  -	      ERR
      4  1639					      ENDIF
      5  1639		       ec		      .byte.b	-20
      0  163a					      EVAL8	- 20
      1  163a				  -	      IF	(- 20 > 127) || (- 20 < -128)
      2  163a				  -	      ECHO	"Erroneous position value", - 20
      3  163a				  -	      ERR
      4  163a					      ENDIF
      5  163a		       ec		      .byte.b	- 20
      0  163b					      EVAL8	-30
      1  163b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  163b				  -	      ECHO	"Erroneous position value", -30
      3  163b				  -	      ERR
      4  163b					      ENDIF
      5  163b		       e2		      .byte.b	-30
      0  163c					      EVAL8	-40
      1  163c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  163c				  -	      ECHO	"Erroneous position value", -40
      3  163c				  -	      ERR
      4  163c					      ENDIF
      5  163c		       d8		      .byte.b	-40
      0  163d					      EVAL8	-50
      1  163d				  -	      IF	(-50 > 127) || (-50 < -128)
      2  163d				  -	      ECHO	"Erroneous position value", -50
      3  163d				  -	      ERR
      4  163d					      ENDIF
      5  163d		       ce		      .byte.b	-50
      0  163e					      EVAL8	0
      1  163e				  -	      IF	(0 > 127) || (0 < -128)
      2  163e				  -	      ECHO	"Erroneous position value", 0
      3  163e				  -	      ERR
      4  163e					      ENDIF
      5  163e		       00		      .byte.b	0
      0  163f					      EVAL8	0
      1  163f				  -	      IF	(0 > 127) || (0 < -128)
      2  163f				  -	      ECHO	"Erroneous position value", 0
      3  163f				  -	      ERR
      4  163f					      ENDIF
      5  163f		       00		      .byte.b	0
    187  1640
    188  1640
    189  1640
      0  1640					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  1640		       02 40	   .TEMP      =	* - _BANK_START
 BANK_EVAL (1K) SIZE =  $240 , FREE= $1c0
      2  1640					      ECHO	"BANK_EVAL", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1640				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1640				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_EVAL", " size=", * - ORIGIN
      5  1640				  -	      ERR
      6  1640					      ENDIF
    191  1640
    192  1640							;---------------------------------------------------------------------------------------------------
    193  1640							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#1.asm LEVEL 2 PASS 4
      0  1640					      include	"BANK_StateMachine@1#1.asm"
      0  1640					      SLOT	1
      1  1640				  -	      IF	(1 < 0) || (1 > 3)
      2  1640				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1640				  -	      ERR
      4  1640					      ENDIF
      5  1640				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1640				   _BANK_SLOT SET	1 * 64
      0  1640					      NEWBANK	STATEMACHINE
      1  1bf0 ????				      SEG	STATEMACHINE
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   STATEMACHINE_START SET	*
      6  1800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1800				   STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + 1024
      3  1800
      4  1800
      5  1800							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      6  1800
      7  1800
      8  1800		       00 10	   CURSOR_MOVE_SPEED =	16
      9  1800		       00 14	   CAP_SPEED  =	20
     10  1800		       00 28	   HOLD_DELAY =	40
     11  1800
     12  1800
     13  1800							;---------------------------------------------------------------------------------------------------
     14  1800
     15  1800
     16  1800							;---------------------------------------------------------------------------------------------------
     17  1800
      0  1800					      DEF	aiStartMoveGen
      1  1800				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  1800				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  1800				   aiStartMoveGen
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	aiStartMoveGen
     19  1800					      SUBROUTINE
     20  1800
      0  1800					      REFER	AiStateMachine
      1  1800					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1800				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1800					      ENDIF
      0  1800					      VEND	aiStartMoveGen
      1  1800				  -	      IFNCONST	aiStartMoveGen
      2  1800				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  1800				  -	      ERR
      4  1800					      ENDIF
      5  1800		       00 a9	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
     23  1800
     24  1800							; To assist with castling, generate the moves for the opponent, giving us effectively
     25  1800							; a list of squares that are being attacked. The castling can't happen if the king is
     26  1800							; in check or if the squares it would have to move over are in check
     27  1800
     28  1800							; we don't need to worry about this if K has moved, or relevant R has moved or if
     29  1800							; the squares between are occupied. We can tell THAT by examining the movelist to see
     30  1800							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     31  1800
     32  1800							;inc currentPly
     33  1800							;jsr InitialiseMoveGeneration
     34  1800
      0  1800					      PHASE	AI_StepMoveGen
      1  1800		       a9 0c		      lda	#AI_StepMoveGen
      2  1802		       85 8b		      sta	aiState
     36  1804		       60		      rts
     37  1805
     38  1805
     39  1805							;---------------------------------------------------------------------------------------------------
     40  1805
      0  1805					      DEF	aiInCheckBackup
      1  1805				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  1805				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  1805				   aiInCheckBackup
      4  1805				   TEMPORARY_VAR SET	Overlay
      5  1805				   TEMPORARY_OFFSET SET	0
      6  1805				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  1805				   FUNCTION_NAME SET	aiInCheckBackup
     42  1805					      SUBROUTINE
     43  1805
      0  1805					      REFER	AiStateMachine
      1  1805					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1805				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1805					      ENDIF
      0  1805					      VEND	aiInCheckBackup
      1  1805				  -	      IFNCONST	aiInCheckBackup
      2  1805				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  1805				  -	      ERR
      4  1805					      ENDIF
      5  1805		       00 a9	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
     46  1805
     47  1805							; We're about to draw some large text on the screen
     48  1805							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     49  1805
     50  1805		       c6 84		      dec	drawCount
     51  1807		       30 02		      bmi	.exit	; done all rows
     52  1809		       a4 84		      ldy	drawCount
     53  180b				  -	      IF	0
     54  180b				  -	      jmp	SAFE_BackupBitmaps
     55  180b					      ENDIF
     56  180b
      0  180b				   .exit      PHASE	AI_InCheckDelay
      1  180b		       a9 1e		      lda	#AI_InCheckDelay
      2  180d		       85 8b		      sta	aiState
     58  180f		       60		      rts
     59  1810
     60  1810
     61  1810							;---------------------------------------------------------------------------------------------------
     62  1810
      0  1810					      DEF	aiInCheckDelay
      1  1810				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  1810				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  1810				   aiInCheckDelay
      4  1810				   TEMPORARY_VAR SET	Overlay
      5  1810				   TEMPORARY_OFFSET SET	0
      6  1810				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  1810				   FUNCTION_NAME SET	aiInCheckDelay
     64  1810					      SUBROUTINE
     65  1810
      0  1810					      REFER	AiStateMachine
      1  1810					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1810				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1810					      ENDIF
      0  1810					      VEND	aiInCheckDelay
      1  1810				  -	      IFNCONST	aiInCheckDelay
      2  1810				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  1810				  -	      ERR
      4  1810					      ENDIF
      5  1810		       00 a9	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
     68  1810
     69  1810		       c6 89		      dec	mdelay
     70  1812		       d0 08		      bne	.exit
     71  1814
     72  1814		       a9 00		      lda	#0
     73  1816		       85 49		      sta	COLUBK
     74  1818
      0  1818					      PHASE	AI_BeginSelectMovePhase
      1  1818		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  181a		       85 8b		      sta	aiState
     76  181c		       60	   .exit      rts
     77  181d
     78  181d
     79  181d							;---------------------------------------------------------------------------------------------------
     80  181d
      0  181d					      DEF	aiBeginSelectMovePhase
      1  181d				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  181d				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  181d				   aiBeginSelectMovePhase
      4  181d				   TEMPORARY_VAR SET	Overlay
      5  181d				   TEMPORARY_OFFSET SET	0
      6  181d				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  181d				   FUNCTION_NAME SET	aiBeginSelectMovePhase
     82  181d					      SUBROUTINE
     83  181d
      0  181d					      REFER	AiStateMachine
      1  181d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  181d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  181d					      ENDIF
      0  181d					      VEND	aiBeginSelectMovePhase
      1  181d				  -	      IFNCONST	aiBeginSelectMovePhase
      2  181d				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  181d				  -	      ERR
      4  181d					      ENDIF
      5  181d		       00 a9	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
     86  181d
     87  181d
     88  181d		       a9 02		      lda	#$2
     89  181f		       85 46		      sta	COLUP0
     90  1821		       a2 04		      ldx	#%100
     91  1823		       86 4a		      stx	CTRLPF	; under
     92  1825
     93  1825		       a9 00		      lda	#0
     94  1827		       85 89		      sta	mdelay	;?
     95  1829		       85 8e		      sta	aiFlashPhase	; odd/even for flashing pieces
     96  182b
     97  182b		       a9 28		      lda	#CAP_SPEED*2
     98  182d		       85 8c		      sta	aiFlashDelay
     99  182f
    100  182f		       a9 ff		      lda	#-1
    101  1831		       85 85		      sta	fromX12
    102  1833		       85 86		      sta	toX12
    103  1835
    104  1835		       46 a2		      lsr	randomness
    105  1837
    106  1837
      0  1837					      PHASE	AI_FlashComputerMove
      1  1837		       a9 00		      lda	#AI_FlashComputerMove
      2  1839		       85 8b		      sta	aiState
    108  183b		       60		      rts
    109  183c
    110  183c							;---------------------------------------------------------------------------------------------------
    111  183c
      0  183c					      DEF	aiFlashComputerMove
      1  183c				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  183c				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  183c				   aiFlashComputerMove
      4  183c				   TEMPORARY_VAR SET	Overlay
      5  183c				   TEMPORARY_OFFSET SET	0
      6  183c				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  183c				   FUNCTION_NAME SET	aiFlashComputerMove
    113  183c					      SUBROUTINE
    114  183c
      0  183c					      REFER	AiStateMachine
      1  183c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  183c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  183c					      ENDIF
      0  183c					      VEND	aiFlashComputerMove
      1  183c				  -	      IFNCONST	aiFlashComputerMove
      2  183c				  -	      ECHO	"Incorrect VEND label", aiFlashComputerMove
      3  183c				  -	      ERR
      4  183c					      ENDIF
      5  183c		       00 a9	   VAREND_aiFlashComputerMove =	TEMPORARY_VAR
    117  183c
    118  183c		       a5 80		      lda	squareToDraw
    119  183e		       30 1f		      bmi	.initial2	; startup - no computer move to show
    120  1840
    121  1840							; "squareToDraw" is the piece that should flash while human waits
    122  1840
    123  1840		       ad 80 02 	      lda	SWCHA
    124  1843		       29 f0		      and	#$F0
    125  1845		       c9 f0		      cmp	#$F0
    126  1847		       f0 08		      beq	.nodir
    127  1849
    128  1849		       a9 01		      lda	#1
    129  184b		       85 8c		      sta	aiFlashDelay
    130  184d		       25 8e		      and	aiFlashPhase
    131  184f		       f0 0e		      beq	.initial
    132  1851
    133  1851		       c6 8c	   .nodir     dec	aiFlashDelay
    134  1853		       d0 0e		      bne	.exit	; don't flash
    135  1855		       a9 28		      lda	#CAP_SPEED*2
    136  1857		       85 8c		      sta	aiFlashDelay
    137  1859
    138  1859		       e6 8e		      inc	aiFlashPhase
    139  185b
    140  185b							; WARNING - local variables will not survive the following call...!
    141  185b		       20 be f0 	      jsr	CopySinglePiece	;@0
    142  185e		       60		      rts
    143  185f
    144  185f				   .initial
    145  185f
    146  185f							;SWAP
      0  185f				   .initial2  PHASE	AI_SelectStartSquare
      1  185f		       a9 02		      lda	#AI_SelectStartSquare
      2  1861		       85 8b		      sta	aiState
    148  1863
    149  1863		       60	   .exit      rts
    150  1864
    151  1864
    152  1864							;---------------------------------------------------------------------------------------------------
    153  1864
      0  1864					      DEF	aiSelectStartSquare
      1  1864				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  1864				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  1864				   aiSelectStartSquare
      4  1864				   TEMPORARY_VAR SET	Overlay
      5  1864				   TEMPORARY_OFFSET SET	0
      6  1864				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  1864				   FUNCTION_NAME SET	aiSelectStartSquare
    155  1864					      SUBROUTINE
    156  1864
      0  1864					      REFER	AiStateMachine
      1  1864					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1864				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1864					      ENDIF
      0  1864					      VEND	aiSelectStartSquare
      1  1864				  -	      IFNCONST	aiSelectStartSquare
      2  1864				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  1864				  -	      ERR
      4  1864					      ENDIF
      5  1864		       00 a9	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    159  1864
      0  1864					      NEXT_RANDOM
      1  1864		       a5 81		      lda	rnd
      2  1866		       4a		      lsr
      3  1867		       90 02		      bcc	.skipEOR
      4  1869		       49 fe		      eor	#RND_EOR_VAL
      5  186b		       85 81	   .skipEOR   sta	rnd
    161  186d
    162  186d		       20 17 f6 	      jsr	moveCursor
    163  1870
    164  1870							; Search the player's movelist for the square, so we can set cursor colour
    165  1870
    166  1870		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
    167  1872		       85 3e		      sta	SET_BANK_RAM	;@2
    168  1874
    169  1874		       a5 88		      lda	cursorX12
    170  1876		       85 85		      sta	fromX12
    171  1878
      0  1878					      ldy@PLY	moveIndex
      1  1878		       ac cf f9 	      ldy	moveIndex
    173  187b		       30 0d		      bmi	.done
    174  187d
    175  187d		       d9 00 f8    .scan      cmp	MoveFrom,y
    176  1880		       f0 03		      beq	.scanned
    177  1882		       88		      dey
    178  1883		       10 f8		      bpl	.scan
    179  1885
      0  1885				   .scanned   lda@PLY	MovePiece,y
      1  1885		       b9 00 f9 	      lda	MovePiece,y
    181  1888		       85 96		      sta	fromPiece
    182  188a
    183  188a		       c6 8a	   .done      dec	ccur	; pulse colour for valid squares
    184  188c		       20 b1 f4 	      jsr	setCursorColours
    185  188f
    186  188f		       98		      tya
    187  1890		       05 4c		      ora	INPT4
    188  1892		       30 04		      bmi	.exit	; illegal square or no button press
    189  1894
      0  1894					      PHASE	AI_StartSquareSelected
      1  1894		       a9 03		      lda	#AI_StartSquareSelected
      2  1896		       85 8b		      sta	aiState
    191  1898
    192  1898		       60	   .exit      rts
    193  1899
    194  1899							;---------------------------------------------------------------------------------------------------
    195  1899
      0  1899					      DEF	setCursorPriority
      1  1899				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  1899				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  1899				   setCursorPriority
      4  1899				   TEMPORARY_VAR SET	Overlay
      5  1899				   TEMPORARY_OFFSET SET	0
      6  1899				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  1899				   FUNCTION_NAME SET	setCursorPriority
    197  1899					      SUBROUTINE
    198  1899
      0  1899					      REFER	moveCursor
      1  1899					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  1899				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  1899					      ENDIF
      0  1899					      VEND	setCursorPriority
      1  1899				  -	      IFNCONST	setCursorPriority
      2  1899				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  1899				  -	      ERR
      4  1899					      ENDIF
      5  1899		       00 aa	   VAREND_setCursorPriority =	TEMPORARY_VAR
    201  1899
    202  1899		       98		      tya
    203  189a		       48		      pha
    204  189b
    205  189b		       a2 04		      ldx	#%100
    206  189d
    207  189d		       a4 88		      ldy	cursorX12
    208  189f		       30 0b		      bmi	.under
    209  18a1
    210  18a1		       a9 d1		      lda	#RAMBANK_BOARD
    211  18a3		       85 3e		      sta	SET_BANK_RAM	;@3
    212  18a5		       b9 79 fc 	      lda	Board,y
    213  18a8		       d0 02		      bne	.under
    214  18aa		       a2 00		      ldx	#0
    215  18ac		       86 4a	   .under     stx	CTRLPF	; UNDER
    216  18ae
    217  18ae		       68		      pla
    218  18af		       a8		      tay
    219  18b0		       60		      rts
    220  18b1
    221  18b1							;---------------------------------------------------------------------------------------------------
    222  18b1
      0  18b1					      DEF	setCursorColours
      1  18b1				   SLOT_setCursorColours SET	_BANK_SLOT
      2  18b1				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  18b1				   setCursorColours
      4  18b1				   TEMPORARY_VAR SET	Overlay
      5  18b1				   TEMPORARY_OFFSET SET	0
      6  18b1				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  18b1				   FUNCTION_NAME SET	setCursorColours
    224  18b1					      SUBROUTINE
    225  18b1
      0  18b1					      REFER	aiSelectStartSquare
      1  18b1					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  18b1				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  18b1					      ENDIF
      0  18b1					      REFER	aiDrawMoves
      1  18b1				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  18b1					      ENDIF
      0  18b1					      REFER	aiUnDrawTargetSquares
      1  18b1				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  18b1					      ENDIF
      0  18b1					      REFER	aiShowMoveCaptures
      1  18b1				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  18b1					      ENDIF
      0  18b1					      REFER	aiSlowFlash
      1  18b1				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  18b1					      ENDIF
      0  18b1					      REFER	aiSelectDestinationSquare
      1  18b1				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  18b1					      ENDIF
      0  18b1					      VEND	setCursorColours
      1  18b1				  -	      IFNCONST	setCursorColours
      2  18b1				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  18b1				  -	      ERR
      4  18b1					      ENDIF
      5  18b1		       00 a9	   VAREND_setCursorColours =	TEMPORARY_VAR
    233  18b1
    234  18b1							; pass y=-1 if move is NOT in the movelist
    235  18b1							; preserve y
    236  18b1
    237  18b1		       a9 40		      lda	#$40
    238  18b3
    239  18b3		       c0 ff		      cpy	#-1
    240  18b5		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    241  18b7
    242  18b7		       a5 8a		      lda	ccur
    243  18b9		       4a		      lsr
    244  18ba		       4a		      lsr
    245  18bb		       4a		      lsr
    246  18bc		       29 03		      and	#3
    247  18be		       18		      clc
    248  18bf		       69 d0		      adc	#$D0	;COLOUR_LINE_1
    249  18c1
    250  18c1		       85 46	   .writeCursorCol sta	COLUP0
    251  18c3		       60		      rts
    252  18c4
    253  18c4
    254  18c4							;---------------------------------------------------------------------------------------------------
    255  18c4
    256  18c4							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    257  18c4							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    258  18c4
      0  18c4					      ALLOCATE	JoyCombined, 16
      0  18c4					      OPTIONAL_PAGEBREAK	"Table", 16
     12  18c4					      LIST	ON
      0  18c4					      DEF	JoyCombined
      1  18c4				   SLOT_JoyCombined SET	_BANK_SLOT
      2  18c4				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  18c4				   JoyCombined
      4  18c4				   TEMPORARY_VAR SET	Overlay
      5  18c4				   TEMPORARY_OFFSET SET	0
      6  18c4				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  18c4				   FUNCTION_NAME SET	JoyCombined
    260  18c4		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    261  18d4
      0  18d4					      ALLOCATE	JoyMoveCursor, 16
      0  18d4					      OPTIONAL_PAGEBREAK	"Table", 16
     12  18d4					      LIST	ON
      0  18d4					      DEF	JoyMoveCursor
      1  18d4				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  18d4				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  18d4				   JoyMoveCursor
      4  18d4				   TEMPORARY_VAR SET	Overlay
      5  18d4				   TEMPORARY_OFFSET SET	0
      6  18d4				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  18d4				   FUNCTION_NAME SET	JoyMoveCursor
    263  18d4		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    264  18e4
    265  18e4
    266  18e4							;---------------------------------------------------------------------------------------------------
    267  18e4
    268  18e4							;---------------------------------------------------------------------------------------------------
    269  18e4
      0  18e4					      DEF	aiDrawMoves
      1  18e4				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  18e4				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  18e4				   aiDrawMoves
      4  18e4				   TEMPORARY_VAR SET	Overlay
      5  18e4				   TEMPORARY_OFFSET SET	0
      6  18e4				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  18e4				   FUNCTION_NAME SET	aiDrawMoves
    271  18e4					      SUBROUTINE
    272  18e4
      0  18e4					      REFER	AiStateMachine
      1  18e4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  18e4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  18e4					      ENDIF
      0  18e4					      VEND	aiDrawMoves
      1  18e4				  -	      IFNCONST	aiDrawMoves
      2  18e4				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  18e4				  -	      ERR
      4  18e4					      ENDIF
      5  18e4		       00 a9	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    275  18e4
    276  18e4		       c6 8a		      dec	ccur
    277  18e6		       20 b1 f4 	      jsr	setCursorColours
    278  18e9
    279  18e9		       c6 89		      dec	mdelay
    280  18eb		       d0 25		      bne	.exit
    281  18ed		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    282  18ef		       85 89		      sta	mdelay	; once triggered, runs always
    283  18f1
    284  18f1		       a5 8d		      lda	aiMoveIndex
    285  18f3		       10 09		      bpl	.valid
    286  18f5
    287  18f5		       a9 89		      lda	#RAMBANK_PLY+1
    288  18f7		       85 3e		      sta	SET_BANK_RAM	;@2
      0  18f9					      lda@PLY	moveIndex
      1  18f9		       ad cf f9 	      lda	moveIndex
    290  18fc		       85 8d		      sta	aiMoveIndex
    291  18fe				   .valid
    292  18fe
    293  18fe		       20 1f f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    294  1901		       a5 8d		      lda	aiMoveIndex
    295  1903		       10 19		      bpl	.unsure	; still drawing in this phase
    296  1905
    297  1905		       a9 14		      lda	#CAP_SPEED
    298  1907		       85 89		      sta	mdelay
    299  1909
    300  1909		       a9 00		      lda	#0
    301  190b		       85 8e		      sta	aiFlashPhase	; controls odd/even exit of flashing
    302  190d
      0  190d					      PHASE	AI_ShowMoveCaptures
      1  190d		       a9 05		      lda	#AI_ShowMoveCaptures
      2  190f		       85 8b		      sta	aiState
    304  1911		       60		      rts
    305  1912
    306  1912				   .exit
    307  1912
    308  1912							; Initial piece selection has happened, but the button hasn't been released yet
    309  1912							; AND we're still in the waiting phase to see if the button was held long enough for move show
    310  1912
    311  1912		       a5 4c		      lda	INPT4
    312  1914		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    313  1916
    314  1916							; Aha! Button released, so we know the selected piece and can start flashing it
    315  1916							; and allowing movement of the selector to a destination square...
    316  1916
    317  1916		       a9 18		      lda	#6*4
    318  1918		       85 8a		      sta	ccur	; bright green square for selection
    319  191a
      0  191a					      PHASE	AI_SelectDestinationSquare
      1  191a		       a9 08		      lda	#AI_SelectDestinationSquare
      2  191c		       85 8b		      sta	aiState
    321  191e
    322  191e		       60	   .unsure    rts
    323  191f
    324  191f
    325  191f							;---------------------------------------------------------------------------------------------------
    326  191f
      0  191f					      DEF	showMoveOptions
      1  191f				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  191f				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  191f				   showMoveOptions
      4  191f				   TEMPORARY_VAR SET	Overlay
      5  191f				   TEMPORARY_OFFSET SET	0
      6  191f				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  191f				   FUNCTION_NAME SET	showMoveOptions
    328  191f					      SUBROUTINE
    329  191f
      0  191f					      REFER	aiDrawMoves
      1  191f					      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  191f				   TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  191f					      ENDIF
      0  191f					      REFER	aiUnDrawTargetSquares
      1  191f				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  191f				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  191f					      ENDIF
    332  191f
      0  191f					      VAR	__saveIdx, 1
      1  191f		       00 a9	   __saveIdx  =	TEMPORARY_VAR
      2  191f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  191f
      4  191f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  191f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  191f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  191f					      ENDIF
      8  191f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  191f				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  191f				  -	      ERR
     11  191f					      ENDIF
     12  191f					      LIST	ON
      0  191f					      VAR	__piece, 1
      1  191f		       00 aa	   __piece    =	TEMPORARY_VAR
      2  191f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  191f
      4  191f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  191f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  191f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  191f					      ENDIF
      8  191f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  191f				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  191f				  -	      ERR
     11  191f					      ENDIF
     12  191f					      LIST	ON
    335  191f
      0  191f					      VEND	showMoveOptions
      1  191f				  -	      IFNCONST	showMoveOptions
      2  191f				  -	      ECHO	"Incorrect VEND label", showMoveOptions
      3  191f				  -	      ERR
      4  191f					      ENDIF
      5  191f		       00 ab	   VAREND_showMoveOptions =	TEMPORARY_VAR
    337  191f
    338  191f							; place a marker on the board for any square matching the piece
    339  191f							; EXCEPT for squares which are occupied (we'll flash those later)
    340  191f
    341  191f		       a6 8d	   .next      ldx	aiMoveIndex
    342  1921		       86 a9		      stx	__saveIdx
    343  1923		       30 4c		      bmi	.skip
    344  1925
    345  1925		       ad 84 02 	      lda	INTIM
    346  1928		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    347  192a		       90 45		      bcc	.skip
    348  192c
    349  192c		       c6 8d		      dec	aiMoveIndex
    350  192e
    351  192e		       a9 89		      lda	#RAMBANK_PLY+1
    352  1930		       85 3e		      sta	SET_BANK_RAM	;@2
    353  1932
      0  1932					      lda@PLY	MoveFrom,x
      1  1932		       bd 00 f8 	      lda	MoveFrom,x
    355  1935		       c5 85		      cmp	fromX12
    356  1937		       d0 e6		      bne	.next
    357  1939
      0  1939					      lda@PLY	MoveTo,x
      1  1939		       bd 64 f8 	      lda	MoveTo,x
    359  193c		       85 80		      sta	squareToDraw
    360  193e
      0  193e					      lda@PLY	MovePiece,x
      1  193e		       bd 00 f9 	      lda	MovePiece,x
    362  1941		       85 aa		      sta	__piece
    363  1943
    364  1943							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    365  1943							; TODO this could/will fail on sorted lists. MMh.
    366  1943
    367  1943		       ca		      dex
    368  1944		       30 16		      bmi	.prom
    369  1946
      0  1946					      lda@PLY	MoveTo,x
      1  1946		       bd 64 f8 	      lda	MoveTo,x
    371  1949		       c5 80		      cmp	squareToDraw
    372  194b		       d0 0f		      bne	.prom
    373  194d
      0  194d					      lda@PLY	MovePiece,x
      1  194d		       bd 00 f9 	      lda	MovePiece,x
    375  1950		       45 aa		      eor	__piece
    376  1952		       29 0f		      and	#PIECE_MASK
    377  1954		       f0 06		      beq	.prom	; same piece type so not a promote
    378  1956
    379  1956		       c6 8d		      dec	aiMoveIndex
    380  1958		       c6 8d		      dec	aiMoveIndex
    381  195a		       c6 8d		      dec	aiMoveIndex
    382  195c				   .prom
    383  195c
    384  195c		       a4 80		      ldy	squareToDraw
    385  195e
    386  195e		       a9 d1		      lda	#RAMBANK_BOARD
    387  1960		       85 3e		      sta	SET_BANK_RAM	;@3
    388  1962		       b9 79 fc 	      lda	Board,y
    389  1965		       29 0f		      and	#PIECE_MASK
    390  1967		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    391  1969
    392  1969
    393  1969							;lda INTIM
    394  1969							;cmp #SPEEDOF_COPYSINGLEPIECE
    395  1969							;bcc .skip
    396  1969
    397  1969							;lda aiMoveIndex
    398  1969							;sta __saveIdx
    399  1969
    400  1969							; Draw the marker..."?
    401  1969							; WARNING - local variables will not survive the following call...!
    402  1969
    403  1969		       a0 1c		      ldy	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    404  196b		       20 76 f5 	      jsr	CopySetupForMarker	;@this
    405  196e		       4c c5 f0 	      jmp	InterceptMarkerCopy	;@0
    406  1971
    407  1971
    408  1971
    409  1971		       a5 a9	   .skip      lda	__saveIdx
    410  1973		       85 8d		      sta	aiMoveIndex
    411  1975		       60		      rts
    412  1976
    413  1976
    414  1976							;---------------------------------------------------------------------------------------------------
    415  1976
      0  1976					      DEF	CopySetupForMarker
      1  1976				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  1976				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  1976				   CopySetupForMarker
      4  1976				   TEMPORARY_VAR SET	Overlay
      5  1976				   TEMPORARY_OFFSET SET	0
      6  1976				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  1976				   FUNCTION_NAME SET	CopySetupForMarker
    417  1976					      SUBROUTINE
    418  1976
      0  1976					      REFER	showMoveOptions
      1  1976					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  1976				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  1976					      ENDIF
      0  1976					      REFER	showPromoteOptions
      1  1976				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  1976				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  1976					      ENDIF
    421  1976
      0  1976					      VAR	__pieceColour2b, 1
      1  1976		       00 ab	   __pieceColour2b =	TEMPORARY_VAR
      2  1976				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1976
      4  1976				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1976				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1976				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1976					      ENDIF
      8  1976				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1976				  -	      ECHO	"Temporary Variable", __pieceColour2b, "overflow!"
     10  1976				  -	      ERR
     11  1976					      ENDIF
     12  1976					      LIST	ON
      0  1976					      VAR	__tmpb, 1
      1  1976		       00 ac	   __tmpb     =	TEMPORARY_VAR
      2  1976				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1976
      4  1976				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1976				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1976				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1976					      ENDIF
      8  1976				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1976				  -	      ECHO	"Temporary Variable", __tmpb, "overflow!"
     10  1976				  -	      ERR
     11  1976					      ENDIF
     12  1976					      LIST	ON
      0  1976					      VAR	__shiftxb, 1
      1  1976		       00 ad	   __shiftxb  =	TEMPORARY_VAR
      2  1976				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1976
      4  1976				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1976				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1976				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1976					      ENDIF
      8  1976				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1976				  -	      ECHO	"Temporary Variable", __shiftxb, "overflow!"
     10  1976				  -	      ERR
     11  1976					      ENDIF
     12  1976					      LIST	ON
    425  1976
      0  1976					      VEND	CopySetupForMarker
      1  1976				  -	      IFNCONST	CopySetupForMarker
      2  1976				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  1976				  -	      ERR
      4  1976					      ENDIF
      5  1976		       00 ae	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    427  1976
    428  1976
    429  1976							; y = base shape
    430  1976							; figure colouration of square
    431  1976
    432  1976		       a5 80		      lda	squareToDraw
    433  1978
    434  1978		       a2 0a		      ldx	#10
    435  197a		       38		      sec
    436  197b		       e9 0a	   .sub10     sbc	#10
    437  197d		       ca		      dex
    438  197e		       b0 fb		      bcs	.sub10
    439  1980		       69 08		      adc	#8
    440  1982		       85 ad		      sta	__shiftxb
    441  1984		       86 ac		      stx	__tmpb
    442  1986		       65 ac		      adc	__tmpb
    443  1988
    444  1988
    445  1988		       29 01		      and	#1
    446  198a							;eor #1
    447  198a		       f0 02		      beq	.white
    448  198c		       a9 24		      lda	#36
    449  198e				   .white
    450  198e		       85 ab		      sta	__pieceColour2b	; actually SQUARE black/white
    451  1990
    452  1990		       a5 95		      lda	sideToMove
    453  1992		       0a		      asl
    454  1993		       90 02		      bcc	.blackAdjust
    455  1995		       09 10		      ora	#16	; switch white pieces
    456  1997		       4a	   .blackAdjust lsr
    457  1998		       29 0f		      and	#%1111
    458  199a		       aa		      tax
    459  199b
    460  199b		       a5 ad		      lda	__shiftxb
    461  199d		       29 03		      and	#3	; shift position in P
    462  199f		       85 ad		      sta	__shiftxb
    463  19a1
    464  19a1		       98		      tya
    465  19a2		       18		      clc
    466  19a3		       65 ad		      adc	__shiftxb
    467  19a5		       18		      clc
    468  19a6		       65 ab		      adc	__pieceColour2b
    469  19a8		       a8		      tay
    470  19a9		       60		      rts
    471  19aa
    472  19aa
    473  19aa							;---------------------------------------------------------------------------------------------------
    474  19aa
      0  19aa					      DEF	aiUnDrawTargetSquares
      1  19aa				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  19aa				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  19aa				   aiUnDrawTargetSquares
      4  19aa				   TEMPORARY_VAR SET	Overlay
      5  19aa				   TEMPORARY_OFFSET SET	0
      6  19aa				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  19aa				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    476  19aa					      SUBROUTINE
    477  19aa
      0  19aa					      REFER	AiStateMachine
      1  19aa					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  19aa				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  19aa					      ENDIF
      0  19aa					      VEND	aiUnDrawTargetSquares
      1  19aa				  -	      IFNCONST	aiUnDrawTargetSquares
      2  19aa				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  19aa				  -	      ERR
      4  19aa					      ENDIF
      5  19aa		       00 a9	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    480  19aa
    481  19aa
    482  19aa		       c6 8a		      dec	ccur
    483  19ac		       20 b1 f4 	      jsr	setCursorColours
    484  19af
    485  19af		       c6 89		      dec	mdelay
    486  19b1		       d0 1c		      bne	.exit
    487  19b3		       a9 01		      lda	#1
    488  19b5		       85 89		      sta	mdelay	; once triggered, runs always
    489  19b7
    490  19b7		       a5 8d		      lda	aiMoveIndex
    491  19b9		       10 09		      bpl	.valid
    492  19bb
    493  19bb		       a9 89		      lda	#RAMBANK_PLY+1
    494  19bd		       85 3e		      sta	SET_BANK_RAM	;@2
      0  19bf					      lda@PLY	moveIndex
      1  19bf		       ad cf f9 	      lda	moveIndex
    496  19c2		       85 8d		      sta	aiMoveIndex
    497  19c4				   .valid
    498  19c4
    499  19c4		       20 1f f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    500  19c7		       a5 8d		      lda	aiMoveIndex
    501  19c9		       10 04		      bpl	.exit	; still drawing in this phase
    502  19cb
      0  19cb					      PHASE	AI_SelectStartSquare
      1  19cb		       a9 02		      lda	#AI_SelectStartSquare
      2  19cd		       85 8b		      sta	aiState
    504  19cf
    505  19cf		       60	   .exit      rts
    506  19d0
    507  19d0
    508  19d0							;---------------------------------------------------------------------------------------------------
    509  19d0
    510  19d0
      0  19d0					      DEF	aiShowMoveCaptures
      1  19d0				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  19d0				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  19d0				   aiShowMoveCaptures
      4  19d0				   TEMPORARY_VAR SET	Overlay
      5  19d0				   TEMPORARY_OFFSET SET	0
      6  19d0				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  19d0				   FUNCTION_NAME SET	aiShowMoveCaptures
    512  19d0					      SUBROUTINE
    513  19d0
      0  19d0					      REFER	AiStateMachine
      1  19d0					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  19d0				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  19d0					      ENDIF
      0  19d0					      VEND	aiShowMoveCaptures
      1  19d0				  -	      IFNCONST	aiShowMoveCaptures
      2  19d0				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  19d0				  -	      ERR
      4  19d0					      ENDIF
      5  19d0		       00 a9	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    516  19d0
    517  19d0							; draw/undraw ALL captured pieces
    518  19d0							; we should do this an even number of times so that pieces don't disappEOR
    519  19d0
    520  19d0		       c6 8a		      dec	ccur
    521  19d2		       20 b1 f4 	      jsr	setCursorColours
    522  19d5
    523  19d5		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    524  19d7
    525  19d7		       a5 8d		      lda	aiMoveIndex
    526  19d9		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    527  19db		       a9 89		      lda	#RAMBANK_PLY+1
    528  19dd		       85 3e		      sta	SET_BANK_RAM	;@2
      0  19df					      lda@PLY	moveIndex
      1  19df		       ad cf f9 	      lda	moveIndex
    530  19e2		       85 8d		      sta	aiMoveIndex
    531  19e4				   .valid
    532  19e4
    533  19e4							;lda #BANK_showMoveCaptures
    534  19e4							;sta SET_BANK;@0
    535  19e4
    536  19e4		       20 d3 f2 	      jsr	showMoveCaptures	;@0
    537  19e7		       a5 8d		      lda	aiMoveIndex
    538  19e9		       10 06		      bpl	.exit
    539  19eb
    540  19eb		       e6 8e		      inc	aiFlashPhase
    541  19ed
      0  19ed					      PHASE	AI_SlowFlash
      1  19ed		       a9 06		      lda	#AI_SlowFlash
      2  19ef		       85 8b		      sta	aiState
    543  19f1
    544  19f1		       60	   .exit      rts
    545  19f2
    546  19f2
    547  19f2							;---------------------------------------------------------------------------------------------------
    548  19f2
      0  19f2					      DEF	aiSlowFlash
      1  19f2				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  19f2				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  19f2				   aiSlowFlash
      4  19f2				   TEMPORARY_VAR SET	Overlay
      5  19f2				   TEMPORARY_OFFSET SET	0
      6  19f2				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  19f2				   FUNCTION_NAME SET	aiSlowFlash
    550  19f2					      SUBROUTINE
    551  19f2
      0  19f2					      REFER	AiStateMachine
      1  19f2					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  19f2				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  19f2					      ENDIF
      0  19f2					      VEND	aiSlowFlash
      1  19f2				  -	      IFNCONST	aiSlowFlash
      2  19f2				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  19f2				  -	      ERR
      4  19f2					      ENDIF
      5  19f2		       00 a9	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    554  19f2
    555  19f2							; Joystick button is held down, so we're displaying the available moves
    556  19f2							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    557  19f2
    558  19f2		       c6 8a		      dec	ccur
    559  19f4		       20 b1 f4 	      jsr	setCursorColours
    560  19f7
    561  19f7		       a5 8e		      lda	aiFlashPhase
    562  19f9		       29 01		      and	#1
    563  19fb		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    564  19fd
    565  19fd		       a5 4c		      lda	INPT4
    566  19ff		       30 0d		      bmi	.butpress	; exit on button release
    567  1a01
    568  1a01				   .notEven
    569  1a01
    570  1a01							; Wait for delay to expire then back and flash 'em again
    571  1a01
    572  1a01		       c6 89		      dec	mdelay
    573  1a03		       10 08		      bpl	.slowWait
    574  1a05
    575  1a05		       a9 14		      lda	#CAP_SPEED
    576  1a07		       85 89		      sta	mdelay
    577  1a09
      0  1a09					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  1a09		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1a0b		       85 8b		      sta	aiState
    579  1a0d
    580  1a0d		       60	   .slowWait  rts
    581  1a0e
    582  1a0e
    583  1a0e		       a9 01	   .butpress  lda	#1
    584  1a10		       85 89		      sta	mdelay
    585  1a12
      0  1a12					      PHASE	AI_UnDrawTargetSquares
      1  1a12		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  1a14		       85 8b		      sta	aiState
    587  1a16		       60		      rts
    588  1a17
    589  1a17
    590  1a17							;---------------------------------------------------------------------------------------------------
    591  1a17
      0  1a17					      DEF	moveCursor
      1  1a17				   SLOT_moveCursor SET	_BANK_SLOT
      2  1a17				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  1a17				   moveCursor
      4  1a17				   TEMPORARY_VAR SET	Overlay
      5  1a17				   TEMPORARY_OFFSET SET	0
      6  1a17				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  1a17				   FUNCTION_NAME SET	moveCursor
    593  1a17					      SUBROUTINE
    594  1a17
      0  1a17					      REFER	aiSelectStartSquare
      1  1a17					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  1a17				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  1a17					      ENDIF
      0  1a17					      REFER	aiSelectDestinationSquare
      1  1a17				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  1a17				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  1a17					      ENDIF
    597  1a17
      0  1a17					      VAR	__newCursor, 1
      1  1a17		       00 a9	   __newCursor =	TEMPORARY_VAR
      2  1a17				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1a17
      4  1a17				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1a17				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1a17				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1a17					      ENDIF
      8  1a17				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1a17				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  1a17				  -	      ERR
     11  1a17					      ENDIF
     12  1a17					      LIST	ON
    599  1a17
      0  1a17					      VEND	moveCursor
      1  1a17				  -	      IFNCONST	moveCursor
      2  1a17				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  1a17				  -	      ERR
      4  1a17					      ENDIF
      5  1a17		       00 aa	   VAREND_moveCursor =	TEMPORARY_VAR
    601  1a17
    602  1a17							; Part (a) move cursor around the board waiting for joystick press
    603  1a17
    604  1a17		       a2 00		      ldx	#0	; delay
    605  1a19
    606  1a19		       ad 80 02 	      lda	SWCHA
    607  1a1c		       4a		      lsr
    608  1a1d		       4a		      lsr
    609  1a1e		       4a		      lsr
    610  1a1f		       4a		      lsr
    611  1a20		       a8		      tay
    612  1a21
    613  1a21		       c9 0f		      cmp	#15
    614  1a23		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
    615  1a25
    616  1a25		       c6 89		      dec	mdelay
    617  1a27		       10 1f		      bpl	.delaym
    618  1a29
    619  1a29		       18		      clc
    620  1a2a		       a5 88		      lda	cursorX12
    621  1a2c		       79 d4 f4 	      adc	JoyMoveCursor,y
    622  1a2f		       85 a9		      sta	__newCursor
    623  1a31		       a8		      tay
    624  1a32
    625  1a32		       a9 d1		      lda	#RAMBANK_BOARD
    626  1a34		       85 3e		      sta	SET_BANK_RAM	;@3
    627  1a36		       b9 15 fc 	      lda	ValidSquare,y
    628  1a39		       c9 ff		      cmp	#-1
    629  1a3b		       f0 04		      beq	.invalid
    630  1a3d		       a5 a9		      lda	__newCursor
    631  1a3f		       85 88		      sta	cursorX12
    632  1a41				   .invalid
    633  1a41
    634  1a41		       a2 10		      ldx	#CURSOR_MOVE_SPEED
    635  1a43		       86 89	   .cursor    stx	mdelay
    636  1a45		       20 99 f4 	      jsr	setCursorPriority
    637  1a48		       60	   .delaym    rts
    638  1a49
    639  1a49
    640  1a49							;---------------------------------------------------------------------------------------------------
    641  1a49
      0  1a49					      DEF	aiSelectDestinationSquare
      1  1a49				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  1a49				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  1a49				   aiSelectDestinationSquare
      4  1a49				   TEMPORARY_VAR SET	Overlay
      5  1a49				   TEMPORARY_OFFSET SET	0
      6  1a49				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  1a49				   FUNCTION_NAME SET	aiSelectDestinationSquare
    643  1a49					      SUBROUTINE
    644  1a49
      0  1a49					      REFER	AiStateMachine
      1  1a49					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1a49				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1a49					      ENDIF
      0  1a49					      VEND	aiSelectDestinationSquare
      1  1a49				  -	      IFNCONST	aiSelectDestinationSquare
      2  1a49				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  1a49				  -	      ERR
      4  1a49					      ENDIF
      5  1a49		       00 a9	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    647  1a49
    648  1a49							; Piece is selected and now we're looking for a button press on a destination square
    649  1a49							; we flash the piece on-and-off while we're doing that
    650  1a49							; Flash the selected piece
    651  1a49
    652  1a49		       ad 84 02 	      lda	INTIM
    653  1a4c		       c9 28		      cmp	#ONCEPERFRAME
    654  1a4e		       90 0e		      bcc	.exit
    655  1a50
    656  1a50
    657  1a50		       c6 8c		      dec	aiFlashDelay
    658  1a52		       d0 0a		      bne	.exit	; don't flash
    659  1a54		       a9 14		      lda	#CAP_SPEED
    660  1a56		       85 8c		      sta	aiFlashDelay
    661  1a58
    662  1a58		       e6 8e		      inc	aiFlashPhase
    663  1a5a
    664  1a5a							; WARNING - local variables will not survive the following call...!
    665  1a5a		       20 be f0 	      jsr	CopySinglePiece	;@0
    666  1a5d		       60		      rts
    667  1a5e
    668  1a5e				   .exit
    669  1a5e		       20 17 f6 	      jsr	moveCursor
    670  1a61
    671  1a61		       ad 84 02 	      lda	INTIM
    672  1a64		       c9 14		      cmp	#20
    673  1a66		       90 39		      bcc	.noButton
    674  1a68
    675  1a68
    676  1a68		       a4 88		      ldy	cursorX12
    677  1a6a		       84 86		      sty	toX12
    678  1a6c
      0  1a6c					      CALL	GetPiece	;@3
      1  1a6c				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1a6c				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1a6c				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1a6c				  -	      ERR
      5  1a6c					      ENDIF
      6  1a6c		       a9 d9		      lda	#BANK_GetPiece
      7  1a6e		       85 3f		      sta	SET_BANK
      8  1a70		       20 00 fc 	      jsr	GetPiece
    680  1a73		       20 b1 f4 	      jsr	setCursorColours
    681  1a76
    682  1a76
    683  1a76							; y = valid square
    684  1a76
    685  1a76		       a5 4c		      lda	INPT4
    686  1a78		       30 27		      bmi	.noButton
    687  1a7a
    688  1a7a		       a5 86		      lda	toX12
    689  1a7c		       c5 85		      cmp	fromX12
    690  1a7e		       f0 0d		      beq	.cancel
    691  1a80
    692  1a80		       c0 ff		      cpy	#-1
    693  1a82		       f0 1d		      beq	.noButton	; not a valid square
    694  1a84
    695  1a84		       a5 8e		      lda	aiFlashPhase
    696  1a86		       29 01		      and	#1
    697  1a88		       f0 13		      beq	.done
    698  1a8a		       85 8c		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    699  1a8c		       60		      rts
    700  1a8d
    701  1a8d				   .cancel
    702  1a8d
    703  1a8d		       a5 8e		      lda	aiFlashPhase
    704  1a8f		       29 01		      and	#1
    705  1a91		       f0 05		      beq	.doCancel
    706  1a93
    707  1a93							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    708  1a93
    709  1a93		       a9 01		      lda	#1
    710  1a95		       85 8c		      sta	aiFlashDelay
    711  1a97		       60		      rts
    712  1a98
    713  1a98
      0  1a98				   .doCancel  PHASE	AI_ReselectDebounce
      1  1a98		       a9 0a		      lda	#AI_ReselectDebounce
      2  1a9a		       85 8b		      sta	aiState
    715  1a9c		       60		      rts
    716  1a9d
      0  1a9d				   .done      PHASE	AI_Quiescent	; destination selected!
      1  1a9d		       a9 09		      lda	#AI_Quiescent
      2  1a9f		       85 8b		      sta	aiState
    718  1aa1		       60	   .noButton  rts
    719  1aa2
    720  1aa2
    721  1aa2
    722  1aa2
    723  1aa2
    724  1aa2							;---------------------------------------------------------------------------------------------------
    725  1aa2
      0  1aa2					      DEF	aiRollPromotionPiece
      1  1aa2				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  1aa2				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  1aa2				   aiRollPromotionPiece
      4  1aa2				   TEMPORARY_VAR SET	Overlay
      5  1aa2				   TEMPORARY_OFFSET SET	0
      6  1aa2				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  1aa2				   FUNCTION_NAME SET	aiRollPromotionPiece
    727  1aa2					      SUBROUTINE
    728  1aa2
      0  1aa2					      REFER	AiStateMachine
      1  1aa2					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1aa2				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1aa2					      ENDIF
      0  1aa2					      VEND	aiRollPromotionPiece
      1  1aa2				  -	      IFNCONST	aiRollPromotionPiece
      2  1aa2				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  1aa2				  -	      ERR
      4  1aa2					      ENDIF
      5  1aa2		       00 a9	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    731  1aa2
    732  1aa2							; Flash the '?' and wait for an UDLR move
    733  1aa2
    734  1aa2		       ad 84 02 	      lda	INTIM
    735  1aa5		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    736  1aa7		       90 2b		      bcc	.exit
    737  1aa9
    738  1aa9		       ad 80 02 	      lda	SWCHA
    739  1aac		       29 f0		      and	#$F0
    740  1aae		       c9 f0		      cmp	#$F0
    741  1ab0		       f0 0a		      beq	.nojoy
    742  1ab2
    743  1ab2		       a9 00		      lda	#0
    744  1ab4		       85 8c		      sta	aiFlashDelay
    745  1ab6
    746  1ab6		       a5 8e		      lda	aiFlashPhase
    747  1ab8		       29 01		      and	#1
    748  1aba		       f0 19		      beq	.even
    749  1abc
    750  1abc		       a5 8c	   .nojoy     lda	aiFlashDelay
    751  1abe		       f0 03		      beq	.do
    752  1ac0		       c6 8c		      dec	aiFlashDelay
    753  1ac2		       60		      rts
    754  1ac3
    755  1ac3				   .do
    756  1ac3		       a9 1e		      lda	#30
    757  1ac5		       85 8c		      sta	aiFlashDelay	; speed of "?" flashing
    758  1ac7
    759  1ac7
    760  1ac7		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    761  1ac9		       a5 95		      lda	sideToMove
    762  1acb		       10 02		      bpl	.wtm
    763  1acd		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    764  1acf				   .wtm
    765  1acf		       20 e9 f6 	      jsr	showPromoteOptions	; draw the "?"
    766  1ad2
    767  1ad2		       e6 8e		      inc	aiFlashPhase
    768  1ad4
    769  1ad4		       60	   .exit      rts
    770  1ad5
    771  1ad5
    772  1ad5		       a9 03	   .even      lda	#3	; QUEEN
    773  1ad7		       85 96		      sta	fromPiece	; cycles as index to NBRQ
    774  1ad9
    775  1ad9							;inc aiFlashPhase
    776  1ad9
    777  1ad9		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    778  1adb		       a5 95		      lda	sideToMove
    779  1add		       10 02		      bpl	.blackStuff
    780  1adf		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    781  1ae1				   .blackStuff
    782  1ae1
    783  1ae1		       20 e9 f6 	      jsr	showPromoteOptions	; draw the initial Q
    784  1ae4
      0  1ae4					      PHASE	AI_ChooseDebounce
      1  1ae4		       a9 22		      lda	#AI_ChooseDebounce
      2  1ae6		       85 8b		      sta	aiState
    786  1ae8		       60		      rts
    787  1ae9
    788  1ae9
    789  1ae9							;---------------------------------------------------------------------------------------------------
    790  1ae9
      0  1ae9					      DEF	showPromoteOptions
      1  1ae9				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  1ae9				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  1ae9				   showPromoteOptions
      4  1ae9				   TEMPORARY_VAR SET	Overlay
      5  1ae9				   TEMPORARY_OFFSET SET	0
      6  1ae9				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  1ae9				   FUNCTION_NAME SET	showPromoteOptions
    792  1ae9					      SUBROUTINE
    793  1ae9
      0  1ae9					      REFER	aiRollPromotionPiece	;✅
      1  1ae9					      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  1ae9				   TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  1ae9					      ENDIF
      0  1ae9					      REFER	aiChoosePromotePiece	;✅
      1  1ae9				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  1ae9				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  1ae9					      ENDIF
      0  1ae9					      VEND	showPromoteOptions
      1  1ae9				  -	      IFNCONST	showPromoteOptions
      2  1ae9				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  1ae9				  -	      ERR
      4  1ae9					      ENDIF
      5  1ae9		       00 a9	   VAREND_showPromoteOptions =	TEMPORARY_VAR
    797  1ae9
    798  1ae9							; X = character shape # (?/N/B/R/Q)
    799  1ae9
    800  1ae9		       a4 86		      ldy	toX12
    801  1aeb		       84 80		      sty	squareToDraw
    802  1aed
    803  1aed		       8a		      txa
    804  1aee		       a8		      tay
    805  1aef
    806  1aef		       20 76 f5 	      jsr	CopySetupForMarker	;@this
    807  1af2		       4c c5 f0 	      jmp	InterceptMarkerCopy	;@0
    808  1af5
    809  1af5
    810  1af5							;---------------------------------------------------------------------------------------------------
    811  1af5
      0  1af5					      DEF	aiChoosePromotePiece
      1  1af5				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  1af5				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  1af5				   aiChoosePromotePiece
      4  1af5				   TEMPORARY_VAR SET	Overlay
      5  1af5				   TEMPORARY_OFFSET SET	0
      6  1af5				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  1af5				   FUNCTION_NAME SET	aiChoosePromotePiece
    813  1af5					      SUBROUTINE
    814  1af5
      0  1af5					      REFER	AiStateMachine
      1  1af5					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1af5				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1af5					      ENDIF
      0  1af5					      VEND	aiChoosePromotePiece
      1  1af5				  -	      IFNCONST	aiChoosePromotePiece
      2  1af5				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  1af5				  -	      ERR
      4  1af5					      ENDIF
      5  1af5		       00 a9	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
    817  1af5
    818  1af5							; Question-mark phase has exited via joystick direction
    819  1af5							; Now we cycle through the selectable pieces
    820  1af5
    821  1af5		       ad 84 02 	      lda	INTIM
    822  1af8		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    823  1afa		       90 4e		      bcc	.exit
    824  1afc
    825  1afc		       a5 4c		      lda	INPT4
    826  1afe		       30 0a		      bmi	.nobut	; no press
    827  1b00
    828  1b00							; button pressed but make sure phase is correct for exit
    829  1b00
    830  1b00		       a9 01		      lda	#1
    831  1b02		       85 8c		      sta	aiFlashDelay	; force quick rehash to this if phase incorrect
    832  1b04
    833  1b04		       a5 8e		      lda	aiFlashPhase
    834  1b06		       29 01		      and	#1
    835  1b08		       f0 41		      beq	.chosen	; button pressed --> selection made
    836  1b0a				   .nobut
    837  1b0a
    838  1b0a		       ad 80 02 	      lda	SWCHA
    839  1b0d		       29 f0		      and	#$F0
    840  1b0f		       c9 f0		      cmp	#$F0
    841  1b11		       f0 04		      beq	.nodir	; no direction pressed
    842  1b13
    843  1b13
    844  1b13		       a9 01		      lda	#1
    845  1b15		       85 8c		      sta	aiFlashDelay
    846  1b17
    847  1b17
    848  1b17		       c6 8c	   .nodir     dec	aiFlashDelay
    849  1b19		       d0 2f		      bne	.exit
    850  1b1b
    851  1b1b		       a9 1e		      lda	#30
    852  1b1d		       85 8c		      sta	aiFlashDelay
    853  1b1f
    854  1b1f		       a5 8e		      lda	aiFlashPhase
    855  1b21		       4a		      lsr
    856  1b22		       b0 1c		      bcs	.odd	; must wait until piece undrawn
    857  1b24
    858  1b24		       ad 80 02 	      lda	SWCHA
    859  1b27		       29 f0		      and	#$F0
    860  1b29		       c9 f0		      cmp	#$F0
    861  1b2b		       f0 13		      beq	.odd	; no direction pressed
    862  1b2d
    863  1b2d		       4a		      lsr
    864  1b2e		       4a		      lsr
    865  1b2f		       4a		      lsr
    866  1b30		       4a		      lsr
    867  1b31		       a8		      tay
    868  1b32
    869  1b32
    870  1b32							; cycle to the next promotable piece (N/B/R/Q)
    871  1b32							; TODO; use joy table for mod instead of just incrementing all the time
    872  1b32
    873  1b32		       18		      clc
    874  1b33		       a5 96		      lda	fromPiece
    875  1b35		       79 c4 f4 	      adc	JoyCombined,y
    876  1b38		       29 03		      and	#3
    877  1b3a		       85 96		      sta	fromPiece
    878  1b3c
      0  1b3c					      PHASE	AI_ChooseDebounce	; after draw, wait for release
      1  1b3c		       a9 22		      lda	#AI_ChooseDebounce
      2  1b3e		       85 8b		      sta	aiState
    880  1b40
    881  1b40				   .odd
    882  1b40
    883  1b40				   .force
    884  1b40		       e6 8e		      inc	aiFlashPhase	; on/off toggle
    885  1b42
    886  1b42		       a4 96		      ldy	fromPiece
    887  1b44		       be 6a f7 	      ldx	promotePiece,y
    888  1b47		       20 e9 f6 	      jsr	showPromoteOptions	;@this
    889  1b4a
    890  1b4a		       60	   .exit      rts
    891  1b4b
    892  1b4b
    893  1b4b
    894  1b4b
    895  1b4b
    896  1b4b
    897  1b4b				   .chosen
    898  1b4b		       a5 96		      lda	fromPiece
    899  1b4d		       29 0f		      and	#PIECE_MASK
    900  1b4f		       aa		      tax
    901  1b50
    902  1b50		       bd 6e f7 	      lda	promoteType,x
    903  1b53		       85 96		      sta	fromPiece
    904  1b55
    905  1b55		       a4 86		      ldy	toX12
    906  1b57		       a9 d1		      lda	#RAMBANK_BOARD
    907  1b59		       85 3e		      sta	SET_BANK_RAM	;@3
    908  1b5b		       b9 79 fc 	      lda	Board,y
    909  1b5e		       29 0f		      and	#PIECE_MASK
    910  1b60		       f0 03		      beq	.nothing
    911  1b62
    912  1b62		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
    913  1b65
      0  1b65				   .nothing   PHASE	AI_MoveIsSelected
      1  1b65		       a9 14		      lda	#AI_MoveIsSelected
      2  1b67		       85 8b		      sta	aiState
    915  1b69		       60		      rts
    916  1b6a
      0  1b6a					      ALLOCATE	promotePiece, 4
      0  1b6a					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1b6a					      LIST	ON
      0  1b6a					      DEF	promotePiece
      1  1b6a				   SLOT_promotePiece SET	_BANK_SLOT
      2  1b6a				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  1b6a				   promotePiece
      4  1b6a				   TEMPORARY_VAR SET	Overlay
      5  1b6a				   TEMPORARY_OFFSET SET	0
      6  1b6a				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  1b6a				   FUNCTION_NAME SET	promotePiece
    918  1b6a		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    919  1b6b		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    920  1b6c		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    921  1b6d		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    922  1b6e
      0  1b6e					      ALLOCATE	promoteType,4
      0  1b6e					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1b6e					      LIST	ON
      0  1b6e					      DEF	promoteType
      1  1b6e				   SLOT_promoteType SET	_BANK_SLOT
      2  1b6e				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  1b6e				   promoteType
      4  1b6e				   TEMPORARY_VAR SET	Overlay
      5  1b6e				   TEMPORARY_OFFSET SET	0
      6  1b6e				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  1b6e				   FUNCTION_NAME SET	promoteType
    924  1b6e		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    925  1b72
    926  1b72
    927  1b72							;---------------------------------------------------------------------------------------------------
    928  1b72
      0  1b72					      DEF	aiMarchA2
      1  1b72				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  1b72				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  1b72				   aiMarchA2
      4  1b72				   TEMPORARY_VAR SET	Overlay
      5  1b72				   TEMPORARY_OFFSET SET	0
      6  1b72				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  1b72				   FUNCTION_NAME SET	aiMarchA2
    930  1b72					      SUBROUTINE
    931  1b72
      0  1b72					      REFER	AiStateMachine
      1  1b72					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b72				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b72					      ENDIF
      0  1b72					      VEND	aiMarchA2
      1  1b72				  -	      IFNCONST	aiMarchA2
      2  1b72				  -	      ECHO	"Incorrect VEND label", aiMarchA2
      3  1b72				  -	      ERR
      4  1b72					      ENDIF
      5  1b72		       00 a9	   VAREND_aiMarchA2 =	TEMPORARY_VAR
    934  1b72
    935  1b72							; erase object in new sqare --> blank
    936  1b72
    937  1b72		       a4 85		      ldy	fromX12
    938  1b74		       84 80		      sty	squareToDraw
    939  1b76
    940  1b76		       a9 d1		      lda	#RAMBANK_BOARD
    941  1b78		       85 3e		      sta	SET_BANK_RAM	;@3
    942  1b7a		       b9 79 fc 	      lda	Board,y
    943  1b7d		       f0 03		      beq	.skipbl
    944  1b7f
    945  1b7f							; WARNING - local variables will not survive the following call...!
    946  1b7f		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    947  1b82
    948  1b82				   .skipbl
    949  1b82		       a4 85		      ldy	fromX12
    950  1b84		       84 aa		      sty	__boardIndex
    951  1b86
    952  1b86		       a9 d1		      lda	#RAMBANK_BOARD
    953  1b88		       85 3e		      sta	SET_BANK_RAM	;@3
    954  1b8a		       b9 79 fc 	      lda	Board,y
    955  1b8d		       85 97		      sta	lastPiece	; what we are overwriting
    956  1b8f		       a5 96		      lda	fromPiece
    957  1b91		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    958  1b93		       29 df		      and	#~FLAG_ENPASSANT
    959  1b95		       a4 aa		      ldy	__boardIndex
      0  1b97					      sta@RAM	Board,y	; and what's actually moving there
      1  1b97		       99 79 fe 	      sta	[RAM]+Board,y
    961  1b9a
    962  1b9a
      0  1b9a					      PHASE	AI_MarchB
      1  1b9a		       a9 18		      lda	#AI_MarchB
      2  1b9c		       85 8b		      sta	aiState
    964  1b9e		       60		      rts
    965  1b9f
    966  1b9f
    967  1b9f							;---------------------------------------------------------------------------------------------------
    968  1b9f
      0  1b9f					      DEF	aiMarchB2
      1  1b9f				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  1b9f				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  1b9f				   aiMarchB2
      4  1b9f				   TEMPORARY_VAR SET	Overlay
      5  1b9f				   TEMPORARY_OFFSET SET	0
      6  1b9f				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  1b9f				   FUNCTION_NAME SET	aiMarchB2
    970  1b9f					      SUBROUTINE
    971  1b9f
      0  1b9f					      REFER	AiStateMachine
      1  1b9f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b9f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b9f					      ENDIF
      0  1b9f					      VEND	aiMarchB2
      1  1b9f				  -	      IFNCONST	aiMarchB2
      2  1b9f				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  1b9f				  -	      ERR
      4  1b9f					      ENDIF
      5  1b9f		       00 a9	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    974  1b9f
    975  1b9f		       a4 83		      ldy	lastSquareX12
    976  1ba1		       84 80		      sty	squareToDraw
    977  1ba3
    978  1ba3		       a9 d1		      lda	#RAMBANK_BOARD
    979  1ba5		       85 3e		      sta	SET_BANK_RAM	;@3
    980  1ba7		       b9 79 fc 	      lda	Board,y
    981  1baa		       f0 03		      beq	.skipbl2
    982  1bac
    983  1bac							; WARNING - local variables will not survive the following call...!
    984  1bac		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    985  1baf				   .skipbl2
    986  1baf
    987  1baf		       a5 85		      lda	fromX12
    988  1bb1		       c5 86		      cmp	toX12
    989  1bb3		       f0 09		      beq	xhalt
    990  1bb5
    991  1bb5		       a9 02		      lda	#2	;??? inter-move segment speed (can be 0)
    992  1bb7		       85 82		      sta	drawDelay
      0  1bb9					      PHASE	AI_MarchToTargetA
      1  1bb9		       a9 16		      lda	#AI_MarchToTargetA
      2  1bbb		       85 8b		      sta	aiState
    994  1bbd
    995  1bbd		       60		      rts
    996  1bbe
    997  1bbe				   xhalt
    998  1bbe
    999  1bbe							;??? jsr FinaliseMove
   1000  1bbe
   1001  1bbe		       a9 04		      lda	#4	; on/off count
   1002  1bc0		       85 84		      sta	drawCount	; flashing for piece about to move
   1003  1bc2		       a9 00		      lda	#0
   1004  1bc4		       85 82		      sta	drawDelay
   1005  1bc6
      0  1bc6					      PHASE	AI_FinalFlash
      1  1bc6		       a9 1b		      lda	#AI_FinalFlash
      2  1bc8		       85 8b		      sta	aiState
   1007  1bca		       60		      rts
   1008  1bcb
   1009  1bcb
   1010  1bcb							;---------------------------------------------------------------------------------------------------
   1011  1bcb
   1012  1bcb
      0  1bcb					      DEF	aiWriteStartPieceBlank
      1  1bcb				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  1bcb				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  1bcb				   aiWriteStartPieceBlank
      4  1bcb				   TEMPORARY_VAR SET	Overlay
      5  1bcb				   TEMPORARY_OFFSET SET	0
      6  1bcb				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  1bcb				   FUNCTION_NAME SET	aiWriteStartPieceBlank
   1014  1bcb					      SUBROUTINE
   1015  1bcb
      0  1bcb					      REFER	AiStateMachine
      1  1bcb					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1bcb				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1bcb					      ENDIF
      0  1bcb					      VEND	aiWriteStartPieceBlank
      1  1bcb				  -	      IFNCONST	aiWriteStartPieceBlank
      2  1bcb				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  1bcb				  -	      ERR
      4  1bcb					      ENDIF
      5  1bcb		       00 a9	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
   1018  1bcb
   1019  1bcb							; Flash the piece in-place preparatory to moving it.
   1020  1bcb							; drawDelay = flash speed
   1021  1bcb							; drawCount = # of flashes
   1022  1bcb
   1023  1bcb
   1024  1bcb		       a9 04		      lda	#%100
   1025  1bcd		       85 4a		      sta	CTRLPF
   1026  1bcf		       a9 02		      lda	#2
   1027  1bd1		       85 46		      sta	COLUP0
   1028  1bd3
   1029  1bd3
   1030  1bd3		       a5 82		      lda	drawDelay
   1031  1bd5		       f0 03		      beq	deCount
   1032  1bd7		       c6 82		      dec	drawDelay
   1033  1bd9		       60		      rts
   1034  1bda				   deCount
   1035  1bda
   1036  1bda		       a5 84		      lda	drawCount
   1037  1bdc		       f0 0d		      beq	flashDone
   1038  1bde		       c6 84		      dec	drawCount
   1039  1be0
   1040  1be0		       a9 0a		      lda	#READY_TO_MOVE_FLASH
   1041  1be2		       85 82		      sta	drawDelay	; "getting ready to move" flash
   1042  1be4
   1043  1be4		       a5 85		      lda	fromX12
   1044  1be6		       85 80		      sta	squareToDraw
   1045  1be8
   1046  1be8							; WARNING - local variables will not survive the following call...!
   1047  1be8		       4c be f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
   1048  1beb
   1049  1beb				   flashDone
   1050  1beb
   1051  1beb							;lda #2
   1052  1beb							;sta drawDelay
      0  1beb					      PHASE	AI_MarchToTargetA
      1  1beb		       a9 16		      lda	#AI_MarchToTargetA
      2  1bed		       85 8b		      sta	aiState
   1054  1bef		       60		      rts
   1055  1bf0
   1056  1bf0
   1057  1bf0							;---------------------------------------------------------------------------------------------------
   1058  1bf0
      0  1bf0					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  1bf0		       03 f0	   .TEMP      =	* - _BANK_START
 BANK_StateMachine (1K) SIZE =  $3f0 , FREE= $10
      2  1bf0					      ECHO	"BANK_StateMachine", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1bf0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1bf0				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine", " size=", * - ORIGIN
      5  1bf0				  -	      ERR
      6  1bf0					      ENDIF
   1060  1bf0
   1061  1bf0
   1062  1bf0							;---------------------------------------------------------------------------------------------------
   1063  1bf0
   1064  1bf0							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#2.asm LEVEL 2 PASS 4
      0  1bf0					      include	"BANK_StateMachine@1#2.asm"
      0  1bf0					      SLOT	1
      1  1bf0				  -	      IF	(1 < 0) || (1 > 3)
      2  1bf0				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1bf0				  -	      ERR
      4  1bf0					      ENDIF
      5  1bf0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1bf0				   _BANK_SLOT SET	1 * 64
      0  1bf0					      NEWBANK	STATEMACHINE2
      1  1dcf ????				      SEG	STATEMACHINE2
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   STATEMACHINE2_START SET	*
      6  1c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1c00				   STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  1c00
      4  1c00
      5  1c00							;---------------------------------------------------------------------------------------------------
      6  1c00
      0  1c00					      DEF	aiChooseDebounce
      1  1c00				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  1c00				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  1c00				   aiChooseDebounce
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	aiChooseDebounce
      8  1c00					      SUBROUTINE
      9  1c00
      0  1c00					      REFER	AiStateMachine
      1  1c00					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c00				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c00					      ENDIF
      0  1c00					      VEND	aiChooseDebounce
      1  1c00				  -	      IFNCONST	aiChooseDebounce
      2  1c00				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  1c00				  -	      ERR
      4  1c00					      ENDIF
      5  1c00		       00 a9	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
     12  1c00
     13  1c00							; We've changed promotion piece, and drawn it
     14  1c00							; wait for joystick to be released before continuing
     15  1c00
     16  1c00		       ad 80 02 	      lda	SWCHA
     17  1c03		       29 f0		      and	#$F0
     18  1c05		       c9 f0		      cmp	#$F0
     19  1c07		       d0 0a		      bne	.exit	; wait while joystick still pressed
     20  1c09
     21  1c09		       a9 01		      lda	#1
     22  1c0b		       85 8c		      sta	aiFlashDelay
     23  1c0d		       85 8e		      sta	aiFlashPhase
     24  1c0f
      0  1c0f					      PHASE	AI_ChoosePromotePiece
      1  1c0f		       a9 21		      lda	#AI_ChoosePromotePiece
      2  1c11		       85 8b		      sta	aiState
     26  1c13		       60	   .exit      rts
     27  1c14
     28  1c14
     29  1c14							;---------------------------------------------------------------------------------------------------
     30  1c14
      0  1c14					      DEF	aiReselectDebounce
      1  1c14				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  1c14				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  1c14				   aiReselectDebounce
      4  1c14				   TEMPORARY_VAR SET	Overlay
      5  1c14				   TEMPORARY_OFFSET SET	0
      6  1c14				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  1c14				   FUNCTION_NAME SET	aiReselectDebounce
     32  1c14					      SUBROUTINE
     33  1c14
      0  1c14					      REFER	AiStateMachine
      1  1c14					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c14				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c14					      ENDIF
      0  1c14					      VEND	aiReselectDebounce
      1  1c14				  -	      IFNCONST	aiReselectDebounce
      2  1c14				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  1c14				  -	      ERR
      4  1c14					      ENDIF
      5  1c14		       00 a9	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
     36  1c14
     37  1c14							; We've just cancelled the move. Wait for the button to be released
     38  1c14							; and then go back to selecting a piece to move
     39  1c14
     40  1c14		       a5 4c		      lda	INPT4
     41  1c16		       10 04		      bpl	.exit	; button still pressed, so wait
     42  1c18
      0  1c18					      PHASE	AI_SelectStartSquare
      1  1c18		       a9 02		      lda	#AI_SelectStartSquare
      2  1c1a		       85 8b		      sta	aiState
     44  1c1c		       60	   .exit      rts
     45  1c1d
     46  1c1d
     47  1c1d							;---------------------------------------------------------------------------------------------------
     48  1c1d
      0  1c1d					      DEF	aiDelayAfterMove
      1  1c1d				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  1c1d				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  1c1d				   aiDelayAfterMove
      4  1c1d				   TEMPORARY_VAR SET	Overlay
      5  1c1d				   TEMPORARY_OFFSET SET	0
      6  1c1d				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  1c1d				   FUNCTION_NAME SET	aiDelayAfterMove
     50  1c1d					      SUBROUTINE
     51  1c1d
      0  1c1d					      REFER	AiStateMachine
      1  1c1d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c1d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c1d					      ENDIF
      0  1c1d					      VEND	aiDelayAfterMove
      1  1c1d				  -	      IFNCONST	aiDelayAfterMove
      2  1c1d				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  1c1d				  -	      ERR
      4  1c1d					      ENDIF
      5  1c1d		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
     54  1c1d
     55  1c1d		       a9 32		      lda	#50
     56  1c1f		       85 8c		      sta	aiFlashDelay
      0  1c21					      PHASE	AI_DelayAfterMove2
      1  1c21		       a9 26		      lda	#AI_DelayAfterMove2
      2  1c23		       85 8b		      sta	aiState
     58  1c25		       60	   .exit      rts
     59  1c26
     60  1c26
     61  1c26							;---------------------------------------------------------------------------------------------------
     62  1c26
      0  1c26					      DEF	aiDelayAfterMove2
      1  1c26				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  1c26				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  1c26				   aiDelayAfterMove2
      4  1c26				   TEMPORARY_VAR SET	Overlay
      5  1c26				   TEMPORARY_OFFSET SET	0
      6  1c26				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  1c26				   FUNCTION_NAME SET	aiDelayAfterMove2
     64  1c26					      SUBROUTINE
     65  1c26
      0  1c26					      REFER	AiStateMachine
      1  1c26					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c26				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c26					      ENDIF
      0  1c26					      VEND	aiDelayAfterMove
      1  1c26				  -	      IFNCONST	aiDelayAfterMove
      2  1c26				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  1c26				  -	      ERR
      4  1c26					      ENDIF
      5  1c26		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
     68  1c26
     69  1c26		       c6 8c		      dec	aiFlashDelay
     70  1c28		       d0 04		      bne	.exit
      0  1c2a					      PHASE	AI_MoveIsSelected
      1  1c2a		       a9 14		      lda	#AI_MoveIsSelected
      2  1c2c		       85 8b		      sta	aiState
     72  1c2e		       60	   .exit      rts
     73  1c2f
     74  1c2f
     75  1c2f							;---------------------------------------------------------------------------------------------------
     76  1c2f
      0  1c2f					      DEF	aiDelayAfterPlaced
      1  1c2f				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  1c2f				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  1c2f				   aiDelayAfterPlaced
      4  1c2f				   TEMPORARY_VAR SET	Overlay
      5  1c2f				   TEMPORARY_OFFSET SET	0
      6  1c2f				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  1c2f				   FUNCTION_NAME SET	aiDelayAfterPlaced
     78  1c2f					      SUBROUTINE
     79  1c2f
      0  1c2f					      REFER	AiStateMachine
      1  1c2f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c2f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c2f					      ENDIF
      0  1c2f					      VEND	aiDelayAfterPlaced
      1  1c2f				  -	      IFNCONST	aiDelayAfterPlaced
      2  1c2f				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  1c2f				  -	      ERR
      4  1c2f					      ENDIF
      5  1c2f		       00 a9	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
     82  1c2f
     83  1c2f		       a2 4b		      ldx	#75	; delay after human move
     84  1c31		       a5 95		      lda	sideToMove
     85  1c33		       30 02		      bmi	.computer
     86  1c35		       a2 01		      ldx	#1	; delay after computer move
     87  1c37		       86 8c	   .computer  stx	aiFlashDelay
     88  1c39
      0  1c39					      PHASE	AI_DelayAfterPlaced2
      1  1c39		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  1c3b		       85 8b		      sta	aiState
     90  1c3d		       60		      rts
     91  1c3e
     92  1c3e
     93  1c3e							;---------------------------------------------------------------------------------------------------
     94  1c3e
      0  1c3e					      DEF	aiDelayAfterPlaced2
      1  1c3e				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  1c3e				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  1c3e				   aiDelayAfterPlaced2
      4  1c3e				   TEMPORARY_VAR SET	Overlay
      5  1c3e				   TEMPORARY_OFFSET SET	0
      6  1c3e				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  1c3e				   FUNCTION_NAME SET	aiDelayAfterPlaced2
     96  1c3e					      SUBROUTINE
     97  1c3e
      0  1c3e					      REFER	AiStateMachine
      1  1c3e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c3e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c3e					      ENDIF
      0  1c3e					      VEND	aiDelayAfterPlaced2
      1  1c3e				  -	      IFNCONST	aiDelayAfterPlaced2
      2  1c3e				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced2
      3  1c3e				  -	      ERR
      4  1c3e					      ENDIF
      5  1c3e		       00 a9	   VAREND_aiDelayAfterPlaced2 =	TEMPORARY_VAR
    100  1c3e
    101  1c3e		       c6 8c		      dec	aiFlashDelay
    102  1c40		       d0 04		      bne	.exit
    103  1c42
    104  1c42							;SWAP
    105  1c42
      0  1c42					      PHASE	AI_GenerateMoves
      1  1c42		       a9 12		      lda	#AI_GenerateMoves
      2  1c44		       85 8b		      sta	aiState
    107  1c46		       60	   .exit      rts
    108  1c47
    109  1c47
    110  1c47							;---------------------------------------------------------------------------------------------------
    111  1c47
      0  1c47					      DEF	aiMarchToTargetB
      1  1c47				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  1c47				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  1c47				   aiMarchToTargetB
      4  1c47				   TEMPORARY_VAR SET	Overlay
      5  1c47				   TEMPORARY_OFFSET SET	0
      6  1c47				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  1c47				   FUNCTION_NAME SET	aiMarchToTargetB
    113  1c47					      SUBROUTINE
    114  1c47
      0  1c47					      REFER	AiStateMachine
      1  1c47					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c47				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c47					      ENDIF
      0  1c47					      VEND	aiMarchToTargetB
      1  1c47				  -	      IFNCONST	aiMarchToTargetB
      2  1c47				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  1c47				  -	      ERR
      4  1c47					      ENDIF
      5  1c47		       00 a9	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    117  1c47
    118  1c47							; now we want to undraw the piece in the old square
    119  1c47
    120  1c47		       a5 82		      lda	drawDelay
    121  1c49		       f0 03		      beq	.stepOne
    122  1c4b		       c6 82		      dec	drawDelay
    123  1c4d		       60		      rts
    124  1c4e
    125  1c4e				   .stepOne
    126  1c4e		       a5 83		      lda	lastSquareX12
    127  1c50		       85 80		      sta	squareToDraw
    128  1c52
    129  1c52							; WARNING - local variables will not survive the following call...!
    130  1c52		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    131  1c55
    132  1c55		       a4 83		      ldy	lastSquareX12
    133  1c57		       a5 98		      lda	previousPiece
    134  1c59
    135  1c59		       a2 d1		      ldx	#RAMBANK_BOARD
    136  1c5b		       86 3e		      stx	SET_BANK_RAM	;@3
      0  1c5d					      sta@RAM	Board,y	; and what's actually moving there
      1  1c5d		       99 79 fe 	      sta	[RAM]+Board,y
    138  1c60
    139  1c60		       a5 97		      lda	lastPiece
    140  1c62		       85 98		      sta	previousPiece
    141  1c64
      0  1c64					      PHASE	AI_MarchB2
      1  1c64		       a9 1a		      lda	#AI_MarchB2
      2  1c66		       85 8b		      sta	aiState
    143  1c68		       60		      rts
    144  1c69
    145  1c69
    146  1c69							;---------------------------------------------------------------------------------------------------
    147  1c69
      0  1c69					      DEF	aiPromotePawnStart
      1  1c69				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  1c69				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  1c69				   aiPromotePawnStart
      4  1c69				   TEMPORARY_VAR SET	Overlay
      5  1c69				   TEMPORARY_OFFSET SET	0
      6  1c69				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  1c69				   FUNCTION_NAME SET	aiPromotePawnStart
    149  1c69					      SUBROUTINE
    150  1c69
      0  1c69					      REFER	AiStateMachine
      1  1c69					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c69				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c69					      ENDIF
      0  1c69					      VEND	aiPromotePawnStart
      1  1c69				  -	      IFNCONST	aiPromotePawnStart
      2  1c69				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  1c69				  -	      ERR
      4  1c69					      ENDIF
      5  1c69		       00 a9	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    153  1c69
    154  1c69
    155  1c69		       ad 84 02 	      lda	INTIM
    156  1c6c		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    157  1c6e		       90 1c		      bcc	.exit
    158  1c70
    159  1c70		       a9 00		      lda	#0
    160  1c72		       85 8e		      sta	aiFlashPhase
    161  1c74		       85 8c		      sta	aiFlashDelay
    162  1c76
    163  1c76		       a4 86		      ldy	toX12
    164  1c78		       84 80		      sty	squareToDraw
    165  1c7a
    166  1c7a		       a9 d1		      lda	#RAMBANK_BOARD
    167  1c7c		       85 3e		      sta	SET_BANK_RAM	;@3
    168  1c7e		       b9 79 fc 	      lda	Board,y
    169  1c81		       29 0f		      and	#PIECE_MASK
    170  1c83		       f0 03		      beq	.empty
    171  1c85
    172  1c85							; WARNING - local variables will not survive the following call...!
    173  1c85		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    174  1c88
      0  1c88				   .empty     PHASE	AI_RollPromotionPiece
      1  1c88		       a9 20		      lda	#AI_RollPromotionPiece
      2  1c8a		       85 8b		      sta	aiState
    176  1c8c		       60	   .exit      rts
    177  1c8d
    178  1c8d
    179  1c8d							;---------------------------------------------------------------------------------------------------
    180  1c8d
      0  1c8d					      DEF	aiGenerateMoves
      1  1c8d				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  1c8d				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  1c8d				   aiGenerateMoves
      4  1c8d				   TEMPORARY_VAR SET	Overlay
      5  1c8d				   TEMPORARY_OFFSET SET	0
      6  1c8d				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  1c8d				   FUNCTION_NAME SET	aiGenerateMoves
    182  1c8d					      SUBROUTINE
    183  1c8d
      0  1c8d					      REFER	AiStateMachine
      1  1c8d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c8d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c8d					      ENDIF
      0  1c8d					      VEND	aiGenerateMoves
      1  1c8d				  -	      IFNCONST	aiGenerateMoves
      2  1c8d				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  1c8d				  -	      ERR
      4  1c8d					      ENDIF
      5  1c8d		       00 a9	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    186  1c8d
    187  1c8d		       a5 86		      lda	toX12
    188  1c8f		       85 80		      sta	squareToDraw	; for showing move (display square)
    189  1c91
    190  1c91		       a6 95		      ldx	sideToMove
    191  1c93		       10 05		      bpl	.player
    192  1c95
    193  1c95
      0  1c95				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  1c95		       a9 13		      lda	#AI_ComputerMove
      2  1c97		       85 8b		      sta	aiState
    195  1c99		       60		      rts
    196  1c9a
    197  1c9a
      0  1c9a				   .player    PHASE	AI_StartMoveGen
      1  1c9a		       a9 0b		      lda	#AI_StartMoveGen
      2  1c9c		       85 8b		      sta	aiState
    199  1c9e		       60		      rts
    200  1c9f
    201  1c9f
    202  1c9f							;---------------------------------------------------------------------------------------------------
    203  1c9f
      0  1c9f					      DEF	aiStepMoveGen
      1  1c9f				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  1c9f				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  1c9f				   aiStepMoveGen
      4  1c9f				   TEMPORARY_VAR SET	Overlay
      5  1c9f				   TEMPORARY_OFFSET SET	0
      6  1c9f				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  1c9f				   FUNCTION_NAME SET	aiStepMoveGen
    205  1c9f					      SUBROUTINE
    206  1c9f
      0  1c9f					      REFER	AiStateMachine
      1  1c9f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c9f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c9f					      ENDIF
      0  1c9f					      VEND	aiStepMoveGen
      1  1c9f				  -	      IFNCONST	aiStepMoveGen
      2  1c9f				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  1c9f				  -	      ERR
      4  1c9f					      ENDIF
      5  1c9f		       00 a9	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    209  1c9f
    210  1c9f		       a5 87		      lda	originX12	; location of cursor (show move)
    211  1ca1		       85 88		      sta	cursorX12
      0  1ca3					      PHASE	AI_BeginSelectMovePhase
      1  1ca3		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  1ca5		       85 8b		      sta	aiState
    213  1ca7		       60		      rts
    214  1ca8
    215  1ca8
    216  1ca8							;---------------------------------------------------------------------------------------------------
    217  1ca8
    218  1d00		       00 00 00 00*	      align	256	; TODO?
      0  1d00					      DEF	PositionSprites
      1  1d00				   SLOT_PositionSprites SET	_BANK_SLOT
      2  1d00				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  1d00				   PositionSprites
      4  1d00				   TEMPORARY_VAR SET	Overlay
      5  1d00				   TEMPORARY_OFFSET SET	0
      6  1d00				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  1d00				   FUNCTION_NAME SET	PositionSprites
    220  1d00					      SUBROUTINE
    221  1d00
      0  1d00					      REFER	StartupBankReset
      1  1d00				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1d00				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1d00					      ENDIF
      0  1d00					      VEND	PositionSprites
      1  1d00				  -	      IFNCONST	PositionSprites
      2  1d00				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  1d00				  -	      ERR
      4  1d00					      ENDIF
      5  1d00		       00 a7	   VAREND_PositionSprites =	TEMPORARY_VAR
    224  1d00
    225  1d00
    226  1d00		       a5 88		      lda	cursorX12
    227  1d02		       38		      sec
    228  1d03		       e9 0a	   .sub10     sbc	#10
    229  1d05		       b0 fc		      bcs	.sub10
    230  1d07		       69 08		      adc	#8
    231  1d09		       a8		      tay
    232  1d0a
    233  1d0a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    234  1d0c
    235  1d0c		       b9 30 f5 	      lda	colToPixel,y
    236  1d0f
    237  1d0f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    238  1d10		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    239  1d12		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    240  1d14
    241  1d14		       a8		      tay
    242  1d15		       b9 30 f4 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    243  1d18		       85 60		      sta	HMP0
    244  1d1a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    245  1d1c
    246  1d1c		       85 42		      sta	WSYNC
    247  1d1e		       85 6a		      sta	HMOVE
    248  1d20
    249  1d20		       60		      rts
    250  1d21
    251  1d21							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    252  1d21							; fine adjustment value. This table is on a page boundary to guarantee the processor
    253  1d21							; will cross a page boundary and waste a cycle in order to be at the precise position
    254  1d21							; for a RESP0,x write
    255  1d21
    256  1d21				   fineAdjustBegin
    257  1d21
    258  1d21		       70		      DC.B	%01110000	; Left 7
    259  1d22		       60		      DC.B	%01100000	; Left 6
    260  1d23		       50		      DC.B	%01010000	; Left 5
    261  1d24		       40		      DC.B	%01000000	; Left 4
    262  1d25		       30		      DC.B	%00110000	; Left 3
    263  1d26		       20		      DC.B	%00100000	; Left 2
    264  1d27		       10		      DC.B	%00010000	; Left 1
    265  1d28		       00		      DC.B	%00000000	; No movement.
    266  1d29		       f0		      DC.B	%11110000	; Right 1
    267  1d2a		       e0		      DC.B	%11100000	; Right 2
    268  1d2b		       d0		      DC.B	%11010000	; Right 3
    269  1d2c		       c0		      DC.B	%11000000	; Right 4
    270  1d2d		       b0		      DC.B	%10110000	; Right 5
    271  1d2e		       a0		      DC.B	%10100000	; Right 6
    272  1d2f		       90		      DC.B	%10010000	; Right 7
    273  1d30
    274  1d30		       f4 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    275  1d30
    276  1d30
      0  1d30					      ALLOCATE	colToPixel, 8
      0  1d30					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1d30					      LIST	ON
      0  1d30					      DEF	colToPixel
      1  1d30				   SLOT_colToPixel SET	_BANK_SLOT
      2  1d30				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  1d30				   colToPixel
      4  1d30				   TEMPORARY_VAR SET	Overlay
      5  1d30				   TEMPORARY_OFFSET SET	0
      6  1d30				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  1d30				   FUNCTION_NAME SET	colToPixel
    278  1d30		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    279  1d38
    280  1d38
    281  1d38							;---------------------------------------------------------------------------------------------------
    282  1d38
      0  1d38					      DEF	aiMarchToTargetA
      1  1d38				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  1d38				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  1d38				   aiMarchToTargetA
      4  1d38				   TEMPORARY_VAR SET	Overlay
      5  1d38				   TEMPORARY_OFFSET SET	0
      6  1d38				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  1d38				   FUNCTION_NAME SET	aiMarchToTargetA
    284  1d38					      SUBROUTINE
    285  1d38
      0  1d38					      REFER	AiStateMachine
      1  1d38					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1d38				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1d38					      ENDIF
    287  1d38
      0  1d38					      VAR	__fromRow, 1
      1  1d38		       00 a9	   __fromRow  =	TEMPORARY_VAR
      2  1d38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d38
      4  1d38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d38					      ENDIF
      8  1d38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d38				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  1d38				  -	      ERR
     11  1d38					      ENDIF
     12  1d38					      LIST	ON
      0  1d38					      VAR	__boardIndex, 1
      1  1d38		       00 aa	   __boardIndex =	TEMPORARY_VAR
      2  1d38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d38
      4  1d38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d38					      ENDIF
      8  1d38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d38				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  1d38				  -	      ERR
     11  1d38					      ENDIF
     12  1d38					      LIST	ON
      0  1d38					      VAR	__fromCol, 1
      1  1d38		       00 ab	   __fromCol  =	TEMPORARY_VAR
      2  1d38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d38
      4  1d38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d38					      ENDIF
      8  1d38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d38				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  1d38				  -	      ERR
     11  1d38					      ENDIF
     12  1d38					      LIST	ON
      0  1d38					      VAR	__toCol, 1
      1  1d38		       00 ac	   __toCol    =	TEMPORARY_VAR
      2  1d38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1d38
      4  1d38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1d38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1d38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1d38					      ENDIF
      8  1d38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1d38				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  1d38				  -	      ERR
     11  1d38					      ENDIF
     12  1d38					      LIST	ON
    292  1d38
      0  1d38					      VEND	aiMarchToTargetA
      1  1d38				  -	      IFNCONST	aiMarchToTargetA
      2  1d38				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  1d38				  -	      ERR
      4  1d38					      ENDIF
      5  1d38		       00 ad	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    294  1d38
    295  1d38
    296  1d38		       a5 82		      lda	drawDelay
    297  1d3a		       f0 03		      beq	.nodelay
    298  1d3c		       c6 82		      dec	drawDelay
    299  1d3e		       60		      rts
    300  1d3f				   .nodelay
    301  1d3f
    302  1d3f							; Now we calculate move to new square
    303  1d3f
    304  1d3f		       a5 85		      lda	fromX12
    305  1d41		       c5 86		      cmp	toX12
    306  1d43		       f0 44		      beq	.unmovedx
    307  1d45		       85 83		      sta	lastSquareX12
    308  1d47
    309  1d47		       38		      sec
    310  1d48		       a2 fd		      ldx	#-3
    311  1d4a		       e9 0a	   .sub10     sbc	#10
    312  1d4c		       e8		      inx
    313  1d4d		       b0 fb		      bcs	.sub10
    314  1d4f		       69 08		      adc	#8
    315  1d51		       85 ab		      sta	__fromCol
    316  1d53		       86 a9		      stx	__fromRow
    317  1d55
    318  1d55		       a5 86		      lda	toX12
    319  1d57		       38		      sec
    320  1d58		       a2 fd		      ldx	#-3
    321  1d5a		       e9 0a	   .sub10b    sbc	#10
    322  1d5c		       e8		      inx
    323  1d5d		       b0 fb		      bcs	.sub10b
    324  1d5f		       69 08		      adc	#8
    325  1d61		       85 ac		      sta	__toCol
    326  1d63
    327  1d63
    328  1d63		       e4 a9		      cpx	__fromRow
    329  1d65		       f0 13		      beq	.rowDone
    330  1d67
    331  1d67		       b0 0a		      bcs	.incRow
    332  1d69
    333  1d69		       38		      sec
    334  1d6a		       a5 85		      lda	fromX12
    335  1d6c		       e9 0a		      sbc	#10
    336  1d6e		       85 85		      sta	fromX12
    337  1d70		       4c 7a f5 	      jmp	.rowDone
    338  1d73
    339  1d73		       18	   .incRow    clc
    340  1d74		       a5 85		      lda	fromX12
    341  1d76		       69 0a		      adc	#10
    342  1d78		       85 85		      sta	fromX12
    343  1d7a
    344  1d7a				   .rowDone
    345  1d7a
    346  1d7a		       a5 ac		      lda	__toCol
    347  1d7c		       c5 ab		      cmp	__fromCol
    348  1d7e		       f0 09		      beq	.colDone
    349  1d80
    350  1d80		       b0 05		      bcs	.incCol
    351  1d82
    352  1d82		       c6 85		      dec	fromX12
    353  1d84		       4c 89 f5 	      jmp	.colDone
    354  1d87
    355  1d87		       e6 85	   .incCol    inc	fromX12
    356  1d89				   .colDone
    357  1d89				   .unmovedx
    358  1d89
    359  1d89		       a5 87		      lda	originX12
    360  1d8b		       85 88		      sta	cursorX12
    361  1d8d
      0  1d8d					      PHASE	AI_MarchA2
      1  1d8d		       a9 17		      lda	#AI_MarchA2
      2  1d8f		       85 8b		      sta	aiState
    363  1d91		       60		      rts
    364  1d92
    365  1d92
    366  1d92							;---------------------------------------------------------------------------------------------------
    367  1d92
      0  1d92					      DEF	aiFinalFlash
      1  1d92				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  1d92				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  1d92				   aiFinalFlash
      4  1d92				   TEMPORARY_VAR SET	Overlay
      5  1d92				   TEMPORARY_OFFSET SET	0
      6  1d92				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  1d92				   FUNCTION_NAME SET	aiFinalFlash
    369  1d92					      SUBROUTINE
    370  1d92
      0  1d92					      REFER	AiStateMachine
      1  1d92					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1d92				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1d92					      ENDIF
      0  1d92					      VEND	aiFinalFlash
      1  1d92				  -	      IFNCONST	aiFinalFlash
      2  1d92				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  1d92				  -	      ERR
      4  1d92					      ENDIF
      5  1d92		       00 a9	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    373  1d92
    374  1d92							; Piece has finished the animated move and is now in destination square.
    375  1d92							; Flash the piece
    376  1d92
    377  1d92		       a5 82		      lda	drawDelay
    378  1d94		       f0 03		      beq	.deCount
    379  1d96		       c6 82		      dec	drawDelay
    380  1d98		       60		      rts
    381  1d99
    382  1d99		       a5 84	   .deCount   lda	drawCount
    383  1d9b		       f0 0e		      beq	.flashDone2
    384  1d9d		       c6 84		      dec	drawCount
    385  1d9f
    386  1d9f		       a9 0a		      lda	#10
    387  1da1		       85 82		      sta	drawDelay	; "getting ready to move" flash
    388  1da3
    389  1da3		       a5 85		      lda	fromX12
    390  1da5		       85 80		      sta	squareToDraw
    391  1da7
    392  1da7							; WARNING - local variables will not survive the following call...!
    393  1da7		       20 be f0 	      jsr	CopySinglePiece	;@0
    394  1daa		       60		      rts
    395  1dab
    396  1dab				   .flashDone2
    397  1dab
    398  1dab		       a9 64		      lda	#100
    399  1dad		       85 8c		      sta	aiFlashDelay
    400  1daf
      0  1daf					      PHASE	AI_SpecialMoveFixup
      1  1daf		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  1db1		       85 8b		      sta	aiState
    402  1db3		       60		      rts
    403  1db4
    404  1db4
    405  1db4							;---------------------------------------------------------------------------------------------------
    406  1db4
      0  1db4					      DEF	aiStartSquareSelected
      1  1db4				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  1db4				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  1db4				   aiStartSquareSelected
      4  1db4				   TEMPORARY_VAR SET	Overlay
      5  1db4				   TEMPORARY_OFFSET SET	0
      6  1db4				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  1db4				   FUNCTION_NAME SET	aiStartSquareSelected
    408  1db4					      SUBROUTINE
    409  1db4
      0  1db4					      REFER	AiStateMachine
      1  1db4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1db4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1db4					      ENDIF
      0  1db4					      VEND	aiStartSquareSelected
      1  1db4				  -	      IFNCONST	aiStartSquareSelected
      2  1db4				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  1db4				  -	      ERR
      4  1db4					      ENDIF
      5  1db4		       00 a9	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    412  1db4
    413  1db4
    414  1db4							; Mark all the valid moves for the selected piece on the board
    415  1db4							; and then start pulsing the piece
    416  1db4							; AND start choosing for selection of TO square
    417  1db4
    418  1db4							; Iterate the movelist and for all from squares which = drawPieceNumber
    419  1db4							; then draw a BLANK at that square
    420  1db4							; do 1 by one, when none found then increment state
    421  1db4
    422  1db4		       a5 88		      lda	cursorX12
    423  1db6		       85 80		      sta	squareToDraw
    424  1db8
    425  1db8		       a9 0a		      lda	#10
    426  1dba		       85 8c		      sta	aiFlashDelay
    427  1dbc
    428  1dbc		       a9 00		      lda	#0
    429  1dbe		       85 86		      sta	toX12	;aiToSquareX12
    430  1dc0		       85 8e		      sta	aiFlashPhase	; for debounce exit timing
    431  1dc2
    432  1dc2		       a9 ff		      lda	#-1
    433  1dc4		       85 8d		      sta	aiMoveIndex
    434  1dc6
    435  1dc6		       a9 28		      lda	#HOLD_DELAY
    436  1dc8		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    437  1dca
      0  1dca					      PHASE	AI_DrawMoves
      1  1dca		       a9 04		      lda	#AI_DrawMoves
      2  1dcc		       85 8b		      sta	aiState
    439  1dce		       60		      rts
    440  1dcf
    441  1dcf
    442  1dcf							;---------------------------------------------------------------------------------------------------
    443  1dcf
      0  1dcf					      CHECK_BANK_SIZE	"BANK_StateMachine2"
      1  1dcf		       01 cf	   .TEMP      =	* - _BANK_START
 BANK_StateMachine2 (1K) SIZE =  $1cf , FREE= $231
      2  1dcf					      ECHO	"BANK_StateMachine2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1dcf				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1dcf				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine2", " size=", * - ORIGIN
      5  1dcf				  -	      ERR
      6  1dcf					      ENDIF
    445  1dcf
    446  1dcf							;---------------------------------------------------------------------------------------------------
    447  1dcf
    448  1dcf							; EOF
------- FILE ./chess.asm
------- FILE piece_graphics.asm LEVEL 2 PASS 4
      0  1dcf					      include	"piece_graphics.asm"
      1  1dcf							; Import the graphics definitions generated by ConvertChessPieces.py
      2  1dcf
      0  1dcf					      SLOT	2
      1  1dcf				  -	      IF	(2 < 0) || (2 > 3)
      2  1dcf				  -	      ECHO	"Illegal bank address/segment location", 2
      3  1dcf				  -	      ERR
      4  1dcf					      ENDIF
      5  1dcf				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  1dcf				   _BANK_SLOT SET	2 * 64
      0  1dcf					      NEWBANK	PIECES_0
      1  23d8 ????				      SEG	PIECES_0
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   PIECES_0_START SET	*
      6  2000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2000				   PIECES_0   SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + 1024
      5  2000
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2000					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  2000					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  2000					      LIST	ON
      0  2000					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  2000				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2000				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2000				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  2000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  2018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  2030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2048					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  2048					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  2048					      LIST	ON
      0  2048					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  2048				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2048				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2048				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  2048				   TEMPORARY_VAR SET	Overlay
      5  2048				   TEMPORARY_OFFSET SET	0
      6  2048				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2048				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  2048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2090					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  2090					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  2090					      LIST	ON
      0  2090					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  2090				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2090				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2090				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  2090				   TEMPORARY_VAR SET	Overlay
      5  2090				   TEMPORARY_OFFSET SET	0
      6  2090				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2090				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  2090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  20a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  20c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  20d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  20d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  2100					      LIST	ON
      0  2100					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  2100				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2100				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2100				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  2100				   TEMPORARY_VAR SET	Overlay
      5  2100				   TEMPORARY_OFFSET SET	0
      6  2100				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2100				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  2100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2148					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  2148					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  2148					      LIST	ON
      0  2148					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  2148				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2148				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2148				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  2148				   TEMPORARY_VAR SET	Overlay
      5  2148				   TEMPORARY_OFFSET SET	0
      6  2148				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2148				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  2148		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2190					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  2190					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  2190					      LIST	ON
      0  2190					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  2190				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2190				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2190				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  2190				   TEMPORARY_VAR SET	Overlay
      5  2190				   TEMPORARY_OFFSET SET	0
      6  2190				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2190				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  2190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  21a8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  21c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  21d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  21d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  2200					      LIST	ON
      0  2200					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  2200				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2200				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2200				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  2200				   TEMPORARY_VAR SET	Overlay
      5  2200				   TEMPORARY_OFFSET SET	0
      6  2200				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2200				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  2200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2218		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2230		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2248					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  2248					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  2248					      LIST	ON
      0  2248					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  2248				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2248				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2248				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  2248				   TEMPORARY_VAR SET	Overlay
      5  2248				   TEMPORARY_OFFSET SET	0
      6  2248				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2248				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  2248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2278		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2290					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2290					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2290					      LIST	ON
      0  2290					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  2290				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2290				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2290				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  2290				   TEMPORARY_VAR SET	Overlay
      5  2290				   TEMPORARY_OFFSET SET	0
      6  2290				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2290				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  2290		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  22a8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  22c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  22d8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  22d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2300					      LIST	ON
      0  2300					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  2300				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2300				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2300				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  2300				   TEMPORARY_VAR SET	Overlay
      5  2300				   TEMPORARY_OFFSET SET	0
      6  2300				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2300				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  2300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2318		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2348					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2348					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2348					      LIST	ON
      0  2348					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  2348				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2348				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2348				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  2348				   TEMPORARY_VAR SET	Overlay
      5  2348				   TEMPORARY_OFFSET SET	0
      6  2348				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2348				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  2348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2360		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2378		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2390					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2390					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2390					      LIST	ON
      0  2390					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  2390				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2390				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2390				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  2390				   TEMPORARY_VAR SET	Overlay
      5  2390				   TEMPORARY_OFFSET SET	0
      6  2390				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2390				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  2390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  23a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  23c0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  23d8					      CHECK_BANK_SIZE	"PIECES_0 (1K)"
      1  23d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_0 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  23d8					      ECHO	"PIECES_0 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  23d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  23d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_0 (1K)", " size=", * - ORIGIN
      5  23d8				  -	      ERR
      6  23d8					      ENDIF
     19  23d8
      0  23d8					      SLOT	2
      1  23d8				  -	      IF	(2 < 0) || (2 > 3)
      2  23d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  23d8				  -	      ERR
      4  23d8					      ENDIF
      5  23d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  23d8				   _BANK_SLOT SET	2 * 64
      0  23d8					      NEWBANK	PIECES_1
      1  27d8 ????				      SEG	PIECES_1
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   PIECES_1_START SET	*
      6  2400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2400				   PIECES_1   SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2400					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2400					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  2400					      LIST	ON
      0  2400					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  2400				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2400				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2400				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  2400				   TEMPORARY_VAR SET	Overlay
      5  2400				   TEMPORARY_OFFSET SET	0
      6  2400				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2400				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  2400		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  2418		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2448					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  2448					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  2448					      LIST	ON
      0  2448					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  2448				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2448				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2448				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  2448				   TEMPORARY_VAR SET	Overlay
      5  2448				   TEMPORARY_OFFSET SET	0
      6  2448				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2448				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  2448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2460		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  2478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2490					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2490					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  2490					      LIST	ON
      0  2490					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  2490				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2490				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2490				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  2490				   TEMPORARY_VAR SET	Overlay
      5  2490				   TEMPORARY_OFFSET SET	0
      6  2490				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2490				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  2490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  24a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  24c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  24d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  24d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  2500					      LIST	ON
      0  2500					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  2500				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2500				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2500				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  2500				   TEMPORARY_VAR SET	Overlay
      5  2500				   TEMPORARY_OFFSET SET	0
      6  2500				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2500				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  2500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2530		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2548					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  2548					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  2548					      LIST	ON
      0  2548					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  2548				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2548				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2548				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  2548				   TEMPORARY_VAR SET	Overlay
      5  2548				   TEMPORARY_OFFSET SET	0
      6  2548				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2548				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  2548		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2560		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2590					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  2590					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  2590					      LIST	ON
      0  2590					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  2590				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2590				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2590				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  2590				   TEMPORARY_VAR SET	Overlay
      5  2590				   TEMPORARY_OFFSET SET	0
      6  2590				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2590				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  2590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  25a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  25c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  25d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  25d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  2600					      LIST	ON
      0  2600					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  2600				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2600				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2600				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  2600				   TEMPORARY_VAR SET	Overlay
      5  2600				   TEMPORARY_OFFSET SET	0
      6  2600				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2600				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  2600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2618		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2630		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2648					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  2648					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  2648					      LIST	ON
      0  2648					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  2648				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2648				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2648				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  2648				   TEMPORARY_VAR SET	Overlay
      5  2648				   TEMPORARY_OFFSET SET	0
      6  2648				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2648				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  2648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2678		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2690					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  2690					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  2690					      LIST	ON
      0  2690					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  2690				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2690				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2690				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  2690				   TEMPORARY_VAR SET	Overlay
      5  2690				   TEMPORARY_OFFSET SET	0
      6  2690				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2690				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  2690		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  26a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  26c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  26d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  26d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  2700					      LIST	ON
      0  2700					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  2700				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2700				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2700				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  2700				   TEMPORARY_VAR SET	Overlay
      5  2700				   TEMPORARY_OFFSET SET	0
      6  2700				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2700				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  2700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2718		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2748					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  2748					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  2748					      LIST	ON
      0  2748					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  2748				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2748				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2748				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  2748				   TEMPORARY_VAR SET	Overlay
      5  2748				   TEMPORARY_OFFSET SET	0
      6  2748				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2748				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  2748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2760		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2778		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2790					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  2790					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  2790					      LIST	ON
      0  2790					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  2790				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2790				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2790				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  2790				   TEMPORARY_VAR SET	Overlay
      5  2790				   TEMPORARY_OFFSET SET	0
      6  2790				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2790				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  2790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  27a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  27c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  27d8					      CHECK_BANK_SIZE	"PIECES_1 (1K)"
      1  27d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_1 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  27d8					      ECHO	"PIECES_1 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  27d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  27d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_1 (1K)", " size=", * - ORIGIN
      5  27d8				  -	      ERR
      6  27d8					      ENDIF
      0  27d8					      SLOT	2
      1  27d8				  -	      IF	(2 < 0) || (2 > 3)
      2  27d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  27d8				  -	      ERR
      4  27d8					      ENDIF
      5  27d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  27d8				   _BANK_SLOT SET	2 * 64
      0  27d8					      NEWBANK	PIECES_2
      1  2bd8 ????				      SEG	PIECES_2
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   PIECES_2_START SET	*
      6  2800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2800				   PIECES_2   SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2800					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  2800				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2800				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2800				   WHITE_KING_on_WHITE_SQUARE_0
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  2800		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  2818		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2848					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  2848				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2848				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2848				   WHITE_KING_on_WHITE_SQUARE_1
      4  2848				   TEMPORARY_VAR SET	Overlay
      5  2848				   TEMPORARY_OFFSET SET	0
      6  2848				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2848				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2890					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  2890				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2890				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2890				   WHITE_KING_on_WHITE_SQUARE_2
      4  2890				   TEMPORARY_VAR SET	Overlay
      5  2890				   TEMPORARY_OFFSET SET	0
      6  2890				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2890				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  28c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  28d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  2900				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2900				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2900				   WHITE_KING_on_WHITE_SQUARE_3
      4  2900				   TEMPORARY_VAR SET	Overlay
      5  2900				   TEMPORARY_OFFSET SET	0
      6  2900				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2900				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2948					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  2948				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2948				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2948				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  2948				   TEMPORARY_VAR SET	Overlay
      5  2948				   TEMPORARY_OFFSET SET	0
      6  2948				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2948				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  2948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2990					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  2990				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2990				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2990				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  2990				   TEMPORARY_VAR SET	Overlay
      5  2990				   TEMPORARY_OFFSET SET	0
      6  2990				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2990				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  29d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  2a00				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2a00				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2a00				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  2a00				   TEMPORARY_VAR SET	Overlay
      5  2a00				   TEMPORARY_OFFSET SET	0
      6  2a00				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2a00				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2a48					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  2a48				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2a48				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2a48				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  2a48				   TEMPORARY_VAR SET	Overlay
      5  2a48				   TEMPORARY_OFFSET SET	0
      6  2a48				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2a48				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2a90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  2a90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2a90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2a90				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  2a90				   TEMPORARY_VAR SET	Overlay
      5  2a90				   TEMPORARY_OFFSET SET	0
      6  2a90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2a90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  2a90		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  2aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ad8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  2b00				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2b00				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2b00				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  2b00				   TEMPORARY_VAR SET	Overlay
      5  2b00				   TEMPORARY_OFFSET SET	0
      6  2b00				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2b00				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2b48					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  2b48				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2b48				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2b48				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  2b48				   TEMPORARY_VAR SET	Overlay
      5  2b48				   TEMPORARY_OFFSET SET	0
      6  2b48				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2b48				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  2b78		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2b90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  2b90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2b90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2b90				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  2b90				   TEMPORARY_VAR SET	Overlay
      5  2b90				   TEMPORARY_OFFSET SET	0
      6  2b90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2b90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
      0  2bd8					      CHECK_BANK_SIZE	"PIECES_2 (1K)"
      1  2bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_2 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2bd8					      ECHO	"PIECES_2 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_2 (1K)", " size=", * - ORIGIN
      5  2bd8				  -	      ERR
      6  2bd8					      ENDIF
      0  2bd8					      SLOT	2
      1  2bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2bd8				  -	      ERR
      4  2bd8					      ENDIF
      5  2bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2bd8				   _BANK_SLOT SET	2 * 64
      0  2bd8					      NEWBANK	PIECES_3
      1  2fd8 ????				      SEG	PIECES_3
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   PIECES_3_START SET	*
      6  2c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2c00				   PIECES_3   SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  2c00				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2c00				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  2c00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  2c18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  2c48				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2c48				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  2c90				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2c90				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  2cc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  2d00				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2d00				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  2d48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2d48				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  2d48		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  2d60		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  2d90				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2d90				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  2e00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2e00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  2e30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  2e48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2e48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  2e90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  2e90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  2ea8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  2f00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  2f48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  2f78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  2f90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECES_3 (1K)"
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_3 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2fd8					      ECHO	"PIECES_3 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_3 (1K)", " size=", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      0  2fd8					      SLOT	2
      1  2fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2fd8				  -	      ERR
      4  2fd8					      ENDIF
      5  2fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2fd8				   _BANK_SLOT SET	2 * 64
      0  2fd8					      NEWBANK	PIECE_4
      1  33d8 ????				      SEG	PIECE_4
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   PIECE_4_START SET	*
      6  3000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3000				   PIECE_4    SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  3000				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  3000		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  3048				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  3090				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  30c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  3100				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3100				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3100				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  3148				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3148				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3148				   WHITE_KING_on_BLACK_SQUARE_0
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  3148		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  3160		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  3190				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3190				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3190				   WHITE_KING_on_BLACK_SQUARE_1
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  3200				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3200				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3200				   WHITE_KING_on_BLACK_SQUARE_2
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3230		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  3248				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3248				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3248				   WHITE_KING_on_BLACK_SQUARE_3
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  3290				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3290				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3290				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  3290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  32a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  3300				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3300				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3300				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  3348				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3348				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3348				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3378		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  3390				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3390				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3390				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
      0  33d8					      CHECK_BANK_SIZE	"PIECES_4 (1K)"
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_4 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  33d8					      ECHO	"PIECES_4 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_4 (1K)", " size=", * - ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      0  33d8					      SLOT	2
      1  33d8				  -	      IF	(2 < 0) || (2 > 3)
      2  33d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  33d8				  -	      ERR
      4  33d8					      ENDIF
      5  33d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  33d8				   _BANK_SLOT SET	2 * 64
      0  33d8					      NEWBANK	PIECE_5
      1  37d8 ????				      SEG	PIECE_5
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   PIECE_5_START SET	*
      6  3400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3400				   PIECE_5    SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  3400				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3400				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3400				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  3400		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  3418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  3448				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3448				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3448				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  3490				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3490				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3490				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  34c0		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  3500				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3500				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3500				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  3548				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3548				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3548				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  3548		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  3560		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  3590				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3590				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3590				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  3600				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3600				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3600				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  3630		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  3648				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3648				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  3690				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3690				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  3690		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  36a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  3700				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3700				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  3748				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3748				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  3778		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  3790				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3790				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECES_5 (1K)"
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_5 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  37d8					      ECHO	"PIECES_5 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_5 (1K)", " size=", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      0  37d8					      SLOT	2
      1  37d8				  -	      IF	(2 < 0) || (2 > 3)
      2  37d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  37d8				  -	      ERR
      4  37d8					      ENDIF
      5  37d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  37d8				   _BANK_SLOT SET	2 * 64
      0  37d8					      NEWBANK	PIECE_6
      1  3b90 ????				      SEG	PIECE_6
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   PIECE_6_START SET	*
      6  3800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3800				   PIECE_6    SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  3800					      LIST	ON
      0  3800					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  3800				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3800				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  3800		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  3818		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  3848					      LIST	ON
      0  3848					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  3848				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3848				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  3890					      LIST	ON
      0  3890					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  3890				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3890				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  38c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  3900					      LIST	ON
      0  3900					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  3900				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3900				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  3948					      LIST	ON
      0  3948					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  3948				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3948				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  3948		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  3990					      LIST	ON
      0  3990					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  3990				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3990				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  3a00					      LIST	ON
      0  3a00					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  3a00				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3a00				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  3a30		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  3a48					      LIST	ON
      0  3a48					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  3a48				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3a48				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  3a90					      LIST	ON
      0  3a90					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  3a90				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3a90				   BLACK_KING_on_WHITE_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  3a90		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  3aa8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  3b00					      LIST	ON
      0  3b00					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  3b00				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3b00				   BLACK_KING_on_WHITE_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  3b48					      LIST	ON
      0  3b48					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  3b48				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3b48				   BLACK_KING_on_WHITE_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3b78		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
      0  3b90					      CHECK_BANK_SIZE	"PIECES_6 (1K)"
      1  3b90		       03 90	   .TEMP      =	* - _BANK_START
 PIECES_6 (1K) (1K) SIZE =  $390 , FREE= $70
      2  3b90					      ECHO	"PIECES_6 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3b90				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3b90				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_6 (1K)", " size=", * - ORIGIN
      5  3b90				  -	      ERR
      6  3b90					      ENDIF
      0  3b90					      SLOT	2
      1  3b90				  -	      IF	(2 < 0) || (2 > 3)
      2  3b90				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3b90				  -	      ERR
      4  3b90					      ENDIF
      5  3b90				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3b90				   _BANK_SLOT SET	2 * 64
      0  3b90					      NEWBANK	PIECE_7
      1  3fd8 ????				      SEG	PIECE_7
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECE_7_START SET	*
      6  3c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3c00				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  3c00					      LIST	ON
      0  3c00					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  3c00				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3c00				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3c00				   BLACK_KING_on_WHITE_SQUARE_3
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  3c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  3c48					      LIST	ON
      0  3c48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  3c48				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3c48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3c48				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  3c90					      LIST	ON
      0  3c90					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  3c90				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3c90				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3c90				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  3d00				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3d00				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3d00				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  3d48				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3d48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3d48				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  3d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  3d90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3d90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3d90				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  3d90		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  3e00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3e00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3e00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  3e48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3e48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3e48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  3e90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3e90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3e90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  3e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  3f00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3f00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3f00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  3f00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  3f18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  3f48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3f48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3f48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  3f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3f90					      LIST	ON
      0  3f90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  3f90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3f90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3f90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  3fd8					      CHECK_BANK_SIZE	"PIECE_7 (1K)"
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_7 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3fd8					      ECHO	"PIECE_7 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_7 (1K)", " size=", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      0  3fd8					      SLOT	2
      1  3fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3fd8				  -	      ERR
      4  3fd8					      ENDIF
      5  3fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3fd8				   _BANK_SLOT SET	2 * 64
      0  3fd8					      NEWBANK	PIECE_8
      1  4048 ????				      SEG	PIECE_8
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECE_8_START SET	*
      6  4000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4000				   PIECE_8    SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  4000					      LIST	ON
      0  4000					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  4000				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4000				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4000				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  4000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
    127  4048
      0  4048					      CHECK_BANK_SIZE	"PIECES_8 (1K)"
      1  4048		       00 48	   .TEMP      =	* - _BANK_START
 PIECES_8 (1K) (1K) SIZE =  $48 , FREE= $3b8
      2  4048					      ECHO	"PIECES_8 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4048				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4048				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_8 (1K)", " size=", * - ORIGIN
      5  4048				  -	      ERR
      6  4048					      ENDIF
    129  4048
    130  4048							;    NEWBANK PIECES_5
    131  4048
    132  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    133  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    134  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    135  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    136  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    137  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    138  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    139  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    140  4048
    141  4048
    142  4048				  -	      IF	0
    143  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    144  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    145  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    146  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    147  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    148  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    149  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    150  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    151  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    152  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    153  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    154  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    155  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    156  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    157  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    158  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    159  4048					      ENDIF
    160  4048
    161  4048							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    162  4048
    163  4048				  -	      IF	0
    164  4048				  -	      NEWBANK	PIECES_6
    165  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    166  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    167  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    168  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    169  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    170  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    171  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    172  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    173  4048				  -
    174  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    175  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    176  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    177  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    178  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    179  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    180  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    181  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    182  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    183  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    184  4048				  -
    185  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    186  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    187  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    188  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    189  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    190  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    191  4048				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    192  4048				  -
    193  4048				  -
    194  4048				  -	      NEWBANK	PIECES_7
    195  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    196  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    197  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    198  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    199  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    200  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    201  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    202  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    203  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    204  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    205  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    206  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    207  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    208  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    209  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    210  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    211  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    212  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    213  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    214  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    215  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    216  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    217  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    218  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    219  4048				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    220  4048				  -
    221  4048				  -
    222  4048				  -	      NEWBANK	PIECES_8
    223  4048				  -
    224  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    225  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    226  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    227  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    228  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    229  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    230  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    231  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    232  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    233  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    234  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    235  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    236  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    237  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    238  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    239  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    240  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    241  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    242  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    243  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    244  4048				  -
    245  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    246  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    247  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    248  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    249  4048				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    250  4048				  -
    251  4048					      ENDIF
    252  4048
    253  4048							;    NEWBANK PIECES_9
    254  4048
    255  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    256  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    257  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    258  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    259  4048							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    260  4048
    261  4048				  -	      IF	0
    262  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    263  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    264  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    265  4048					      ENDIF
    266  4048
    267  4048							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    268  4048
    269  4048				  -	      IF	0
    270  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    271  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    272  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    273  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    274  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    275  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    276  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    277  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    278  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    279  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    280  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    281  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    282  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    283  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    284  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    285  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    286  4048					      ENDIF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2.asm LEVEL 2 PASS 4
      0  4048					      include	"BANK_GENERIC@2.asm"
      1  4048
      0  4048					      SLOT	2
      1  4048				  -	      IF	(2 < 0) || (2 > 3)
      2  4048				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4048				  -	      ERR
      4  4048					      ENDIF
      5  4048				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4048				   _BANK_SLOT SET	2 * 64
      0  4048					      NEWBANK	GENERIC_BANK@2
      1  4775 ????				      SEG	GENERIC_BANK@2
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   GENERIC_BANK@2_START SET	*
      6  4400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4400				   GENERIC_BANK@2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + 1024
      4  4400
      5  4400							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
      6  4400
      7  4400				  -	      IF	0
      8  4400				  -	      IF	PLUSCART = YES
      9  4400				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     10  4400				  -	      .byte	"pluscart.firmaplus.de", #0
     11  4400				  -	      ENDIF
     12  4400					      ENDIF
     13  4400
     14  4400		       54 4a 33 45 STELLA_AUTODETECT dc	"TJ3E"	; 3E+ autodetect
     15  4404
     16  4404
     17  4404							;---------------------------------------------------------------------------------------------------
     18  4404
      0  4404					      DEF	tidySc
      1  4404				   SLOT_tidySc SET	_BANK_SLOT
      2  4404				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  4404				   tidySc
      4  4404				   TEMPORARY_VAR SET	Overlay
      5  4404				   TEMPORARY_OFFSET SET	0
      6  4404				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  4404				   FUNCTION_NAME SET	tidySc
     20  4404					      SUBROUTINE
     21  4404
      0  4404					      REFER	StartupBankReset	;✅
      1  4404				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  4404				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  4404					      ENDIF
      0  4404					      VEND	tidySc
      1  4404				  -	      IFNCONST	tidySc
      2  4404				  -	      ECHO	"Incorrect VEND label", tidySc
      3  4404				  -	      ERR
      4  4404					      ENDIF
      5  4404		       00 a7	   VAREND_tidySc =	TEMPORARY_VAR
     24  4404
     25  4404		       a9 00		      lda	#0
     26  4406		       85 4d		      sta	PF0
     27  4408		       85 4e		      sta	PF1
     28  440a		       85 4f		      sta	PF2
     29  440c		       85 5b		      sta	GRP0
     30  440e		       85 5c		      sta	GRP1
     31  4410
     32  4410		       a9 42		      lda	#%01000010	; bit6 is not required
     33  4412							;sta VBLANK			  ; end of screen - enter blanking
     34  4412
     35  4412
     36  4412							; END OF VISIBLE SCREEN
     37  4412							; HERE'S SOME TIME TO DO STUFF
     38  4412
     39  4412		       a9 2e		      lda	#TIME_PART_2
     40  4414		       8d 96 02 	      sta	TIM64T
     41  4417		       60		      rts
     42  4418
     43  4418
     44  4418							;---------------------------------------------------------------------------------------------------
     45  4418
      0  4418					      DEF	longD
      1  4418				   SLOT_longD SET	_BANK_SLOT
      2  4418				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  4418				   longD
      4  4418				   TEMPORARY_VAR SET	Overlay
      5  4418				   TEMPORARY_OFFSET SET	0
      6  4418				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  4418				   FUNCTION_NAME SET	longD
     47  4418					      SUBROUTINE
     48  4418
      0  4418					      REFER	StartupBankReset	;✅
      1  4418				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  4418				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  4418					      ENDIF
      0  4418					      VEND	longD
      1  4418				  -	      IFNCONST	longD
      2  4418				  -	      ECHO	"Incorrect VEND label", longD
      3  4418				  -	      ERR
      4  4418					      ENDIF
      5  4418		       00 a7	   VAREND_longD =	TEMPORARY_VAR
     51  4418
     52  4418		       85 42		      sta	WSYNC
     53  441a
     54  441a		       20 2b f8 	      jsr	_rts
     55  441d		       20 2b f8 	      jsr	_rts
     56  4420		       20 2b f8 	      jsr	_rts
      0  4423					      SLEEP	7
      1  4423				   .CYCLES    SET	7
      2  4423
      3  4423				  -	      IF	.CYCLES < 2
      4  4423				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4423				  -	      ERR
      6  4423					      ENDIF
      7  4423
      8  4423					      IF	.CYCLES & 1
      9  4423					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4423		       04 00		      nop	0
     11  4425				  -	      ELSE
     12  4425				  -	      bit	VSYNC
     13  4425					      ENDIF
     14  4425				   .CYCLES    SET	.CYCLES - 3
     15  4425					      ENDIF
     16  4425
     17  4425					      REPEAT	.CYCLES / 2
     18  4425		       ea		      nop
     17  4425					      REPEND
     18  4426		       ea		      nop
     19  4427					      REPEND
     58  4427
     59  4427		       a2 00		      ldx	#0
     60  4429		       86 41		      stx	VBLANK
     61  442b		       60	   _rts       rts
     62  442c
     63  442c
     64  442c							;---------------------------------------------------------------------------------------------------
     65  442c
      0  442c					      DEF	aiStartClearBoard
      1  442c				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  442c				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  442c				   aiStartClearBoard
      4  442c				   TEMPORARY_VAR SET	Overlay
      5  442c				   TEMPORARY_OFFSET SET	0
      6  442c				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  442c				   FUNCTION_NAME SET	aiStartClearBoard
     67  442c					      SUBROUTINE
     68  442c
      0  442c					      REFER	AiStateMachine	;✅
      1  442c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  442c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  442c					      ENDIF
      0  442c					      VEND	aiStartClearBoard
      1  442c				  -	      IFNCONST	aiStartClearBoard
      2  442c				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  442c				  -	      ERR
      4  442c					      ENDIF
      5  442c		       00 a9	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     71  442c
     72  442c		       a2 08		      ldx	#8
     73  442e		       86 84		      stx	drawCount	; = bank
     74  4430
     75  4430		       a9 ff		      lda	#-1
     76  4432		       85 88		      sta	cursorX12
     77  4434
      0  4434					      PHASE	AI_ClearEachRow
      1  4434		       a9 0e		      lda	#AI_ClearEachRow
      2  4436		       85 8b		      sta	aiState
     79  4438		       60		      rts
     80  4439
     81  4439
     82  4439							;---------------------------------------------------------------------------------------------------
     83  4439
      0  4439					      DEF	aiClearEachRow
      1  4439				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  4439				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  4439				   aiClearEachRow
      4  4439				   TEMPORARY_VAR SET	Overlay
      5  4439				   TEMPORARY_OFFSET SET	0
      6  4439				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  4439				   FUNCTION_NAME SET	aiClearEachRow
     85  4439					      SUBROUTINE
     86  4439
      0  4439					      REFER	AiStateMachine	;✅
      1  4439					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4439				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4439					      ENDIF
      0  4439					      VEND	aiClearEachRow
      1  4439				  -	      IFNCONST	aiClearEachRow
      2  4439				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  4439				  -	      ERR
      4  4439					      ENDIF
      5  4439		       00 a9	   VAREND_aiClearEachRow =	TEMPORARY_VAR
     89  4439
     90  4439		       c6 84		      dec	drawCount
     91  443b		       30 00		      bmi	.bitmapCleared
     92  443d							;TODOldy drawCount
     93  443d							;TODO jmp CallClear
     94  443d
     95  443d				   .bitmapCleared
     96  443d
     97  443d		       a9 63		      lda	#99
     98  443f		       85 80		      sta	squareToDraw
     99  4441
      0  4441					      PHASE	AI_DrawEntireBoard
      1  4441		       a9 0f		      lda	#AI_DrawEntireBoard
      2  4443		       85 8b		      sta	aiState
    101  4445		       60		      rts
    102  4446
    103  4446
    104  4446							;---------------------------------------------------------------------------------------------------
    105  4446
      0  4446					      DEF	aiMoveIsSelected
      1  4446				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  4446				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  4446				   aiMoveIsSelected
      4  4446				   TEMPORARY_VAR SET	Overlay
      5  4446				   TEMPORARY_OFFSET SET	0
      6  4446				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  4446				   FUNCTION_NAME SET	aiMoveIsSelected
    107  4446					      SUBROUTINE
    108  4446
      0  4446					      COMMON_VARS
      1  4446
      0  4446					      VAR	__thinkbar, 1
      1  4446		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__toggle, 1
      1  4446		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      4  4446
      0  4446					      VAR	__bestMove, 1
      1  4446		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__alpha, 2
      1  4446		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__beta, 2
      1  4446		       00 ac	   __beta     =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__negaMax, 2
      1  4446		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__value, 2
      1  4446		       00 b0	   __value    =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
     10  4446
      0  4446					      VAR	__quiesceCapOnly, 1
      1  4446		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
     12  4446
      0  4446					      VAR	__originalPiece, 1
      1  4446		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__capturedPiece, 1
      1  4446		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
     15  4446
      0  4446					      REFER	AiStateMachine	;✅
      1  4446				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4446				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4446					      ENDIF
      0  4446					      VEND	aiMoveIsSelected
      1  4446				  -	      IFNCONST	aiMoveIsSelected
      2  4446				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  4446				  -	      ERR
      4  4446					      ENDIF
      5  4446		       00 b5	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    112  4446
    113  4446							; Both computer and human have now seleted a move, and converge here
    114  4446
    115  4446
    116  4446							; fromPiece	 piece doing the move
    117  4446							; fromX12	 current square X12
    118  4446							; originX12	 starting square X12
    119  4446							; toX12	 ending square X12
    120  4446
    121  4446							; get the piece types from the board
    122  4446
    123  4446		       a9 d1		      lda	#RAMBANK_BOARD
    124  4448		       85 3e		      sta	SET_BANK_RAM	;@3
    125  444a		       a4 87		      ldy	originX12
    126  444c		       b9 79 fc 	      lda	Board,y
    127  444f		       85 b3		      sta	__originalPiece
    128  4451		       a4 86		      ldy	toX12
    129  4453		       b9 79 fc 	      lda	Board,y
    130  4456		       85 b4		      sta	__capturedPiece
    131  4458
    132  4458
    133  4458		       20 c5 f8 	      jsr	AdjustMaterialPositionalValue	;@this
    134  445b
    135  445b		       a9 00		      lda	#0
    136  445d		       85 98		      sta	previousPiece
    137  445f		       85 82		      sta	drawDelay
    138  4461
    139  4461		       a9 0a		      lda	#10	; on/off count
    140  4463		       85 84		      sta	drawCount	; flashing for piece about to move
    141  4465
      0  4465					      PHASE	AI_WriteStartPieceBlank
      1  4465		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  4467		       85 8b		      sta	aiState
    143  4469		       60	   .idleErase rts
    144  446a
    145  446a
    146  446a							;---------------------------------------------------------------------------------------------------
    147  446a
      0  446a					      DEF	CopySetup
      1  446a				   SLOT_CopySetup SET	_BANK_SLOT
      2  446a				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  446a				   CopySetup
      4  446a				   TEMPORARY_VAR SET	Overlay
      5  446a				   TEMPORARY_OFFSET SET	0
      6  446a				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  446a				   FUNCTION_NAME SET	CopySetup
    149  446a					      SUBROUTINE
    150  446a
      0  446a					      REFER	CopySinglePiece	;✅
      1  446a					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  446a				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  446a					      ENDIF
    152  446a
      0  446a					      VAR	__tmp, 1
      1  446a		       00 ac	   __tmp      =	TEMPORARY_VAR
      2  446a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  446a
      4  446a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  446a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  446a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  446a					      ENDIF
      8  446a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  446a				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  446a				  -	      ERR
     11  446a					      ENDIF
     12  446a					      LIST	ON
      0  446a					      VAR	__shiftx, 1
      1  446a		       00 ad	   __shiftx   =	TEMPORARY_VAR
      2  446a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  446a
      4  446a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  446a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  446a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  446a					      ENDIF
      8  446a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  446a				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  446a				  -	      ERR
     11  446a					      ENDIF
     12  446a					      LIST	ON
      0  446a					      VAR	__pieceColour2, 1
      1  446a		       00 ae	   __pieceColour2 =	TEMPORARY_VAR
      2  446a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  446a
      4  446a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  446a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  446a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  446a					      ENDIF
      8  446a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  446a				  -	      ECHO	"Temporary Variable", __pieceColour2, "overflow!"
     10  446a				  -	      ERR
     11  446a					      ENDIF
     12  446a					      LIST	ON
    156  446a
      0  446a					      VEND	CopySetup
      1  446a				  -	      IFNCONST	CopySetup
      2  446a				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  446a				  -	      ERR
      4  446a					      ENDIF
      5  446a		       00 af	   VAREND_CopySetup =	TEMPORARY_VAR
    158  446a
    159  446a							; figure colouration of square
    160  446a
    161  446a		       a5 80		      lda	squareToDraw
    162  446c
    163  446c					      IF	DIAGNOSTICS
    164  446c							; Catch out-of-range piece square
    165  446c							; will not catch off left/right edge
    166  446c
    167  446c		       c9 64	   .fail      cmp	#100
    168  446e		       b0 fc		      bcs	.fail
    169  4470		       c9 16		      cmp	#22
    170  4472		       90 f8		      bcc	.fail
    171  4474					      ENDIF
    172  4474
    173  4474
    174  4474		       a2 0a		      ldx	#10
    175  4476		       38		      sec
    176  4477		       e9 0a	   .sub10     sbc	#10
    177  4479		       ca		      dex
    178  447a		       b0 fb		      bcs	.sub10
    179  447c		       69 08		      adc	#8
    180  447e		       85 ad		      sta	__shiftx
    181  4480					      IF	DIAGNOSTICS
    182  4480		       c9 08	   .fail2     cmp	#8
    183  4482		       b0 fc		      bcs	.fail2
    184  4484		       e0 08		      cpx	#8
    185  4486		       b0 f8		      bcs	.fail2
    186  4488					      ENDIF
    187  4488		       86 ac		      stx	__tmp
    188  448a		       65 ac		      adc	__tmp
    189  448c
    190  448c
    191  448c		       29 01		      and	#1
    192  448e		       49 01		      eor	#1
    193  4490		       f0 02		      beq	.white
    194  4492		       a9 24		      lda	#36
    195  4494				   .white
    196  4494		       85 ae		      sta	__pieceColour2	; actually SQUARE black/white
    197  4496
    198  4496							; PieceColour = 0 for white square, 36 for black square
    199  4496
    200  4496		       a9 d1		      lda	#RAMBANK_BOARD
    201  4498		       85 3e		      sta	SET_BANK_RAM	;@3
    202  449a
    203  449a		       a4 80		      ldy	squareToDraw
    204  449c		       b9 79 fc 	      lda	Board,y
    205  449f							;and #$87
    206  449f		       0a		      asl
    207  44a0		       90 02		      bcc	.blackAdjust
    208  44a2		       09 10		      ora	#16	; switch white pieces
    209  44a4		       4a	   .blackAdjust lsr
    210  44a5		       29 0f		      and	#%1111
    211  44a7		       aa		      tax
    212  44a8
    213  44a8		       a5 ad		      lda	__shiftx
    214  44aa		       29 03		      and	#3	; shift position in P
    215  44ac
    216  44ac		       18		      clc
    217  44ad		       7d b5 f8 	      adc	PieceToShape,x
    218  44b0		       18		      clc
    219  44b1		       65 ae		      adc	__pieceColour2
    220  44b3		       a8		      tay
    221  44b4		       60		      rts
    222  44b5
    223  44b5				   PieceToShape
    224  44b5
    225  44b5		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    226  44b6		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    227  44b7		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    228  44b8		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    229  44b9		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    230  44ba		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    231  44bb		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    232  44bc		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    233  44bd
    234  44bd		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    235  44be		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    236  44bf		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    237  44c0		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    238  44c1		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    239  44c2		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    240  44c3		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    241  44c4		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    242  44c5
    243  44c5
    244  44c5							;---------------------------------------------------------------------------------------------------
    245  44c5
      0  44c5					      DEF	AdjustMaterialPositionalValue
      1  44c5				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  44c5				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  44c5				   AdjustMaterialPositionalValue
      4  44c5				   TEMPORARY_VAR SET	Overlay
      5  44c5				   TEMPORARY_OFFSET SET	0
      6  44c5				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  44c5				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    247  44c5					      SUBROUTINE
    248  44c5
    249  44c5							; A move is about to be made, so  adjust material and positional values based on from/to and
    250  44c5							; capture.
    251  44c5
    252  44c5							; First, nominate referencing subroutines so that local variables can be adjusted properly
    253  44c5
      0  44c5					      COMMON_VARS
      1  44c5
      0  44c5					      VAR	__thinkbar, 1
      1  44c5		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__toggle, 1
      1  44c5		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      4  44c5
      0  44c5					      VAR	__bestMove, 1
      1  44c5		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__alpha, 2
      1  44c5		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__beta, 2
      1  44c5		       00 ac	   __beta     =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__negaMax, 2
      1  44c5		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__value, 2
      1  44c5		       00 b0	   __value    =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
     10  44c5
      0  44c5					      VAR	__quiesceCapOnly, 1
      1  44c5		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
     12  44c5
      0  44c5					      VAR	__originalPiece, 1
      1  44c5		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__capturedPiece, 1
      1  44c5		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
     15  44c5
      0  44c5					      REFER	MakeMove	;✅
      1  44c5				  -	      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  44c5				  -TEMPORARY_VAR SET	VAREND_MakeMove
      3  44c5					      ENDIF
      0  44c5					      REFER	aiMoveIsSelected	;✅
      1  44c5				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  44c5				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  44c5					      ENDIF
      0  44c5					      VEND	AdjustMaterialPositionalValue
      1  44c5				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  44c5				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  44c5				  -	      ERR
      4  44c5					      ENDIF
      5  44c5		       00 b5	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    258  44c5
    259  44c5							; fromPiece	 piece doing the move (promoted type)
    260  44c5							; fromX12	 current square
    261  44c5							; originX12	 starting square
    262  44c5							; toX12	 ending square
    263  44c5
    264  44c5
    265  44c5							; {
    266  44c5							;   adjust the positional value  (originX12 --> fromX12)
    267  44c5
    268  44c5		       a4 86		      ldy	toX12	; already loaded
    269  44c7		       a5 96		      lda	fromPiece
    270  44c9		       20 34 f9 	      jsr	AddPiecePositionValue	; add pos value for new position
    271  44cc
    272  44cc
    273  44cc		       a5 b3		      lda	__originalPiece
    274  44ce		       45 96		      eor	fromPiece	; the new piece
    275  44d0		       29 0f		      and	#PIECE_MASK
    276  44d2		       f0 05		      beq	.same1	; unchanged, so skip
    277  44d4
    278  44d4		       a5 96		      lda	fromPiece	; new piece
    279  44d6		       20 11 f9 	      jsr	AddPieceMaterialValue
    280  44d9
    281  44d9				   .same1
    282  44d9
    283  44d9							; and now the 'subtracts'
    284  44d9
      0  44d9					      NEGEVAL
      1  44d9
      2  44d9		       38		      sec
      3  44da		       a9 00		      lda	#0
      4  44dc		       e5 8f		      sbc	Evaluation
      5  44de		       85 8f		      sta	Evaluation
      6  44e0		       a9 00		      lda	#0
      7  44e2		       e5 90		      sbc	Evaluation+1
      8  44e4		       85 90		      sta	Evaluation+1
    286  44e6
    287  44e6		       a4 87		      ldy	originX12
    288  44e8		       a5 b3		      lda	__originalPiece
    289  44ea		       20 34 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    290  44ed
    291  44ed
    292  44ed		       a5 b3		      lda	__originalPiece
    293  44ef		       45 96		      eor	fromPiece	; the new piece
    294  44f1		       29 0f		      and	#PIECE_MASK
    295  44f3		       f0 05		      beq	.same2	; unchanged, so skip
    296  44f5
    297  44f5		       a5 b3		      lda	__originalPiece
    298  44f7		       20 11 f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    299  44fa				   .same2
    300  44fa
      0  44fa					      NEGEVAL
      1  44fa
      2  44fa		       38		      sec
      3  44fb		       a9 00		      lda	#0
      4  44fd		       e5 8f		      sbc	Evaluation
      5  44ff		       85 8f		      sta	Evaluation
      6  4501		       a9 00		      lda	#0
      7  4503		       e5 90		      sbc	Evaluation+1
      8  4505		       85 90		      sta	Evaluation+1
    302  4507
    303  4507							; If there's a capture, we adjust the material value
    304  4507
    305  4507							;		      lda __capturedPiece
    306  4507							;		      eor __originalPiece
    307  4507							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    308  4507
    309  4507
    310  4507		       a5 b4		      lda	__capturedPiece
    311  4509		       29 0f		      and	#PIECE_MASK
    312  450b		       f0 03		      beq	.noCapture
    313  450d		       20 11 f9 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    314  4510				   .noCapture
    315  4510
    316  4510							; }
    317  4510		       60		      rts
    318  4511
    319  4511
    320  4511							;---------------------------------------------------------------------------------------------------
    321  4511
      0  4511					      DEF	AddPieceMaterialValue
      1  4511				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  4511				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  4511				   AddPieceMaterialValue
      4  4511				   TEMPORARY_VAR SET	Overlay
      5  4511				   TEMPORARY_OFFSET SET	0
      6  4511				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  4511				   FUNCTION_NAME SET	AddPieceMaterialValue
    323  4511					      SUBROUTINE
    324  4511
      0  4511					      COMMON_VARS
      1  4511
      0  4511					      VAR	__thinkbar, 1
      1  4511		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__toggle, 1
      1  4511		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      4  4511
      0  4511					      VAR	__bestMove, 1
      1  4511		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__alpha, 2
      1  4511		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__beta, 2
      1  4511		       00 ac	   __beta     =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__negaMax, 2
      1  4511		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__value, 2
      1  4511		       00 b0	   __value    =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
     10  4511
      0  4511					      VAR	__quiesceCapOnly, 1
      1  4511		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
     12  4511
      0  4511					      VAR	__originalPiece, 1
      1  4511		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__capturedPiece, 1
      1  4511		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
     15  4511
      0  4511					      REFER	InitialisePieceSquares	;✅
      1  4511					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  4511					      ENDIF
      0  4511					      REFER	AdjustMaterialPositionalValue	;✅
      1  4511				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  4511				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  4511					      ENDIF
    328  4511							;REFER EnPassantRemovePiece ;✅
      0  4511					      VEND	AddPieceMaterialValue
      1  4511				  -	      IFNCONST	AddPieceMaterialValue
      2  4511				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  4511				  -	      ERR
      4  4511					      ENDIF
      5  4511		       00 b9	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
    330  4511
    331  4511							; Adjust the material score based on the piece
    332  4511							; a = piece type + flags
    333  4511
    334  4511		       29 0f		      and	#PIECE_MASK
    335  4513		       a8		      tay
    336  4514
    337  4514		       18		      clc
    338  4515		       b9 24 f9 	      lda	PieceValueLO,y
    339  4518		       65 8f		      adc	Evaluation
    340  451a		       85 8f		      sta	Evaluation
    341  451c		       b9 2c f9 	      lda	PieceValueHI,y
    342  451f		       65 90		      adc	Evaluation+1
    343  4521		       85 90		      sta	Evaluation+1
    344  4523		       60		      rts
    345  4524
    346  4524
    347  4524					      MAC	valuetable
    348  4524					      .byte	{1}0	; blank
    349  4524					      .byte	{1}100	; white P
    350  4524					      .byte	{1}100	; black P
    351  4524					      .byte	{1}320	; N
    352  4524					      .byte	{1}375	; B
    353  4524					      .byte	{1}575	; R
    354  4524					      .byte	{1}900	; Q
    355  4524					      .byte	{1}10000	; K
    356  4524					      ENDM
    357  4524
    358  4524				   PieceValueLO
      0  4524					      VALUETABLE	<
      1  4524		       00		      .byte.b	<0
      2  4525		       64		      .byte.b	<100
      3  4526		       64		      .byte.b	<100
      4  4527		       40		      .byte.b	<320
      5  4528		       77		      .byte.b	<375
      6  4529		       3f		      .byte.b	<575
      7  452a		       84		      .byte.b	<900
      8  452b		       10		      .byte.b	<10000
    360  452c
    361  452c				   PieceValueHI
      0  452c					      VALUETABLE	>
      1  452c		       00		      .byte.b	>0
      2  452d		       00		      .byte.b	>100
      3  452e		       00		      .byte.b	>100
      4  452f		       01		      .byte.b	>320
      5  4530		       01		      .byte.b	>375
      6  4531		       02		      .byte.b	>575
      7  4532		       03		      .byte.b	>900
      8  4533		       27		      .byte.b	>10000
    363  4534
    364  4534
    365  4534							;---------------------------------------------------------------------------------------------------
    366  4534
      0  4534					      DEF	AddPiecePositionValue
      1  4534				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  4534				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  4534				   AddPiecePositionValue
      4  4534				   TEMPORARY_VAR SET	Overlay
      5  4534				   TEMPORARY_OFFSET SET	0
      6  4534				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  4534				   FUNCTION_NAME SET	AddPiecePositionValue
    368  4534					      SUBROUTINE
    369  4534
      0  4534					      REFER	InitialisePieceSquares	;✅
      1  4534					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  4534				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  4534					      ENDIF
      0  4534					      REFER	AdjustMaterialPositionalValue	;✅
      1  4534				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  4534				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  4534					      ENDIF
    372  4534							;REFER EnPassantRemovePiece ;✅
      0  4534					      VAR	__valPtr, 2
      1  4534		       00 b9	   __valPtr   =	TEMPORARY_VAR
      2  4534				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4534
      4  4534				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4534					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4534				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4534					      ENDIF
      8  4534				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4534				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  4534				  -	      ERR
     11  4534					      ENDIF
     12  4534					      LIST	ON
      0  4534					      VEND	AddPiecePositionValue
      1  4534				  -	      IFNCONST	AddPiecePositionValue
      2  4534				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  4534				  -	      ERR
      4  4534					      ENDIF
      5  4534		       00 bb	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    375  4534
    376  4534
    377  4534							; adds value of square piece is on to the evaluation
    378  4534							; note to do the subtraction as -( -x + val) == x - val
    379  4534
    380  4534							; y = square
    381  4534							; a = piece type (+flags)
    382  4534
    383  4534
    384  4534
    385  4534		       c9 80		      cmp	#128	; black = CS
    386  4536		       29 0f		      and	#PIECE_MASK
    387  4538		       aa		      tax
    388  4539
    389  4539		       a9 c5		      lda	#EVAL
    390  453b		       85 3f		      sta	SET_BANK	;@3
    391  453d
    392  453d							; black pieces flip rows so we can use the same eval tables
    393  453d
    394  453d		       98		      tya
    395  453e		       90 03		      bcc	.white
    396  4540		       b9 61 f9 	      lda	FlipSquareIndex,y
    397  4543							;clc
    398  4543				   .white
    399  4543		       7d 00 fc 	      adc	PosValVecLO,x
    400  4546		       85 b9		      sta	__valPtr
    401  4548		       bd 08 fc 	      lda	PosValVecHI,x
    402  454b		       69 00		      adc	#0
    403  454d		       85 ba		      sta	__valPtr+1
    404  454f
    405  454f		       a0 00		      ldy	#0
    406  4551		       b1 b9		      lda	(__valPtr),y
    407  4553		       10 01		      bpl	.sum
    408  4555		       88		      dey
    409  4556
    410  4556		       18	   .sum       clc
    411  4557		       65 8f		      adc	Evaluation
    412  4559		       85 8f		      sta	Evaluation
    413  455b		       98		      tya
    414  455c		       65 90		      adc	Evaluation+1
    415  455e		       85 90		      sta	Evaluation+1
    416  4560		       60		      rts
    417  4561
    418  4561
    419  4561				   FlipSquareIndex
    420  4561
    421  4561		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    422  456b		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    423  4575
    424  4575				   .SQBASE    SET	90-1
    425  4575					      REPEAT	8
    426  4575		       00 00		      .byte.b	0,0
    427  4575				   .SQX       SET	2
    428  4577					      REPEAT	8
    429  4577		       5b		      .byte.b	(.SQBASE+.SQX)
    430  4577				   .SQX       SET	.SQX + 1
    428  4577					      REPEND
    429  4578		       5c		      .byte.b	(.SQBASE+.SQX)
    430  4578				   .SQX       SET	.SQX + 1
    428  4578					      REPEND
    429  4579		       5d		      .byte.b	(.SQBASE+.SQX)
    430  4579				   .SQX       SET	.SQX + 1
    428  4579					      REPEND
    429  457a		       5e		      .byte.b	(.SQBASE+.SQX)
    430  457a				   .SQX       SET	.SQX + 1
    428  457a					      REPEND
    429  457b		       5f		      .byte.b	(.SQBASE+.SQX)
    430  457b				   .SQX       SET	.SQX + 1
    428  457b					      REPEND
    429  457c		       60		      .byte.b	(.SQBASE+.SQX)
    430  457c				   .SQX       SET	.SQX + 1
    428  457c					      REPEND
    429  457d		       61		      .byte.b	(.SQBASE+.SQX)
    430  457d				   .SQX       SET	.SQX + 1
    428  457d					      REPEND
    429  457e		       62		      .byte.b	(.SQBASE+.SQX)
    430  457e				   .SQX       SET	.SQX + 1
    431  457f					      REPEND
    432  457f				   .SQBASE    SET	.SQBASE - 10
    425  457f					      REPEND
    426  457f		       00 00		      .byte.b	0,0
    427  457f				   .SQX       SET	2
    428  4581					      REPEAT	8
    429  4581		       51		      .byte.b	(.SQBASE+.SQX)
    430  4581				   .SQX       SET	.SQX + 1
    428  4581					      REPEND
    429  4582		       52		      .byte.b	(.SQBASE+.SQX)
    430  4582				   .SQX       SET	.SQX + 1
    428  4582					      REPEND
    429  4583		       53		      .byte.b	(.SQBASE+.SQX)
    430  4583				   .SQX       SET	.SQX + 1
    428  4583					      REPEND
    429  4584		       54		      .byte.b	(.SQBASE+.SQX)
    430  4584				   .SQX       SET	.SQX + 1
    428  4584					      REPEND
    429  4585		       55		      .byte.b	(.SQBASE+.SQX)
    430  4585				   .SQX       SET	.SQX + 1
    428  4585					      REPEND
    429  4586		       56		      .byte.b	(.SQBASE+.SQX)
    430  4586				   .SQX       SET	.SQX + 1
    428  4586					      REPEND
    429  4587		       57		      .byte.b	(.SQBASE+.SQX)
    430  4587				   .SQX       SET	.SQX + 1
    428  4587					      REPEND
    429  4588		       58		      .byte.b	(.SQBASE+.SQX)
    430  4588				   .SQX       SET	.SQX + 1
    431  4589					      REPEND
    432  4589				   .SQBASE    SET	.SQBASE - 10
    425  4589					      REPEND
    426  4589		       00 00		      .byte.b	0,0
    427  4589				   .SQX       SET	2
    428  458b					      REPEAT	8
    429  458b		       47		      .byte.b	(.SQBASE+.SQX)
    430  458b				   .SQX       SET	.SQX + 1
    428  458b					      REPEND
    429  458c		       48		      .byte.b	(.SQBASE+.SQX)
    430  458c				   .SQX       SET	.SQX + 1
    428  458c					      REPEND
    429  458d		       49		      .byte.b	(.SQBASE+.SQX)
    430  458d				   .SQX       SET	.SQX + 1
    428  458d					      REPEND
    429  458e		       4a		      .byte.b	(.SQBASE+.SQX)
    430  458e				   .SQX       SET	.SQX + 1
    428  458e					      REPEND
    429  458f		       4b		      .byte.b	(.SQBASE+.SQX)
    430  458f				   .SQX       SET	.SQX + 1
    428  458f					      REPEND
    429  4590		       4c		      .byte.b	(.SQBASE+.SQX)
    430  4590				   .SQX       SET	.SQX + 1
    428  4590					      REPEND
    429  4591		       4d		      .byte.b	(.SQBASE+.SQX)
    430  4591				   .SQX       SET	.SQX + 1
    428  4591					      REPEND
    429  4592		       4e		      .byte.b	(.SQBASE+.SQX)
    430  4592				   .SQX       SET	.SQX + 1
    431  4593					      REPEND
    432  4593				   .SQBASE    SET	.SQBASE - 10
    425  4593					      REPEND
    426  4593		       00 00		      .byte.b	0,0
    427  4593				   .SQX       SET	2
    428  4595					      REPEAT	8
    429  4595		       3d		      .byte.b	(.SQBASE+.SQX)
    430  4595				   .SQX       SET	.SQX + 1
    428  4595					      REPEND
    429  4596		       3e		      .byte.b	(.SQBASE+.SQX)
    430  4596				   .SQX       SET	.SQX + 1
    428  4596					      REPEND
    429  4597		       3f		      .byte.b	(.SQBASE+.SQX)
    430  4597				   .SQX       SET	.SQX + 1
    428  4597					      REPEND
    429  4598		       40		      .byte.b	(.SQBASE+.SQX)
    430  4598				   .SQX       SET	.SQX + 1
    428  4598					      REPEND
    429  4599		       41		      .byte.b	(.SQBASE+.SQX)
    430  4599				   .SQX       SET	.SQX + 1
    428  4599					      REPEND
    429  459a		       42		      .byte.b	(.SQBASE+.SQX)
    430  459a				   .SQX       SET	.SQX + 1
    428  459a					      REPEND
    429  459b		       43		      .byte.b	(.SQBASE+.SQX)
    430  459b				   .SQX       SET	.SQX + 1
    428  459b					      REPEND
    429  459c		       44		      .byte.b	(.SQBASE+.SQX)
    430  459c				   .SQX       SET	.SQX + 1
    431  459d					      REPEND
    432  459d				   .SQBASE    SET	.SQBASE - 10
    425  459d					      REPEND
    426  459d		       00 00		      .byte.b	0,0
    427  459d				   .SQX       SET	2
    428  459f					      REPEAT	8
    429  459f		       33		      .byte.b	(.SQBASE+.SQX)
    430  459f				   .SQX       SET	.SQX + 1
    428  459f					      REPEND
    429  45a0		       34		      .byte.b	(.SQBASE+.SQX)
    430  45a0				   .SQX       SET	.SQX + 1
    428  45a0					      REPEND
    429  45a1		       35		      .byte.b	(.SQBASE+.SQX)
    430  45a1				   .SQX       SET	.SQX + 1
    428  45a1					      REPEND
    429  45a2		       36		      .byte.b	(.SQBASE+.SQX)
    430  45a2				   .SQX       SET	.SQX + 1
    428  45a2					      REPEND
    429  45a3		       37		      .byte.b	(.SQBASE+.SQX)
    430  45a3				   .SQX       SET	.SQX + 1
    428  45a3					      REPEND
    429  45a4		       38		      .byte.b	(.SQBASE+.SQX)
    430  45a4				   .SQX       SET	.SQX + 1
    428  45a4					      REPEND
    429  45a5		       39		      .byte.b	(.SQBASE+.SQX)
    430  45a5				   .SQX       SET	.SQX + 1
    428  45a5					      REPEND
    429  45a6		       3a		      .byte.b	(.SQBASE+.SQX)
    430  45a6				   .SQX       SET	.SQX + 1
    431  45a7					      REPEND
    432  45a7				   .SQBASE    SET	.SQBASE - 10
    425  45a7					      REPEND
    426  45a7		       00 00		      .byte.b	0,0
    427  45a7				   .SQX       SET	2
    428  45a9					      REPEAT	8
    429  45a9		       29		      .byte.b	(.SQBASE+.SQX)
    430  45a9				   .SQX       SET	.SQX + 1
    428  45a9					      REPEND
    429  45aa		       2a		      .byte.b	(.SQBASE+.SQX)
    430  45aa				   .SQX       SET	.SQX + 1
    428  45aa					      REPEND
    429  45ab		       2b		      .byte.b	(.SQBASE+.SQX)
    430  45ab				   .SQX       SET	.SQX + 1
    428  45ab					      REPEND
    429  45ac		       2c		      .byte.b	(.SQBASE+.SQX)
    430  45ac				   .SQX       SET	.SQX + 1
    428  45ac					      REPEND
    429  45ad		       2d		      .byte.b	(.SQBASE+.SQX)
    430  45ad				   .SQX       SET	.SQX + 1
    428  45ad					      REPEND
    429  45ae		       2e		      .byte.b	(.SQBASE+.SQX)
    430  45ae				   .SQX       SET	.SQX + 1
    428  45ae					      REPEND
    429  45af		       2f		      .byte.b	(.SQBASE+.SQX)
    430  45af				   .SQX       SET	.SQX + 1
    428  45af					      REPEND
    429  45b0		       30		      .byte.b	(.SQBASE+.SQX)
    430  45b0				   .SQX       SET	.SQX + 1
    431  45b1					      REPEND
    432  45b1				   .SQBASE    SET	.SQBASE - 10
    425  45b1					      REPEND
    426  45b1		       00 00		      .byte.b	0,0
    427  45b1				   .SQX       SET	2
    428  45b3					      REPEAT	8
    429  45b3		       1f		      .byte.b	(.SQBASE+.SQX)
    430  45b3				   .SQX       SET	.SQX + 1
    428  45b3					      REPEND
    429  45b4		       20		      .byte.b	(.SQBASE+.SQX)
    430  45b4				   .SQX       SET	.SQX + 1
    428  45b4					      REPEND
    429  45b5		       21		      .byte.b	(.SQBASE+.SQX)
    430  45b5				   .SQX       SET	.SQX + 1
    428  45b5					      REPEND
    429  45b6		       22		      .byte.b	(.SQBASE+.SQX)
    430  45b6				   .SQX       SET	.SQX + 1
    428  45b6					      REPEND
    429  45b7		       23		      .byte.b	(.SQBASE+.SQX)
    430  45b7				   .SQX       SET	.SQX + 1
    428  45b7					      REPEND
    429  45b8		       24		      .byte.b	(.SQBASE+.SQX)
    430  45b8				   .SQX       SET	.SQX + 1
    428  45b8					      REPEND
    429  45b9		       25		      .byte.b	(.SQBASE+.SQX)
    430  45b9				   .SQX       SET	.SQX + 1
    428  45b9					      REPEND
    429  45ba		       26		      .byte.b	(.SQBASE+.SQX)
    430  45ba				   .SQX       SET	.SQX + 1
    431  45bb					      REPEND
    432  45bb				   .SQBASE    SET	.SQBASE - 10
    425  45bb					      REPEND
    426  45bb		       00 00		      .byte.b	0,0
    427  45bb				   .SQX       SET	2
    428  45bd					      REPEAT	8
    429  45bd		       15		      .byte.b	(.SQBASE+.SQX)
    430  45bd				   .SQX       SET	.SQX + 1
    428  45bd					      REPEND
    429  45be		       16		      .byte.b	(.SQBASE+.SQX)
    430  45be				   .SQX       SET	.SQX + 1
    428  45be					      REPEND
    429  45bf		       17		      .byte.b	(.SQBASE+.SQX)
    430  45bf				   .SQX       SET	.SQX + 1
    428  45bf					      REPEND
    429  45c0		       18		      .byte.b	(.SQBASE+.SQX)
    430  45c0				   .SQX       SET	.SQX + 1
    428  45c0					      REPEND
    429  45c1		       19		      .byte.b	(.SQBASE+.SQX)
    430  45c1				   .SQX       SET	.SQX + 1
    428  45c1					      REPEND
    429  45c2		       1a		      .byte.b	(.SQBASE+.SQX)
    430  45c2				   .SQX       SET	.SQX + 1
    428  45c2					      REPEND
    429  45c3		       1b		      .byte.b	(.SQBASE+.SQX)
    430  45c3				   .SQX       SET	.SQX + 1
    428  45c3					      REPEND
    429  45c4		       1c		      .byte.b	(.SQBASE+.SQX)
    430  45c4				   .SQX       SET	.SQX + 1
    431  45c5					      REPEND
    432  45c5				   .SQBASE    SET	.SQBASE - 10
    433  45c5					      REPEND
    434  45c5
    435  45c5							;---------------------------------------------------------------------------------------------------
    436  45c5
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  45c5					      include	"piece_vectors.asm"
      1  45c5							; Created by ConvertChessPieces.py
      0  45c5					      DEF	PIECE_VECTOR_LO
      1  45c5				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  45c5				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  45c5				   PIECE_VECTOR_LO
      4  45c5				   TEMPORARY_VAR SET	Overlay
      5  45c5				   TEMPORARY_OFFSET SET	0
      6  45c5				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  45c5				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  45c5		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  45c6		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  45c7		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  45c8		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  45c9		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  45ca		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  45cb		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  45cc		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  45cd		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  45ce		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  45cf		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  45d0		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  45d1		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  45d2		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  45d3		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  45d4		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  45d5		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  45d6		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  45d7		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  45d8		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  45d9		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  45da		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  45db		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  45dc		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  45dd		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  45de		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  45df		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  45e0		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  45e1		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  45e2		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  45e3		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  45e4		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  45e5		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  45e6		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  45e7		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  45e8		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  45e9		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  45ea		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  45eb		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  45ec		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  45ed		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  45ee		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  45ef		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  45f0		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  45f1		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  45f2		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  45f3		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  45f4		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  45f5		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  45f6		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  45f7		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  45f8		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  45f9		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  45fa		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  45fb		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  45fc		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  45fd		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  45fe		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  45ff		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  4600		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  4601		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  4602		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  4603		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  4604		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  4605		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  4606		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  4607		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  4608		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  4609		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  460a		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  460b		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  460c		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  460d		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  460e		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  460f		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  4610		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  4611		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  4612		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  4613		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  4614		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  4615		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  4616		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  4617		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  4618		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  4619		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  461a		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  461b		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  461c		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  461d		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  461e		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  461f		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  4620		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  4621		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  4622		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  4623		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  4624		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  4625		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  4626		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  4627		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  4628		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  4629		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  462a		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  462b		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  462c		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  462d		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  462e		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  462f		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  4630		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  4631		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  4632		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  4633		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  4634		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  4635		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  4636		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  4637		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  4638		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  4639		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  463a		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  463b		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  463c		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  463d		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  463e		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  463f		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  4640		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  4641		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  4642		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  4643		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  4644		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  4645		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  4646		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  4647		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  4648		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  4649		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  464a		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  464b		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  464c		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  464d		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  464e		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  464f		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  4650		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  4651		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  4652		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  4653		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  4654		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  4655					      DEF	PIECE_VECTOR_HI
      1  4655				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  4655				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  4655				   PIECE_VECTOR_HI
      4  4655				   TEMPORARY_VAR SET	Overlay
      5  4655				   TEMPORARY_OFFSET SET	0
      6  4655				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  4655				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  4655		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  4656		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  4657		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  4658		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  4659		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  465a		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  465b		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  465c		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  465d		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  465e		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  465f		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  4660		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  4661		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  4662		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  4663		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  4664		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  4665		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  4666		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  4667		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  4668		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  4669		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  466a		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  466b		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  466c		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  466d		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  466e		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  466f		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  4670		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  4671		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  4672		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  4673		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  4674		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  4675		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  4676		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  4677		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  4678		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  4679		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  467a		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  467b		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  467c		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  467d		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  467e		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  467f		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  4680		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  4681		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  4682		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  4683		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  4684		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  4685		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  4686		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  4687		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  4688		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  4689		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  468a		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  468b		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  468c		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  468d		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  468e		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  468f		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  4690		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  4691		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  4692		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  4693		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  4694		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  4695		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  4696		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  4697		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  4698		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  4699		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  469a		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  469b		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  469c		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  469d		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  469e		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  469f		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  46a0		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  46a1		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  46a2		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  46a3		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  46a4		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  46a5		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  46a6		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  46a7		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  46a8		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  46a9		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  46aa		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  46ab		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  46ac		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  46ad		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  46ae		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  46af		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  46b0		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  46b1		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  46b2		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  46b3		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  46b4		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  46b5		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  46b6		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  46b7		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  46b8		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  46b9		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  46ba		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  46bb		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  46bc		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  46bd		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  46be		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  46bf		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  46c0		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  46c1		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  46c2		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  46c3		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  46c4		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  46c5		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  46c6		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  46c7		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  46c8		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  46c9		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  46ca		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  46cb		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  46cc		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  46cd		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  46ce		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  46cf		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  46d0		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  46d1		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  46d2		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  46d3		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  46d4		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  46d5		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  46d6		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  46d7		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  46d8		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  46d9		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  46da		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  46db		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  46dc		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  46dd		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  46de		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  46df		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  46e0		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  46e1		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  46e2		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  46e3		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  46e4		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  46e5					      DEF	PIECE_VECTOR_BANK
      1  46e5				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  46e5				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  46e5				   PIECE_VECTOR_BANK
      4  46e5				   TEMPORARY_VAR SET	Overlay
      5  46e5				   TEMPORARY_OFFSET SET	0
      6  46e5				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  46e5				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  46e5		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  46e6		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  46e7		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  46e8		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  46e9		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  46ea		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  46eb		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  46ec		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  46ed		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  46ee		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  46ef		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  46f0		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  46f1		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  46f2		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  46f3		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  46f4		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  46f5		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  46f6		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  46f7		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  46f8		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  46f9		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  46fa		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  46fb		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  46fc		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  46fd		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  46fe		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  46ff		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  4700		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  4701		       93		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  4702		       93		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  4703		       93		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  4704		       94		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  4705		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  4706		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  4707		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  4708		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  4709		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  470a		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  470b		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  470c		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  470d		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  470e		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  470f		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  4710		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  4711		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  4712		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  4713		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  4714		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  4715		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  4716		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  4717		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  4718		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  4719		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  471a		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  471b		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  471c		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  471d		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  471e		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  471f		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  4720		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  4721		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  4722		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  4723		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  4724		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  4725		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  4726		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  4727		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  4728		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  4729		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  472a		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  472b		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  472c		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  472d		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  472e		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  472f		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  4730		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  4731		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  4732		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  4733		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  4734		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  4735		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  4736		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  4737		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  4738		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  4739		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  473a		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  473b		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  473c		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  473d		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  473e		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  473f		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  4740		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  4741		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  4742		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  4743		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  4744		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  4745		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  4746		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  4747		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  4748		       8f		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  4749		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  474a		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  474b		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  474c		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  474d		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  474e		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  474f		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  4750		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  4751		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  4752		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  4753		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  4754		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  4755		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  4756		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  4757		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  4758		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  4759		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  475a		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  475b		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  475c		       90		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  475d		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  475e		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  475f		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  4760		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  4761		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  4762		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  4763		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  4764		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  4765		       93		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  4766		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  4767		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  4768		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  4769		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  476a		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  476b		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  476c		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  476d		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  476e		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  476f		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  4770		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  4771		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  4772		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  4773		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  4774		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  4775
    438  4775							; piece index equates...
    439  4775		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  4775		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  4775		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  4775		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  4775		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  4775		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  4775		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  4775		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  4775		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  4775		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  4775		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  4775		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  4775		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  4775		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  4775		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  4775		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  4775		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  4775		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  4775		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  4775		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  4775		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  4775		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  4775		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  4775		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  4775		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  4775		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  4775		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  4775		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  4775		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  4775		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  4775		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  4775		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  4775		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  4775		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  4775		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  4775		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  4775		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  4775		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  4775		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  4775		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  4775		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  4775		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  4775		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  4775		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  4775		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  4775		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  4775		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  4775		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  4775		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  4775		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  4775		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  4775		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  4775		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  4775		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  4775		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  4775		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  4775		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  4775		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  4775		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  4775		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  4775		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  4775		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  4775		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  4775		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  4775		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  4775		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  4775		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  4775		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  4775		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  4775		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  4775		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  4775		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  4775		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  4775		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  4775		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  4775		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  4775		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  4775		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  4775		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  4775		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  4775		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  4775		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  4775		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  4775		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  4775		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  4775		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  4775		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  4775		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  4775		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  4775		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  4775		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  4775		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  4775		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  4775		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  4775		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  4775		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  4775		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  4775		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  4775		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  4775		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  4775		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  4775		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  4775		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  4775		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  4775		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  4775		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  4775		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  4775		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  4775		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  4775		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  4775		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  4775		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  4775		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  4775		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  4775		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  4775		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  4775		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  4775		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  4775		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  4775		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  4775		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  4775		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  4775		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  4775		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  4775		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  4775		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  4775		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  4775		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  4775		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  4775		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  4775		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  4775		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  4775		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  4775		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  4775		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  4775		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  4775		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  4775		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  4775		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  4775		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  4775		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  4775		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  4775		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  4775		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC@2.asm
    438  4775
    439  4775
    440  4775							;---------------------------------------------------------------------------------------------------
    441  4775
      0  4775					      CHECK_BANK_SIZE	"BANK_GENERIC@2"
      1  4775		       03 75	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2 (1K) SIZE =  $375 , FREE= $8b
      2  4775					      ECHO	"BANK_GENERIC@2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4775				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4775				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2", " size=", * - ORIGIN
      5  4775				  -	      ERR
      6  4775					      ENDIF
    443  4775
    444  4775							;---------------------------------------------------------------------------------------------------
    445  4775							;EOF
------- FILE ./chess.asm
------- FILE GFX1.asm LEVEL 2 PASS 4
      0  4775					      include	"GFX1.asm"
      0  4775					      SLOT	2
      1  4775				  -	      IF	(2 < 0) || (2 > 3)
      2  4775				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4775				  -	      ERR
      4  4775					      ENDIF
      5  4775				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4775				   _BANK_SLOT SET	2 * 64
      0  4775					      NEWBANK	GFX1
      1  4bd8 ????				      SEG	GFX1
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   GFX1_START SET	*
      6  4800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4800				   GFX1       SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + 1024
      3  4800
      4  4800
      5  4800							;---------------------------------------------------------------------------------------------------
      6  4800
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  4800					      LIST	ON
      0  4800					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  4800				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4800				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4800				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  4800		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4848					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  4848					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  4848					      LIST	ON
      0  4848					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  4848				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4848				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4848				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  4848				   TEMPORARY_VAR SET	Overlay
      5  4848				   TEMPORARY_OFFSET SET	0
      6  4848				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4848				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  4848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4860		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4890					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  4890					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  4890					      LIST	ON
      0  4890					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  4890				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4890				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4890				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  4890				   TEMPORARY_VAR SET	Overlay
      5  4890				   TEMPORARY_OFFSET SET	0
      6  4890				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4890				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  4890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  48a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  48c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  48d8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  48d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  4900					      LIST	ON
      0  4900					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  4900				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4900				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4900				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  4900				   TEMPORARY_VAR SET	Overlay
      5  4900				   TEMPORARY_OFFSET SET	0
      6  4900				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4900				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  4900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4930		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4948					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  4948					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  4948					      LIST	ON
      0  4948					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  4948				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4948				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4948				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  4948				   TEMPORARY_VAR SET	Overlay
      5  4948				   TEMPORARY_OFFSET SET	0
      6  4948				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4948				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  4948		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  4960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4990					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  4990					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  4990					      LIST	ON
      0  4990					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  4990				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4990				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4990				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  4990				   TEMPORARY_VAR SET	Overlay
      5  4990				   TEMPORARY_OFFSET SET	0
      6  4990				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4990				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  4990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  49a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  49c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  49d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  49d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  4a00					      LIST	ON
      0  4a00					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  4a00				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4a00				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4a00				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  4a00				   TEMPORARY_VAR SET	Overlay
      5  4a00				   TEMPORARY_OFFSET SET	0
      6  4a00				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4a00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  4a30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4a48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  4a48					      LIST	ON
      0  4a48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  4a48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4a48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4a48				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  4a48				   TEMPORARY_VAR SET	Overlay
      5  4a48				   TEMPORARY_OFFSET SET	0
      6  4a48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4a48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX1.asm
     15  4a90
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4a90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  4a90					      LIST	ON
      0  4a90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  4a90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4a90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4a90				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  4a90				   TEMPORARY_VAR SET	Overlay
      5  4a90				   TEMPORARY_OFFSET SET	0
      6  4a90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4a90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  4a90		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$e0,$40,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  4aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ad8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  4b00					      LIST	ON
      0  4b00					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  4b00				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4b00				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4b00				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  4b00				   TEMPORARY_VAR SET	Overlay
      5  4b00				   TEMPORARY_OFFSET SET	0
      6  4b00				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4b00				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  4b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b18		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$38,$10,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4b48					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  4b48					      LIST	ON
      0  4b48					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  4b48				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4b48				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4b48				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  4b48				   TEMPORARY_VAR SET	Overlay
      5  4b48				   TEMPORARY_OFFSET SET	0
      6  4b48				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4b48				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  4b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$03,$01,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4b90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  4b90					      LIST	ON
      0  4b90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  4b90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4b90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4b90				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  4b90				   TEMPORARY_VAR SET	Overlay
      5  4b90				   TEMPORARY_OFFSET SET	0
      6  4b90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4b90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4bc0		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$70,$20,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE GFX1.asm
     20  4bd8
     21  4bd8
     22  4bd8							;---------------------------------------------------------------------------------------------------
     23  4bd8
      0  4bd8					      CHECK_BANK_SIZE	"BANK_GFX1"
      1  4bd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX1 (1K) SIZE =  $3d8 , FREE= $28
      2  4bd8					      ECHO	"BANK_GFX1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4bd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX1", " size=", * - ORIGIN
      5  4bd8				  -	      ERR
      6  4bd8					      ENDIF
     25  4bd8
     26  4bd8							;---------------------------------------------------------------------------------------------------
     27  4bd8							;EOF
------- FILE ./chess.asm
------- FILE GFX2.asm LEVEL 2 PASS 4
      0  4bd8					      include	"GFX2.asm"
      0  4bd8					      SLOT	2
      1  4bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4bd8				  -	      ERR
      4  4bd8					      ENDIF
      5  4bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4bd8				   _BANK_SLOT SET	2 * 64
      0  4bd8					      NEWBANK	GFX2
      1  4fd8 ????				      SEG	GFX2
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   GFX2_START SET	*
      6  4c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4c00				   GFX2       SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  4c00
      4  4c00							;---------------------------------------------------------------------------------------------------
      5  4c00
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  4c00					      LIST	ON
      0  4c00					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  4c00				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4c00				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4c00				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  4c00		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$e0,$40,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4c48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  4c48					      LIST	ON
      0  4c48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  4c48				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4c48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4c48				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  4c48				   TEMPORARY_VAR SET	Overlay
      5  4c48				   TEMPORARY_OFFSET SET	0
      6  4c48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4c48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  4c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$38,$10,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4c90					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  4c90					      LIST	ON
      0  4c90					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  4c90				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4c90				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4c90				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  4c90				   TEMPORARY_VAR SET	Overlay
      5  4c90				   TEMPORARY_OFFSET SET	0
      6  4c90				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4c90				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$03,$01,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
      9  4cd8
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4cd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  4d00					      LIST	ON
      0  4d00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  4d00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4d00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4d00				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  4d00				   TEMPORARY_VAR SET	Overlay
      5  4d00				   TEMPORARY_OFFSET SET	0
      6  4d00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4d00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  4d00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  4d18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4d48					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  4d48					      LIST	ON
      0  4d48					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  4d48				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4d48				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4d48				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  4d48				   TEMPORARY_VAR SET	Overlay
      5  4d48				   TEMPORARY_OFFSET SET	0
      6  4d48				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4d48				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  4d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  4d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4d90					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  4d90					      LIST	ON
      0  4d90					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  4d90				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4d90				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4d90				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  4d90				   TEMPORARY_VAR SET	Overlay
      5  4d90				   TEMPORARY_OFFSET SET	0
      6  4d90				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4d90				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  4d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4da8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4dc0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4dd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  4e00					      LIST	ON
      0  4e00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  4e00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4e00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4e00				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  4e00				   TEMPORARY_VAR SET	Overlay
      5  4e00				   TEMPORARY_OFFSET SET	0
      6  4e00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4e00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4e48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  4e48					      LIST	ON
      0  4e48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  4e48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4e48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4e48				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  4e48				   TEMPORARY_VAR SET	Overlay
      5  4e48				   TEMPORARY_OFFSET SET	0
      6  4e48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4e48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  4e48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  4e60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4e90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  4e90					      LIST	ON
      0  4e90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  4e90				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4e90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4e90				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  4e90				   TEMPORARY_VAR SET	Overlay
      5  4e90				   TEMPORARY_OFFSET SET	0
      6  4e90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4e90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ea8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  4ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4ed8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  4f00					      LIST	ON
      0  4f00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  4f00				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4f00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4f00				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  4f00				   TEMPORARY_VAR SET	Overlay
      5  4f00				   TEMPORARY_OFFSET SET	0
      6  4f00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4f00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  4f30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4f48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  4f48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  4f48					      LIST	ON
      0  4f48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  4f48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4f48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4f48				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  4f48				   TEMPORARY_VAR SET	Overlay
      5  4f48				   TEMPORARY_OFFSET SET	0
      6  4f48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4f48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  4f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4f78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE GFX2.asm
     18  4f90
     19  4f90
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4f90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  4f90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  4f90					      LIST	ON
      0  4f90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  4f90				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4f90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4f90				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  4f90				   TEMPORARY_VAR SET	Overlay
      5  4f90				   TEMPORARY_OFFSET SET	0
      6  4f90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4f90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  4f90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4fa8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
     21  4fd8
     22  4fd8
     23  4fd8							;---------------------------------------------------------------------------------------------------
     24  4fd8
      0  4fd8					      CHECK_BANK_SIZE	"BANK_GFX2"
      1  4fd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX2 (1K) SIZE =  $3d8 , FREE= $28
      2  4fd8					      ECHO	"BANK_GFX2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4fd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX2", " size=", * - ORIGIN
      5  4fd8				  -	      ERR
      6  4fd8					      ENDIF
     26  4fd8
     27  4fd8							;---------------------------------------------------------------------------------------------------
     28  4fd8							;EOF
------- FILE ./chess.asm
------- FILE GFX3.asm LEVEL 2 PASS 4
      0  4fd8					      include	"GFX3.asm"
      0  4fd8					      SLOT	2
      1  4fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4fd8				  -	      ERR
      4  4fd8					      ENDIF
      5  4fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4fd8				   _BANK_SLOT SET	2 * 64
      0  4fd8					      NEWBANK	GFX3
      1  53d8 ????				      SEG	GFX3
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   GFX3_START SET	*
      6  5000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5000				   GFX3       SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + 1024
      3  5000
      4  5000							;---------------------------------------------------------------------------------------------------
      5  5000
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5000					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  5000					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  5000					      LIST	ON
      0  5000					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  5000				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5000				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5000				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  5000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5018		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
      7  5048
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5048					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  5048					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  5048					      LIST	ON
      0  5048					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  5048				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5048				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5048				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  5048				   TEMPORARY_VAR SET	Overlay
      5  5048				   TEMPORARY_OFFSET SET	0
      6  5048				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5048				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  5048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5060		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5078		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5090					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  5090					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  5090					      LIST	ON
      0  5090					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  5090				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5090				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5090				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  5090				   TEMPORARY_VAR SET	Overlay
      5  5090				   TEMPORARY_OFFSET SET	0
      6  5090				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5090				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  5090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  50a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  50c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     10  50d8
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  50d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  50d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  5100					      LIST	ON
      0  5100					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  5100				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5100				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5100				   BLACK_KING_on_BLACK_SQUARE_0
      4  5100				   TEMPORARY_VAR SET	Overlay
      5  5100				   TEMPORARY_OFFSET SET	0
      6  5100				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5100				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  5100		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5118		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5148					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  5148					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  5148					      LIST	ON
      0  5148					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  5148				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5148				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5148				   BLACK_KING_on_BLACK_SQUARE_1
      4  5148				   TEMPORARY_VAR SET	Overlay
      5  5148				   TEMPORARY_OFFSET SET	0
      6  5148				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5148				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  5148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5160		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5190					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  5190					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  5190					      LIST	ON
      0  5190					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  5190				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5190				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5190				   BLACK_KING_on_BLACK_SQUARE_2
      4  5190				   TEMPORARY_VAR SET	Overlay
      5  5190				   TEMPORARY_OFFSET SET	0
      6  5190				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5190				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  5190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  51a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  51c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  51d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  51d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  5200					      LIST	ON
      0  5200					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  5200				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5200				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5200				   BLACK_KING_on_BLACK_SQUARE_3
      4  5200				   TEMPORARY_VAR SET	Overlay
      5  5200				   TEMPORARY_OFFSET SET	0
      6  5200				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5200				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  5200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5230		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     15  5248
     16  5248
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5248					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  5248					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  5248					      LIST	ON
      0  5248					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  5248				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5248				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5248				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  5248				   TEMPORARY_VAR SET	Overlay
      5  5248				   TEMPORARY_OFFSET SET	0
      6  5248				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5248				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  5248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5278		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$70,$20,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     18  5290
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5290					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  5290					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  5290					      LIST	ON
      0  5290					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  5290				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5290				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5290				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  5290				   TEMPORARY_VAR SET	Overlay
      5  5290				   TEMPORARY_OFFSET SET	0
      6  5290				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5290				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  5290		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  52a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  52c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  52d8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  52d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  5300					      LIST	ON
      0  5300					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  5300				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5300				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5300				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  5300				   TEMPORARY_VAR SET	Overlay
      5  5300				   TEMPORARY_OFFSET SET	0
      6  5300				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5300				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  5300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5318		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5348					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  5348					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  5348					      LIST	ON
      0  5348					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  5348				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5348				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5348				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  5348				   TEMPORARY_VAR SET	Overlay
      5  5348				   TEMPORARY_OFFSET SET	0
      6  5348				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5348				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  5348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5378		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5390					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  5390					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  5390					      LIST	ON
      0  5390					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  5390				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5390				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5390				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  5390				   TEMPORARY_VAR SET	Overlay
      5  5390				   TEMPORARY_OFFSET SET	0
      6  5390				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5390				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  5390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  53a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     23  53d8
     24  53d8							;---------------------------------------------------------------------------------------------------
     25  53d8
      0  53d8					      CHECK_BANK_SIZE	"BANK_GFX3"
      1  53d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX3 (1K) SIZE =  $3d8 , FREE= $28
      2  53d8					      ECHO	"BANK_GFX3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  53d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  53d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX3", " size=", * - ORIGIN
      5  53d8				  -	      ERR
      6  53d8					      ENDIF
     27  53d8
     28  53d8							;---------------------------------------------------------------------------------------------------
     29  53d8							;EOF
------- FILE ./chess.asm
------- FILE GFX4.asm LEVEL 2 PASS 4
      0  53d8					      include	"GFX4.asm"
      0  53d8					      SLOT	2
      1  53d8				  -	      IF	(2 < 0) || (2 > 3)
      2  53d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  53d8				  -	      ERR
      4  53d8					      ENDIF
      5  53d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  53d8				   _BANK_SLOT SET	2 * 64
      0  53d8					      NEWBANK	GFX4
      1  57d8 ????				      SEG	GFX4
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   GFX4_START SET	*
      6  5400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5400				   GFX4       SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + 1024
      3  5400
      4  5400							;---------------------------------------------------------------------------------------------------
      5  5400
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  5400					      LIST	ON
      0  5400					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  5400				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5400				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5400				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  5400		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  5418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  5448					      LIST	ON
      0  5448					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  5448				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5448				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5448				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  5490					      LIST	ON
      0  5490					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  5490				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5490				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5490				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  54c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  5500					      LIST	ON
      0  5500					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  5500				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5500				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  5500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE GFX4.asm
     10  5548
     11  5548
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5548					      LIST	ON
      0  5548					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  5548				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5548				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5548				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  5548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  5560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5590					      LIST	ON
      0  5590					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  5590				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5590				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5590				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  55c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5600					      LIST	ON
      0  5600					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  5600				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5600				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5600				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  5630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5648					      LIST	ON
      0  5648					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  5648				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5648				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5648				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5690					      LIST	ON
      0  5690					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  5690				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5690				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5690				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  5690		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  56a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5700					      LIST	ON
      0  5700					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  5700				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5700				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5700				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5748					      LIST	ON
      0  5748					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  5748				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5748				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5748				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5778		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5790					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5790					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5790					      LIST	ON
      0  5790					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  5790				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5790				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5790				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  5790				   TEMPORARY_VAR SET	Overlay
      5  5790				   TEMPORARY_OFFSET SET	0
      6  5790				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5790				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  5790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  57a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  57c0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
     20  57d8
     21  57d8
     22  57d8							;---------------------------------------------------------------------------------------------------
     23  57d8
      0  57d8					      CHECK_BANK_SIZE	"BANK_GFX4"
      1  57d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX4 (1K) SIZE =  $3d8 , FREE= $28
      2  57d8					      ECHO	"BANK_GFX4", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  57d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  57d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX4", " size=", * - ORIGIN
      5  57d8				  -	      ERR
      6  57d8					      ENDIF
     25  57d8
     26  57d8							;---------------------------------------------------------------------------------------------------
     27  57d8							;EOF
------- FILE ./chess.asm
------- FILE NEGAMAX@1.asm LEVEL 2 PASS 4
      0  57d8					      include	"NEGAMAX@1.asm"
      1  57d8							; Chess
      2  57d8							; Copyright (c) 2019-2020 Andrew Davie
      3  57d8							; andrew@taswegian.com
      4  57d8
      0  57d8					      SLOT	1
      1  57d8				  -	      IF	(1 < 0) || (1 > 3)
      2  57d8				  -	      ECHO	"Illegal bank address/segment location", 1
      3  57d8				  -	      ERR
      4  57d8					      ENDIF
      5  57d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  57d8				   _BANK_SLOT SET	1 * 64
      0  57d8					      NEWBANK	NEGAMAX
      1  5b7f ????				      SEG	NEGAMAX
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   NEGAMAX_START SET	*
      6  5800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5800				   NEGAMAX    SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + 1024
      7  5800
      8  5800							;---------------------------------------------------------------------------------------------------
      9  5800
      0  5800					      DEF	aiComputerMove
      1  5800				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  5800				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  5800				   aiComputerMove
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	aiComputerMove
     11  5800					      SUBROUTINE
     12  5800
      0  5800					      REFER	AiStateMachine	;✅
      1  5800					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5800				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5800					      ENDIF
      0  5800					      VEND	aiComputerMove
      1  5800				  -	      IFNCONST	aiComputerMove
      2  5800				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  5800				  -	      ERR
      4  5800					      ENDIF
      5  5800		       00 a9	   VAREND_aiComputerMove =	TEMPORARY_VAR
     15  5800
     16  5800
     17  5800		       a9 88		      lda	#RAMBANK_PLY
     18  5802		       85 94		      sta	currentPly
     19  5804		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     20  5806
     21  5806		       a9 01		      lda	#1
     22  5808		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
     23  580a
     24  580a
     25  580a		       20 3a f4 	      jsr	selectmove	;@this
     26  580d
     27  580d
     28  580d		       a9 00		      lda	#0
     29  580f		       85 4a		      sta	CTRLPF	; clear mirroring
     30  5811		       85 4e		      sta	PF1
     31  5813		       85 4f		      sta	PF2
     32  5815
     33  5815							; correct ply is already switched
     34  5815
      0  5815					      lda@PLY	bestMove
      1  5815		       ad d1 f9 	      lda	bestMove
     36  5818		       10 17		      bpl	.notComputer
     37  581a
     38  581a							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     39  581a
      0  581a					      SWAP
      1  581a		       a5 95		      lda	sideToMove
      2  581c		       49 80		      eor	#SWAP_SIDE
      3  581e		       85 95		      sta	sideToMove
      4  5820
      5  5820
     41  5820		       20 88 f1 	      jsr	GenerateAllMoves	;@0
     42  5823		       a5 a0		      lda	flagCheck
     43  5825		       f0 05		      beq	.gameDrawn
     44  5827
      0  5827					      PHASE	AI_CheckMate
      1  5827		       a9 23		      lda	#AI_CheckMate
      2  5829		       85 8b		      sta	aiState
     46  582b		       60		      rts
     47  582c
     48  582c
      0  582c				   .gameDrawn PHASE	AI_Draw
      1  582c		       a9 24		      lda	#AI_Draw
      2  582e		       85 8b		      sta	aiState
     50  5830		       60		      rts
     51  5831
     52  5831				   .notComputer
     53  5831
     54  5831
     55  5831		       a9 ff		      lda	#-1
     56  5833		       85 88		      sta	cursorX12
     57  5835
      0  5835					      PHASE	AI_DelayAfterMove
      1  5835		       a9 25		      lda	#AI_DelayAfterMove
      2  5837		       85 8b		      sta	aiState
     59  5839		       60	   .halted    rts
     60  583a
     61  583a
     62  583a							;---------------------------------------------------------------------------------------------------
     63  583a
      0  583a					      DEF	selectmove
      1  583a				   SLOT_selectmove SET	_BANK_SLOT
      2  583a				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  583a				   selectmove
      4  583a				   TEMPORARY_VAR SET	Overlay
      5  583a				   TEMPORARY_OFFSET SET	0
      6  583a				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  583a				   FUNCTION_NAME SET	selectmove
     65  583a					      SUBROUTINE
     66  583a
      0  583a					      COMMON_VARS
      1  583a
      0  583a					      VAR	__thinkbar, 1
      1  583a		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__toggle, 1
      1  583a		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      4  583a
      0  583a					      VAR	__bestMove, 1
      1  583a		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__alpha, 2
      1  583a		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__beta, 2
      1  583a		       00 ac	   __beta     =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__negaMax, 2
      1  583a		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__value, 2
      1  583a		       00 b0	   __value    =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
     10  583a
      0  583a					      VAR	__quiesceCapOnly, 1
      1  583a		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
     12  583a
      0  583a					      VAR	__originalPiece, 1
      1  583a		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__capturedPiece, 1
      1  583a		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
     15  583a
      0  583a					      REFER	aiComputerMove	;✅
      1  583a				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  583a				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  583a					      ENDIF
      0  583a					      VEND	selectmove
      1  583a				  -	      IFNCONST	selectmove
      2  583a				  -	      ECHO	"Incorrect VEND label", selectmove
      3  583a				  -	      ERR
      4  583a					      ENDIF
      5  583a		       00 b5	   VAREND_selectmove =	TEMPORARY_VAR
     70  583a
     71  583a
     72  583a							; RAM bank already switched in!!!
     73  583a							; returns with RAM bank switched
     74  583a
     75  583a
     76  583a					      IF	DIAGNOSTICS
     77  583a
     78  583a		       a9 00		      lda	#0
     79  583c		       85 9d		      sta	positionCount
     80  583e		       85 9e		      sta	positionCount+1
     81  5840		       85 9f		      sta	positionCount+2
     82  5842							;sta maxPly
     83  5842					      ENDIF
     84  5842
     85  5842
     86  5842		       a9 00		      lda	#<INFINITY
     87  5844		       85 ac		      sta	__beta
     88  5846		       a9 70		      lda	#>INFINITY
     89  5848		       85 ad		      sta	__beta+1
     90  584a
     91  584a		       a9 00		      lda	#<-INFINITY
     92  584c		       85 aa		      sta	__alpha
     93  584e		       a9 90		      lda	#>-INFINITY
     94  5850		       85 ab		      sta	__alpha+1	; player tries to maximise
     95  5852
     96  5852		       a2 03		      ldx	#SEARCH_DEPTH
     97  5854		       a9 00		      lda	#0	; no captured piece
     98  5856		       85 b2		      sta	__quiesceCapOnly	; ALL moves to be generated
     99  5858
    100  5858		       20 1e f5 	      jsr	negaMax
    101  585b
    102  585b							;lda currentPly
    103  585b							;sta SET_BANK_RAM ;tmp?
    104  585b
      0  585b					      ldx@PLY	bestMove
      1  585b		       ae d1 f9 	      ldx	bestMove
    106  585e		       30 26		      bmi	.nomove
    107  5860
    108  5860							; Generate player's moves in reply
    109  5860							; Make the computer move, list player moves (PLY+1), unmake computer move
    110  5860
      0  5860					      stx@PLY	movePtr
      1  5860		       8e d0 fb 	      stx	[RAM]+movePtr
    112  5863		       20 87 f4 	      jsr	MakeMove	;@this
    113  5866		       20 35 f2 	      jsr	ListPlayerMoves	;@0
    114  5869
    115  5869		       c6 94		      dec	currentPly
    116  586b		       20 92 f2 	      jsr	unmakeMove	;@0
    117  586e
    118  586e							; Grab the computer move details for the UI animation
    119  586e
    120  586e		       a9 88		      lda	#RAMBANK_PLY
    121  5870		       85 3e		      sta	SET_BANK_RAM
    122  5872
      0  5872					      ldx@PLY	bestMove
      1  5872		       ae d1 f9 	      ldx	bestMove
      0  5875					      lda@PLY	MoveTo,x
      1  5875		       bd 64 f8 	      lda	MoveTo,x
    125  5878		       85 86		      sta	toX12
      0  587a					      lda@PLY	MoveFrom,x
      1  587a		       bd 00 f8 	      lda	MoveFrom,x
    127  587d		       85 87		      sta	originX12
    128  587f		       85 85		      sta	fromX12
      0  5881					      lda@PLY	MovePiece,x
      1  5881		       bd 00 f9 	      lda	MovePiece,x
    130  5884		       85 96		      sta	fromPiece
    131  5886
    132  5886				   .nomove
    133  5886		       60		      rts
    134  5887
    135  5887
    136  5887							;---------------------------------------------------------------------------------------------------
    137  5887
      0  5887					      DEF	MakeMove
      1  5887				   SLOT_MakeMove SET	_BANK_SLOT
      2  5887				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  5887				   MakeMove
      4  5887				   TEMPORARY_VAR SET	Overlay
      5  5887				   TEMPORARY_OFFSET SET	0
      6  5887				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  5887				   FUNCTION_NAME SET	MakeMove
    139  5887					      SUBROUTINE
    140  5887
      0  5887					      COMMON_VARS
      1  5887
      0  5887					      VAR	__thinkbar, 1
      1  5887		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__toggle, 1
      1  5887		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      4  5887
      0  5887					      VAR	__bestMove, 1
      1  5887		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__alpha, 2
      1  5887		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__beta, 2
      1  5887		       00 ac	   __beta     =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__negaMax, 2
      1  5887		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__value, 2
      1  5887		       00 b0	   __value    =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
     10  5887
      0  5887					      VAR	__quiesceCapOnly, 1
      1  5887		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
     12  5887
      0  5887					      VAR	__originalPiece, 1
      1  5887		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__capturedPiece, 1
      1  5887		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
     15  5887
      0  5887					      REFER	selectmove	;✅
      1  5887				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  5887					      ENDIF
      0  5887					      REFER	ListPlayerMoves	;✅
      1  5887				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  5887					      ENDIF
      0  5887					      REFER	quiesce	;✅
      1  5887				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  5887					      ENDIF
      0  5887					      REFER	negaMax	;✅
      1  5887				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  5887					      ENDIF
      0  5887					      VEND	MakeMove
      1  5887				  -	      IFNCONST	MakeMove
      2  5887				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  5887				  -	      ERR
      4  5887					      ENDIF
      5  5887		       00 b5	   VAREND_MakeMove =	TEMPORARY_VAR
    147  5887
    148  5887							; Do a move without any GUI stuff
    149  5887							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    150  5887							; and all relevant flags in original state. This is NOT used for the visible move on the
    151  5887							; screen.
    152  5887
    153  5887
    154  5887							; fromPiece	 piece doing the move
    155  5887							; fromX12	 current square X12
    156  5887							; originX12	 starting square X12
    157  5887							; toX12	 ending square X12
    158  5887
    159  5887							; BANK:SLOT2 = currentPly
    160  5887
    161  5887
    162  5887							; There are potentially "two" moves, with the following
    163  5887							; a) Castling, moving both rook and king
    164  5887							; b) en-Passant, capturing pawn on "odd" square
    165  5887							; These both set "secondary" movers which are used for restoring during unmakeMove
    166  5887
    167  5887		       a0 d1		      ldy	#RAMBANK_BOARD
    168  5889		       84 3e		      sty	SET_BANK_RAM	;@3
    169  588b
      0  588b					      ldx@PLY	movePtr
      1  588b		       ae d0 f9 	      ldx	movePtr
      0  588e					      ldy@PLY	MoveFrom,x
      1  588e		       bc 00 f8 	      ldy	MoveFrom,x
    172  5891		       84 85		      sty	fromX12
    173  5893		       84 87		      sty	originX12
    174  5895
      0  5895					      lda@RAM	Board,y
      1  5895		       b9 79 fc 	      lda	Board,y
    176  5898		       85 b3		      sta	__originalPiece
      0  589a					      sta@PLY	restorePiece
      1  589a		       8d d9 fb 	      sta	[RAM]+restorePiece
    178  589d
    179  589d		       a9 00		      lda	#0
      0  589f					      sta@RAM	Board,y
      1  589f		       99 79 fe 	      sta	[RAM]+Board,y
      0  58a2					      sta@PLY	secondaryPiece
      1  58a2		       8d cc fb 	      sta	[RAM]+secondaryPiece
    182  58a5
    183  58a5		       85 a5		      sta	vkSquare
    184  58a7		       85 a6		      sta	vkSquare+1
    185  58a9
      0  58a9					      ldy@PLY	MoveTo,x
      1  58a9		       bc 64 f8 	      ldy	MoveTo,x
    187  58ac		       84 86		      sty	toX12
    188  58ae
      0  58ae					      lda@RAM	Board,y
      1  58ae		       b9 79 fc 	      lda	Board,y
    190  58b1		       85 b4		      sta	__capturedPiece
      0  58b3					      sta@PLY	capturedPiece
      1  58b3		       8d cb fb 	      sta	[RAM]+capturedPiece
    192  58b6
      0  58b6					      lda@PLY	MovePiece,x
      1  58b6		       bd 00 f9 	      lda	MovePiece,x
    194  58b9		       85 96		      sta	fromPiece
    195  58bb
    196  58bb		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
    197  58bd		       09 40		      ora	#FLAG_MOVED
      0  58bf					      sta@RAM	Board,y
      1  58bf		       99 79 fe 	      sta	[RAM]+Board,y
    199  58c2
    200  58c2
      0  58c2				   .move      CALL	AdjustMaterialPositionalValue	;@2
      1  58c2				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  58c2				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  58c2				  -	      ECHO	"Cannot switch bank in use for", AdjustMaterialPositionalValue
      4  58c2				  -	      ERR
      5  58c2					      ENDIF
      6  58c2		       a9 91		      lda	#BANK_AdjustMaterialPositionalValue
      7  58c4		       85 3f		      sta	SET_BANK
      8  58c6		       20 c5 f8 	      jsr	AdjustMaterialPositionalValue
    202  58c9
    203  58c9
    204  58c9					      IF	CASTLING_ENABLED
    205  58c9
    206  58c9							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    207  58c9							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    208  58c9							; redo the moving code (for the rook, this time).
    209  58c9
    210  58c9							; Set the squares that need to be checked for "virtual check" - preventing the king
    211  58c9							; from castling from/across check.
    212  58c9
    213  58c9		       a5 96		      lda	fromPiece
    214  58cb		       29 17		      and	#FLAG_CASTLE|KING
    215  58cd		       c9 17		      cmp	#FLAG_CASTLE|KING
    216  58cf		       d0 13		      bne	.exit	; NOT involved in castle!
    217  58d1
    218  58d1							; Must be a king, castling. Calculate the virtual squares which need to be checked for
    219  58d1							; invalid castling. Prevents moving in/across check.
    220  58d1
    221  58d1		       18		      clc
    222  58d2		       a5 87		      lda	originX12
    223  58d4		       85 a6		      sta	vkSquare+1	; king origin
    224  58d6		       65 86		      adc	toX12
    225  58d8		       4a		      lsr
    226  58d9		       85 a5		      sta	vkSquare	; intermediate square
    227  58db
    228  58db
    229  58db							; Now generate a new move for the rook
    230  58db
      0  58db					      CALL	GenCastleMoveForRook	;@3
      1  58db				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  58db				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  58db				  -	      ECHO	"Cannot switch bank in use for", GenCastleMoveForRook
      4  58db				  -	      ERR
      5  58db					      ENDIF
      6  58db		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      7  58dd		       85 3f		      sta	SET_BANK
      8  58df		       20 21 fc 	      jsr	GenCastleMoveForRook
    232  58e2		       b0 de		      bcs	.move	; move the rook!
    233  58e4
    234  58e4				   .exit
    235  58e4					      ENDIF
    236  58e4
    237  58e4
    238  58e4
    239  58e4
    240  58e4							; Swap over sides
    241  58e4
      0  58e4					      NEGEVAL
      1  58e4
      2  58e4		       38		      sec
      3  58e5		       a9 00		      lda	#0
      4  58e7		       e5 8f		      sbc	Evaluation
      5  58e9		       85 8f		      sta	Evaluation
      6  58eb		       a9 00		      lda	#0
      7  58ed		       e5 90		      sbc	Evaluation+1
      8  58ef		       85 90		      sta	Evaluation+1
      0  58f1					      SWAP
      1  58f1		       a5 95		      lda	sideToMove
      2  58f3		       49 80		      eor	#SWAP_SIDE
      3  58f5		       85 95		      sta	sideToMove
      4  58f7
      5  58f7
    244  58f7
    245  58f7		       a5 94		      lda	currentPly
    246  58f9		       85 3e		      sta	SET_BANK_RAM
    247  58fb		       60		      rts
    248  58fc
    249  58fc
    250  58fc							;---------------------------------------------------------------------------------------------------
    251  58fc
    252  58fc							;function negaMax(node, depth, α, β, color) is
    253  58fc							;    if depth = 0 or node is a terminal node then
    254  58fc							;	  return color × the heuristic value of node
    255  58fc
    256  58fc							;    childNodes := generateMoves(node)
    257  58fc							;    childNodes := orderMoves(childNodes)
    258  58fc							;    value := −∞
    259  58fc							;    foreach child in childNodes do
    260  58fc							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    261  58fc							;	  α := max(α, value)
    262  58fc							;	  if α ≥ β then
    263  58fc							;	      break (* cut-off *)
    264  58fc							;    return value
    265  58fc							;(* Initial call for Player A's root node *)
    266  58fc							;negaMax(rootNode, depth, −∞, +∞, 1)
    267  58fc
    268  58fc
    269  58fc					      SUBROUTINE
    270  58fc
    271  58fc		       a9 ff	   .doQ       lda	#-1
    272  58fe		       85 b2		      sta	__quiesceCapOnly
    273  5900		       20 98 f6 	      jsr	quiesce
    274  5903		       e6 b2		      inc	__quiesceCapOnly
    275  5905		       60		      rts
    276  5906
    277  5906
      0  5906				   .exit      lda@PLY	value
      1  5906		       ad d6 f9 	      lda	value
    279  5909		       85 ae		      sta	__negaMax
      0  590b					      lda@PLY	value+1
      1  590b		       ad d7 f9 	      lda	value+1
    281  590e		       85 af		      sta	__negaMax+1
    282  5910		       60		      rts
    283  5911
    284  5911
    285  5911				   .terminal
    286  5911
    287  5911					      IF	QUIESCE_EXTRA_DEPTH > 0
    288  5911		       c9 00		      cmp	#0	; captured piece
    289  5913		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
    290  5915					      ENDIF
    291  5915
    292  5915
    293  5915		       a5 8f		      lda	Evaluation
    294  5917		       85 ae		      sta	__negaMax
    295  5919		       a5 90		      lda	Evaluation+1
    296  591b		       85 af		      sta	__negaMax+1
    297  591d
    298  591d		       60	   .inCheck2  rts
    299  591e
    300  591e
    301  591e
      0  591e					      DEF	negaMax
      1  591e				   SLOT_negaMax SET	_BANK_SLOT
      2  591e				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  591e				   negaMax
      4  591e				   TEMPORARY_VAR SET	Overlay
      5  591e				   TEMPORARY_OFFSET SET	0
      6  591e				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  591e				   FUNCTION_NAME SET	negaMax
    303  591e
    304  591e							; PARAMS depth-1, -beta, -alpha
    305  591e							; pased through temporary variables (__alpha, __beta) and X reg
    306  591e
    307  591e							; pass...
    308  591e							; x = depthleft
    309  591e							; a = captured piece
    310  591e							; SET_BANK_RAM      --> current ply
    311  591e							; __alpha[2] = param alpha
    312  591e							; __beta[2] = param beta
    313  591e
    314  591e
      0  591e					      COMMON_VARS
      1  591e
      0  591e					      VAR	__thinkbar, 1
      1  591e		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
      0  591e					      VAR	__toggle, 1
      1  591e		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
      4  591e
      0  591e					      VAR	__bestMove, 1
      1  591e		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
      0  591e					      VAR	__alpha, 2
      1  591e		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
      0  591e					      VAR	__beta, 2
      1  591e		       00 ac	   __beta     =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
      0  591e					      VAR	__negaMax, 2
      1  591e		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
      0  591e					      VAR	__value, 2
      1  591e		       00 b0	   __value    =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
     10  591e
      0  591e					      VAR	__quiesceCapOnly, 1
      1  591e		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
     12  591e
      0  591e					      VAR	__originalPiece, 1
      1  591e		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
      0  591e					      VAR	__capturedPiece, 1
      1  591e		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  591e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  591e
      4  591e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  591e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  591e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  591e					      ENDIF
      8  591e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  591e				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  591e				  -	      ERR
     11  591e					      ENDIF
     12  591e					      LIST	ON
     15  591e
      0  591e					      REFER	selectmove	;✅
      1  591e				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  591e				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  591e					      ENDIF
      0  591e					      VEND	negaMax
      1  591e				  -	      IFNCONST	negaMax
      2  591e				  -	      ECHO	"Incorrect VEND label", negaMax
      3  591e				  -	      ERR
      4  591e					      ENDIF
      5  591e		       00 b5	   VAREND_negaMax =	TEMPORARY_VAR
    318  591e
    319  591e		       48		      pha
    320  591f
    321  591f		       20 7a f0 	      jsr	ThinkBar	;@0
    322  5922
    323  5922		       a5 94		      lda	currentPly
    324  5924		       85 3e		      sta	SET_BANK_RAM	;@2
    325  5926
    326  5926		       68		      pla
    327  5927		       ca		      dex
    328  5928		       30 e7		      bmi	.terminal
      0  592a					      stx@PLY	depthLeft
      1  592a		       8e d8 fb 	      stx	[RAM]+depthLeft
    330  592d
    331  592d
    332  592d							; Allow the player to force computer to select a move. Press the SELECT switch
    333  592d
      0  592d					      lda@PLY	bestMove
      1  592d		       ad d1 f9 	      lda	bestMove
    335  5930		       30 07		      bmi	.noCheat	; can't force if no move chosen!
    336  5932		       ad 82 02 	      lda	SWCHB
    337  5935		       29 02		      and	#2
    338  5937		       f0 cd		      beq	.exit	; SELECT abort
    339  5939				   .noCheat
    340  5939
    341  5939
      0  5939					      NEXT_RANDOM
      1  5939		       a5 81		      lda	rnd
      2  593b		       4a		      lsr
      3  593c		       90 02		      bcc	.skipEOR
      4  593e		       49 fe		      eor	#RND_EOR_VAL
      5  5940		       85 81	   .skipEOR   sta	rnd
    343  5942		       25 a2		      and	randomness
    344  5944		       65 8f		      adc	Evaluation
    345  5946		       85 8f		      sta	Evaluation	; since it's random we don't care about HI
    346  5948							;bcc .evOK
    347  5948							;inc Evaluation+1
    348  5948				   .evOK
    349  5948
    350  5948
    351  5948
    352  5948							;lda #2
    353  5948							;sta COLUPF			  ; grey thinkbars
    354  5948
    355  5948		       a5 aa		      lda	__alpha
      0  594a					      sta@PLY	alpha
      1  594a		       8d d2 fb 	      sta	[RAM]+alpha
    357  594d		       a5 ab		      lda	__alpha+1
      0  594f					      sta@PLY	alpha+1
      1  594f		       8d d3 fb 	      sta	[RAM]+alpha+1
    359  5952
    360  5952		       a5 ac		      lda	__beta
      0  5954					      sta@PLY	beta
      1  5954		       8d d4 fb 	      sta	[RAM]+beta
    362  5957		       a5 ad		      lda	__beta+1
      0  5959					      sta@PLY	beta+1
      1  5959		       8d d5 fb 	      sta	[RAM]+beta+1
    364  595c
    365  595c
    366  595c		       20 88 f1 	      jsr	GenerateAllMoves	;@0
    367  595f
    368  595f		       a5 a0		      lda	flagCheck
    369  5961		       d0 ba		      bne	.inCheck2	; OTHER guy in check
    370  5963
    371  5963		       a9 00		      lda	#<-INFINITY
      0  5965					      sta@PLY	value
      1  5965		       8d d6 fb 	      sta	[RAM]+value
    373  5968		       a9 90		      lda	#>-INFINITY
      0  596a					      sta@PLY	value+1
      1  596a		       8d d7 fb 	      sta	[RAM]+value+1
    375  596d
      0  596d					      ldx@PLY	moveIndex
      1  596d		       ae cf f9 	      ldx	moveIndex
    377  5970		       10 03		      bpl	.forChild
    378  5972		       4c 06 f5 	      jmp	.exit
    379  5975
      0  5975				   .forChild  stx@PLY	movePtr
      1  5975		       8e d0 fb 	      stx	[RAM]+movePtr
    381  5978
    382  5978		       20 87 f4 	      jsr	MakeMove	;@this
    383  597b
    384  597b
    385  597b							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    386  597b
    387  597b							; PARAMS depth-1, -beta, -alpha
    388  597b							; pased through temporary variables (__alpha, __beta) and X reg
    389  597b
    390  597b		       38		      sec
    391  597c		       a9 00		      lda	#0
      0  597e					      sbc@PLY	beta
      1  597e		       ed d4 f9 	      sbc	beta
    393  5981		       85 aa		      sta	__alpha
    394  5983		       a9 00		      lda	#0
      0  5985					      sbc@PLY	beta+1
      1  5985		       ed d5 f9 	      sbc	beta+1
    396  5988		       85 ab		      sta	__alpha+1
    397  598a
    398  598a		       38		      sec
    399  598b		       a9 00		      lda	#0
      0  598d					      sbc@PLY	alpha
      1  598d		       ed d2 f9 	      sbc	alpha
    401  5990		       85 ac		      sta	__beta
    402  5992		       a9 00		      lda	#0
      0  5994					      sbc@PLY	alpha+1
      1  5994		       ed d3 f9 	      sbc	alpha+1
    404  5997		       85 ad		      sta	__beta+1
    405  5999
    406  5999
      0  5999					      ldx@PLY	depthLeft
      1  5999		       ae d8 f9 	      ldx	depthLeft
      0  599c					      lda@PLY	capturedPiece
      1  599c		       ad cb f9 	      lda	capturedPiece
    409  599f
    410  599f		       e6 94		      inc	currentPly
    411  59a1		       a4 94		      ldy	currentPly
    412  59a3		       84 3e		      sty	SET_BANK_RAM	; self-switch
    413  59a5
    414  59a5		       20 1e f5 	      jsr	negaMax	;@this
    415  59a8
    416  59a8		       c6 94		      dec	currentPly
    417  59aa		       a5 94		      lda	currentPly
    418  59ac		       85 3e		      sta	SET_BANK_RAM
    419  59ae
    420  59ae		       20 92 f2 	      jsr	unmakeMove	;@0
    421  59b1
    422  59b1		       38		      sec
    423  59b2		       a9 00		      lda	#0
    424  59b4		       e5 ae		      sbc	__negaMax
    425  59b6		       85 ae		      sta	__negaMax
    426  59b8		       a9 00		      lda	#0
    427  59ba		       e5 af		      sbc	__negaMax+1
    428  59bc		       85 af		      sta	__negaMax+1	; -negaMax(...)
    429  59be
    430  59be					      IF	1
    431  59be		       a5 a0		      lda	flagCheck
    432  59c0		       f0 06		      beq	.notCheck
    433  59c2
    434  59c2							; at this point we've determined that the move was illegal, because the next ply detected
    435  59c2							; a king capture. So, the move should be totally discounted
    436  59c2
    437  59c2		       a9 00		      lda	#0
    438  59c4		       85 a0		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    439  59c6		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    440  59c8					      ENDIF
    441  59c8
    442  59c8		       38	   .notCheck  sec
      0  59c9					      lda@PLY	value
      1  59c9		       ad d6 f9 	      lda	value
    444  59cc		       e5 ae		      sbc	__negaMax
      0  59ce					      lda@PLY	value+1
      1  59ce		       ad d7 f9 	      lda	value+1
    446  59d1		       e5 af		      sbc	__negaMax+1
    447  59d3		       50 02		      bvc	.lab0
    448  59d5		       49 80		      eor	#$80
    449  59d7		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    450  59d9
    451  59d9							; so, negaMax > value!
    452  59d9
    453  59d9		       a5 ae		      lda	__negaMax
      0  59db					      sta@PLY	value
      1  59db		       8d d6 fb 	      sta	[RAM]+value
    455  59de		       a5 af		      lda	__negaMax+1
      0  59e0					      sta@PLY	value+1	; max(value, -negaMax)
      1  59e0		       8d d7 fb 	      sta	[RAM]+value+1
    457  59e3
      0  59e3					      lda@PLY	movePtr
      1  59e3		       ad d0 f9 	      lda	movePtr
      0  59e6					      sta@PLY	bestMove
      1  59e6		       8d d1 fb 	      sta	[RAM]+bestMove
    460  59e9				   .lt0
    461  59e9
    462  59e9							;	  α := max(α, value)
    463  59e9
    464  59e9		       38		      sec
      0  59ea					      lda@PLY	value
      1  59ea		       ad d6 f9 	      lda	value
      0  59ed					      sbc@PLY	alpha
      1  59ed		       ed d2 f9 	      sbc	alpha
      0  59f0					      lda@PLY	value+1
      1  59f0		       ad d7 f9 	      lda	value+1
      0  59f3					      sbc@PLY	alpha+1
      1  59f3		       ed d3 f9 	      sbc	alpha+1
    469  59f6		       50 02		      bvc	.lab1
    470  59f8		       49 80		      eor	#$80
    471  59fa		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    472  59fc
      0  59fc					      lda@PLY	value
      1  59fc		       ad d6 f9 	      lda	value
      0  59ff					      sta@PLY	alpha
      1  59ff		       8d d2 fb 	      sta	[RAM]+alpha
      0  5a02					      lda@PLY	value+1
      1  5a02		       ad d7 f9 	      lda	value+1
      0  5a05					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  5a05		       8d d3 fb 	      sta	[RAM]+alpha+1
    477  5a08
    478  5a08				   .lt1
    479  5a08
    480  5a08							;	  if α ≥ β then
    481  5a08							;	      break (* cut-off *)
    482  5a08
    483  5a08		       38		      sec
      0  5a09					      lda@PLY	alpha
      1  5a09		       ad d2 f9 	      lda	alpha
      0  5a0c					      sbc@PLY	beta
      1  5a0c		       ed d4 f9 	      sbc	beta
      0  5a0f					      lda@PLY	alpha+1
      1  5a0f		       ad d3 f9 	      lda	alpha+1
      0  5a12					      sbc@PLY	beta+1
      1  5a12		       ed d5 f9 	      sbc	beta+1
    488  5a15		       50 02		      bvc	.lab2
    489  5a17		       49 80		      eor	#$80
    490  5a19		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    491  5a1b
    492  5a1b
      0  5a1b				   .nextMove  ldx@PLY	movePtr
      1  5a1b		       ae d0 f9 	      ldx	movePtr
    494  5a1e		       ca	   .nextX     dex
    495  5a1f		       30 03		      bmi	.retrn
    496  5a21		       4c 75 f5 	      jmp	.forChild
    497  5a24
    498  5a24		       4c 06 f5    .retrn     jmp	.exit
    499  5a27
    500  5a27							;---------------------------------------------------------------------------------------------------
    501  5a27
    502  5a27					      MAC	xchg
    503  5a27					      lda@PLY	{1},x
    504  5a27					      pha		;sta __xchg
    505  5a27					      lda@PLY	{1},y
    506  5a27					      sta@PLY	{1},x
    507  5a27					      pla		;lda __xchg
    508  5a27					      sta@PLY	{1},y
    509  5a27					      ENDM		;{name}
    510  5a27
    511  5a27
      0  5a27					      DEF	Sort
      1  5a27				   SLOT_Sort  SET	_BANK_SLOT
      2  5a27				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  5a27				   Sort
      4  5a27				   TEMPORARY_VAR SET	Overlay
      5  5a27				   TEMPORARY_OFFSET SET	0
      6  5a27				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  5a27				   FUNCTION_NAME SET	Sort
    513  5a27					      SUBROUTINE
    514  5a27
      0  5a27					      REFER	GenerateAllMoves
      1  5a27					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5a27				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5a27					      ENDIF
      0  5a27					      VAR	__xchg, 1
      1  5a27		       00 b8	   __xchg     =	TEMPORARY_VAR
      2  5a27				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a27
      4  5a27				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a27				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a27				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a27					      ENDIF
      8  5a27				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a27				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  5a27				  -	      ERR
     11  5a27					      ENDIF
     12  5a27					      LIST	ON
      0  5a27					      VEND	Sort
      1  5a27				  -	      IFNCONST	Sort
      2  5a27				  -	      ECHO	"Incorrect VEND label", Sort
      3  5a27				  -	      ERR
      4  5a27					      ENDIF
      5  5a27		       00 b9	   VAREND_Sort =	TEMPORARY_VAR
    518  5a27
    519  5a27		       a5 b2		      lda	__quiesceCapOnly
    520  5a29		       d0 4a		      bne	.exit	; only caps present so already sorted!
    521  5a2b
      0  5a2b					      ldx@PLY	moveIndex
      1  5a2b		       ae cf f9 	      ldx	moveIndex
      0  5a2e					      ldy@PLY	moveIndex
      1  5a2e		       ac cf f9 	      ldy	moveIndex
    524  5a31		       c8		      iny		; this is OK - swaps "1st" with itself if it's a capture
    525  5a32
    526  5a32		       88	   .next      dey
    527  5a33		       30 40		      bmi	.exit
    528  5a35
      0  5a35					      lda@PLY	MoveCapture,y
      1  5a35		       b9 64 f9 	      lda	MoveCapture,y
    530  5a38		       f0 f8		      beq	.next
    531  5a3a
      0  5a3a					      XCHG	MoveFrom
      0  5a3a					      lda@PLY	MoveFrom,x
      1  5a3a		       bd 00 f8 	      lda	MoveFrom,x
      2  5a3d		       48		      pha
      0  5a3e					      lda@PLY	MoveFrom,y
      1  5a3e		       b9 00 f8 	      lda	MoveFrom,y
      0  5a41					      sta@PLY	MoveFrom,x
      1  5a41		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  5a44		       68		      pla
      0  5a45					      sta@PLY	MoveFrom,y
      1  5a45		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  5a48					      XCHG	MoveTo
      0  5a48					      lda@PLY	MoveTo,x
      1  5a48		       bd 64 f8 	      lda	MoveTo,x
      2  5a4b		       48		      pha
      0  5a4c					      lda@PLY	MoveTo,y
      1  5a4c		       b9 64 f8 	      lda	MoveTo,y
      0  5a4f					      sta@PLY	MoveTo,x
      1  5a4f		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  5a52		       68		      pla
      0  5a53					      sta@PLY	MoveTo,y
      1  5a53		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  5a56					      XCHG	MovePiece
      0  5a56					      lda@PLY	MovePiece,x
      1  5a56		       bd 00 f9 	      lda	MovePiece,x
      2  5a59		       48		      pha
      0  5a5a					      lda@PLY	MovePiece,y
      1  5a5a		       b9 00 f9 	      lda	MovePiece,y
      0  5a5d					      sta@PLY	MovePiece,x
      1  5a5d		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  5a60		       68		      pla
      0  5a61					      sta@PLY	MovePiece,y
      1  5a61		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  5a64					      XCHG	MoveCapture
      0  5a64					      lda@PLY	MoveCapture,x
      1  5a64		       bd 64 f9 	      lda	MoveCapture,x
      2  5a67		       48		      pha
      0  5a68					      lda@PLY	MoveCapture,y
      1  5a68		       b9 64 f9 	      lda	MoveCapture,y
      0  5a6b					      sta@PLY	MoveCapture,x
      1  5a6b		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  5a6e		       68		      pla
      0  5a6f					      sta@PLY	MoveCapture,y
      1  5a6f		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    536  5a72
    537  5a72		       ca		      dex
    538  5a73		       10 bd		      bpl	.next
    539  5a75
    540  5a75				   .exit
    541  5a75
    542  5a75
    543  5a75
    544  5a75
    545  5a75							; Scan for capture of king
    546  5a75							; Also scan for virtual king captures (squares involved in castling)
    547  5a75
      0  5a75					      ldx@PLY	moveIndex
      1  5a75		       ae cf f9 	      ldx	moveIndex
    549  5a78		       30 19		      bmi	.notCheck	; OK if no captures in quiesce!
    550  5a7a
      0  5a7a				   .scanCheck lda@PLY	MoveCapture,x
      1  5a7a		       bd 64 f9 	      lda	MoveCapture,x
    552  5a7d		       29 0f		      and	#PIECE_MASK
    553  5a7f		       c9 07		      cmp	#KING
    554  5a81		       f0 12		      beq	.check
    555  5a83
    556  5a83							; If the squares the king is crossing for castling are capturable, then that's an illegal
    557  5a83							; castle move and it's treated as if the king were in check.
    558  5a83
      0  5a83					      lda@PLY	MoveTo,x
      1  5a83		       bd 64 f8 	      lda	MoveTo,x
      0  5a86					      cmp@PLY	virtualKingSquare
      1  5a86		       cd da f9 	      cmp	virtualKingSquare
    561  5a89		       f0 0a		      beq	.check
      0  5a8b					      cmp@PLY	virtualKingSquare+1
      1  5a8b		       cd db f9 	      cmp	virtualKingSquare+1
    563  5a8e		       f0 05		      beq	.check
    564  5a90
    565  5a90		       ca	   .nextScan  dex
    566  5a91		       10 e7		      bpl	.scanCheck
    567  5a93
    568  5a93		       a9 00	   .notCheck  lda	#0
    569  5a95		       85 a0	   .check     sta	flagCheck
    570  5a97		       60		      rts
    571  5a98
    572  5a98
    573  5a98							;---------------------------------------------------------------------------------------------------
    574  5a98							; QUIESCE!
    575  5a98
    576  5a98							;int Quiesce( int alpha, int beta ) {
    577  5a98							;    int stand_pat = Evaluate();
    578  5a98							;    if( stand_pat >= beta )
    579  5a98							;	  return beta;
    580  5a98							;    if( alpha < stand_pat )
    581  5a98							;	  alpha = stand_pat;
    582  5a98
    583  5a98							;    until( every_capture_has_been_examined )	{
    584  5a98							;	  MakeCapture();
    585  5a98							;	  score = -Quiesce( -beta, -alpha );
    586  5a98							;	  TakeBackMove();
    587  5a98
    588  5a98							;	  if( score >= beta )
    589  5a98							;	      return beta;
    590  5a98							;	  if( score > alpha )
    591  5a98							;	     alpha = score;
    592  5a98							;    }
    593  5a98							;    return alpha;
    594  5a98							;}
    595  5a98
    596  5a98
    597  5a98							;---------------------------------------------------------------------------------------------------
    598  5a98
      0  5a98					      DEF	quiesce
      1  5a98				   SLOT_quiesce SET	_BANK_SLOT
      2  5a98				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  5a98				   quiesce
      4  5a98				   TEMPORARY_VAR SET	Overlay
      5  5a98				   TEMPORARY_OFFSET SET	0
      6  5a98				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  5a98				   FUNCTION_NAME SET	quiesce
    600  5a98					      SUBROUTINE
    601  5a98
    602  5a98							; pass...
    603  5a98							; x = depthleft
    604  5a98							; SET_BANK_RAM      --> current ply
    605  5a98							; __alpha[2] = param alpha
    606  5a98							; __beta[2] = param beta
    607  5a98
    608  5a98
      0  5a98					      COMMON_VARS
      1  5a98
      0  5a98					      VAR	__thinkbar, 1
      1  5a98		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
      0  5a98					      VAR	__toggle, 1
      1  5a98		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
      4  5a98
      0  5a98					      VAR	__bestMove, 1
      1  5a98		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
      0  5a98					      VAR	__alpha, 2
      1  5a98		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
      0  5a98					      VAR	__beta, 2
      1  5a98		       00 ac	   __beta     =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
      0  5a98					      VAR	__negaMax, 2
      1  5a98		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
      0  5a98					      VAR	__value, 2
      1  5a98		       00 b0	   __value    =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
     10  5a98
      0  5a98					      VAR	__quiesceCapOnly, 1
      1  5a98		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
     12  5a98
      0  5a98					      VAR	__originalPiece, 1
      1  5a98		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
      0  5a98					      VAR	__capturedPiece, 1
      1  5a98		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  5a98				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a98
      4  5a98				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a98				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a98				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a98					      ENDIF
      8  5a98				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a98				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  5a98				  -	      ERR
     11  5a98					      ENDIF
     12  5a98					      LIST	ON
     15  5a98
      0  5a98					      REFER	negaMax
      1  5a98				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  5a98				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  5a98					      ENDIF
      0  5a98					      VEND	quiesce
      1  5a98				  -	      IFNCONST	quiesce
      2  5a98				  -	      ECHO	"Incorrect VEND label", quiesce
      3  5a98				  -	      ERR
      4  5a98					      ENDIF
      5  5a98		       00 b5	   VAREND_quiesce =	TEMPORARY_VAR
    612  5a98
    613  5a98		       a5 94		      lda	currentPly
    614  5a9a		       c9 90		      cmp	#RAMBANK_PLY + PLY_BANKS -1
    615  5a9c		       b0 28		      bcs	.retBeta
    616  5a9e							;sta SET_BANK_RAM ;tmp
    617  5a9e
    618  5a9e
    619  5a9e		       20 7a f0 	      jsr	ThinkBar	;@0
    620  5aa1
    621  5aa1		       a5 ac		      lda	__beta
      0  5aa3					      sta@PLY	beta
      1  5aa3		       8d d4 fb 	      sta	[RAM]+beta
    623  5aa6		       a5 ad		      lda	__beta+1
      0  5aa8					      sta@PLY	beta+1
      1  5aa8		       8d d5 fb 	      sta	[RAM]+beta+1
    625  5aab
    626  5aab		       a5 aa		      lda	__alpha
      0  5aad					      sta@PLY	alpha
      1  5aad		       8d d2 fb 	      sta	[RAM]+alpha
    628  5ab0		       a5 ab		      lda	__alpha+1
      0  5ab2					      sta@PLY	alpha+1
      1  5ab2		       8d d3 fb 	      sta	[RAM]+alpha+1
    630  5ab5
    631  5ab5
    632  5ab5							;    int stand_pat = Evaluate();
    633  5ab5							;    if( stand_pat >= beta )
    634  5ab5							;	  return beta;
    635  5ab5
    636  5ab5		       38		      sec
    637  5ab6		       a5 8f		      lda	Evaluation
      0  5ab8					      sbc@PLY	beta
      1  5ab8		       ed d4 f9 	      sbc	beta
    639  5abb		       a5 90		      lda	Evaluation+1
      0  5abd					      sbc@PLY	beta+1
      1  5abd		       ed d5 f9 	      sbc	beta+1
    641  5ac0		       50 02		      bvc	.spat0
    642  5ac2		       49 80		      eor	#$80
    643  5ac4		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    644  5ac6
    645  5ac6		       ad d4 f9    .retBeta   lda	beta
    646  5ac9		       85 ae		      sta	__negaMax
    647  5acb		       ad d5 f9 	      lda	beta+1
    648  5ace		       85 af		      sta	__negaMax+1
    649  5ad0
    650  5ad0		       60	   .abort     rts
    651  5ad1
    652  5ad1				   .norb
    653  5ad1
    654  5ad1
    655  5ad1							;    if( alpha < stand_pat )
    656  5ad1							;	  alpha = stand_pat;
    657  5ad1
    658  5ad1		       38		      sec
    659  5ad2		       ad d2 f9 	      lda	alpha
    660  5ad5		       e5 8f		      sbc	Evaluation
    661  5ad7		       ad d3 f9 	      lda	alpha+1
    662  5ada		       e5 90		      sbc	Evaluation+1
    663  5adc		       50 02		      bvc	.spat1
    664  5ade		       49 80		      eor	#$80
    665  5ae0		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    666  5ae2
    667  5ae2							; alpha < stand_pat
    668  5ae2
    669  5ae2		       a5 8f		      lda	Evaluation
      0  5ae4					      sta@PLY	alpha
      1  5ae4		       8d d2 fb 	      sta	[RAM]+alpha
    671  5ae7		       a5 90		      lda	Evaluation+1
      0  5ae9					      sta@PLY	alpha+1
      1  5ae9		       8d d3 fb 	      sta	[RAM]+alpha+1
    673  5aec
    674  5aec				   .alpha
    675  5aec		       20 88 f1 	      jsr	GenerateAllMoves
    676  5aef		       a5 a0		      lda	flagCheck
    677  5af1		       d0 dd		      bne	.abort	; pure abort
    678  5af3
      0  5af3					      ldx@PLY	moveIndex
      1  5af3		       ae cf f9 	      ldx	moveIndex
    680  5af6		       30 76		      bmi	.exit
    681  5af8
      0  5af8				   .forChild  stx@PLY	movePtr
      1  5af8		       8e d0 fb 	      stx	[RAM]+movePtr
    683  5afb
    684  5afb							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    685  5afb
    686  5afb		       20 87 f4 	      jsr	MakeMove	;@this
    687  5afe
    688  5afe		       38		      sec
    689  5aff		       a9 00		      lda	#0
      0  5b01					      sbc@PLY	beta
      1  5b01		       ed d4 f9 	      sbc	beta
    691  5b04		       85 aa		      sta	__alpha
    692  5b06		       a9 00		      lda	#0
      0  5b08					      sbc@PLY	beta+1
      1  5b08		       ed d5 f9 	      sbc	beta+1
    694  5b0b		       85 ab		      sta	__alpha+1
    695  5b0d
    696  5b0d		       38		      sec
    697  5b0e		       a9 00		      lda	#0
      0  5b10					      sbc@PLY	alpha
      1  5b10		       ed d2 f9 	      sbc	alpha
    699  5b13		       85 ac		      sta	__beta
    700  5b15		       a9 00		      lda	#0
      0  5b17					      sbc@PLY	alpha+1
      1  5b17		       ed d3 f9 	      sbc	alpha+1
    702  5b1a		       85 ad		      sta	__beta+1
    703  5b1c
    704  5b1c		       e6 94		      inc	currentPly
    705  5b1e		       a5 94		      lda	currentPly
    706  5b20		       85 3e		      sta	SET_BANK_RAM	; self-switch
    707  5b22
    708  5b22		       20 98 f6 	      jsr	quiesce	;@this
    709  5b25
    710  5b25		       c6 94		      dec	currentPly
    711  5b27
    712  5b27		       20 92 f2 	      jsr	unmakeMove	;@0
    713  5b2a
    714  5b2a		       a5 a0		      lda	flagCheck	; don't consider moves which leave us in check
    715  5b2c		       d0 4b		      bne	.inCheck
    716  5b2e
    717  5b2e		       38		      sec
    718  5b2f							;lda #0			 ; already 0
    719  5b2f		       e5 ae		      sbc	__negaMax
    720  5b31		       85 ae		      sta	__negaMax
    721  5b33		       a9 00		      lda	#0
    722  5b35		       e5 af		      sbc	__negaMax+1
    723  5b37		       85 af		      sta	__negaMax+1	; -negaMax(...)
    724  5b39
    725  5b39
    726  5b39
    727  5b39							;	  if( score >= beta )
    728  5b39							;	      return beta;
    729  5b39
    730  5b39
    731  5b39		       38		      sec
    732  5b3a		       a5 ae		      lda	__negaMax
      0  5b3c					      sbc@PLY	beta
      1  5b3c		       ed d4 f9 	      sbc	beta
    734  5b3f		       a5 af		      lda	__negaMax+1
      0  5b41					      sbc@PLY	beta+1
      1  5b41		       ed d5 f9 	      sbc	beta+1
    736  5b44		       50 02		      bvc	.lab0
    737  5b46		       49 80		      eor	#$80
    738  5b48		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    739  5b4a		       4c c6 f6 	      jmp	.retBeta
    740  5b4d				   .nrb2
    741  5b4d
    742  5b4d							;	  if( score > alpha )
    743  5b4d							;	     alpha = score;
    744  5b4d							;    }
    745  5b4d
    746  5b4d		       38		      sec
      0  5b4e					      lda@PLY	alpha
      1  5b4e		       ad d2 f9 	      lda	alpha
    748  5b51		       e5 ae		      sbc	__negaMax
      0  5b53					      lda@PLY	alpha+1
      1  5b53		       ad d3 f9 	      lda	alpha+1
    750  5b56		       e5 af		      sbc	__negaMax+1
    751  5b58		       50 02		      bvc	.lab2
    752  5b5a		       49 80		      eor	#$80
    753  5b5c		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    754  5b5e
    755  5b5e							; score > alpha
    756  5b5e
    757  5b5e		       a5 ae		      lda	__negaMax
      0  5b60					      sta@PLY	alpha
      1  5b60		       8d d2 fb 	      sta	[RAM]+alpha
    759  5b63		       a5 af		      lda	__negaMax+1
      0  5b65					      sta@PLY	alpha+1
      1  5b65		       8d d3 fb 	      sta	[RAM]+alpha+1
    761  5b68
      0  5b68				   .nextMove  ldx@PLY	movePtr
      1  5b68		       ae d0 f9 	      ldx	movePtr
    763  5b6b		       ca		      dex
    764  5b6c		       10 8a		      bpl	.forChild
    765  5b6e
    766  5b6e							;    return alpha;
    767  5b6e
    768  5b6e				   .exit
      0  5b6e					      lda@PLY	alpha
      1  5b6e		       ad d2 f9 	      lda	alpha
    770  5b71		       85 ae		      sta	__negaMax
      0  5b73					      lda@PLY	alpha+1
      1  5b73		       ad d3 f9 	      lda	alpha+1
    772  5b76		       85 af		      sta	__negaMax+1
    773  5b78		       60		      rts
    774  5b79
    775  5b79		       a9 00	   .inCheck   lda	#0
    776  5b7b		       85 a0		      sta	flagCheck
    777  5b7d		       f0 e9		      beq	.nextMove
    778  5b7f
    779  5b7f
    780  5b7f							;---------------------------------------------------------------------------------------------------
    781  5b7f
      0  5b7f					      CHECK_BANK_SIZE	"NEGAMAX"
      1  5b7f		       03 7f	   .TEMP      =	* - _BANK_START
 NEGAMAX (1K) SIZE =  $37f , FREE= $81
      2  5b7f					      ECHO	"NEGAMAX", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5b7f				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5b7f				  -	      ECHO	"BANK OVERFLOW @ ", "NEGAMAX", " size=", * - ORIGIN
      5  5b7f				  -	      ERR
      6  5b7f					      ENDIF
    783  5b7f
    784  5b7f							;---------------------------------------------------------------------------------------------------
    785  5b7f							; EOF
------- FILE ./chess.asm
    639  5b7f
------- FILE PIECE_MACROS.asm LEVEL 2 PASS 4
      0  5b7f					      include	"PIECE_MACROS.asm"
      1  5b7f							; Copyright (C)2020 Andrew Davie
      2  5b7f							; Common macros for piece move handlers
      3  5b7f
      4  5b7f							;---------------------------------------------------------------------------------------------------
      5  5b7f							; Looks at a square offset {1} to see if piece can move to it
      6  5b7f							; Adds the square to the movelist if it can
      7  5b7f							; Keeps moving in the same direction until it's blocked/off=board
      8  5b7f
      9  5b7f					      MAC	move_towards
     10  5b7f					      SUBROUTINE
     11  5b7f
     12  5b7f							; = 76 for single square (empty/take)
     13  5b7f
     14  5b7f					      lda	#0
     15  5b7f					      sta	capture
     16  5b7f
     17  5b7f					      ldx	currentSquare	; 3
     18  5b7f					      bne	.project	; 3   unconditional
     19  5b7f
     20  5b7f				   .empty     jsr	AddMove	; 57
     21  5b7f				   .project   ldy	ValidSquare+{1},x	; 4
     22  5b7f					      bmi	.invalid	; 2/3 off board!
     23  5b7f					      lda	Board,y	; 4   piece @ destination
     24  5b7f					      beq	.empty	; 2/3
     25  5b7f					      sta	capture
     26  5b7f					      eor	currentPiece	; 3
     27  5b7f					      bpl	.invalid	; 2/3 same colour
     28  5b7f					      jsr	AddMove	; 57  and exit
     29  5b7f
     30  5b7f				   .invalid
     31  5b7f					      ENDM
     32  5b7f
     33  5b7f
     34  5b7f							;---------------------------------------------------------------------------------------------------
     35  5b7f
     36  5b7f					      MAC	move_to
     37  5b7f					      SUBROUTINE
     38  5b7f					      ldy	ValidSquare+{1},x
     39  5b7f					      bmi	.invalid	; off board!
     40  5b7f					      lda	Board,y	; piece @ destination
     41  5b7f					      sta	capture
     42  5b7f					      beq	.squareEmpty
     43  5b7f					      eor	currentPiece
     44  5b7f					      bpl	.invalid	; same colour
     45  5b7f				   .squareEmpty jsr	AddMove
     46  5b7f				   .invalid
     47  5b7f					      ENDM
     48  5b7f
     49  5b7f
     50  5b7f							;---------------------------------------------------------------------------------------------------
     51  5b7f
     52  5b7f					      MAC	move_to_x
     53  5b7f					      ldx	currentSquare
     54  5b7f					      MOVE_TO	{1}
     55  5b7f					      ENDM
     56  5b7f
     57  5b7f
     58  5b7f							;---------------------------------------------------------------------------------------------------
     59  5b7f							; EOF
------- FILE ./chess.asm
    641  5b7f
------- FILE PIECE_HANDLER@1#1.asm LEVEL 2 PASS 4
      0  5b7f					      include	"PIECE_HANDLER@1#1.asm"
      0  5b7f					      SLOT	1
      1  5b7f				  -	      IF	(1 < 0) || (1 > 3)
      2  5b7f				  -	      ECHO	"Illegal bank address/segment location", 1
      3  5b7f				  -	      ERR
      4  5b7f					      ENDIF
      5  5b7f				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  5b7f				   _BANK_SLOT SET	1 * 64
      0  5b7f					      NEWBANK	PIECE_HANDLER_1
      1  5e68 ????				      SEG	PIECE_HANDLER_1
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   PIECE_HANDLER_1_START SET	*
      6  5c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5c00				   PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  5c00
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  5c00					      include	"PIECE_PAWN.asm"
      1  5c00							; Copyright (C)2020 Andrew Davie
      2  5c00							; Pawn move handlers
      3  5c00
      4  5c00							;---------------------------------------------------------------------------------------------------
      5  5c00							; WHITE PAWN
      6  5c00							;---------------------------------------------------------------------------------------------------
      7  5c00
      8  5c00		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  5c00		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  5c00
     11  5c00							;---------------------------------------------------------------------------------------------------
     12  5c00
     13  5c00					      MAC	en_passant
     14  5c00					      SUBROUTINE
     15  5c00							; {1} = _LEFT or _RIGHT
     16  5c00
     17  5c00					      ldx	currentSquare
     18  5c00					      ldy	ValidSquare+{1},x
     19  5c00					      cpy	enPassantPawn
     20  5c00					      bne	.invalid
     21  5c00					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  5c00					      lda	Board,y
     23  5c00					      bne	.invalid
     24  5c00					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  5c00				   .invalid
     26  5c00					      ENDM
     27  5c00
     28  5c00							;---------------------------------------------------------------------------------------------------
     29  5c00
     30  5c00					      MAC	promote_pawn
     31  5c00							;SUBROUTINE
     32  5c00
     33  5c00							;{1} = BLACK or WHITE
     34  5c00
     35  5c00
     36  5c00					      sty	__temp
     37  5c00					      lda	#{1}|QUEEN
     38  5c00					      sta	currentPiece
     39  5c00					      jsr	AddMove
     40  5c00
     41  5c00					      lda	#{1}|ROOK
     42  5c00					      sta	currentPiece
     43  5c00					      ldy	__temp
     44  5c00					      jsr	AddMove
     45  5c00
     46  5c00					      lda	#{1}|BISHOP
     47  5c00					      sta	currentPiece
     48  5c00					      ldy	__temp
     49  5c00					      jsr	AddMove
     50  5c00
     51  5c00					      lda	#{1}|KNIGHT
     52  5c00					      sta	currentPiece
     53  5c00					      ldy	__temp
     54  5c00					      jsr	AddMove
     55  5c00
     56  5c00					      IF	{1} = WHITE
     57  5c00					      lda	#WHITE|WP
     58  5c00					      ENDIF
     59  5c00					      IF	{1} = BLACK
     60  5c00					      lda	#BLACK|BP
     61  5c00					      ENDIF
     62  5c00					      sta	currentPiece
     63  5c00					      ENDM
     64  5c00
     65  5c00							;---------------------------------------------------------------------------------------------------
     66  5c00
     67  5c00					      MAC	move_or_promote_pawn
     68  5c00							;SUBROUTINE
     69  5c00							; {1} = BLACK or WHITE
     70  5c00
     71  5c00					      IF	{1} = WHITE
     72  5c00					      cpy	#90	; last rank?
     73  5c00					      bcc	.standard
     74  5c00					      jsr	PromoteWhitePawn
     75  5c00					      jmp	.pMoved
     76  5c00					      ENDIF
     77  5c00
     78  5c00					      IF	{1} = BLACK
     79  5c00					      cpy	#30	; last rank?
     80  5c00					      bcs	.standard
     81  5c00					      jsr	PromoteBlackPawn
     82  5c00					      jmp	.pMoved
     83  5c00					      ENDIF
     84  5c00
     85  5c00				   .standard  jsr	AddMove	; add +1UP move
     86  5c00				   .pMoved
     87  5c00
     88  5c00					      ENDM
     89  5c00
     90  5c00							;---------------------------------------------------------------------------------------------------
     91  5c00
     92  5c00					      MAC	take
     93  5c00							;SUBROUTINE
     94  5c00							; {1} = capture square offset
     95  5c00
     96  5c00					      ldx	currentSquare
     97  5c00					      ldy	ValidSquare+{1},x
     98  5c00					      bmi	.invalid2
     99  5c00					      lda	Board,y
    100  5c00					      beq	.invalid2	; square empty
    101  5c00					      sta	capture
    102  5c00					      eor	currentPiece
    103  5c00					      bpl	.invalid	; same colour
    104  5c00
    105  5c00					      MOVE_OR_PROMOTE_PAWN	{2}
    106  5c00
    107  5c00					      jmp	.invalid2
    108  5c00				   .invalid   inc	protecting
    109  5c00				   .invalid2
    110  5c00					      ENDM
    111  5c00
    112  5c00							;---------------------------------------------------------------------------------------------------
    113  5c00
      0  5c00					      DEF	PromoteWhitePawn
      1  5c00				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  5c00				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  5c00				   PromoteWhitePawn
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	PromoteWhitePawn
    115  5c00					      SUBROUTINE
    116  5c00
      0  5c00					      REFER	Handle_WHITE_PAWN
      1  5c00					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  5c00				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  5c00					      ENDIF
      0  5c00					      VAR	__temp, 1
      1  5c00		       00 b8	   __temp     =	TEMPORARY_VAR
      2  5c00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5c00
      4  5c00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c00					      ENDIF
      8  5c00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c00				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  5c00				  -	      ERR
     11  5c00					      ENDIF
     12  5c00					      LIST	ON
      0  5c00					      VEND	PromoteWhitePawn
      1  5c00				  -	      IFNCONST	PromoteWhitePawn
      2  5c00				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  5c00				  -	      ERR
      4  5c00					      ENDIF
      5  5c00		       00 b9	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  5c00
      0  5c00					      PROMOTE_PAWN	WHITE
      1  5c00
      2  5c00
      3  5c00
      4  5c00
      5  5c00
      6  5c00		       84 b8		      sty	__temp
      7  5c02		       a9 06		      lda	#WHITE|QUEEN
      8  5c04		       85 91		      sta	currentPiece
      9  5c06		       20 6a f2 	      jsr	AddMove
     10  5c09
     11  5c09		       a9 05		      lda	#WHITE|ROOK
     12  5c0b		       85 91		      sta	currentPiece
     13  5c0d		       a4 b8		      ldy	__temp
     14  5c0f		       20 6a f2 	      jsr	AddMove
     15  5c12
     16  5c12		       a9 04		      lda	#WHITE|BISHOP
     17  5c14		       85 91		      sta	currentPiece
     18  5c16		       a4 b8		      ldy	__temp
     19  5c18		       20 6a f2 	      jsr	AddMove
     20  5c1b
     21  5c1b		       a9 03		      lda	#WHITE|KNIGHT
     22  5c1d		       85 91		      sta	currentPiece
     23  5c1f		       a4 b8		      ldy	__temp
     24  5c21		       20 6a f2 	      jsr	AddMove
     25  5c24
     26  5c24					      IF	WHITE = WHITE
     27  5c24		       a9 01		      lda	#WHITE|WP
     28  5c26					      ENDIF
     29  5c26				  -	      IF	WHITE = BLACK
     30  5c26				  -	      lda	#BLACK|BP
     31  5c26					      ENDIF
     32  5c26		       85 91		      sta	currentPiece
    122  5c28		       60		      rts
    123  5c29
    124  5c29							;---------------------------------------------------------------------------------------------------
    125  5c29
      0  5c29					      DEF	Handle_WHITE_PAWN
      1  5c29				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  5c29				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  5c29				   Handle_WHITE_PAWN
      4  5c29				   TEMPORARY_VAR SET	Overlay
      5  5c29				   TEMPORARY_OFFSET SET	0
      6  5c29				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  5c29				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  5c29					      SUBROUTINE
    128  5c29
      0  5c29					      REFER	GenerateAllMoves
      1  5c29					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5c29				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5c29					      ENDIF
      0  5c29					      VEND	Handle_WHITE_PAWN
      1  5c29				  -	      IFNCONST	Handle_WHITE_PAWN
      2  5c29				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  5c29				  -	      ERR
      4  5c29					      ENDIF
      5  5c29		       00 b8	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  5c29
    132  5c29		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  5c2c		       b9 79 fc 	      lda	Board,y
    134  5c2f		       d0 26		      bne	.pMoved	; occupied
    135  5c31		       85 9c		      sta	capture
    136  5c33
    137  5c33							; we may need to promote the pawn
    138  5c33							; All possibilites (Q/R/B/N) are added as individual moves
    139  5c33
      0  5c33					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  5c33
      2  5c33
      3  5c33
      4  5c33					      IF	WHITE = WHITE
      5  5c33		       c0 5a		      cpy	#90
      6  5c35		       90 06		      bcc	.standard
      7  5c37		       20 00 f4 	      jsr	PromoteWhitePawn
      8  5c3a		       4c 40 f4 	      jmp	.pMoved
      9  5c3d					      ENDIF
     10  5c3d
     11  5c3d				  -	      IF	WHITE = BLACK
     12  5c3d				  -	      cpy	#30
     13  5c3d				  -	      bcs	.standard
     14  5c3d				  -	      jsr	PromoteBlackPawn
     15  5c3d				  -	      jmp	.pMoved
     16  5c3d					      ENDIF
     17  5c3d
     18  5c3d		       20 6a f2    .standard  jsr	AddMove
     19  5c40				   .pMoved
     20  5c40
    141  5c40
    142  5c40							; the +2 move off the home rank...
    143  5c40
    144  5c40		       a6 92		      ldx	currentSquare
    145  5c42		       e0 28		      cpx	#WHITE_HOME_ROW
    146  5c44		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  5c46		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  5c49		       b9 79 fc 	      lda	Board,y
    149  5c4c		       d0 09		      bne	.pMoved	; destination square occupied
    150  5c4e
    151  5c4e		       a5 91		      lda	currentPiece
    152  5c50		       09 20		      ora	#FLAG_ENPASSANT
    153  5c52		       85 91		      sta	currentPiece	; GENERATE en-passant opportunity
    154  5c54
    155  5c54		       20 6a f2 	      jsr	AddMove	; add the +2UP move off home row
    156  5c57
    157  5c57				   .pMoved
    158  5c57
    159  5c57							; regular captures...
    160  5c57
      0  5c57					      TAKE	_UP+_LEFT, WHITE
      1  5c57
      2  5c57
      3  5c57
      4  5c57		       a6 92		      ldx	currentSquare
      5  5c59		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  5c5c		       30 1d		      bmi	.invalid2
      7  5c5e		       b9 79 fc 	      lda	Board,y
      8  5c61		       f0 18		      beq	.invalid2
      9  5c63		       85 9c		      sta	capture
     10  5c65		       45 91		      eor	currentPiece
     11  5c67		       10 10		      bpl	.invalid
     12  5c69
      0  5c69					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  5c69
      2  5c69
      3  5c69
      4  5c69					      IF	WHITE = WHITE
      5  5c69		       c0 5a		      cpy	#90
      6  5c6b		       90 06		      bcc	.standard
      7  5c6d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  5c70		       4c 76 f4 	      jmp	.pMoved
      9  5c73					      ENDIF
     10  5c73
     11  5c73				  -	      IF	WHITE = BLACK
     12  5c73				  -	      cpy	#30
     13  5c73				  -	      bcs	.standard
     14  5c73				  -	      jsr	PromoteBlackPawn
     15  5c73				  -	      jmp	.pMoved
     16  5c73					      ENDIF
     17  5c73
     18  5c73		       20 6a f2    .standard  jsr	AddMove
     19  5c76				   .pMoved
     20  5c76
     14  5c76
     15  5c76		       4c 7b f4 	      jmp	.invalid2
     16  5c79		       e6 a1	   .invalid   inc	protecting
     17  5c7b				   .invalid2
      0  5c7b					      TAKE	_UP+_RIGHT, WHITE
      1  5c7b
      2  5c7b
      3  5c7b
      4  5c7b		       a6 92		      ldx	currentSquare
      5  5c7d		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  5c80		       30 1d		      bmi	.invalid2
      7  5c82		       b9 79 fc 	      lda	Board,y
      8  5c85		       f0 18		      beq	.invalid2
      9  5c87		       85 9c		      sta	capture
     10  5c89		       45 91		      eor	currentPiece
     11  5c8b		       10 10		      bpl	.invalid
     12  5c8d
      0  5c8d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  5c8d
      2  5c8d
      3  5c8d
      4  5c8d					      IF	WHITE = WHITE
      5  5c8d		       c0 5a		      cpy	#90
      6  5c8f		       90 06		      bcc	.standard
      7  5c91		       20 00 f4 	      jsr	PromoteWhitePawn
      8  5c94		       4c 9a f4 	      jmp	.pMoved
      9  5c97					      ENDIF
     10  5c97
     11  5c97				  -	      IF	WHITE = BLACK
     12  5c97				  -	      cpy	#30
     13  5c97				  -	      bcs	.standard
     14  5c97				  -	      jsr	PromoteBlackPawn
     15  5c97				  -	      jmp	.pMoved
     16  5c97					      ENDIF
     17  5c97
     18  5c97		       20 6a f2    .standard  jsr	AddMove
     19  5c9a				   .pMoved
     20  5c9a
     14  5c9a
     15  5c9a		       4c 9f f4 	      jmp	.invalid2
     16  5c9d		       e6 a1	   .invalid   inc	protecting
     17  5c9f				   .invalid2
    163  5c9f
    164  5c9f
    165  5c9f				  -	      IF	ENPASSANT_ENABLED
    166  5c9f				  -			; en-passant captures...
    167  5c9f				  -
    168  5c9f				  -	      lda	enPassantPawn
    169  5c9f				  -	      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  5c9f				  -
    171  5c9f				  -	      lda	currentPiece
    172  5c9f				  -	      ora	#FLAG_ENPASSANT
    173  5c9f				  -	      sta	currentPiece	; CONSUME en-passant opportunity
    174  5c9f				  -
    175  5c9f				  -	      EN_PASSANT	_LEFT, _UP
    176  5c9f				  -	      EN_PASSANT	_RIGHT, _UP
    177  5c9f				  -
    178  5c9f				  -.noEnPassant
    179  5c9f					      ENDIF
    180  5c9f
    181  5c9f		       4c cd f1 	      jmp	MoveReturn
    182  5ca2
    183  5ca2
    184  5ca2							;---------------------------------------------------------------------------------------------------
    185  5ca2							; BLACK PAWN
    186  5ca2							;---------------------------------------------------------------------------------------------------
    187  5ca2
      0  5ca2					      DEF	PromoteBlackPawn
      1  5ca2				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  5ca2				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  5ca2				   PromoteBlackPawn
      4  5ca2				   TEMPORARY_VAR SET	Overlay
      5  5ca2				   TEMPORARY_OFFSET SET	0
      6  5ca2				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  5ca2				   FUNCTION_NAME SET	PromoteBlackPawn
    189  5ca2					      SUBROUTINE
    190  5ca2
      0  5ca2					      REFER	Handle_BLACK_PAWN
      1  5ca2					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  5ca2				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  5ca2					      ENDIF
      0  5ca2					      VAR	__temp, 1
      1  5ca2		       00 b8	   __temp     =	TEMPORARY_VAR
      2  5ca2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5ca2
      4  5ca2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5ca2				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5ca2				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5ca2					      ENDIF
      8  5ca2				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5ca2				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  5ca2				  -	      ERR
     11  5ca2					      ENDIF
     12  5ca2					      LIST	ON
      0  5ca2					      VEND	PromoteBlackPawn
      1  5ca2				  -	      IFNCONST	PromoteBlackPawn
      2  5ca2				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  5ca2				  -	      ERR
      4  5ca2					      ENDIF
      5  5ca2		       00 b9	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  5ca2
      0  5ca2					      PROMOTE_PAWN	BLACK
      1  5ca2
      2  5ca2
      3  5ca2
      4  5ca2
      5  5ca2
      6  5ca2		       84 b8		      sty	__temp
      7  5ca4		       a9 86		      lda	#BLACK|QUEEN
      8  5ca6		       85 91		      sta	currentPiece
      9  5ca8		       20 6a f2 	      jsr	AddMove
     10  5cab
     11  5cab		       a9 85		      lda	#BLACK|ROOK
     12  5cad		       85 91		      sta	currentPiece
     13  5caf		       a4 b8		      ldy	__temp
     14  5cb1		       20 6a f2 	      jsr	AddMove
     15  5cb4
     16  5cb4		       a9 84		      lda	#BLACK|BISHOP
     17  5cb6		       85 91		      sta	currentPiece
     18  5cb8		       a4 b8		      ldy	__temp
     19  5cba		       20 6a f2 	      jsr	AddMove
     20  5cbd
     21  5cbd		       a9 83		      lda	#BLACK|KNIGHT
     22  5cbf		       85 91		      sta	currentPiece
     23  5cc1		       a4 b8		      ldy	__temp
     24  5cc3		       20 6a f2 	      jsr	AddMove
     25  5cc6
     26  5cc6				  -	      IF	BLACK = WHITE
     27  5cc6				  -	      lda	#WHITE|WP
     28  5cc6					      ENDIF
     29  5cc6					      IF	BLACK = BLACK
     30  5cc6		       a9 82		      lda	#BLACK|BP
     31  5cc8					      ENDIF
     32  5cc8		       85 91		      sta	currentPiece
    196  5cca		       60		      rts
    197  5ccb
      0  5ccb					      DEF	Handle_BLACK_PAWN
      1  5ccb				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  5ccb				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  5ccb				   Handle_BLACK_PAWN
      4  5ccb				   TEMPORARY_VAR SET	Overlay
      5  5ccb				   TEMPORARY_OFFSET SET	0
      6  5ccb				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  5ccb				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  5ccb					      SUBROUTINE
    200  5ccb
      0  5ccb					      REFER	GenerateAllMoves
      1  5ccb					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5ccb				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5ccb					      ENDIF
      0  5ccb					      VEND	Handle_BLACK_PAWN
      1  5ccb				  -	      IFNCONST	Handle_BLACK_PAWN
      2  5ccb				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  5ccb				  -	      ERR
      4  5ccb					      ENDIF
      5  5ccb		       00 b8	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  5ccb
    204  5ccb		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  5cce		       b9 79 fc 	      lda	Board,y
    206  5cd1		       d0 26		      bne	.pMoved	; occupied
    207  5cd3		       85 9c		      sta	capture
    208  5cd5
    209  5cd5							; we may need to promote the pawn
    210  5cd5							; All possibilites (Q/R/B/N) are added as individual moves
    211  5cd5
      0  5cd5					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  5cd5
      2  5cd5
      3  5cd5
      4  5cd5				  -	      IF	BLACK = WHITE
      5  5cd5				  -	      cpy	#90
      6  5cd5				  -	      bcc	.standard
      7  5cd5				  -	      jsr	PromoteWhitePawn
      8  5cd5				  -	      jmp	.pMoved
      9  5cd5					      ENDIF
     10  5cd5
     11  5cd5					      IF	BLACK = BLACK
     12  5cd5		       c0 1e		      cpy	#30
     13  5cd7		       b0 06		      bcs	.standard
     14  5cd9		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  5cdc		       4c e2 f4 	      jmp	.pMoved
     16  5cdf					      ENDIF
     17  5cdf
     18  5cdf		       20 6a f2    .standard  jsr	AddMove
     19  5ce2				   .pMoved
     20  5ce2
    213  5ce2
    214  5ce2							; the +2 move off the home rank...
    215  5ce2
    216  5ce2		       a6 92		      ldx	currentSquare
    217  5ce4		       e0 52		      cpx	#BLACK_HOME_ROW
    218  5ce6		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  5ce8
    220  5ce8
    221  5ce8		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  5ceb		       b9 79 fc 	      lda	Board,y
    223  5cee		       d0 09		      bne	.pMoved	; destination square occupied
    224  5cf0
    225  5cf0		       a5 91		      lda	currentPiece
    226  5cf2		       09 20		      ora	#FLAG_ENPASSANT
    227  5cf4		       85 91		      sta	currentPiece	; CAN en-passant
    228  5cf6
    229  5cf6		       20 6a f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  5cf9
    231  5cf9				   .pMoved
    232  5cf9
    233  5cf9							; regular captures... (with promotion)
    234  5cf9
      0  5cf9					      TAKE	_DOWN+_LEFT, BLACK
      1  5cf9
      2  5cf9
      3  5cf9
      4  5cf9		       a6 92		      ldx	currentSquare
      5  5cfb		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  5cfe		       30 1d		      bmi	.invalid2
      7  5d00		       b9 79 fc 	      lda	Board,y
      8  5d03		       f0 18		      beq	.invalid2
      9  5d05		       85 9c		      sta	capture
     10  5d07		       45 91		      eor	currentPiece
     11  5d09		       10 10		      bpl	.invalid
     12  5d0b
      0  5d0b					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  5d0b
      2  5d0b
      3  5d0b
      4  5d0b				  -	      IF	BLACK = WHITE
      5  5d0b				  -	      cpy	#90
      6  5d0b				  -	      bcc	.standard
      7  5d0b				  -	      jsr	PromoteWhitePawn
      8  5d0b				  -	      jmp	.pMoved
      9  5d0b					      ENDIF
     10  5d0b
     11  5d0b					      IF	BLACK = BLACK
     12  5d0b		       c0 1e		      cpy	#30
     13  5d0d		       b0 06		      bcs	.standard
     14  5d0f		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  5d12		       4c 18 f5 	      jmp	.pMoved
     16  5d15					      ENDIF
     17  5d15
     18  5d15		       20 6a f2    .standard  jsr	AddMove
     19  5d18				   .pMoved
     20  5d18
     14  5d18
     15  5d18		       4c 1d f5 	      jmp	.invalid2
     16  5d1b		       e6 a1	   .invalid   inc	protecting
     17  5d1d				   .invalid2
      0  5d1d					      TAKE	_DOWN+_RIGHT, BLACK
      1  5d1d
      2  5d1d
      3  5d1d
      4  5d1d		       a6 92		      ldx	currentSquare
      5  5d1f		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  5d22		       30 1d		      bmi	.invalid2
      7  5d24		       b9 79 fc 	      lda	Board,y
      8  5d27		       f0 18		      beq	.invalid2
      9  5d29		       85 9c		      sta	capture
     10  5d2b		       45 91		      eor	currentPiece
     11  5d2d		       10 10		      bpl	.invalid
     12  5d2f
      0  5d2f					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  5d2f
      2  5d2f
      3  5d2f
      4  5d2f				  -	      IF	BLACK = WHITE
      5  5d2f				  -	      cpy	#90
      6  5d2f				  -	      bcc	.standard
      7  5d2f				  -	      jsr	PromoteWhitePawn
      8  5d2f				  -	      jmp	.pMoved
      9  5d2f					      ENDIF
     10  5d2f
     11  5d2f					      IF	BLACK = BLACK
     12  5d2f		       c0 1e		      cpy	#30
     13  5d31		       b0 06		      bcs	.standard
     14  5d33		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  5d36		       4c 3c f5 	      jmp	.pMoved
     16  5d39					      ENDIF
     17  5d39
     18  5d39		       20 6a f2    .standard  jsr	AddMove
     19  5d3c				   .pMoved
     20  5d3c
     14  5d3c
     15  5d3c		       4c 41 f5 	      jmp	.invalid2
     16  5d3f		       e6 a1	   .invalid   inc	protecting
     17  5d41				   .invalid2
    237  5d41
    238  5d41
    239  5d41				  -	      IF	ENPASSANT_ENABLED
    240  5d41				  -			; en-passant captures...
    241  5d41				  -
    242  5d41				  -	      lda	enPassantPawn
    243  5d41				  -	      beq	.noEnPassant	; was last move en-passantable?
    244  5d41				  -
    245  5d41				  -	      lda	currentPiece
    246  5d41				  -	      ora	#FLAG_ENPASSANT
    247  5d41				  -	      sta	currentPiece	; any en-passant move added will have flag set
    248  5d41				  -
    249  5d41				  -	      EN_PASSANT	_LEFT, _DOWN
    250  5d41				  -	      EN_PASSANT	_RIGHT, _DOWN
    251  5d41				  -
    252  5d41				  -.noEnPassant
    253  5d41					      ENDIF
    254  5d41
    255  5d41		       4c cd f1 	      jmp	MoveReturn
    256  5d44
    257  5d44							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  5d44					      include	"PIECE_KNIGHT.asm"
      1  5d44							; Copyright (C)2020 Andrew Davie
      2  5d44							; Knight move handler
      3  5d44
      4  5d44							;---------------------------------------------------------------------------------------------------
      5  5d44							; KNIGHT
      6  5d44							;---------------------------------------------------------------------------------------------------
      7  5d44
      0  5d44					      DEF	Handle_KNIGHT
      1  5d44				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  5d44				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  5d44				   Handle_KNIGHT
      4  5d44				   TEMPORARY_VAR SET	Overlay
      5  5d44				   TEMPORARY_OFFSET SET	0
      6  5d44				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  5d44				   FUNCTION_NAME SET	Handle_KNIGHT
      9  5d44					      SUBROUTINE
     10  5d44
      0  5d44					      REFER	GenerateAllMoves	;✅
      1  5d44					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5d44				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5d44					      ENDIF
      0  5d44					      VEND	Handle_KNIGHT
      1  5d44				  -	      IFNCONST	Handle_KNIGHT
      2  5d44				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  5d44				  -	      ERR
      4  5d44					      ENDIF
      5  5d44		       00 b8	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  5d44
     14  5d44							; x = currentSquare (square the piece is on)
     15  5d44							; currentPiece (with flags/colour attached)
     16  5d44
      0  5d44					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  5d44					      SUBROUTINE
      2  5d44		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  5d47		       30 0e		      bmi	.invalid
      4  5d49		       b9 79 fc 	      lda	Board,y
      5  5d4c		       85 9c		      sta	capture
      6  5d4e		       f0 04		      beq	.squareEmpty
      7  5d50		       45 91		      eor	currentPiece
      8  5d52		       10 03		      bpl	.invalid
      9  5d54		       20 6a f2    .squareEmpty jsr	AddMove
     10  5d57				   .invalid
      0  5d57					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  5d57		       a6 92		      ldx	currentSquare
      0  5d59					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  5d59					      SUBROUTINE
      2  5d59		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  5d5c		       30 0e		      bmi	.invalid
      4  5d5e		       b9 79 fc 	      lda	Board,y
      5  5d61		       85 9c		      sta	capture
      6  5d63		       f0 04		      beq	.squareEmpty
      7  5d65		       45 91		      eor	currentPiece
      8  5d67		       10 03		      bpl	.invalid
      9  5d69		       20 6a f2    .squareEmpty jsr	AddMove
     10  5d6c				   .invalid
      0  5d6c					      MOVE_TO_X	_UP+_UP+_LEFT
      1  5d6c		       a6 92		      ldx	currentSquare
      0  5d6e					      MOVE_TO	_UP+_UP+_LEFT
      1  5d6e					      SUBROUTINE
      2  5d6e		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  5d71		       30 0e		      bmi	.invalid
      4  5d73		       b9 79 fc 	      lda	Board,y
      5  5d76		       85 9c		      sta	capture
      6  5d78		       f0 04		      beq	.squareEmpty
      7  5d7a		       45 91		      eor	currentPiece
      8  5d7c		       10 03		      bpl	.invalid
      9  5d7e		       20 6a f2    .squareEmpty jsr	AddMove
     10  5d81				   .invalid
      0  5d81					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  5d81		       a6 92		      ldx	currentSquare
      0  5d83					      MOVE_TO	_UP+_UP+_RIGHT
      1  5d83					      SUBROUTINE
      2  5d83		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  5d86		       30 0e		      bmi	.invalid
      4  5d88		       b9 79 fc 	      lda	Board,y
      5  5d8b		       85 9c		      sta	capture
      6  5d8d		       f0 04		      beq	.squareEmpty
      7  5d8f		       45 91		      eor	currentPiece
      8  5d91		       10 03		      bpl	.invalid
      9  5d93		       20 6a f2    .squareEmpty jsr	AddMove
     10  5d96				   .invalid
     21  5d96
      0  5d96					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  5d96		       a6 92		      ldx	currentSquare
      0  5d98					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  5d98					      SUBROUTINE
      2  5d98		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  5d9b		       30 0e		      bmi	.invalid
      4  5d9d		       b9 79 fc 	      lda	Board,y
      5  5da0		       85 9c		      sta	capture
      6  5da2		       f0 04		      beq	.squareEmpty
      7  5da4		       45 91		      eor	currentPiece
      8  5da6		       10 03		      bpl	.invalid
      9  5da8		       20 6a f2    .squareEmpty jsr	AddMove
     10  5dab				   .invalid
      0  5dab					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  5dab		       a6 92		      ldx	currentSquare
      0  5dad					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  5dad					      SUBROUTINE
      2  5dad		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  5db0		       30 0e		      bmi	.invalid
      4  5db2		       b9 79 fc 	      lda	Board,y
      5  5db5		       85 9c		      sta	capture
      6  5db7		       f0 04		      beq	.squareEmpty
      7  5db9		       45 91		      eor	currentPiece
      8  5dbb		       10 03		      bpl	.invalid
      9  5dbd		       20 6a f2    .squareEmpty jsr	AddMove
     10  5dc0				   .invalid
      0  5dc0					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  5dc0		       a6 92		      ldx	currentSquare
      0  5dc2					      MOVE_TO	_UP+_LEFT+_LEFT
      1  5dc2					      SUBROUTINE
      2  5dc2		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  5dc5		       30 0e		      bmi	.invalid
      4  5dc7		       b9 79 fc 	      lda	Board,y
      5  5dca		       85 9c		      sta	capture
      6  5dcc		       f0 04		      beq	.squareEmpty
      7  5dce		       45 91		      eor	currentPiece
      8  5dd0		       10 03		      bpl	.invalid
      9  5dd2		       20 6a f2    .squareEmpty jsr	AddMove
     10  5dd5				   .invalid
      0  5dd5					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  5dd5		       a6 92		      ldx	currentSquare
      0  5dd7					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  5dd7					      SUBROUTINE
      2  5dd7		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  5dda		       30 0e		      bmi	.invalid
      4  5ddc		       b9 79 fc 	      lda	Board,y
      5  5ddf		       85 9c		      sta	capture
      6  5de1		       f0 04		      beq	.squareEmpty
      7  5de3		       45 91		      eor	currentPiece
      8  5de5		       10 03		      bpl	.invalid
      9  5de7		       20 6a f2    .squareEmpty jsr	AddMove
     10  5dea				   .invalid
     26  5dea
     27  5dea		       4c cd f1 	      jmp	MoveReturn
     28  5ded
     29  5ded							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  5ded					      include	"PIECE_BISHOP.asm"
      1  5ded							; Copyright (C)2020 Andrew Davie
      2  5ded
      3  5ded							;---------------------------------------------------------------------------------------------------
      4  5ded							; BISHOP
      5  5ded							;---------------------------------------------------------------------------------------------------
      6  5ded
      0  5ded					      DEF	Handle_BISHOP
      1  5ded				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  5ded				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  5ded				   Handle_BISHOP
      4  5ded				   TEMPORARY_VAR SET	Overlay
      5  5ded				   TEMPORARY_OFFSET SET	0
      6  5ded				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  5ded				   FUNCTION_NAME SET	Handle_BISHOP
      8  5ded					      SUBROUTINE
      9  5ded
      0  5ded					      REFER	GenerateAllMoves	;✅
      1  5ded					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5ded				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5ded					      ENDIF
      0  5ded					      VEND	Handle_BISHOP
      1  5ded				  -	      IFNCONST	Handle_BISHOP
      2  5ded				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  5ded				  -	      ERR
      4  5ded					      ENDIF
      5  5ded		       00 b8	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  5ded
     13  5ded							; x = currentSquare (square the piece is on)
     14  5ded							; currentPiece (with flags/colour attached)
     15  5ded
      0  5ded					      MOVE_TOWARDS	_DOWN+_LEFT
      1  5ded					      SUBROUTINE
      2  5ded
      3  5ded
      4  5ded
      5  5ded		       a9 00		      lda	#0
      6  5def		       85 9c		      sta	capture
      7  5df1
      8  5df1		       a6 92		      ldx	currentSquare
      9  5df3		       d0 03		      bne	.project
     10  5df5
     11  5df5		       20 6a f2    .empty     jsr	AddMove
     12  5df8		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  5dfb		       30 0e		      bmi	.invalid
     14  5dfd		       b9 79 fc 	      lda	Board,y
     15  5e00		       f0 f3		      beq	.empty
     16  5e02		       85 9c		      sta	capture
     17  5e04		       45 91		      eor	currentPiece
     18  5e06		       10 03		      bpl	.invalid
     19  5e08		       20 6a f2 	      jsr	AddMove
     20  5e0b
     21  5e0b				   .invalid
      0  5e0b					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  5e0b					      SUBROUTINE
      2  5e0b
      3  5e0b
      4  5e0b
      5  5e0b		       a9 00		      lda	#0
      6  5e0d		       85 9c		      sta	capture
      7  5e0f
      8  5e0f		       a6 92		      ldx	currentSquare
      9  5e11		       d0 03		      bne	.project
     10  5e13
     11  5e13		       20 6a f2    .empty     jsr	AddMove
     12  5e16		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  5e19		       30 0e		      bmi	.invalid
     14  5e1b		       b9 79 fc 	      lda	Board,y
     15  5e1e		       f0 f3		      beq	.empty
     16  5e20		       85 9c		      sta	capture
     17  5e22		       45 91		      eor	currentPiece
     18  5e24		       10 03		      bpl	.invalid
     19  5e26		       20 6a f2 	      jsr	AddMove
     20  5e29
     21  5e29				   .invalid
      0  5e29					      MOVE_TOWARDS	_UP+_LEFT
      1  5e29					      SUBROUTINE
      2  5e29
      3  5e29
      4  5e29
      5  5e29		       a9 00		      lda	#0
      6  5e2b		       85 9c		      sta	capture
      7  5e2d
      8  5e2d		       a6 92		      ldx	currentSquare
      9  5e2f		       d0 03		      bne	.project
     10  5e31
     11  5e31		       20 6a f2    .empty     jsr	AddMove
     12  5e34		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  5e37		       30 0e		      bmi	.invalid
     14  5e39		       b9 79 fc 	      lda	Board,y
     15  5e3c		       f0 f3		      beq	.empty
     16  5e3e		       85 9c		      sta	capture
     17  5e40		       45 91		      eor	currentPiece
     18  5e42		       10 03		      bpl	.invalid
     19  5e44		       20 6a f2 	      jsr	AddMove
     20  5e47
     21  5e47				   .invalid
      0  5e47					      MOVE_TOWARDS	_UP+_RIGHT
      1  5e47					      SUBROUTINE
      2  5e47
      3  5e47
      4  5e47
      5  5e47		       a9 00		      lda	#0
      6  5e49		       85 9c		      sta	capture
      7  5e4b
      8  5e4b		       a6 92		      ldx	currentSquare
      9  5e4d		       d0 03		      bne	.project
     10  5e4f
     11  5e4f		       20 6a f2    .empty     jsr	AddMove
     12  5e52		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  5e55		       30 0e		      bmi	.invalid
     14  5e57		       b9 79 fc 	      lda	Board,y
     15  5e5a		       f0 f3		      beq	.empty
     16  5e5c		       85 9c		      sta	capture
     17  5e5e		       45 91		      eor	currentPiece
     18  5e60		       10 03		      bpl	.invalid
     19  5e62		       20 6a f2 	      jsr	AddMove
     20  5e65
     21  5e65				   .invalid
     20  5e65
     21  5e65		       4c cd f1 	      jmp	MoveReturn
     22  5e68
     23  5e68							;---------------------------------------------------------------------------------------------------
     24  5e68							; EOF
------- FILE PIECE_HANDLER@1#1.asm
      7  5e68
      8  5e68							;---------------------------------------------------------------------------------------------------
      9  5e68
      0  5e68					      CHECK_BANK_SIZE	"PIECE_HANDLER_1"
      1  5e68		       02 68	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_1 (1K) SIZE =  $268 , FREE= $198
      2  5e68					      ECHO	"PIECE_HANDLER_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5e68				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5e68				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_1", " size=", * - ORIGIN
      5  5e68				  -	      ERR
      6  5e68					      ENDIF
     11  5e68
     12  5e68							;---------------------------------------------------------------------------------------------------
     13  5e68							; EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#2.asm LEVEL 2 PASS 4
      0  5e68					      include	"PIECE_HANDLER@1#2.asm"
      0  5e68					      SLOT	1
      1  5e68				  -	      IF	(1 < 0) || (1 > 3)
      2  5e68				  -	      ECHO	"Illegal bank address/segment location", 1
      3  5e68				  -	      ERR
      4  5e68					      ENDIF
      5  5e68				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  5e68				   _BANK_SLOT SET	1 * 64
      0  5e68					      NEWBANK	PIECE_HANDLER_2
      1  625c ????				      SEG	PIECE_HANDLER_2
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   PIECE_HANDLER_2_START SET	*
      6  6000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6000				   PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + 1024
      3  6000
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  6000					      include	"PIECE_ROOK.asm"
      1  6000							; Copyright (C)2020 Andrew Davie
      2  6000							; Rook move handler
      3  6000
      4  6000							;---------------------------------------------------------------------------------------------------
      5  6000							; ROOK
      6  6000							;---------------------------------------------------------------------------------------------------
      7  6000
      0  6000					      DEF	Handle_ROOK
      1  6000				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  6000				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  6000				   Handle_ROOK
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	Handle_ROOK
      9  6000					      SUBROUTINE
     10  6000
      0  6000					      REFER	GenerateAllMoves	;✅
      1  6000					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6000				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6000					      ENDIF
      0  6000					      VEND	Handle_ROOK
      1  6000				  -	      IFNCONST	Handle_ROOK
      2  6000				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  6000				  -	      ERR
      4  6000					      ENDIF
      5  6000		       00 b8	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  6000
     14  6000							; Pass...
     15  6000							; x = currentSquare (square the piece is on)
     16  6000							; currentPiece (with flags/colour attached)
     17  6000
      0  6000					      MOVE_TOWARDS	_DOWN
      1  6000					      SUBROUTINE
      2  6000
      3  6000
      4  6000
      5  6000		       a9 00		      lda	#0
      6  6002		       85 9c		      sta	capture
      7  6004
      8  6004		       a6 92		      ldx	currentSquare
      9  6006		       d0 03		      bne	.project
     10  6008
     11  6008		       20 6a f2    .empty     jsr	AddMove
     12  600b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  600e		       30 0e		      bmi	.invalid
     14  6010		       b9 79 fc 	      lda	Board,y
     15  6013		       f0 f3		      beq	.empty
     16  6015		       85 9c		      sta	capture
     17  6017		       45 91		      eor	currentPiece
     18  6019		       10 03		      bpl	.invalid
     19  601b		       20 6a f2 	      jsr	AddMove
     20  601e
     21  601e				   .invalid
      0  601e					      MOVE_TOWARDS	_RIGHT
      1  601e					      SUBROUTINE
      2  601e
      3  601e
      4  601e
      5  601e		       a9 00		      lda	#0
      6  6020		       85 9c		      sta	capture
      7  6022
      8  6022		       a6 92		      ldx	currentSquare
      9  6024		       d0 03		      bne	.project
     10  6026
     11  6026		       20 6a f2    .empty     jsr	AddMove
     12  6029		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  602c		       30 0e		      bmi	.invalid
     14  602e		       b9 79 fc 	      lda	Board,y
     15  6031		       f0 f3		      beq	.empty
     16  6033		       85 9c		      sta	capture
     17  6035		       45 91		      eor	currentPiece
     18  6037		       10 03		      bpl	.invalid
     19  6039		       20 6a f2 	      jsr	AddMove
     20  603c
     21  603c				   .invalid
      0  603c					      MOVE_TOWARDS	_UP
      1  603c					      SUBROUTINE
      2  603c
      3  603c
      4  603c
      5  603c		       a9 00		      lda	#0
      6  603e		       85 9c		      sta	capture
      7  6040
      8  6040		       a6 92		      ldx	currentSquare
      9  6042		       d0 03		      bne	.project
     10  6044
     11  6044		       20 6a f2    .empty     jsr	AddMove
     12  6047		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  604a		       30 0e		      bmi	.invalid
     14  604c		       b9 79 fc 	      lda	Board,y
     15  604f		       f0 f3		      beq	.empty
     16  6051		       85 9c		      sta	capture
     17  6053		       45 91		      eor	currentPiece
     18  6055		       10 03		      bpl	.invalid
     19  6057		       20 6a f2 	      jsr	AddMove
     20  605a
     21  605a				   .invalid
      0  605a					      MOVE_TOWARDS	_LEFT
      1  605a					      SUBROUTINE
      2  605a
      3  605a
      4  605a
      5  605a		       a9 00		      lda	#0
      6  605c		       85 9c		      sta	capture
      7  605e
      8  605e		       a6 92		      ldx	currentSquare
      9  6060		       d0 03		      bne	.project
     10  6062
     11  6062		       20 6a f2    .empty     jsr	AddMove
     12  6065		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  6068		       30 0e		      bmi	.invalid
     14  606a		       b9 79 fc 	      lda	Board,y
     15  606d		       f0 f3		      beq	.empty
     16  606f		       85 9c		      sta	capture
     17  6071		       45 91		      eor	currentPiece
     18  6073		       10 03		      bpl	.invalid
     19  6075		       20 6a f2 	      jsr	AddMove
     20  6078
     21  6078				   .invalid
     22  6078
     23  6078		       4c cd f1 	      jmp	MoveReturn
     24  607b
     25  607b							;---------------------------------------------------------------------------------------------------
     26  607b							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  607b					      include	"PIECE_QUEEN.asm"
      1  607b							; Copyright (C)2020 Andrew Davie
      2  607b
      3  607b							;---------------------------------------------------------------------------------------------------
      4  607b							; QUEEN
      5  607b							;---------------------------------------------------------------------------------------------------
      6  607b
      0  607b					      DEF	Handle_QUEEN
      1  607b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  607b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  607b				   Handle_QUEEN
      4  607b				   TEMPORARY_VAR SET	Overlay
      5  607b				   TEMPORARY_OFFSET SET	0
      6  607b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  607b				   FUNCTION_NAME SET	Handle_QUEEN
      8  607b					      SUBROUTINE
      9  607b
      0  607b					      REFER	GenerateAllMoves	;✅
      1  607b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  607b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  607b					      ENDIF
      0  607b					      VEND	Handle_QUEEN
      1  607b				  -	      IFNCONST	Handle_QUEEN
      2  607b				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  607b				  -	      ERR
      4  607b					      ENDIF
      5  607b		       00 b8	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  607b
     13  607b							; Pass...
     14  607b							; x = currentSquare (square the piece is on)
     15  607b							; currentPiece (with flags/colour attached)
     16  607b
      0  607b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  607b					      SUBROUTINE
      2  607b
      3  607b
      4  607b
      5  607b		       a9 00		      lda	#0
      6  607d		       85 9c		      sta	capture
      7  607f
      8  607f		       a6 92		      ldx	currentSquare
      9  6081		       d0 03		      bne	.project
     10  6083
     11  6083		       20 6a f2    .empty     jsr	AddMove
     12  6086		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6089		       30 0e		      bmi	.invalid
     14  608b		       b9 79 fc 	      lda	Board,y
     15  608e		       f0 f3		      beq	.empty
     16  6090		       85 9c		      sta	capture
     17  6092		       45 91		      eor	currentPiece
     18  6094		       10 03		      bpl	.invalid
     19  6096		       20 6a f2 	      jsr	AddMove
     20  6099
     21  6099				   .invalid
      0  6099					      MOVE_TOWARDS	_DOWN
      1  6099					      SUBROUTINE
      2  6099
      3  6099
      4  6099
      5  6099		       a9 00		      lda	#0
      6  609b		       85 9c		      sta	capture
      7  609d
      8  609d		       a6 92		      ldx	currentSquare
      9  609f		       d0 03		      bne	.project
     10  60a1
     11  60a1		       20 6a f2    .empty     jsr	AddMove
     12  60a4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  60a7		       30 0e		      bmi	.invalid
     14  60a9		       b9 79 fc 	      lda	Board,y
     15  60ac		       f0 f3		      beq	.empty
     16  60ae		       85 9c		      sta	capture
     17  60b0		       45 91		      eor	currentPiece
     18  60b2		       10 03		      bpl	.invalid
     19  60b4		       20 6a f2 	      jsr	AddMove
     20  60b7
     21  60b7				   .invalid
      0  60b7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  60b7					      SUBROUTINE
      2  60b7
      3  60b7
      4  60b7
      5  60b7		       a9 00		      lda	#0
      6  60b9		       85 9c		      sta	capture
      7  60bb
      8  60bb		       a6 92		      ldx	currentSquare
      9  60bd		       d0 03		      bne	.project
     10  60bf
     11  60bf		       20 6a f2    .empty     jsr	AddMove
     12  60c2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  60c5		       30 0e		      bmi	.invalid
     14  60c7		       b9 79 fc 	      lda	Board,y
     15  60ca		       f0 f3		      beq	.empty
     16  60cc		       85 9c		      sta	capture
     17  60ce		       45 91		      eor	currentPiece
     18  60d0		       10 03		      bpl	.invalid
     19  60d2		       20 6a f2 	      jsr	AddMove
     20  60d5
     21  60d5				   .invalid
      0  60d5					      MOVE_TOWARDS	_RIGHT
      1  60d5					      SUBROUTINE
      2  60d5
      3  60d5
      4  60d5
      5  60d5		       a9 00		      lda	#0
      6  60d7		       85 9c		      sta	capture
      7  60d9
      8  60d9		       a6 92		      ldx	currentSquare
      9  60db		       d0 03		      bne	.project
     10  60dd
     11  60dd		       20 6a f2    .empty     jsr	AddMove
     12  60e0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  60e3		       30 0e		      bmi	.invalid
     14  60e5		       b9 79 fc 	      lda	Board,y
     15  60e8		       f0 f3		      beq	.empty
     16  60ea		       85 9c		      sta	capture
     17  60ec		       45 91		      eor	currentPiece
     18  60ee		       10 03		      bpl	.invalid
     19  60f0		       20 6a f2 	      jsr	AddMove
     20  60f3
     21  60f3				   .invalid
      0  60f3					      MOVE_TOWARDS	_UP+_RIGHT
      1  60f3					      SUBROUTINE
      2  60f3
      3  60f3
      4  60f3
      5  60f3		       a9 00		      lda	#0
      6  60f5		       85 9c		      sta	capture
      7  60f7
      8  60f7		       a6 92		      ldx	currentSquare
      9  60f9		       d0 03		      bne	.project
     10  60fb
     11  60fb		       20 6a f2    .empty     jsr	AddMove
     12  60fe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6101		       30 0e		      bmi	.invalid
     14  6103		       b9 79 fc 	      lda	Board,y
     15  6106		       f0 f3		      beq	.empty
     16  6108		       85 9c		      sta	capture
     17  610a		       45 91		      eor	currentPiece
     18  610c		       10 03		      bpl	.invalid
     19  610e		       20 6a f2 	      jsr	AddMove
     20  6111
     21  6111				   .invalid
      0  6111					      MOVE_TOWARDS	_UP
      1  6111					      SUBROUTINE
      2  6111
      3  6111
      4  6111
      5  6111		       a9 00		      lda	#0
      6  6113		       85 9c		      sta	capture
      7  6115
      8  6115		       a6 92		      ldx	currentSquare
      9  6117		       d0 03		      bne	.project
     10  6119
     11  6119		       20 6a f2    .empty     jsr	AddMove
     12  611c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  611f		       30 0e		      bmi	.invalid
     14  6121		       b9 79 fc 	      lda	Board,y
     15  6124		       f0 f3		      beq	.empty
     16  6126		       85 9c		      sta	capture
     17  6128		       45 91		      eor	currentPiece
     18  612a		       10 03		      bpl	.invalid
     19  612c		       20 6a f2 	      jsr	AddMove
     20  612f
     21  612f				   .invalid
      0  612f					      MOVE_TOWARDS	_UP+_LEFT
      1  612f					      SUBROUTINE
      2  612f
      3  612f
      4  612f
      5  612f		       a9 00		      lda	#0
      6  6131		       85 9c		      sta	capture
      7  6133
      8  6133		       a6 92		      ldx	currentSquare
      9  6135		       d0 03		      bne	.project
     10  6137
     11  6137		       20 6a f2    .empty     jsr	AddMove
     12  613a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  613d		       30 0e		      bmi	.invalid
     14  613f		       b9 79 fc 	      lda	Board,y
     15  6142		       f0 f3		      beq	.empty
     16  6144		       85 9c		      sta	capture
     17  6146		       45 91		      eor	currentPiece
     18  6148		       10 03		      bpl	.invalid
     19  614a		       20 6a f2 	      jsr	AddMove
     20  614d
     21  614d				   .invalid
      0  614d					      MOVE_TOWARDS	_LEFT
      1  614d					      SUBROUTINE
      2  614d
      3  614d
      4  614d
      5  614d		       a9 00		      lda	#0
      6  614f		       85 9c		      sta	capture
      7  6151
      8  6151		       a6 92		      ldx	currentSquare
      9  6153		       d0 03		      bne	.project
     10  6155
     11  6155		       20 6a f2    .empty     jsr	AddMove
     12  6158		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  615b		       30 0e		      bmi	.invalid
     14  615d		       b9 79 fc 	      lda	Board,y
     15  6160		       f0 f3		      beq	.empty
     16  6162		       85 9c		      sta	capture
     17  6164		       45 91		      eor	currentPiece
     18  6166		       10 03		      bpl	.invalid
     19  6168		       20 6a f2 	      jsr	AddMove
     20  616b
     21  616b				   .invalid
     25  616b
     26  616b		       4c cd f1 	      jmp	MoveReturn
     27  616e
     28  616e							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  616e					      include	"PIECE_KING.asm"
      1  616e							; Copyright (C)2020 Andrew Davie
      2  616e
      3  616e							;---------------------------------------------------------------------------------------------------
      4  616e							; KING
      5  616e							; This is the move handler for a KING
      6  616e							; "Check" is detected in the next ply of the search.
      7  616e
      8  616e
      9  616e							;---------------------------------------------------------------------------------------------------
     10  616e
     11  616e							; MACRO - Castling
     12  616e
     13  616e		       00 03	   KINGSIDE   =	3
     14  616e		       ff ff ff fc QUEENSIDE  =	-4
     15  616e
     16  616e					      MAC	castle
     17  616e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  616e
     19  616e					      ldx	currentSquare
     20  616e					      lda	Board+{1},x	; kingside/queenside R position
     21  616e					      and	#PIECE_MASK|FLAG_MOVED
     22  616e					      cmp	#ROOK
     23  616e					      bne	.noCastle	; not a R that hasn't moved
     24  616e
     25  616e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  616e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  616e
     28  616e					      IF	{1} = QUEENSIDE
     29  616e					      lda	Board-3,x	; N pos
     30  616e					      ora	Board-2,x	; B pos
     31  616e					      ora	Board-1,x	; Q pos
     32  616e					      bne	.noCastle	; not vacant?
     33  616e
     34  616e					      ENDIF
     35  616e
     36  616e					      IF	{1} = KINGSIDE
     37  616e					      lda	Board+2,x	; N pos
     38  616e					      ora	Board+1,x	; B pos
     39  616e					      bne	.noCastle	; not vacant?
     40  616e					      ENDIF
     41  616e
     42  616e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  616e
     44  616e							; FINALLY -- king can castle
     45  616e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  616e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  616e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  616e
     49  616e					      lda	currentPiece
     50  616e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  616e					      sta	currentPiece
     52  616e
     53  616e					      IF	{1} = KINGSIDE
     54  616e					      ldy	ValidSquare+2,x
     55  616e					      ENDIF
     56  616e
     57  616e					      IF	{1} = QUEENSIDE
     58  616e					      ldy	ValidSquare-2,x
     59  616e					      ENDIF
     60  616e
     61  616e					      jsr	AddMove	; 57
     62  616e
     63  616e				   .noCastle
     64  616e					      ENDM
     65  616e
     66  616e
     67  616e							;---------------------------------------------------------------------------------------------------
     68  616e
      0  616e					      DEF	Handle_KING
      1  616e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  616e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  616e				   Handle_KING
      4  616e				   TEMPORARY_VAR SET	Overlay
      5  616e				   TEMPORARY_OFFSET SET	0
      6  616e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  616e				   FUNCTION_NAME SET	Handle_KING
     70  616e					      SUBROUTINE
     71  616e
      0  616e					      REFER	GenerateAllMoves	;✅
      1  616e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  616e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  616e					      ENDIF
      0  616e					      VEND	Handle_KING
      1  616e				  -	      IFNCONST	Handle_KING
      2  616e				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  616e				  -	      ERR
      4  616e					      ENDIF
      5  616e		       00 b8	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  616e
     75  616e							; x = currentSquare (square the KING is on)
     76  616e							; currentPiece (KING of course, but with flags/colour attached)
     77  616e
      0  616e					      MOVE_TO	_DOWN+_LEFT
      1  616e					      SUBROUTINE
      2  616e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  6171		       30 0e		      bmi	.invalid
      4  6173		       b9 79 fc 	      lda	Board,y
      5  6176		       85 9c		      sta	capture
      6  6178		       f0 04		      beq	.squareEmpty
      7  617a		       45 91		      eor	currentPiece
      8  617c		       10 03		      bpl	.invalid
      9  617e		       20 6a f2    .squareEmpty jsr	AddMove
     10  6181				   .invalid
      0  6181					      MOVE_TO_X	_DOWN
      1  6181		       a6 92		      ldx	currentSquare
      0  6183					      MOVE_TO	_DOWN
      1  6183					      SUBROUTINE
      2  6183		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      3  6186		       30 0e		      bmi	.invalid
      4  6188		       b9 79 fc 	      lda	Board,y
      5  618b		       85 9c		      sta	capture
      6  618d		       f0 04		      beq	.squareEmpty
      7  618f		       45 91		      eor	currentPiece
      8  6191		       10 03		      bpl	.invalid
      9  6193		       20 6a f2    .squareEmpty jsr	AddMove
     10  6196				   .invalid
      0  6196					      MOVE_TO_X	_DOWN+_RIGHT
      1  6196		       a6 92		      ldx	currentSquare
      0  6198					      MOVE_TO	_DOWN+_RIGHT
      1  6198					      SUBROUTINE
      2  6198		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  619b		       30 0e		      bmi	.invalid
      4  619d		       b9 79 fc 	      lda	Board,y
      5  61a0		       85 9c		      sta	capture
      6  61a2		       f0 04		      beq	.squareEmpty
      7  61a4		       45 91		      eor	currentPiece
      8  61a6		       10 03		      bpl	.invalid
      9  61a8		       20 6a f2    .squareEmpty jsr	AddMove
     10  61ab				   .invalid
      0  61ab					      MOVE_TO_X	_RIGHT
      1  61ab		       a6 92		      ldx	currentSquare
      0  61ad					      MOVE_TO	_RIGHT
      1  61ad					      SUBROUTINE
      2  61ad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      3  61b0		       30 0e		      bmi	.invalid
      4  61b2		       b9 79 fc 	      lda	Board,y
      5  61b5		       85 9c		      sta	capture
      6  61b7		       f0 04		      beq	.squareEmpty
      7  61b9		       45 91		      eor	currentPiece
      8  61bb		       10 03		      bpl	.invalid
      9  61bd		       20 6a f2    .squareEmpty jsr	AddMove
     10  61c0				   .invalid
      0  61c0					      MOVE_TO_X	_UP+_RIGHT
      1  61c0		       a6 92		      ldx	currentSquare
      0  61c2					      MOVE_TO	_UP+_RIGHT
      1  61c2					      SUBROUTINE
      2  61c2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  61c5		       30 0e		      bmi	.invalid
      4  61c7		       b9 79 fc 	      lda	Board,y
      5  61ca		       85 9c		      sta	capture
      6  61cc		       f0 04		      beq	.squareEmpty
      7  61ce		       45 91		      eor	currentPiece
      8  61d0		       10 03		      bpl	.invalid
      9  61d2		       20 6a f2    .squareEmpty jsr	AddMove
     10  61d5				   .invalid
      0  61d5					      MOVE_TO_X	_UP
      1  61d5		       a6 92		      ldx	currentSquare
      0  61d7					      MOVE_TO	_UP
      1  61d7					      SUBROUTINE
      2  61d7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      3  61da		       30 0e		      bmi	.invalid
      4  61dc		       b9 79 fc 	      lda	Board,y
      5  61df		       85 9c		      sta	capture
      6  61e1		       f0 04		      beq	.squareEmpty
      7  61e3		       45 91		      eor	currentPiece
      8  61e5		       10 03		      bpl	.invalid
      9  61e7		       20 6a f2    .squareEmpty jsr	AddMove
     10  61ea				   .invalid
      0  61ea					      MOVE_TO_X	_UP+_LEFT
      1  61ea		       a6 92		      ldx	currentSquare
      0  61ec					      MOVE_TO	_UP+_LEFT
      1  61ec					      SUBROUTINE
      2  61ec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      3  61ef		       30 0e		      bmi	.invalid
      4  61f1		       b9 79 fc 	      lda	Board,y
      5  61f4		       85 9c		      sta	capture
      6  61f6		       f0 04		      beq	.squareEmpty
      7  61f8		       45 91		      eor	currentPiece
      8  61fa		       10 03		      bpl	.invalid
      9  61fc		       20 6a f2    .squareEmpty jsr	AddMove
     10  61ff				   .invalid
      0  61ff					      MOVE_TO_X	_LEFT
      1  61ff		       a6 92		      ldx	currentSquare
      0  6201					      MOVE_TO	_LEFT
      1  6201					      SUBROUTINE
      2  6201		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      3  6204		       30 0e		      bmi	.invalid
      4  6206		       b9 79 fc 	      lda	Board,y
      5  6209		       85 9c		      sta	capture
      6  620b		       f0 04		      beq	.squareEmpty
      7  620d		       45 91		      eor	currentPiece
      8  620f		       10 03		      bpl	.invalid
      9  6211		       20 6a f2    .squareEmpty jsr	AddMove
     10  6214				   .invalid
     86  6214
     87  6214							;IF CASTLING_ENABLED
     88  6214
     89  6214		       24 91		      bit	currentPiece
     90  6216		       70 41		      bvs	.exit	; king has moved, so no castling
     91  6218
      0  6218					      CASTLE	KINGSIDE
      1  6218
      2  6218
      3  6218		       a6 92		      ldx	currentSquare
      4  621a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  621d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  621f		       c9 05		      cmp	#ROOK
      7  6221		       d0 14		      bne	.noCastle
      8  6223
      9  6223
     10  6223
     11  6223
     12  6223				  -	      IF	KINGSIDE = QUEENSIDE
     13  6223				  -	      lda	Board-3,x
     14  6223				  -	      ora	Board-2,x
     15  6223				  -	      ora	Board-1,x
     16  6223				  -	      bne	.noCastle
     17  6223				  -
     18  6223					      ENDIF
     19  6223
     20  6223					      IF	KINGSIDE = KINGSIDE
     21  6223		       bd 7b fc 	      lda	Board+2,x
     22  6226		       1d 7a fc 	      ora	Board+1,x
     23  6229		       d0 0c		      bne	.noCastle
     24  622b					      ENDIF
     25  622b
     26  622b
     27  622b
     28  622b
     29  622b
     30  622b
     31  622b
     32  622b
     33  622b		       a5 91		      lda	currentPiece
     34  622d		       09 10		      ora	#FLAG_CASTLE
     35  622f		       85 91		      sta	currentPiece
     36  6231
     37  6231					      IF	KINGSIDE = KINGSIDE
     38  6231		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  6234					      ENDIF
     40  6234
     41  6234				  -	      IF	KINGSIDE = QUEENSIDE
     42  6234				  -	      ldy	ValidSquare-2,x
     43  6234					      ENDIF
     44  6234
     45  6234		       20 6a f2 	      jsr	AddMove
     46  6237
     47  6237				   .noCastle
      0  6237					      CASTLE	QUEENSIDE
      1  6237
      2  6237
      3  6237		       a6 92		      ldx	currentSquare
      4  6239		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  623c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  623e		       c9 05		      cmp	#ROOK
      7  6240		       d0 17		      bne	.noCastle
      8  6242
      9  6242
     10  6242
     11  6242
     12  6242					      IF	QUEENSIDE = QUEENSIDE
     13  6242		       bd 76 fc 	      lda	Board-3,x
     14  6245		       1d 77 fc 	      ora	Board-2,x
     15  6248		       1d 78 fc 	      ora	Board-1,x
     16  624b		       d0 0c		      bne	.noCastle
     17  624d
     18  624d					      ENDIF
     19  624d
     20  624d				  -	      IF	QUEENSIDE = KINGSIDE
     21  624d				  -	      lda	Board+2,x
     22  624d				  -	      ora	Board+1,x
     23  624d				  -	      bne	.noCastle
     24  624d					      ENDIF
     25  624d
     26  624d
     27  624d
     28  624d
     29  624d
     30  624d
     31  624d
     32  624d
     33  624d		       a5 91		      lda	currentPiece
     34  624f		       09 10		      ora	#FLAG_CASTLE
     35  6251		       85 91		      sta	currentPiece
     36  6253
     37  6253				  -	      IF	QUEENSIDE = KINGSIDE
     38  6253				  -	      ldy	ValidSquare+2,x
     39  6253					      ENDIF
     40  6253
     41  6253					      IF	QUEENSIDE = QUEENSIDE
     42  6253		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  6256					      ENDIF
     44  6256
     45  6256		       20 6a f2 	      jsr	AddMove
     46  6259
     47  6259				   .noCastle
     94  6259
     95  6259							;ENDIF
     96  6259
     97  6259		       4c cd f1    .exit      jmp	MoveReturn
     98  625c
     99  625c							;---------------------------------------------------------------------------------------------------
    100  625c							; EOF
------- FILE PIECE_HANDLER@1#2.asm
      7  625c
      8  625c							;---------------------------------------------------------------------------------------------------
      9  625c
      0  625c					      CHECK_BANK_SIZE	"PIECE_HANDLER_2"
      1  625c		       02 5c	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_2 (1K) SIZE =  $25c , FREE= $1a4
      2  625c					      ECHO	"PIECE_HANDLER_2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  625c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  625c				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_2", " size=", * - ORIGIN
      5  625c				  -	      ERR
      6  625c					      ENDIF
     11  625c
     12  625c							;---------------------------------------------------------------------------------------------------
     13  625c							; EOF
------- FILE ./chess.asm
------- FILE BANK_3.asm LEVEL 2 PASS 4
      0  625c					      include	"BANK_3.asm"
      1  625c							; Chess
      2  625c							; Copyright (c) 2019-2020 Andrew Davie
      3  625c							; andrew@taswegian.com
      4  625c
      0  625c					      SLOT	3	; this code assembles for bank #1
      1  625c				  -	      IF	(3 < 0) || (3 > 3)
      2  625c				  -	      ECHO	"Illegal bank address/segment location", 3
      3  625c				  -	      ERR
      4  625c					      ENDIF
      5  625c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  625c				   _BANK_SLOT SET	3 * 64
      0  625c					      NEWBANK	THREE
      1  6464 ????				      SEG	THREE
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   THREE_START SET	*
      6  6400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6400				   THREE      SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + 1024
      7  6400
      8  6400							;---------------------------------------------------------------------------------------------------
      9  6400
      0  6400					      DEF	GetPiece
      1  6400				   SLOT_GetPiece SET	_BANK_SLOT
      2  6400				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  6400				   GetPiece
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	GetPiece
     11  6400					      SUBROUTINE
     12  6400
      0  6400					      REFER	aiSelectDestinationSquare	;✅
      1  6400					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  6400				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  6400					      ENDIF
      0  6400					      REFER	aiQuiescent	;✅
      1  6400				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  6400				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  6400					      ENDIF
      0  6400					      VEND	GetPiece
      1  6400				  -	      IFNCONST	GetPiece
      2  6400				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  6400				  -	      ERR
      4  6400					      ENDIF
      5  6400		       00 a9	   VAREND_GetPiece =	TEMPORARY_VAR
     16  6400
     17  6400							; Retrieve the piece+flags from the movelist, given from/to squares
     18  6400							; Required as moves have different flags but same origin squares (e.g., castling)
     19  6400
     20  6400		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
     21  6402							;lda currentPly
     22  6402		       85 3e		      sta	SET_BANK_RAM	;@2
     23  6404
     24  6404							; returns piece in A+fromPiece
     25  6404							; or Y=-1 if not found
     26  6404
     27  6404							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     28  6404							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     29  6404							; This fixes the move with/without castle flag
     30  6404
     31  6404
      0  6404					      ldy@PLY	moveIndex
      1  6404		       ac cf f9 	      ldy	moveIndex
     33  6407		       30 11		      bmi	.fail	; shouldn't happen
     34  6409
     35  6409		       a5 85	   .scan      lda	fromX12
      0  640b					      cmp@PLY	MoveFrom,y
      1  640b		       d9 00 f8 	      cmp	MoveFrom,y
     37  640e		       d0 07		      bne	.next
     38  6410		       a5 86		      lda	toX12
      0  6412					      cmp@PLY	MoveTo,y
      1  6412		       d9 64 f8 	      cmp	MoveTo,y
     40  6415		       f0 04		      beq	.found
     41  6417		       88	   .next      dey
     42  6418		       10 ef		      bpl	.scan
     43  641a		       60	   .fail      rts
     44  641b
      0  641b				   .found     lda@PLY	MovePiece,y
      1  641b		       b9 00 f9 	      lda	MovePiece,y
     46  641e		       85 96		      sta	fromPiece
     47  6420
     48  6420		       60		      rts
     49  6421
     50  6421
     51  6421							;---------------------------------------------------------------------------------------------------
     52  6421
     53  6421							;     DEF GenCastleMoveForRook_ENPASSANT
     54  6421							;     SUBROUTINE
     55  6421
     56  6421							;	   REFER MakeMove ;✅
     57  6421							;	   REFER CastleFixupDraw_ENPASSANT ;✅
     58  6421							;	   VEND GenCastleMoveForRook_ENPASSANT
     59  6421
     60  6421							;	   rts ;tmp
     61  6421							;	   jsr debug ;tmp
     62  6421
     63  6421							;     ; Like castling, this generates the acutal extra-move for the en-passant
     64  6421
     65  6421
     66  6421							;     ; Check to see if we are doing an actual en-passant capture...
     67  6421
     68  6421							;     ; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
     69  6421							;     ;  as the en-passant will fail if the taking piece does not have this flag set correctly
     70  6421
     71  6421
     72  6421
     73  6421							;     ; {
     74  6421							;     ; With en-passant flag, it is essentially dual-use.
     75  6421							;     ; First, it marks if the move is *involved* somehow in an en-passant
     76  6421							;     ; if the piece has MOVED already, then it's an en-passant capture
     77  6421							;     ; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
     78  6421
     79  6421							;		       ldy enPassantPawn	       ; save from previous side move
     80  6421
     81  6421							;		       ldx #0			       ; (probably) NO en-passant this time
     82  6421							;		       lda fromPiece
     83  6421							;		       and #FLAG_ENPASSANT|FLAG_MOVED
     84  6421							;		       cmp #FLAG_ENPASSANT
     85  6421							;		       bne .noep		       ; HAS moved, or not en-passant
     86  6421
     87  6421							;		       eor fromPiece		       ; clear FLAG_ENPASSANT
     88  6421							;		       sta fromPiece
     89  6421
     90  6421							;		       ldx toX12		       ; this IS an en-passantable opening, so record the square
     91  6421							; .noep	       stx enPassantPawn	       ; capturable square for en-passant move (or none)
     92  6421
     93  6421							;     ; }
     94  6421
     95  6421							;		       clc
     96  6421
     97  6421							;		       lda fromPiece
     98  6421							;		       and #FLAG_ENPASSANT
     99  6421							;		       beq .notEnPassant	       ; not an en-passant, or it's enpassant by a MOVED piece
    100  6421
    101  6421
    102  6421							;     ; at this point the attacking pawn has finished moving to the "take" square
    103  6421							;     ; the loser-pawn is marked with enPassantPawn
    104  6421							;     ; we want to generate a 'blank' move to take the pawn
    105  6421
    106  6421							;		       lda originX12		       ; we need a blank square to move FROM
    107  6421							;		       sta fromX12		       ; use the square the attacker pawn just left
    108  6421
    109  6421							;     ; calculate the captured pawn's square based on move colour
    110  6421
    111  6421							;		       lda #-10
    112  6421							;		       ldx fromPiece
    113  6421							;		       bpl .white
    114  6421							;		       lda #10
    115  6421							; .white
    116  6421							;		       clc
    117  6421							;		       adc fromX12		       ; attacker destination square
    118  6421							;		       sta toX12		       ; now we have the captured pawn square!
    119  6421							;		       sta@PLY secondarySquare	       ; square to which we RESTORE the captured pawn on unmakemove
    120  6421
    121  6421							;		       sta@PLY secondaryBlank
    122  6421							;		       lda fromPiece
    123  6421							;		       eor #$80 		       ; opponent pawn
    124  6421							;		       sta@PLY secondaryPiece	       ; a capture!
    125  6421
    126  6421
    127  6421							;		       sec			       ; double-move, so don't change sides
    128  6421							; .notEnPassant       rts
    129  6421
    130  6421
    131  6421							;---------------------------------------------------------------------------------------------------
    132  6421
      0  6421					      DEF	GenCastleMoveForRook
      1  6421				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  6421				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  6421				   GenCastleMoveForRook
      4  6421				   TEMPORARY_VAR SET	Overlay
      5  6421				   TEMPORARY_OFFSET SET	0
      6  6421				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  6421				   FUNCTION_NAME SET	GenCastleMoveForRook
    134  6421					      SUBROUTINE
    135  6421
      0  6421					      REFER	MakeMove	;✅
      1  6421					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  6421				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  6421					      ENDIF
      0  6421					      REFER	CastleFixupDraw	;✅
      1  6421				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  6421				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  6421					      ENDIF
      0  6421					      VEND	GenCastleMoveForRook
      1  6421				  -	      IFNCONST	GenCastleMoveForRook
      2  6421				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  6421				  -	      ERR
      4  6421					      ENDIF
      5  6421		       00 b5	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    139  6421
    140  6421							; Generate secondary move for the rook, involved in a castling move
    141  6421							; Returns:
    142  6421							;   CC --> not a castle/secondary
    143  6421							;   CS --> secondary move valid
    144  6421
    145  6421
    146  6421		       18		      clc
    147  6422
    148  6422		       a5 96		      lda	fromPiece
    149  6424		       29 10		      and	#FLAG_CASTLE
    150  6426		       f0 2b		      beq	.exit	; NOT involved in castle!
    151  6428
    152  6428		       a2 04		      ldx	#4
    153  642a		       a5 85		      lda	fromX12	; *destination*
    154  642c		       18	   .findCast  clc
    155  642d		       ca		      dex
    156  642e		       30 23		      bmi	.exit
    157  6430		       dd 54 fc 	      cmp	KSquare,x
    158  6433		       d0 f7		      bne	.findCast
    159  6435
    160  6435		       bd 5c fc 	      lda	RSquareEnd,x
    161  6438		       85 86		      sta	toX12
      0  643a					      sta@PLY	secondaryBlank
      1  643a		       8d ce fb 	      sta	[RAM]+secondaryBlank
    163  643d		       bc 58 fc 	      ldy	RSquareStart,x
    164  6440		       84 85		      sty	fromX12
    165  6442		       84 87		      sty	originX12
      0  6444					      sty@PLY	secondarySquare
      1  6444		       8c cd fb 	      sty	[RAM]+secondarySquare
    167  6447
    168  6447		       a5 96		      lda	fromPiece
    169  6449		       29 80		      and	#128	; colour bit
    170  644b		       09 05		      ora	#ROOK	; preserve colour
    171  644d		       85 96		      sta	fromPiece
      0  644f					      sta@PLY	secondaryPiece
      1  644f		       8d cc fb 	      sta	[RAM]+secondaryPiece
    173  6452
    174  6452		       38		      sec
    175  6453		       60	   .exit      rts
    176  6454
    177  6454
    178  6454		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    179  6458		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    180  645c		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    181  6460		       19 1b 5f 61 virtualSquare1 .byte.b	25,27,95,97
    182  6464							;virtualSquare2      .byte 26,26,96,96
    183  6464
    184  6464							;---------------------------------------------------------------------------------------------------
    185  6464
    186  6464							; DEF GenEnPassantMove
    187  6464							; SUBROUTINE
    188  6464
    189  6464							;     REFER EnPassantCheck
    190  6464							;     REFER MakeMove
    191  6464							;     VEND GenEnPassantMove
    192  6464
    193  6464
    194  6464							;		   rts
    195  6464
    196  6464
    197  6464
    198  6464							;---------------------------------------------------------------------------------------------------
    199  6464
      0  6464					      CHECK_BANK_SIZE	"BANK_3"
      1  6464		       00 64	   .TEMP      =	* - _BANK_START
 BANK_3 (1K) SIZE =  $64 , FREE= $39c
      2  6464					      ECHO	"BANK_3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6464				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6464				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_3", " size=", * - ORIGIN
      5  6464				  -	      ERR
      6  6464					      ENDIF
    201  6464
    202  6464							;---------------------------------------------------------------------------------------------------
    203  6464							; EOF
------- FILE ./chess.asm
    645  6464
------- FILE BANK_LAST.asm LEVEL 2 PASS 4
      0  6464					      include	"BANK_LAST.asm"
      1  6464							; Chess
      2  6464							; Copyright (c) 2019-2020 Andrew Davie
      3  6464							; andrew@taswegian.com
      4  6464
      0  6464					      SLOT	3
      1  6464				  -	      IF	(3 < 0) || (3 > 3)
      2  6464				  -	      ECHO	"Illegal bank address/segment location", 3
      3  6464				  -	      ERR
      4  6464					      ENDIF
      5  6464				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  6464				   _BANK_SLOT SET	3 * 64
      0  6464					      NEWBANK	LAST
      1  6c00 ????				      SEG	LAST
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   LAST_START SET	*
      6  6800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6800				   LAST       SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + 1024
      7  6800
      8  6800
      9  6800		       00 00 00 00*	      ds	1024
     10  6c00
     11  6c00							; EOF
------- FILE ./chess.asm
    647  6c00
    648  6c00							;---------------------------------------------------------------------------------------------------
    649  6c00							;EOF
