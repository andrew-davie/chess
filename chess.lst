------- FILE ./chess.asm LEVEL 1 PASS 5
      1  8000 ????						; Chess
      2  8000 ????						; Atari 2600 Chess display system
      3  8000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  8000 ????						; andrew@taswegian.com
      5  8000 ????
      6  8000 ????
      7  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  8000 ????
      9  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 5
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 5
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 5
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????	       00 08	   MARKER     =	8
     34  0000 ????
     35  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     36  0000 ????
     37  0000 ????						;---------------------------------------------------------------------------------------------------
     38  0000 ????
     39  0000 ????						; Movements
     40  0000 ????
     41  0000 ????	       00 0a	   _UP	      =	10	; up
     42  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     43  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     44  0000 ????	       00 01	   _RIGHT     =	1	; right
     45  0000 ????
     46  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 5
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						; Pathways
     94  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
     95  0000 ????						; if QuickDraw does immediate exit, 58✅
     96  0000 ????
     97  0000 ????						;---------------------------------------------------------------------------------------------------
     98  0000 ????
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIME, 95	;✅ processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	(95+32)/64 + 2
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    101  0000 ????
    102  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    103  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    104  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    105  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    106  0000 ????						; uses ...
    107  0000 ????
    108  0000 ????
    109  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    110  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    111  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    112  0000 ????
    113  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    114  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    115  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./chess.asm
     20  0000 ????
     21  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     22  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     23  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     24  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     25  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     26  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     27  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     28  0000 ????
     29  0000 ????	       00 01	   YES	      =	1
     30  0000 ????	       00 00	   NO	      =	0
     31  0000 ????
     32  0000 ????	       7f ff	   INFINITY   =	32767
     33  0000 ????
     34  0000 ????
     35  0000 ????						; assemble diagnostics. Remove for release.
     36  0000 ????
     37  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     38  0000 ????	       00 00	   DIAGNOSTICS =	0
     39  0000 ????	       00 01	   QUIESCENCE =	1
     40  0000 ????	       00 00	   ASSERTS    =	0
     41  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     42  0000 ????	       00 00	   ENPASSANT_ENABLED =	0
     43  0000 ????	       00 01	   CASTLING_ENABLED =	1
     44  0000 ????						;PIECELIST_ENABLED	  = 0
     45  0000 ????
     46  0000 ????	       00 00	   WHITE_PLAYER =	0	; human
     47  0000 ????	       00 00	   BLACK_PLAYER =	0	; human
     48  0000 ????
     49  0000 ????	       00 03	   SEARCH_DEPTH =	3
     50  0000 ????	       00 83	   SWAP_SIDE  =	128 + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     51  0000 ????
     52  0000 ????
     53  0000 ????
     54  0000 ????						; DELAYS
     55  0000 ????
     56  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     57  0000 ????
     58  0000 ????						;===================================
     59  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     60  0000 ????						;===================================
     61  0000 ????
     62  0000 ????						;-------------------------------------------------------------------------------
     63  0000 ????						; The following are optional YES/NO depending on phase of the moon
     64  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     65  0000 ????						;-------------------------------------------------------------------------------
     66  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     67  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     68  0000 ????			  -	      IF	FINAL_VERSION = YES
     69  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     70  0000 ????				      ENDIF
     71  0000 ????
     72  0000 ????						;-------------------------------------------------------------------------------
     73  0000 ????
     74  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     75  0000 ????
     76  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     77  0000 ????
     78  0000 ????						;------------------------------------------------------------------------------
     79  0000 ????
     80  0000 ????	       00 01	   PLUSCART   =	YES
     81  0000 ????
     82  0000 ????						;------------------------------------------------------------------------------
     83  0000 ????
     84  0000 ????
     85  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
     86  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
     87  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
     88  0000 ????
     89  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
     90  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
     91  0000 ????
     92  0000 ????
     93  0000 ????	       10 00	   RAM_3E     =	$1000
     94  0000 ????	       04 00	   RAM_SIZE   =	$400
     95  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
     96  0000 ????	       04 00	   RAM	      =	RAM_WRITE
     97  0000 ????
     98  0000 ????
     99  0000 ????
    100  0000 ????						; Platform constants:
    101  0000 ????	       00 02	   PAL	      =	%10
    102  0000 ????	       00 02	   PAL_50     =	PAL|0
    103  0000 ????	       00 03	   PAL_60     =	PAL|1
    104  0000 ????
    105  0000 ????
    106  0000 ????				      IF	L276
    107  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    108  0000 ????			  -	      ELSE
    109  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    110  0000 ????				      ENDIF
    111  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    112  0000 ????
    113  0000 ????				      IF	L276
    114  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    115  0000 ????			  -	      ELSE
    116  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    117  0000 ????				      ENDIF
    118  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    119  0000 ????
    120  0000 ????				      IF	L276
    121  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    122  0000 ????			  -	      ELSE
    123  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    124  0000 ????				      ENDIF
    125  0000 ????	       01 38	   SCANLINES_PAL =	312
    126  0000 ????
    127  0000 ????
    128  0000 ????	       00 2d	   TIME_PART_2 =	45
    129  0000 ????	       00 2f	   TIME_PART_1 =	47
    130  0000 ????
    131  0000 ????
    132  0000 ????						;------------------------------------------------------------------------------
    133  0000 ????						; MACRO definitions
    134  0000 ????
    135  0000 ????
    136  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    137  0000 ????
    138  0000 ????				      MAC	newbank
    139  0000 ????				      SEG	{1}
    140  0000 ????				      ORG	ORIGIN
    141  0000 ????				      RORG	$F000
    142  0000 ????			   BANK_START SET	*
    143  0000 ????			   {1}	      SET	ORIGIN / 2048
    144  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    145  0000 ????			   _CURRENT_BANK SET	{1}
    146  0000 ????				      ENDM		; bank name
    147  0000 ????
    148  0000 ????				      MAC	define_1k_segment
    149  0000 ????				      ALIGN	$400
    150  0000 ????			   SEGMENT_{1} SET	*
    151  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    152  0000 ????				      ENDM		; {seg name}
    153  0000 ????
    154  0000 ????				      MAC	check_bank_size
    155  0000 ????			   .TEMP      =	* - BANK_START
    156  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    157  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    158  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    159  0000 ????				      ERR
    160  0000 ????				      endif
    161  0000 ????				      ENDM		; name
    162  0000 ????
    163  0000 ????
    164  0000 ????				      MAC	check_half_bank_size
    165  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    166  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    167  0000 ????			   .TEMP      =	* - BANK_START
    168  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    169  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    170  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    171  0000 ????				      ERR
    172  0000 ????				      endif
    173  0000 ????				      ENDM		; name
    174  0000 ????
    175  0000 ????
    176  0000 ????						;---------------------------------------------------------------------------------------------------
    177  0000 ????
    178  0000 ????						; Macro inserts a page break if the object would overlap a page
    179  0000 ????
    180  0000 ????				      MAC	optional_pagebreak
    181  0000 ????				      LIST	OFF
    182  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    183  0000 ????			   EARLY_LOCATION SET	*
    184  0000 ????				      ALIGN	256
    185  0000 ????				      IF	VERBOSE=1
    186  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    187  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    188  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    189  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    190  0000 ????				      ENDIF
    191  0000 ????				      ENDIF
    192  0000 ????				      LIST	ON
    193  0000 ????				      ENDM		; { string, size }
    194  0000 ????
    195  0000 ????
    196  0000 ????				      MAC	check_page_crossing
    197  0000 ????				      LIST	OFF
    198  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    199  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    200  0000 ????				      endif
    201  0000 ????				      LIST	ON
    202  0000 ????				      ENDM
    203  0000 ????
    204  0000 ????				      MAC	checkpage
    205  0000 ????				      LIST	OFF
    206  0000 ????				      IF	>. != >{1}
    207  0000 ????				      ECHO	""
    208  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    209  0000 ????				      ECHO	""
    210  0000 ????				      ERR
    211  0000 ????				      ENDIF
    212  0000 ????				      LIST	ON
    213  0000 ????				      ENDM
    214  0000 ????
    215  0000 ????				      MAC	checkpagex
    216  0000 ????				      LIST	OFF
    217  0000 ????				      IF	>. != >{1}
    218  0000 ????				      ECHO	""
    219  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    220  0000 ????				      ECHO	{2}
    221  0000 ????				      ECHO	""
    222  0000 ????				      ERR
    223  0000 ????				      ENDIF
    224  0000 ????				      LIST	ON
    225  0000 ????				      ENDM
    226  0000 ????
    227  0000 ????						;---------------------------------------------------------------------------------------------------
    228  0000 ????
    229  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    230  0000 ????				      MAC	variable
    231  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    232  0000 ????			   {1}	      ds	{2}
    233  0000 ????				      ENDM		; {name, size}
    234  0000 ????
    235  0000 ????
    236  0000 ????						;---------------------------------------------------------------------------------------------------
    237  0000 ????
    238  0000 ????				      MAC	def
    239  0000 ????			   BANK_{1}   SET	_CURRENT_BANK	; bank in which this subroutine resides
    240  0000 ????			   {1}			; entry point
    241  0000 ????			   TEMPORARY_VAR SET	Overlay
    242  0000 ????			   TEMPORARY_OFFSET SET	0
    243  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    244  0000 ????			   FUNCTION_NAME SET	{1}
    245  0000 ????				      SUBROUTINE
    246  0000 ????				      ENDM		; name of subroutine
    247  0000 ????
    248  0000 ????
    249  0000 ????						;---------------------------------------------------------------------------------------------------
    250  0000 ????
    251  0000 ????				      MAC	allocate
    252  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    253  0000 ????				      DEF	{1}
    254  0000 ????				      ENDM
    255  0000 ????
    256  0000 ????
    257  0000 ????						;---------------------------------------------------------------------------------------------------
    258  0000 ????
    259  0000 ????				      MAC	negeval
    260  0000 ????
    261  0000 ????				      sec
    262  0000 ????				      lda	#0
    263  0000 ????				      sbc	Evaluation
    264  0000 ????				      sta	Evaluation
    265  0000 ????				      lda	#0
    266  0000 ????				      sbc	Evaluation+1
    267  0000 ????				      sta	Evaluation+1
    268  0000 ????				      ENDM
    269  0000 ????
    270  0000 ????
    271  0000 ????				      MAC	swap
    272  0000 ????				      lda	sideToMove
    273  0000 ????				      eor	#SWAP_SIDE
    274  0000 ????				      sta	sideToMove
    275  0000 ????				      ENDM
    276  0000 ????
    277  0000 ????
    278  0000 ????						;---------------------------------------------------------------------------------------------------
    279  0000 ????
    280  0000 ????			   TEMPORARY_OFFSET SET	0
    281  0000 ????
    282  0000 ????
    283  0000 ????				      MAC	vend
    284  0000 ????				      IFNCONST	{1}
    285  0000 ????				      ECHO	"Incorrect VEND label", {1}
    286  0000 ????				      ERR
    287  0000 ????				      ENDIF
    288  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    289  0000 ????				      ENDM		; {1}
    290  0000 ????
    291  0000 ????
    292  0000 ????				      MAC	refer
    293  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    294  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    295  0000 ????				      ENDIF
    296  0000 ????				      ENDM		; {1}
    297  0000 ????
    298  0000 ????
    299  0000 ????
    300  0000 ????						; Define a temporary variable for use in a subroutine
    301  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    302  0000 ????
    303  0000 ????				      MAC	var
    304  0000 ????			   {1}	      =	TEMPORARY_VAR
    305  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    306  0000 ????
    307  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    308  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    309  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    310  0000 ????				      ENDIF
    311  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    312  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    313  0000 ????				      ERR
    314  0000 ????				      ENDIF
    315  0000 ????				      LIST	ON
    316  0000 ????				      ENDM		; { name, size }
    317  0000 ????
    318  0000 ????
    319  0000 ????						;---------------------------------------------------------------------------------------------------
    320  0000 ????
    321  0000 ????				      MAC	tag
    322  0000 ????						; {0}
    323  0000 ????				      ENDM		; {ident/tag}
    324  0000 ????
    325  0000 ????						;---------------------------------------------------------------------------------------------------
    326  0000 ????
    327  0000 ????				      MAC	sta@ram
    328  0000 ????				      sta	[RAM]+{0}
    329  0000 ????				      ENDM		;{}
    330  0000 ????
    331  0000 ????				      MAC	stx@ram
    332  0000 ????				      stx	[RAM]+{0}
    333  0000 ????				      ENDM
    334  0000 ????
    335  0000 ????				      MAC	sty@ram
    336  0000 ????				      sty	[RAM]+{0}
    337  0000 ????				      ENDM
    338  0000 ????
    339  0000 ????				      MAC	sta@ply
    340  0000 ????				      sta	[RAM]+{0}
    341  0000 ????				      ENDM		;{}
    342  0000 ????
    343  0000 ????				      MAC	stx@ply
    344  0000 ????				      stx	[RAM]+{0}
    345  0000 ????				      ENDM
    346  0000 ????
    347  0000 ????				      MAC	sty@ply
    348  0000 ????				      sty	[RAM]+{0}
    349  0000 ????				      ENDM
    350  0000 ????
    351  0000 ????
    352  0000 ????				      MAC	lda@ram
    353  0000 ????				      lda	{0}
    354  0000 ????				      ENDM		;{}
    355  0000 ????
    356  0000 ????				      MAC	ldx@ram
    357  0000 ????				      ldx	{0}
    358  0000 ????				      ENDM		;{}
    359  0000 ????
    360  0000 ????				      MAC	ldy@ram
    361  0000 ????				      ldy	{0}
    362  0000 ????				      ENDM		;{}
    363  0000 ????
    364  0000 ????
    365  0000 ????				      MAC	lda@ply
    366  0000 ????				      lda	{0}
    367  0000 ????				      ENDM		;{}
    368  0000 ????
    369  0000 ????				      MAC	ldx@ply
    370  0000 ????				      ldx	{0}
    371  0000 ????				      ENDM		;{}
    372  0000 ????
    373  0000 ????				      MAC	ldy@ply
    374  0000 ????				      ldy	{0}
    375  0000 ????				      ENDM		;{}
    376  0000 ????
    377  0000 ????
    378  0000 ????				      MAC	adc@ply
    379  0000 ????				      adc	{0}
    380  0000 ????				      ENDM		;{}
    381  0000 ????
    382  0000 ????				      MAC	sbc@ply
    383  0000 ????				      sbc	{0}
    384  0000 ????				      ENDM		;{}
    385  0000 ????
    386  0000 ????
    387  0000 ????						;---------------------------------------------------------------------------------------------------
    388  0000 ????
    389  0000 ????				      MAC	newrambank
    390  0000 ????						; {1}	     bank name
    391  0000 ????						; {2}	     RAM bank number
    392  0000 ????
    393  0000 ????				      SEG.U	{1}
    394  0000 ????				      ORG	ORIGIN_RAM
    395  0000 ????				      RORG	RAM_3E
    396  0000 ????			   BANK_START SET	*
    397  0000 ????			   RAMBANK_{1} SET	ORIGIN_RAM / RAM_SIZE
    398  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    399  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    400  0000 ????				      ENDM		; bank name
    401  0000 ????
    402  0000 ????						; TODO - fix - this is faulty....
    403  0000 ????				      MAC	validate_ram_size
    404  0000 ????			   .RAM_BANK_SIZE SET	* - RAM_3E
    405  0000 ????				      IF	.RAM_BANK_SIZE > RAM_SIZE
    406  0000 ????				      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
    407  0000 ????				      ERR
    408  0000 ????				      ENDIF
    409  0000 ????				      ENDM
    410  0000 ????
    411  0000 ????						;---------------------------------------------------------------------------------------------------
    412  0000 ????
    413  0000 ????				      MAC	resync
    414  0000 ????						; resync screen, X and Y == 0 afterwards
    415  0000 ????				      lda	#%10	; make sure VBLANK is ON
    416  0000 ????				      sta	VBLANK
    417  0000 ????
    418  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    419  0000 ????			   .loopResync
    420  0000 ????				      VERTICAL_SYNC
    421  0000 ????
    422  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    423  0000 ????				      lda	Platform
    424  0000 ????				      eor	#PAL_50	; PAL-50?
    425  0000 ????				      bne	.ntsc
    426  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    427  0000 ????			   .ntsc
    428  0000 ????			   .loopWait
    429  0000 ????				      sta	WSYNC
    430  0000 ????				      sta	WSYNC
    431  0000 ????				      dey
    432  0000 ????				      bne	.loopWait
    433  0000 ????				      dex
    434  0000 ????				      bne	.loopResync
    435  0000 ????				      ENDM
    436  0000 ????
    437  0000 ????				      MAC	set_platform
    438  0000 ????						; 00 = NTSC
    439  0000 ????						; 01 = NTSC
    440  0000 ????						; 10 = PAL-50
    441  0000 ????						; 11 = PAL-60
    442  0000 ????				      lda	SWCHB
    443  0000 ????				      rol
    444  0000 ????				      rol
    445  0000 ????				      rol
    446  0000 ????				      and	#%11
    447  0000 ????				      eor	#PAL
    448  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    449  0000 ????				      ENDM
    450  0000 ????
    451  0000 ????
    452  0000 ????						;---------------------------------------------------------------------------------------------------
    453  0000 ????
    454  0000 ????				      MAC	jsrom_safe
    455  0000 ????						; Saves bank of routine to variable for later restore.
    456  0000 ????						; Switches to the bank and does a JSR to the routine.
    457  0000 ????
    458  0000 ????				      lda	#BANK_{1}
    459  0000 ????				      sta	savedBank
    460  0000 ????				      sta	SET_BANK
    461  0000 ????				      jsr	{1}
    462  0000 ????				      ENDM		; {routine}
    463  0000 ????
    464  0000 ????
    465  0000 ????				      MAC	jsrom
    466  0000 ????
    467  0000 ????				      lda	#BANK_{1}
    468  0000 ????				      sta	SET_BANK
    469  0000 ????				      jsr	{1}
    470  0000 ????				      ENDM		; {routine}
    471  0000 ????
    472  0000 ????
    473  0000 ????				      MAC	jsram
    474  0000 ????				      lda	#BANK_{1}
    475  0000 ????				      sta	SET_BANK_RAM
    476  0000 ????				      jsr	{1}
    477  0000 ????				      ENDM
    478  0000 ????
    479  0000 ????
    480  0000 ????
    481  0000 ????				      MAC	timecheck
    482  0000 ????				      lda	INTIM
    483  0000 ????				      cmp	#SPEEDOF_{1}
    484  0000 ????				      bcc	{2}
    485  0000 ????				      ENDM		; {ident}, {branch if out of time}
    486  0000 ????
    487  0000 ????
    488  0000 ????				      MAC	timing
    489  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    490  0000 ????				      ENDM		; {label}, {cycles}
    491  0000 ????
    492  0000 ????
    493  0000 ????						;---------------------------------------------------------------------------------------------------
    494  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 5
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00fa ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   savedBank  ds	1	; switched-in bank for FIXED returns
     24 U008c		       00	   aiState    ds	1	; state
     25 U008d		       00	   aiFlashDelay ds	1
     26 U008e
     27 U008e		       00	   aiMoveIndex ds	1
     28 U008f
     29 U008f		       00	   aiFlashPhase ds	1
     30 U0090
     31 U0090		       00 00	   Evaluation ds	2	; tracks value of the board position
     32 U0092
     33 U0092		       00	   currentPiece ds	1
     34 U0093		       00	   currentSquare ds	1
     35 U0094		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     36 U0095		       00	   currentPly ds	1
     37 U0096
     38 U0096							;    IFCONST PIECELIST_ENABLED
     39 U0096							;piecelistIndex		  ds 1
     40 U0096							;    ELSE
     41 U0096		       00	   squareIndex ds	1
     42 U0097							;    ENDIF
     43 U0097
     44 U0097
     45 U0097		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     46 U0098		       00	   fromPiece  ds	1
     47 U0099		       00	   lastPiece  ds	1
     48 U009a		       00	   previousPiece ds	1
     49 U009b
     50 U009b		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     51 U009c		       00 00	   speech_addr ds	2
     52 U009e		       00	   bg	      ds	1
     53 U009f
     54 U009f		       00	   capture    ds	1
     55 U00a0		       00	   captureLastPly ds	1
     56 U00a1
     57 U00a1				  -	      IF	DIAGNOSTICS
     58 U00a1				  -maxPly     ds	1
     59 U00a1				  -positionCount ds	3
     60 U00a1					      ENDIF
     61 U00a1
     62 U00a1		       00	   flagCheck  ds	1
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 5
      0 U00a2					      include	"overlays.asm"
      1 U00a2							; Chess
      2 U00a2							; Atari 2600 Chess display system
      3 U00a2							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a2							; andrew@taswegian.com
      5 U00a2
      6 U00a2							;---------------------------------------------------------------------------------------------------
      7 U00a2							; OVERLAYS!
      8 U00a2							; These variables are overlays, and should be managed with care
      9 U00a2							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a2							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a2							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a2							; overlay #2
     13 U00a2
     14 U00a2							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a2
     16 U00a2							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a2							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a2							;---------------------------------------------------------------------------------------------------
     19 U00a2
     20 U00a2					      MAC	overlay
     21 U00a2				   OVERLAY_NAME SET	{1}
     22 U00a2					      SEG.U	OVERLAY_{1}
     23 U00a2					      org	Overlay
     24 U00a2					      ENDM		; {name}
     25 U00a2
     26 U00a2							;---------------------------------------------------------------------------------------------------
     27 U00a2
     28 U00a2					      MAC	validate_overlay
     29 U00a2					      LIST	OFF
     30 U00a2				   OVERLAY_DELTA SET	* - Overlay
     31 U00a2					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a2					      ENDIF
     34 U00a2					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a2					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a2					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a2					      ERR
     38 U00a2					      ENDIF
     39 U00a2					      LIST	ON
     40 U00a2					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a2					      ENDM
     42 U00a2
     43 U00a2							;---------------------------------------------------------------------------------------------------
     44 U00a2
     45 U00a2				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a2
     48 U00a2
     49 U00a2							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a2							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a2							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a2							; (especially the latter ones) are only used in rare occasions.
     53 U00a2
     54 U00a2							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a2							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a2
      0 U00a2					      DEF	Overlay
      1 U00a2				   BANK_Overlay SET	_CURRENT_BANK
      2 U00a2				   Overlay
      3 U00a2				   TEMPORARY_VAR SET	Overlay
      4 U00a2				   TEMPORARY_OFFSET SET	0
      5 U00a2				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      6 U00a2				   FUNCTION_NAME SET	Overlay
      7 U00a2					      SUBROUTINE
     58 U00a2		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00ee				   END_OF_OVERLAY
     60 U00ee
     61 U00ee							;---------------------------------------------------------------------------------------------------
     62 U00ee							; And now... the overlays....
     63 U00ee
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00ee					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00ee
     66 U00ee							;---------------------------------------------------------------------------------------------------
     67 U00ee
     68 U00ee							; Some overlays are used across multiple routines/calls, and they will need to be defined
     69 U00ee							; "globally" in this file.
     70 U00ee
      0 U00ee					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00ee		       00 a2	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __pieceShapeBuffer, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr, 2
      1 U00ee		       00 ea	   __ptr      =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr2, 2
      1 U00ee		       00 ec	   __ptr2     =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr2, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
     74 U00ee
     75 U00ee							;---------------------------------------------------------------------------------------------------
     76 U00ee
     77 U00ee
     78 U00ee					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     79 U00ee					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $4c
     80 U00ee					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     81 U00ee
     82 U00ee							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 5
      0 U00ee					      include	"stack.asm"
      1 U00ee							; Chess
      2 U00ee							; Atari 2600 Chess display system
      3 U00ee							; Copyright (c) 2019-2020 Andrew Davie
      4 U00ee							; andrew@taswegian.com
      5 U00ee
      6 U00ee
      7 U00ee		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00ee
      9 U00ee		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00fa
     11 U00fa							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00fa							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00fa							;  but since overlay is not generally stressed during alphabeta, we're good.
------- FILE ./chess.asm
    498 U00fa
 FREE BYTES IN ZERO PAGE =  $5
    499 U00fa					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    500 U00fa				  -	      IF	* > $FF
    501 U00fa				  -	      ERR	"Zero Page overflow!"
    502 U00fa					      ENDIF
    503 U00fa
    504 U00fa							;------------------------------------------------------------------------------
    505 U00fa							;##############################################################################
    506 U00fa							;------------------------------------------------------------------------------
    507 U00fa
    508 U00fa							; NOW THE VERY INTERESTING '3E' RAM BANKS
    509 U00fa							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 1k TOTAL ACCESSIBLE
    510 U00fa							; IN A 2K MEMORY SPACE
    511 U00fa
      0 U00fa					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00fa
      2 U00fa
      3 U00fa
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	RAM_3E
      7 U0000				   BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	ORIGIN_RAM / RAM_SIZE
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    513 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	RAM_3E
      7 U0400				   BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0400				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0400				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0400				  -	      ERR
      5 U0400					      ENDIF
    513 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	RAM_3E
      7 U0800				   BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0800				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0800				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0800				  -	      ERR
      5 U0800					      ENDIF
    513 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	RAM_3E
      7 U0c00				   BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0c00				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0c00				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0c00				  -	      ERR
      5 U0c00					      ENDIF
    513 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	RAM_3E
      7 U1000				   BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1000				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1000				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1000				  -	      ERR
      5 U1000					      ENDIF
    513 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	RAM_3E
      7 U1400				   BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1400				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1400				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1400				  -	      ERR
      5 U1400					      ENDIF
    513 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	RAM_3E
      7 U1800				   BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1800				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1800				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1800				  -	      ERR
      5 U1800					      ENDIF
    513 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	RAM_3E
      7 U1c00				   BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1c00				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1c00				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1c00				  -	      ERR
      5 U1c00					      ENDIF
    516 U1c00					      REPEND
    517 U1c00
    518 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    519 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    520 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    521 U1c00
    522 U1c00							; A neat feature of having multiple copies of the same code in different RAM banks
    523 U1c00							; is that we can use that code to switch between banks, and the system will happily
    524 U1c00							; execute the next instruction from the newly switched-in bank without a problem.
    525 U1c00
    526 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    527 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    528 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    529 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    530 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    531 U1c00
    532 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    533 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    534 U1c00
    535 U1c00							;------------------------------------------------------------------------------
    536 U1c00
    537 U1c00
    538 U1c00							;---------------------------------------------------------------------------------------------------
    539 U1c00
    540 U1c00
    541 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    542 U1c00
    543 U1c00					      MAC	next_random
    544 U1c00					      lda	rnd
    545 U1c00					      lsr
    546 U1c00					      bcc	.skipEOR
    547 U1c00					      eor	#RND_EOR_VAL
    548 U1c00				   .skipEOR   sta	rnd
    549 U1c00					      ENDM
    550 U1c00
    551 U1c00							;--------------------------------------------------------------------------------
    552 U1c00
    553 U1c00					      MAC	phase
    554 U1c00					      lda	#{1}
    555 U1c00					      sta	aiState
    556 U1c00					      ENDM		;#
    557 U1c00
    558 U1c00
    559 U1c00					      MAC	common_vars_alphabeta
    560 U1c00
    561 U1c00					      VAR	__bestMove, 1
    562 U1c00					      VAR	__bestScore, 2
    563 U1c00					      VAR	__alpha, 2
    564 U1c00					      VAR	__beta, 2
    565 U1c00					      VAR	__negamax, 2
    566 U1c00					      VAR	__value, 2
    567 U1c00
    568 U1c00					      ENDM
    569 U1c00
    570 U1c00							;--------------------------------------------------------------------------------
    571 U1c00
    572 U1c00							;ORIGIN      SET 0
    573 U1c00
------- FILE Handler_MACROS.asm LEVEL 2 PASS 5
      0 U1c00					      include	"Handler_MACROS.asm"
      1 U1c00							; Copyright (C)2020 Andrew Davie
      2 U1c00							; Common macros for piece move handlers
      3 U1c00
      4 U1c00							;---------------------------------------------------------------------------------------------------
      5 U1c00							; Looks at a square offset {1} to see if piece can move to it
      6 U1c00							; Adds the square to the movelist if it can
      7 U1c00							; Keeps moving in the same direction until it's blocked/off=board
      8 U1c00
      9 U1c00					      MAC	move_towards
     10 U1c00					      SUBROUTINE
     11 U1c00
     12 U1c00							; = 76 for single square (empty/take)
     13 U1c00
     14 U1c00					      lda	#0
     15 U1c00					      sta	capture
     16 U1c00
     17 U1c00					      ldx	currentSquare	; 3
     18 U1c00					      bne	.project	; 3   unconditional
     19 U1c00
     20 U1c00				   .empty     jsr	AddMove	; 57
     21 U1c00				   .project   ldy	ValidSquare+{1},x	; 4
     22 U1c00					      bmi	.invalid	; 2/3 off board!
     23 U1c00					      lda	Board,y	; 4   piece @ destination
     24 U1c00					      beq	.empty	; 2/3
     25 U1c00					      sta	capture
     26 U1c00					      eor	currentPiece	; 3
     27 U1c00					      bpl	.invalid	; 2/3 same colour
     28 U1c00					      jsr	AddMove	; 57  and exit
     29 U1c00
     30 U1c00				   .invalid
     31 U1c00					      ENDM
     32 U1c00
     33 U1c00
     34 U1c00							;---------------------------------------------------------------------------------------------------
     35 U1c00
     36 U1c00					      MAC	move_to
     37 U1c00					      SUBROUTINE
     38 U1c00					      ldy	ValidSquare+{1},x
     39 U1c00					      bmi	.invalid	; off board!
     40 U1c00					      lda	Board,y	; piece @ destination
     41 U1c00					      sta	capture
     42 U1c00					      beq	.squareEmpty
     43 U1c00					      eor	currentPiece
     44 U1c00					      bpl	.invalid	; same colour
     45 U1c00				   .squareEmpty jsr	AddMove
     46 U1c00				   .invalid
     47 U1c00					      ENDM
     48 U1c00
     49 U1c00
     50 U1c00							;---------------------------------------------------------------------------------------------------
     51 U1c00
     52 U1c00					      MAC	move_to_x
     53 U1c00					      ldx	currentSquare
     54 U1c00					      MOVE_TO	{1}
     55 U1c00					      ENDM
     56 U1c00
     57 U1c00
     58 U1c00							;---------------------------------------------------------------------------------------------------
     59 U1c00							; EOF
------- FILE ./chess.asm
    575 U1c00
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 5
      0 U1c00					      include	"BANK_GENERIC.asm"
      1 U1c00
      0 U1c00					      NEWBANK	GENERIC_BANK_1
      1  07d8 ????				      SEG	GENERIC_BANK_1
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	GENERIC_BANK_1
      3  0000
      0  0000					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  0000					      ALIGN	$400
      2  0000				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  0000				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
      5  0000
      6  0000				  -	      if	0
      7  0000				  -	      IF	PLUSCART = YES
      8  0000				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
      9  0000				  -	      .byte	"pluscart.firmaplus.de", #0
     10  0000				  -	      ENDIF
     11  0000					      endif
     12  0000
     13  0000		       85 3e a9 00 STELLA_AUTODETECT .byte.b	$85,$3e,$a9,$00	; 3E
     14  0004
     15  0004
     16  0004							;---------------------------------------------------------------------------------------------------
     17  0004							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     18  0004							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     19  0004							; bank finishes.  Just continue on from where it left off...
     20  0004							;---------------------------------------------------------------------------------------------------
     21  0004
      0  0004					      DEF	Cart_Init
      1  0004				   BANK_Cart_Init SET	_CURRENT_BANK
      2  0004				   Cart_Init
      3  0004				   TEMPORARY_VAR SET	Overlay
      4  0004				   TEMPORARY_OFFSET SET	0
      5  0004				   VAR_BOUNDARY_Cart_Init SET	TEMPORARY_OFFSET
      6  0004				   FUNCTION_NAME SET	Cart_Init
      7  0004					      SUBROUTINE
     23  0004					      SUBROUTINE
     24  0004
      0  0004					      REFER	Reset
      1  0004				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0004				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0004					      ENDIF
      0  0004					      VEND	Cart_Init
      1  0004				  -	      IFNCONST	Cart_Init
      2  0004				  -	      ECHO	"Incorrect VEND label", Cart_Init
      3  0004				  -	      ERR
      4  0004					      ENDIF
      5  0004		       00 a2	   VAREND_Cart_Init =	TEMPORARY_VAR
     27  0004
     28  0004		       78		      sei
     29  0005		       d8		      cld
     30  0006
     31  0006							; See if we can come up with something 'random' for startup
     32  0006
     33  0006		       ac 84 02 	      ldy	INTIM
     34  0009		       d0 02		      bne	.toR
     35  000b		       a0 9a		      ldy	#$9A
     36  000d		       84 81	   .toR       sty	rnd
     37  000f
     38  000f
     39  000f		       a9 00		      lda	#0
     40  0011		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     41  0014		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     42  0017		       85 6b		      sta	HMCLR
     43  0019
     44  0019							; cleanup remains of title screen
     45  0019		       85 5b		      sta	GRP0
     46  001b		       85 5c		      sta	GRP1
     47  001d
     48  001d		       a9 10		      lda	#%00010000	; double width missile, double width player
     49  001f		       85 44		      sta	NUSIZ0
     50  0021		       85 45		      sta	NUSIZ1
     51  0023
     52  0023		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     53  0025		       85 4a		      sta	CTRLPF
     54  0027
     55  0027		       a9 09		      lda	#WHITE+RAMBANK_PLY
     56  0029		       85 97		      sta	sideToMove
     57  002b
     58  002b
     59  002b							;		      rts
     60  002b							;   ; fall through...
     61  002b
     62  002b							;---------------------------------------------------------------------------------------------------
     63  002b
      0  002b					      DEF	SetupBanks
      1  002b				   BANK_SetupBanks SET	_CURRENT_BANK
      2  002b				   SetupBanks
      3  002b				   TEMPORARY_VAR SET	Overlay
      4  002b				   TEMPORARY_OFFSET SET	0
      5  002b				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      6  002b				   FUNCTION_NAME SET	SetupBanks
      7  002b					      SUBROUTINE
     65  002b					      SUBROUTINE
     66  002b
     67  002b							; Move a copy of the row bank template to the first 8 banks of RAM
     68  002b							; and then terminate the draw subroutine by substituting in a RTS on the last one
     69  002b
      0  002b					      REFER	Reset
      1  002b				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  002b				  -TEMPORARY_VAR SET	VAREND_Reset
      3  002b					      ENDIF
      0  002b					      VAR	__plyBank, 1
      1  002b		       00 a2	   __plyBank  =	TEMPORARY_VAR
      2  002b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  002b
      4  002b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  002b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  002b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  002b					      ENDIF
      8  002b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  002b				  -	      ECHO	"Temporary Variable", __plyBank, "overflow!"
     10  002b				  -	      ERR
     11  002b					      ENDIF
     12  002b					      LIST	ON
      0  002b					      VEND	SetupBanks
      1  002b				  -	      IFNCONST	SetupBanks
      2  002b				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  002b				  -	      ERR
      4  002b					      ENDIF
      5  002b		       00 a3	   VAREND_SetupBanks =	TEMPORARY_VAR
     73  002b
     74  002b							; SAFE
     75  002b
     76  002b		       a0 07		      ldy	#7
     77  002d		       a2 01	   .copyRowBanks ldx	#BANK_ROM_SHADOW_OF_CHESS_BITMAP
     78  002f		       20 27 fd 	      jsr	CopyShadowROMtoRAM
     79  0032		       88		      dey
     80  0033		       10 f8		      bpl	.copyRowBanks
     81  0035
     82  0035
     83  0035							; copy the BOARD/MOVES bank
     84  0035
     85  0035		       a0 08		      ldy	#RAMBANK_BOARD
     86  0037		       a2 0a		      ldx	#MOVES
     87  0039		       20 27 fd 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
     88  003c
     89  003c							; copy the PLY banks
     90  003c
     91  003c		       a9 0a		      lda	#MAX_PLY
     92  003e		       85 a2		      sta	__plyBank
     93  0040		       a0 09		      ldy	#RAMBANK_PLY
     94  0042		       84 95		      sty	currentPly
     95  0044		       a2 0b	   .copyPlyBanks ldx	#BANK_PLY
     96  0046		       20 27 fd 	      jsr	CopyShadowROMtoRAM
     97  0049		       c8		      iny
     98  004a		       c6 a2		      dec	__plyBank
     99  004c		       d0 f6		      bne	.copyPlyBanks
    100  004e
    101  004e		       60		      rts
    102  004f
    103  004f
    104  004f							;---------------------------------------------------------------------------------------------------
    105  004f
      0  004f					      DEF	tidySc
      1  004f				   BANK_tidySc SET	_CURRENT_BANK
      2  004f				   tidySc
      3  004f				   TEMPORARY_VAR SET	Overlay
      4  004f				   TEMPORARY_OFFSET SET	0
      5  004f				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      6  004f				   FUNCTION_NAME SET	tidySc
      7  004f					      SUBROUTINE
    107  004f					      SUBROUTINE
    108  004f
    109  004f		       a9 00		      lda	#0
    110  0051		       85 4d		      sta	PF0
    111  0053		       85 4e		      sta	PF1
    112  0055		       85 4f		      sta	PF2
    113  0057		       85 5b		      sta	GRP0
    114  0059		       85 5c		      sta	GRP1
    115  005b
    116  005b		       a9 42		      lda	#%01000010	; bit6 is not required
    117  005d		       85 41		      sta	VBLANK	; end of screen - enter blanking
    118  005f
    119  005f
    120  005f							; END OF VISIBLE SCREEN
    121  005f							; HERE'S SOME TIME TO DO STUFF
    122  005f
    123  005f		       a9 2d		      lda	#TIME_PART_2
    124  0061		       8d 96 02 	      sta	TIM64T
    125  0064		       60		      rts
    126  0065
    127  0065
    128  0065							;---------------------------------------------------------------------------------------------------
    129  0065
      0  0065					      DEF	longD
      1  0065				   BANK_longD SET	_CURRENT_BANK
      2  0065				   longD
      3  0065				   TEMPORARY_VAR SET	Overlay
      4  0065				   TEMPORARY_OFFSET SET	0
      5  0065				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      6  0065				   FUNCTION_NAME SET	longD
      7  0065					      SUBROUTINE
    131  0065					      SUBROUTINE
    132  0065
    133  0065		       85 42		      sta	WSYNC
    134  0067
    135  0067		       20 69 f8 	      jsr	_rts
    136  006a		       20 69 f8 	      jsr	_rts
    137  006d		       20 69 f8 	      jsr	_rts
      0  0070					      SLEEP	7
      1  0070				   .CYCLES    SET	7
      2  0070
      3  0070				  -	      IF	.CYCLES < 2
      4  0070				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0070				  -	      ERR
      6  0070					      ENDIF
      7  0070
      8  0070					      IF	.CYCLES & 1
      9  0070					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0070		       04 00		      nop	0
     11  0072				  -	      ELSE
     12  0072				  -	      bit	VSYNC
     13  0072					      ENDIF
     14  0072				   .CYCLES    SET	.CYCLES - 3
     15  0072					      ENDIF
     16  0072
     17  0072					      REPEAT	.CYCLES / 2
     18  0072		       ea		      nop
     17  0072					      REPEND
     18  0073		       ea		      nop
     19  0074					      REPEND
    139  0074
    140  0074		       a2 00		      ldx	#0
    141  0076		       86 41		      stx	VBLANK
    142  0078		       60		      rts
    143  0079
    144  0079				  -	      if	0
    145  0079				  -	      DEF	Resync
    146  0079				  -	      SUBROUTINE
    147  0079				  -
    148  0079				  -	      RESYNC
    149  0079				  -	      rts
    150  0079					      endif
    151  0079
    152  0079							;---------------------------------------------------------------------------------------------------
    153  0079
      0  0079					      DEF	aiStartClearBoard
      1  0079				   BANK_aiStartClearBoard SET	_CURRENT_BANK
      2  0079				   aiStartClearBoard
      3  0079				   TEMPORARY_VAR SET	Overlay
      4  0079				   TEMPORARY_OFFSET SET	0
      5  0079				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      6  0079				   FUNCTION_NAME SET	aiStartClearBoard
      7  0079					      SUBROUTINE
    155  0079					      SUBROUTINE
    156  0079
      0  0079					      REFER	AiStateMachine
      1  0079				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0079				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0079					      ENDIF
      0  0079					      VEND	aiStartClearBoard
      1  0079				  -	      IFNCONST	aiStartClearBoard
      2  0079				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  0079				  -	      ERR
      4  0079					      ENDIF
      5  0079		       00 a2	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
    159  0079
    160  0079		       a2 08		      ldx	#8
    161  007b		       86 84		      stx	drawCount	; = bank
    162  007d
    163  007d		       a9 ff		      lda	#-1
    164  007f		       85 88		      sta	cursorX12
    165  0081
      0  0081					      PHASE	AI_ClearEachRow
      1  0081		       a9 0e		      lda	#AI_ClearEachRow
      2  0083		       85 8c		      sta	aiState
    167  0085		       60		      rts
    168  0086
    169  0086							;---------------------------------------------------------------------------------------------------
    170  0086
      0  0086					      DEF	aiClearEachRow
      1  0086				   BANK_aiClearEachRow SET	_CURRENT_BANK
      2  0086				   aiClearEachRow
      3  0086				   TEMPORARY_VAR SET	Overlay
      4  0086				   TEMPORARY_OFFSET SET	0
      5  0086				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      6  0086				   FUNCTION_NAME SET	aiClearEachRow
      7  0086					      SUBROUTINE
    172  0086					      SUBROUTINE
    173  0086
      0  0086					      REFER	AiStateMachine
      1  0086				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0086				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0086					      ENDIF
      0  0086					      VEND	aiClearEachRow
      1  0086				  -	      IFNCONST	aiClearEachRow
      2  0086				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  0086				  -	      ERR
      4  0086					      ENDIF
      5  0086		       00 a2	   VAREND_aiClearEachRow =	TEMPORARY_VAR
    176  0086
    177  0086		       c6 84		      dec	drawCount
    178  0088		       30 05		      bmi	.bitmapCleared
    179  008a		       a4 84		      ldy	drawCount
    180  008c		       4c 76 f8 	      jmp	CallClear
    181  008f
    182  008f				   .bitmapCleared
    183  008f
    184  008f		       a9 63		      lda	#99
    185  0091		       85 80		      sta	squareToDraw
    186  0093
      0  0093					      PHASE	AI_DrawEntireBoard
      1  0093		       a9 0f		      lda	#AI_DrawEntireBoard
      2  0095		       85 8c		      sta	aiState
    188  0097		       60		      rts
    189  0098
    190  0098
    191  0098
    192  0098							;---------------------------------------------------------------------------------------------------
    193  0098
      0  0098					      DEF	aiMoveIsSelected
      1  0098				   BANK_aiMoveIsSelected SET	_CURRENT_BANK
      2  0098				   aiMoveIsSelected
      3  0098				   TEMPORARY_VAR SET	Overlay
      4  0098				   TEMPORARY_OFFSET SET	0
      5  0098				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      6  0098				   FUNCTION_NAME SET	aiMoveIsSelected
      7  0098					      SUBROUTINE
    195  0098					      SUBROUTINE
    196  0098
      0  0098					      REFER	AiStateMachine
      1  0098				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0098				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0098					      ENDIF
      0  0098					      VEND	aiMoveIsSelected
      1  0098				  -	      IFNCONST	aiMoveIsSelected
      2  0098				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  0098				  -	      ERR
      4  0098					      ENDIF
      5  0098		       00 a2	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    199  0098
    200  0098
    201  0098							; Both computer and human have now seleted a move, and converge here
    202  0098
    203  0098
    204  0098							; fromPiece	 piece doing the move
    205  0098							; fromX12	 current square X12
    206  0098							; originX12	 starting square X12
    207  0098							; toX12	 ending square X12
    208  0098
    209  0098		       20 b0 f9 	      jsr	AdjustMaterialPositionalValue
    210  009b
    211  009b		       a9 00		      lda	#BLANK
    212  009d		       85 9a		      sta	previousPiece
    213  009f
    214  009f							;lda toSquare
    215  009f							;cmp fromSquare
    216  009f							;beq .idleErase
    217  009f
    218  009f		       a9 06		      lda	#6	; on/off count
    219  00a1		       85 84		      sta	drawCount	; flashing for piece about to move
    220  00a3		       a9 00		      lda	#0
    221  00a5		       85 82		      sta	drawDelay
    222  00a7
      0  00a7					      PHASE	AI_WriteStartPieceBlank
      1  00a7		       a9 16		      lda	#AI_WriteStartPieceBlank
      2  00a9		       85 8c		      sta	aiState
    224  00ab		       60	   .idleErase rts
    225  00ac
    226  00ac
    227  00ac							;---------------------------------------------------------------------------------------------------
    228  00ac
      0  00ac					      DEF	aiWriteStartPieceBlank
      1  00ac				   BANK_aiWriteStartPieceBlank SET	_CURRENT_BANK
      2  00ac				   aiWriteStartPieceBlank
      3  00ac				   TEMPORARY_VAR SET	Overlay
      4  00ac				   TEMPORARY_OFFSET SET	0
      5  00ac				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      6  00ac				   FUNCTION_NAME SET	aiWriteStartPieceBlank
      7  00ac					      SUBROUTINE
    230  00ac					      SUBROUTINE
    231  00ac
      0  00ac					      REFER	AiStateMachine
      1  00ac				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00ac				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00ac					      ENDIF
      0  00ac					      VEND	aiWriteStartPieceBlank
      1  00ac				  -	      IFNCONST	aiWriteStartPieceBlank
      2  00ac				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  00ac				  -	      ERR
      4  00ac					      ENDIF
      5  00ac		       00 a2	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    234  00ac
    235  00ac							; Flash the piece in-place preparatory to moving it.
    236  00ac							; drawDelay = flash speed
    237  00ac							; drawCount = # of flashes
    238  00ac
    239  00ac		       a5 82		      lda	drawDelay
    240  00ae		       f0 03		      beq	deCount
    241  00b0		       c6 82		      dec	drawDelay
    242  00b2		       60		      rts
    243  00b3				   deCount
    244  00b3
    245  00b3		       a5 84		      lda	drawCount
    246  00b5		       f0 0e		      beq	flashDone
    247  00b7		       c6 84		      dec	drawCount
    248  00b9
    249  00b9		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    250  00bb		       85 82		      sta	drawDelay	; "getting ready to move" flash
    251  00bd
    252  00bd		       a5 85		      lda	fromX12
    253  00bf		       85 80		      sta	squareToDraw
    254  00c1
    255  00c1		       20 57 fd 	      jsr	CopySinglePiece	; EOR-draw = flash
    256  00c4		       60		      rts
    257  00c5
      0  00c5				   flashDone  PHASE	AI_MarchToTargetA
      1  00c5		       a9 17		      lda	#AI_MarchToTargetA
      2  00c7		       85 8c		      sta	aiState
    259  00c9		       60		      rts
    260  00ca
    261  00ca
    262  00ca							;---------------------------------------------------------------------------------------------------
    263  00ca
      0  00ca					      DEF	aiDrawPart2
      1  00ca				   BANK_aiDrawPart2 SET	_CURRENT_BANK
      2  00ca				   aiDrawPart2
      3  00ca				   TEMPORARY_VAR SET	Overlay
      4  00ca				   TEMPORARY_OFFSET SET	0
      5  00ca				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      6  00ca				   FUNCTION_NAME SET	aiDrawPart2
      7  00ca					      SUBROUTINE
    265  00ca					      SUBROUTINE
    266  00ca
      0  00ca					      REFER	AiStateMachine
      1  00ca				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00ca				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00ca					      ENDIF
      0  00ca					      VEND	aiDrawPart2
      1  00ca				  -	      IFNCONST	aiDrawPart2
      2  00ca				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  00ca				  -	      ERR
      4  00ca					      ENDIF
      5  00ca		       00 a2	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
    269  00ca
    270  00ca		       20 57 fd 	      jsr	CopySinglePiece
    271  00cd
      0  00cd					      DEF	aiDrawPart3
      1  00cd				   BANK_aiDrawPart3 SET	_CURRENT_BANK
      2  00cd				   aiDrawPart3
      3  00cd				   TEMPORARY_VAR SET	Overlay
      4  00cd				   TEMPORARY_OFFSET SET	0
      5  00cd				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      6  00cd				   FUNCTION_NAME SET	aiDrawPart3
      7  00cd					      SUBROUTINE
    273  00cd					      SUBROUTINE
    274  00cd
    275  00cd		       c6 80		      dec	squareToDraw
    276  00cf		       a5 80		      lda	squareToDraw
    277  00d1		       c9 16		      cmp	#22
    278  00d3		       90 05		      bcc	.comp
    279  00d5
      0  00d5					      PHASE	AI_DrawEntireBoard
      1  00d5		       a9 0f		      lda	#AI_DrawEntireBoard
      2  00d7		       85 8c		      sta	aiState
    281  00d9		       60		      rts
    282  00da
      0  00da				   .comp      PHASE	AI_FlipBuffers
      1  00da		       a9 12		      lda	#AI_FlipBuffers
      2  00dc		       85 8c		      sta	aiState
    284  00de		       60		      rts
    285  00df
    286  00df
    287  00df
    288  00df							;---------------------------------------------------------------------------------------------------
    289  00df
      0  00df					      DEF	aiMarchB
      1  00df				   BANK_aiMarchB SET	_CURRENT_BANK
      2  00df				   aiMarchB
      3  00df				   TEMPORARY_VAR SET	Overlay
      4  00df				   TEMPORARY_OFFSET SET	0
      5  00df				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      6  00df				   FUNCTION_NAME SET	aiMarchB
      7  00df					      SUBROUTINE
    291  00df					      SUBROUTINE
    292  00df
      0  00df					      REFER	AiStateMachine
      1  00df				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00df				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00df					      ENDIF
      0  00df					      VEND	aiMarchB
      1  00df				  -	      IFNCONST	aiMarchB
      2  00df				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  00df				  -	      ERR
      4  00df					      ENDIF
      5  00df		       00 a2	   VAREND_aiMarchB =	TEMPORARY_VAR
    295  00df
    296  00df							; Draw the piece in the new square
    297  00df
    298  00df		       a5 85		      lda	fromX12
    299  00e1		       85 80		      sta	squareToDraw
    300  00e3
    301  00e3		       20 57 fd 	      jsr	CopySinglePiece	; draw the moving piece into the new square
    302  00e6
    303  00e6		       a9 06		      lda	#6	; snail trail delay
    304  00e8		       85 82		      sta	drawDelay
    305  00ea
      0  00ea					      PHASE	AI_MarchToTargetB
      1  00ea		       a9 19		      lda	#AI_MarchToTargetB
      2  00ec		       85 8c		      sta	aiState
    307  00ee		       60		      rts
    308  00ef
    309  00ef
    310  00ef							;---------------------------------------------------------------------------------------------------
    311  00ef
      0  00ef					      DEF	aiFinalFlash
      1  00ef				   BANK_aiFinalFlash SET	_CURRENT_BANK
      2  00ef				   aiFinalFlash
      3  00ef				   TEMPORARY_VAR SET	Overlay
      4  00ef				   TEMPORARY_OFFSET SET	0
      5  00ef				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      6  00ef				   FUNCTION_NAME SET	aiFinalFlash
      7  00ef					      SUBROUTINE
    313  00ef					      SUBROUTINE
    314  00ef
      0  00ef					      REFER	AiStateMachine
      1  00ef				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00ef				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00ef					      ENDIF
      0  00ef					      VEND	aiFinalFlash
      1  00ef				  -	      IFNCONST	aiFinalFlash
      2  00ef				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  00ef				  -	      ERR
      4  00ef					      ENDIF
      5  00ef		       00 a2	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    317  00ef
    318  00ef
    319  00ef		       a5 82		      lda	drawDelay
    320  00f1		       f0 03		      beq	.deCount
    321  00f3		       c6 82		      dec	drawDelay
    322  00f5		       60		      rts
    323  00f6
    324  00f6		       a5 84	   .deCount   lda	drawCount
    325  00f8		       f0 0e		      beq	flashDone2
    326  00fa		       c6 84		      dec	drawCount
    327  00fc
    328  00fc		       a9 0a		      lda	#10
    329  00fe		       85 82		      sta	drawDelay	; "getting ready to move" flash
    330  0100
    331  0100		       a5 85		      lda	fromX12
    332  0102		       85 80		      sta	squareToDraw
    333  0104
    334  0104		       20 57 fd 	      jsr	CopySinglePiece
    335  0107		       60		      rts
    336  0108
      0  0108				   flashDone2 PHASE	AI_SpecialMoveFixup
      1  0108		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  010a		       85 8c		      sta	aiState
    338  010c		       60		      rts
    339  010d
    340  010d
    341  010d							;---------------------------------------------------------------------------------------------------
    342  010d
      0  010d					      DEF	aiDraw
      1  010d				   BANK_aiDraw SET	_CURRENT_BANK
      2  010d				   aiDraw
      3  010d				   TEMPORARY_VAR SET	Overlay
      4  010d				   TEMPORARY_OFFSET SET	0
      5  010d				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      6  010d				   FUNCTION_NAME SET	aiDraw
      7  010d					      SUBROUTINE
    344  010d					      SUBROUTINE
    345  010d		       a9 c0		      lda	#$C0
    346  010f		       85 49		      sta	COLUBK
    347  0111		       60		      rts
    348  0112
    349  0112
    350  0112							;---------------------------------------------------------------------------------------------------
    351  0112
      0  0112					      DEF	aiCheckMate
      1  0112				   BANK_aiCheckMate SET	_CURRENT_BANK
      2  0112				   aiCheckMate
      3  0112				   TEMPORARY_VAR SET	Overlay
      4  0112				   TEMPORARY_OFFSET SET	0
      5  0112				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      6  0112				   FUNCTION_NAME SET	aiCheckMate
      7  0112					      SUBROUTINE
    353  0112					      SUBROUTINE
    354  0112		       a9 44		      lda	#$44
    355  0114		       85 49		      sta	COLUBK
    356  0116		       60		      rts
    357  0117
    358  0117
    359  0117							;---------------------------------------------------------------------------------------------------
    360  0117
      0  0117					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1"
      1  0117
      2  0117
      3  0117		       01 17	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (1K) SIZE =  $117 , FREE= $2e9
      4  0117					      ECHO	"GENERIC_BANK_1", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0117				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0117				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0117				  -	      ERR
      8  0117					      endif
    362  0117
    363  0117
    364  0117							;---------------------------------------------------------------------------------------------------
    365  0117
------- FILE piece_vectors.asm LEVEL 3 PASS 5
      0  0117					      include	"piece_vectors.asm"
      1  0117							; Created by ConvertChessPieces.py
      0  0117					      DEF	PIECE_VECTOR_LO
      1  0117				   BANK_PIECE_VECTOR_LO SET	_CURRENT_BANK
      2  0117				   PIECE_VECTOR_LO
      3  0117				   TEMPORARY_VAR SET	Overlay
      4  0117				   TEMPORARY_OFFSET SET	0
      5  0117				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      6  0117				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      7  0117					      SUBROUTINE
      3  0117		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  0118		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  0119		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  011a		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  011b		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  011c		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  011d		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  011e		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  011f		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  0120		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  0121		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  0122		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  0123		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  0124		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  0125		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  0126		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  0127		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  0128		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  0129		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  012a		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  012b		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  012c		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  012d		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  012e		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  012f		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  0130		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  0131		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  0132		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  0133		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  0134		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  0135		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  0136		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  0137		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  0138		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  0139		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  013a		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  013b		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  013c		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  013d		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  013e		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  013f		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  0140		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  0141		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  0142		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  0143		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  0144		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  0145		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  0146		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  0147		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  0148		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  0149		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  014a		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  014b		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  014c		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  014d		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  014e		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  014f		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  0150		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  0151		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  0152		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  0153		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  0154		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  0155		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  0156		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  0157		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  0158		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  0159		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  015a		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  015b		       b4		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  015c		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  015d		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  015e		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  015f		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  0160		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  0161		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  0162		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  0163		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  0164		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  0165		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  0166		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  0167		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  0168		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  0169		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  016a		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  016b		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  016c		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  016d		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  016e		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  016f		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  0170		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  0171		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  0172		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  0173		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  0174		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  0175		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  0176		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  0177		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  0178		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  0179		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  017a		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  017b		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  017c		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  017d		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  017e		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  017f		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  0180		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  0181		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  0182		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  0183		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  0184		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  0185		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  0186		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  0187		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  0188		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  0189		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  018a		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  018b		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  018c		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  018d		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  018e		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  018f		       87		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  0190		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  0191		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  0192		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  0193		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  0194		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  0195		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  0196		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  0197		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  0198		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  0199		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  019a		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  019b		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  019c		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  019d		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  019e		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  019f		       38		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  01a0		       80		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  01a1		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  01a2		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  01a3		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  01a4		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  01a5		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  01a6		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  01a7					      DEF	PIECE_VECTOR_HI
      1  01a7				   BANK_PIECE_VECTOR_HI SET	_CURRENT_BANK
      2  01a7				   PIECE_VECTOR_HI
      3  01a7				   TEMPORARY_VAR SET	Overlay
      4  01a7				   TEMPORARY_OFFSET SET	0
      5  01a7				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      6  01a7				   FUNCTION_NAME SET	PIECE_VECTOR_HI
      7  01a7					      SUBROUTINE
    148  01a7		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  01a8		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  01a9		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  01aa		       f1		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  01ab		       f1		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  01ac		       f1		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  01ad		       f2		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  01ae		       f2		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  01af		       f2		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  01b0		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  01b1		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  01b2		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  01b3		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  01b4		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  01b5		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  01b6		       f5		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  01b7		       f5		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  01b8		       f5		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  01b9		       f6		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  01ba		       f6		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  01bb		       f6		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  01bc		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  01bd		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  01be		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  01bf		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  01c0		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  01c1		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  01c2		       f1		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  01c3		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  01c4		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  01c5		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  01c6		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  01c7		       f5		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  01c8		       f5		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  01c9		       f5		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  01ca		       f6		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  01cb		       f1		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  01cc		       f1		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  01cd		       f2		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  01ce		       f2		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  01cf		       f2		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  01d0		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  01d1		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  01d2		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  01d3		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  01d4		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  01d5		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  01d6		       f5		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  01d7		       f5		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  01d8		       f5		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  01d9		       f6		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  01da		       f6		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  01db		       f6		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  01dc		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  01dd		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  01de		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  01df		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  01e0		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  01e1		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  01e2		       f1		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  01e3		       f1		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  01e4		       f1		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  01e5		       f2		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  01e6		       f2		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  01e7		       f5		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  01e8		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  01e9		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  01ea		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  01eb		       f3		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  01ec		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  01ed		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  01ee		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  01ef		       f2		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  01f0		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  01f1		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  01f2		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  01f3		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  01f4		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  01f5		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  01f6		       f5		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  01f7		       f5		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  01f8		       f5		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  01f9		       f6		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  01fa		       f6		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  01fb		       f6		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  01fc		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  01fd		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  01fe		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  01ff		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  0200		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  0201		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  0202		       f1		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  0203		       f1		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  0204		       f1		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  0205		       f2		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  0206		       f2		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  0207		       f2		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  0208		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  0209		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  020a		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  020b		       f5		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  020c		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  020d		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  020e		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  020f		       f4		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  0210		       f4		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  0211		       f5		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  0212		       f5		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  0213		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  0214		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  0215		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  0216		       f5		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  0217		       f5		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  0218		       f5		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  0219		       f6		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  021a		       f6		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  021b		       f6		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  021c		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  021d		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  021e		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  021f		       f1		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  0220		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  0221		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  0222		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  0223		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  0224		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  0225		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  0226		       f4		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  0227		       f4		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  0228		       f4		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  0229		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  022a		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  022b		       f5		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  022c		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  022d		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  022e		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  022f		       f4		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  0230		       f4		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  0231		       f5		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  0232		       f5		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  0233		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  0234		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  0235		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  0236		       f4		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  0237					      DEF	PIECE_VECTOR_BANK
      1  0237				   BANK_PIECE_VECTOR_BANK SET	_CURRENT_BANK
      2  0237				   PIECE_VECTOR_BANK
      3  0237				   TEMPORARY_VAR SET	Overlay
      4  0237				   TEMPORARY_OFFSET SET	0
      5  0237				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      6  0237				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
      7  0237					      SUBROUTINE
    293  0237		       02		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  0238		       02		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  0239		       02		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  023a		       02		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  023b		       02		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  023c		       02		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  023d		       02		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  023e		       02		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  023f		       02		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  0240		       02		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  0241		       02		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  0242		       02		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  0243		       02		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  0244		       02		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  0245		       02		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  0246		       02		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  0247		       02		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  0248		       02		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  0249		       02		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  024a		       02		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  024b		       02		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  024c		       02		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  024d		       02		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  024e		       02		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  024f		       03		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  0250		       03		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  0251		       03		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  0252		       03		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  0253		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  0254		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  0255		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  0256		       09		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  0257		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  0258		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  0259		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  025a		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  025b		       03		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  025c		       03		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  025d		       03		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  025e		       03		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  025f		       03		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  0260		       03		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  0261		       03		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  0262		       03		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  0263		       03		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  0264		       03		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  0265		       03		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  0266		       03		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  0267		       03		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  0268		       03		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  0269		       03		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  026a		       03		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  026b		       03		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  026c		       03		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  026d		       03		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  026e		       03		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  026f		       04		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  0270		       04		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  0271		       04		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  0272		       04		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  0273		       04		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  0274		       04		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  0275		       04		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  0276		       04		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  0277		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  0278		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  0279		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  027a		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  027b		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  027c		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  027d		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  027e		       0a		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  027f		       04		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  0280		       04		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  0281		       04		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  0282		       04		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  0283		       04		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  0284		       04		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  0285		       04		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  0286		       04		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  0287		       04		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  0288		       04		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  0289		       04		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  028a		       04		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  028b		       04		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  028c		       04		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  028d		       04		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  028e		       04		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  028f		       05		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  0290		       05		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  0291		       05		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  0292		       05		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  0293		       05		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  0294		       05		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  0295		       05		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  0296		       05		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  0297		       05		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  0298		       05		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  0299		       05		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  029a		       05		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  029b		       06		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  029c		       06		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  029d		       06		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  029e		       06		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  029f		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  02a0		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  02a1		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  02a2		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  02a3		       05		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  02a4		       05		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  02a5		       05		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  02a6		       05		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  02a7		       05		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  02a8		       05		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  02a9		       05		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  02aa		       05		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  02ab		       05		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  02ac		       05		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  02ad		       05		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  02ae		       05		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  02af		       09		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  02b0		       09		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  02b1		       09		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  02b2		       09		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  02b3		       09		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  02b4		       09		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  02b5		       09		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  02b6		       09		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  02b7		       09		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  02b8		       09		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  02b9		       09		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  02ba		       09		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  02bb		       09		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  02bc		       09		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  02bd		       09		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  02be		       09		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  02bf		       06		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  02c0		       06		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  02c1		       06		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  02c2		       06		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  02c3		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  02c4		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  02c5		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  02c6		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  02c7
    438  02c7							; piece index equates...
    439  02c7		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  02c7		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  02c7		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  02c7		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  02c7		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  02c7		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  02c7		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  02c7		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  02c7		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  02c7		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  02c7		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  02c7		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  02c7		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  02c7		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  02c7		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  02c7		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  02c7		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  02c7		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  02c7		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  02c7		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  02c7		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  02c7		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  02c7		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  02c7		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  02c7		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  02c7		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  02c7		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  02c7		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  02c7		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  02c7		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  02c7		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  02c7		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  02c7		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  02c7		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  02c7		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  02c7		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  02c7		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  02c7		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  02c7		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  02c7		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  02c7		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  02c7		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  02c7		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  02c7		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  02c7		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  02c7		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  02c7		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  02c7		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  02c7		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  02c7		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  02c7		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  02c7		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  02c7		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  02c7		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  02c7		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  02c7		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  02c7		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  02c7		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  02c7		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  02c7		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  02c7		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  02c7		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  02c7		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  02c7		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  02c7		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  02c7		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  02c7		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  02c7		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  02c7		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  02c7		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  02c7		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  02c7		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  02c7		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  02c7		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  02c7		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  02c7		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  02c7		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  02c7		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  02c7		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  02c7		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  02c7		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  02c7		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  02c7		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  02c7		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  02c7		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  02c7		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  02c7		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  02c7		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  02c7		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  02c7		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  02c7		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  02c7		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  02c7		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  02c7		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  02c7		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  02c7		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  02c7		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  02c7		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  02c7		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  02c7		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  02c7		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  02c7		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  02c7		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  02c7		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  02c7		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  02c7		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  02c7		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  02c7		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  02c7		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  02c7		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  02c7		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  02c7		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  02c7		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  02c7		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  02c7		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  02c7		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  02c7		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  02c7		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  02c7		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  02c7		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  02c7		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  02c7		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  02c7		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  02c7		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  02c7		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  02c7		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  02c7		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  02c7		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  02c7		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  02c7		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  02c7		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  02c7		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  02c7		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  02c7		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  02c7		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  02c7		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  02c7		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  02c7		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  02c7		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  02c7		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  02c7		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  02c7		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  02c7		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  02c7		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC.asm
    367  02c7
    368  02c7							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
    369  02c7							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
    370  02c7							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
    371  02c7							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
    372  02c7							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
    373  02c7							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
    374  02c7							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
    375  02c7							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
    376  02c7
    377  02c7							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
    378  02c7							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
    379  02c7							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
    380  02c7							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
    381  02c7							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
    382  02c7							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
    383  02c7							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
    384  02c7							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
    385  02c7
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  02c7					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  02c7					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  0300					      LIST	ON
      0  0300					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  0300				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  0300				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  0300				   TEMPORARY_VAR SET	Overlay
      4  0300				   TEMPORARY_OFFSET SET	0
      5  0300				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0300				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      7  0300					      SUBROUTINE
      3  0300		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0318		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  0348					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  0348					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  0348					      LIST	ON
      0  0348					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  0348				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  0348				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  0348				   TEMPORARY_VAR SET	Overlay
      4  0348				   TEMPORARY_OFFSET SET	0
      5  0348				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0348				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      7  0348					      SUBROUTINE
      3  0348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0360		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0378		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  0390					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  0390					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  0390					      LIST	ON
      0  0390					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  0390				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  0390				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  0390				   TEMPORARY_VAR SET	Overlay
      4  0390				   TEMPORARY_OFFSET SET	0
      5  0390				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0390				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      7  0390					      SUBROUTINE
      3  0390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  03a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  03c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  03d8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  03d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  0400					      LIST	ON
      0  0400					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  0400				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  0400				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  0400				   TEMPORARY_VAR SET	Overlay
      4  0400				   TEMPORARY_OFFSET SET	0
      5  0400				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0400				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      7  0400					      SUBROUTINE
      3  0400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0430		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  0448					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  0448					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  0448					      LIST	ON
      0  0448					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  0448				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  0448				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  0448				   TEMPORARY_VAR SET	Overlay
      4  0448				   TEMPORARY_OFFSET SET	0
      5  0448				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0448				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      7  0448					      SUBROUTINE
      3  0448		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  0460		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  0490					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  0490					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  0490					      LIST	ON
      0  0490					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  0490				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  0490				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  0490				   TEMPORARY_VAR SET	Overlay
      4  0490				   TEMPORARY_OFFSET SET	0
      5  0490				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0490				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      7  0490					      SUBROUTINE
      3  0490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  04a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  04c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  04d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  04d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  0500					      LIST	ON
      0  0500					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  0500				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  0500				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  0500				   TEMPORARY_VAR SET	Overlay
      4  0500				   TEMPORARY_OFFSET SET	0
      5  0500				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0500				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      7  0500					      SUBROUTINE
      3  0500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  0530		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  0548					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  0548					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  0548					      LIST	ON
      0  0548					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  0548				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  0548				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  0548				   TEMPORARY_VAR SET	Overlay
      4  0548				   TEMPORARY_OFFSET SET	0
      5  0548				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0548				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      7  0548					      SUBROUTINE
      3  0548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0578		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE BANK_GENERIC.asm
    394  0590
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  0590					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  0590					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  0590					      LIST	ON
      0  0590					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  0590				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  0590				   WHITE_MARKER_on_BLACK_SQUARE_0
      3  0590				   TEMPORARY_VAR SET	Overlay
      4  0590				   TEMPORARY_OFFSET SET	0
      5  0590				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0590				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      7  0590					      SUBROUTINE
      3  0590		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  05a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  05c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  05d8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  05d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  0600					      LIST	ON
      0  0600					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  0600				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  0600				   WHITE_MARKER_on_BLACK_SQUARE_1
      3  0600				   TEMPORARY_VAR SET	Overlay
      4  0600				   TEMPORARY_OFFSET SET	0
      5  0600				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0600				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      7  0600					      SUBROUTINE
      3  0600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0618		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  0630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  0648					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  0648					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  0648					      LIST	ON
      0  0648					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  0648				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  0648				   WHITE_MARKER_on_BLACK_SQUARE_2
      3  0648				   TEMPORARY_VAR SET	Overlay
      4  0648				   TEMPORARY_OFFSET SET	0
      5  0648				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0648				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      7  0648					      SUBROUTINE
      3  0648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0678		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  0690					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  0690					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  0690					      LIST	ON
      0  0690					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  0690				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  0690				   WHITE_MARKER_on_BLACK_SQUARE_3
      3  0690				   TEMPORARY_VAR SET	Overlay
      4  0690				   TEMPORARY_OFFSET SET	0
      5  0690				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0690				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      7  0690					      SUBROUTINE
      3  0690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  06a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  06c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  06d8					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  06d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  0700					      LIST	ON
      0  0700					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  0700				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  0700				   WHITE_MARKER_on_WHITE_SQUARE_0
      3  0700				   TEMPORARY_VAR SET	Overlay
      4  0700				   TEMPORARY_OFFSET SET	0
      5  0700				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0700				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      7  0700					      SUBROUTINE
      3  0700		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0718		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  0748					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  0748					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  0748					      LIST	ON
      0  0748					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  0748				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  0748				   WHITE_MARKER_on_WHITE_SQUARE_1
      3  0748				   TEMPORARY_VAR SET	Overlay
      4  0748				   TEMPORARY_OFFSET SET	0
      5  0748				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0748				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      7  0748					      SUBROUTINE
      3  0748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0760		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0778		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  0790					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  0790					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  0790					      LIST	ON
      0  0790					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  0790				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  0790				   WHITE_MARKER_on_WHITE_SQUARE_2
      3  0790				   TEMPORARY_VAR SET	Overlay
      4  0790				   TEMPORARY_OFFSET SET	0
      5  0790				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0790				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      7  0790					      SUBROUTINE
      3  0790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  07a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  07c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
    402  07d8
      0  07d8					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  07d8		       07 d8	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $7d8 , FREE= $28
      2  07d8					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  07d8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  07d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  07d8				  -	      ERR
      6  07d8					      endif
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 5
      0  07d8					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  07d8
      0  07d8					      NEWBANK	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      1  0b06 ????				      SEG	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   BANK_ROM_SHADOW_OF_CHESS_BITMAP SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      3  0800
      4  0800							; Template bank for a SINGLE ROW of the chessboard display.
      5  0800							; There are 8x of these.
      6  0800							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
      7  0800							; The bank is copied from ROM into RAM at startup.
      8  0800							; The draw switches between consecutive row banks, with the last returning
      9  0800							; we effectively have 1K
     10  0800							;---------------------------------------------------------------------------------------------------
     11  0800
     12  0800		       00 94	   COLOUR_LINE_1 =	$94
     13  0800		       00 4a	   COLOUR_LINE_2 =	$4a
     14  0800		       00 fa	   COLOUR_LINE_3 =	$fa
     15  0800		       00 00	   BACKGCOL   =	$00
     16  0800
     17  0800							;COLOUR_LINE_1 = $94
     18  0800							;COLOUR_LINE_2 = $48
     19  0800							;COLOUR_LINE_3 = $2C
     20  0800							;BACKGCOL	= $00
     21  0800
     22  0800							;
     23  0800
     24  0800							; good/contrast
     25  0800							;COLOUR_LINE_1 = $a6
     26  0800							;COLOUR_LINE_2 = $4a
     27  0800							;COLOUR_LINE_3 = $2A
     28  0800
     29  0800							;COLOUR_LINE_1 = $94 ; square col
     30  0800							;COLOUR_LINE_2 = $C6
     31  0800							;COLOUR_LINE_3 = $48
     32  0800							;BACKGCOL	= 0 ;$F0
     33  0800
     34  0800
     35  0800							; good 94/46/28/0
     36  0800							; good 94/44/26/0
     37  0800
     38  0800
     39  0800		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     40  0800
     41  0800
      0  0800					      ALLOCATE	ChessBitmap, ROW_BITMAP_SIZE
      0  0800					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0800					      LIST	ON
      0  0800					      DEF	ChessBitmap
      1  0800				   BANK_ChessBitmap SET	_CURRENT_BANK
      2  0800				   ChessBitmap
      3  0800				   TEMPORARY_VAR SET	Overlay
      4  0800				   TEMPORARY_OFFSET SET	0
      5  0800				   VAR_BOUNDARY_ChessBitmap SET	TEMPORARY_OFFSET
      6  0800				   FUNCTION_NAME SET	ChessBitmap
      7  0800					      SUBROUTINE
     43  0800		       00 00 00 00*ChessBitmap0 ds	24
     44  0818		       00 00 00 00*ChessBitmap1 ds	24
     45  0830		       00 00 00 00*ChessBitmap2 ds	24
     46  0848		       00 00 00 00*ChessBitmap3 ds	24
     47  0860		       00 00 00 00*ChessBitmap4 ds	24
     48  0878		       00 00 00 00*ChessBitmap5 ds	24
     49  0890
      0  0890					      ALLOCATE	BlankSprite, 8
      0  0890					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0890					      LIST	ON
      0  0890					      DEF	BlankSprite
      1  0890				   BANK_BlankSprite SET	_CURRENT_BANK
      2  0890				   BlankSprite
      3  0890				   TEMPORARY_VAR SET	Overlay
      4  0890				   TEMPORARY_OFFSET SET	0
      5  0890				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      6  0890				   FUNCTION_NAME SET	BlankSprite
      7  0890					      SUBROUTINE
     51  0890		       00 00 00 00*	      ds	8, 0
     52  0898
      0  0898					      ALLOCATE	SpriteBuffer, 24
      0  0898					      OPTIONAL_PAGEBREAK	"Table", 24
     12  0898					      LIST	ON
      0  0898					      DEF	SpriteBuffer
      1  0898				   BANK_SpriteBuffer SET	_CURRENT_BANK
      2  0898				   SpriteBuffer
      3  0898				   TEMPORARY_VAR SET	Overlay
      4  0898				   TEMPORARY_OFFSET SET	0
      5  0898				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      6  0898				   FUNCTION_NAME SET	SpriteBuffer
      7  0898					      SUBROUTINE
     54  0898				   SpriteBuffer2
     55  0898					      REPEAT	24
     56  0898		       f8		      .byte.b	%11111000
     55  0898					      REPEND
     56  0899		       f8		      .byte.b	%11111000
     55  0899					      REPEND
     56  089a		       f8		      .byte.b	%11111000
     55  089a					      REPEND
     56  089b		       f8		      .byte.b	%11111000
     55  089b					      REPEND
     56  089c		       f8		      .byte.b	%11111000
     55  089c					      REPEND
     56  089d		       f8		      .byte.b	%11111000
     55  089d					      REPEND
     56  089e		       f8		      .byte.b	%11111000
     55  089e					      REPEND
     56  089f		       f8		      .byte.b	%11111000
     55  089f					      REPEND
     56  08a0		       f8		      .byte.b	%11111000
     55  08a0					      REPEND
     56  08a1		       f8		      .byte.b	%11111000
     55  08a1					      REPEND
     56  08a2		       f8		      .byte.b	%11111000
     55  08a2					      REPEND
     56  08a3		       f8		      .byte.b	%11111000
     55  08a3					      REPEND
     56  08a4		       f8		      .byte.b	%11111000
     55  08a4					      REPEND
     56  08a5		       f8		      .byte.b	%11111000
     55  08a5					      REPEND
     56  08a6		       f8		      .byte.b	%11111000
     55  08a6					      REPEND
     56  08a7		       f8		      .byte.b	%11111000
     55  08a7					      REPEND
     56  08a8		       f8		      .byte.b	%11111000
     55  08a8					      REPEND
     56  08a9		       f8		      .byte.b	%11111000
     55  08a9					      REPEND
     56  08aa		       f8		      .byte.b	%11111000
     55  08aa					      REPEND
     56  08ab		       f8		      .byte.b	%11111000
     55  08ab					      REPEND
     56  08ac		       f8		      .byte.b	%11111000
     55  08ac					      REPEND
     56  08ad		       f8		      .byte.b	%11111000
     55  08ad					      REPEND
     56  08ae		       f8		      .byte.b	%11111000
     55  08ae					      REPEND
     56  08af		       f8		      .byte.b	%11111000
     57  08b0					      REPEND
     58  08b0
      0  08b0					      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
      0  08b0					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0900					      LIST	ON
      0  0900					      DEF	BackupBitmap
      1  0900				   BANK_BackupBitmap SET	_CURRENT_BANK
      2  0900				   BackupBitmap
      3  0900				   TEMPORARY_VAR SET	Overlay
      4  0900				   TEMPORARY_OFFSET SET	0
      5  0900				   VAR_BOUNDARY_BackupBitmap SET	TEMPORARY_OFFSET
      6  0900				   FUNCTION_NAME SET	BackupBitmap
      7  0900					      SUBROUTINE
     60  0900		       00 00 00 00*	      ds	ROW_BITMAP_SIZE, 0
     61  0990
     62  0990							;---------------------------------------------------------------------------------------------------
     63  0990
      0  0990					      DEF	ClearRowBitmap
      1  0990				   BANK_ClearRowBitmap SET	_CURRENT_BANK
      2  0990				   ClearRowBitmap
      3  0990				   TEMPORARY_VAR SET	Overlay
      4  0990				   TEMPORARY_OFFSET SET	0
      5  0990				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      6  0990				   FUNCTION_NAME SET	ClearRowBitmap
      7  0990					      SUBROUTINE
     65  0990					      SUBROUTINE
     66  0990
      0  0990					      REFER	CallClear
      1  0990				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  0990				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  0990					      ENDIF
      0  0990					      VEND	ClearRowBitmap
      1  0990				  -	      IFNCONST	ClearRowBitmap
      2  0990				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  0990				  -	      ERR
      4  0990					      ENDIF
      5  0990		       00 a2	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     69  0990
     70  0990							; No transient variable dependencies/calls
     71  0990
     72  0990		       a9 00		      lda	#0
     73  0992		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  0994				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  0994		       99 ff f3 	      sta	[RAM]+ChessBitmap-1,y
     75  0997		       88		      dey
     76  0998		       d0 fa		      bne	.clearRow
     77  099a		       60		      rts
     78  099b
     79  099b
     80  099b							;---------------------------------------------------------------------------------------------------
     81  099b
      0  099b					      DEF	CopyPieceToRowBitmap
      1  099b				   BANK_CopyPieceToRowBitmap SET	_CURRENT_BANK
      2  099b				   CopyPieceToRowBitmap
      3  099b				   TEMPORARY_VAR SET	Overlay
      4  099b				   TEMPORARY_OFFSET SET	0
      5  099b				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      6  099b				   FUNCTION_NAME SET	CopyPieceToRowBitmap
      7  099b					      SUBROUTINE
     83  099b					      SUBROUTINE
     84  099b
      0  099b					      REFER	CopySinglePiece	; special-case due to 'intercept'
      1  099b					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  099b				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  099b					      ENDIF
      0  099b					      VEND	CopyPieceToRowBitmap
      1  099b				  -	      IFNCONST	CopyPieceToRowBitmap
      2  099b				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  099b				  -	      ERR
      4  099b					      ENDIF
      5  099b		       00 ad	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
     87  099b
     88  099b		       a0 11		      ldy	#17
     89  099d		       b0 30		      bcs	.rightSide
     90  099f
     91  099f		       b9 a2 00    .copyPiece lda	__pieceShapeBuffer,y
     92  09a2		       f0 06		      beq	.blank1
     93  09a4		       59 00 f0 	      eor	ChessBitmap,y
      0  09a7					      sta@RAM	ChessBitmap,y
      1  09a7		       99 00 f4 	      sta	[RAM]+ChessBitmap,y
     95  09aa
     96  09aa		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
     97  09ad		       f0 06		      beq	.blank2
     98  09af		       59 12 f0 	      eor	ChessBitmap+18,y
      0  09b2					      sta@RAM	ChessBitmap+18,y
      1  09b2		       99 12 f4 	      sta	[RAM]+ChessBitmap+18,y
    100  09b5
    101  09b5		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
    102  09b8		       f0 06		      beq	.blank3
    103  09ba		       59 24 f0 	      eor	ChessBitmap+36,y
      0  09bd					      sta@RAM	ChessBitmap+36,y
      1  09bd		       99 24 f4 	      sta	[RAM]+ChessBitmap+36,y
    105  09c0
    106  09c0		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
    107  09c3		       f0 06		      beq	.blank4
    108  09c5		       59 36 f0 	      eor	ChessBitmap+54,y
      0  09c8					      sta@RAM	ChessBitmap+54,y
      1  09c8		       99 36 f4 	      sta	[RAM]+ChessBitmap+54,y
    110  09cb
    111  09cb		       88	   .blank4    dey
    112  09cc		       10 d1		      bpl	.copyPiece
    113  09ce		       60		      rts
    114  09cf
    115  09cf				   .rightSide
    116  09cf
    117  09cf					      SUBROUTINE
    118  09cf
    119  09cf		       b9 a2 00    .copyPieceR lda	__pieceShapeBuffer,y
    120  09d2		       f0 06		      beq	.blank1
    121  09d4		       59 48 f0 	      eor	ChessBitmap+72,y
      0  09d7					      sta@RAM	ChessBitmap+72,y
      1  09d7		       99 48 f4 	      sta	[RAM]+ChessBitmap+72,y
    123  09da
    124  09da		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
    125  09dd		       f0 06		      beq	.blank2
    126  09df		       59 5a f0 	      eor	ChessBitmap+72+18,y
      0  09e2					      sta@RAM	ChessBitmap+72+18,y
      1  09e2		       99 5a f4 	      sta	[RAM]+ChessBitmap+72+18,y
    128  09e5
    129  09e5		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
    130  09e8		       f0 06		      beq	.blank3
    131  09ea		       59 6c f0 	      eor	ChessBitmap+72+36,y
      0  09ed					      sta@RAM	ChessBitmap+72+36,y
      1  09ed		       99 6c f4 	      sta	[RAM]+ChessBitmap+72+36,y
    133  09f0
    134  09f0		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
    135  09f3		       f0 06		      beq	.blank4
    136  09f5		       59 7e f0 	      eor	ChessBitmap+72+54,y
      0  09f8					      sta@RAM	ChessBitmap+72+54,y
      1  09f8		       99 7e f4 	      sta	[RAM]+ChessBitmap+72+54,y
    138  09fb
    139  09fb		       88	   .blank4    dey
    140  09fc		       10 d1		      bpl	.copyPieceR
    141  09fe		       60		      rts
    142  09ff
    143  09ff
    144  09ff							;---------------------------------------------------------------------------------------------------
    145  09ff
    146  0a00		       00		      ALIGN	256
    147  0a00					      SUBROUTINE
    148  0a00
      0  0a00					      REFER	Reset
      1  0a00				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0a00				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0a00					      ENDIF
    150  0a00				   __dummy
      0  0a00					      VEND	__dummy
      1  0a00				  -	      IFNCONST	__dummy
      2  0a00				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0a00				  -	      ERR
      4  0a00					      ENDIF
      5  0a00		       00 ad	   VAREND___dummy =	TEMPORARY_VAR
    152  0a00
    153  0a00							; x = row # (and bank#)
    154  0a00
    155  0a00				   .endline
    156  0a00
    157  0a00							;@59
    158  0a00
    159  0a00							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
    160  0a00							; Note that the other 7 row banks are unmodified (keeping the 'inx')
    161  0a00				   SELFMOD_RTS_ON_LAST_ROW
    162  0a00
    163  0a00		       e8		      inx		; 2
    164  0a01		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
    165  0a03
      0  0a03					      DEF	DrawRow
      1  0a03				   BANK_DrawRow SET	_CURRENT_BANK
      2  0a03				   DrawRow
      3  0a03				   TEMPORARY_VAR SET	Overlay
      4  0a03				   TEMPORARY_OFFSET SET	0
      5  0a03				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      6  0a03				   FUNCTION_NAME SET	DrawRow
      7  0a03					      SUBROUTINE
    167  0a03
    168  0a03							;@64
    169  0a03		       a0 07		      ldy	#7	; 2
    170  0a05		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
    171  0a07
    172  0a07							;@58...
    173  0a07
    174  0a07				   .l3
    175  0a07
    176  0a07		       b9 a8 f0    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
    177  0a0a		       85 5b		      sta	GRP0	; 3
    178  0a0c		       b9 a8 f0    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
    179  0a0f		       85 5c		      sta	GRP1	; 3
    180  0a11
    181  0a11							;@-4
    182  0a11
    183  0a11		       a9 94		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    184  0a13		       85 48		      sta	COLUPF	; 3 @1
    185  0a15
    186  0a15		       b9 10 f0 	      lda	ChessBitmap0+16,y	; 4
    187  0a18		       85 4d		      sta	PF0	; 3
    188  0a1a		       b9 28 f0 	      lda	ChessBitmap1+16,y	; 4
    189  0a1d		       85 4e		      sta	PF1	; 3
    190  0a1f		       b9 40 f0 	      lda	ChessBitmap2+16,y	; 4
    191  0a22		       85 4f		      sta	PF2	; 3 @22
    192  0a24
      0  0a24					      SLEEP	6	; 6 @28
      1  0a24				   .CYCLES    SET	6
      2  0a24
      3  0a24				  -	      IF	.CYCLES < 2
      4  0a24				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a24				  -	      ERR
      6  0a24					      ENDIF
      7  0a24
      8  0a24				  -	      IF	.CYCLES & 1
      9  0a24				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a24				  -	      nop	0
     11  0a24				  -	      ELSE
     12  0a24				  -	      bit	VSYNC
     13  0a24				  -	      ENDIF
     14  0a24				  -.CYCLES    SET	.CYCLES - 3
     15  0a24					      ENDIF
     16  0a24
     17  0a24					      REPEAT	.CYCLES / 2
     18  0a24		       ea		      nop
     17  0a24					      REPEND
     18  0a25		       ea		      nop
     17  0a25					      REPEND
     18  0a26		       ea		      nop
     19  0a27					      REPEND
    194  0a27
    195  0a27		       b9 58 f0 	      lda	ChessBitmap3+16,y	; 4
    196  0a2a		       85 4d		      sta	PF0	; 3
    197  0a2c		       b9 70 f0 	      lda	ChessBitmap4+16,y	; 4
    198  0a2f		       85 4e		      sta	PF1	; 3
    199  0a31		       b9 88 f0 	      lda	ChessBitmap5+16,y	; 4
    200  0a34		       8d 4f 00 	      sta.w	PF2	; 4 @50
    201  0a37
      0  0a37					      SLEEP	4	; 4
      1  0a37				   .CYCLES    SET	4
      2  0a37
      3  0a37				  -	      IF	.CYCLES < 2
      4  0a37				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a37				  -	      ERR
      6  0a37					      ENDIF
      7  0a37
      8  0a37				  -	      IF	.CYCLES & 1
      9  0a37				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a37				  -	      nop	0
     11  0a37				  -	      ELSE
     12  0a37				  -	      bit	VSYNC
     13  0a37				  -	      ENDIF
     14  0a37				  -.CYCLES    SET	.CYCLES - 3
     15  0a37					      ENDIF
     16  0a37
     17  0a37					      REPEAT	.CYCLES / 2
     18  0a37		       ea		      nop
     17  0a37					      REPEND
     18  0a38		       ea		      nop
     19  0a39					      REPEND
    203  0a39
    204  0a39		       88		      dey		; 2
    205  0a3a		       30 c4		      bmi	.endline	; 2 (3)
    206  0a3c
    207  0a3c							;@57
    208  0a3c				   .drawLine
    209  0a3c
      0  0a3c					      SLEEP	11
      1  0a3c				   .CYCLES    SET	11
      2  0a3c
      3  0a3c				  -	      IF	.CYCLES < 2
      4  0a3c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a3c				  -	      ERR
      6  0a3c					      ENDIF
      7  0a3c
      8  0a3c					      IF	.CYCLES & 1
      9  0a3c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a3c		       04 00		      nop	0
     11  0a3e				  -	      ELSE
     12  0a3e				  -	      bit	VSYNC
     13  0a3e					      ENDIF
     14  0a3e				   .CYCLES    SET	.CYCLES - 3
     15  0a3e					      ENDIF
     16  0a3e
     17  0a3e					      REPEAT	.CYCLES / 2
     18  0a3e		       ea		      nop
     17  0a3e					      REPEND
     18  0a3f		       ea		      nop
     17  0a3f					      REPEND
     18  0a40		       ea		      nop
     17  0a40					      REPEND
     18  0a41		       ea		      nop
     19  0a42					      REPEND
    211  0a42
    212  0a42				   .dl2
    213  0a42		       b9 98 f0    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    214  0a45		       85 5b		      sta	GRP0	; 3
    215  0a47		       b9 98 f0    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    216  0a4a		       85 5c		      sta	GRP1	; 3
    217  0a4c
    218  0a4c							;@7
    219  0a4c
    220  0a4c		       a9 4a		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    221  0a4e		       85 48		      sta	COLUPF	; 3 @12
    222  0a50
    223  0a50		       b9 00 f0 	      lda	ChessBitmap0,y	; 4
    224  0a53		       85 4d		      sta	PF0	; 3
    225  0a55		       b9 18 f0 	      lda	ChessBitmap1,y	; 4
    226  0a58		       85 4e		      sta	PF1	; 3
    227  0a5a		       b9 30 f0 	      lda	ChessBitmap2,y	; 4
    228  0a5d		       85 4f		      sta	PF2	; 3 @33
    229  0a5f
      0  0a5f					      SLEEP	3	; 3 @36
      1  0a5f				   .CYCLES    SET	3
      2  0a5f
      3  0a5f				  -	      IF	.CYCLES < 2
      4  0a5f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a5f				  -	      ERR
      6  0a5f					      ENDIF
      7  0a5f
      8  0a5f					      IF	.CYCLES & 1
      9  0a5f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a5f		       04 00		      nop	0
     11  0a61				  -	      ELSE
     12  0a61				  -	      bit	VSYNC
     13  0a61					      ENDIF
     14  0a61				   .CYCLES    SET	.CYCLES - 3
     15  0a61					      ENDIF
     16  0a61
     17  0a61				  -	      REPEAT	.CYCLES / 2
     18  0a61				  -	      nop
     19  0a61					      REPEND
    231  0a61
    232  0a61		       b9 48 f0 	      lda	ChessBitmap3,y	; 4
    233  0a64		       85 4d		      sta	PF0	; 3
    234  0a66		       b9 60 f0 	      lda	ChessBitmap4,y	; 4
    235  0a69		       85 4e		      sta	PF1	; 3
    236  0a6b		       b9 78 f0 	      lda	ChessBitmap5,y	; 4
    237  0a6e		       85 4f		      sta	PF2	; 3 @57
    238  0a70
      0  0a70					      SLEEP	5
      1  0a70				   .CYCLES    SET	5
      2  0a70
      3  0a70				  -	      IF	.CYCLES < 2
      4  0a70				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a70				  -	      ERR
      6  0a70					      ENDIF
      7  0a70
      8  0a70					      IF	.CYCLES & 1
      9  0a70					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a70		       04 00		      nop	0
     11  0a72				  -	      ELSE
     12  0a72				  -	      bit	VSYNC
     13  0a72					      ENDIF
     14  0a72				   .CYCLES    SET	.CYCLES - 3
     15  0a72					      ENDIF
     16  0a72
     17  0a72					      REPEAT	.CYCLES / 2
     18  0a72		       ea		      nop
     19  0a73					      REPEND
    240  0a73
    241  0a73		       b9 a0 f0    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    242  0a76		       85 5b		      sta	GRP0	; 3
    243  0a78		       b9 a0 f0    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    244  0a7b		       85 5c		      sta	GRP1	; 3
    245  0a7d
    246  0a7d							;@0
    247  0a7d		       a9 fa		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    248  0a7f		       85 48		      sta	COLUPF	; 3 @5
    249  0a81
    250  0a81		       b9 08 f0 	      lda	ChessBitmap0+8,y	; 4
    251  0a84		       85 4d		      sta	PF0	; 3
    252  0a86		       b9 20 f0 	      lda	ChessBitmap1+8,y	; 4
    253  0a89		       85 4e		      sta	PF1	; 3
    254  0a8b		       b9 38 f0 	      lda	ChessBitmap2+8,y	; 4
    255  0a8e		       85 4f		      sta	PF2	; 3 @26
    256  0a90
      0  0a90					      SLEEP	8	; 6 @34
      1  0a90				   .CYCLES    SET	8
      2  0a90
      3  0a90				  -	      IF	.CYCLES < 2
      4  0a90				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0a90				  -	      ERR
      6  0a90					      ENDIF
      7  0a90
      8  0a90				  -	      IF	.CYCLES & 1
      9  0a90				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0a90				  -	      nop	0
     11  0a90				  -	      ELSE
     12  0a90				  -	      bit	VSYNC
     13  0a90				  -	      ENDIF
     14  0a90				  -.CYCLES    SET	.CYCLES - 3
     15  0a90					      ENDIF
     16  0a90
     17  0a90					      REPEAT	.CYCLES / 2
     18  0a90		       ea		      nop
     17  0a90					      REPEND
     18  0a91		       ea		      nop
     17  0a91					      REPEND
     18  0a92		       ea		      nop
     17  0a92					      REPEND
     18  0a93		       ea		      nop
     19  0a94					      REPEND
    258  0a94
    259  0a94		       b9 50 f0 	      lda	ChessBitmap3+8,y	; 4
    260  0a97		       85 4d		      sta	PF0	; 3
    261  0a99		       b9 68 f0 	      lda	ChessBitmap4+8,y	; 4
    262  0a9c		       85 4e		      sta	PF1	; 3
    263  0a9e		       b9 80 f0 	      lda	ChessBitmap5+8,y	; 4
    264  0aa1		       85 4f		      sta	PF2	; 3 @55
    265  0aa3
    266  0aa3		       4c 07 f2 	      jmp	.l3	; 3 @58
    267  0aa6
    268  0aa6
    269  0aa6							;---------------------------------------------------------------------------------------------------
    270  0aa6
      0  0aa6					      DEF	WriteBlank
      1  0aa6				   BANK_WriteBlank SET	_CURRENT_BANK
      2  0aa6				   WriteBlank
      3  0aa6				   TEMPORARY_VAR SET	Overlay
      4  0aa6				   TEMPORARY_OFFSET SET	0
      5  0aa6				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      6  0aa6				   FUNCTION_NAME SET	WriteBlank
      7  0aa6					      SUBROUTINE
    272  0aa6					      SUBROUTINE
    273  0aa6
      0  0aa6					      REFER	Reset
      1  0aa6				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0aa6				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0aa6					      ENDIF
      0  0aa6					      VEND	WriteBlank
      1  0aa6				  -	      IFNCONST	WriteBlank
      2  0aa6				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  0aa6				  -	      ERR
      4  0aa6					      ENDIF
      5  0aa6		       00 a2	   VAREND_WriteBlank =	TEMPORARY_VAR
    276  0aa6
    277  0aa6		       a9 90		      lda	#<BlankSprite
      0  0aa8					      sta@RAM	SMSPRITE0_0+1
      1  0aa8		       8d 43 f6 	      sta	[RAM]+SMSPRITE0_0+1
      0  0aab					      sta@RAM	SMSPRITE8_0+1
      1  0aab		       8d 74 f6 	      sta	[RAM]+SMSPRITE8_0+1
      0  0aae					      sta@RAM	SMSPRITE16_0+1
      1  0aae		       8d 08 f6 	      sta	[RAM]+SMSPRITE16_0+1
      0  0ab1					      sta@RAM	SMSPRITE0_1+1
      1  0ab1		       8d 48 f6 	      sta	[RAM]+SMSPRITE0_1+1
      0  0ab4					      sta@RAM	SMSPRITE8_1+1
      1  0ab4		       8d 79 f6 	      sta	[RAM]+SMSPRITE8_1+1
      0  0ab7					      sta@RAM	SMSPRITE16_1+1
      1  0ab7		       8d 0d f6 	      sta	[RAM]+SMSPRITE16_1+1
    284  0aba
    285  0aba		       a9 f0		      lda	#>BlankSprite
      0  0abc					      sta@RAM	SMSPRITE0_0+2
      1  0abc		       8d 44 f6 	      sta	[RAM]+SMSPRITE0_0+2
      0  0abf					      sta@RAM	SMSPRITE8_0+2
      1  0abf		       8d 75 f6 	      sta	[RAM]+SMSPRITE8_0+2
      0  0ac2					      sta@RAM	SMSPRITE16_0+2
      1  0ac2		       8d 09 f6 	      sta	[RAM]+SMSPRITE16_0+2
      0  0ac5					      sta@RAM	SMSPRITE0_1+2
      1  0ac5		       8d 49 f6 	      sta	[RAM]+SMSPRITE0_1+2
      0  0ac8					      sta@RAM	SMSPRITE8_1+2
      1  0ac8		       8d 7a f6 	      sta	[RAM]+SMSPRITE8_1+2
      0  0acb					      sta@RAM	SMSPRITE16_1+2
      1  0acb		       8d 0e f6 	      sta	[RAM]+SMSPRITE16_1+2
    292  0ace
    293  0ace		       60		      rts
    294  0acf
    295  0acf
    296  0acf							;---------------------------------------------------------------------------------------------------
    297  0acf
      0  0acf					      DEF	WriteCursor
      1  0acf				   BANK_WriteCursor SET	_CURRENT_BANK
      2  0acf				   WriteCursor
      3  0acf				   TEMPORARY_VAR SET	Overlay
      4  0acf				   TEMPORARY_OFFSET SET	0
      5  0acf				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      6  0acf				   FUNCTION_NAME SET	WriteCursor
      7  0acf					      SUBROUTINE
    299  0acf					      SUBROUTINE
    300  0acf
      0  0acf					      REFER	Reset
      1  0acf				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0acf				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0acf					      ENDIF
      0  0acf					      VEND	WriteCursor
      1  0acf				  -	      IFNCONST	WriteCursor
      2  0acf				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  0acf				  -	      ERR
      4  0acf					      ENDIF
      5  0acf		       00 a2	   VAREND_WriteCursor =	TEMPORARY_VAR
    303  0acf
    304  0acf		       38		      sec
    305  0ad0		       a5 88		      lda	cursorX12
    306  0ad2		       30 1f		      bmi	.exit
    307  0ad4		       a2 0a		      ldx	#10
    308  0ad6		       e9 0a	   .sub10     sbc	#10
    309  0ad8		       ca		      dex
    310  0ad9		       b0 fb		      bcs	.sub10
    311  0adb
    312  0adb		       86 3e		      stx	SET_BANK_RAM
    313  0add		       a9 98		      lda	#<SpriteBuffer
      0  0adf					      sta@RAM	SMSPRITE0_0+1
      1  0adf		       8d 43 f6 	      sta	[RAM]+SMSPRITE0_0+1
      0  0ae2					      sta@RAM	SMSPRITE8_0+1
      1  0ae2		       8d 74 f6 	      sta	[RAM]+SMSPRITE8_0+1
      0  0ae5					      sta@RAM	SMSPRITE16_0+1
      1  0ae5		       8d 08 f6 	      sta	[RAM]+SMSPRITE16_0+1
    317  0ae8		       a9 f0		      lda	#>SpriteBuffer
      0  0aea					      sta@RAM	SMSPRITE0_0+2
      1  0aea		       8d 44 f6 	      sta	[RAM]+SMSPRITE0_0+2
      0  0aed					      sta@RAM	SMSPRITE8_0+2
      1  0aed		       8d 75 f6 	      sta	[RAM]+SMSPRITE8_0+2
      0  0af0					      sta@RAM	SMSPRITE16_0+2
      1  0af0		       8d 09 f6 	      sta	[RAM]+SMSPRITE16_0+2
    321  0af3
    322  0af3		       60	   .exit      rts
    323  0af4
    324  0af4
    325  0af4							;---------------------------------------------------------------------------------------------------
    326  0af4
      0  0af4					      DEF	SaveBitmap
      1  0af4				   BANK_SaveBitmap SET	_CURRENT_BANK
      2  0af4				   SaveBitmap
      3  0af4				   TEMPORARY_VAR SET	Overlay
      4  0af4				   TEMPORARY_OFFSET SET	0
      5  0af4				   VAR_BOUNDARY_SaveBitmap SET	TEMPORARY_OFFSET
      6  0af4				   FUNCTION_NAME SET	SaveBitmap
      7  0af4					      SUBROUTINE
    328  0af4					      SUBROUTINE
    329  0af4
      0  0af4					      REFER	SAFE_BackupBitmaps
      1  0af4				  -	      IF	VAREND_SAFE_BackupBitmaps > TEMPORARY_VAR
      2  0af4				  -TEMPORARY_VAR SET	VAREND_SAFE_BackupBitmaps
      3  0af4					      ENDIF
      0  0af4					      VEND	SaveBitmap
      1  0af4				  -	      IFNCONST	SaveBitmap
      2  0af4				  -	      ECHO	"Incorrect VEND label", SaveBitmap
      3  0af4				  -	      ERR
      4  0af4					      ENDIF
      5  0af4		       00 a2	   VAREND_SaveBitmap =	TEMPORARY_VAR
    332  0af4
    333  0af4		       a0 47		      ldy	#71
    334  0af6		       b9 00 f0    .fromTo    lda	ChessBitmap,y
      0  0af9					      sta@RAM	BackupBitmap,y
      1  0af9		       99 00 f5 	      sta	[RAM]+BackupBitmap,y
    336  0afc		       b9 48 f0 	      lda	ChessBitmap+72,y
      0  0aff					      sta@RAM	BackupBitmap+72,y
      1  0aff		       99 48 f5 	      sta	[RAM]+BackupBitmap+72,y
    338  0b02		       88		      dey
    339  0b03		       10 f1		      bpl	.fromTo
    340  0b05		       60		      rts
    341  0b06
    342  0b06
    343  0b06							;---------------------------------------------------------------------------------------------------
    344  0b06
    345  0b06				  -	      if	0
    346  0b06				  -	      DEF	RestoreBitmap
    347  0b06				  -	      SUBROUTINE
    348  0b06				  -
    349  0b06				  -	      VEND	RestoreBitmap
    350  0b06				  -
    351  0b06				  -	      ldy	#71
    352  0b06				  -.fromTo    lda	BackupBitmap,y
    353  0b06				  -	      sta@RAM	ChessBitmap,y
    354  0b06				  -	      lda	BackupBitmap+72,y
    355  0b06				  -	      sta@RAM	ChessBitmap+72,y
    356  0b06				  -	      dey
    357  0b06				  -	      bpl	.fromTo
    358  0b06				  -	      rts
    359  0b06					      endif
    360  0b06
    361  0b06							;---------------------------------------------------------------------------------------------------
    362  0b06
    363  0b06				  -	      if	0
    364  0b06				  -	      DEF	CopyTextToRowBitmap
    365  0b06				  -	      SUBROUTINE
    366  0b06				  -
    367  0b06				  -	      VEND	CopyTextToRowBitmap
    368  0b06				  -
    369  0b06				  -			; An OR-draw, used for placing matricies/text onscreen
    370  0b06				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    371  0b06				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    372  0b06				  -			; in original state once text disappears
    373  0b06				  -
    374  0b06				  -	      ldy	#71
    375  0b06				  -	      bcs	.rightSide
    376  0b06				  -
    377  0b06				  -.copy      lda	__pieceShapeBuffer,y
    378  0b06				  -	      ora	ChessBitmap,y
    379  0b06				  -	      sta@RAM	ChessBitmap,y
    380  0b06				  -	      dey
    381  0b06				  -	      bpl	.copy
    382  0b06				  -
    383  0b06				  -	      rts
    384  0b06				  -
    385  0b06				  -.rightSide
    386  0b06				  -
    387  0b06				  -	      SUBROUTINE
    388  0b06				  -
    389  0b06				  -.copy      lda	__pieceShapeBuffer,y
    390  0b06				  -	      ora	ChessBitmap+72,y
    391  0b06				  -	      sta@RAM	ChessBitmap+72,y
    392  0b06				  -	      dey
    393  0b06				  -	      bpl	.copy
    394  0b06				  -
    395  0b06				  -	      rts
    396  0b06				  -
    397  0b06					      endif
    398  0b06
    399  0b06							;---------------------------------------------------------------------------------------------------
    400  0b06
      0  0b06					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  0b06
      2  0b06
      3  0b06		       03 06	   .TEMP      =	* - BANK_START
 ROM_SHADOW_SCREEN (1K) SIZE =  $306 , FREE= $fa
      4  0b06					      ECHO	"ROM_SHADOW_SCREEN", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0b06				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0b06				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0b06				  -	      ERR
      8  0b06					      endif
    402  0b06							;VALIDATE_RAM_SIZE
------- FILE ./chess.asm
------- FILE BANK_CHESS_INCLUDES.asm LEVEL 2 PASS 5
      0  0b06					      include	"BANK_CHESS_INCLUDES.asm"
      1  0b06							; Copyright (c) 2019-2020 Andrew Davie
      2  0b06							; andrew@taswegian.com
      3  0b06
      4  0b06
      5  0b06							; Each piece is defined as 3 PF bytes (horizontal) x 24 scanlines (vertical)
      6  0b06							; The pieces are converted by ConvertChessPieces.py (in tools), which takes
      7  0b06							; a single gif of the format..
      8  0b06							; a row of white pieces on black squares
      9  0b06							; a row of white pieces on white squares
     10  0b06							; a row of black pieces on black squares
     11  0b06							; a row of black pieces on white squares
     12  0b06
     13  0b06							; each row has the pieces ordered thus:
     14  0b06							; a blank, then pawn, knight, bishop, rook, queen, king
     15  0b06							; each piece is 5 pixels wide x 8 pixels deep
     16  0b06							; each pixel is from an 8-colour palette.
     17  0b06							; Given a pixel colour 0-7 (represented in binary 000 - 111) then if the bits
     18  0b06							; for the colour are abc (i.e., colour #3 = binary 011 = bits 0bc)
     19  0b06							; then bit "a" becomes the first interleaved chronocolour pixel (line 1)
     20  0b06							; bit "b" becomes the second ICC pixel line (2)
     21  0b06							; bit "c" becomes the third ICC pixel line (3)
     22  0b06							; Thus, a 5 pxel x 8 pixel shape becomes 24 lines deep
     23  0b06							; The tool produces 4 variants of the piece; shifted into the 4 squares
     24  0b06							; in the PF - thus, at pixel 0, pixel 5, pixel 10, pixel 15.
     25  0b06							; These 4 shifted positions are stored consecutively in the shape definition
     26  0b06
     27  0b06							; Example...
     28  0b06							;DEF WHITE_BISHOP_on_BLACK_SQUARE_0
     29  0b06							;.byte $00,$40,$40,$40,$00,$00,$e0,$e0,$e0,$d0,$d0,$d0,$b0,$b0,$b0,$f0,$f0,$f0,$e0,$60,$e0,$f0,$f0,$f0 ;PF0
     30  0b06							;.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$80,$80,$00,$80,$80,$00,$80,$00,$00,$00,$00,$80,$00 ;PF1
     31  0b06							;.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00 ;PF2
     32  0b06
     33  0b06							; The above defines the three 24-byte vertical strips for the 3 PF bytes that
     34  0b06							; the piece (could) overlay. In this case, on square 0 (leftmost), it doesn't
     35  0b06							; actually have any data in PF1 or PF2.
     36  0b06
------- FILE piece_graphics.asm LEVEL 3 PASS 5
      0  0b06					      include	"piece_graphics.asm"
      1  0b06							; Import the graphics definitions generated by ConvertChessPieces.py
      0  0b06					      NEWBANK	PIECES_0
      1  17d8 ????				      SEG	PIECES_0
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   PIECES_0   SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	PIECES_0
      3  1000
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1000					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  1000					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  1000					      LIST	ON
      0  1000					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  1000				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1000				   WHITE_BLANK_on_WHITE_SQUARE_0
      3  1000				   TEMPORARY_VAR SET	Overlay
      4  1000				   TEMPORARY_OFFSET SET	0
      5  1000				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1000				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      7  1000					      SUBROUTINE
      3  1000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  1018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  1030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1048					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  1048					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  1048					      LIST	ON
      0  1048					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  1048				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1048				   WHITE_BLANK_on_WHITE_SQUARE_1
      3  1048				   TEMPORARY_VAR SET	Overlay
      4  1048				   TEMPORARY_OFFSET SET	0
      5  1048				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1048				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      7  1048					      SUBROUTINE
      3  1048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  1078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1090					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  1090					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  1090					      LIST	ON
      0  1090					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  1090				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1090				   WHITE_BLANK_on_WHITE_SQUARE_2
      3  1090				   TEMPORARY_VAR SET	Overlay
      4  1090				   TEMPORARY_OFFSET SET	0
      5  1090				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1090				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      7  1090					      SUBROUTINE
      3  1090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  10a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  10c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  10d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  10d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  1100					      LIST	ON
      0  1100					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  1100				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1100				   WHITE_BLANK_on_WHITE_SQUARE_3
      3  1100				   TEMPORARY_VAR SET	Overlay
      4  1100				   TEMPORARY_OFFSET SET	0
      5  1100				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1100				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      7  1100					      SUBROUTINE
      3  1100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1148					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  1148					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  1148					      LIST	ON
      0  1148					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  1148				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1148				   WHITE_PAWN_on_WHITE_SQUARE_0
      3  1148				   TEMPORARY_VAR SET	Overlay
      4  1148				   TEMPORARY_OFFSET SET	0
      5  1148				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1148				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      7  1148					      SUBROUTINE
      3  1148		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1190					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  1190					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  1190					      LIST	ON
      0  1190					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  1190				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1190				   WHITE_PAWN_on_WHITE_SQUARE_1
      3  1190				   TEMPORARY_VAR SET	Overlay
      4  1190				   TEMPORARY_OFFSET SET	0
      5  1190				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1190				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      7  1190					      SUBROUTINE
      3  1190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  11a8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  11c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  11d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  11d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  1200					      LIST	ON
      0  1200					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  1200				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1200				   WHITE_PAWN_on_WHITE_SQUARE_2
      3  1200				   TEMPORARY_VAR SET	Overlay
      4  1200				   TEMPORARY_OFFSET SET	0
      5  1200				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1200				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      7  1200					      SUBROUTINE
      3  1200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1218		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1230		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1248					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  1248					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  1248					      LIST	ON
      0  1248					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  1248				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1248				   WHITE_PAWN_on_WHITE_SQUARE_3
      3  1248				   TEMPORARY_VAR SET	Overlay
      4  1248				   TEMPORARY_OFFSET SET	0
      5  1248				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1248				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      7  1248					      SUBROUTINE
      3  1248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1278		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1290					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  1290					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  1290					      LIST	ON
      0  1290					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  1290				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1290				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  1290				   TEMPORARY_VAR SET	Overlay
      4  1290				   TEMPORARY_OFFSET SET	0
      5  1290				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1290				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      7  1290					      SUBROUTINE
      3  1290		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  12a8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  12c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  12d8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  12d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  1300					      LIST	ON
      0  1300					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  1300				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1300				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  1300				   TEMPORARY_VAR SET	Overlay
      4  1300				   TEMPORARY_OFFSET SET	0
      5  1300				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1300				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      7  1300					      SUBROUTINE
      3  1300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1318		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1348					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  1348					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  1348					      LIST	ON
      0  1348					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  1348				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1348				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  1348				   TEMPORARY_VAR SET	Overlay
      4  1348				   TEMPORARY_OFFSET SET	0
      5  1348				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1348				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      7  1348					      SUBROUTINE
      3  1348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1360		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1378		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1390					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  1390					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  1390					      LIST	ON
      0  1390					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  1390				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1390				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  1390				   TEMPORARY_VAR SET	Overlay
      4  1390				   TEMPORARY_OFFSET SET	0
      5  1390				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1390				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      7  1390					      SUBROUTINE
      3  1390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  13a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  13c0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  13d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  13d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  1400					      LIST	ON
      0  1400					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  1400				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1400				   WHITE_BISHOP_on_WHITE_SQUARE_0
      3  1400				   TEMPORARY_VAR SET	Overlay
      4  1400				   TEMPORARY_OFFSET SET	0
      5  1400				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1400				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      7  1400					      SUBROUTINE
      3  1400		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  1418		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1448					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  1448					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  1448					      LIST	ON
      0  1448					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  1448				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1448				   WHITE_BISHOP_on_WHITE_SQUARE_1
      3  1448				   TEMPORARY_VAR SET	Overlay
      4  1448				   TEMPORARY_OFFSET SET	0
      5  1448				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1448				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      7  1448					      SUBROUTINE
      3  1448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1460		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  1478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1490					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  1490					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  1490					      LIST	ON
      0  1490					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  1490				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1490				   WHITE_BISHOP_on_WHITE_SQUARE_2
      3  1490				   TEMPORARY_VAR SET	Overlay
      4  1490				   TEMPORARY_OFFSET SET	0
      5  1490				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1490				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      7  1490					      SUBROUTINE
      3  1490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  14a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  14c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  14d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  14d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  1500					      LIST	ON
      0  1500					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  1500				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1500				   WHITE_BISHOP_on_WHITE_SQUARE_3
      3  1500				   TEMPORARY_VAR SET	Overlay
      4  1500				   TEMPORARY_OFFSET SET	0
      5  1500				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1500				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      7  1500					      SUBROUTINE
      3  1500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1530		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1548					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  1548					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  1548					      LIST	ON
      0  1548					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  1548				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1548				   WHITE_ROOK_on_WHITE_SQUARE_0
      3  1548				   TEMPORARY_VAR SET	Overlay
      4  1548				   TEMPORARY_OFFSET SET	0
      5  1548				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1548				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      7  1548					      SUBROUTINE
      3  1548		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1560		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1590					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  1590					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  1590					      LIST	ON
      0  1590					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  1590				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1590				   WHITE_ROOK_on_WHITE_SQUARE_1
      3  1590				   TEMPORARY_VAR SET	Overlay
      4  1590				   TEMPORARY_OFFSET SET	0
      5  1590				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1590				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      7  1590					      SUBROUTINE
      3  1590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  15a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  15c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  15d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  15d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  1600					      LIST	ON
      0  1600					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  1600				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1600				   WHITE_ROOK_on_WHITE_SQUARE_2
      3  1600				   TEMPORARY_VAR SET	Overlay
      4  1600				   TEMPORARY_OFFSET SET	0
      5  1600				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1600				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      7  1600					      SUBROUTINE
      3  1600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1618		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1630		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1648					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  1648					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  1648					      LIST	ON
      0  1648					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  1648				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1648				   WHITE_ROOK_on_WHITE_SQUARE_3
      3  1648				   TEMPORARY_VAR SET	Overlay
      4  1648				   TEMPORARY_OFFSET SET	0
      5  1648				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1648				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      7  1648					      SUBROUTINE
      3  1648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1678		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1690					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  1690					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  1690					      LIST	ON
      0  1690					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  1690				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1690				   WHITE_QUEEN_on_WHITE_SQUARE_0
      3  1690				   TEMPORARY_VAR SET	Overlay
      4  1690				   TEMPORARY_OFFSET SET	0
      5  1690				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1690				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      7  1690					      SUBROUTINE
      3  1690		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  16a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  16c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  16d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  16d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  1700					      LIST	ON
      0  1700					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  1700				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1700				   WHITE_QUEEN_on_WHITE_SQUARE_1
      3  1700				   TEMPORARY_VAR SET	Overlay
      4  1700				   TEMPORARY_OFFSET SET	0
      5  1700				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1700				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      7  1700					      SUBROUTINE
      3  1700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1718		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1748					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  1748					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  1748					      LIST	ON
      0  1748					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  1748				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1748				   WHITE_QUEEN_on_WHITE_SQUARE_2
      3  1748				   TEMPORARY_VAR SET	Overlay
      4  1748				   TEMPORARY_OFFSET SET	0
      5  1748				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1748				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      7  1748					      SUBROUTINE
      3  1748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1760		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1778		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1790					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  1790					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  1790					      LIST	ON
      0  1790					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  1790				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1790				   WHITE_QUEEN_on_WHITE_SQUARE_3
      3  1790				   TEMPORARY_VAR SET	Overlay
      4  1790				   TEMPORARY_OFFSET SET	0
      5  1790				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1790				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      7  1790					      SUBROUTINE
      3  1790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  17a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  17c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  17d8					      CHECK_BANK_SIZE	"PIECE_0 (2K)"
      1  17d8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_0 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  17d8					      ECHO	"PIECE_0 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  17d8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  17d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  17d8				  -	      ERR
      6  17d8					      endif
      0  17d8					      NEWBANK	PIECES_1
      1  1fd8 ????				      SEG	PIECES_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   PIECES_1   SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	PIECES_1
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1800					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  1800					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  1800					      LIST	ON
      0  1800					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  1800				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1800				   WHITE_KING_on_WHITE_SQUARE_0
      3  1800				   TEMPORARY_VAR SET	Overlay
      4  1800				   TEMPORARY_OFFSET SET	0
      5  1800				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1800				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      7  1800					      SUBROUTINE
      3  1800		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$a0,$80,$40,$00,$00	;PF0
      4  1818		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1848					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  1848					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  1848					      LIST	ON
      0  1848					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  1848				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1848				   WHITE_KING_on_WHITE_SQUARE_1
      3  1848				   TEMPORARY_VAR SET	Overlay
      4  1848				   TEMPORARY_OFFSET SET	0
      5  1848				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1848				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      7  1848					      SUBROUTINE
      3  1848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1860		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$28,$08,$10,$00,$00	;PF1
      5  1878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1890					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  1890					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  1890					      LIST	ON
      0  1890					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  1890				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1890				   WHITE_KING_on_WHITE_SQUARE_2
      3  1890				   TEMPORARY_VAR SET	Overlay
      4  1890				   TEMPORARY_OFFSET SET	0
      5  1890				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1890				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      7  1890					      SUBROUTINE
      3  1890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  18a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$01,$00,$00,$00,$00	;PF1
      5  18c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$02,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  18d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  18d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  1900					      LIST	ON
      0  1900					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  1900				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1900				   WHITE_KING_on_WHITE_SQUARE_3
      3  1900				   TEMPORARY_VAR SET	Overlay
      4  1900				   TEMPORARY_OFFSET SET	0
      5  1900				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1900				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      7  1900					      SUBROUTINE
      3  1900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1930		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$50,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1948					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  1948					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  1948					      LIST	ON
      0  1948					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  1948				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1948				   WHITE_BLANK_on_BLACK_SQUARE_0
      3  1948				   TEMPORARY_VAR SET	Overlay
      4  1948				   TEMPORARY_OFFSET SET	0
      5  1948				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1948				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      7  1948					      SUBROUTINE
      3  1948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1990					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  1990					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  1990					      LIST	ON
      0  1990					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  1990				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1990				   WHITE_BLANK_on_BLACK_SQUARE_1
      3  1990				   TEMPORARY_VAR SET	Overlay
      4  1990				   TEMPORARY_OFFSET SET	0
      5  1990				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1990				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      7  1990					      SUBROUTINE
      3  1990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  19a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  19c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  19d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  19d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  1a00					      LIST	ON
      0  1a00					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  1a00				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1a00				   WHITE_BLANK_on_BLACK_SQUARE_2
      3  1a00				   TEMPORARY_VAR SET	Overlay
      4  1a00				   TEMPORARY_OFFSET SET	0
      5  1a00				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1a00				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      7  1a00					      SUBROUTINE
      3  1a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1a48					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  1a48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  1a48					      LIST	ON
      0  1a48					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  1a48				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1a48				   WHITE_BLANK_on_BLACK_SQUARE_3
      3  1a48				   TEMPORARY_VAR SET	Overlay
      4  1a48				   TEMPORARY_OFFSET SET	0
      5  1a48				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1a48				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      7  1a48					      SUBROUTINE
      3  1a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1a90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  1a90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  1a90					      LIST	ON
      0  1a90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  1a90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1a90				   WHITE_PAWN_on_BLACK_SQUARE_0
      3  1a90				   TEMPORARY_VAR SET	Overlay
      4  1a90				   TEMPORARY_OFFSET SET	0
      5  1a90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1a90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      7  1a90					      SUBROUTINE
      3  1a90		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  1aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1ad8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  1ad8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  1b00					      LIST	ON
      0  1b00					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  1b00				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1b00				   WHITE_PAWN_on_BLACK_SQUARE_1
      3  1b00				   TEMPORARY_VAR SET	Overlay
      4  1b00				   TEMPORARY_OFFSET SET	0
      5  1b00				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1b00				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      7  1b00					      SUBROUTINE
      3  1b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b18		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  1b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  1b48					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  1b48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  1b48					      LIST	ON
      0  1b48					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  1b48				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1b48				   WHITE_PAWN_on_BLACK_SQUARE_2
      3  1b48				   TEMPORARY_VAR SET	Overlay
      4  1b48				   TEMPORARY_OFFSET SET	0
      5  1b48				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1b48				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      7  1b48					      SUBROUTINE
      3  1b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  1b78		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1b90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  1b90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  1b90					      LIST	ON
      0  1b90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  1b90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1b90				   WHITE_PAWN_on_BLACK_SQUARE_3
      3  1b90				   TEMPORARY_VAR SET	Overlay
      4  1b90				   TEMPORARY_OFFSET SET	0
      5  1b90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1b90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      7  1b90					      SUBROUTINE
      3  1b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1bc0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1bd8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  1bd8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  1c00					      LIST	ON
      0  1c00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  1c00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1c00				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  1c00				   TEMPORARY_VAR SET	Overlay
      4  1c00				   TEMPORARY_OFFSET SET	0
      5  1c00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1c00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      7  1c00					      SUBROUTINE
      3  1c00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  1c18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  1c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1c48					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  1c48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  1c48					      LIST	ON
      0  1c48					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  1c48				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1c48				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  1c48				   TEMPORARY_VAR SET	Overlay
      4  1c48				   TEMPORARY_OFFSET SET	0
      5  1c48				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1c48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      7  1c48					      SUBROUTINE
      3  1c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1c60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  1c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  1c90					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  1c90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  1c90					      LIST	ON
      0  1c90					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  1c90				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1c90				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  1c90				   TEMPORARY_VAR SET	Overlay
      4  1c90				   TEMPORARY_OFFSET SET	0
      5  1c90				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1c90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      7  1c90					      SUBROUTINE
      3  1c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ca8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  1cc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1cd8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  1cd8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  1d00					      LIST	ON
      0  1d00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  1d00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1d00				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  1d00				   TEMPORARY_VAR SET	Overlay
      4  1d00				   TEMPORARY_OFFSET SET	0
      5  1d00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1d00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      7  1d00					      SUBROUTINE
      3  1d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1d30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1d48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  1d48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  1d48					      LIST	ON
      0  1d48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  1d48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1d48				   WHITE_BISHOP_on_BLACK_SQUARE_0
      3  1d48				   TEMPORARY_VAR SET	Overlay
      4  1d48				   TEMPORARY_OFFSET SET	0
      5  1d48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1d48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      7  1d48					      SUBROUTINE
      3  1d48		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  1d60		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  1d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1d90					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  1d90					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  1d90					      LIST	ON
      0  1d90					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  1d90				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1d90				   WHITE_BISHOP_on_BLACK_SQUARE_1
      3  1d90				   TEMPORARY_VAR SET	Overlay
      4  1d90				   TEMPORARY_OFFSET SET	0
      5  1d90				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1d90				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      7  1d90					      SUBROUTINE
      3  1d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1da8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  1dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  1dd8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  1dd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  1e00					      LIST	ON
      0  1e00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  1e00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1e00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      3  1e00				   TEMPORARY_VAR SET	Overlay
      4  1e00				   TEMPORARY_OFFSET SET	0
      5  1e00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1e00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      7  1e00					      SUBROUTINE
      3  1e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  1e30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1e48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  1e48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  1e48					      LIST	ON
      0  1e48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  1e48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1e48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      3  1e48				   TEMPORARY_VAR SET	Overlay
      4  1e48				   TEMPORARY_OFFSET SET	0
      5  1e48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1e48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      7  1e48					      SUBROUTINE
      3  1e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1e78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  1e90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  1e90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  1e90					      LIST	ON
      0  1e90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  1e90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  1e90				   WHITE_ROOK_on_BLACK_SQUARE_0
      3  1e90				   TEMPORARY_VAR SET	Overlay
      4  1e90				   TEMPORARY_OFFSET SET	0
      5  1e90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1e90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      7  1e90					      SUBROUTINE
      3  1e90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  1ea8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  1ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  1ed8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  1ed8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  1f00					      LIST	ON
      0  1f00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  1f00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  1f00				   WHITE_ROOK_on_BLACK_SQUARE_1
      3  1f00				   TEMPORARY_VAR SET	Overlay
      4  1f00				   TEMPORARY_OFFSET SET	0
      5  1f00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1f00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      7  1f00					      SUBROUTINE
      3  1f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  1f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  1f48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  1f48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  1f48					      LIST	ON
      0  1f48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  1f48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  1f48				   WHITE_ROOK_on_BLACK_SQUARE_2
      3  1f48				   TEMPORARY_VAR SET	Overlay
      4  1f48				   TEMPORARY_OFFSET SET	0
      5  1f48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1f48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      7  1f48					      SUBROUTINE
      3  1f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  1f78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  1f90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  1f90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  1f90					      LIST	ON
      0  1f90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  1f90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  1f90				   WHITE_ROOK_on_BLACK_SQUARE_3
      3  1f90				   TEMPORARY_VAR SET	Overlay
      4  1f90				   TEMPORARY_OFFSET SET	0
      5  1f90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1f90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      7  1f90					      SUBROUTINE
      3  1f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1fc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  1fd8					      CHECK_BANK_SIZE	"PIECE_1 (2K)"
      1  1fd8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_1 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  1fd8					      ECHO	"PIECE_1 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1fd8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1fd8				  -	      ERR
      6  1fd8					      endif
      0  1fd8					      NEWBANK	PIECES_2
      1  27d8 ????				      SEG	PIECES_2
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   PIECES_2   SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	PIECES_2
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2000					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  2000					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  2000					      LIST	ON
      0  2000					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  2000				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2000				   WHITE_QUEEN_on_BLACK_SQUARE_0
      3  2000				   TEMPORARY_VAR SET	Overlay
      4  2000				   TEMPORARY_OFFSET SET	0
      5  2000				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2000				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      7  2000					      SUBROUTINE
      3  2000		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  2018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  2030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2048					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  2048					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  2048					      LIST	ON
      0  2048					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  2048				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2048				   WHITE_QUEEN_on_BLACK_SQUARE_1
      3  2048				   TEMPORARY_VAR SET	Overlay
      4  2048				   TEMPORARY_OFFSET SET	0
      5  2048				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2048				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      7  2048					      SUBROUTINE
      3  2048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2060		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  2078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2090					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  2090					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  2090					      LIST	ON
      0  2090					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  2090				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2090				   WHITE_QUEEN_on_BLACK_SQUARE_2
      3  2090				   TEMPORARY_VAR SET	Overlay
      4  2090				   TEMPORARY_OFFSET SET	0
      5  2090				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2090				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      7  2090					      SUBROUTINE
      3  2090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  20a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  20c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  20d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  20d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  2100					      LIST	ON
      0  2100					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  2100				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2100				   WHITE_QUEEN_on_BLACK_SQUARE_3
      3  2100				   TEMPORARY_VAR SET	Overlay
      4  2100				   TEMPORARY_OFFSET SET	0
      5  2100				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2100				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      7  2100					      SUBROUTINE
      3  2100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2130		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2148					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  2148					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  2148					      LIST	ON
      0  2148					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  2148				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2148				   WHITE_KING_on_BLACK_SQUARE_0
      3  2148				   TEMPORARY_VAR SET	Overlay
      4  2148				   TEMPORARY_OFFSET SET	0
      5  2148				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2148				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      7  2148					      SUBROUTINE
      3  2148		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$f0,$50,$70,$b0,$e0,$40	;PF0
      4  2160		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$00,$00	;PF1
      5  2178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2190					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  2190					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  2190					      LIST	ON
      0  2190					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  2190				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2190				   WHITE_KING_on_BLACK_SQUARE_1
      3  2190				   TEMPORARY_VAR SET	Overlay
      4  2190				   TEMPORARY_OFFSET SET	0
      5  2190				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2190				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      7  2190					      SUBROUTINE
      3  2190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  21a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$7c,$54,$74,$6c,$38,$10	;PF1
      5  21c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  21d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  21d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  2200					      LIST	ON
      0  2200					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  2200				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2200				   WHITE_KING_on_BLACK_SQUARE_2
      3  2200				   TEMPORARY_VAR SET	Overlay
      4  2200				   TEMPORARY_OFFSET SET	0
      5  2200				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2200				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      7  2200					      SUBROUTINE
      3  2200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2218		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$03,$02,$03,$03,$01,$00	;PF1
      5  2230		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$07,$05,$05,$06,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2248					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  2248					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  2248					      LIST	ON
      0  2248					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  2248				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2248				   WHITE_KING_on_BLACK_SQUARE_3
      3  2248				   TEMPORARY_VAR SET	Overlay
      4  2248				   TEMPORARY_OFFSET SET	0
      5  2248				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2248				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      7  2248					      SUBROUTINE
      3  2248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2278		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$f8,$a8,$b8,$d8,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2290					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  2290					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  2290					      LIST	ON
      0  2290					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  2290				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2290				   BLACK_BLANK_on_WHITE_SQUARE_0
      3  2290				   TEMPORARY_VAR SET	Overlay
      4  2290				   TEMPORARY_OFFSET SET	0
      5  2290				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2290				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      7  2290					      SUBROUTINE
      3  2290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  22a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  22c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  22d8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  22d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  2300					      LIST	ON
      0  2300					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  2300				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2300				   BLACK_BLANK_on_WHITE_SQUARE_1
      3  2300				   TEMPORARY_VAR SET	Overlay
      4  2300				   TEMPORARY_OFFSET SET	0
      5  2300				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2300				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      7  2300					      SUBROUTINE
      3  2300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2318		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2348					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  2348					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  2348					      LIST	ON
      0  2348					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  2348				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2348				   BLACK_BLANK_on_WHITE_SQUARE_2
      3  2348				   TEMPORARY_VAR SET	Overlay
      4  2348				   TEMPORARY_OFFSET SET	0
      5  2348				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2348				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      7  2348					      SUBROUTINE
      3  2348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  2378		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2390					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  2390					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  2390					      LIST	ON
      0  2390					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  2390				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2390				   BLACK_BLANK_on_WHITE_SQUARE_3
      3  2390				   TEMPORARY_VAR SET	Overlay
      4  2390				   TEMPORARY_OFFSET SET	0
      5  2390				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2390				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      7  2390					      SUBROUTINE
      3  2390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  23a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  23c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  23d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  23d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  2400					      LIST	ON
      0  2400					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  2400				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2400				   BLACK_PAWN_on_WHITE_SQUARE_0
      3  2400				   TEMPORARY_VAR SET	Overlay
      4  2400				   TEMPORARY_OFFSET SET	0
      5  2400				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2400				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      7  2400					      SUBROUTINE
      3  2400		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$00,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  2418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2448					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  2448					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  2448					      LIST	ON
      0  2448					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  2448				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2448				   BLACK_PAWN_on_WHITE_SQUARE_1
      3  2448				   TEMPORARY_VAR SET	Overlay
      4  2448				   TEMPORARY_OFFSET SET	0
      5  2448				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2448				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      7  2448					      SUBROUTINE
      3  2448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2460		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$00,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2490					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  2490					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  2490					      LIST	ON
      0  2490					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  2490				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2490				   BLACK_PAWN_on_WHITE_SQUARE_2
      3  2490				   TEMPORARY_VAR SET	Overlay
      4  2490				   TEMPORARY_OFFSET SET	0
      5  2490				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2490				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      7  2490					      SUBROUTINE
      3  2490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  24a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  24c0		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$00,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  24d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  24d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  2500					      LIST	ON
      0  2500					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  2500				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2500				   BLACK_PAWN_on_WHITE_SQUARE_3
      3  2500				   TEMPORARY_VAR SET	Overlay
      4  2500				   TEMPORARY_OFFSET SET	0
      5  2500				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2500				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      7  2500					      SUBROUTINE
      3  2500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2530		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$00,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2548					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2548					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2548					      LIST	ON
      0  2548					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  2548				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2548				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  2548				   TEMPORARY_VAR SET	Overlay
      4  2548				   TEMPORARY_OFFSET SET	0
      5  2548				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2548				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      7  2548					      SUBROUTINE
      3  2548		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  2560		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2590					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  2590					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2590					      LIST	ON
      0  2590					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  2590				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2590				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  2590				   TEMPORARY_VAR SET	Overlay
      4  2590				   TEMPORARY_OFFSET SET	0
      5  2590				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2590				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      7  2590					      SUBROUTINE
      3  2590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  25a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  25c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  25d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  25d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2600					      LIST	ON
      0  2600					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  2600				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2600				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  2600				   TEMPORARY_VAR SET	Overlay
      4  2600				   TEMPORARY_OFFSET SET	0
      5  2600				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2600				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      7  2600					      SUBROUTINE
      3  2600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2618		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  2630		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2648					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2648					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2648					      LIST	ON
      0  2648					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  2648				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2648				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  2648				   TEMPORARY_VAR SET	Overlay
      4  2648				   TEMPORARY_OFFSET SET	0
      5  2648				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2648				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      7  2648					      SUBROUTINE
      3  2648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2678		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2690					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2690					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  2690					      LIST	ON
      0  2690					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  2690				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2690				   BLACK_BISHOP_on_WHITE_SQUARE_0
      3  2690				   TEMPORARY_VAR SET	Overlay
      4  2690				   TEMPORARY_OFFSET SET	0
      5  2690				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2690				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      7  2690					      SUBROUTINE
      3  2690		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  26a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  26c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  26d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  26d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  2700					      LIST	ON
      0  2700					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  2700				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2700				   BLACK_BISHOP_on_WHITE_SQUARE_1
      3  2700				   TEMPORARY_VAR SET	Overlay
      4  2700				   TEMPORARY_OFFSET SET	0
      5  2700				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2700				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      7  2700					      SUBROUTINE
      3  2700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2718		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  2730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2748					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2748					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  2748					      LIST	ON
      0  2748					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  2748				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2748				   BLACK_BISHOP_on_WHITE_SQUARE_2
      3  2748				   TEMPORARY_VAR SET	Overlay
      4  2748				   TEMPORARY_OFFSET SET	0
      5  2748				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2748				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      7  2748					      SUBROUTINE
      3  2748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2760		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  2778		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2790					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  2790					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  2790					      LIST	ON
      0  2790					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  2790				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2790				   BLACK_BISHOP_on_WHITE_SQUARE_3
      3  2790				   TEMPORARY_VAR SET	Overlay
      4  2790				   TEMPORARY_OFFSET SET	0
      5  2790				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2790				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      7  2790					      SUBROUTINE
      3  2790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  27a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  27c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  27d8					      CHECK_BANK_SIZE	"PIECE_2 (2K)"
      1  27d8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_2 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  27d8					      ECHO	"PIECE_2 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27d8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27d8				  -	      ERR
      6  27d8					      endif
      0  27d8					      NEWBANK	PIECES_3
      1  2fd8 ????				      SEG	PIECES_3
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   PIECES_3   SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	PIECES_3
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2800					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  2800				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2800				   BLACK_ROOK_on_WHITE_SQUARE_0
      3  2800				   TEMPORARY_VAR SET	Overlay
      4  2800				   TEMPORARY_OFFSET SET	0
      5  2800				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2800				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      7  2800					      SUBROUTINE
      3  2800		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  2818		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2848					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  2848				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2848				   BLACK_ROOK_on_WHITE_SQUARE_1
      3  2848				   TEMPORARY_VAR SET	Overlay
      4  2848				   TEMPORARY_OFFSET SET	0
      5  2848				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2848				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      7  2848					      SUBROUTINE
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2890					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  2890				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2890				   BLACK_ROOK_on_WHITE_SQUARE_2
      3  2890				   TEMPORARY_VAR SET	Overlay
      4  2890				   TEMPORARY_OFFSET SET	0
      5  2890				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2890				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      7  2890					      SUBROUTINE
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  28c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  28d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  2900				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2900				   BLACK_ROOK_on_WHITE_SQUARE_3
      3  2900				   TEMPORARY_VAR SET	Overlay
      4  2900				   TEMPORARY_OFFSET SET	0
      5  2900				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2900				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      7  2900					      SUBROUTINE
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2948					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  2948				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2948				   BLACK_QUEEN_on_WHITE_SQUARE_0
      3  2948				   TEMPORARY_VAR SET	Overlay
      4  2948				   TEMPORARY_OFFSET SET	0
      5  2948				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2948				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      7  2948					      SUBROUTINE
      3  2948		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  2960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2990					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  2990				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2990				   BLACK_QUEEN_on_WHITE_SQUARE_1
      3  2990				   TEMPORARY_VAR SET	Overlay
      4  2990				   TEMPORARY_OFFSET SET	0
      5  2990				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2990				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      7  2990					      SUBROUTINE
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  29d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  2a00				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2a00				   BLACK_QUEEN_on_WHITE_SQUARE_2
      3  2a00				   TEMPORARY_VAR SET	Overlay
      4  2a00				   TEMPORARY_OFFSET SET	0
      5  2a00				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2a00				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      7  2a00					      SUBROUTINE
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  2a30		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2a48					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  2a48				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2a48				   BLACK_QUEEN_on_WHITE_SQUARE_3
      3  2a48				   TEMPORARY_VAR SET	Overlay
      4  2a48				   TEMPORARY_OFFSET SET	0
      5  2a48				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2a48				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      7  2a48					      SUBROUTINE
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2a90					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  2a90				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2a90				   BLACK_KING_on_WHITE_SQUARE_0
      3  2a90				   TEMPORARY_VAR SET	Overlay
      4  2a90				   TEMPORARY_OFFSET SET	0
      5  2a90				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2a90				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      7  2a90					      SUBROUTINE
      3  2a90		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$f0,$f0,$40,$e0,$40	;PF0
      4  2aa8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2ad8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  2b00				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2b00				   BLACK_KING_on_WHITE_SQUARE_1
      3  2b00				   TEMPORARY_VAR SET	Overlay
      4  2b00				   TEMPORARY_OFFSET SET	0
      5  2b00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2b00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      7  2b00					      SUBROUTINE
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$7c,$7c,$10,$38,$10	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2b48					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  2b48				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2b48				   BLACK_KING_on_WHITE_SQUARE_2
      3  2b48				   TEMPORARY_VAR SET	Overlay
      4  2b48				   TEMPORARY_OFFSET SET	0
      5  2b48				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2b48				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      7  2b48					      SUBROUTINE
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$03,$03,$00,$01,$00	;PF1
      5  2b78		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$07,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2b90					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  2b90				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2b90				   BLACK_KING_on_WHITE_SQUARE_3
      3  2b90				   TEMPORARY_VAR SET	Overlay
      4  2b90				   TEMPORARY_OFFSET SET	0
      5  2b90				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2b90				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      7  2b90					      SUBROUTINE
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$f8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2bd8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  2bd8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  2c00				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2c00				   BLACK_BLANK_on_BLACK_SQUARE_0
      3  2c00				   TEMPORARY_VAR SET	Overlay
      4  2c00				   TEMPORARY_OFFSET SET	0
      5  2c00				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2c00				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      7  2c00					      SUBROUTINE
      3  2c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2c48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  2c48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2c48				   BLACK_BLANK_on_BLACK_SQUARE_1
      3  2c48				   TEMPORARY_VAR SET	Overlay
      4  2c48				   TEMPORARY_OFFSET SET	0
      5  2c48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2c48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      7  2c48					      SUBROUTINE
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2c90					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  2c90				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2c90				   BLACK_BLANK_on_BLACK_SQUARE_2
      3  2c90				   TEMPORARY_VAR SET	Overlay
      4  2c90				   TEMPORARY_OFFSET SET	0
      5  2c90				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2c90				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      7  2c90					      SUBROUTINE
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2cd8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  2d00				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2d00				   BLACK_BLANK_on_BLACK_SQUARE_3
      3  2d00				   TEMPORARY_VAR SET	Overlay
      4  2d00				   TEMPORARY_OFFSET SET	0
      5  2d00				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2d00				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      7  2d00					      SUBROUTINE
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2d48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  2d48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2d48				   BLACK_PAWN_on_BLACK_SQUARE_0
      3  2d48				   TEMPORARY_VAR SET	Overlay
      4  2d48				   TEMPORARY_OFFSET SET	0
      5  2d48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2d48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      7  2d48					      SUBROUTINE
      3  2d48		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2d90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  2d90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2d90				   BLACK_PAWN_on_BLACK_SQUARE_1
      3  2d90				   TEMPORARY_VAR SET	Overlay
      4  2d90				   TEMPORARY_OFFSET SET	0
      5  2d90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2d90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      7  2d90					      SUBROUTINE
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2dd8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  2e00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2e00				   BLACK_PAWN_on_BLACK_SQUARE_2
      3  2e00				   TEMPORARY_VAR SET	Overlay
      4  2e00				   TEMPORARY_OFFSET SET	0
      5  2e00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2e00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      7  2e00					      SUBROUTINE
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e30		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2e48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  2e48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2e48				   BLACK_PAWN_on_BLACK_SQUARE_3
      3  2e48				   TEMPORARY_VAR SET	Overlay
      4  2e48				   TEMPORARY_OFFSET SET	0
      5  2e48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2e48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      7  2e48					      SUBROUTINE
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2e90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  2e90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2e90				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  2e90				   TEMPORARY_VAR SET	Overlay
      4  2e90				   TEMPORARY_OFFSET SET	0
      5  2e90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2e90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      7  2e90					      SUBROUTINE
      3  2e90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  2ea8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2ed8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  2f00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2f00				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  2f00				   TEMPORARY_VAR SET	Overlay
      4  2f00				   TEMPORARY_OFFSET SET	0
      5  2f00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2f00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      7  2f00					      SUBROUTINE
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2f48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  2f48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2f48				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  2f48				   TEMPORARY_VAR SET	Overlay
      4  2f48				   TEMPORARY_OFFSET SET	0
      5  2f48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2f48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      7  2f48					      SUBROUTINE
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2f78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2f90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  2f90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2f90				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  2f90				   TEMPORARY_VAR SET	Overlay
      4  2f90				   TEMPORARY_OFFSET SET	0
      5  2f90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2f90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      7  2f90					      SUBROUTINE
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECES_3 (2K)"
      1  2fd8		       07 d8	   .TEMP      =	* - BANK_START
 PIECES_3 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  2fd8					      ECHO	"PIECES_3 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      endif
    107  2fd8							;    NEWBANK PIECES_4
    108  2fd8
    109  2fd8							;    CHECK_BANK_SIZE "PIECES_4 (2K)"
    110  2fd8
    111  2fd8							;    NEWBANK PIECES_5
    112  2fd8
    113  2fd8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    114  2fd8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    115  2fd8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    116  2fd8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    117  2fd8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    118  2fd8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    119  2fd8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    120  2fd8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    121  2fd8
    122  2fd8
    123  2fd8				  -	      if	0
    124  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    125  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    126  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    127  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    128  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    129  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    130  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    131  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    132  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    133  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    134  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    135  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    136  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    137  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    138  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    139  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    140  2fd8					      endif
    141  2fd8							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    142  2fd8
    143  2fd8				  -	      if	0
    144  2fd8				  -	      NEWBANK	PIECES_6
    145  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    146  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    147  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    148  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    149  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    150  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    151  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    152  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    153  2fd8				  -
    154  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    155  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    156  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    157  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    158  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    159  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    160  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    161  2fd8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    162  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    163  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    164  2fd8				  -
    165  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    166  2fd8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    167  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    168  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    169  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    170  2fd8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    171  2fd8				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    172  2fd8				  -
    173  2fd8				  -
    174  2fd8				  -	      NEWBANK	PIECES_7
    175  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    176  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    177  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    178  2fd8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    179  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    180  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    181  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    182  2fd8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    183  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    184  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    185  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    186  2fd8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    187  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    188  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    189  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    190  2fd8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    191  2fd8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    192  2fd8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    193  2fd8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    194  2fd8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    195  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    196  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    197  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    198  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    199  2fd8				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    200  2fd8				  -
    201  2fd8				  -
    202  2fd8				  -	      NEWBANK	PIECES_8
    203  2fd8				  -
    204  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    205  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    206  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    207  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    208  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    209  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    210  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    211  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    212  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    213  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    214  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    215  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    216  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    217  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    218  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    219  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    220  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    221  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    222  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    223  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    224  2fd8				  -
    225  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    226  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    227  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    228  2fd8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    229  2fd8				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    230  2fd8				  -
    231  2fd8					      endif
    232  2fd8
    233  2fd8							;    NEWBANK PIECES_9
    234  2fd8
    235  2fd8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    236  2fd8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    237  2fd8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    238  2fd8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    239  2fd8							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    240  2fd8
    241  2fd8				  -	      if	0
    242  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    243  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    244  2fd8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    245  2fd8					      endif
    246  2fd8
    247  2fd8							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    248  2fd8
    249  2fd8				  -	      if	0
    250  2fd8				  -
    251  2fd8				  -
    252  2fd8				  -
    253  2fd8				  -
    254  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    255  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    256  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    257  2fd8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    258  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    259  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    260  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    261  2fd8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    262  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    263  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    264  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    265  2fd8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    266  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    267  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    268  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    269  2fd8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    270  2fd8				  -
    271  2fd8				  -
    272  2fd8					      endif
------- FILE BANK_CHESS_INCLUDES.asm
     38  2fd8
     39  2fd8							;    NEWBANK PIECE_VECTORS
     40  2fd8							;    include "piece_vectors.asm"
     41  2fd8							;    CHECK_BANK_SIZE "PIECE_VECTORS (2K)"
------- FILE ./chess.asm
------- FILE BANK_StateMachine.asm LEVEL 2 PASS 5
      0  2fd8					      include	"BANK_StateMachine.asm"
      0  2fd8					      NEWBANK	STATEMACHINE
      1  36d8 ????				      SEG	STATEMACHINE
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   STATEMACHINE SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	STATEMACHINE
      2  3000
      3  3000
      4  3000							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      5  3000
      6  3000		       00 09	   PLAYER     =	RAMBANK_PLY
      7  3000		       00 0a	   OPPONENT   =	PLAYER + 1
      8  3000
      9  3000		       00 10	   CURSOR_MOVE_SPEED =	16
     10  3000		       00 14	   CAP_SPEED  =	20
     11  3000		       00 28	   HOLD_DELAY =	40
     12  3000
     13  3000
     14  3000							;---------------------------------------------------------------------------------------------------
     15  3000
     16  3000				   P	      SET	0
     17  3000					      MAC	ain
     18  3000				   AI_{1}     SET	P
     19  3000				   P	      SET	P+1
     20  3000					      ENDM
     21  3000
     22  3000					      MAC	lo
     23  3000					      .byte	<ai{1}
     24  3000					      ENDM
     25  3000
     26  3000					      MAC	hi
     27  3000					      .byte	>ai{1}
     28  3000					      ENDM
     29  3000
     30  3000					      MAC	bk
     31  3000					      .byte	BANK_ai{1}
     32  3000					      ENDM
     33  3000
     34  3000
     35  3000		       00 28	   ONCEPERFRAME =	40
     36  3000
     37  3000					      MAC	tabdef
     38  3000
     39  3000					      {1}	BeginSelectMovePhase
     40  3000					      {1}	SelectStartSquare
     41  3000					      {1}	StartSquareSelected
     42  3000					      {1}	DrawMoves
     43  3000					      {1}	ShowP_MoveCaptures
     44  3000					      {1}	SlowFlash
     45  3000					      {1}	UnDrawTargetSquares
     46  3000					      {1}	SelectDestinationSquare
     47  3000					      {1}	Quiescent
     48  3000					      {1}	ReselectDebounce
     49  3000					      {1}	StartMoveGen
     50  3000					      {1}	StepMoveGen
     51  3000					      {1}	LookForCheck
     52  3000					      {1}	StartClearBoard
     53  3000					      {1}	ClearEachRow
     54  3000					      {1}	DrawEntireBoard
     55  3000					      {1}	DrawPart2
     56  3000					      {1}	DrawPart3
     57  3000					      {1}	FlipBuffers
     58  3000					      {1}	GenerateMoves
     59  3000					      {1}	ComputerMove
     60  3000					      {1}	MoveIsSelected
     61  3000					      {1}	WriteStartPieceBlank
     62  3000					      {1}	MarchToTargetA
     63  3000					      {1}	MarchB
     64  3000					      {1}	MarchToTargetB
     65  3000					      {1}	MarchB2
     66  3000					      {1}	FinalFlash
     67  3000					      {1}	SpecialMoveFixup
     68  3000					      {1}	InCheckBackup
     69  3000					      {1}	InCheckDelay
     70  3000					      {1}	PromotePawnStart
     71  3000					      {1}	RollPromotionPiece
     72  3000					      {1}	ChoosePromotePiece
     73  3000					      {1}	ChooseDebounce
     74  3000					      {1}	CheckMate
     75  3000					      {1}	Draw
     76  3000
     77  3000					      ENDM		; {1} = macro to use
     78  3000
      0  3000					      TABDEF	AIN
      1  3000
      0  3000					      AIN	BeginSelectMovePhase
      1  3000				   AI_BeginSelectMovePhase SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	SelectStartSquare
      1  3000				   AI_SelectStartSquare SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	StartSquareSelected
      1  3000				   AI_StartSquareSelected SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	DrawMoves
      1  3000				   AI_DrawMoves SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ShowP_MoveCaptures
      1  3000				   AI_ShowP_MoveCaptures SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	SlowFlash
      1  3000				   AI_SlowFlash SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	UnDrawTargetSquares
      1  3000				   AI_UnDrawTargetSquares SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	SelectDestinationSquare
      1  3000				   AI_SelectDestinationSquare SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	Quiescent
      1  3000				   AI_Quiescent SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ReselectDebounce
      1  3000				   AI_ReselectDebounce SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	StartMoveGen
      1  3000				   AI_StartMoveGen SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	StepMoveGen
      1  3000				   AI_StepMoveGen SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	LookForCheck
      1  3000				   AI_LookForCheck SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	StartClearBoard
      1  3000				   AI_StartClearBoard SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ClearEachRow
      1  3000				   AI_ClearEachRow SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	DrawEntireBoard
      1  3000				   AI_DrawEntireBoard SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	DrawPart2
      1  3000				   AI_DrawPart2 SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	DrawPart3
      1  3000				   AI_DrawPart3 SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	FlipBuffers
      1  3000				   AI_FlipBuffers SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	GenerateMoves
      1  3000				   AI_GenerateMoves SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ComputerMove
      1  3000				   AI_ComputerMove SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MoveIsSelected
      1  3000				   AI_MoveIsSelected SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	WriteStartPieceBlank
      1  3000				   AI_WriteStartPieceBlank SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MarchToTargetA
      1  3000				   AI_MarchToTargetA SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MarchB
      1  3000				   AI_MarchB  SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MarchToTargetB
      1  3000				   AI_MarchToTargetB SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	MarchB2
      1  3000				   AI_MarchB2 SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	FinalFlash
      1  3000				   AI_FinalFlash SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	SpecialMoveFixup
      1  3000				   AI_SpecialMoveFixup SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	InCheckBackup
      1  3000				   AI_InCheckBackup SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	InCheckDelay
      1  3000				   AI_InCheckDelay SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	PromotePawnStart
      1  3000				   AI_PromotePawnStart SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	RollPromotionPiece
      1  3000				   AI_RollPromotionPiece SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ChoosePromotePiece
      1  3000				   AI_ChoosePromotePiece SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	ChooseDebounce
      1  3000				   AI_ChooseDebounce SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	CheckMate
      1  3000				   AI_CheckMate SET	P
      2  3000				   P	      SET	P+1
      0  3000					      AIN	Draw
      1  3000				   AI_Draw    SET	P
      2  3000				   P	      SET	P+1
     39  3000
     80  3000
      0  3000					      DEF	AiVectorLO
      1  3000				   BANK_AiVectorLO SET	_CURRENT_BANK
      2  3000				   AiVectorLO
      3  3000				   TEMPORARY_VAR SET	Overlay
      4  3000				   TEMPORARY_OFFSET SET	0
      5  3000				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      6  3000				   FUNCTION_NAME SET	AiVectorLO
      7  3000					      SUBROUTINE
      0  3000					      TABDEF	LO
      1  3000
      0  3000					      LO	BeginSelectMovePhase
      1  3000		       ad		      .byte.b	<aiBeginSelectMovePhase
      0  3001					      LO	SelectStartSquare
      1  3001		       c2		      .byte.b	<aiSelectStartSquare
      0  3002					      LO	StartSquareSelected
      1  3002		       20		      .byte.b	<aiStartSquareSelected
      0  3003					      LO	DrawMoves
      1  3003		       3b		      .byte.b	<aiDrawMoves
      0  3004					      LO	ShowP_MoveCaptures
      1  3004		       e6		      .byte.b	<aiShowP_MoveCaptures
      0  3005					      LO	SlowFlash
      1  3005		       04		      .byte.b	<aiSlowFlash
      0  3006					      LO	UnDrawTargetSquares
      1  3006		       c4		      .byte.b	<aiUnDrawTargetSquares
      0  3007					      LO	SelectDestinationSquare
      1  3007		       6b		      .byte.b	<aiSelectDestinationSquare
      0  3008					      LO	Quiescent
      1  3008		       c0		      .byte.b	<aiQuiescent
      0  3009					      LO	ReselectDebounce
      1  3009		       b7		      .byte.b	<aiReselectDebounce
      0  300a					      LO	StartMoveGen
      1  300a		       81		      .byte.b	<aiStartMoveGen
      0  300b					      LO	StepMoveGen
      1  300b		       df		      .byte.b	<aiStepMoveGen
      0  300c					      LO	LookForCheck
      1  300c		       8b		      .byte.b	<aiLookForCheck
      0  300d					      LO	StartClearBoard
      1  300d		       79		      .byte.b	<aiStartClearBoard
      0  300e					      LO	ClearEachRow
      1  300e		       86		      .byte.b	<aiClearEachRow
      0  300f					      LO	DrawEntireBoard
      1  300f		       7c		      .byte.b	<aiDrawEntireBoard
      0  3010					      LO	DrawPart2
      1  3010		       ca		      .byte.b	<aiDrawPart2
      0  3011					      LO	DrawPart3
      1  3011		       cd		      .byte.b	<aiDrawPart3
      0  3012					      LO	FlipBuffers
      1  3012		       b0		      .byte.b	<aiFlipBuffers
      0  3013					      LO	GenerateMoves
      1  3013		       ce		      .byte.b	<aiGenerateMoves
      0  3014					      LO	ComputerMove
      1  3014		       86		      .byte.b	<aiComputerMove
      0  3015					      LO	MoveIsSelected
      1  3015		       98		      .byte.b	<aiMoveIsSelected
      0  3016					      LO	WriteStartPieceBlank
      1  3016		       ac		      .byte.b	<aiWriteStartPieceBlank
      0  3017					      LO	MarchToTargetA
      1  3017		       59		      .byte.b	<aiMarchToTargetA
      0  3018					      LO	MarchB
      1  3018		       df		      .byte.b	<aiMarchB
      0  3019					      LO	MarchToTargetB
      1  3019		       f4		      .byte.b	<aiMarchToTargetB
      0  301a					      LO	MarchB2
      1  301a		       ca		      .byte.b	<aiMarchB2
      0  301b					      LO	FinalFlash
      1  301b		       ef		      .byte.b	<aiFinalFlash
      0  301c					      LO	SpecialMoveFixup
      1  301c		       47		      .byte.b	<aiSpecialMoveFixup
      0  301d					      LO	InCheckBackup
      1  301d		       92		      .byte.b	<aiInCheckBackup
      0  301e					      LO	InCheckDelay
      1  301e		       a0		      .byte.b	<aiInCheckDelay
      0  301f					      LO	PromotePawnStart
      1  301f		       e0		      .byte.b	<aiPromotePawnStart
      0  3020					      LO	RollPromotionPiece
      1  3020		       00		      .byte.b	<aiRollPromotionPiece
      0  3021					      LO	ChoosePromotePiece
      1  3021		       46		      .byte.b	<aiChoosePromotePiece
      0  3022					      LO	ChooseDebounce
      1  3022		       b1		      .byte.b	<aiChooseDebounce
      0  3023					      LO	CheckMate
      1  3023		       12		      .byte.b	<aiCheckMate
      0  3024					      LO	Draw
      1  3024		       0d		      .byte.b	<aiDraw
     39  3025
     83  3025
      0  3025					      DEF	AiVectorHI
      1  3025				   BANK_AiVectorHI SET	_CURRENT_BANK
      2  3025				   AiVectorHI
      3  3025				   TEMPORARY_VAR SET	Overlay
      4  3025				   TEMPORARY_OFFSET SET	0
      5  3025				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      6  3025				   FUNCTION_NAME SET	AiVectorHI
      7  3025					      SUBROUTINE
      0  3025					      TABDEF	HI
      1  3025
      0  3025					      HI	BeginSelectMovePhase
      1  3025		       f0		      .byte.b	>aiBeginSelectMovePhase
      0  3026					      HI	SelectStartSquare
      1  3026		       f0		      .byte.b	>aiSelectStartSquare
      0  3027					      HI	StartSquareSelected
      1  3027		       f1		      .byte.b	>aiStartSquareSelected
      0  3028					      HI	DrawMoves
      1  3028		       f1		      .byte.b	>aiDrawMoves
      0  3029					      HI	ShowP_MoveCaptures
      1  3029		       f1		      .byte.b	>aiShowP_MoveCaptures
      0  302a					      HI	SlowFlash
      1  302a		       f2		      .byte.b	>aiSlowFlash
      0  302b					      HI	UnDrawTargetSquares
      1  302b		       f1		      .byte.b	>aiUnDrawTargetSquares
      0  302c					      HI	SelectDestinationSquare
      1  302c		       f2		      .byte.b	>aiSelectDestinationSquare
      0  302d					      HI	Quiescent
      1  302d		       f2		      .byte.b	>aiQuiescent
      0  302e					      HI	ReselectDebounce
      1  302e		       f2		      .byte.b	>aiReselectDebounce
      0  302f					      HI	StartMoveGen
      1  302f		       f0		      .byte.b	>aiStartMoveGen
      0  3030					      HI	StepMoveGen
      1  3030		       f8		      .byte.b	>aiStepMoveGen
      0  3031					      HI	LookForCheck
      1  3031		       f0		      .byte.b	>aiLookForCheck
      0  3032					      HI	StartClearBoard
      1  3032		       f0		      .byte.b	>aiStartClearBoard
      0  3033					      HI	ClearEachRow
      1  3033		       f0		      .byte.b	>aiClearEachRow
      0  3034					      HI	DrawEntireBoard
      1  3034		       f8		      .byte.b	>aiDrawEntireBoard
      0  3035					      HI	DrawPart2
      1  3035		       f0		      .byte.b	>aiDrawPart2
      0  3036					      HI	DrawPart3
      1  3036		       f0		      .byte.b	>aiDrawPart3
      0  3037					      HI	FlipBuffers
      1  3037		       f8		      .byte.b	>aiFlipBuffers
      0  3038					      HI	GenerateMoves
      1  3038		       f8		      .byte.b	>aiGenerateMoves
      0  3039					      HI	ComputerMove
      1  3039		       f9		      .byte.b	>aiComputerMove
      0  303a					      HI	MoveIsSelected
      1  303a		       f0		      .byte.b	>aiMoveIsSelected
      0  303b					      HI	WriteStartPieceBlank
      1  303b		       f0		      .byte.b	>aiWriteStartPieceBlank
      0  303c					      HI	MarchToTargetA
      1  303c		       f0		      .byte.b	>aiMarchToTargetA
      0  303d					      HI	MarchB
      1  303d		       f0		      .byte.b	>aiMarchB
      0  303e					      HI	MarchToTargetB
      1  303e		       f0		      .byte.b	>aiMarchToTargetB
      0  303f					      HI	MarchB2
      1  303f		       f0		      .byte.b	>aiMarchB2
      0  3040					      HI	FinalFlash
      1  3040		       f0		      .byte.b	>aiFinalFlash
      0  3041					      HI	SpecialMoveFixup
      1  3041		       fa		      .byte.b	>aiSpecialMoveFixup
      0  3042					      HI	InCheckBackup
      1  3042		       f0		      .byte.b	>aiInCheckBackup
      0  3043					      HI	InCheckDelay
      1  3043		       f0		      .byte.b	>aiInCheckDelay
      0  3044					      HI	PromotePawnStart
      1  3044		       f2		      .byte.b	>aiPromotePawnStart
      0  3045					      HI	RollPromotionPiece
      1  3045		       f3		      .byte.b	>aiRollPromotionPiece
      0  3046					      HI	ChoosePromotePiece
      1  3046		       f3		      .byte.b	>aiChoosePromotePiece
      0  3047					      HI	ChooseDebounce
      1  3047		       f3		      .byte.b	>aiChooseDebounce
      0  3048					      HI	CheckMate
      1  3048		       f1		      .byte.b	>aiCheckMate
      0  3049					      HI	Draw
      1  3049		       f1		      .byte.b	>aiDraw
     39  304a
     86  304a
      0  304a					      DEF	AiVectorBANK
      1  304a				   BANK_AiVectorBANK SET	_CURRENT_BANK
      2  304a				   AiVectorBANK
      3  304a				   TEMPORARY_VAR SET	Overlay
      4  304a				   TEMPORARY_OFFSET SET	0
      5  304a				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      6  304a				   FUNCTION_NAME SET	AiVectorBANK
      7  304a					      SUBROUTINE
      0  304a					      TABDEF	BK
      1  304a
      0  304a					      BK	BeginSelectMovePhase
      1  304a		       06		      .byte.b	BANK_aiBeginSelectMovePhase
      0  304b					      BK	SelectStartSquare
      1  304b		       06		      .byte.b	BANK_aiSelectStartSquare
      0  304c					      BK	StartSquareSelected
      1  304c		       06		      .byte.b	BANK_aiStartSquareSelected
      0  304d					      BK	DrawMoves
      1  304d		       06		      .byte.b	BANK_aiDrawMoves
      0  304e					      BK	ShowP_MoveCaptures
      1  304e		       06		      .byte.b	BANK_aiShowP_MoveCaptures
      0  304f					      BK	SlowFlash
      1  304f		       06		      .byte.b	BANK_aiSlowFlash
      0  3050					      BK	UnDrawTargetSquares
      1  3050		       06		      .byte.b	BANK_aiUnDrawTargetSquares
      0  3051					      BK	SelectDestinationSquare
      1  3051		       06		      .byte.b	BANK_aiSelectDestinationSquare
      0  3052					      BK	Quiescent
      1  3052		       06		      .byte.b	BANK_aiQuiescent
      0  3053					      BK	ReselectDebounce
      1  3053		       06		      .byte.b	BANK_aiReselectDebounce
      0  3054					      BK	StartMoveGen
      1  3054		       06		      .byte.b	BANK_aiStartMoveGen
      0  3055					      BK	StepMoveGen
      1  3055		       0f		      .byte.b	BANK_aiStepMoveGen
      0  3056					      BK	LookForCheck
      1  3056		       06		      .byte.b	BANK_aiLookForCheck
      0  3057					      BK	StartClearBoard
      1  3057		       00		      .byte.b	BANK_aiStartClearBoard
      0  3058					      BK	ClearEachRow
      1  3058		       00		      .byte.b	BANK_aiClearEachRow
      0  3059					      BK	DrawEntireBoard
      1  3059		       0f		      .byte.b	BANK_aiDrawEntireBoard
      0  305a					      BK	DrawPart2
      1  305a		       00		      .byte.b	BANK_aiDrawPart2
      0  305b					      BK	DrawPart3
      1  305b		       00		      .byte.b	BANK_aiDrawPart3
      0  305c					      BK	FlipBuffers
      1  305c		       0f		      .byte.b	BANK_aiFlipBuffers
      0  305d					      BK	GenerateMoves
      1  305d		       0f		      .byte.b	BANK_aiGenerateMoves
      0  305e					      BK	ComputerMove
      1  305e		       0f		      .byte.b	BANK_aiComputerMove
      0  305f					      BK	MoveIsSelected
      1  305f		       00		      .byte.b	BANK_aiMoveIsSelected
      0  3060					      BK	WriteStartPieceBlank
      1  3060		       00		      .byte.b	BANK_aiWriteStartPieceBlank
      0  3061					      BK	MarchToTargetA
      1  3061		       09		      .byte.b	BANK_aiMarchToTargetA
      0  3062					      BK	MarchB
      1  3062		       00		      .byte.b	BANK_aiMarchB
      0  3063					      BK	MarchToTargetB
      1  3063		       09		      .byte.b	BANK_aiMarchToTargetB
      0  3064					      BK	MarchB2
      1  3064		       09		      .byte.b	BANK_aiMarchB2
      0  3065					      BK	FinalFlash
      1  3065		       00		      .byte.b	BANK_aiFinalFlash
      0  3066					      BK	SpecialMoveFixup
      1  3066		       0f		      .byte.b	BANK_aiSpecialMoveFixup
      0  3067					      BK	InCheckBackup
      1  3067		       06		      .byte.b	BANK_aiInCheckBackup
      0  3068					      BK	InCheckDelay
      1  3068		       06		      .byte.b	BANK_aiInCheckDelay
      0  3069					      BK	PromotePawnStart
      1  3069		       06		      .byte.b	BANK_aiPromotePawnStart
      0  306a					      BK	RollPromotionPiece
      1  306a		       06		      .byte.b	BANK_aiRollPromotionPiece
      0  306b					      BK	ChoosePromotePiece
      1  306b		       06		      .byte.b	BANK_aiChoosePromotePiece
      0  306c					      BK	ChooseDebounce
      1  306c		       06		      .byte.b	BANK_aiChooseDebounce
      0  306d					      BK	CheckMate
      1  306d		       00		      .byte.b	BANK_aiCheckMate
      0  306e					      BK	Draw
      1  306e		       00		      .byte.b	BANK_aiDraw
     39  306f
     89  306f
     90  306f
     91  306f							;---------------------------------------------------------------------------------------------------
     92  306f
      0  306f					      DEF	AiSetupVectors
      1  306f				   BANK_AiSetupVectors SET	_CURRENT_BANK
      2  306f				   AiSetupVectors
      3  306f				   TEMPORARY_VAR SET	Overlay
      4  306f				   TEMPORARY_OFFSET SET	0
      5  306f				   VAR_BOUNDARY_AiSetupVectors SET	TEMPORARY_OFFSET
      6  306f				   FUNCTION_NAME SET	AiSetupVectors
      7  306f					      SUBROUTINE
     94  306f					      SUBROUTINE
     95  306f
      0  306f					      REFER	AiStateMachine
      1  306f				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  306f				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  306f					      ENDIF
      0  306f					      VEND	AiSetupVectors
      1  306f				  -	      IFNCONST	AiSetupVectors
      2  306f				  -	      ECHO	"Incorrect VEND label", AiSetupVectors
      3  306f				  -	      ERR
      4  306f					      ENDIF
      5  306f		       00 a2	   VAREND_AiSetupVectors =	TEMPORARY_VAR
     98  306f
     99  306f							; State machine vector setup - points to current routine to execute
    100  306f
    101  306f		       a6 8c		      ldx	aiState
    102  3071		       bd 00 f0 	      lda	AiVectorLO,x
    103  3074		       85 ea		      sta	__ptr
    104  3076		       bd 25 f0 	      lda	AiVectorHI,x
    105  3079		       85 eb		      sta	__ptr+1
    106  307b
    107  307b		       bd 4a f0 	      lda	AiVectorBANK,x
    108  307e		       85 8b		      sta	savedBank
    109  3080
    110  3080		       60		      rts
    111  3081
    112  3081
    113  3081							;---------------------------------------------------------------------------------------------------
    114  3081
      0  3081					      DEF	aiStartMoveGen
      1  3081				   BANK_aiStartMoveGen SET	_CURRENT_BANK
      2  3081				   aiStartMoveGen
      3  3081				   TEMPORARY_VAR SET	Overlay
      4  3081				   TEMPORARY_OFFSET SET	0
      5  3081				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      6  3081				   FUNCTION_NAME SET	aiStartMoveGen
      7  3081					      SUBROUTINE
    116  3081					      SUBROUTINE
    117  3081
      0  3081					      REFER	AiStateMachine
      1  3081				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3081				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3081					      ENDIF
      0  3081					      VEND	aiStartMoveGen
      1  3081				  -	      IFNCONST	aiStartMoveGen
      2  3081				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  3081				  -	      ERR
      4  3081					      ENDIF
      5  3081		       00 a2	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
    120  3081
    121  3081							; To assist with castling, generate the moves for the opponent, giving us effectively
    122  3081							; a list of squares that are being attacked. The castling can't happen if the king is
    123  3081							; in check or if the squares it would have to move over are in check
    124  3081
    125  3081							; we don't need to worry about this if K has moved, or relevant R has moved or if
    126  3081							; the squares between are occupied. We can tell THAT by examining the movelist to see
    127  3081							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
    128  3081
    129  3081		       e6 95		      inc	currentPly
    130  3083		       20 bc f8 	      jsr	InitialiseMoveGeneration
      0  3086					      PHASE	AI_StepMoveGen
      1  3086		       a9 0b		      lda	#AI_StepMoveGen
      2  3088		       85 8c		      sta	aiState
    132  308a		       60		      rts
    133  308b
    134  308b
    135  308b							;---------------------------------------------------------------------------------------------------
    136  308b
    137  308b
      0  308b					      DEF	aiLookForCheck
      1  308b				   BANK_aiLookForCheck SET	_CURRENT_BANK
      2  308b				   aiLookForCheck
      3  308b				   TEMPORARY_VAR SET	Overlay
      4  308b				   TEMPORARY_OFFSET SET	0
      5  308b				   VAR_BOUNDARY_aiLookForCheck SET	TEMPORARY_OFFSET
      6  308b				   FUNCTION_NAME SET	aiLookForCheck
      7  308b					      SUBROUTINE
    139  308b					      SUBROUTINE
    140  308b
      0  308b					      REFER	AiStateMachine
      1  308b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  308b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  308b					      ENDIF
      0  308b					      VEND	aiLookForCheck
      1  308b				  -	      IFNCONST	aiLookForCheck
      2  308b				  -	      ECHO	"Incorrect VEND label", aiLookForCheck
      3  308b				  -	      ERR
      4  308b					      ENDIF
      5  308b		       00 a2	   VAREND_aiLookForCheck =	TEMPORARY_VAR
    143  308b
    144  308b		       c6 95		      dec	currentPly
    145  308d
    146  308d
    147  308d				  -	      if	0
    148  308d				  -
    149  308d				  -			; now we've finished generating the opponent moves
    150  308d				  -			; See if the square our king is on is an attacked square (that is, it appears as a TO
    151  308d				  -			; square in the opponent's movelist)
    152  308d				  -
    153  308d				  -
    154  308d				  -	      jsr	SAFE_GetKingSquare	; king's current X12 square
    155  308d				  -
    156  308d				  -	      inc	currentPly
    157  308d				  -	      jsr	Go_IsSquareUnderAttack
    158  308d				  -	      dec	currentPly
    159  308d				  -	      bcc	.exit
    160  308d				  -
    161  308d				  -			; in check!
    162  308d				  -
    163  308d				  -	      lda	#$40
    164  308d				  -	      sta	COLUBK
    165  308d				  -
    166  308d				  -	      lda	#50
    167  308d				  -	      sta	mdelay
    168  308d				  -
    169  308d				  -	      lda	#8
    170  308d				  -	      sta	drawCount	; row #
    171  308d				  -
    172  308d				  -	      PHASE	AI_InCheckBackup
    173  308d				  -	      rts
    174  308d					      endif
    175  308d
      0  308d				   .exit      PHASE	AI_BeginSelectMovePhase
      1  308d		       a9 00		      lda	#AI_BeginSelectMovePhase
      2  308f		       85 8c		      sta	aiState
    177  3091		       60		      rts
    178  3092
    179  3092							;---------------------------------------------------------------------------------------------------
    180  3092
      0  3092					      DEF	aiInCheckBackup
      1  3092				   BANK_aiInCheckBackup SET	_CURRENT_BANK
      2  3092				   aiInCheckBackup
      3  3092				   TEMPORARY_VAR SET	Overlay
      4  3092				   TEMPORARY_OFFSET SET	0
      5  3092				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      6  3092				   FUNCTION_NAME SET	aiInCheckBackup
      7  3092					      SUBROUTINE
    182  3092					      SUBROUTINE
    183  3092
      0  3092					      REFER	AiStateMachine
      1  3092				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3092				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3092					      ENDIF
      0  3092					      VEND	aiInCheckBackup
      1  3092				  -	      IFNCONST	aiInCheckBackup
      2  3092				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  3092				  -	      ERR
      4  3092					      ENDIF
      5  3092		       00 a2	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
    186  3092
    187  3092							; We're about to draw some large text on the screen
    188  3092							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
    189  3092
    190  3092		       c6 84		      dec	drawCount
    191  3094		       30 05		      bmi	.exit	; done all rows
    192  3096		       a4 84		      ldy	drawCount
    193  3098		       4c b9 fd 	      jmp	SAFE_BackupBitmaps
    194  309b
      0  309b				   .exit      PHASE	AI_InCheckDelay
      1  309b		       a9 1e		      lda	#AI_InCheckDelay
      2  309d		       85 8c		      sta	aiState
    196  309f		       60		      rts
    197  30a0
    198  30a0
    199  30a0							;---------------------------------------------------------------------------------------------------
    200  30a0
      0  30a0					      DEF	aiInCheckDelay
      1  30a0				   BANK_aiInCheckDelay SET	_CURRENT_BANK
      2  30a0				   aiInCheckDelay
      3  30a0				   TEMPORARY_VAR SET	Overlay
      4  30a0				   TEMPORARY_OFFSET SET	0
      5  30a0				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      6  30a0				   FUNCTION_NAME SET	aiInCheckDelay
      7  30a0					      SUBROUTINE
    202  30a0					      SUBROUTINE
    203  30a0
      0  30a0					      REFER	AiStateMachine
      1  30a0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  30a0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  30a0					      ENDIF
      0  30a0					      VEND	aiInCheckDelay
      1  30a0				  -	      IFNCONST	aiInCheckDelay
      2  30a0				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  30a0				  -	      ERR
      4  30a0					      ENDIF
      5  30a0		       00 a2	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
    206  30a0
    207  30a0		       c6 89		      dec	mdelay
    208  30a2		       d0 08		      bne	.exit
    209  30a4
    210  30a4		       a9 00		      lda	#0
    211  30a6		       85 49		      sta	COLUBK
    212  30a8
      0  30a8					      PHASE	AI_BeginSelectMovePhase
      1  30a8		       a9 00		      lda	#AI_BeginSelectMovePhase
      2  30aa		       85 8c		      sta	aiState
    214  30ac		       60	   .exit      rts
    215  30ad
    216  30ad
    217  30ad							;---------------------------------------------------------------------------------------------------
    218  30ad
      0  30ad					      DEF	aiBeginSelectMovePhase
      1  30ad				   BANK_aiBeginSelectMovePhase SET	_CURRENT_BANK
      2  30ad				   aiBeginSelectMovePhase
      3  30ad				   TEMPORARY_VAR SET	Overlay
      4  30ad				   TEMPORARY_OFFSET SET	0
      5  30ad				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      6  30ad				   FUNCTION_NAME SET	aiBeginSelectMovePhase
      7  30ad					      SUBROUTINE
    220  30ad					      SUBROUTINE
    221  30ad
      0  30ad					      REFER	AiStateMachine
      1  30ad				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  30ad				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  30ad					      ENDIF
      0  30ad					      VEND	aiBeginSelectMovePhase
      1  30ad				  -	      IFNCONST	aiBeginSelectMovePhase
      2  30ad				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  30ad				  -	      ERR
      4  30ad					      ENDIF
      5  30ad		       00 a2	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
    224  30ad
    225  30ad		       a9 38		      lda	#$38
    226  30af		       85 88		      sta	cursorX12
    227  30b1
    228  30b1		       a9 00		      lda	#0
    229  30b3		       85 89		      sta	mdelay	;?
    230  30b5		       85 8f		      sta	aiFlashPhase	;?
    231  30b7
    232  30b7		       a9 ff		      lda	#-1
    233  30b9		       85 85		      sta	fromX12
    234  30bb		       85 86		      sta	toX12
    235  30bd
      0  30bd					      PHASE	AI_SelectStartSquare
      1  30bd		       a9 01		      lda	#AI_SelectStartSquare
      2  30bf		       85 8c		      sta	aiState
    237  30c1		       60		      rts
    238  30c2
    239  30c2							;---------------------------------------------------------------------------------------------------
    240  30c2
      0  30c2					      DEF	aiSelectStartSquare
      1  30c2				   BANK_aiSelectStartSquare SET	_CURRENT_BANK
      2  30c2				   aiSelectStartSquare
      3  30c2				   TEMPORARY_VAR SET	Overlay
      4  30c2				   TEMPORARY_OFFSET SET	0
      5  30c2				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      6  30c2				   FUNCTION_NAME SET	aiSelectStartSquare
      7  30c2					      SUBROUTINE
    242  30c2					      SUBROUTINE
    243  30c2
      0  30c2					      REFER	AiStateMachine
      1  30c2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  30c2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  30c2					      ENDIF
      0  30c2					      VEND	aiSelectStartSquare
      1  30c2				  -	      IFNCONST	aiSelectStartSquare
      2  30c2				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  30c2				  -	      ERR
      4  30c2					      ENDIF
      5  30c2		       00 a2	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    246  30c2
    247  30c2		       20 29 f2 	      jsr	moveCursor
    248  30c5		       20 0b fd 	      jsr	IsValidP_MoveFromSquare
    249  30c8
    250  30c8		       c6 8a		      dec	ccur	; pulse colour for valid squares
    251  30ca		       20 ed f0 	      jsr	setCursorColours
    252  30cd
    253  30cd		       98		      tya
    254  30ce		       05 4c		      ora	INPT4
    255  30d0		       30 04		      bmi	.exit	; illegal square or no button press
    256  30d2
      0  30d2					      PHASE	AI_StartSquareSelected
      1  30d2		       a9 02		      lda	#AI_StartSquareSelected
      2  30d4		       85 8c		      sta	aiState
    258  30d6
    259  30d6		       60	   .exit      rts
    260  30d7
    261  30d7							;---------------------------------------------------------------------------------------------------
    262  30d7
      0  30d7					      DEF	setCursorPriority
      1  30d7				   BANK_setCursorPriority SET	_CURRENT_BANK
      2  30d7				   setCursorPriority
      3  30d7				   TEMPORARY_VAR SET	Overlay
      4  30d7				   TEMPORARY_OFFSET SET	0
      5  30d7				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      6  30d7				   FUNCTION_NAME SET	setCursorPriority
      7  30d7					      SUBROUTINE
    264  30d7					      SUBROUTINE
    265  30d7
      0  30d7					      REFER	moveCursor
      1  30d7					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  30d7				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  30d7					      ENDIF
      0  30d7					      VEND	setCursorPriority
      1  30d7				  -	      IFNCONST	setCursorPriority
      2  30d7				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  30d7				  -	      ERR
      4  30d7					      ENDIF
      5  30d7		       00 a3	   VAREND_setCursorPriority =	TEMPORARY_VAR
    268  30d7
    269  30d7		       98		      tya
    270  30d8		       48		      pha
    271  30d9
    272  30d9		       a2 04		      ldx	#%100
    273  30db
    274  30db		       a4 88		      ldy	cursorX12
    275  30dd		       30 09		      bmi	.under
    276  30df		       20 e7 fc 	      jsr	GetBoard
    277  30e2		       c9 00		      cmp	#0
    278  30e4		       d0 02		      bne	.under
    279  30e6		       a2 00		      ldx	#0
    280  30e8		       86 4a	   .under     stx	CTRLPF	; UNDER
    281  30ea
    282  30ea		       68		      pla
    283  30eb		       a8		      tay
    284  30ec		       60		      rts
    285  30ed
    286  30ed							;---------------------------------------------------------------------------------------------------
    287  30ed
      0  30ed					      DEF	setCursorColours
      1  30ed				   BANK_setCursorColours SET	_CURRENT_BANK
      2  30ed				   setCursorColours
      3  30ed				   TEMPORARY_VAR SET	Overlay
      4  30ed				   TEMPORARY_OFFSET SET	0
      5  30ed				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      6  30ed				   FUNCTION_NAME SET	setCursorColours
      7  30ed					      SUBROUTINE
    289  30ed					      SUBROUTINE
    290  30ed
      0  30ed					      REFER	aiSelectStartSquare
      1  30ed				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  30ed					      ENDIF
      0  30ed					      REFER	aiDrawMoves
      1  30ed				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  30ed					      ENDIF
      0  30ed					      REFER	aiUnDrawTargetSquares
      1  30ed				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  30ed					      ENDIF
      0  30ed					      REFER	aiShowP_MoveCaptures
      1  30ed				  -	      IF	VAREND_aiShowP_MoveCaptures > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiShowP_MoveCaptures
      3  30ed					      ENDIF
      0  30ed					      REFER	aiSlowFlash
      1  30ed				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  30ed					      ENDIF
      0  30ed					      REFER	aiSelectDestinationSquare
      1  30ed				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  30ed				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  30ed					      ENDIF
      0  30ed					      VEND	setCursorColours
      1  30ed				  -	      IFNCONST	setCursorColours
      2  30ed				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  30ed				  -	      ERR
      4  30ed					      ENDIF
      5  30ed		       00 a2	   VAREND_setCursorColours =	TEMPORARY_VAR
    298  30ed
    299  30ed							; pass y=-1 if move is NOT in the movelist
    300  30ed							; preserve y
    301  30ed
    302  30ed		       a9 44		      lda	#$44
    303  30ef
    304  30ef		       c0 ff		      cpy	#-1
    305  30f1		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    306  30f3
    307  30f3		       a5 8a		      lda	ccur
    308  30f5		       4a		      lsr
    309  30f6		       4a		      lsr
    310  30f7		       4a		      lsr
    311  30f8		       29 03		      and	#3
    312  30fa		       18		      clc
    313  30fb		       69 c0		      adc	#$C0	;COLOUR_LINE_1
    314  30fd
    315  30fd		       85 46	   .writeCursorCol sta	COLUP0
    316  30ff		       60		      rts
    317  3100
    318  3100
    319  3100							;---------------------------------------------------------------------------------------------------
    320  3100
    321  3100							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    322  3100							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    323  3100
      0  3100					      ALLOCATE	JoyCombined, 16
      0  3100					      OPTIONAL_PAGEBREAK	"Table", 16
     12  3100					      LIST	ON
      0  3100					      DEF	JoyCombined
      1  3100				   BANK_JoyCombined SET	_CURRENT_BANK
      2  3100				   JoyCombined
      3  3100				   TEMPORARY_VAR SET	Overlay
      4  3100				   TEMPORARY_OFFSET SET	0
      5  3100				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      6  3100				   FUNCTION_NAME SET	JoyCombined
      7  3100					      SUBROUTINE
    325  3100		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    326  3110
      0  3110					      ALLOCATE	JoyMoveCursor, 16
      0  3110					      OPTIONAL_PAGEBREAK	"Table", 16
     12  3110					      LIST	ON
      0  3110					      DEF	JoyMoveCursor
      1  3110				   BANK_JoyMoveCursor SET	_CURRENT_BANK
      2  3110				   JoyMoveCursor
      3  3110				   TEMPORARY_VAR SET	Overlay
      4  3110				   TEMPORARY_OFFSET SET	0
      5  3110				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      6  3110				   FUNCTION_NAME SET	JoyMoveCursor
      7  3110					      SUBROUTINE
    328  3110		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    329  3120
    330  3120
    331  3120							;---------------------------------------------------------------------------------------------------
    332  3120
      0  3120					      DEF	aiStartSquareSelected
      1  3120				   BANK_aiStartSquareSelected SET	_CURRENT_BANK
      2  3120				   aiStartSquareSelected
      3  3120				   TEMPORARY_VAR SET	Overlay
      4  3120				   TEMPORARY_OFFSET SET	0
      5  3120				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      6  3120				   FUNCTION_NAME SET	aiStartSquareSelected
      7  3120					      SUBROUTINE
    334  3120					      SUBROUTINE
    335  3120
      0  3120					      REFER	AiStateMachine
      1  3120				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3120				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3120					      ENDIF
      0  3120					      VEND	aiStartSquareSelected
      1  3120				  -	      IFNCONST	aiStartSquareSelected
      2  3120				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  3120				  -	      ERR
      4  3120					      ENDIF
      5  3120		       00 a2	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    338  3120
    339  3120
    340  3120							; Mark all the valid moves for the selected piece on the board
    341  3120							; and then start pulsing the piece
    342  3120							; AND start choosing for selection of TO square
    343  3120
    344  3120							; Iterate the movelist and for all from squares which = drawPieceNumber
    345  3120							; then draw a BLANK at that square
    346  3120							; do 1 by one, when none found then increment state
    347  3120
    348  3120		       a5 88		      lda	cursorX12
    349  3122		       85 80		      sta	squareToDraw
    350  3124
    351  3124		       a9 0a		      lda	#10
    352  3126		       85 8d		      sta	aiFlashDelay
    353  3128
    354  3128		       a9 00		      lda	#0
    355  312a		       85 86		      sta	toX12	;aiToSquareX12
    356  312c		       85 8f		      sta	aiFlashPhase	; for debounce exit timing
    357  312e
    358  312e		       a9 ff		      lda	#-1
    359  3130		       85 8e		      sta	aiMoveIndex
    360  3132
    361  3132		       a9 28		      lda	#HOLD_DELAY
    362  3134		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    363  3136
      0  3136					      PHASE	AI_DrawMoves
      1  3136		       a9 03		      lda	#AI_DrawMoves
      2  3138		       85 8c		      sta	aiState
    365  313a		       60		      rts
    366  313b
    367  313b
    368  313b							;---------------------------------------------------------------------------------------------------
    369  313b
      0  313b					      DEF	aiDrawMoves
      1  313b				   BANK_aiDrawMoves SET	_CURRENT_BANK
      2  313b				   aiDrawMoves
      3  313b				   TEMPORARY_VAR SET	Overlay
      4  313b				   TEMPORARY_OFFSET SET	0
      5  313b				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      6  313b				   FUNCTION_NAME SET	aiDrawMoves
      7  313b					      SUBROUTINE
    371  313b					      SUBROUTINE
    372  313b
      0  313b					      REFER	AiStateMachine
      1  313b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  313b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  313b					      ENDIF
      0  313b					      VEND	aiDrawMoves
      1  313b				  -	      IFNCONST	aiDrawMoves
      2  313b				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  313b				  -	      ERR
      4  313b					      ENDIF
      5  313b		       00 a2	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    375  313b
    376  313b		       c6 8a		      dec	ccur
    377  313d		       20 ed f0 	      jsr	setCursorColours
    378  3140
    379  3140		       c6 89		      dec	mdelay
    380  3142		       d0 21		      bne	.exit
    381  3144		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    382  3146		       85 89		      sta	mdelay	; once triggered, runs always
    383  3148
    384  3148		       a5 8e		      lda	aiMoveIndex
    385  314a		       10 05		      bpl	.valid
    386  314c		       20 93 fd 	      jsr	SAFE_getMoveIndex
    387  314f		       85 8e		      sta	aiMoveIndex
    388  3151				   .valid
    389  3151
    390  3151		       20 72 f1 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    391  3154		       a5 8e		      lda	aiMoveIndex
    392  3156		       10 19		      bpl	.unsure	; still drawing in this phase
    393  3158
    394  3158		       a9 14		      lda	#CAP_SPEED
    395  315a		       85 89		      sta	mdelay
    396  315c
    397  315c		       a9 00		      lda	#0
    398  315e		       85 8f		      sta	aiFlashPhase	; controls odd/even exit of flashing
    399  3160
      0  3160					      PHASE	AI_ShowP_MoveCaptures
      1  3160		       a9 04		      lda	#AI_ShowP_MoveCaptures
      2  3162		       85 8c		      sta	aiState
    401  3164		       60		      rts
    402  3165
    403  3165				   .exit
    404  3165
    405  3165							; Initial piece selection has happened, but the button hasn't been released yet
    406  3165							; AND we're still in the waiting phase to see if the button was held long enough for move show
    407  3165
    408  3165		       a5 4c		      lda	INPT4
    409  3167		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    410  3169
    411  3169							; Aha! Button released, so we know the selected piece and can start flashing it
    412  3169							; and allowing movement of the selector to a destination square...
    413  3169
    414  3169		       a9 18		      lda	#6*4
    415  316b		       85 8a		      sta	ccur	; bright green square for selection
    416  316d
      0  316d					      PHASE	AI_SelectDestinationSquare
      1  316d		       a9 07		      lda	#AI_SelectDestinationSquare
      2  316f		       85 8c		      sta	aiState
    418  3171
    419  3171		       60	   .unsure    rts
    420  3172
    421  3172
    422  3172							;---------------------------------------------------------------------------------------------------
    423  3172
      0  3172					      DEF	SAFE_showMoveOptions
      1  3172				   BANK_SAFE_showMoveOptions SET	_CURRENT_BANK
      2  3172				   SAFE_showMoveOptions
      3  3172				   TEMPORARY_VAR SET	Overlay
      4  3172				   TEMPORARY_OFFSET SET	0
      5  3172				   VAR_BOUNDARY_SAFE_showMoveOptions SET	TEMPORARY_OFFSET
      6  3172				   FUNCTION_NAME SET	SAFE_showMoveOptions
      7  3172					      SUBROUTINE
    425  3172					      SUBROUTINE
    426  3172
      0  3172					      REFER	aiDrawMoves
      1  3172				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  3172				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  3172					      ENDIF
      0  3172					      REFER	aiUnDrawTargetSquares
      1  3172				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  3172				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  3172					      ENDIF
      0  3172					      VAR	__saveIdx, 1
      1  3172		       00 a2	   __saveIdx  =	TEMPORARY_VAR
      2  3172				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3172
      4  3172				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3172				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3172				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3172					      ENDIF
      8  3172				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3172				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  3172				  -	      ERR
     11  3172					      ENDIF
     12  3172					      LIST	ON
      0  3172					      VAR	__piece, 1
      1  3172		       00 a3	   __piece    =	TEMPORARY_VAR
      2  3172				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3172
      4  3172				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3172				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3172				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3172					      ENDIF
      8  3172				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3172				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  3172				  -	      ERR
     11  3172					      ENDIF
     12  3172					      LIST	ON
      0  3172					      VEND	SAFE_showMoveOptions
      1  3172				  -	      IFNCONST	SAFE_showMoveOptions
      2  3172				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveOptions
      3  3172				  -	      ERR
      4  3172					      ENDIF
      5  3172		       00 a4	   VAREND_SAFE_showMoveOptions =	TEMPORARY_VAR
    432  3172
    433  3172							; place a marker on the board for any square matching the piece
    434  3172							; EXCEPT for squares which are occupied (we'll flash those later)
    435  3172
    436  3172		       a6 8e	   .next      ldx	aiMoveIndex
    437  3174		       86 a2		      stx	__saveIdx
    438  3176		       30 47		      bmi	.skip
    439  3178
    440  3178		       ad 84 02 	      lda	INTIM
    441  317b		       c9 05		      cmp	#5
    442  317d		       90 40		      bcc	.skip
    443  317f
    444  317f		       c6 8e		      dec	aiMoveIndex
    445  3181
    446  3181		       20 cf fd 	      jsr	GetP_MoveFrom
    447  3184		       c5 85		      cmp	fromX12
    448  3186		       d0 ea		      bne	.next
    449  3188
    450  3188		       20 db fd 	      jsr	GetP_MoveTo
    451  318b		       85 80		      sta	squareToDraw
    452  318d
    453  318d		       20 e7 fd 	      jsr	GetP_MovePiece
    454  3190		       85 a3		      sta	__piece
    455  3192
    456  3192							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    457  3192
    458  3192		       ca	   .sk	      dex
    459  3193		       30 16		      bmi	.prom
    460  3195		       20 db fd 	      jsr	GetP_MoveTo
    461  3198		       c5 80		      cmp	squareToDraw
    462  319a		       d0 0f		      bne	.prom
    463  319c		       20 e7 fd 	      jsr	GetP_MovePiece
    464  319f		       45 a3		      eor	__piece
    465  31a1		       29 0f		      and	#PIECE_MASK
    466  31a3		       f0 06		      beq	.prom	; same piece type so not a promote
    467  31a5
    468  31a5		       c6 8e		      dec	aiMoveIndex
    469  31a7		       c6 8e		      dec	aiMoveIndex
    470  31a9		       c6 8e		      dec	aiMoveIndex
    471  31ab				   .prom
    472  31ab
    473  31ab		       a4 80		      ldy	squareToDraw
    474  31ad		       20 e7 fc 	      jsr	GetBoard
    475  31b0		       29 0f		      and	#PIECE_MASK
    476  31b2		       d0 be		      bne	.next	; don't draw dots on captures - they are flashed later
    477  31b4
    478  31b4
    479  31b4		       ad 84 02 	      lda	INTIM
    480  31b7		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    481  31b9		       90 04		      bcc	.skip
    482  31bb
    483  31bb							;lda aiMoveIndex
    484  31bb							;sta __saveIdx
    485  31bb
    486  31bb		       20 9f fd 	      jsr	markerDraw
    487  31be		       60		      rts
    488  31bf
    489  31bf		       a5 a2	   .skip      lda	__saveIdx
    490  31c1		       85 8e		      sta	aiMoveIndex
    491  31c3		       60		      rts
    492  31c4
    493  31c4
    494  31c4							;---------------------------------------------------------------------------------------------------
    495  31c4
      0  31c4					      DEF	aiUnDrawTargetSquares
      1  31c4				   BANK_aiUnDrawTargetSquares SET	_CURRENT_BANK
      2  31c4				   aiUnDrawTargetSquares
      3  31c4				   TEMPORARY_VAR SET	Overlay
      4  31c4				   TEMPORARY_OFFSET SET	0
      5  31c4				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      6  31c4				   FUNCTION_NAME SET	aiUnDrawTargetSquares
      7  31c4					      SUBROUTINE
    497  31c4					      SUBROUTINE
    498  31c4
      0  31c4					      REFER	AiStateMachine
      1  31c4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  31c4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  31c4					      ENDIF
      0  31c4					      VEND	aiUnDrawTargetSquares
      1  31c4				  -	      IFNCONST	aiUnDrawTargetSquares
      2  31c4				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  31c4				  -	      ERR
      4  31c4					      ENDIF
      5  31c4		       00 a2	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    501  31c4
    502  31c4
    503  31c4		       c6 8a		      dec	ccur
    504  31c6		       20 ed f0 	      jsr	setCursorColours
    505  31c9
    506  31c9		       c6 89		      dec	mdelay
    507  31cb		       d0 18		      bne	.exit
    508  31cd		       a9 01		      lda	#1
    509  31cf		       85 89		      sta	mdelay	; once triggered, runs always
    510  31d1
    511  31d1		       a5 8e		      lda	aiMoveIndex
    512  31d3		       10 05		      bpl	.valid
    513  31d5		       20 93 fd 	      jsr	SAFE_getMoveIndex
    514  31d8		       85 8e		      sta	aiMoveIndex
    515  31da				   .valid
    516  31da
    517  31da		       20 72 f1 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    518  31dd		       a5 8e		      lda	aiMoveIndex
    519  31df		       10 04		      bpl	.exit	; still drawing in this phase
    520  31e1
      0  31e1					      PHASE	AI_SelectStartSquare
      1  31e1		       a9 01		      lda	#AI_SelectStartSquare
      2  31e3		       85 8c		      sta	aiState
    522  31e5
    523  31e5		       60	   .exit      rts
    524  31e6
    525  31e6
    526  31e6							;---------------------------------------------------------------------------------------------------
    527  31e6
    528  31e6
      0  31e6					      DEF	aiShowP_MoveCaptures
      1  31e6				   BANK_aiShowP_MoveCaptures SET	_CURRENT_BANK
      2  31e6				   aiShowP_MoveCaptures
      3  31e6				   TEMPORARY_VAR SET	Overlay
      4  31e6				   TEMPORARY_OFFSET SET	0
      5  31e6				   VAR_BOUNDARY_aiShowP_MoveCaptures SET	TEMPORARY_OFFSET
      6  31e6				   FUNCTION_NAME SET	aiShowP_MoveCaptures
      7  31e6					      SUBROUTINE
    530  31e6					      SUBROUTINE
    531  31e6
      0  31e6					      REFER	AiStateMachine
      1  31e6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  31e6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  31e6					      ENDIF
      0  31e6					      VEND	aiShowP_MoveCaptures
      1  31e6				  -	      IFNCONST	aiShowP_MoveCaptures
      2  31e6				  -	      ECHO	"Incorrect VEND label", aiShowP_MoveCaptures
      3  31e6				  -	      ERR
      4  31e6					      ENDIF
      5  31e6		       00 a2	   VAREND_aiShowP_MoveCaptures =	TEMPORARY_VAR
    534  31e6
    535  31e6							; draw/undraw ALL captured pieces
    536  31e6							; we should do this an even number of times so that pieces don't disappEOR
    537  31e6
    538  31e6		       c6 8a		      dec	ccur
    539  31e8		       20 ed f0 	      jsr	setCursorColours
    540  31eb
    541  31eb		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    542  31ed
    543  31ed		       a5 8e		      lda	aiMoveIndex
    544  31ef		       10 05		      bpl	.valid	; guaranteed -1 on 1st call
    545  31f1		       20 93 fd 	      jsr	SAFE_getMoveIndex
    546  31f4		       85 8e		      sta	aiMoveIndex
    547  31f6				   .valid
    548  31f6
    549  31f6		       20 c3 fd 	      jsr	SAFE_showP_MoveCaptures
    550  31f9		       a5 8e		      lda	aiMoveIndex
    551  31fb		       10 06		      bpl	.exit
    552  31fd
    553  31fd		       e6 8f		      inc	aiFlashPhase
    554  31ff
      0  31ff					      PHASE	AI_SlowFlash
      1  31ff		       a9 05		      lda	#AI_SlowFlash
      2  3201		       85 8c		      sta	aiState
    556  3203
    557  3203		       60	   .exit      rts
    558  3204
    559  3204
    560  3204							;---------------------------------------------------------------------------------------------------
    561  3204
      0  3204					      DEF	aiSlowFlash
      1  3204				   BANK_aiSlowFlash SET	_CURRENT_BANK
      2  3204				   aiSlowFlash
      3  3204				   TEMPORARY_VAR SET	Overlay
      4  3204				   TEMPORARY_OFFSET SET	0
      5  3204				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      6  3204				   FUNCTION_NAME SET	aiSlowFlash
      7  3204					      SUBROUTINE
    563  3204					      SUBROUTINE
    564  3204
      0  3204					      REFER	AiStateMachine
      1  3204				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3204				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3204					      ENDIF
      0  3204					      VEND	aiSlowFlash
      1  3204				  -	      IFNCONST	aiSlowFlash
      2  3204				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  3204				  -	      ERR
      4  3204					      ENDIF
      5  3204		       00 a2	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    567  3204
    568  3204							; Joystick button is held down, so we're displaying the available moves
    569  3204							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    570  3204
    571  3204		       c6 8a		      dec	ccur
    572  3206		       20 ed f0 	      jsr	setCursorColours
    573  3209
    574  3209		       a5 8f		      lda	aiFlashPhase
    575  320b		       29 01		      and	#1
    576  320d		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    577  320f
    578  320f		       a5 4c		      lda	INPT4
    579  3211		       30 0d		      bmi	.butpress	; exit on button release
    580  3213
    581  3213				   .notEven
    582  3213
    583  3213							; Wait for delay to expire then back and flash 'em again
    584  3213
    585  3213		       c6 89		      dec	mdelay
    586  3215		       10 08		      bpl	.slowWait
    587  3217
    588  3217		       a9 14		      lda	#CAP_SPEED
    589  3219		       85 89		      sta	mdelay
    590  321b
      0  321b					      PHASE	AI_ShowP_MoveCaptures	; go back and rEORdraw all captures again
      1  321b		       a9 04		      lda	#AI_ShowP_MoveCaptures
      2  321d		       85 8c		      sta	aiState
    592  321f
    593  321f		       60	   .slowWait  rts
    594  3220
    595  3220
    596  3220		       a9 01	   .butpress  lda	#1
    597  3222		       85 89		      sta	mdelay
    598  3224
      0  3224					      PHASE	AI_UnDrawTargetSquares
      1  3224		       a9 06		      lda	#AI_UnDrawTargetSquares
      2  3226		       85 8c		      sta	aiState
    600  3228		       60		      rts
    601  3229
    602  3229
    603  3229							;---------------------------------------------------------------------------------------------------
    604  3229
      0  3229					      DEF	moveCursor
      1  3229				   BANK_moveCursor SET	_CURRENT_BANK
      2  3229				   moveCursor
      3  3229				   TEMPORARY_VAR SET	Overlay
      4  3229				   TEMPORARY_OFFSET SET	0
      5  3229				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      6  3229				   FUNCTION_NAME SET	moveCursor
      7  3229					      SUBROUTINE
    606  3229					      SUBROUTINE
    607  3229
      0  3229					      REFER	aiSelectStartSquare
      1  3229				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  3229				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  3229					      ENDIF
      0  3229					      REFER	aiSelectDestinationSquare
      1  3229				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  3229				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  3229					      ENDIF
      0  3229					      VAR	__newCursor, 1
      1  3229		       00 a2	   __newCursor =	TEMPORARY_VAR
      2  3229				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3229
      4  3229				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3229				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3229				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3229					      ENDIF
      8  3229				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3229				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  3229				  -	      ERR
     11  3229					      ENDIF
     12  3229					      LIST	ON
      0  3229					      VEND	moveCursor
      1  3229				  -	      IFNCONST	moveCursor
      2  3229				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  3229				  -	      ERR
      4  3229					      ENDIF
      5  3229		       00 a3	   VAREND_moveCursor =	TEMPORARY_VAR
    612  3229
    613  3229							; Part (a) move cursor around the board waiting for joystick press
    614  3229
    615  3229
    616  3229		       ad 80 02 	      lda	SWCHA
    617  322c		       4a		      lsr
    618  322d		       4a		      lsr
    619  322e		       4a		      lsr
    620  322f		       4a		      lsr
    621  3230		       a8		      tay
    622  3231
    623  3231		       c9 0f		      cmp	#15
    624  3233		       f0 20		      beq	.cursor	; nothing pressed - skip delays
    625  3235
    626  3235		       c6 89		      dec	mdelay
    627  3237		       10 23		      bpl	.delaym
    628  3239
    629  3239		       18		      clc
    630  323a		       a5 88		      lda	cursorX12
    631  323c		       79 10 f1 	      adc	JoyMoveCursor,y
    632  323f		       85 a2		      sta	__newCursor
    633  3241		       a8		      tay
    634  3242		       20 db fc 	      jsr	GetValid
    635  3245		       c9 ff		      cmp	#-1
    636  3247		       f0 04		      beq	.invalid
    637  3249		       a5 a2		      lda	__newCursor
    638  324b		       85 88		      sta	cursorX12
    639  324d				   .invalid
    640  324d
    641  324d		       a9 10		      lda	#CURSOR_MOVE_SPEED
    642  324f		       85 89		      sta	mdelay
    643  3251		       20 d7 f0 	      jsr	setCursorPriority
    644  3254		       60		      rts
    645  3255
    646  3255
    647  3255		       a9 00	   .cursor    lda	#0
    648  3257		       85 89		      sta	mdelay
    649  3259		       20 d7 f0 	      jsr	setCursorPriority
    650  325c
    651  325c		       60	   .delaym    rts
    652  325d
    653  325d
    654  325d							;---------------------------------------------------------------------------------------------------
    655  325d
      0  325d					      DEF	FlashPiece
      1  325d				   BANK_FlashPiece SET	_CURRENT_BANK
      2  325d				   FlashPiece
      3  325d				   TEMPORARY_VAR SET	Overlay
      4  325d				   TEMPORARY_OFFSET SET	0
      5  325d				   VAR_BOUNDARY_FlashPiece SET	TEMPORARY_OFFSET
      6  325d				   FUNCTION_NAME SET	FlashPiece
      7  325d					      SUBROUTINE
    657  325d					      SUBROUTINE
    658  325d
      0  325d					      REFER	aiSelectDestinationSquare
      1  325d				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  325d				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  325d					      ENDIF
      0  325d					      VEND	FlashPiece
      1  325d				  -	      IFNCONST	FlashPiece
      2  325d				  -	      ECHO	"Incorrect VEND label", FlashPiece
      3  325d				  -	      ERR
      4  325d					      ENDIF
      5  325d		       00 a2	   VAREND_FlashPiece =	TEMPORARY_VAR
    661  325d
    662  325d							; Flash the selected piece
    663  325d
    664  325d		       c6 8d		      dec	aiFlashDelay
    665  325f		       d0 09		      bne	.exit	; don't flash
    666  3261		       a9 14		      lda	#CAP_SPEED
    667  3263		       85 8d		      sta	aiFlashDelay
    668  3265
    669  3265		       e6 8f		      inc	aiFlashPhase
    670  3267
    671  3267		       20 57 fd 	      jsr	CopySinglePiece
    672  326a
    673  326a		       60	   .exit      rts
    674  326b
    675  326b
    676  326b							;---------------------------------------------------------------------------------------------------
    677  326b
      0  326b					      DEF	aiSelectDestinationSquare
      1  326b				   BANK_aiSelectDestinationSquare SET	_CURRENT_BANK
      2  326b				   aiSelectDestinationSquare
      3  326b				   TEMPORARY_VAR SET	Overlay
      4  326b				   TEMPORARY_OFFSET SET	0
      5  326b				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      6  326b				   FUNCTION_NAME SET	aiSelectDestinationSquare
      7  326b					      SUBROUTINE
    679  326b					      SUBROUTINE
    680  326b
      0  326b					      REFER	AiStateMachine
      1  326b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  326b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  326b					      ENDIF
      0  326b					      VEND	aiSelectDestinationSquare
      1  326b				  -	      IFNCONST	aiSelectDestinationSquare
      2  326b				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  326b				  -	      ERR
      4  326b					      ENDIF
      5  326b		       00 a2	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    683  326b
    684  326b							; Piece is selected and now we're looking for a button press on a destination square
    685  326b							; we flash the piece on-and-off while we're doing that
    686  326b
    687  326b		       20 5d f2 	      jsr	FlashPiece
    688  326e
      0  326e					      NEXT_RANDOM
      1  326e		       a5 81		      lda	rnd
      2  3270		       4a		      lsr
      3  3271		       90 02		      bcc	.skipEOR
      4  3273		       49 fe		      eor	#RND_EOR_VAL
      5  3275		       85 81	   .skipEOR   sta	rnd
    690  3277
    691  3277		       ad 84 02 	      lda	INTIM
    692  327a		       c9 14		      cmp	#20
    693  327c		       90 38		      bcc	.noButton
    694  327e
    695  327e		       20 29 f2 	      jsr	moveCursor
    696  3281
    697  3281		       a4 88		      ldy	cursorX12
    698  3283		       84 86		      sty	toX12
    699  3285
    700  3285		       20 1b fd 	      jsr	GetPiece
    701  3288		       20 ed f0 	      jsr	setCursorColours
    702  328b
    703  328b
    704  328b							; y = valid square
    705  328b
    706  328b		       a5 4c		      lda	INPT4
    707  328d		       30 27		      bmi	.noButton
    708  328f
    709  328f		       a5 86		      lda	toX12
    710  3291		       c5 85		      cmp	fromX12
    711  3293		       f0 0d		      beq	.cancel
    712  3295
    713  3295		       c0 ff		      cpy	#-1
    714  3297		       f0 1d		      beq	.noButton	; not a valid square
    715  3299
    716  3299		       a5 8f		      lda	aiFlashPhase
    717  329b		       29 01		      and	#1
    718  329d		       f0 13		      beq	.done
    719  329f		       85 8d		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    720  32a1		       60		      rts
    721  32a2
    722  32a2				   .cancel
    723  32a2
    724  32a2		       a5 8f		      lda	aiFlashPhase
    725  32a4		       29 01		      and	#1
    726  32a6		       f0 05		      beq	.doCancel
    727  32a8
    728  32a8							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    729  32a8
    730  32a8		       a9 01		      lda	#1
    731  32aa		       85 8d		      sta	aiFlashDelay
    732  32ac		       60		      rts
    733  32ad
    734  32ad
      0  32ad				   .doCancel  PHASE	AI_ReselectDebounce
      1  32ad		       a9 09		      lda	#AI_ReselectDebounce
      2  32af		       85 8c		      sta	aiState
    736  32b1		       60		      rts
    737  32b2
      0  32b2				   .done      PHASE	AI_Quiescent	; destination selected!
      1  32b2		       a9 08		      lda	#AI_Quiescent
      2  32b4		       85 8c		      sta	aiState
    739  32b6		       60	   .noButton  rts
    740  32b7
    741  32b7
    742  32b7							;---------------------------------------------------------------------------------------------------
    743  32b7
      0  32b7					      DEF	aiReselectDebounce
      1  32b7				   BANK_aiReselectDebounce SET	_CURRENT_BANK
      2  32b7				   aiReselectDebounce
      3  32b7				   TEMPORARY_VAR SET	Overlay
      4  32b7				   TEMPORARY_OFFSET SET	0
      5  32b7				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      6  32b7				   FUNCTION_NAME SET	aiReselectDebounce
      7  32b7					      SUBROUTINE
    745  32b7					      SUBROUTINE
    746  32b7
      0  32b7					      REFER	AiStateMachine
      1  32b7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  32b7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  32b7					      ENDIF
      0  32b7					      VEND	aiReselectDebounce
      1  32b7				  -	      IFNCONST	aiReselectDebounce
      2  32b7				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  32b7				  -	      ERR
      4  32b7					      ENDIF
      5  32b7		       00 a2	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    749  32b7
    750  32b7							; We've just cancelled the move. Wait for the button to be released
    751  32b7							; and then go back to selecting a piece to move
    752  32b7
    753  32b7		       a5 4c		      lda	INPT4
    754  32b9		       10 04		      bpl	.exit	; button still pressed, so wait
    755  32bb
      0  32bb					      PHASE	AI_SelectStartSquare
      1  32bb		       a9 01		      lda	#AI_SelectStartSquare
      2  32bd		       85 8c		      sta	aiState
    757  32bf		       60	   .exit      rts
    758  32c0
    759  32c0
    760  32c0							;---------------------------------------------------------------------------------------------------
    761  32c0
      0  32c0					      DEF	aiQuiescent
      1  32c0				   BANK_aiQuiescent SET	_CURRENT_BANK
      2  32c0				   aiQuiescent
      3  32c0				   TEMPORARY_VAR SET	Overlay
      4  32c0				   TEMPORARY_OFFSET SET	0
      5  32c0				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      6  32c0				   FUNCTION_NAME SET	aiQuiescent
      7  32c0					      SUBROUTINE
    763  32c0					      SUBROUTINE
    764  32c0
      0  32c0					      REFER	AiStateMachine
      1  32c0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  32c0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  32c0					      ENDIF
      0  32c0					      VEND	aiQuiescent
      1  32c0				  -	      IFNCONST	aiQuiescent
      2  32c0				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  32c0				  -	      ERR
      4  32c0					      ENDIF
      5  32c0		       00 a2	   VAREND_aiQuiescent =	TEMPORARY_VAR
    767  32c0
    768  32c0							; Move has been selected
    769  32c0
    770  32c0		       a9 ff		      lda	#-1
    771  32c2		       85 88		      sta	cursorX12
    772  32c4
    773  32c4		       a5 85		      lda	fromX12
    774  32c6		       85 87		      sta	originX12
    775  32c8		       20 1b fd 	      jsr	GetPiece	; from the movelist
    776  32cb
    777  32cb		       a4 85		      ldy	fromX12
    778  32cd		       20 e7 fc 	      jsr	GetBoard	; get the piece from the board itself
    779  32d0
    780  32d0		       45 98		      eor	fromPiece
    781  32d2		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    782  32d4		       d0 05		      bne	.promote	; promote a pawn
    783  32d6
      0  32d6					      PHASE	AI_MoveIsSelected
      1  32d6		       a9 15		      lda	#AI_MoveIsSelected
      2  32d8		       85 8c		      sta	aiState
    785  32da		       60		      rts
    786  32db
      0  32db				   .promote   PHASE	AI_PromotePawnStart
      1  32db		       a9 1f		      lda	#AI_PromotePawnStart
      2  32dd		       85 8c		      sta	aiState
    788  32df		       60		      rts
    789  32e0
    790  32e0
    791  32e0							;---------------------------------------------------------------------------------------------------
    792  32e0
      0  32e0					      DEF	aiPromotePawnStart
      1  32e0				   BANK_aiPromotePawnStart SET	_CURRENT_BANK
      2  32e0				   aiPromotePawnStart
      3  32e0				   TEMPORARY_VAR SET	Overlay
      4  32e0				   TEMPORARY_OFFSET SET	0
      5  32e0				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      6  32e0				   FUNCTION_NAME SET	aiPromotePawnStart
      7  32e0					      SUBROUTINE
    794  32e0					      SUBROUTINE
    795  32e0
      0  32e0					      REFER	AiStateMachine
      1  32e0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  32e0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  32e0					      ENDIF
      0  32e0					      VEND	aiPromotePawnStart
      1  32e0				  -	      IFNCONST	aiPromotePawnStart
      2  32e0				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  32e0				  -	      ERR
      4  32e0					      ENDIF
      5  32e0		       00 a2	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    798  32e0
    799  32e0
    800  32e0		       ad 84 02 	      lda	INTIM
    801  32e3		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    802  32e5		       90 18		      bcc	.exit
    803  32e7
    804  32e7		       a9 00		      lda	#0
    805  32e9		       85 8f		      sta	aiFlashPhase
    806  32eb		       85 8d		      sta	aiFlashDelay
    807  32ed
    808  32ed		       a4 86		      ldy	toX12
    809  32ef		       84 80		      sty	squareToDraw
    810  32f1
    811  32f1		       20 e7 fc 	      jsr	GetBoard
    812  32f4		       29 0f		      and	#PIECE_MASK
    813  32f6		       f0 03		      beq	.empty
    814  32f8
    815  32f8		       20 57 fd 	      jsr	CopySinglePiece	; remove any capturable piece for display purposes
    816  32fb
      0  32fb				   .empty     PHASE	AI_RollPromotionPiece
      1  32fb		       a9 20		      lda	#AI_RollPromotionPiece
      2  32fd		       85 8c		      sta	aiState
    818  32ff		       60	   .exit      rts
    819  3300
    820  3300
    821  3300							;---------------------------------------------------------------------------------------------------
    822  3300
      0  3300					      DEF	aiRollPromotionPiece
      1  3300				   BANK_aiRollPromotionPiece SET	_CURRENT_BANK
      2  3300				   aiRollPromotionPiece
      3  3300				   TEMPORARY_VAR SET	Overlay
      4  3300				   TEMPORARY_OFFSET SET	0
      5  3300				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      6  3300				   FUNCTION_NAME SET	aiRollPromotionPiece
      7  3300					      SUBROUTINE
    824  3300					      SUBROUTINE
    825  3300
      0  3300					      REFER	AiStateMachine
      1  3300				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3300				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3300					      ENDIF
      0  3300					      VEND	aiRollPromotionPiece
      1  3300				  -	      IFNCONST	aiRollPromotionPiece
      2  3300				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  3300				  -	      ERR
      4  3300					      ENDIF
      5  3300		       00 a2	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    828  3300
    829  3300							; Flash the '?' and wait for an UDLR move
    830  3300
    831  3300		       ad 84 02 	      lda	INTIM
    832  3303		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    833  3305		       90 28		      bcc	.exit
    834  3307
    835  3307		       ad 80 02 	      lda	SWCHA
    836  330a		       29 f0		      and	#$F0
    837  330c		       c9 f0		      cmp	#$F0
    838  330e		       f0 0a		      beq	.nojoy
    839  3310
    840  3310		       a9 00		      lda	#0
    841  3312		       85 8d		      sta	aiFlashDelay
    842  3314
    843  3314		       a5 8f		      lda	aiFlashPhase
    844  3316		       29 01		      and	#1
    845  3318		       f0 16		      beq	.even
    846  331a
    847  331a		       c6 8d	   .nojoy     dec	aiFlashDelay
    848  331c		       10 11		      bpl	.exit
    849  331e
    850  331e		       a9 0a		      lda	#10
    851  3320		       85 8d		      sta	aiFlashDelay
    852  3322
    853  3322		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    854  3324		       a5 97		      lda	sideToMove
    855  3326		       10 02		      bpl	.wtm
    856  3328		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    857  332a				   .wtm
    858  332a		       20 ab fd 	      jsr	showPromoteOptions
    859  332d
    860  332d		       e6 8f		      inc	aiFlashPhase
    861  332f
    862  332f		       60	   .exit      rts
    863  3330
    864  3330
    865  3330		       a9 03	   .even      lda	#3	; QUEEN
    866  3332		       85 98		      sta	fromPiece	; cycles as index to NBRQ
    867  3334
    868  3334		       e6 8f		      inc	aiFlashPhase
    869  3336
    870  3336
    871  3336		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    872  3338		       a5 97		      lda	sideToMove
    873  333a		       10 02		      bpl	.whiteToMove
    874  333c		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    875  333e				   .whiteToMove
    876  333e
    877  333e		       20 ab fd 	      jsr	showPromoteOptions
    878  3341
      0  3341					      PHASE	AI_ChooseDebounce
      1  3341		       a9 22		      lda	#AI_ChooseDebounce
      2  3343		       85 8c		      sta	aiState
    880  3345		       60		      rts
    881  3346
    882  3346
    883  3346							;---------------------------------------------------------------------------------------------------
    884  3346
      0  3346					      DEF	aiChoosePromotePiece
      1  3346				   BANK_aiChoosePromotePiece SET	_CURRENT_BANK
      2  3346				   aiChoosePromotePiece
      3  3346				   TEMPORARY_VAR SET	Overlay
      4  3346				   TEMPORARY_OFFSET SET	0
      5  3346				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      6  3346				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  3346					      SUBROUTINE
    886  3346					      SUBROUTINE
    887  3346
      0  3346					      REFER	AiStateMachine
      1  3346				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3346				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3346					      ENDIF
      0  3346					      VEND	aiChoosePromotePiece
      1  3346				  -	      IFNCONST	aiChoosePromotePiece
      2  3346				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  3346				  -	      ERR
      4  3346					      ENDIF
      5  3346		       00 a2	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
    890  3346
    891  3346							; Question-mark phase has exited via joystick direction
    892  3346							; Now we cycle through the selectable pieces
    893  3346
    894  3346		       ad 84 02 	      lda	INTIM
    895  3349		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    896  334b		       90 40		      bcc	.exit
    897  334d
    898  334d		       a5 4c		      lda	INPT4
    899  334f		       30 0a		      bmi	.nobut	; no press
    900  3351
    901  3351							; button pressed but make sure phase is correct for exit
    902  3351
    903  3351		       a9 00		      lda	#0
    904  3353		       85 8d		      sta	aiFlashDelay
    905  3355
    906  3355		       a5 8f		      lda	aiFlashPhase
    907  3357		       29 01		      and	#1
    908  3359		       f0 33		      beq	.chosen	; button pressed --> selection made
    909  335b
    910  335b				   .nobut
    911  335b		       ad 80 02 	      lda	SWCHA
    912  335e		       29 f0		      and	#$F0
    913  3360		       c9 f0		      cmp	#$F0
    914  3362		       f0 17		      beq	.odd	; no direction pressed
    915  3364
    916  3364		       4a		      lsr
    917  3365		       4a		      lsr
    918  3366		       4a		      lsr
    919  3367		       4a		      lsr
    920  3368		       a8		      tay
    921  3369
    922  3369							; joystick but make sure phase is correct
    923  3369
    924  3369		       a5 8f		      lda	aiFlashPhase
    925  336b		       4a		      lsr
    926  336c		       b0 0d		      bcs	.odd	; must wait until piece undrawn
    927  336e
    928  336e							; cycle to the next promotable piece (N/B/R/Q)
    929  336e							; TODO; use joy table for mod instead of just incrementing all the time
    930  336e
    931  336e							;clc
    932  336e		       a5 98		      lda	fromPiece
    933  3370		       79 00 f1 	      adc	JoyCombined,y
    934  3373		       29 03		      and	#3
    935  3375		       85 98		      sta	fromPiece
    936  3377
      0  3377					      PHASE	AI_ChooseDebounce	; wait for release
      1  3377		       a9 22		      lda	#AI_ChooseDebounce
      2  3379		       85 8c		      sta	aiState
    938  337b
    939  337b		       c6 8d	   .odd       dec	aiFlashDelay
    940  337d		       10 0e		      bpl	.exit
    941  337f
    942  337f		       a9 0a	   .force     lda	#10
    943  3381		       85 8d		      sta	aiFlashDelay
    944  3383
    945  3383		       e6 8f		      inc	aiFlashPhase
    946  3385
    947  3385		       a4 98		      ldy	fromPiece
    948  3387		       be a9 f3 	      ldx	promotePiece,y
    949  338a		       20 ab fd 	      jsr	showPromoteOptions
    950  338d
    951  338d		       60	   .exit      rts
    952  338e
    953  338e
    954  338e				   .chosen
    955  338e		       a5 98		      lda	fromPiece
    956  3390		       29 0f		      and	#PIECE_MASK
    957  3392		       aa		      tax
    958  3393
    959  3393		       bd ad f3 	      lda	promoteType,x
    960  3396		       85 98		      sta	fromPiece
    961  3398
    962  3398		       a4 86		      ldy	toX12
    963  339a		       20 e7 fc 	      jsr	GetBoard
    964  339d		       29 0f		      and	#PIECE_MASK
    965  339f		       f0 03		      beq	.nothing
    966  33a1
    967  33a1		       20 57 fd 	      jsr	CopySinglePiece	; put back whatever was there to start
    968  33a4
      0  33a4				   .nothing   PHASE	AI_MoveIsSelected
      1  33a4		       a9 15		      lda	#AI_MoveIsSelected
      2  33a6		       85 8c		      sta	aiState
    970  33a8		       60		      rts
    971  33a9
      0  33a9					      ALLOCATE	promotePiece, 4
      0  33a9					      OPTIONAL_PAGEBREAK	"Table", 4
     12  33a9					      LIST	ON
      0  33a9					      DEF	promotePiece
      1  33a9				   BANK_promotePiece SET	_CURRENT_BANK
      2  33a9				   promotePiece
      3  33a9				   TEMPORARY_VAR SET	Overlay
      4  33a9				   TEMPORARY_OFFSET SET	0
      5  33a9				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      6  33a9				   FUNCTION_NAME SET	promotePiece
      7  33a9					      SUBROUTINE
    973  33a9		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    974  33aa		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    975  33ab		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    976  33ac		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    977  33ad
      0  33ad					      ALLOCATE	promoteType,4
      0  33ad					      OPTIONAL_PAGEBREAK	"Table", 4
     12  33ad					      LIST	ON
      0  33ad					      DEF	promoteType
      1  33ad				   BANK_promoteType SET	_CURRENT_BANK
      2  33ad				   promoteType
      3  33ad				   TEMPORARY_VAR SET	Overlay
      4  33ad				   TEMPORARY_OFFSET SET	0
      5  33ad				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      6  33ad				   FUNCTION_NAME SET	promoteType
      7  33ad					      SUBROUTINE
    979  33ad		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    980  33b1
    981  33b1
    982  33b1							;---------------------------------------------------------------------------------------------------
    983  33b1
      0  33b1					      DEF	aiChooseDebounce
      1  33b1				   BANK_aiChooseDebounce SET	_CURRENT_BANK
      2  33b1				   aiChooseDebounce
      3  33b1				   TEMPORARY_VAR SET	Overlay
      4  33b1				   TEMPORARY_OFFSET SET	0
      5  33b1				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      6  33b1				   FUNCTION_NAME SET	aiChooseDebounce
      7  33b1					      SUBROUTINE
    985  33b1					      SUBROUTINE
    986  33b1
      0  33b1					      REFER	AiStateMachine
      1  33b1				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  33b1				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  33b1					      ENDIF
      0  33b1					      VEND	aiChooseDebounce
      1  33b1				  -	      IFNCONST	aiChooseDebounce
      2  33b1				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  33b1				  -	      ERR
      4  33b1					      ENDIF
      5  33b1		       00 a2	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    989  33b1
    990  33b1							; We've changed promotion piece, but wait for joystick to be released
    991  33b1
    992  33b1		       ad 80 02 	      lda	SWCHA
    993  33b4		       29 f0		      and	#$F0
    994  33b6		       c9 f0		      cmp	#$F0
    995  33b8		       d0 08		      bne	.exit	; wait while joystick still pressed
    996  33ba
    997  33ba		       a9 01		      lda	#1
    998  33bc		       85 8d		      sta	aiFlashDelay
    999  33be
      0  33be					      PHASE	AI_ChoosePromotePiece
      1  33be		       a9 21		      lda	#AI_ChoosePromotePiece
      2  33c0		       85 8c		      sta	aiState
   1001  33c2		       60	   .exit      rts
   1002  33c3
   1003  33c3
   1004  33c3							;---------------------------------------------------------------------------------------------------
   1005  33c3
   1006  3400		       00 00 00 00*	      align	256
      0  3400					      DEF	PositionSprites
      1  3400				   BANK_PositionSprites SET	_CURRENT_BANK
      2  3400				   PositionSprites
      3  3400				   TEMPORARY_VAR SET	Overlay
      4  3400				   TEMPORARY_OFFSET SET	0
      5  3400				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      6  3400				   FUNCTION_NAME SET	PositionSprites
      7  3400					      SUBROUTINE
   1008  3400					      SUBROUTINE
   1009  3400
      0  3400					      REFER	Reset
      1  3400				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  3400				  -TEMPORARY_VAR SET	VAREND_Reset
      3  3400					      ENDIF
      0  3400					      VEND	PositionSprites
      1  3400				  -	      IFNCONST	PositionSprites
      2  3400				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  3400				  -	      ERR
      4  3400					      ENDIF
      5  3400		       00 a2	   VAREND_PositionSprites =	TEMPORARY_VAR
   1012  3400
   1013  3400
   1014  3400		       a5 88		      lda	cursorX12
   1015  3402		       38		      sec
   1016  3403		       e9 0a	   .sub10     sbc	#10
   1017  3405		       b0 fc		      bcs	.sub10
   1018  3407		       69 08		      adc	#8
   1019  3409		       a8		      tay
   1020  340a
   1021  340a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
   1022  340c
   1023  340c		       b9 30 f4 	      lda	colToPixel,y
   1024  340f
   1025  340f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
   1026  3410		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
   1027  3412		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
   1028  3414
   1029  3414		       a8		      tay
   1030  3415		       b9 30 f3 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
   1031  3418		       85 60		      sta	HMP0
   1032  341a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
   1033  341c
   1034  341c		       85 42		      sta	WSYNC
   1035  341e		       85 6a		      sta	HMOVE
   1036  3420
   1037  3420		       60		      rts
   1038  3421
   1039  3421							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
   1040  3421							; fine adjustment value. This table is on a page boundary to guarantee the processor
   1041  3421							; will cross a page boundary and waste a cycle in order to be at the precise position
   1042  3421							; for a RESP0,x write
   1043  3421
   1044  3421				   fineAdjustBegin
   1045  3421
   1046  3421		       70		      DC.B	%01110000	; Left 7
   1047  3422		       60		      DC.B	%01100000	; Left 6
   1048  3423		       50		      DC.B	%01010000	; Left 5
   1049  3424		       40		      DC.B	%01000000	; Left 4
   1050  3425		       30		      DC.B	%00110000	; Left 3
   1051  3426		       20		      DC.B	%00100000	; Left 2
   1052  3427		       10		      DC.B	%00010000	; Left 1
   1053  3428		       00		      DC.B	%00000000	; No movement.
   1054  3429		       f0		      DC.B	%11110000	; Right 1
   1055  342a		       e0		      DC.B	%11100000	; Right 2
   1056  342b		       d0		      DC.B	%11010000	; Right 3
   1057  342c		       c0		      DC.B	%11000000	; Right 4
   1058  342d		       b0		      DC.B	%10110000	; Right 5
   1059  342e		       a0		      DC.B	%10100000	; Right 6
   1060  342f		       90		      DC.B	%10010000	; Right 7
   1061  3430
   1062  3430		       f3 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
   1063  3430
   1064  3430
      0  3430					      ALLOCATE	colToPixel, 8
      0  3430					      OPTIONAL_PAGEBREAK	"Table", 8
     12  3430					      LIST	ON
      0  3430					      DEF	colToPixel
      1  3430				   BANK_colToPixel SET	_CURRENT_BANK
      2  3430				   colToPixel
      3  3430				   TEMPORARY_VAR SET	Overlay
      4  3430				   TEMPORARY_OFFSET SET	0
      5  3430				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      6  3430				   FUNCTION_NAME SET	colToPixel
      7  3430					      SUBROUTINE
   1066  3430		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
   1067  3438
   1068  3438							;---------------------------------------------------------------------------------------------------
   1069  3438
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  3438					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  3438					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  3438					      LIST	ON
      0  3438					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  3438				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3438				   BLACK_MARKER_on_BLACK_SQUARE_0
      3  3438				   TEMPORARY_VAR SET	Overlay
      4  3438				   TEMPORARY_OFFSET SET	0
      5  3438				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3438				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      7  3438					      SUBROUTINE
      3  3438		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3450		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3468		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  3480					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  3480					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  3480					      LIST	ON
      0  3480					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  3480				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3480				   BLACK_MARKER_on_BLACK_SQUARE_1
      3  3480				   TEMPORARY_VAR SET	Overlay
      4  3480				   TEMPORARY_OFFSET SET	0
      5  3480				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3480				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      7  3480					      SUBROUTINE
      3  3480		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3498		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  34b0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  34c8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  34c8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  3500					      LIST	ON
      0  3500					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  3500				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3500				   BLACK_MARKER_on_BLACK_SQUARE_2
      3  3500				   TEMPORARY_VAR SET	Overlay
      4  3500				   TEMPORARY_OFFSET SET	0
      5  3500				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3500				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      7  3500					      SUBROUTINE
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  3548					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  3548					      LIST	ON
      0  3548					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  3548				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3548				   BLACK_MARKER_on_BLACK_SQUARE_3
      3  3548				   TEMPORARY_VAR SET	Overlay
      4  3548				   TEMPORARY_OFFSET SET	0
      5  3548				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3548				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      7  3548					      SUBROUTINE
      3  3548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3578		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  3590					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  3590					      LIST	ON
      0  3590					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  3590				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3590				   BLACK_MARKER_on_WHITE_SQUARE_0
      3  3590				   TEMPORARY_VAR SET	Overlay
      4  3590				   TEMPORARY_OFFSET SET	0
      5  3590				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3590				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      7  3590					      SUBROUTINE
      3  3590		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  35a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  35d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  3600					      LIST	ON
      0  3600					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  3600				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3600				   BLACK_MARKER_on_WHITE_SQUARE_1
      3  3600				   TEMPORARY_VAR SET	Overlay
      4  3600				   TEMPORARY_OFFSET SET	0
      5  3600				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3600				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      7  3600					      SUBROUTINE
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  3630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  3648					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  3648					      LIST	ON
      0  3648					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  3648				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3648				   BLACK_MARKER_on_WHITE_SQUARE_2
      3  3648				   TEMPORARY_VAR SET	Overlay
      4  3648				   TEMPORARY_OFFSET SET	0
      5  3648				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3648				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      7  3648					      SUBROUTINE
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  3690					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  3690					      LIST	ON
      0  3690					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  3690				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3690				   BLACK_MARKER_on_WHITE_SQUARE_3
      3  3690				   TEMPORARY_VAR SET	Overlay
      4  3690				   TEMPORARY_OFFSET SET	0
      5  3690				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3690				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      7  3690					      SUBROUTINE
      3  3690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  36a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  36c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
   1078  36d8
   1079  36d8							;---------------------------------------------------------------------------------------------------
   1080  36d8
      0  36d8					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  36d8		       06 d8	   .TEMP      =	* - BANK_START
 BANK_StateMachine (2K) SIZE =  $6d8 , FREE= $128
      2  36d8					      ECHO	"BANK_StateMachine", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  36d8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  36d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  36d8				  -	      ERR
      6  36d8					      endif
   1082  36d8
   1083  36d8
   1084  36d8							;---------------------------------------------------------------------------------------------------
   1085  36d8
   1086  36d8							; EOF
------- FILE ./chess.asm
------- FILE BANK_TEXT_OVERLAYS.asm LEVEL 2 PASS 5
      0  36d8					      include	"BANK_TEXT_OVERLAYS.asm"
      0  36d8					      NEWBANK	TEXT_OVERLAYS
      1  3802 ????				      SEG	TEXT_OVERLAYS
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   TEXT_OVERLAYS SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	TEXT_OVERLAYS
      2  3800
      3  3800
      4  3800
      5  3800
      6  3800				   sample
      7  3800		       48 aa		      .byte.b	72,%10101010
      8  3802
      9  3802
     10  3802
     11  3802							;EOF
------- FILE ./chess.asm
    581  3802
------- FILE titleScreen.asm LEVEL 2 PASS 5
      0  3802					      include	"titleScreen.asm"
      0  3802					      NEWBANK	TITLESCREEN
      1  47c0 ????				      SEG	TITLESCREEN
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   TITLESCREEN SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	TITLESCREEN
      2  4000
      3  4000				   OverscanTime2
      4  4000		       1a 1a		      .byte.b	26, 26
      5  4002		       20 20		      .byte.b	32, 32
      6  4004
      7  4004				   colvec
      8  4004		       00 f1 d8 f1	      .word.w	colr_ntsc2, colr_pal
      9  4008
     10  4008
     11  4008		       32 32	   VBlankTime .byte.b	50,50
     12  400a
      0  400a					      DEF	TitleScreen
      1  400a				   BANK_TitleScreen SET	_CURRENT_BANK
      2  400a				   TitleScreen
      3  400a				   TEMPORARY_VAR SET	Overlay
      4  400a				   TEMPORARY_OFFSET SET	0
      5  400a				   VAR_BOUNDARY_TitleScreen SET	TEMPORARY_OFFSET
      6  400a				   FUNCTION_NAME SET	TitleScreen
      7  400a					      SUBROUTINE
     14  400a					      SUBROUTINE
     15  400a
      0  400a					      VAR	__colour_table, 2
      1  400a		       00 a2	   __colour_table =	TEMPORARY_VAR
      2  400a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  400a
      4  400a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  400a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  400a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  400a					      ENDIF
      8  400a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  400a				  -	      ECHO	"Temporary Variable", __colour_table, "overflow!"
     10  400a				  -	      ERR
     11  400a					      ENDIF
     12  400a					      LIST	ON
     17  400a
     18  400a							; Start of new frame
     19  400a
     20  400a							; Start of vertical blank processing
     21  400a
     22  400a				   TitleSequence
     23  400a
     24  400a		       a9 00		      lda	#%00000000
     25  400c		       85 4a		      sta	CTRLPF
     26  400e		       85 49		      sta	COLUBK
     27  4010
     28  4010		       a2 00		      ldx	#0	;Platform
     29  4012		       a9 00		      lda	#<colr_ntsc2	;colvec,x
     30  4014		       85 a2		      sta	__colour_table
     31  4016		       a9 f1		      lda	#>colr_ntsc2	;colvec+1,x
     32  4018		       85 a3		      sta	__colour_table+1
     33  401a
     34  401a							;		  sta rndHi
     35  401a							;		  sta rnd
     36  401a
     37  401a
     38  401a				  -	      if	0
     39  401a				  -	      lda	#0
     40  401a				  -	      sta	digit
     41  401a				  -	      lda	#$10
     42  401a				  -	      sta	digit+1
     43  401a				  -	      lda	#$20
     44  401a				  -	      sta	digit+2
     45  401a					      endif
     46  401a
     47  401a
     48  401a
     49  401a
     50  401a							;RESYNC
     51  401a
     52  401a				   RestartFrame0
     53  401a
     54  401a				  -	      if	0
     55  401a				  -	      ldx	#2
     56  401a				  -rollcols   clc
     57  401a				  -	      lda	digit+2
     58  401a				  -	      adc	#$10
     59  401a				  -	      sta	digit+2
     60  401a				  -	      bcc	finxc
     61  401a				  -	      dex
     62  401a				  -	      bpl	rollcols
     63  401a				  -finxc
     64  401a					      endif
     65  401a
      0  401a					      DEF	RestartFrame
      1  401a				   BANK_RestartFrame SET	_CURRENT_BANK
      2  401a				   RestartFrame
      3  401a				   TEMPORARY_VAR SET	Overlay
      4  401a				   TEMPORARY_OFFSET SET	0
      5  401a				   VAR_BOUNDARY_RestartFrame SET	TEMPORARY_OFFSET
      6  401a				   FUNCTION_NAME SET	RestartFrame
      7  401a					      SUBROUTINE
     67  401a		       a9 00		      LDA	#0
     68  401c		       a9 0e		      lda	#%1110	; VSYNC ON
     69  401e		       85 42	   .loopVSync2 sta	WSYNC
     70  4020		       85 40		      sta	VSYNC
     71  4022		       4a		      lsr
     72  4023		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     73  4025
     74  4025							;------------------------------------------------------------------
     75  4025
     76  4025		       a6 9b		      ldx	Platform
     77  4027		       bc 08 f0 	      ldy	VBlankTime,x
     78  402a		       8c 96 02 	      sty	TIM64T
     79  402d
     80  402d
     81  402d				  -	      if	0
     82  402d				  -	      lda	SWCHB
     83  402d				  -	      rol
     84  402d				  -	      rol
     85  402d				  -	      rol
     86  402d				  -	      and	#%11
     87  402d				  -	      eor	#PAL
     88  402d				  -	      cmp	Platform
     89  402d				  -	      beq	platOK
     90  402d				  -	      sta	Platform
     91  402d				  -	      jmp	TitleSequence
     92  402d				  -platOK
     93  402d					      endif
     94  402d
     95  402d		       e6 81	   k2	      inc	rnd
     96  402f		       f0 fc		      beq	k2
     97  4031
     98  4031
     99  4031		       85 42	   VerticalBlank sta	WSYNC
    100  4033		       ad 84 02 	      lda	INTIM
    101  4036		       d0 f9		      bne	VerticalBlank
    102  4038		       85 41		      sta	VBLANK
    103  403a
    104  403a							;sta COLUBK
    105  403a
    106  403a							;------------------------------------------------------------------
    107  403a
    108  403a							; Do X scanlines of color-changing (our picture)
    109  403a
    110  403a		       a0 d1		      ldy	#210-1	; this counts our scanline number
    111  403c		       a2 03	   SokoLogo   ldx	#3
    112  403e		       b1 a2	   triplet    lda	(__colour_table),y
    113  4040							;    eor digit-1,x
    114  4040		       85 42		      sta	WSYNC
    115  4042		       85 48		      sta	COLUPF	; 3
    116  4044
    117  4044		       b9 b0 f2 	      lda	COL_0,y	; 5
    118  4047		       85 4d		      sta	PF0	; 3   @11
    119  4049		       b9 88 f3 	      lda	COL_1,y	; 5
    120  404c		       85 4e		      sta	PF1	; 3   @19
    121  404e		       b9 60 f4 	      lda	COL_2,y	; 5
    122  4051		       85 4f		      sta	PF2	; 3   @27
    123  4053
    124  4053		       b9 38 f5 	      lda	COL_3,y	; 5
    125  4056		       85 4d		      sta	PF0	; 3   @35
      0  4058					      SLEEP	2	; @37
      1  4058				   .CYCLES    SET	2
      2  4058
      3  4058				  -	      IF	.CYCLES < 2
      4  4058				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4058				  -	      ERR
      6  4058					      ENDIF
      7  4058
      8  4058				  -	      IF	.CYCLES & 1
      9  4058				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4058				  -	      nop	0
     11  4058				  -	      ELSE
     12  4058				  -	      bit	VSYNC
     13  4058				  -	      ENDIF
     14  4058				  -.CYCLES    SET	.CYCLES - 3
     15  4058					      ENDIF
     16  4058
     17  4058					      REPEAT	.CYCLES / 2
     18  4058		       ea		      nop
     19  4059					      REPEND
    127  4059		       b9 10 f6 	      lda	COL_4,y	; 5
    128  405c		       85 4e		      sta	PF1	; 3   @45
      0  405e					      SLEEP	3	; @45
      1  405e				   .CYCLES    SET	3
      2  405e
      3  405e				  -	      IF	.CYCLES < 2
      4  405e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  405e				  -	      ERR
      6  405e					      ENDIF
      7  405e
      8  405e					      IF	.CYCLES & 1
      9  405e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  405e		       04 00		      nop	0
     11  4060				  -	      ELSE
     12  4060				  -	      bit	VSYNC
     13  4060					      ENDIF
     14  4060				   .CYCLES    SET	.CYCLES - 3
     15  4060					      ENDIF
     16  4060
     17  4060				  -	      REPEAT	.CYCLES / 2
     18  4060				  -	      nop
     19  4060					      REPEND
    130  4060		       b9 e8 f6 	      lda	COL_5,y	; 5
    131  4063		       85 4f		      sta	PF2	; 3
    132  4065
    133  4065		       88		      dey		; 2
    134  4066		       ca		      dex		; 2
    135  4067		       d0 d5		      bne	triplet	; 2(3)
    136  4069
    137  4069		       c0 ff		      cpy	#-1	; 2
    138  406b		       d0 cf		      bne	SokoLogo	; 2(3)
    139  406d
    140  406d							;lda #0
    141  406d							;sta PF0
    142  406d							;sta PF1
    143  406d							;sta PF2
    144  406d
    145  406d		       a6 9b		      ldx	Platform
    146  406f		       bd 00 f0 	      lda	OverscanTime2,x
    147  4072		       8d 96 02 	      sta	TIM64T
    148  4075
    149  4075				  -	      if	0
    150  4075				  -	      sta	WSYNC
    151  4075				  -	      sta	WSYNC
    152  4075				  -	      sta	WSYNC
    153  4075				  -	      sta	WSYNC
    154  4075				  -	      sta	WSYNC
    155  4075				  -	      SLEEP	8
    156  4075				  -	      jsr	SokoScreen
    157  4075				  -
    158  4075				  -	      lda	#0
    159  4075				  -	      sta	BoardScrollX
    160  4075				  -	      sta	BoardScrollY
    161  4075					      endif
    162  4075
    163  4075							;		ldy #63
    164  4075							;bot2		 sta WSYNC
    165  4075							;		dey
    166  4075							;		bpl bot2
    167  4075
    168  4075							;--------------------------------------------------------------------------
    169  4075
    170  4075		       a9 00		      lda	#0
    171  4077		       85 4d		      sta	PF0
    172  4079		       85 4e		      sta	PF1
    173  407b		       85 4f		      sta	PF2
    174  407d
    175  407d
      0  407d					      NEXT_RANDOM
      1  407d		       a5 81		      lda	rnd
      2  407f		       4a		      lsr
      3  4080		       90 02		      bcc	.skipEOR
      4  4082		       49 fe		      eor	#RND_EOR_VAL
      5  4084		       85 81	   .skipEOR   sta	rnd
    177  4086
    178  4086							; D1 VBLANK turns off beam
    179  4086							; It needs to be turned on 37 scanlines later
    180  4086
    181  4086				   oscan
    182  4086		       ad 84 02 	      lda	INTIM
    183  4089		       d0 fb		      bne	oscan
    184  408b
    185  408b		       a9 42		      lda	#%01000010	; bit6 is not required
    186  408d		       85 41		      sta	VBLANK	; end of screen - enter blanking
    187  408f
    188  408f				  -	      if	0
    189  408f				  -	      inc	rnd
    190  408f				  -	      bne	rdd
    191  408f				  -	      inc	rndHi
    192  408f				  -rdd
    193  408f				  -
    194  408f				  -	      dec	digitick
    195  408f				  -	      bpl	ret2
    196  408f				  -	      lda	#40
    197  408f				  -	      sta	digitick
    198  408f				  -
    199  408f				  -	      jsr	Random
    200  408f				  -	      and	#3
    201  408f				  -	      beq	ret2
    202  408f				  -	      tax
    203  408f				  -	      jsr	Random
    204  408f				  -	      and	#$F0
    205  408f				  -	      sta	digit-1,x
    206  408f				  -	      jmp	RestartFrame0
    207  408f				  -
    208  408f				  -ret2
    209  408f					      endif
    210  408f
    211  408f
    212  408f		       a5 4c		      lda	INPT4
    213  4091		       10 03		      bpl	ret
    214  4093
    215  4093		       4c 1a f0 	      jmp	RestartFrame
    216  4096
    217  4096				   ret
    218  4096		       60		      rts
    219  4097
    220  4097
    221  4097
    222  4097					      MAC	lumtable
    223  4097							; {4} MIN LUM 1
    224  4097							; {5} MIN LUM 2
    225  4097							; {6} MIN LUM 3
    226  4097
    227  4097				   .LUM1      SET	{4}*256
    228  4097				   .LUM2      SET	{5}*256
    229  4097				   .LUM3      SET	{6}*256
    230  4097
    231  4097				   .STEP1     =	(256*({7}-{4}))/72
    232  4097				   .STEP2     =	(256*({8}-{5}))/72
    233  4097				   .STEP3     =	(256*({9}-{6}))/72
    234  4097
    235  4097					      REPEAT	72
    236  4097					      .byte	{1}+(.LUM1/256)
    237  4097					      .byte	{2}+(.LUM2/256)
    238  4097					      .byte	{3}+(.LUM3/256)
    239  4097
    240  4097							;    ECHO {1}+(.LUM1/256)
    241  4097							;    ECHO {2}+(.LUM1/256)
    242  4097							;    ECHO {3}+(.LUM1/256)
    243  4097
    244  4097				   .LUM1      SET	.LUM1 + .STEP1
    245  4097				   .LUM2      SET	.LUM2 + .STEP2
    246  4097				   .LUM3      SET	.LUM3 + .STEP3
    247  4097					      REPEND
    248  4097					      ENDM		;{1}{2}{3} base colours
    249  4097
    250  4097							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    251  4097							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    252  4097
    253  4100		       00 00 00 00*	      align	256
    254  4100							;    ECHO "NTSC LUMS"
    255  4100				   colr_ntsc2
      0  4100					      LUMTABLE	$40,$20,$90,$4,$6,$8,$4,$6,$8
      1  4100
      2  4100
      3  4100
      4  4100
      5  4100				   .LUM1      SET	$4*256
      6  4100				   .LUM2      SET	$6*256
      7  4100				   .LUM3      SET	$8*256
      8  4100
      9  4100		       00 00	   .STEP1     =	(256*($4-$4))/72
     10  4100		       00 00	   .STEP2     =	(256*($6-$6))/72
     11  4100		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  4100
     13  4100					      REPEAT	72
     14  4100		       44		      .byte.b	$40+(.LUM1/256)
     15  4101		       26		      .byte.b	$20+(.LUM2/256)
     16  4102		       98		      .byte.b	$90+(.LUM3/256)
     17  4103
     18  4103
     19  4103
     20  4103
     21  4103
     22  4103				   .LUM1      SET	.LUM1 + .STEP1
     23  4103				   .LUM2      SET	.LUM2 + .STEP2
     24  4103				   .LUM3      SET	.LUM3 + .STEP3
     13  4103					      REPEND
     14  4103		       44		      .byte.b	$40+(.LUM1/256)
     15  4104		       26		      .byte.b	$20+(.LUM2/256)
     16  4105		       98		      .byte.b	$90+(.LUM3/256)
     17  4106
     18  4106
     19  4106
     20  4106
     21  4106
     22  4106				   .LUM1      SET	.LUM1 + .STEP1
     23  4106				   .LUM2      SET	.LUM2 + .STEP2
     24  4106				   .LUM3      SET	.LUM3 + .STEP3
     13  4106					      REPEND
     14  4106		       44		      .byte.b	$40+(.LUM1/256)
     15  4107		       26		      .byte.b	$20+(.LUM2/256)
     16  4108		       98		      .byte.b	$90+(.LUM3/256)
     17  4109
     18  4109
     19  4109
     20  4109
     21  4109
     22  4109				   .LUM1      SET	.LUM1 + .STEP1
     23  4109				   .LUM2      SET	.LUM2 + .STEP2
     24  4109				   .LUM3      SET	.LUM3 + .STEP3
     13  4109					      REPEND
     14  4109		       44		      .byte.b	$40+(.LUM1/256)
     15  410a		       26		      .byte.b	$20+(.LUM2/256)
     16  410b		       98		      .byte.b	$90+(.LUM3/256)
     17  410c
     18  410c
     19  410c
     20  410c
     21  410c
     22  410c				   .LUM1      SET	.LUM1 + .STEP1
     23  410c				   .LUM2      SET	.LUM2 + .STEP2
     24  410c				   .LUM3      SET	.LUM3 + .STEP3
     13  410c					      REPEND
     14  410c		       44		      .byte.b	$40+(.LUM1/256)
     15  410d		       26		      .byte.b	$20+(.LUM2/256)
     16  410e		       98		      .byte.b	$90+(.LUM3/256)
     17  410f
     18  410f
     19  410f
     20  410f
     21  410f
     22  410f				   .LUM1      SET	.LUM1 + .STEP1
     23  410f				   .LUM2      SET	.LUM2 + .STEP2
     24  410f				   .LUM3      SET	.LUM3 + .STEP3
     13  410f					      REPEND
     14  410f		       44		      .byte.b	$40+(.LUM1/256)
     15  4110		       26		      .byte.b	$20+(.LUM2/256)
     16  4111		       98		      .byte.b	$90+(.LUM3/256)
     17  4112
     18  4112
     19  4112
     20  4112
     21  4112
     22  4112				   .LUM1      SET	.LUM1 + .STEP1
     23  4112				   .LUM2      SET	.LUM2 + .STEP2
     24  4112				   .LUM3      SET	.LUM3 + .STEP3
     13  4112					      REPEND
     14  4112		       44		      .byte.b	$40+(.LUM1/256)
     15  4113		       26		      .byte.b	$20+(.LUM2/256)
     16  4114		       98		      .byte.b	$90+(.LUM3/256)
     17  4115
     18  4115
     19  4115
     20  4115
     21  4115
     22  4115				   .LUM1      SET	.LUM1 + .STEP1
     23  4115				   .LUM2      SET	.LUM2 + .STEP2
     24  4115				   .LUM3      SET	.LUM3 + .STEP3
     13  4115					      REPEND
     14  4115		       44		      .byte.b	$40+(.LUM1/256)
     15  4116		       26		      .byte.b	$20+(.LUM2/256)
     16  4117		       98		      .byte.b	$90+(.LUM3/256)
     17  4118
     18  4118
     19  4118
     20  4118
     21  4118
     22  4118				   .LUM1      SET	.LUM1 + .STEP1
     23  4118				   .LUM2      SET	.LUM2 + .STEP2
     24  4118				   .LUM3      SET	.LUM3 + .STEP3
     13  4118					      REPEND
     14  4118		       44		      .byte.b	$40+(.LUM1/256)
     15  4119		       26		      .byte.b	$20+(.LUM2/256)
     16  411a		       98		      .byte.b	$90+(.LUM3/256)
     17  411b
     18  411b
     19  411b
     20  411b
     21  411b
     22  411b				   .LUM1      SET	.LUM1 + .STEP1
     23  411b				   .LUM2      SET	.LUM2 + .STEP2
     24  411b				   .LUM3      SET	.LUM3 + .STEP3
     13  411b					      REPEND
     14  411b		       44		      .byte.b	$40+(.LUM1/256)
     15  411c		       26		      .byte.b	$20+(.LUM2/256)
     16  411d		       98		      .byte.b	$90+(.LUM3/256)
     17  411e
     18  411e
     19  411e
     20  411e
     21  411e
     22  411e				   .LUM1      SET	.LUM1 + .STEP1
     23  411e				   .LUM2      SET	.LUM2 + .STEP2
     24  411e				   .LUM3      SET	.LUM3 + .STEP3
     13  411e					      REPEND
     14  411e		       44		      .byte.b	$40+(.LUM1/256)
     15  411f		       26		      .byte.b	$20+(.LUM2/256)
     16  4120		       98		      .byte.b	$90+(.LUM3/256)
     17  4121
     18  4121
     19  4121
     20  4121
     21  4121
     22  4121				   .LUM1      SET	.LUM1 + .STEP1
     23  4121				   .LUM2      SET	.LUM2 + .STEP2
     24  4121				   .LUM3      SET	.LUM3 + .STEP3
     13  4121					      REPEND
     14  4121		       44		      .byte.b	$40+(.LUM1/256)
     15  4122		       26		      .byte.b	$20+(.LUM2/256)
     16  4123		       98		      .byte.b	$90+(.LUM3/256)
     17  4124
     18  4124
     19  4124
     20  4124
     21  4124
     22  4124				   .LUM1      SET	.LUM1 + .STEP1
     23  4124				   .LUM2      SET	.LUM2 + .STEP2
     24  4124				   .LUM3      SET	.LUM3 + .STEP3
     13  4124					      REPEND
     14  4124		       44		      .byte.b	$40+(.LUM1/256)
     15  4125		       26		      .byte.b	$20+(.LUM2/256)
     16  4126		       98		      .byte.b	$90+(.LUM3/256)
     17  4127
     18  4127
     19  4127
     20  4127
     21  4127
     22  4127				   .LUM1      SET	.LUM1 + .STEP1
     23  4127				   .LUM2      SET	.LUM2 + .STEP2
     24  4127				   .LUM3      SET	.LUM3 + .STEP3
     13  4127					      REPEND
     14  4127		       44		      .byte.b	$40+(.LUM1/256)
     15  4128		       26		      .byte.b	$20+(.LUM2/256)
     16  4129		       98		      .byte.b	$90+(.LUM3/256)
     17  412a
     18  412a
     19  412a
     20  412a
     21  412a
     22  412a				   .LUM1      SET	.LUM1 + .STEP1
     23  412a				   .LUM2      SET	.LUM2 + .STEP2
     24  412a				   .LUM3      SET	.LUM3 + .STEP3
     13  412a					      REPEND
     14  412a		       44		      .byte.b	$40+(.LUM1/256)
     15  412b		       26		      .byte.b	$20+(.LUM2/256)
     16  412c		       98		      .byte.b	$90+(.LUM3/256)
     17  412d
     18  412d
     19  412d
     20  412d
     21  412d
     22  412d				   .LUM1      SET	.LUM1 + .STEP1
     23  412d				   .LUM2      SET	.LUM2 + .STEP2
     24  412d				   .LUM3      SET	.LUM3 + .STEP3
     13  412d					      REPEND
     14  412d		       44		      .byte.b	$40+(.LUM1/256)
     15  412e		       26		      .byte.b	$20+(.LUM2/256)
     16  412f		       98		      .byte.b	$90+(.LUM3/256)
     17  4130
     18  4130
     19  4130
     20  4130
     21  4130
     22  4130				   .LUM1      SET	.LUM1 + .STEP1
     23  4130				   .LUM2      SET	.LUM2 + .STEP2
     24  4130				   .LUM3      SET	.LUM3 + .STEP3
     13  4130					      REPEND
     14  4130		       44		      .byte.b	$40+(.LUM1/256)
     15  4131		       26		      .byte.b	$20+(.LUM2/256)
     16  4132		       98		      .byte.b	$90+(.LUM3/256)
     17  4133
     18  4133
     19  4133
     20  4133
     21  4133
     22  4133				   .LUM1      SET	.LUM1 + .STEP1
     23  4133				   .LUM2      SET	.LUM2 + .STEP2
     24  4133				   .LUM3      SET	.LUM3 + .STEP3
     13  4133					      REPEND
     14  4133		       44		      .byte.b	$40+(.LUM1/256)
     15  4134		       26		      .byte.b	$20+(.LUM2/256)
     16  4135		       98		      .byte.b	$90+(.LUM3/256)
     17  4136
     18  4136
     19  4136
     20  4136
     21  4136
     22  4136				   .LUM1      SET	.LUM1 + .STEP1
     23  4136				   .LUM2      SET	.LUM2 + .STEP2
     24  4136				   .LUM3      SET	.LUM3 + .STEP3
     13  4136					      REPEND
     14  4136		       44		      .byte.b	$40+(.LUM1/256)
     15  4137		       26		      .byte.b	$20+(.LUM2/256)
     16  4138		       98		      .byte.b	$90+(.LUM3/256)
     17  4139
     18  4139
     19  4139
     20  4139
     21  4139
     22  4139				   .LUM1      SET	.LUM1 + .STEP1
     23  4139				   .LUM2      SET	.LUM2 + .STEP2
     24  4139				   .LUM3      SET	.LUM3 + .STEP3
     13  4139					      REPEND
     14  4139		       44		      .byte.b	$40+(.LUM1/256)
     15  413a		       26		      .byte.b	$20+(.LUM2/256)
     16  413b		       98		      .byte.b	$90+(.LUM3/256)
     17  413c
     18  413c
     19  413c
     20  413c
     21  413c
     22  413c				   .LUM1      SET	.LUM1 + .STEP1
     23  413c				   .LUM2      SET	.LUM2 + .STEP2
     24  413c				   .LUM3      SET	.LUM3 + .STEP3
     13  413c					      REPEND
     14  413c		       44		      .byte.b	$40+(.LUM1/256)
     15  413d		       26		      .byte.b	$20+(.LUM2/256)
     16  413e		       98		      .byte.b	$90+(.LUM3/256)
     17  413f
     18  413f
     19  413f
     20  413f
     21  413f
     22  413f				   .LUM1      SET	.LUM1 + .STEP1
     23  413f				   .LUM2      SET	.LUM2 + .STEP2
     24  413f				   .LUM3      SET	.LUM3 + .STEP3
     13  413f					      REPEND
     14  413f		       44		      .byte.b	$40+(.LUM1/256)
     15  4140		       26		      .byte.b	$20+(.LUM2/256)
     16  4141		       98		      .byte.b	$90+(.LUM3/256)
     17  4142
     18  4142
     19  4142
     20  4142
     21  4142
     22  4142				   .LUM1      SET	.LUM1 + .STEP1
     23  4142				   .LUM2      SET	.LUM2 + .STEP2
     24  4142				   .LUM3      SET	.LUM3 + .STEP3
     13  4142					      REPEND
     14  4142		       44		      .byte.b	$40+(.LUM1/256)
     15  4143		       26		      .byte.b	$20+(.LUM2/256)
     16  4144		       98		      .byte.b	$90+(.LUM3/256)
     17  4145
     18  4145
     19  4145
     20  4145
     21  4145
     22  4145				   .LUM1      SET	.LUM1 + .STEP1
     23  4145				   .LUM2      SET	.LUM2 + .STEP2
     24  4145				   .LUM3      SET	.LUM3 + .STEP3
     13  4145					      REPEND
     14  4145		       44		      .byte.b	$40+(.LUM1/256)
     15  4146		       26		      .byte.b	$20+(.LUM2/256)
     16  4147		       98		      .byte.b	$90+(.LUM3/256)
     17  4148
     18  4148
     19  4148
     20  4148
     21  4148
     22  4148				   .LUM1      SET	.LUM1 + .STEP1
     23  4148				   .LUM2      SET	.LUM2 + .STEP2
     24  4148				   .LUM3      SET	.LUM3 + .STEP3
     13  4148					      REPEND
     14  4148		       44		      .byte.b	$40+(.LUM1/256)
     15  4149		       26		      .byte.b	$20+(.LUM2/256)
     16  414a		       98		      .byte.b	$90+(.LUM3/256)
     17  414b
     18  414b
     19  414b
     20  414b
     21  414b
     22  414b				   .LUM1      SET	.LUM1 + .STEP1
     23  414b				   .LUM2      SET	.LUM2 + .STEP2
     24  414b				   .LUM3      SET	.LUM3 + .STEP3
     13  414b					      REPEND
     14  414b		       44		      .byte.b	$40+(.LUM1/256)
     15  414c		       26		      .byte.b	$20+(.LUM2/256)
     16  414d		       98		      .byte.b	$90+(.LUM3/256)
     17  414e
     18  414e
     19  414e
     20  414e
     21  414e
     22  414e				   .LUM1      SET	.LUM1 + .STEP1
     23  414e				   .LUM2      SET	.LUM2 + .STEP2
     24  414e				   .LUM3      SET	.LUM3 + .STEP3
     13  414e					      REPEND
     14  414e		       44		      .byte.b	$40+(.LUM1/256)
     15  414f		       26		      .byte.b	$20+(.LUM2/256)
     16  4150		       98		      .byte.b	$90+(.LUM3/256)
     17  4151
     18  4151
     19  4151
     20  4151
     21  4151
     22  4151				   .LUM1      SET	.LUM1 + .STEP1
     23  4151				   .LUM2      SET	.LUM2 + .STEP2
     24  4151				   .LUM3      SET	.LUM3 + .STEP3
     13  4151					      REPEND
     14  4151		       44		      .byte.b	$40+(.LUM1/256)
     15  4152		       26		      .byte.b	$20+(.LUM2/256)
     16  4153		       98		      .byte.b	$90+(.LUM3/256)
     17  4154
     18  4154
     19  4154
     20  4154
     21  4154
     22  4154				   .LUM1      SET	.LUM1 + .STEP1
     23  4154				   .LUM2      SET	.LUM2 + .STEP2
     24  4154				   .LUM3      SET	.LUM3 + .STEP3
     13  4154					      REPEND
     14  4154		       44		      .byte.b	$40+(.LUM1/256)
     15  4155		       26		      .byte.b	$20+(.LUM2/256)
     16  4156		       98		      .byte.b	$90+(.LUM3/256)
     17  4157
     18  4157
     19  4157
     20  4157
     21  4157
     22  4157				   .LUM1      SET	.LUM1 + .STEP1
     23  4157				   .LUM2      SET	.LUM2 + .STEP2
     24  4157				   .LUM3      SET	.LUM3 + .STEP3
     13  4157					      REPEND
     14  4157		       44		      .byte.b	$40+(.LUM1/256)
     15  4158		       26		      .byte.b	$20+(.LUM2/256)
     16  4159		       98		      .byte.b	$90+(.LUM3/256)
     17  415a
     18  415a
     19  415a
     20  415a
     21  415a
     22  415a				   .LUM1      SET	.LUM1 + .STEP1
     23  415a				   .LUM2      SET	.LUM2 + .STEP2
     24  415a				   .LUM3      SET	.LUM3 + .STEP3
     13  415a					      REPEND
     14  415a		       44		      .byte.b	$40+(.LUM1/256)
     15  415b		       26		      .byte.b	$20+(.LUM2/256)
     16  415c		       98		      .byte.b	$90+(.LUM3/256)
     17  415d
     18  415d
     19  415d
     20  415d
     21  415d
     22  415d				   .LUM1      SET	.LUM1 + .STEP1
     23  415d				   .LUM2      SET	.LUM2 + .STEP2
     24  415d				   .LUM3      SET	.LUM3 + .STEP3
     13  415d					      REPEND
     14  415d		       44		      .byte.b	$40+(.LUM1/256)
     15  415e		       26		      .byte.b	$20+(.LUM2/256)
     16  415f		       98		      .byte.b	$90+(.LUM3/256)
     17  4160
     18  4160
     19  4160
     20  4160
     21  4160
     22  4160				   .LUM1      SET	.LUM1 + .STEP1
     23  4160				   .LUM2      SET	.LUM2 + .STEP2
     24  4160				   .LUM3      SET	.LUM3 + .STEP3
     13  4160					      REPEND
     14  4160		       44		      .byte.b	$40+(.LUM1/256)
     15  4161		       26		      .byte.b	$20+(.LUM2/256)
     16  4162		       98		      .byte.b	$90+(.LUM3/256)
     17  4163
     18  4163
     19  4163
     20  4163
     21  4163
     22  4163				   .LUM1      SET	.LUM1 + .STEP1
     23  4163				   .LUM2      SET	.LUM2 + .STEP2
     24  4163				   .LUM3      SET	.LUM3 + .STEP3
     13  4163					      REPEND
     14  4163		       44		      .byte.b	$40+(.LUM1/256)
     15  4164		       26		      .byte.b	$20+(.LUM2/256)
     16  4165		       98		      .byte.b	$90+(.LUM3/256)
     17  4166
     18  4166
     19  4166
     20  4166
     21  4166
     22  4166				   .LUM1      SET	.LUM1 + .STEP1
     23  4166				   .LUM2      SET	.LUM2 + .STEP2
     24  4166				   .LUM3      SET	.LUM3 + .STEP3
     13  4166					      REPEND
     14  4166		       44		      .byte.b	$40+(.LUM1/256)
     15  4167		       26		      .byte.b	$20+(.LUM2/256)
     16  4168		       98		      .byte.b	$90+(.LUM3/256)
     17  4169
     18  4169
     19  4169
     20  4169
     21  4169
     22  4169				   .LUM1      SET	.LUM1 + .STEP1
     23  4169				   .LUM2      SET	.LUM2 + .STEP2
     24  4169				   .LUM3      SET	.LUM3 + .STEP3
     13  4169					      REPEND
     14  4169		       44		      .byte.b	$40+(.LUM1/256)
     15  416a		       26		      .byte.b	$20+(.LUM2/256)
     16  416b		       98		      .byte.b	$90+(.LUM3/256)
     17  416c
     18  416c
     19  416c
     20  416c
     21  416c
     22  416c				   .LUM1      SET	.LUM1 + .STEP1
     23  416c				   .LUM2      SET	.LUM2 + .STEP2
     24  416c				   .LUM3      SET	.LUM3 + .STEP3
     13  416c					      REPEND
     14  416c		       44		      .byte.b	$40+(.LUM1/256)
     15  416d		       26		      .byte.b	$20+(.LUM2/256)
     16  416e		       98		      .byte.b	$90+(.LUM3/256)
     17  416f
     18  416f
     19  416f
     20  416f
     21  416f
     22  416f				   .LUM1      SET	.LUM1 + .STEP1
     23  416f				   .LUM2      SET	.LUM2 + .STEP2
     24  416f				   .LUM3      SET	.LUM3 + .STEP3
     13  416f					      REPEND
     14  416f		       44		      .byte.b	$40+(.LUM1/256)
     15  4170		       26		      .byte.b	$20+(.LUM2/256)
     16  4171		       98		      .byte.b	$90+(.LUM3/256)
     17  4172
     18  4172
     19  4172
     20  4172
     21  4172
     22  4172				   .LUM1      SET	.LUM1 + .STEP1
     23  4172				   .LUM2      SET	.LUM2 + .STEP2
     24  4172				   .LUM3      SET	.LUM3 + .STEP3
     13  4172					      REPEND
     14  4172		       44		      .byte.b	$40+(.LUM1/256)
     15  4173		       26		      .byte.b	$20+(.LUM2/256)
     16  4174		       98		      .byte.b	$90+(.LUM3/256)
     17  4175
     18  4175
     19  4175
     20  4175
     21  4175
     22  4175				   .LUM1      SET	.LUM1 + .STEP1
     23  4175				   .LUM2      SET	.LUM2 + .STEP2
     24  4175				   .LUM3      SET	.LUM3 + .STEP3
     13  4175					      REPEND
     14  4175		       44		      .byte.b	$40+(.LUM1/256)
     15  4176		       26		      .byte.b	$20+(.LUM2/256)
     16  4177		       98		      .byte.b	$90+(.LUM3/256)
     17  4178
     18  4178
     19  4178
     20  4178
     21  4178
     22  4178				   .LUM1      SET	.LUM1 + .STEP1
     23  4178				   .LUM2      SET	.LUM2 + .STEP2
     24  4178				   .LUM3      SET	.LUM3 + .STEP3
     13  4178					      REPEND
     14  4178		       44		      .byte.b	$40+(.LUM1/256)
     15  4179		       26		      .byte.b	$20+(.LUM2/256)
     16  417a		       98		      .byte.b	$90+(.LUM3/256)
     17  417b
     18  417b
     19  417b
     20  417b
     21  417b
     22  417b				   .LUM1      SET	.LUM1 + .STEP1
     23  417b				   .LUM2      SET	.LUM2 + .STEP2
     24  417b				   .LUM3      SET	.LUM3 + .STEP3
     13  417b					      REPEND
     14  417b		       44		      .byte.b	$40+(.LUM1/256)
     15  417c		       26		      .byte.b	$20+(.LUM2/256)
     16  417d		       98		      .byte.b	$90+(.LUM3/256)
     17  417e
     18  417e
     19  417e
     20  417e
     21  417e
     22  417e				   .LUM1      SET	.LUM1 + .STEP1
     23  417e				   .LUM2      SET	.LUM2 + .STEP2
     24  417e				   .LUM3      SET	.LUM3 + .STEP3
     13  417e					      REPEND
     14  417e		       44		      .byte.b	$40+(.LUM1/256)
     15  417f		       26		      .byte.b	$20+(.LUM2/256)
     16  4180		       98		      .byte.b	$90+(.LUM3/256)
     17  4181
     18  4181
     19  4181
     20  4181
     21  4181
     22  4181				   .LUM1      SET	.LUM1 + .STEP1
     23  4181				   .LUM2      SET	.LUM2 + .STEP2
     24  4181				   .LUM3      SET	.LUM3 + .STEP3
     13  4181					      REPEND
     14  4181		       44		      .byte.b	$40+(.LUM1/256)
     15  4182		       26		      .byte.b	$20+(.LUM2/256)
     16  4183		       98		      .byte.b	$90+(.LUM3/256)
     17  4184
     18  4184
     19  4184
     20  4184
     21  4184
     22  4184				   .LUM1      SET	.LUM1 + .STEP1
     23  4184				   .LUM2      SET	.LUM2 + .STEP2
     24  4184				   .LUM3      SET	.LUM3 + .STEP3
     13  4184					      REPEND
     14  4184		       44		      .byte.b	$40+(.LUM1/256)
     15  4185		       26		      .byte.b	$20+(.LUM2/256)
     16  4186		       98		      .byte.b	$90+(.LUM3/256)
     17  4187
     18  4187
     19  4187
     20  4187
     21  4187
     22  4187				   .LUM1      SET	.LUM1 + .STEP1
     23  4187				   .LUM2      SET	.LUM2 + .STEP2
     24  4187				   .LUM3      SET	.LUM3 + .STEP3
     13  4187					      REPEND
     14  4187		       44		      .byte.b	$40+(.LUM1/256)
     15  4188		       26		      .byte.b	$20+(.LUM2/256)
     16  4189		       98		      .byte.b	$90+(.LUM3/256)
     17  418a
     18  418a
     19  418a
     20  418a
     21  418a
     22  418a				   .LUM1      SET	.LUM1 + .STEP1
     23  418a				   .LUM2      SET	.LUM2 + .STEP2
     24  418a				   .LUM3      SET	.LUM3 + .STEP3
     13  418a					      REPEND
     14  418a		       44		      .byte.b	$40+(.LUM1/256)
     15  418b		       26		      .byte.b	$20+(.LUM2/256)
     16  418c		       98		      .byte.b	$90+(.LUM3/256)
     17  418d
     18  418d
     19  418d
     20  418d
     21  418d
     22  418d				   .LUM1      SET	.LUM1 + .STEP1
     23  418d				   .LUM2      SET	.LUM2 + .STEP2
     24  418d				   .LUM3      SET	.LUM3 + .STEP3
     13  418d					      REPEND
     14  418d		       44		      .byte.b	$40+(.LUM1/256)
     15  418e		       26		      .byte.b	$20+(.LUM2/256)
     16  418f		       98		      .byte.b	$90+(.LUM3/256)
     17  4190
     18  4190
     19  4190
     20  4190
     21  4190
     22  4190				   .LUM1      SET	.LUM1 + .STEP1
     23  4190				   .LUM2      SET	.LUM2 + .STEP2
     24  4190				   .LUM3      SET	.LUM3 + .STEP3
     13  4190					      REPEND
     14  4190		       44		      .byte.b	$40+(.LUM1/256)
     15  4191		       26		      .byte.b	$20+(.LUM2/256)
     16  4192		       98		      .byte.b	$90+(.LUM3/256)
     17  4193
     18  4193
     19  4193
     20  4193
     21  4193
     22  4193				   .LUM1      SET	.LUM1 + .STEP1
     23  4193				   .LUM2      SET	.LUM2 + .STEP2
     24  4193				   .LUM3      SET	.LUM3 + .STEP3
     13  4193					      REPEND
     14  4193		       44		      .byte.b	$40+(.LUM1/256)
     15  4194		       26		      .byte.b	$20+(.LUM2/256)
     16  4195		       98		      .byte.b	$90+(.LUM3/256)
     17  4196
     18  4196
     19  4196
     20  4196
     21  4196
     22  4196				   .LUM1      SET	.LUM1 + .STEP1
     23  4196				   .LUM2      SET	.LUM2 + .STEP2
     24  4196				   .LUM3      SET	.LUM3 + .STEP3
     13  4196					      REPEND
     14  4196		       44		      .byte.b	$40+(.LUM1/256)
     15  4197		       26		      .byte.b	$20+(.LUM2/256)
     16  4198		       98		      .byte.b	$90+(.LUM3/256)
     17  4199
     18  4199
     19  4199
     20  4199
     21  4199
     22  4199				   .LUM1      SET	.LUM1 + .STEP1
     23  4199				   .LUM2      SET	.LUM2 + .STEP2
     24  4199				   .LUM3      SET	.LUM3 + .STEP3
     13  4199					      REPEND
     14  4199		       44		      .byte.b	$40+(.LUM1/256)
     15  419a		       26		      .byte.b	$20+(.LUM2/256)
     16  419b		       98		      .byte.b	$90+(.LUM3/256)
     17  419c
     18  419c
     19  419c
     20  419c
     21  419c
     22  419c				   .LUM1      SET	.LUM1 + .STEP1
     23  419c				   .LUM2      SET	.LUM2 + .STEP2
     24  419c				   .LUM3      SET	.LUM3 + .STEP3
     13  419c					      REPEND
     14  419c		       44		      .byte.b	$40+(.LUM1/256)
     15  419d		       26		      .byte.b	$20+(.LUM2/256)
     16  419e		       98		      .byte.b	$90+(.LUM3/256)
     17  419f
     18  419f
     19  419f
     20  419f
     21  419f
     22  419f				   .LUM1      SET	.LUM1 + .STEP1
     23  419f				   .LUM2      SET	.LUM2 + .STEP2
     24  419f				   .LUM3      SET	.LUM3 + .STEP3
     13  419f					      REPEND
     14  419f		       44		      .byte.b	$40+(.LUM1/256)
     15  41a0		       26		      .byte.b	$20+(.LUM2/256)
     16  41a1		       98		      .byte.b	$90+(.LUM3/256)
     17  41a2
     18  41a2
     19  41a2
     20  41a2
     21  41a2
     22  41a2				   .LUM1      SET	.LUM1 + .STEP1
     23  41a2				   .LUM2      SET	.LUM2 + .STEP2
     24  41a2				   .LUM3      SET	.LUM3 + .STEP3
     13  41a2					      REPEND
     14  41a2		       44		      .byte.b	$40+(.LUM1/256)
     15  41a3		       26		      .byte.b	$20+(.LUM2/256)
     16  41a4		       98		      .byte.b	$90+(.LUM3/256)
     17  41a5
     18  41a5
     19  41a5
     20  41a5
     21  41a5
     22  41a5				   .LUM1      SET	.LUM1 + .STEP1
     23  41a5				   .LUM2      SET	.LUM2 + .STEP2
     24  41a5				   .LUM3      SET	.LUM3 + .STEP3
     13  41a5					      REPEND
     14  41a5		       44		      .byte.b	$40+(.LUM1/256)
     15  41a6		       26		      .byte.b	$20+(.LUM2/256)
     16  41a7		       98		      .byte.b	$90+(.LUM3/256)
     17  41a8
     18  41a8
     19  41a8
     20  41a8
     21  41a8
     22  41a8				   .LUM1      SET	.LUM1 + .STEP1
     23  41a8				   .LUM2      SET	.LUM2 + .STEP2
     24  41a8				   .LUM3      SET	.LUM3 + .STEP3
     13  41a8					      REPEND
     14  41a8		       44		      .byte.b	$40+(.LUM1/256)
     15  41a9		       26		      .byte.b	$20+(.LUM2/256)
     16  41aa		       98		      .byte.b	$90+(.LUM3/256)
     17  41ab
     18  41ab
     19  41ab
     20  41ab
     21  41ab
     22  41ab				   .LUM1      SET	.LUM1 + .STEP1
     23  41ab				   .LUM2      SET	.LUM2 + .STEP2
     24  41ab				   .LUM3      SET	.LUM3 + .STEP3
     13  41ab					      REPEND
     14  41ab		       44		      .byte.b	$40+(.LUM1/256)
     15  41ac		       26		      .byte.b	$20+(.LUM2/256)
     16  41ad		       98		      .byte.b	$90+(.LUM3/256)
     17  41ae
     18  41ae
     19  41ae
     20  41ae
     21  41ae
     22  41ae				   .LUM1      SET	.LUM1 + .STEP1
     23  41ae				   .LUM2      SET	.LUM2 + .STEP2
     24  41ae				   .LUM3      SET	.LUM3 + .STEP3
     13  41ae					      REPEND
     14  41ae		       44		      .byte.b	$40+(.LUM1/256)
     15  41af		       26		      .byte.b	$20+(.LUM2/256)
     16  41b0		       98		      .byte.b	$90+(.LUM3/256)
     17  41b1
     18  41b1
     19  41b1
     20  41b1
     21  41b1
     22  41b1				   .LUM1      SET	.LUM1 + .STEP1
     23  41b1				   .LUM2      SET	.LUM2 + .STEP2
     24  41b1				   .LUM3      SET	.LUM3 + .STEP3
     13  41b1					      REPEND
     14  41b1		       44		      .byte.b	$40+(.LUM1/256)
     15  41b2		       26		      .byte.b	$20+(.LUM2/256)
     16  41b3		       98		      .byte.b	$90+(.LUM3/256)
     17  41b4
     18  41b4
     19  41b4
     20  41b4
     21  41b4
     22  41b4				   .LUM1      SET	.LUM1 + .STEP1
     23  41b4				   .LUM2      SET	.LUM2 + .STEP2
     24  41b4				   .LUM3      SET	.LUM3 + .STEP3
     13  41b4					      REPEND
     14  41b4		       44		      .byte.b	$40+(.LUM1/256)
     15  41b5		       26		      .byte.b	$20+(.LUM2/256)
     16  41b6		       98		      .byte.b	$90+(.LUM3/256)
     17  41b7
     18  41b7
     19  41b7
     20  41b7
     21  41b7
     22  41b7				   .LUM1      SET	.LUM1 + .STEP1
     23  41b7				   .LUM2      SET	.LUM2 + .STEP2
     24  41b7				   .LUM3      SET	.LUM3 + .STEP3
     13  41b7					      REPEND
     14  41b7		       44		      .byte.b	$40+(.LUM1/256)
     15  41b8		       26		      .byte.b	$20+(.LUM2/256)
     16  41b9		       98		      .byte.b	$90+(.LUM3/256)
     17  41ba
     18  41ba
     19  41ba
     20  41ba
     21  41ba
     22  41ba				   .LUM1      SET	.LUM1 + .STEP1
     23  41ba				   .LUM2      SET	.LUM2 + .STEP2
     24  41ba				   .LUM3      SET	.LUM3 + .STEP3
     13  41ba					      REPEND
     14  41ba		       44		      .byte.b	$40+(.LUM1/256)
     15  41bb		       26		      .byte.b	$20+(.LUM2/256)
     16  41bc		       98		      .byte.b	$90+(.LUM3/256)
     17  41bd
     18  41bd
     19  41bd
     20  41bd
     21  41bd
     22  41bd				   .LUM1      SET	.LUM1 + .STEP1
     23  41bd				   .LUM2      SET	.LUM2 + .STEP2
     24  41bd				   .LUM3      SET	.LUM3 + .STEP3
     13  41bd					      REPEND
     14  41bd		       44		      .byte.b	$40+(.LUM1/256)
     15  41be		       26		      .byte.b	$20+(.LUM2/256)
     16  41bf		       98		      .byte.b	$90+(.LUM3/256)
     17  41c0
     18  41c0
     19  41c0
     20  41c0
     21  41c0
     22  41c0				   .LUM1      SET	.LUM1 + .STEP1
     23  41c0				   .LUM2      SET	.LUM2 + .STEP2
     24  41c0				   .LUM3      SET	.LUM3 + .STEP3
     13  41c0					      REPEND
     14  41c0		       44		      .byte.b	$40+(.LUM1/256)
     15  41c1		       26		      .byte.b	$20+(.LUM2/256)
     16  41c2		       98		      .byte.b	$90+(.LUM3/256)
     17  41c3
     18  41c3
     19  41c3
     20  41c3
     21  41c3
     22  41c3				   .LUM1      SET	.LUM1 + .STEP1
     23  41c3				   .LUM2      SET	.LUM2 + .STEP2
     24  41c3				   .LUM3      SET	.LUM3 + .STEP3
     13  41c3					      REPEND
     14  41c3		       44		      .byte.b	$40+(.LUM1/256)
     15  41c4		       26		      .byte.b	$20+(.LUM2/256)
     16  41c5		       98		      .byte.b	$90+(.LUM3/256)
     17  41c6
     18  41c6
     19  41c6
     20  41c6
     21  41c6
     22  41c6				   .LUM1      SET	.LUM1 + .STEP1
     23  41c6				   .LUM2      SET	.LUM2 + .STEP2
     24  41c6				   .LUM3      SET	.LUM3 + .STEP3
     13  41c6					      REPEND
     14  41c6		       44		      .byte.b	$40+(.LUM1/256)
     15  41c7		       26		      .byte.b	$20+(.LUM2/256)
     16  41c8		       98		      .byte.b	$90+(.LUM3/256)
     17  41c9
     18  41c9
     19  41c9
     20  41c9
     21  41c9
     22  41c9				   .LUM1      SET	.LUM1 + .STEP1
     23  41c9				   .LUM2      SET	.LUM2 + .STEP2
     24  41c9				   .LUM3      SET	.LUM3 + .STEP3
     13  41c9					      REPEND
     14  41c9		       44		      .byte.b	$40+(.LUM1/256)
     15  41ca		       26		      .byte.b	$20+(.LUM2/256)
     16  41cb		       98		      .byte.b	$90+(.LUM3/256)
     17  41cc
     18  41cc
     19  41cc
     20  41cc
     21  41cc
     22  41cc				   .LUM1      SET	.LUM1 + .STEP1
     23  41cc				   .LUM2      SET	.LUM2 + .STEP2
     24  41cc				   .LUM3      SET	.LUM3 + .STEP3
     13  41cc					      REPEND
     14  41cc		       44		      .byte.b	$40+(.LUM1/256)
     15  41cd		       26		      .byte.b	$20+(.LUM2/256)
     16  41ce		       98		      .byte.b	$90+(.LUM3/256)
     17  41cf
     18  41cf
     19  41cf
     20  41cf
     21  41cf
     22  41cf				   .LUM1      SET	.LUM1 + .STEP1
     23  41cf				   .LUM2      SET	.LUM2 + .STEP2
     24  41cf				   .LUM3      SET	.LUM3 + .STEP3
     13  41cf					      REPEND
     14  41cf		       44		      .byte.b	$40+(.LUM1/256)
     15  41d0		       26		      .byte.b	$20+(.LUM2/256)
     16  41d1		       98		      .byte.b	$90+(.LUM3/256)
     17  41d2
     18  41d2
     19  41d2
     20  41d2
     21  41d2
     22  41d2				   .LUM1      SET	.LUM1 + .STEP1
     23  41d2				   .LUM2      SET	.LUM2 + .STEP2
     24  41d2				   .LUM3      SET	.LUM3 + .STEP3
     13  41d2					      REPEND
     14  41d2		       44		      .byte.b	$40+(.LUM1/256)
     15  41d3		       26		      .byte.b	$20+(.LUM2/256)
     16  41d4		       98		      .byte.b	$90+(.LUM3/256)
     17  41d5
     18  41d5
     19  41d5
     20  41d5
     21  41d5
     22  41d5				   .LUM1      SET	.LUM1 + .STEP1
     23  41d5				   .LUM2      SET	.LUM2 + .STEP2
     24  41d5				   .LUM3      SET	.LUM3 + .STEP3
     13  41d5					      REPEND
     14  41d5		       44		      .byte.b	$40+(.LUM1/256)
     15  41d6		       26		      .byte.b	$20+(.LUM2/256)
     16  41d7		       98		      .byte.b	$90+(.LUM3/256)
     17  41d8
     18  41d8
     19  41d8
     20  41d8
     21  41d8
     22  41d8				   .LUM1      SET	.LUM1 + .STEP1
     23  41d8				   .LUM2      SET	.LUM2 + .STEP2
     24  41d8				   .LUM3      SET	.LUM3 + .STEP3
     25  41d8					      REPEND
    257  41d8							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    258  41d8
    259  41d8							;    ECHO "PAL LUMS"
    260  41d8							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
      0  41d8				   colr_pal   LUMTABLE	$60, $80, $10, $6,$4,$8,$6,$4,$8
      1  41d8
      2  41d8
      3  41d8
      4  41d8
      5  41d8				   .LUM1      SET	$6*256
      6  41d8				   .LUM2      SET	$4*256
      7  41d8				   .LUM3      SET	$8*256
      8  41d8
      9  41d8		       00 00	   .STEP1     =	(256*($6-$6))/72
     10  41d8		       00 00	   .STEP2     =	(256*($4-$4))/72
     11  41d8		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  41d8
     13  41d8					      REPEAT	72
     14  41d8		       66		      .byte.b	$60+(.LUM1/256)
     15  41d9		       84		      .byte.b	$80+(.LUM2/256)
     16  41da		       18		      .byte.b	$10+(.LUM3/256)
     17  41db
     18  41db
     19  41db
     20  41db
     21  41db
     22  41db				   .LUM1      SET	.LUM1 + .STEP1
     23  41db				   .LUM2      SET	.LUM2 + .STEP2
     24  41db				   .LUM3      SET	.LUM3 + .STEP3
     13  41db					      REPEND
     14  41db		       66		      .byte.b	$60+(.LUM1/256)
     15  41dc		       84		      .byte.b	$80+(.LUM2/256)
     16  41dd		       18		      .byte.b	$10+(.LUM3/256)
     17  41de
     18  41de
     19  41de
     20  41de
     21  41de
     22  41de				   .LUM1      SET	.LUM1 + .STEP1
     23  41de				   .LUM2      SET	.LUM2 + .STEP2
     24  41de				   .LUM3      SET	.LUM3 + .STEP3
     13  41de					      REPEND
     14  41de		       66		      .byte.b	$60+(.LUM1/256)
     15  41df		       84		      .byte.b	$80+(.LUM2/256)
     16  41e0		       18		      .byte.b	$10+(.LUM3/256)
     17  41e1
     18  41e1
     19  41e1
     20  41e1
     21  41e1
     22  41e1				   .LUM1      SET	.LUM1 + .STEP1
     23  41e1				   .LUM2      SET	.LUM2 + .STEP2
     24  41e1				   .LUM3      SET	.LUM3 + .STEP3
     13  41e1					      REPEND
     14  41e1		       66		      .byte.b	$60+(.LUM1/256)
     15  41e2		       84		      .byte.b	$80+(.LUM2/256)
     16  41e3		       18		      .byte.b	$10+(.LUM3/256)
     17  41e4
     18  41e4
     19  41e4
     20  41e4
     21  41e4
     22  41e4				   .LUM1      SET	.LUM1 + .STEP1
     23  41e4				   .LUM2      SET	.LUM2 + .STEP2
     24  41e4				   .LUM3      SET	.LUM3 + .STEP3
     13  41e4					      REPEND
     14  41e4		       66		      .byte.b	$60+(.LUM1/256)
     15  41e5		       84		      .byte.b	$80+(.LUM2/256)
     16  41e6		       18		      .byte.b	$10+(.LUM3/256)
     17  41e7
     18  41e7
     19  41e7
     20  41e7
     21  41e7
     22  41e7				   .LUM1      SET	.LUM1 + .STEP1
     23  41e7				   .LUM2      SET	.LUM2 + .STEP2
     24  41e7				   .LUM3      SET	.LUM3 + .STEP3
     13  41e7					      REPEND
     14  41e7		       66		      .byte.b	$60+(.LUM1/256)
     15  41e8		       84		      .byte.b	$80+(.LUM2/256)
     16  41e9		       18		      .byte.b	$10+(.LUM3/256)
     17  41ea
     18  41ea
     19  41ea
     20  41ea
     21  41ea
     22  41ea				   .LUM1      SET	.LUM1 + .STEP1
     23  41ea				   .LUM2      SET	.LUM2 + .STEP2
     24  41ea				   .LUM3      SET	.LUM3 + .STEP3
     13  41ea					      REPEND
     14  41ea		       66		      .byte.b	$60+(.LUM1/256)
     15  41eb		       84		      .byte.b	$80+(.LUM2/256)
     16  41ec		       18		      .byte.b	$10+(.LUM3/256)
     17  41ed
     18  41ed
     19  41ed
     20  41ed
     21  41ed
     22  41ed				   .LUM1      SET	.LUM1 + .STEP1
     23  41ed				   .LUM2      SET	.LUM2 + .STEP2
     24  41ed				   .LUM3      SET	.LUM3 + .STEP3
     13  41ed					      REPEND
     14  41ed		       66		      .byte.b	$60+(.LUM1/256)
     15  41ee		       84		      .byte.b	$80+(.LUM2/256)
     16  41ef		       18		      .byte.b	$10+(.LUM3/256)
     17  41f0
     18  41f0
     19  41f0
     20  41f0
     21  41f0
     22  41f0				   .LUM1      SET	.LUM1 + .STEP1
     23  41f0				   .LUM2      SET	.LUM2 + .STEP2
     24  41f0				   .LUM3      SET	.LUM3 + .STEP3
     13  41f0					      REPEND
     14  41f0		       66		      .byte.b	$60+(.LUM1/256)
     15  41f1		       84		      .byte.b	$80+(.LUM2/256)
     16  41f2		       18		      .byte.b	$10+(.LUM3/256)
     17  41f3
     18  41f3
     19  41f3
     20  41f3
     21  41f3
     22  41f3				   .LUM1      SET	.LUM1 + .STEP1
     23  41f3				   .LUM2      SET	.LUM2 + .STEP2
     24  41f3				   .LUM3      SET	.LUM3 + .STEP3
     13  41f3					      REPEND
     14  41f3		       66		      .byte.b	$60+(.LUM1/256)
     15  41f4		       84		      .byte.b	$80+(.LUM2/256)
     16  41f5		       18		      .byte.b	$10+(.LUM3/256)
     17  41f6
     18  41f6
     19  41f6
     20  41f6
     21  41f6
     22  41f6				   .LUM1      SET	.LUM1 + .STEP1
     23  41f6				   .LUM2      SET	.LUM2 + .STEP2
     24  41f6				   .LUM3      SET	.LUM3 + .STEP3
     13  41f6					      REPEND
     14  41f6		       66		      .byte.b	$60+(.LUM1/256)
     15  41f7		       84		      .byte.b	$80+(.LUM2/256)
     16  41f8		       18		      .byte.b	$10+(.LUM3/256)
     17  41f9
     18  41f9
     19  41f9
     20  41f9
     21  41f9
     22  41f9				   .LUM1      SET	.LUM1 + .STEP1
     23  41f9				   .LUM2      SET	.LUM2 + .STEP2
     24  41f9				   .LUM3      SET	.LUM3 + .STEP3
     13  41f9					      REPEND
     14  41f9		       66		      .byte.b	$60+(.LUM1/256)
     15  41fa		       84		      .byte.b	$80+(.LUM2/256)
     16  41fb		       18		      .byte.b	$10+(.LUM3/256)
     17  41fc
     18  41fc
     19  41fc
     20  41fc
     21  41fc
     22  41fc				   .LUM1      SET	.LUM1 + .STEP1
     23  41fc				   .LUM2      SET	.LUM2 + .STEP2
     24  41fc				   .LUM3      SET	.LUM3 + .STEP3
     13  41fc					      REPEND
     14  41fc		       66		      .byte.b	$60+(.LUM1/256)
     15  41fd		       84		      .byte.b	$80+(.LUM2/256)
     16  41fe		       18		      .byte.b	$10+(.LUM3/256)
     17  41ff
     18  41ff
     19  41ff
     20  41ff
     21  41ff
     22  41ff				   .LUM1      SET	.LUM1 + .STEP1
     23  41ff				   .LUM2      SET	.LUM2 + .STEP2
     24  41ff				   .LUM3      SET	.LUM3 + .STEP3
     13  41ff					      REPEND
     14  41ff		       66		      .byte.b	$60+(.LUM1/256)
     15  4200		       84		      .byte.b	$80+(.LUM2/256)
     16  4201		       18		      .byte.b	$10+(.LUM3/256)
     17  4202
     18  4202
     19  4202
     20  4202
     21  4202
     22  4202				   .LUM1      SET	.LUM1 + .STEP1
     23  4202				   .LUM2      SET	.LUM2 + .STEP2
     24  4202				   .LUM3      SET	.LUM3 + .STEP3
     13  4202					      REPEND
     14  4202		       66		      .byte.b	$60+(.LUM1/256)
     15  4203		       84		      .byte.b	$80+(.LUM2/256)
     16  4204		       18		      .byte.b	$10+(.LUM3/256)
     17  4205
     18  4205
     19  4205
     20  4205
     21  4205
     22  4205				   .LUM1      SET	.LUM1 + .STEP1
     23  4205				   .LUM2      SET	.LUM2 + .STEP2
     24  4205				   .LUM3      SET	.LUM3 + .STEP3
     13  4205					      REPEND
     14  4205		       66		      .byte.b	$60+(.LUM1/256)
     15  4206		       84		      .byte.b	$80+(.LUM2/256)
     16  4207		       18		      .byte.b	$10+(.LUM3/256)
     17  4208
     18  4208
     19  4208
     20  4208
     21  4208
     22  4208				   .LUM1      SET	.LUM1 + .STEP1
     23  4208				   .LUM2      SET	.LUM2 + .STEP2
     24  4208				   .LUM3      SET	.LUM3 + .STEP3
     13  4208					      REPEND
     14  4208		       66		      .byte.b	$60+(.LUM1/256)
     15  4209		       84		      .byte.b	$80+(.LUM2/256)
     16  420a		       18		      .byte.b	$10+(.LUM3/256)
     17  420b
     18  420b
     19  420b
     20  420b
     21  420b
     22  420b				   .LUM1      SET	.LUM1 + .STEP1
     23  420b				   .LUM2      SET	.LUM2 + .STEP2
     24  420b				   .LUM3      SET	.LUM3 + .STEP3
     13  420b					      REPEND
     14  420b		       66		      .byte.b	$60+(.LUM1/256)
     15  420c		       84		      .byte.b	$80+(.LUM2/256)
     16  420d		       18		      .byte.b	$10+(.LUM3/256)
     17  420e
     18  420e
     19  420e
     20  420e
     21  420e
     22  420e				   .LUM1      SET	.LUM1 + .STEP1
     23  420e				   .LUM2      SET	.LUM2 + .STEP2
     24  420e				   .LUM3      SET	.LUM3 + .STEP3
     13  420e					      REPEND
     14  420e		       66		      .byte.b	$60+(.LUM1/256)
     15  420f		       84		      .byte.b	$80+(.LUM2/256)
     16  4210		       18		      .byte.b	$10+(.LUM3/256)
     17  4211
     18  4211
     19  4211
     20  4211
     21  4211
     22  4211				   .LUM1      SET	.LUM1 + .STEP1
     23  4211				   .LUM2      SET	.LUM2 + .STEP2
     24  4211				   .LUM3      SET	.LUM3 + .STEP3
     13  4211					      REPEND
     14  4211		       66		      .byte.b	$60+(.LUM1/256)
     15  4212		       84		      .byte.b	$80+(.LUM2/256)
     16  4213		       18		      .byte.b	$10+(.LUM3/256)
     17  4214
     18  4214
     19  4214
     20  4214
     21  4214
     22  4214				   .LUM1      SET	.LUM1 + .STEP1
     23  4214				   .LUM2      SET	.LUM2 + .STEP2
     24  4214				   .LUM3      SET	.LUM3 + .STEP3
     13  4214					      REPEND
     14  4214		       66		      .byte.b	$60+(.LUM1/256)
     15  4215		       84		      .byte.b	$80+(.LUM2/256)
     16  4216		       18		      .byte.b	$10+(.LUM3/256)
     17  4217
     18  4217
     19  4217
     20  4217
     21  4217
     22  4217				   .LUM1      SET	.LUM1 + .STEP1
     23  4217				   .LUM2      SET	.LUM2 + .STEP2
     24  4217				   .LUM3      SET	.LUM3 + .STEP3
     13  4217					      REPEND
     14  4217		       66		      .byte.b	$60+(.LUM1/256)
     15  4218		       84		      .byte.b	$80+(.LUM2/256)
     16  4219		       18		      .byte.b	$10+(.LUM3/256)
     17  421a
     18  421a
     19  421a
     20  421a
     21  421a
     22  421a				   .LUM1      SET	.LUM1 + .STEP1
     23  421a				   .LUM2      SET	.LUM2 + .STEP2
     24  421a				   .LUM3      SET	.LUM3 + .STEP3
     13  421a					      REPEND
     14  421a		       66		      .byte.b	$60+(.LUM1/256)
     15  421b		       84		      .byte.b	$80+(.LUM2/256)
     16  421c		       18		      .byte.b	$10+(.LUM3/256)
     17  421d
     18  421d
     19  421d
     20  421d
     21  421d
     22  421d				   .LUM1      SET	.LUM1 + .STEP1
     23  421d				   .LUM2      SET	.LUM2 + .STEP2
     24  421d				   .LUM3      SET	.LUM3 + .STEP3
     13  421d					      REPEND
     14  421d		       66		      .byte.b	$60+(.LUM1/256)
     15  421e		       84		      .byte.b	$80+(.LUM2/256)
     16  421f		       18		      .byte.b	$10+(.LUM3/256)
     17  4220
     18  4220
     19  4220
     20  4220
     21  4220
     22  4220				   .LUM1      SET	.LUM1 + .STEP1
     23  4220				   .LUM2      SET	.LUM2 + .STEP2
     24  4220				   .LUM3      SET	.LUM3 + .STEP3
     13  4220					      REPEND
     14  4220		       66		      .byte.b	$60+(.LUM1/256)
     15  4221		       84		      .byte.b	$80+(.LUM2/256)
     16  4222		       18		      .byte.b	$10+(.LUM3/256)
     17  4223
     18  4223
     19  4223
     20  4223
     21  4223
     22  4223				   .LUM1      SET	.LUM1 + .STEP1
     23  4223				   .LUM2      SET	.LUM2 + .STEP2
     24  4223				   .LUM3      SET	.LUM3 + .STEP3
     13  4223					      REPEND
     14  4223		       66		      .byte.b	$60+(.LUM1/256)
     15  4224		       84		      .byte.b	$80+(.LUM2/256)
     16  4225		       18		      .byte.b	$10+(.LUM3/256)
     17  4226
     18  4226
     19  4226
     20  4226
     21  4226
     22  4226				   .LUM1      SET	.LUM1 + .STEP1
     23  4226				   .LUM2      SET	.LUM2 + .STEP2
     24  4226				   .LUM3      SET	.LUM3 + .STEP3
     13  4226					      REPEND
     14  4226		       66		      .byte.b	$60+(.LUM1/256)
     15  4227		       84		      .byte.b	$80+(.LUM2/256)
     16  4228		       18		      .byte.b	$10+(.LUM3/256)
     17  4229
     18  4229
     19  4229
     20  4229
     21  4229
     22  4229				   .LUM1      SET	.LUM1 + .STEP1
     23  4229				   .LUM2      SET	.LUM2 + .STEP2
     24  4229				   .LUM3      SET	.LUM3 + .STEP3
     13  4229					      REPEND
     14  4229		       66		      .byte.b	$60+(.LUM1/256)
     15  422a		       84		      .byte.b	$80+(.LUM2/256)
     16  422b		       18		      .byte.b	$10+(.LUM3/256)
     17  422c
     18  422c
     19  422c
     20  422c
     21  422c
     22  422c				   .LUM1      SET	.LUM1 + .STEP1
     23  422c				   .LUM2      SET	.LUM2 + .STEP2
     24  422c				   .LUM3      SET	.LUM3 + .STEP3
     13  422c					      REPEND
     14  422c		       66		      .byte.b	$60+(.LUM1/256)
     15  422d		       84		      .byte.b	$80+(.LUM2/256)
     16  422e		       18		      .byte.b	$10+(.LUM3/256)
     17  422f
     18  422f
     19  422f
     20  422f
     21  422f
     22  422f				   .LUM1      SET	.LUM1 + .STEP1
     23  422f				   .LUM2      SET	.LUM2 + .STEP2
     24  422f				   .LUM3      SET	.LUM3 + .STEP3
     13  422f					      REPEND
     14  422f		       66		      .byte.b	$60+(.LUM1/256)
     15  4230		       84		      .byte.b	$80+(.LUM2/256)
     16  4231		       18		      .byte.b	$10+(.LUM3/256)
     17  4232
     18  4232
     19  4232
     20  4232
     21  4232
     22  4232				   .LUM1      SET	.LUM1 + .STEP1
     23  4232				   .LUM2      SET	.LUM2 + .STEP2
     24  4232				   .LUM3      SET	.LUM3 + .STEP3
     13  4232					      REPEND
     14  4232		       66		      .byte.b	$60+(.LUM1/256)
     15  4233		       84		      .byte.b	$80+(.LUM2/256)
     16  4234		       18		      .byte.b	$10+(.LUM3/256)
     17  4235
     18  4235
     19  4235
     20  4235
     21  4235
     22  4235				   .LUM1      SET	.LUM1 + .STEP1
     23  4235				   .LUM2      SET	.LUM2 + .STEP2
     24  4235				   .LUM3      SET	.LUM3 + .STEP3
     13  4235					      REPEND
     14  4235		       66		      .byte.b	$60+(.LUM1/256)
     15  4236		       84		      .byte.b	$80+(.LUM2/256)
     16  4237		       18		      .byte.b	$10+(.LUM3/256)
     17  4238
     18  4238
     19  4238
     20  4238
     21  4238
     22  4238				   .LUM1      SET	.LUM1 + .STEP1
     23  4238				   .LUM2      SET	.LUM2 + .STEP2
     24  4238				   .LUM3      SET	.LUM3 + .STEP3
     13  4238					      REPEND
     14  4238		       66		      .byte.b	$60+(.LUM1/256)
     15  4239		       84		      .byte.b	$80+(.LUM2/256)
     16  423a		       18		      .byte.b	$10+(.LUM3/256)
     17  423b
     18  423b
     19  423b
     20  423b
     21  423b
     22  423b				   .LUM1      SET	.LUM1 + .STEP1
     23  423b				   .LUM2      SET	.LUM2 + .STEP2
     24  423b				   .LUM3      SET	.LUM3 + .STEP3
     13  423b					      REPEND
     14  423b		       66		      .byte.b	$60+(.LUM1/256)
     15  423c		       84		      .byte.b	$80+(.LUM2/256)
     16  423d		       18		      .byte.b	$10+(.LUM3/256)
     17  423e
     18  423e
     19  423e
     20  423e
     21  423e
     22  423e				   .LUM1      SET	.LUM1 + .STEP1
     23  423e				   .LUM2      SET	.LUM2 + .STEP2
     24  423e				   .LUM3      SET	.LUM3 + .STEP3
     13  423e					      REPEND
     14  423e		       66		      .byte.b	$60+(.LUM1/256)
     15  423f		       84		      .byte.b	$80+(.LUM2/256)
     16  4240		       18		      .byte.b	$10+(.LUM3/256)
     17  4241
     18  4241
     19  4241
     20  4241
     21  4241
     22  4241				   .LUM1      SET	.LUM1 + .STEP1
     23  4241				   .LUM2      SET	.LUM2 + .STEP2
     24  4241				   .LUM3      SET	.LUM3 + .STEP3
     13  4241					      REPEND
     14  4241		       66		      .byte.b	$60+(.LUM1/256)
     15  4242		       84		      .byte.b	$80+(.LUM2/256)
     16  4243		       18		      .byte.b	$10+(.LUM3/256)
     17  4244
     18  4244
     19  4244
     20  4244
     21  4244
     22  4244				   .LUM1      SET	.LUM1 + .STEP1
     23  4244				   .LUM2      SET	.LUM2 + .STEP2
     24  4244				   .LUM3      SET	.LUM3 + .STEP3
     13  4244					      REPEND
     14  4244		       66		      .byte.b	$60+(.LUM1/256)
     15  4245		       84		      .byte.b	$80+(.LUM2/256)
     16  4246		       18		      .byte.b	$10+(.LUM3/256)
     17  4247
     18  4247
     19  4247
     20  4247
     21  4247
     22  4247				   .LUM1      SET	.LUM1 + .STEP1
     23  4247				   .LUM2      SET	.LUM2 + .STEP2
     24  4247				   .LUM3      SET	.LUM3 + .STEP3
     13  4247					      REPEND
     14  4247		       66		      .byte.b	$60+(.LUM1/256)
     15  4248		       84		      .byte.b	$80+(.LUM2/256)
     16  4249		       18		      .byte.b	$10+(.LUM3/256)
     17  424a
     18  424a
     19  424a
     20  424a
     21  424a
     22  424a				   .LUM1      SET	.LUM1 + .STEP1
     23  424a				   .LUM2      SET	.LUM2 + .STEP2
     24  424a				   .LUM3      SET	.LUM3 + .STEP3
     13  424a					      REPEND
     14  424a		       66		      .byte.b	$60+(.LUM1/256)
     15  424b		       84		      .byte.b	$80+(.LUM2/256)
     16  424c		       18		      .byte.b	$10+(.LUM3/256)
     17  424d
     18  424d
     19  424d
     20  424d
     21  424d
     22  424d				   .LUM1      SET	.LUM1 + .STEP1
     23  424d				   .LUM2      SET	.LUM2 + .STEP2
     24  424d				   .LUM3      SET	.LUM3 + .STEP3
     13  424d					      REPEND
     14  424d		       66		      .byte.b	$60+(.LUM1/256)
     15  424e		       84		      .byte.b	$80+(.LUM2/256)
     16  424f		       18		      .byte.b	$10+(.LUM3/256)
     17  4250
     18  4250
     19  4250
     20  4250
     21  4250
     22  4250				   .LUM1      SET	.LUM1 + .STEP1
     23  4250				   .LUM2      SET	.LUM2 + .STEP2
     24  4250				   .LUM3      SET	.LUM3 + .STEP3
     13  4250					      REPEND
     14  4250		       66		      .byte.b	$60+(.LUM1/256)
     15  4251		       84		      .byte.b	$80+(.LUM2/256)
     16  4252		       18		      .byte.b	$10+(.LUM3/256)
     17  4253
     18  4253
     19  4253
     20  4253
     21  4253
     22  4253				   .LUM1      SET	.LUM1 + .STEP1
     23  4253				   .LUM2      SET	.LUM2 + .STEP2
     24  4253				   .LUM3      SET	.LUM3 + .STEP3
     13  4253					      REPEND
     14  4253		       66		      .byte.b	$60+(.LUM1/256)
     15  4254		       84		      .byte.b	$80+(.LUM2/256)
     16  4255		       18		      .byte.b	$10+(.LUM3/256)
     17  4256
     18  4256
     19  4256
     20  4256
     21  4256
     22  4256				   .LUM1      SET	.LUM1 + .STEP1
     23  4256				   .LUM2      SET	.LUM2 + .STEP2
     24  4256				   .LUM3      SET	.LUM3 + .STEP3
     13  4256					      REPEND
     14  4256		       66		      .byte.b	$60+(.LUM1/256)
     15  4257		       84		      .byte.b	$80+(.LUM2/256)
     16  4258		       18		      .byte.b	$10+(.LUM3/256)
     17  4259
     18  4259
     19  4259
     20  4259
     21  4259
     22  4259				   .LUM1      SET	.LUM1 + .STEP1
     23  4259				   .LUM2      SET	.LUM2 + .STEP2
     24  4259				   .LUM3      SET	.LUM3 + .STEP3
     13  4259					      REPEND
     14  4259		       66		      .byte.b	$60+(.LUM1/256)
     15  425a		       84		      .byte.b	$80+(.LUM2/256)
     16  425b		       18		      .byte.b	$10+(.LUM3/256)
     17  425c
     18  425c
     19  425c
     20  425c
     21  425c
     22  425c				   .LUM1      SET	.LUM1 + .STEP1
     23  425c				   .LUM2      SET	.LUM2 + .STEP2
     24  425c				   .LUM3      SET	.LUM3 + .STEP3
     13  425c					      REPEND
     14  425c		       66		      .byte.b	$60+(.LUM1/256)
     15  425d		       84		      .byte.b	$80+(.LUM2/256)
     16  425e		       18		      .byte.b	$10+(.LUM3/256)
     17  425f
     18  425f
     19  425f
     20  425f
     21  425f
     22  425f				   .LUM1      SET	.LUM1 + .STEP1
     23  425f				   .LUM2      SET	.LUM2 + .STEP2
     24  425f				   .LUM3      SET	.LUM3 + .STEP3
     13  425f					      REPEND
     14  425f		       66		      .byte.b	$60+(.LUM1/256)
     15  4260		       84		      .byte.b	$80+(.LUM2/256)
     16  4261		       18		      .byte.b	$10+(.LUM3/256)
     17  4262
     18  4262
     19  4262
     20  4262
     21  4262
     22  4262				   .LUM1      SET	.LUM1 + .STEP1
     23  4262				   .LUM2      SET	.LUM2 + .STEP2
     24  4262				   .LUM3      SET	.LUM3 + .STEP3
     13  4262					      REPEND
     14  4262		       66		      .byte.b	$60+(.LUM1/256)
     15  4263		       84		      .byte.b	$80+(.LUM2/256)
     16  4264		       18		      .byte.b	$10+(.LUM3/256)
     17  4265
     18  4265
     19  4265
     20  4265
     21  4265
     22  4265				   .LUM1      SET	.LUM1 + .STEP1
     23  4265				   .LUM2      SET	.LUM2 + .STEP2
     24  4265				   .LUM3      SET	.LUM3 + .STEP3
     13  4265					      REPEND
     14  4265		       66		      .byte.b	$60+(.LUM1/256)
     15  4266		       84		      .byte.b	$80+(.LUM2/256)
     16  4267		       18		      .byte.b	$10+(.LUM3/256)
     17  4268
     18  4268
     19  4268
     20  4268
     21  4268
     22  4268				   .LUM1      SET	.LUM1 + .STEP1
     23  4268				   .LUM2      SET	.LUM2 + .STEP2
     24  4268				   .LUM3      SET	.LUM3 + .STEP3
     13  4268					      REPEND
     14  4268		       66		      .byte.b	$60+(.LUM1/256)
     15  4269		       84		      .byte.b	$80+(.LUM2/256)
     16  426a		       18		      .byte.b	$10+(.LUM3/256)
     17  426b
     18  426b
     19  426b
     20  426b
     21  426b
     22  426b				   .LUM1      SET	.LUM1 + .STEP1
     23  426b				   .LUM2      SET	.LUM2 + .STEP2
     24  426b				   .LUM3      SET	.LUM3 + .STEP3
     13  426b					      REPEND
     14  426b		       66		      .byte.b	$60+(.LUM1/256)
     15  426c		       84		      .byte.b	$80+(.LUM2/256)
     16  426d		       18		      .byte.b	$10+(.LUM3/256)
     17  426e
     18  426e
     19  426e
     20  426e
     21  426e
     22  426e				   .LUM1      SET	.LUM1 + .STEP1
     23  426e				   .LUM2      SET	.LUM2 + .STEP2
     24  426e				   .LUM3      SET	.LUM3 + .STEP3
     13  426e					      REPEND
     14  426e		       66		      .byte.b	$60+(.LUM1/256)
     15  426f		       84		      .byte.b	$80+(.LUM2/256)
     16  4270		       18		      .byte.b	$10+(.LUM3/256)
     17  4271
     18  4271
     19  4271
     20  4271
     21  4271
     22  4271				   .LUM1      SET	.LUM1 + .STEP1
     23  4271				   .LUM2      SET	.LUM2 + .STEP2
     24  4271				   .LUM3      SET	.LUM3 + .STEP3
     13  4271					      REPEND
     14  4271		       66		      .byte.b	$60+(.LUM1/256)
     15  4272		       84		      .byte.b	$80+(.LUM2/256)
     16  4273		       18		      .byte.b	$10+(.LUM3/256)
     17  4274
     18  4274
     19  4274
     20  4274
     21  4274
     22  4274				   .LUM1      SET	.LUM1 + .STEP1
     23  4274				   .LUM2      SET	.LUM2 + .STEP2
     24  4274				   .LUM3      SET	.LUM3 + .STEP3
     13  4274					      REPEND
     14  4274		       66		      .byte.b	$60+(.LUM1/256)
     15  4275		       84		      .byte.b	$80+(.LUM2/256)
     16  4276		       18		      .byte.b	$10+(.LUM3/256)
     17  4277
     18  4277
     19  4277
     20  4277
     21  4277
     22  4277				   .LUM1      SET	.LUM1 + .STEP1
     23  4277				   .LUM2      SET	.LUM2 + .STEP2
     24  4277				   .LUM3      SET	.LUM3 + .STEP3
     13  4277					      REPEND
     14  4277		       66		      .byte.b	$60+(.LUM1/256)
     15  4278		       84		      .byte.b	$80+(.LUM2/256)
     16  4279		       18		      .byte.b	$10+(.LUM3/256)
     17  427a
     18  427a
     19  427a
     20  427a
     21  427a
     22  427a				   .LUM1      SET	.LUM1 + .STEP1
     23  427a				   .LUM2      SET	.LUM2 + .STEP2
     24  427a				   .LUM3      SET	.LUM3 + .STEP3
     13  427a					      REPEND
     14  427a		       66		      .byte.b	$60+(.LUM1/256)
     15  427b		       84		      .byte.b	$80+(.LUM2/256)
     16  427c		       18		      .byte.b	$10+(.LUM3/256)
     17  427d
     18  427d
     19  427d
     20  427d
     21  427d
     22  427d				   .LUM1      SET	.LUM1 + .STEP1
     23  427d				   .LUM2      SET	.LUM2 + .STEP2
     24  427d				   .LUM3      SET	.LUM3 + .STEP3
     13  427d					      REPEND
     14  427d		       66		      .byte.b	$60+(.LUM1/256)
     15  427e		       84		      .byte.b	$80+(.LUM2/256)
     16  427f		       18		      .byte.b	$10+(.LUM3/256)
     17  4280
     18  4280
     19  4280
     20  4280
     21  4280
     22  4280				   .LUM1      SET	.LUM1 + .STEP1
     23  4280				   .LUM2      SET	.LUM2 + .STEP2
     24  4280				   .LUM3      SET	.LUM3 + .STEP3
     13  4280					      REPEND
     14  4280		       66		      .byte.b	$60+(.LUM1/256)
     15  4281		       84		      .byte.b	$80+(.LUM2/256)
     16  4282		       18		      .byte.b	$10+(.LUM3/256)
     17  4283
     18  4283
     19  4283
     20  4283
     21  4283
     22  4283				   .LUM1      SET	.LUM1 + .STEP1
     23  4283				   .LUM2      SET	.LUM2 + .STEP2
     24  4283				   .LUM3      SET	.LUM3 + .STEP3
     13  4283					      REPEND
     14  4283		       66		      .byte.b	$60+(.LUM1/256)
     15  4284		       84		      .byte.b	$80+(.LUM2/256)
     16  4285		       18		      .byte.b	$10+(.LUM3/256)
     17  4286
     18  4286
     19  4286
     20  4286
     21  4286
     22  4286				   .LUM1      SET	.LUM1 + .STEP1
     23  4286				   .LUM2      SET	.LUM2 + .STEP2
     24  4286				   .LUM3      SET	.LUM3 + .STEP3
     13  4286					      REPEND
     14  4286		       66		      .byte.b	$60+(.LUM1/256)
     15  4287		       84		      .byte.b	$80+(.LUM2/256)
     16  4288		       18		      .byte.b	$10+(.LUM3/256)
     17  4289
     18  4289
     19  4289
     20  4289
     21  4289
     22  4289				   .LUM1      SET	.LUM1 + .STEP1
     23  4289				   .LUM2      SET	.LUM2 + .STEP2
     24  4289				   .LUM3      SET	.LUM3 + .STEP3
     13  4289					      REPEND
     14  4289		       66		      .byte.b	$60+(.LUM1/256)
     15  428a		       84		      .byte.b	$80+(.LUM2/256)
     16  428b		       18		      .byte.b	$10+(.LUM3/256)
     17  428c
     18  428c
     19  428c
     20  428c
     21  428c
     22  428c				   .LUM1      SET	.LUM1 + .STEP1
     23  428c				   .LUM2      SET	.LUM2 + .STEP2
     24  428c				   .LUM3      SET	.LUM3 + .STEP3
     13  428c					      REPEND
     14  428c		       66		      .byte.b	$60+(.LUM1/256)
     15  428d		       84		      .byte.b	$80+(.LUM2/256)
     16  428e		       18		      .byte.b	$10+(.LUM3/256)
     17  428f
     18  428f
     19  428f
     20  428f
     21  428f
     22  428f				   .LUM1      SET	.LUM1 + .STEP1
     23  428f				   .LUM2      SET	.LUM2 + .STEP2
     24  428f				   .LUM3      SET	.LUM3 + .STEP3
     13  428f					      REPEND
     14  428f		       66		      .byte.b	$60+(.LUM1/256)
     15  4290		       84		      .byte.b	$80+(.LUM2/256)
     16  4291		       18		      .byte.b	$10+(.LUM3/256)
     17  4292
     18  4292
     19  4292
     20  4292
     21  4292
     22  4292				   .LUM1      SET	.LUM1 + .STEP1
     23  4292				   .LUM2      SET	.LUM2 + .STEP2
     24  4292				   .LUM3      SET	.LUM3 + .STEP3
     13  4292					      REPEND
     14  4292		       66		      .byte.b	$60+(.LUM1/256)
     15  4293		       84		      .byte.b	$80+(.LUM2/256)
     16  4294		       18		      .byte.b	$10+(.LUM3/256)
     17  4295
     18  4295
     19  4295
     20  4295
     21  4295
     22  4295				   .LUM1      SET	.LUM1 + .STEP1
     23  4295				   .LUM2      SET	.LUM2 + .STEP2
     24  4295				   .LUM3      SET	.LUM3 + .STEP3
     13  4295					      REPEND
     14  4295		       66		      .byte.b	$60+(.LUM1/256)
     15  4296		       84		      .byte.b	$80+(.LUM2/256)
     16  4297		       18		      .byte.b	$10+(.LUM3/256)
     17  4298
     18  4298
     19  4298
     20  4298
     21  4298
     22  4298				   .LUM1      SET	.LUM1 + .STEP1
     23  4298				   .LUM2      SET	.LUM2 + .STEP2
     24  4298				   .LUM3      SET	.LUM3 + .STEP3
     13  4298					      REPEND
     14  4298		       66		      .byte.b	$60+(.LUM1/256)
     15  4299		       84		      .byte.b	$80+(.LUM2/256)
     16  429a		       18		      .byte.b	$10+(.LUM3/256)
     17  429b
     18  429b
     19  429b
     20  429b
     21  429b
     22  429b				   .LUM1      SET	.LUM1 + .STEP1
     23  429b				   .LUM2      SET	.LUM2 + .STEP2
     24  429b				   .LUM3      SET	.LUM3 + .STEP3
     13  429b					      REPEND
     14  429b		       66		      .byte.b	$60+(.LUM1/256)
     15  429c		       84		      .byte.b	$80+(.LUM2/256)
     16  429d		       18		      .byte.b	$10+(.LUM3/256)
     17  429e
     18  429e
     19  429e
     20  429e
     21  429e
     22  429e				   .LUM1      SET	.LUM1 + .STEP1
     23  429e				   .LUM2      SET	.LUM2 + .STEP2
     24  429e				   .LUM3      SET	.LUM3 + .STEP3
     13  429e					      REPEND
     14  429e		       66		      .byte.b	$60+(.LUM1/256)
     15  429f		       84		      .byte.b	$80+(.LUM2/256)
     16  42a0		       18		      .byte.b	$10+(.LUM3/256)
     17  42a1
     18  42a1
     19  42a1
     20  42a1
     21  42a1
     22  42a1				   .LUM1      SET	.LUM1 + .STEP1
     23  42a1				   .LUM2      SET	.LUM2 + .STEP2
     24  42a1				   .LUM3      SET	.LUM3 + .STEP3
     13  42a1					      REPEND
     14  42a1		       66		      .byte.b	$60+(.LUM1/256)
     15  42a2		       84		      .byte.b	$80+(.LUM2/256)
     16  42a3		       18		      .byte.b	$10+(.LUM3/256)
     17  42a4
     18  42a4
     19  42a4
     20  42a4
     21  42a4
     22  42a4				   .LUM1      SET	.LUM1 + .STEP1
     23  42a4				   .LUM2      SET	.LUM2 + .STEP2
     24  42a4				   .LUM3      SET	.LUM3 + .STEP3
     13  42a4					      REPEND
     14  42a4		       66		      .byte.b	$60+(.LUM1/256)
     15  42a5		       84		      .byte.b	$80+(.LUM2/256)
     16  42a6		       18		      .byte.b	$10+(.LUM3/256)
     17  42a7
     18  42a7
     19  42a7
     20  42a7
     21  42a7
     22  42a7				   .LUM1      SET	.LUM1 + .STEP1
     23  42a7				   .LUM2      SET	.LUM2 + .STEP2
     24  42a7				   .LUM3      SET	.LUM3 + .STEP3
     13  42a7					      REPEND
     14  42a7		       66		      .byte.b	$60+(.LUM1/256)
     15  42a8		       84		      .byte.b	$80+(.LUM2/256)
     16  42a9		       18		      .byte.b	$10+(.LUM3/256)
     17  42aa
     18  42aa
     19  42aa
     20  42aa
     21  42aa
     22  42aa				   .LUM1      SET	.LUM1 + .STEP1
     23  42aa				   .LUM2      SET	.LUM2 + .STEP2
     24  42aa				   .LUM3      SET	.LUM3 + .STEP3
     13  42aa					      REPEND
     14  42aa		       66		      .byte.b	$60+(.LUM1/256)
     15  42ab		       84		      .byte.b	$80+(.LUM2/256)
     16  42ac		       18		      .byte.b	$10+(.LUM3/256)
     17  42ad
     18  42ad
     19  42ad
     20  42ad
     21  42ad
     22  42ad				   .LUM1      SET	.LUM1 + .STEP1
     23  42ad				   .LUM2      SET	.LUM2 + .STEP2
     24  42ad				   .LUM3      SET	.LUM3 + .STEP3
     13  42ad					      REPEND
     14  42ad		       66		      .byte.b	$60+(.LUM1/256)
     15  42ae		       84		      .byte.b	$80+(.LUM2/256)
     16  42af		       18		      .byte.b	$10+(.LUM3/256)
     17  42b0
     18  42b0
     19  42b0
     20  42b0
     21  42b0
     22  42b0				   .LUM1      SET	.LUM1 + .STEP1
     23  42b0				   .LUM2      SET	.LUM2 + .STEP2
     24  42b0				   .LUM3      SET	.LUM3 + .STEP3
     25  42b0					      REPEND
    262  42b0							;colr_pal	  LUMTABLE $90, $20, $60, $6,$A,$a,$C,$6,$8
    263  42b0
------- FILE titleData.asm LEVEL 3 PASS 5
      0  42b0					      include	"titleData.asm"
      1  42b0				   COL_0
      2  42b0		       00		      .byte.b	0	;R (71)
      3  42b1		       00		      .byte.b	0	;G
      4  42b2		       00		      .byte.b	0	;B
      5  42b3		       40		      .byte.b	64	;R (70)
      6  42b4		       40		      .byte.b	64	;G
      7  42b5		       00		      .byte.b	0	;B
      8  42b6		       00		      .byte.b	0	;R (69)
      9  42b7		       00		      .byte.b	0	;G
     10  42b8		       00		      .byte.b	0	;B
     11  42b9		       00		      .byte.b	0	;R (68)
     12  42ba		       80		      .byte.b	128	;G
     13  42bb		       00		      .byte.b	0	;B
     14  42bc		       00		      .byte.b	0	;R (67)
     15  42bd		       20		      .byte.b	32	;G
     16  42be		       00		      .byte.b	0	;B
     17  42bf		       80		      .byte.b	128	;R (66)
     18  42c0		       80		      .byte.b	128	;G
     19  42c1		       00		      .byte.b	0	;B
     20  42c2		       c0		      .byte.b	192	;R (65)
     21  42c3		       c0		      .byte.b	192	;G
     22  42c4		       00		      .byte.b	0	;B
     23  42c5		       40		      .byte.b	64	;R (64)
     24  42c6		       c0		      .byte.b	192	;G
     25  42c7		       00		      .byte.b	0	;B
     26  42c8		       00		      .byte.b	0	;R (63)
     27  42c9		       a0		      .byte.b	160	;G
     28  42ca		       00		      .byte.b	0	;B
     29  42cb		       10		      .byte.b	16	;R (62)
     30  42cc		       70		      .byte.b	112	;G
     31  42cd		       00		      .byte.b	0	;B
     32  42ce		       00		      .byte.b	0	;R (61)
     33  42cf		       80		      .byte.b	128	;G
     34  42d0		       40		      .byte.b	64	;B
     35  42d1		       00		      .byte.b	0	;R (60)
     36  42d2		       c0		      .byte.b	192	;G
     37  42d3		       00		      .byte.b	0	;B
     38  42d4		       00		      .byte.b	0	;R (59)
     39  42d5		       c0		      .byte.b	192	;G
     40  42d6		       00		      .byte.b	0	;B
     41  42d7		       00		      .byte.b	0	;R (58)
     42  42d8		       40		      .byte.b	64	;G
     43  42d9		       00		      .byte.b	0	;B
     44  42da		       00		      .byte.b	0	;R (57)
     45  42db		       c0		      .byte.b	192	;G
     46  42dc		       00		      .byte.b	0	;B
     47  42dd		       00		      .byte.b	0	;R (56)
     48  42de		       60		      .byte.b	96	;G
     49  42df		       00		      .byte.b	0	;B
     50  42e0		       00		      .byte.b	0	;R (55)
     51  42e1		       80		      .byte.b	128	;G
     52  42e2		       00		      .byte.b	0	;B
     53  42e3		       00		      .byte.b	0	;R (54)
     54  42e4		       40		      .byte.b	64	;G
     55  42e5		       00		      .byte.b	0	;B
     56  42e6		       00		      .byte.b	0	;R (53)
     57  42e7		       80		      .byte.b	128	;G
     58  42e8		       00		      .byte.b	0	;B
     59  42e9		       00		      .byte.b	0	;R (52)
     60  42ea		       80		      .byte.b	128	;G
     61  42eb		       00		      .byte.b	0	;B
     62  42ec		       00		      .byte.b	0	;R (51)
     63  42ed		       10		      .byte.b	16	;G
     64  42ee		       00		      .byte.b	0	;B
     65  42ef		       00		      .byte.b	0	;R (50)
     66  42f0		       00		      .byte.b	0	;G
     67  42f1		       00		      .byte.b	0	;B
     68  42f2		       00		      .byte.b	0	;R (49)
     69  42f3		       00		      .byte.b	0	;G
     70  42f4		       00		      .byte.b	0	;B
     71  42f5		       00		      .byte.b	0	;R (48)
     72  42f6		       00		      .byte.b	0	;G
     73  42f7		       00		      .byte.b	0	;B
     74  42f8		       00		      .byte.b	0	;R (47)
     75  42f9		       00		      .byte.b	0	;G
     76  42fa		       00		      .byte.b	0	;B
     77  42fb		       00		      .byte.b	0	;R (46)
     78  42fc		       40		      .byte.b	64	;G
     79  42fd		       00		      .byte.b	0	;B
     80  42fe		       00		      .byte.b	0	;R (45)
     81  42ff		       00		      .byte.b	0	;G
     82  4300		       00		      .byte.b	0	;B
     83  4301		       00		      .byte.b	0	;R (44)
     84  4302		       00		      .byte.b	0	;G
     85  4303		       00		      .byte.b	0	;B
     86  4304		       00		      .byte.b	0	;R (43)
     87  4305		       00		      .byte.b	0	;G
     88  4306		       00		      .byte.b	0	;B
     89  4307		       00		      .byte.b	0	;R (42)
     90  4308		       40		      .byte.b	64	;G
     91  4309		       00		      .byte.b	0	;B
     92  430a		       00		      .byte.b	0	;R (41)
     93  430b		       00		      .byte.b	0	;G
     94  430c		       00		      .byte.b	0	;B
     95  430d		       00		      .byte.b	0	;R (40)
     96  430e		       00		      .byte.b	0	;G
     97  430f		       00		      .byte.b	0	;B
     98  4310		       00		      .byte.b	0	;R (39)
     99  4311		       20		      .byte.b	32	;G
    100  4312		       00		      .byte.b	0	;B
    101  4313		       00		      .byte.b	0	;R (38)
    102  4314		       00		      .byte.b	0	;G
    103  4315		       00		      .byte.b	0	;B
    104  4316		       00		      .byte.b	0	;R (37)
    105  4317		       10		      .byte.b	16	;G
    106  4318		       00		      .byte.b	0	;B
    107  4319		       00		      .byte.b	0	;R (36)
    108  431a		       00		      .byte.b	0	;G
    109  431b		       00		      .byte.b	0	;B
    110  431c		       00		      .byte.b	0	;R (35)
    111  431d		       40		      .byte.b	64	;G
    112  431e		       00		      .byte.b	0	;B
    113  431f		       00		      .byte.b	0	;R (34)
    114  4320		       20		      .byte.b	32	;G
    115  4321		       00		      .byte.b	0	;B
    116  4322		       00		      .byte.b	0	;R (33)
    117  4323		       00		      .byte.b	0	;G
    118  4324		       00		      .byte.b	0	;B
    119  4325		       00		      .byte.b	0	;R (32)
    120  4326		       00		      .byte.b	0	;G
    121  4327		       00		      .byte.b	0	;B
    122  4328		       00		      .byte.b	0	;R (31)
    123  4329		       20		      .byte.b	32	;G
    124  432a		       00		      .byte.b	0	;B
    125  432b		       00		      .byte.b	0	;R (30)
    126  432c		       00		      .byte.b	0	;G
    127  432d		       00		      .byte.b	0	;B
    128  432e		       00		      .byte.b	0	;R (29)
    129  432f		       80		      .byte.b	128	;G
    130  4330		       00		      .byte.b	0	;B
    131  4331		       00		      .byte.b	0	;R (28)
    132  4332		       00		      .byte.b	0	;G
    133  4333		       00		      .byte.b	0	;B
    134  4334		       00		      .byte.b	0	;R (27)
    135  4335		       20		      .byte.b	32	;G
    136  4336		       00		      .byte.b	0	;B
    137  4337		       00		      .byte.b	0	;R (26)
    138  4338		       00		      .byte.b	0	;G
    139  4339		       00		      .byte.b	0	;B
    140  433a		       00		      .byte.b	0	;R (25)
    141  433b		       00		      .byte.b	0	;G
    142  433c		       00		      .byte.b	0	;B
    143  433d		       00		      .byte.b	0	;R (24)
    144  433e		       20		      .byte.b	32	;G
    145  433f		       00		      .byte.b	0	;B
    146  4340		       00		      .byte.b	0	;R (23)
    147  4341		       00		      .byte.b	0	;G
    148  4342		       00		      .byte.b	0	;B
    149  4343		       00		      .byte.b	0	;R (22)
    150  4344		       00		      .byte.b	0	;G
    151  4345		       00		      .byte.b	0	;B
    152  4346		       00		      .byte.b	0	;R (21)
    153  4347		       20		      .byte.b	32	;G
    154  4348		       00		      .byte.b	0	;B
    155  4349		       00		      .byte.b	0	;R (20)
    156  434a		       00		      .byte.b	0	;G
    157  434b		       00		      .byte.b	0	;B
    158  434c		       00		      .byte.b	0	;R (19)
    159  434d		       00		      .byte.b	0	;G
    160  434e		       00		      .byte.b	0	;B
    161  434f		       00		      .byte.b	0	;R (18)
    162  4350		       00		      .byte.b	0	;G
    163  4351		       00		      .byte.b	0	;B
    164  4352		       00		      .byte.b	0	;R (17)
    165  4353		       80		      .byte.b	128	;G
    166  4354		       00		      .byte.b	0	;B
    167  4355		       00		      .byte.b	0	;R (16)
    168  4356		       00		      .byte.b	0	;G
    169  4357		       00		      .byte.b	0	;B
    170  4358		       00		      .byte.b	0	;R (15)
    171  4359		       10		      .byte.b	16	;G
    172  435a		       00		      .byte.b	0	;B
    173  435b		       00		      .byte.b	0	;R (14)
    174  435c		       00		      .byte.b	0	;G
    175  435d		       00		      .byte.b	0	;B
    176  435e		       00		      .byte.b	0	;R (13)
    177  435f		       00		      .byte.b	0	;G
    178  4360		       00		      .byte.b	0	;B
    179  4361		       00		      .byte.b	0	;R (12)
    180  4362		       80		      .byte.b	128	;G
    181  4363		       00		      .byte.b	0	;B
    182  4364		       00		      .byte.b	0	;R (11)
    183  4365		       00		      .byte.b	0	;G
    184  4366		       00		      .byte.b	0	;B
    185  4367		       00		      .byte.b	0	;R (10)
    186  4368		       00		      .byte.b	0	;G
    187  4369		       00		      .byte.b	0	;B
    188  436a		       00		      .byte.b	0	;R (9)
    189  436b		       80		      .byte.b	128	;G
    190  436c		       00		      .byte.b	0	;B
    191  436d		       00		      .byte.b	0	;R (8)
    192  436e		       00		      .byte.b	0	;G
    193  436f		       00		      .byte.b	0	;B
    194  4370		       00		      .byte.b	0	;R (7)
    195  4371		       20		      .byte.b	32	;G
    196  4372		       00		      .byte.b	0	;B
    197  4373		       00		      .byte.b	0	;R (6)
    198  4374		       00		      .byte.b	0	;G
    199  4375		       00		      .byte.b	0	;B
    200  4376		       00		      .byte.b	0	;R (5)
    201  4377		       10		      .byte.b	16	;G
    202  4378		       00		      .byte.b	0	;B
    203  4379		       00		      .byte.b	0	;R (4)
    204  437a		       00		      .byte.b	0	;G
    205  437b		       00		      .byte.b	0	;B
    206  437c		       00		      .byte.b	0	;R (3)
    207  437d		       00		      .byte.b	0	;G
    208  437e		       00		      .byte.b	0	;B
    209  437f		       00		      .byte.b	0	;R (2)
    210  4380		       40		      .byte.b	64	;G
    211  4381		       00		      .byte.b	0	;B
    212  4382		       00		      .byte.b	0	;R (1)
    213  4383		       00		      .byte.b	0	;G
    214  4384		       00		      .byte.b	0	;B
    215  4385		       00		      .byte.b	0	;R (0)
    216  4386		       00		      .byte.b	0	;G
    217  4387		       00		      .byte.b	0	;B
    218  4388				   COL_1
    219  4388		       80		      .byte.b	128	;R (71)
    220  4389		       80		      .byte.b	128	;G
    221  438a		       00		      .byte.b	0	;B
    222  438b		       10		      .byte.b	16	;R (70)
    223  438c		       14		      .byte.b	20	;G
    224  438d		       00		      .byte.b	0	;B
    225  438e		       00		      .byte.b	0	;R (69)
    226  438f		       41		      .byte.b	65	;G
    227  4390		       00		      .byte.b	0	;B
    228  4391		       00		      .byte.b	0	;R (68)
    229  4392		       08		      .byte.b	8	;G
    230  4393		       00		      .byte.b	0	;B
    231  4394		       20		      .byte.b	32	;R (67)
    232  4395		       20		      .byte.b	32	;G
    233  4396		       00		      .byte.b	0	;B
    234  4397		       63		      .byte.b	99	;R (66)
    235  4398		       6b		      .byte.b	107	;G
    236  4399		       00		      .byte.b	0	;B
    237  439a		       ff		      .byte.b	255	;R (65)
    238  439b		       f5		      .byte.b	245	;G
    239  439c		       00		      .byte.b	0	;B
    240  439d		       80		      .byte.b	128	;R (64)
    241  439e		       fb		      .byte.b	251	;G
    242  439f		       04		      .byte.b	4	;B
    243  43a0		       00		      .byte.b	0	;R (63)
    244  43a1		       b7		      .byte.b	183	;G
    245  43a2		       00		      .byte.b	0	;B
    246  43a3		       00		      .byte.b	0	;R (62)
    247  43a4		       b5		      .byte.b	181	;G
    248  43a5		       00		      .byte.b	0	;B
    249  43a6		       00		      .byte.b	0	;R (61)
    250  43a7		       ef		      .byte.b	239	;G
    251  43a8		       10		      .byte.b	16	;B
    252  43a9		       00		      .byte.b	0	;R (60)
    253  43aa		       bd		      .byte.b	189	;G
    254  43ab		       42		      .byte.b	66	;B
    255  43ac		       00		      .byte.b	0	;R (59)
    256  43ad		       77		      .byte.b	119	;G
    257  43ae		       00		      .byte.b	0	;B
    258  43af		       00		      .byte.b	0	;R (58)
    259  43b0		       ee		      .byte.b	238	;G
    260  43b1		       00		      .byte.b	0	;B
    261  43b2		       00		      .byte.b	0	;R (57)
    262  43b3		       9b		      .byte.b	155	;G
    263  43b4		       00		      .byte.b	0	;B
    264  43b5		       00		      .byte.b	0	;R (56)
    265  43b6		       f2		      .byte.b	242	;G
    266  43b7		       00		      .byte.b	0	;B
    267  43b8		       00		      .byte.b	0	;R (55)
    268  43b9		       40		      .byte.b	64	;G
    269  43ba		       00		      .byte.b	0	;B
    270  43bb		       00		      .byte.b	0	;R (54)
    271  43bc		       df		      .byte.b	223	;G
    272  43bd		       00		      .byte.b	0	;B
    273  43be		       10		      .byte.b	16	;R (53)
    274  43bf		       69		      .byte.b	105	;G
    275  43c0		       10		      .byte.b	16	;B
    276  43c1		       00		      .byte.b	0	;R (52)
    277  43c2		       4b		      .byte.b	75	;G
    278  43c3		       00		      .byte.b	0	;B
    279  43c4		       00		      .byte.b	0	;R (51)
    280  43c5		       b0		      .byte.b	176	;G
    281  43c6		       00		      .byte.b	0	;B
    282  43c7		       00		      .byte.b	0	;R (50)
    283  43c8		       a7		      .byte.b	167	;G
    284  43c9		       00		      .byte.b	0	;B
    285  43ca		       00		      .byte.b	0	;R (49)
    286  43cb		       7d		      .byte.b	125	;G
    287  43cc		       02		      .byte.b	2	;B
    288  43cd		       00		      .byte.b	0	;R (48)
    289  43ce		       db		      .byte.b	219	;G
    290  43cf		       20		      .byte.b	32	;B
    291  43d0		       00		      .byte.b	0	;R (47)
    292  43d1		       6d		      .byte.b	109	;G
    293  43d2		       00		      .byte.b	0	;B
    294  43d3		       00		      .byte.b	0	;R (46)
    295  43d4		       ea		      .byte.b	234	;G
    296  43d5		       00		      .byte.b	0	;B
    297  43d6		       00		      .byte.b	0	;R (45)
    298  43d7		       13		      .byte.b	19	;G
    299  43d8		       00		      .byte.b	0	;B
    300  43d9		       00		      .byte.b	0	;R (44)
    301  43da		       7e		      .byte.b	126	;G
    302  43db		       01		      .byte.b	1	;B
    303  43dc		       22		      .byte.b	34	;R (43)
    304  43dd		       77		      .byte.b	119	;G
    305  43de		       08		      .byte.b	8	;B
    306  43df		       04		      .byte.b	4	;R (42)
    307  43e0		       5f		      .byte.b	95	;G
    308  43e1		       00		      .byte.b	0	;B
    309  43e2		       00		      .byte.b	0	;R (41)
    310  43e3		       6f		      .byte.b	111	;G
    311  43e4		       00		      .byte.b	0	;B
    312  43e5		       00		      .byte.b	0	;R (40)
    313  43e6		       b5		      .byte.b	181	;G
    314  43e7		       00		      .byte.b	0	;B
    315  43e8		       00		      .byte.b	0	;R (39)
    316  43e9		       5b		      .byte.b	91	;G
    317  43ea		       00		      .byte.b	0	;B
    318  43eb		       00		      .byte.b	0	;R (38)
    319  43ec		       57		      .byte.b	87	;G
    320  43ed		       00		      .byte.b	0	;B
    321  43ee		       20		      .byte.b	32	;R (37)
    322  43ef		       4d		      .byte.b	77	;G
    323  43f0		       22		      .byte.b	34	;B
    324  43f1		       00		      .byte.b	0	;R (36)
    325  43f2		       55		      .byte.b	85	;G
    326  43f3		       00		      .byte.b	0	;B
    327  43f4		       01		      .byte.b	1	;R (35)
    328  43f5		       56		      .byte.b	86	;G
    329  43f6		       00		      .byte.b	0	;B
    330  43f7		       02		      .byte.b	2	;R (34)
    331  43f8		       57		      .byte.b	87	;G
    332  43f9		       00		      .byte.b	0	;B
    333  43fa		       00		      .byte.b	0	;R (33)
    334  43fb		       2a		      .byte.b	42	;G
    335  43fc		       01		      .byte.b	1	;B
    336  43fd		       01		      .byte.b	1	;R (32)
    337  43fe		       ab		      .byte.b	171	;G
    338  43ff		       00		      .byte.b	0	;B
    339  4400		       22		      .byte.b	34	;R (31)
    340  4401		       17		      .byte.b	23	;G
    341  4402		       20		      .byte.b	32	;B
    342  4403		       00		      .byte.b	0	;R (30)
    343  4404		       55		      .byte.b	85	;G
    344  4405		       02		      .byte.b	2	;B
    345  4406		       22		      .byte.b	34	;R (29)
    346  4407		       17		      .byte.b	23	;G
    347  4408		       20		      .byte.b	32	;B
    348  4409		       00		      .byte.b	0	;R (28)
    349  440a		       2b		      .byte.b	43	;G
    350  440b		       00		      .byte.b	0	;B
    351  440c		       00		      .byte.b	0	;R (27)
    352  440d		       95		      .byte.b	149	;G
    353  440e		       02		      .byte.b	2	;B
    354  440f		       00		      .byte.b	0	;R (26)
    355  4410		       17		      .byte.b	23	;G
    356  4411		       00		      .byte.b	0	;B
    357  4412		       00		      .byte.b	0	;R (25)
    358  4413		       2d		      .byte.b	45	;G
    359  4414		       00		      .byte.b	0	;B
    360  4415		       00		      .byte.b	0	;R (24)
    361  4416		       b4		      .byte.b	180	;G
    362  4417		       00		      .byte.b	0	;B
    363  4418		       00		      .byte.b	0	;R (23)
    364  4419		       0a		      .byte.b	10	;G
    365  441a		       00		      .byte.b	0	;B
    366  441b		       10		      .byte.b	16	;R (22)
    367  441c		       3c		      .byte.b	60	;G
    368  441d		       00		      .byte.b	0	;B
    369  441e		       10		      .byte.b	16	;R (21)
    370  441f		       98		      .byte.b	152	;G
    371  4420		       00		      .byte.b	0	;B
    372  4421		       10		      .byte.b	16	;R (20)
    373  4422		       1a		      .byte.b	26	;G
    374  4423		       00		      .byte.b	0	;B
    375  4424		       00		      .byte.b	0	;R (19)
    376  4425		       14		      .byte.b	20	;G
    377  4426		       00		      .byte.b	0	;B
    378  4427		       00		      .byte.b	0	;R (18)
    379  4428		       5a		      .byte.b	90	;G
    380  4429		       00		      .byte.b	0	;B
    381  442a		       00		      .byte.b	0	;R (17)
    382  442b		       09		      .byte.b	9	;G
    383  442c		       00		      .byte.b	0	;B
    384  442d		       08		      .byte.b	8	;R (16)
    385  442e		       1d		      .byte.b	29	;G
    386  442f		       00		      .byte.b	0	;B
    387  4430		       00		      .byte.b	0	;R (15)
    388  4431		       1a		      .byte.b	26	;G
    389  4432		       00		      .byte.b	0	;B
    390  4433		       20		      .byte.b	32	;R (14)
    391  4434		       ba		      .byte.b	186	;G
    392  4435		       00		      .byte.b	0	;B
    393  4436		       00		      .byte.b	0	;R (13)
    394  4437		       12		      .byte.b	18	;G
    395  4438		       00		      .byte.b	0	;B
    396  4439		       00		      .byte.b	0	;R (12)
    397  443a		       1a		      .byte.b	26	;G
    398  443b		       00		      .byte.b	0	;B
    399  443c		       00		      .byte.b	0	;R (11)
    400  443d		       2d		      .byte.b	45	;G
    401  443e		       10		      .byte.b	16	;B
    402  443f		       10		      .byte.b	16	;R (10)
    403  4440		       3b		      .byte.b	59	;G
    404  4441		       00		      .byte.b	0	;B
    405  4442		       24		      .byte.b	36	;R (9)
    406  4443		       39		      .byte.b	57	;G
    407  4444		       04		      .byte.b	4	;B
    408  4445		       20		      .byte.b	32	;R (8)
    409  4446		       35		      .byte.b	53	;G
    410  4447		       00		      .byte.b	0	;B
    411  4448		       00		      .byte.b	0	;R (7)
    412  4449		       3d		      .byte.b	61	;G
    413  444a		       00		      .byte.b	0	;B
    414  444b		       00		      .byte.b	0	;R (6)
    415  444c		       32		      .byte.b	50	;G
    416  444d		       00		      .byte.b	0	;B
    417  444e		       00		      .byte.b	0	;R (5)
    418  444f		       98		      .byte.b	152	;G
    419  4450		       00		      .byte.b	0	;B
    420  4451		       00		      .byte.b	0	;R (4)
    421  4452		       12		      .byte.b	18	;G
    422  4453		       00		      .byte.b	0	;B
    423  4454		       00		      .byte.b	0	;R (3)
    424  4455		       20		      .byte.b	32	;G
    425  4456		       00		      .byte.b	0	;B
    426  4457		       01		      .byte.b	1	;R (2)
    427  4458		       49		      .byte.b	73	;G
    428  4459		       00		      .byte.b	0	;B
    429  445a		       20		      .byte.b	32	;R (1)
    430  445b		       20		      .byte.b	32	;G
    431  445c		       00		      .byte.b	0	;B
    432  445d		       00		      .byte.b	0	;R (0)
    433  445e		       00		      .byte.b	0	;G
    434  445f		       00		      .byte.b	0	;B
    435  4460				   COL_2
    436  4460		       14		      .byte.b	20	;R (71)
    437  4461		       14		      .byte.b	20	;G
    438  4462		       00		      .byte.b	0	;B
    439  4463		       40		      .byte.b	64	;R (70)
    440  4464		       42		      .byte.b	66	;G
    441  4465		       00		      .byte.b	0	;B
    442  4466		       a8		      .byte.b	168	;R (69)
    443  4467		       a8		      .byte.b	168	;G
    444  4468		       00		      .byte.b	0	;B
    445  4469		       fd		      .byte.b	253	;R (68)
    446  446a		       1d		      .byte.b	29	;G
    447  446b		       00		      .byte.b	0	;B
    448  446c		       f0		      .byte.b	240	;R (67)
    449  446d		       44		      .byte.b	68	;G
    450  446e		       08		      .byte.b	8	;B
    451  446f		       ff		      .byte.b	255	;R (66)
    452  4470		       2f		      .byte.b	47	;G
    453  4471		       00		      .byte.b	0	;B
    454  4472		       ff		      .byte.b	255	;R (65)
    455  4473		       0e		      .byte.b	14	;G
    456  4474		       00		      .byte.b	0	;B
    457  4475		       f8		      .byte.b	248	;R (64)
    458  4476		       0f		      .byte.b	15	;G
    459  4477		       00		      .byte.b	0	;B
    460  4478		       f8		      .byte.b	248	;R (63)
    461  4479		       2e		      .byte.b	46	;G
    462  447a		       00		      .byte.b	0	;B
    463  447b		       f8		      .byte.b	248	;R (62)
    464  447c		       1e		      .byte.b	30	;G
    465  447d		       01		      .byte.b	1	;B
    466  447e		       74		      .byte.b	116	;R (61)
    467  447f		       23		      .byte.b	35	;G
    468  4480		       88		      .byte.b	136	;B
    469  4481		       fc		      .byte.b	252	;R (60)
    470  4482		       0f		      .byte.b	15	;G
    471  4483		       00		      .byte.b	0	;B
    472  4484		       f8		      .byte.b	248	;R (59)
    473  4485		       06		      .byte.b	6	;G
    474  4486		       01		      .byte.b	1	;B
    475  4487		       f8		      .byte.b	248	;R (58)
    476  4488		       8f		      .byte.b	143	;G
    477  4489		       00		      .byte.b	0	;B
    478  448a		       e8		      .byte.b	232	;R (57)
    479  448b		       0e		      .byte.b	14	;G
    480  448c		       10		      .byte.b	16	;B
    481  448d		       e0		      .byte.b	224	;R (56)
    482  448e		       97		      .byte.b	151	;G
    483  448f		       00		      .byte.b	0	;B
    484  4490		       f0		      .byte.b	240	;R (55)
    485  4491		       3a		      .byte.b	58	;G
    486  4492		       00		      .byte.b	0	;B
    487  4493		       e0		      .byte.b	224	;R (54)
    488  4494		       bb		      .byte.b	187	;G
    489  4495		       04		      .byte.b	4	;B
    490  4496		       e0		      .byte.b	224	;R (53)
    491  4497		       3e		      .byte.b	62	;G
    492  4498		       00		      .byte.b	0	;B
    493  4499		       c0		      .byte.b	192	;R (52)
    494  449a		       2a		      .byte.b	42	;G
    495  449b		       00		      .byte.b	0	;B
    496  449c		       80		      .byte.b	128	;R (51)
    497  449d		       3f		      .byte.b	63	;G
    498  449e		       40		      .byte.b	64	;B
    499  449f		       f5		      .byte.b	245	;R (50)
    500  44a0		       3f		      .byte.b	63	;G
    501  44a1		       00		      .byte.b	0	;B
    502  44a2		       e8		      .byte.b	232	;R (49)
    503  44a3		       7f		      .byte.b	127	;G
    504  44a4		       00		      .byte.b	0	;B
    505  44a5		       e0		      .byte.b	224	;R (48)
    506  44a6		       7a		      .byte.b	122	;G
    507  44a7		       04		      .byte.b	4	;B
    508  44a8		       c0		      .byte.b	192	;R (47)
    509  44a9		       5f		      .byte.b	95	;G
    510  44aa		       00		      .byte.b	0	;B
    511  44ab		       90		      .byte.b	144	;R (46)
    512  44ac		       dd		      .byte.b	221	;G
    513  44ad		       02		      .byte.b	2	;B
    514  44ae		       84		      .byte.b	132	;R (45)
    515  44af		       9f		      .byte.b	159	;G
    516  44b0		       00		      .byte.b	0	;B
    517  44b1		       c4		      .byte.b	196	;R (44)
    518  44b2		       cf		      .byte.b	207	;G
    519  44b3		       00		      .byte.b	0	;B
    520  44b4		       c5		      .byte.b	197	;R (43)
    521  44b5		       1f		      .byte.b	31	;G
    522  44b6		       00		      .byte.b	0	;B
    523  44b7		       d4		      .byte.b	212	;R (42)
    524  44b8		       9f		      .byte.b	159	;G
    525  44b9		       20		      .byte.b	32	;B
    526  44ba		       c8		      .byte.b	200	;R (41)
    527  44bb		       1e		      .byte.b	30	;G
    528  44bc		       01		      .byte.b	1	;B
    529  44bd		       c8		      .byte.b	200	;R (40)
    530  44be		       5f		      .byte.b	95	;G
    531  44bf		       00		      .byte.b	0	;B
    532  44c0		       cd		      .byte.b	205	;R (39)
    533  44c1		       5e		      .byte.b	94	;G
    534  44c2		       00		      .byte.b	0	;B
    535  44c3		       c7		      .byte.b	199	;R (38)
    536  44c4		       5b		      .byte.b	91	;G
    537  44c5		       00		      .byte.b	0	;B
    538  44c6		       8b		      .byte.b	139	;R (37)
    539  44c7		       1c		      .byte.b	28	;G
    540  44c8		       00		      .byte.b	0	;B
    541  44c9		       81		      .byte.b	129	;R (36)
    542  44ca		       9a		      .byte.b	154	;G
    543  44cb		       04		      .byte.b	4	;B
    544  44cc		       8e		      .byte.b	142	;R (35)
    545  44cd		       9d		      .byte.b	157	;G
    546  44ce		       00		      .byte.b	0	;B
    547  44cf		       2b		      .byte.b	43	;R (34)
    548  44d0		       36		      .byte.b	54	;G
    549  44d1		       00		      .byte.b	0	;B
    550  44d2		       3a		      .byte.b	58	;R (33)
    551  44d3		       0d		      .byte.b	13	;G
    552  44d4		       00		      .byte.b	0	;B
    553  44d5		       3e		      .byte.b	62	;R (32)
    554  44d6		       85		      .byte.b	133	;G
    555  44d7		       40		      .byte.b	64	;B
    556  44d8		       fa		      .byte.b	250	;R (31)
    557  44d9		       17		      .byte.b	23	;G
    558  44da		       00		      .byte.b	0	;B
    559  44db		       ff		      .byte.b	255	;R (30)
    560  44dc		       03		      .byte.b	3	;G
    561  44dd		       00		      .byte.b	0	;B
    562  44de		       fc		      .byte.b	252	;R (29)
    563  44df		       93		      .byte.b	147	;G
    564  44e0		       00		      .byte.b	0	;B
    565  44e1		       f7		      .byte.b	247	;R (28)
    566  44e2		       81		      .byte.b	129	;G
    567  44e3		       08		      .byte.b	8	;B
    568  44e4		       ff		      .byte.b	255	;R (27)
    569  44e5		       03		      .byte.b	3	;G
    570  44e6		       00		      .byte.b	0	;B
    571  44e7		       fe		      .byte.b	254	;R (26)
    572  44e8		       2b		      .byte.b	43	;G
    573  44e9		       00		      .byte.b	0	;B
    574  44ea		       fe		      .byte.b	254	;R (25)
    575  44eb		       0a		      .byte.b	10	;G
    576  44ec		       00		      .byte.b	0	;B
    577  44ed		       fc		      .byte.b	252	;R (24)
    578  44ee		       4f		      .byte.b	79	;G
    579  44ef		       00		      .byte.b	0	;B
    580  44f0		       fc		      .byte.b	252	;R (23)
    581  44f1		       55		      .byte.b	85	;G
    582  44f2		       00		      .byte.b	0	;B
    583  44f3		       f8		      .byte.b	248	;R (22)
    584  44f4		       45		      .byte.b	69	;G
    585  44f5		       00		      .byte.b	0	;B
    586  44f6		       e8		      .byte.b	232	;R (21)
    587  44f7		       05		      .byte.b	5	;G
    588  44f8		       10		      .byte.b	16	;B
    589  44f9		       f8		      .byte.b	248	;R (20)
    590  44fa		       5b		      .byte.b	91	;G
    591  44fb		       00		      .byte.b	0	;B
    592  44fc		       f8		      .byte.b	248	;R (19)
    593  44fd		       1d		      .byte.b	29	;G
    594  44fe		       00		      .byte.b	0	;B
    595  44ff		       f0		      .byte.b	240	;R (18)
    596  4500		       55		      .byte.b	85	;G
    597  4501		       00		      .byte.b	0	;B
    598  4502		       f0		      .byte.b	240	;R (17)
    599  4503		       16		      .byte.b	22	;G
    600  4504		       00		      .byte.b	0	;B
    601  4505		       f0		      .byte.b	240	;R (16)
    602  4506		       b2		      .byte.b	178	;G
    603  4507		       00		      .byte.b	0	;B
    604  4508		       e0		      .byte.b	224	;R (15)
    605  4509		       0e		      .byte.b	14	;G
    606  450a		       10		      .byte.b	16	;B
    607  450b		       f0		      .byte.b	240	;R (14)
    608  450c		       93		      .byte.b	147	;G
    609  450d		       00		      .byte.b	0	;B
    610  450e		       e0		      .byte.b	224	;R (13)
    611  450f		       25		      .byte.b	37	;G
    612  4510		       00		      .byte.b	0	;B
    613  4511		       c0		      .byte.b	192	;R (12)
    614  4512		       e5		      .byte.b	229	;G
    615  4513		       00		      .byte.b	0	;B
    616  4514		       80		      .byte.b	128	;R (11)
    617  4515		       0e		      .byte.b	14	;G
    618  4516		       00		      .byte.b	0	;B
    619  4517		       c0		      .byte.b	192	;R (10)
    620  4518		       ca		      .byte.b	202	;G
    621  4519		       00		      .byte.b	0	;B
    622  451a		       84		      .byte.b	132	;R (9)
    623  451b		       8e		      .byte.b	142	;G
    624  451c		       00		      .byte.b	0	;B
    625  451d		       00		      .byte.b	0	;R (8)
    626  451e		       8e		      .byte.b	142	;G
    627  451f		       00		      .byte.b	0	;B
    628  4520		       00		      .byte.b	0	;R (7)
    629  4521		       15		      .byte.b	21	;G
    630  4522		       00		      .byte.b	0	;B
    631  4523		       00		      .byte.b	0	;R (6)
    632  4524		       14		      .byte.b	20	;G
    633  4525		       00		      .byte.b	0	;B
    634  4526		       00		      .byte.b	0	;R (5)
    635  4527		       14		      .byte.b	20	;G
    636  4528		       00		      .byte.b	0	;B
    637  4529		       00		      .byte.b	0	;R (4)
    638  452a		       0a		      .byte.b	10	;G
    639  452b		       00		      .byte.b	0	;B
    640  452c		       00		      .byte.b	0	;R (3)
    641  452d		       10		      .byte.b	16	;G
    642  452e		       00		      .byte.b	0	;B
    643  452f		       08		      .byte.b	8	;R (2)
    644  4530		       88		      .byte.b	136	;G
    645  4531		       00		      .byte.b	0	;B
    646  4532		       40		      .byte.b	64	;R (1)
    647  4533		       42		      .byte.b	66	;G
    648  4534		       00		      .byte.b	0	;B
    649  4535		       00		      .byte.b	0	;R (0)
    650  4536		       00		      .byte.b	0	;G
    651  4537		       00		      .byte.b	0	;B
    652  4538				   COL_3
    653  4538		       90		      .byte.b	144	;R (71)
    654  4539		       90		      .byte.b	144	;G
    655  453a		       00		      .byte.b	0	;B
    656  453b		       40		      .byte.b	64	;R (70)
    657  453c		       40		      .byte.b	64	;G
    658  453d		       00		      .byte.b	0	;B
    659  453e		       b0		      .byte.b	176	;R (69)
    660  453f		       b0		      .byte.b	176	;G
    661  4540		       00		      .byte.b	0	;B
    662  4541		       d0		      .byte.b	208	;R (68)
    663  4542		       00		      .byte.b	0	;G
    664  4543		       20		      .byte.b	32	;B
    665  4544		       f0		      .byte.b	240	;R (67)
    666  4545		       00		      .byte.b	0	;G
    667  4546		       00		      .byte.b	0	;B
    668  4547		       f0		      .byte.b	240	;R (66)
    669  4548		       d0		      .byte.b	208	;G
    670  4549		       00		      .byte.b	0	;B
    671  454a		       f0		      .byte.b	240	;R (65)
    672  454b		       00		      .byte.b	0	;G
    673  454c		       00		      .byte.b	0	;B
    674  454d		       f0		      .byte.b	240	;R (64)
    675  454e		       00		      .byte.b	0	;G
    676  454f		       00		      .byte.b	0	;B
    677  4550		       f0		      .byte.b	240	;R (63)
    678  4551		       50		      .byte.b	80	;G
    679  4552		       00		      .byte.b	0	;B
    680  4553		       f0		      .byte.b	240	;R (62)
    681  4554		       00		      .byte.b	0	;G
    682  4555		       00		      .byte.b	0	;B
    683  4556		       f0		      .byte.b	240	;R (61)
    684  4557		       a0		      .byte.b	160	;G
    685  4558		       00		      .byte.b	0	;B
    686  4559		       f0		      .byte.b	240	;R (60)
    687  455a		       00		      .byte.b	0	;G
    688  455b		       00		      .byte.b	0	;B
    689  455c		       f0		      .byte.b	240	;R (59)
    690  455d		       d0		      .byte.b	208	;G
    691  455e		       00		      .byte.b	0	;B
    692  455f		       f0		      .byte.b	240	;R (58)
    693  4560		       c0		      .byte.b	192	;G
    694  4561		       00		      .byte.b	0	;B
    695  4562		       f0		      .byte.b	240	;R (57)
    696  4563		       90		      .byte.b	144	;G
    697  4564		       00		      .byte.b	0	;B
    698  4565		       f0		      .byte.b	240	;R (56)
    699  4566		       80		      .byte.b	128	;G
    700  4567		       00		      .byte.b	0	;B
    701  4568		       f0		      .byte.b	240	;R (55)
    702  4569		       40		      .byte.b	64	;G
    703  456a		       00		      .byte.b	0	;B
    704  456b		       70		      .byte.b	112	;R (54)
    705  456c		       00		      .byte.b	0	;G
    706  456d		       80		      .byte.b	128	;B
    707  456e		       d0		      .byte.b	208	;R (53)
    708  456f		       00		      .byte.b	0	;G
    709  4570		       20		      .byte.b	32	;B
    710  4571		       f0		      .byte.b	240	;R (52)
    711  4572		       80		      .byte.b	128	;G
    712  4573		       00		      .byte.b	0	;B
    713  4574		       f0		      .byte.b	240	;R (51)
    714  4575		       00		      .byte.b	0	;G
    715  4576		       00		      .byte.b	0	;B
    716  4577		       f0		      .byte.b	240	;R (50)
    717  4578		       a0		      .byte.b	160	;G
    718  4579		       00		      .byte.b	0	;B
    719  457a		       f0		      .byte.b	240	;R (49)
    720  457b		       80		      .byte.b	128	;G
    721  457c		       00		      .byte.b	0	;B
    722  457d		       f0		      .byte.b	240	;R (48)
    723  457e		       40		      .byte.b	64	;G
    724  457f		       00		      .byte.b	0	;B
    725  4580		       f0		      .byte.b	240	;R (47)
    726  4581		       20		      .byte.b	32	;G
    727  4582		       00		      .byte.b	0	;B
    728  4583		       f0		      .byte.b	240	;R (46)
    729  4584		       00		      .byte.b	0	;G
    730  4585		       00		      .byte.b	0	;B
    731  4586		       f0		      .byte.b	240	;R (45)
    732  4587		       80		      .byte.b	128	;G
    733  4588		       00		      .byte.b	0	;B
    734  4589		       f0		      .byte.b	240	;R (44)
    735  458a		       00		      .byte.b	0	;G
    736  458b		       00		      .byte.b	0	;B
    737  458c		       f0		      .byte.b	240	;R (43)
    738  458d		       40		      .byte.b	64	;G
    739  458e		       00		      .byte.b	0	;B
    740  458f		       f0		      .byte.b	240	;R (42)
    741  4590		       00		      .byte.b	0	;G
    742  4591		       00		      .byte.b	0	;B
    743  4592		       f0		      .byte.b	240	;R (41)
    744  4593		       20		      .byte.b	32	;G
    745  4594		       00		      .byte.b	0	;B
    746  4595		       f0		      .byte.b	240	;R (40)
    747  4596		       20		      .byte.b	32	;G
    748  4597		       00		      .byte.b	0	;B
    749  4598		       f0		      .byte.b	240	;R (39)
    750  4599		       50		      .byte.b	80	;G
    751  459a		       00		      .byte.b	0	;B
    752  459b		       f0		      .byte.b	240	;R (38)
    753  459c		       10		      .byte.b	16	;G
    754  459d		       00		      .byte.b	0	;B
    755  459e		       70		      .byte.b	112	;R (37)
    756  459f		       80		      .byte.b	128	;G
    757  45a0		       80		      .byte.b	128	;B
    758  45a1		       f0		      .byte.b	240	;R (36)
    759  45a2		       50		      .byte.b	80	;G
    760  45a3		       00		      .byte.b	0	;B
    761  45a4		       f0		      .byte.b	240	;R (35)
    762  45a5		       00		      .byte.b	0	;G
    763  45a6		       00		      .byte.b	0	;B
    764  45a7		       f0		      .byte.b	240	;R (34)
    765  45a8		       40		      .byte.b	64	;G
    766  45a9		       00		      .byte.b	0	;B
    767  45aa		       f0		      .byte.b	240	;R (33)
    768  45ab		       10		      .byte.b	16	;G
    769  45ac		       00		      .byte.b	0	;B
    770  45ad		       f0		      .byte.b	240	;R (32)
    771  45ae		       b0		      .byte.b	176	;G
    772  45af		       00		      .byte.b	0	;B
    773  45b0		       e0		      .byte.b	224	;R (31)
    774  45b1		       00		      .byte.b	0	;G
    775  45b2		       10		      .byte.b	16	;B
    776  45b3		       e0		      .byte.b	224	;R (30)
    777  45b4		       40		      .byte.b	64	;G
    778  45b5		       00		      .byte.b	0	;B
    779  45b6		       e0		      .byte.b	224	;R (29)
    780  45b7		       20		      .byte.b	32	;G
    781  45b8		       00		      .byte.b	0	;B
    782  45b9		       c0		      .byte.b	192	;R (28)
    783  45ba		       00		      .byte.b	0	;G
    784  45bb		       00		      .byte.b	0	;B
    785  45bc		       c0		      .byte.b	192	;R (27)
    786  45bd		       10		      .byte.b	16	;G
    787  45be		       00		      .byte.b	0	;B
    788  45bf		       c0		      .byte.b	192	;R (26)
    789  45c0		       40		      .byte.b	64	;G
    790  45c1		       10		      .byte.b	16	;B
    791  45c2		       90		      .byte.b	144	;R (25)
    792  45c3		       00		      .byte.b	0	;G
    793  45c4		       00		      .byte.b	0	;B
    794  45c5		       f0		      .byte.b	240	;R (24)
    795  45c6		       60		      .byte.b	96	;G
    796  45c7		       00		      .byte.b	0	;B
    797  45c8		       f0		      .byte.b	240	;R (23)
    798  45c9		       00		      .byte.b	0	;G
    799  45ca		       00		      .byte.b	0	;B
    800  45cb		       f0		      .byte.b	240	;R (22)
    801  45cc		       40		      .byte.b	64	;G
    802  45cd		       00		      .byte.b	0	;B
    803  45ce		       f0		      .byte.b	240	;R (21)
    804  45cf		       10		      .byte.b	16	;G
    805  45d0		       00		      .byte.b	0	;B
    806  45d1		       f0		      .byte.b	240	;R (20)
    807  45d2		       00		      .byte.b	0	;G
    808  45d3		       00		      .byte.b	0	;B
    809  45d4		       f0		      .byte.b	240	;R (19)
    810  45d5		       60		      .byte.b	96	;G
    811  45d6		       00		      .byte.b	0	;B
    812  45d7		       f0		      .byte.b	240	;R (18)
    813  45d8		       20		      .byte.b	32	;G
    814  45d9		       00		      .byte.b	0	;B
    815  45da		       f0		      .byte.b	240	;R (17)
    816  45db		       50		      .byte.b	80	;G
    817  45dc		       00		      .byte.b	0	;B
    818  45dd		       f0		      .byte.b	240	;R (16)
    819  45de		       40		      .byte.b	64	;G
    820  45df		       00		      .byte.b	0	;B
    821  45e0		       f0		      .byte.b	240	;R (15)
    822  45e1		       80		      .byte.b	128	;G
    823  45e2		       00		      .byte.b	0	;B
    824  45e3		       f0		      .byte.b	240	;R (14)
    825  45e4		       40		      .byte.b	64	;G
    826  45e5		       00		      .byte.b	0	;B
    827  45e6		       f0		      .byte.b	240	;R (13)
    828  45e7		       00		      .byte.b	0	;G
    829  45e8		       00		      .byte.b	0	;B
    830  45e9		       f0		      .byte.b	240	;R (12)
    831  45ea		       10		      .byte.b	16	;G
    832  45eb		       00		      .byte.b	0	;B
    833  45ec		       f0		      .byte.b	240	;R (11)
    834  45ed		       50		      .byte.b	80	;G
    835  45ee		       00		      .byte.b	0	;B
    836  45ef		       f0		      .byte.b	240	;R (10)
    837  45f0		       00		      .byte.b	0	;G
    838  45f1		       00		      .byte.b	0	;B
    839  45f2		       f0		      .byte.b	240	;R (9)
    840  45f3		       b0		      .byte.b	176	;G
    841  45f4		       00		      .byte.b	0	;B
    842  45f5		       f0		      .byte.b	240	;R (8)
    843  45f6		       90		      .byte.b	144	;G
    844  45f7		       00		      .byte.b	0	;B
    845  45f8		       e0		      .byte.b	224	;R (7)
    846  45f9		       e0		      .byte.b	224	;G
    847  45fa		       00		      .byte.b	0	;B
    848  45fb		       f0		      .byte.b	240	;R (6)
    849  45fc		       d0		      .byte.b	208	;G
    850  45fd		       00		      .byte.b	0	;B
    851  45fe		       60		      .byte.b	96	;R (5)
    852  45ff		       00		      .byte.b	0	;G
    853  4600		       00		      .byte.b	0	;B
    854  4601		       60		      .byte.b	96	;R (4)
    855  4602		       40		      .byte.b	64	;G
    856  4603		       00		      .byte.b	0	;B
    857  4604		       40		      .byte.b	64	;R (3)
    858  4605		       50		      .byte.b	80	;G
    859  4606		       00		      .byte.b	0	;B
    860  4607		       00		      .byte.b	0	;R (2)
    861  4608		       00		      .byte.b	0	;G
    862  4609		       00		      .byte.b	0	;B
    863  460a		       00		      .byte.b	0	;R (1)
    864  460b		       80		      .byte.b	128	;G
    865  460c		       00		      .byte.b	0	;B
    866  460d		       00		      .byte.b	0	;R (0)
    867  460e		       00		      .byte.b	0	;G
    868  460f		       00		      .byte.b	0	;B
    869  4610				   COL_4
    870  4610		       25		      .byte.b	37	;R (71)
    871  4611		       25		      .byte.b	37	;G
    872  4612		       00		      .byte.b	0	;B
    873  4613		       48		      .byte.b	72	;R (70)
    874  4614		       48		      .byte.b	72	;G
    875  4615		       00		      .byte.b	0	;B
    876  4616		       25		      .byte.b	37	;R (69)
    877  4617		       25		      .byte.b	37	;G
    878  4618		       88		      .byte.b	136	;B
    879  4619		       ff		      .byte.b	255	;R (68)
    880  461a		       00		      .byte.b	0	;G
    881  461b		       00		      .byte.b	0	;B
    882  461c		       ff		      .byte.b	255	;R (67)
    883  461d		       04		      .byte.b	4	;G
    884  461e		       00		      .byte.b	0	;B
    885  461f		       ef		      .byte.b	239	;R (66)
    886  4620		       40		      .byte.b	64	;G
    887  4621		       10		      .byte.b	16	;B
    888  4622		       ff		      .byte.b	255	;R (65)
    889  4623		       00		      .byte.b	0	;G
    890  4624		       00		      .byte.b	0	;B
    891  4625		       ff		      .byte.b	255	;R (64)
    892  4626		       02		      .byte.b	2	;G
    893  4627		       00		      .byte.b	0	;B
    894  4628		       ff		      .byte.b	255	;R (63)
    895  4629		       20		      .byte.b	32	;G
    896  462a		       00		      .byte.b	0	;B
    897  462b		       ff		      .byte.b	255	;R (62)
    898  462c		       a5		      .byte.b	165	;G
    899  462d		       00		      .byte.b	0	;B
    900  462e		       ff		      .byte.b	255	;R (61)
    901  462f		       09		      .byte.b	9	;G
    902  4630		       00		      .byte.b	0	;B
    903  4631		       ff		      .byte.b	255	;R (60)
    904  4632		       00		      .byte.b	0	;G
    905  4633		       00		      .byte.b	0	;B
    906  4634		       7f		      .byte.b	127	;R (59)
    907  4635		       42		      .byte.b	66	;G
    908  4636		       80		      .byte.b	128	;B
    909  4637		       ff		      .byte.b	255	;R (58)
    910  4638		       88		      .byte.b	136	;G
    911  4639		       00		      .byte.b	0	;B
    912  463a		       ff		      .byte.b	255	;R (57)
    913  463b		       40		      .byte.b	64	;G
    914  463c		       00		      .byte.b	0	;B
    915  463d		       ff		      .byte.b	255	;R (56)
    916  463e		       09		      .byte.b	9	;G
    917  463f		       00		      .byte.b	0	;B
    918  4640		       7f		      .byte.b	127	;R (55)
    919  4641		       01		      .byte.b	1	;G
    920  4642		       80		      .byte.b	128	;B
    921  4643		       ff		      .byte.b	255	;R (54)
    922  4644		       91		      .byte.b	145	;G
    923  4645		       00		      .byte.b	0	;B
    924  4646		       fe		      .byte.b	254	;R (53)
    925  4647		       81		      .byte.b	129	;G
    926  4648		       00		      .byte.b	0	;B
    927  4649		       fe		      .byte.b	254	;R (52)
    928  464a		       20		      .byte.b	32	;G
    929  464b		       00		      .byte.b	0	;B
    930  464c		       ff		      .byte.b	255	;R (51)
    931  464d		       03		      .byte.b	3	;G
    932  464e		       00		      .byte.b	0	;B
    933  464f		       ff		      .byte.b	255	;R (50)
    934  4650		       83		      .byte.b	131	;G
    935  4651		       00		      .byte.b	0	;B
    936  4652		       fe		      .byte.b	254	;R (49)
    937  4653		       90		      .byte.b	144	;G
    938  4654		       00		      .byte.b	0	;B
    939  4655		       fe		      .byte.b	254	;R (48)
    940  4656		       83		      .byte.b	131	;G
    941  4657		       00		      .byte.b	0	;B
    942  4658		       7e		      .byte.b	126	;R (47)
    943  4659		       12		      .byte.b	18	;G
    944  465a		       80		      .byte.b	128	;B
    945  465b		       fc		      .byte.b	252	;R (46)
    946  465c		       00		      .byte.b	0	;G
    947  465d		       00		      .byte.b	0	;B
    948  465e		       fe		      .byte.b	254	;R (45)
    949  465f		       07		      .byte.b	7	;G
    950  4660		       00		      .byte.b	0	;B
    951  4661		       ef		      .byte.b	239	;R (44)
    952  4662		       03		      .byte.b	3	;G
    953  4663		       10		      .byte.b	16	;B
    954  4664		       ff		      .byte.b	255	;R (43)
    955  4665		       40		      .byte.b	64	;G
    956  4666		       00		      .byte.b	0	;B
    957  4667		       ff		      .byte.b	255	;R (42)
    958  4668		       01		      .byte.b	1	;G
    959  4669		       00		      .byte.b	0	;B
    960  466a		       ff		      .byte.b	255	;R (41)
    961  466b		       01		      .byte.b	1	;G
    962  466c		       00		      .byte.b	0	;B
    963  466d		       bf		      .byte.b	191	;R (40)
    964  466e		       01		      .byte.b	1	;G
    965  466f		       40		      .byte.b	64	;B
    966  4670		       f7		      .byte.b	247	;R (39)
    967  4671		       80		      .byte.b	128	;G
    968  4672		       08		      .byte.b	8	;B
    969  4673		       ff		      .byte.b	255	;R (38)
    970  4674		       40		      .byte.b	64	;G
    971  4675		       00		      .byte.b	0	;B
    972  4676		       ff		      .byte.b	255	;R (37)
    973  4677		       00		      .byte.b	0	;G
    974  4678		       00		      .byte.b	0	;B
    975  4679		       ff		      .byte.b	255	;R (36)
    976  467a		       40		      .byte.b	64	;G
    977  467b		       00		      .byte.b	0	;B
    978  467c		       ff		      .byte.b	255	;R (35)
    979  467d		       a1		      .byte.b	161	;G
    980  467e		       00		      .byte.b	0	;B
    981  467f		       7f		      .byte.b	127	;R (34)
    982  4680		       05		      .byte.b	5	;G
    983  4681		       80		      .byte.b	128	;B
    984  4682		       ff		      .byte.b	255	;R (33)
    985  4683		       21		      .byte.b	33	;G
    986  4684		       00		      .byte.b	0	;B
    987  4685		       bf		      .byte.b	191	;R (32)
    988  4686		       40		      .byte.b	64	;G
    989  4687		       40		      .byte.b	64	;B
    990  4688		       ff		      .byte.b	255	;R (31)
    991  4689		       61		      .byte.b	97	;G
    992  468a		       00		      .byte.b	0	;B
    993  468b		       7f		      .byte.b	127	;R (30)
    994  468c		       81		      .byte.b	129	;G
    995  468d		       80		      .byte.b	128	;B
    996  468e		       f7		      .byte.b	247	;R (29)
    997  468f		       60		      .byte.b	96	;G
    998  4690		       08		      .byte.b	8	;B
    999  4691		       ff		      .byte.b	255	;R (28)
   1000  4692		       81		      .byte.b	129	;G
   1001  4693		       00		      .byte.b	0	;B
   1002  4694		       ef		      .byte.b	239	;R (27)
   1003  4695		       40		      .byte.b	64	;G
   1004  4696		       10		      .byte.b	16	;B
   1005  4697		       ff		      .byte.b	255	;R (26)
   1006  4698		       60		      .byte.b	96	;G
   1007  4699		       00		      .byte.b	0	;B
   1008  469a		       ff		      .byte.b	255	;R (25)
   1009  469b		       18		      .byte.b	24	;G
   1010  469c		       00		      .byte.b	0	;B
   1011  469d		       ff		      .byte.b	255	;R (24)
   1012  469e		       20		      .byte.b	32	;G
   1013  469f		       00		      .byte.b	0	;B
   1014  46a0		       ff		      .byte.b	255	;R (23)
   1015  46a1		       8a		      .byte.b	138	;G
   1016  46a2		       00		      .byte.b	0	;B
   1017  46a3		       f7		      .byte.b	247	;R (22)
   1018  46a4		       10		      .byte.b	16	;G
   1019  46a5		       08		      .byte.b	8	;B
   1020  46a6		       ff		      .byte.b	255	;R (21)
   1021  46a7		       04		      .byte.b	4	;G
   1022  46a8		       00		      .byte.b	0	;B
   1023  46a9		       df		      .byte.b	223	;R (20)
   1024  46aa		       10		      .byte.b	16	;G
   1025  46ab		       20		      .byte.b	32	;B
   1026  46ac		       ff		      .byte.b	255	;R (19)
   1027  46ad		       90		      .byte.b	144	;G
   1028  46ae		       00		      .byte.b	0	;B
   1029  46af		       ff		      .byte.b	255	;R (18)
   1030  46b0		       12		      .byte.b	18	;G
   1031  46b1		       00		      .byte.b	0	;B
   1032  46b2		       ff		      .byte.b	255	;R (17)
   1033  46b3		       00		      .byte.b	0	;G
   1034  46b4		       00		      .byte.b	0	;B
   1035  46b5		       ff		      .byte.b	255	;R (16)
   1036  46b6		       45		      .byte.b	69	;G
   1037  46b7		       00		      .byte.b	0	;B
   1038  46b8		       ff		      .byte.b	255	;R (15)
   1039  46b9		       10		      .byte.b	16	;G
   1040  46ba		       00		      .byte.b	0	;B
   1041  46bb		       ff		      .byte.b	255	;R (14)
   1042  46bc		       23		      .byte.b	35	;G
   1043  46bd		       00		      .byte.b	0	;B
   1044  46be		       fc		      .byte.b	252	;R (13)
   1045  46bf		       12		      .byte.b	18	;G
   1046  46c0		       00		      .byte.b	0	;B
   1047  46c1		       fc		      .byte.b	252	;R (12)
   1048  46c2		       20		      .byte.b	32	;G
   1049  46c3		       00		      .byte.b	0	;B
   1050  46c4		       fe		      .byte.b	254	;R (11)
   1051  46c5		       46		      .byte.b	70	;G
   1052  46c6		       00		      .byte.b	0	;B
   1053  46c7		       f8		      .byte.b	248	;R (10)
   1054  46c8		       48		      .byte.b	72	;G
   1055  46c9		       00		      .byte.b	0	;B
   1056  46ca		       f0		      .byte.b	240	;R (9)
   1057  46cb		       04		      .byte.b	4	;G
   1058  46cc		       00		      .byte.b	0	;B
   1059  46cd		       e0		      .byte.b	224	;R (8)
   1060  46ce		       20		      .byte.b	32	;G
   1061  46cf		       00		      .byte.b	0	;B
   1062  46d0		       e0		      .byte.b	224	;R (7)
   1063  46d1		       29		      .byte.b	41	;G
   1064  46d2		       00		      .byte.b	0	;B
   1065  46d3		       e0		      .byte.b	224	;R (6)
   1066  46d4		       20		      .byte.b	32	;G
   1067  46d5		       00		      .byte.b	0	;B
   1068  46d6		       e0		      .byte.b	224	;R (5)
   1069  46d7		       84		      .byte.b	132	;G
   1070  46d8		       00		      .byte.b	0	;B
   1071  46d9		       60		      .byte.b	96	;R (4)
   1072  46da		       40		      .byte.b	64	;G
   1073  46db		       00		      .byte.b	0	;B
   1074  46dc		       00		      .byte.b	0	;R (3)
   1075  46dd		       88		      .byte.b	136	;G
   1076  46de		       00		      .byte.b	0	;B
   1077  46df		       00		      .byte.b	0	;R (2)
   1078  46e0		       11		      .byte.b	17	;G
   1079  46e1		       00		      .byte.b	0	;B
   1080  46e2		       24		      .byte.b	36	;R (1)
   1081  46e3		       24		      .byte.b	36	;G
   1082  46e4		       00		      .byte.b	0	;B
   1083  46e5		       00		      .byte.b	0	;R (0)
   1084  46e6		       00		      .byte.b	0	;G
   1085  46e7		       00		      .byte.b	0	;B
   1086  46e8				   COL_5
   1087  46e8		       02		      .byte.b	2	;R (71)
   1088  46e9		       12		      .byte.b	18	;G
   1089  46ea		       00		      .byte.b	0	;B
   1090  46eb		       00		      .byte.b	0	;R (70)
   1091  46ec		       00		      .byte.b	0	;G
   1092  46ed		       00		      .byte.b	0	;B
   1093  46ee		       00		      .byte.b	0	;R (69)
   1094  46ef		       02		      .byte.b	2	;G
   1095  46f0		       00		      .byte.b	0	;B
   1096  46f1		       03		      .byte.b	3	;R (68)
   1097  46f2		       12		      .byte.b	18	;G
   1098  46f3		       00		      .byte.b	0	;B
   1099  46f4		       0b		      .byte.b	11	;R (67)
   1100  46f5		       09		      .byte.b	9	;G
   1101  46f6		       00		      .byte.b	0	;B
   1102  46f7		       07		      .byte.b	7	;R (66)
   1103  46f8		       05		      .byte.b	5	;G
   1104  46f9		       00		      .byte.b	0	;B
   1105  46fa		       03		      .byte.b	3	;R (65)
   1106  46fb		       06		      .byte.b	6	;G
   1107  46fc		       00		      .byte.b	0	;B
   1108  46fd		       01		      .byte.b	1	;R (64)
   1109  46fe		       20		      .byte.b	32	;G
   1110  46ff		       00		      .byte.b	0	;B
   1111  4700		       03		      .byte.b	3	;R (63)
   1112  4701		       03		      .byte.b	3	;G
   1113  4702		       00		      .byte.b	0	;B
   1114  4703		       03		      .byte.b	3	;R (62)
   1115  4704		       0a		      .byte.b	10	;G
   1116  4705		       00		      .byte.b	0	;B
   1117  4706		       03		      .byte.b	3	;R (61)
   1118  4707		       02		      .byte.b	2	;G
   1119  4708		       00		      .byte.b	0	;B
   1120  4709		       03		      .byte.b	3	;R (60)
   1121  470a		       00		      .byte.b	0	;G
   1122  470b		       00		      .byte.b	0	;B
   1123  470c		       03		      .byte.b	3	;R (59)
   1124  470d		       0a		      .byte.b	10	;G
   1125  470e		       00		      .byte.b	0	;B
   1126  470f		       03		      .byte.b	3	;R (58)
   1127  4710		       02		      .byte.b	2	;G
   1128  4711		       00		      .byte.b	0	;B
   1129  4712		       01		      .byte.b	1	;R (57)
   1130  4713		       03		      .byte.b	3	;G
   1131  4714		       00		      .byte.b	0	;B
   1132  4715		       01		      .byte.b	1	;R (56)
   1133  4716		       01		      .byte.b	1	;G
   1134  4717		       00		      .byte.b	0	;B
   1135  4718		       00		      .byte.b	0	;R (55)
   1136  4719		       25		      .byte.b	37	;G
   1137  471a		       00		      .byte.b	0	;B
   1138  471b		       00		      .byte.b	0	;R (54)
   1139  471c		       00		      .byte.b	0	;G
   1140  471d		       00		      .byte.b	0	;B
   1141  471e		       00		      .byte.b	0	;R (53)
   1142  471f		       20		      .byte.b	32	;G
   1143  4720		       00		      .byte.b	0	;B
   1144  4721		       00		      .byte.b	0	;R (52)
   1145  4722		       08		      .byte.b	8	;G
   1146  4723		       00		      .byte.b	0	;B
   1147  4724		       00		      .byte.b	0	;R (51)
   1148  4725		       02		      .byte.b	2	;G
   1149  4726		       00		      .byte.b	0	;B
   1150  4727		       00		      .byte.b	0	;R (50)
   1151  4728		       40		      .byte.b	64	;G
   1152  4729		       00		      .byte.b	0	;B
   1153  472a		       00		      .byte.b	0	;R (49)
   1154  472b		       11		      .byte.b	17	;G
   1155  472c		       00		      .byte.b	0	;B
   1156  472d		       00		      .byte.b	0	;R (48)
   1157  472e		       00		      .byte.b	0	;G
   1158  472f		       00		      .byte.b	0	;B
   1159  4730		       00		      .byte.b	0	;R (47)
   1160  4731		       20		      .byte.b	32	;G
   1161  4732		       00		      .byte.b	0	;B
   1162  4733		       00		      .byte.b	0	;R (46)
   1163  4734		       08		      .byte.b	8	;G
   1164  4735		       00		      .byte.b	0	;B
   1165  4736		       00		      .byte.b	0	;R (45)
   1166  4737		       00		      .byte.b	0	;G
   1167  4738		       00		      .byte.b	0	;B
   1168  4739		       00		      .byte.b	0	;R (44)
   1169  473a		       24		      .byte.b	36	;G
   1170  473b		       00		      .byte.b	0	;B
   1171  473c		       00		      .byte.b	0	;R (43)
   1172  473d		       00		      .byte.b	0	;G
   1173  473e		       00		      .byte.b	0	;B
   1174  473f		       00		      .byte.b	0	;R (42)
   1175  4740		       04		      .byte.b	4	;G
   1176  4741		       00		      .byte.b	0	;B
   1177  4742		       00		      .byte.b	0	;R (41)
   1178  4743		       21		      .byte.b	33	;G
   1179  4744		       00		      .byte.b	0	;B
   1180  4745		       01		      .byte.b	1	;R (40)
   1181  4746		       01		      .byte.b	1	;G
   1182  4747		       00		      .byte.b	0	;B
   1183  4748		       01		      .byte.b	1	;R (39)
   1184  4749		       25		      .byte.b	37	;G
   1185  474a		       00		      .byte.b	0	;B
   1186  474b		       01		      .byte.b	1	;R (38)
   1187  474c		       01		      .byte.b	1	;G
   1188  474d		       00		      .byte.b	0	;B
   1189  474e		       03		      .byte.b	3	;R (37)
   1190  474f		       23		      .byte.b	35	;G
   1191  4750		       00		      .byte.b	0	;B
   1192  4751		       03		      .byte.b	3	;R (36)
   1193  4752		       13		      .byte.b	19	;G
   1194  4753		       00		      .byte.b	0	;B
   1195  4754		       01		      .byte.b	1	;R (35)
   1196  4755		       02		      .byte.b	2	;G
   1197  4756		       00		      .byte.b	0	;B
   1198  4757		       01		      .byte.b	1	;R (34)
   1199  4758		       10		      .byte.b	16	;G
   1200  4759		       00		      .byte.b	0	;B
   1201  475a		       03		      .byte.b	3	;R (33)
   1202  475b		       02		      .byte.b	2	;G
   1203  475c		       00		      .byte.b	0	;B
   1204  475d		       01		      .byte.b	1	;R (32)
   1205  475e		       08		      .byte.b	8	;G
   1206  475f		       00		      .byte.b	0	;B
   1207  4760		       03		      .byte.b	3	;R (31)
   1208  4761		       20		      .byte.b	32	;G
   1209  4762		       00		      .byte.b	0	;B
   1210  4763		       03		      .byte.b	3	;R (30)
   1211  4764		       00		      .byte.b	0	;G
   1212  4765		       00		      .byte.b	0	;B
   1213  4766		       03		      .byte.b	3	;R (29)
   1214  4767		       10		      .byte.b	16	;G
   1215  4768		       00		      .byte.b	0	;B
   1216  4769		       03		      .byte.b	3	;R (28)
   1217  476a		       00		      .byte.b	0	;G
   1218  476b		       00		      .byte.b	0	;B
   1219  476c		       07		      .byte.b	7	;R (27)
   1220  476d		       0e		      .byte.b	14	;G
   1221  476e		       00		      .byte.b	0	;B
   1222  476f		       03		      .byte.b	3	;R (26)
   1223  4770		       41		      .byte.b	65	;G
   1224  4771		       00		      .byte.b	0	;B
   1225  4772		       07		      .byte.b	7	;R (25)
   1226  4773		       04		      .byte.b	4	;G
   1227  4774		       00		      .byte.b	0	;B
   1228  4775		       03		      .byte.b	3	;R (24)
   1229  4776		       21		      .byte.b	33	;G
   1230  4777		       00		      .byte.b	0	;B
   1231  4778		       03		      .byte.b	3	;R (23)
   1232  4779		       04		      .byte.b	4	;G
   1233  477a		       00		      .byte.b	0	;B
   1234  477b		       03		      .byte.b	3	;R (22)
   1235  477c		       02		      .byte.b	2	;G
   1236  477d		       00		      .byte.b	0	;B
   1237  477e		       03		      .byte.b	3	;R (21)
   1238  477f		       26		      .byte.b	38	;G
   1239  4780		       00		      .byte.b	0	;B
   1240  4781		       01		      .byte.b	1	;R (20)
   1241  4782		       01		      .byte.b	1	;G
   1242  4783		       00		      .byte.b	0	;B
   1243  4784		       00		      .byte.b	0	;R (19)
   1244  4785		       21		      .byte.b	33	;G
   1245  4786		       00		      .byte.b	0	;B
   1246  4787		       01		      .byte.b	1	;R (18)
   1247  4788		       09		      .byte.b	9	;G
   1248  4789		       00		      .byte.b	0	;B
   1249  478a		       23		      .byte.b	35	;R (17)
   1250  478b		       22		      .byte.b	34	;G
   1251  478c		       00		      .byte.b	0	;B
   1252  478d		       01		      .byte.b	1	;R (16)
   1253  478e		       01		      .byte.b	1	;G
   1254  478f		       00		      .byte.b	0	;B
   1255  4790		       00		      .byte.b	0	;R (15)
   1256  4791		       29		      .byte.b	41	;G
   1257  4792		       00		      .byte.b	0	;B
   1258  4793		       00		      .byte.b	0	;R (14)
   1259  4794		       00		      .byte.b	0	;G
   1260  4795		       00		      .byte.b	0	;B
   1261  4796		       00		      .byte.b	0	;R (13)
   1262  4797		       04		      .byte.b	4	;G
   1263  4798		       00		      .byte.b	0	;B
   1264  4799		       00		      .byte.b	0	;R (12)
   1265  479a		       20		      .byte.b	32	;G
   1266  479b		       00		      .byte.b	0	;B
   1267  479c		       10		      .byte.b	16	;R (11)
   1268  479d		       12		      .byte.b	18	;G
   1269  479e		       00		      .byte.b	0	;B
   1270  479f		       00		      .byte.b	0	;R (10)
   1271  47a0		       00		      .byte.b	0	;G
   1272  47a1		       00		      .byte.b	0	;B
   1273  47a2		       00		      .byte.b	0	;R (9)
   1274  47a3		       21		      .byte.b	33	;G
   1275  47a4		       00		      .byte.b	0	;B
   1276  47a5		       00		      .byte.b	0	;R (8)
   1277  47a6		       08		      .byte.b	8	;G
   1278  47a7		       00		      .byte.b	0	;B
   1279  47a8		       00		      .byte.b	0	;R (7)
   1280  47a9		       20		      .byte.b	32	;G
   1281  47aa		       00		      .byte.b	0	;B
   1282  47ab		       00		      .byte.b	0	;R (6)
   1283  47ac		       04		      .byte.b	4	;G
   1284  47ad		       00		      .byte.b	0	;B
   1285  47ae		       20		      .byte.b	32	;R (5)
   1286  47af		       20		      .byte.b	32	;G
   1287  47b0		       00		      .byte.b	0	;B
   1288  47b1		       00		      .byte.b	0	;R (4)
   1289  47b2		       09		      .byte.b	9	;G
   1290  47b3		       00		      .byte.b	0	;B
   1291  47b4		       00		      .byte.b	0	;R (3)
   1292  47b5		       00		      .byte.b	0	;G
   1293  47b6		       00		      .byte.b	0	;B
   1294  47b7		       00		      .byte.b	0	;R (2)
   1295  47b8		       48		      .byte.b	72	;G
   1296  47b9		       00		      .byte.b	0	;B
   1297  47ba		       02		      .byte.b	2	;R (1)
   1298  47bb		       02		      .byte.b	2	;G
   1299  47bc		       00		      .byte.b	0	;B
   1300  47bd		       00		      .byte.b	0	;R (0)
   1301  47be		       00		      .byte.b	0	;G
   1302  47bf		       00		      .byte.b	0	;B
------- FILE titleScreen.asm
    265  47c0							;    include "pizza.asm"
    266  47c0
      0  47c0					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  47c0		       07 c0	   .TEMP      =	* - BANK_START
 TITLESCREEN (2K) SIZE =  $7c0 , FREE= $40
      2  47c0					      ECHO	"TITLESCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  47c0				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  47c0				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  47c0				  -	      ERR
      6  47c0					      endif
------- FILE ./chess.asm
------- FILE BANK_RECON.asm LEVEL 2 PASS 5
      0  47c0					      include	"BANK_RECON.asm"
      0  47c0					      NEWBANK	RECON
      1  4f48 ????				      SEG	RECON
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   RECON      SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	RECON
      2  4800
      3  4800							;---------------------------------------------------------------------------------------------------
      4  4800
      0  4800					      DEF	UNSAFE_showP_MoveCaptures
      1  4800				   BANK_UNSAFE_showP_MoveCaptures SET	_CURRENT_BANK
      2  4800				   UNSAFE_showP_MoveCaptures
      3  4800				   TEMPORARY_VAR SET	Overlay
      4  4800				   TEMPORARY_OFFSET SET	0
      5  4800				   VAR_BOUNDARY_UNSAFE_showP_MoveCaptures SET	TEMPORARY_OFFSET
      6  4800				   FUNCTION_NAME SET	UNSAFE_showP_MoveCaptures
      7  4800					      SUBROUTINE
      6  4800					      SUBROUTINE
      7  4800
      0  4800					      REFER	SAFE_showP_MoveCaptures
      1  4800				  -	      IF	VAREND_SAFE_showP_MoveCaptures > TEMPORARY_VAR
      2  4800				  -TEMPORARY_VAR SET	VAREND_SAFE_showP_MoveCaptures
      3  4800					      ENDIF
      0  4800					      VAR	__toSquareX12, 1
      1  4800		       00 a2	   __toSquareX12 =	TEMPORARY_VAR
      2  4800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4800
      4  4800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4800					      ENDIF
      8  4800				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4800				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  4800				  -	      ERR
     11  4800					      ENDIF
     12  4800					      LIST	ON
      0  4800					      VAR	__fromPiece, 1
      1  4800		       00 a3	   __fromPiece =	TEMPORARY_VAR
      2  4800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4800
      4  4800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4800					      ENDIF
      8  4800				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4800				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  4800				  -	      ERR
     11  4800					      ENDIF
     12  4800					      LIST	ON
      0  4800					      VAR	__aiMoveIndex, 1
      1  4800		       00 a4	   __aiMoveIndex =	TEMPORARY_VAR
      2  4800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4800
      4  4800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4800					      ENDIF
      8  4800				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4800				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  4800				  -	      ERR
     11  4800					      ENDIF
     12  4800					      LIST	ON
      0  4800					      VEND	UNSAFE_showP_MoveCaptures
      1  4800				  -	      IFNCONST	UNSAFE_showP_MoveCaptures
      2  4800				  -	      ECHO	"Incorrect VEND label", UNSAFE_showP_MoveCaptures
      3  4800				  -	      ERR
      4  4800					      ENDIF
      5  4800		       00 a5	   VAREND_UNSAFE_showP_MoveCaptures =	TEMPORARY_VAR
     13  4800
     14  4800							; place a marker on the board for any square matching the piece
     15  4800							; EXCEPT for squares which are occupied (we'll flash those later)
     16  4800							; x = movelist item # being checked
     17  4800
     18  4800		       a5 8b		      lda	savedBank
     19  4802		       48		      pha
     20  4803
     21  4803		       a9 09		      lda	#BANK_UNSAFE_showP_MoveCaptures
     22  4805		       85 8b		      sta	savedBank
     23  4807
     24  4807
     25  4807		       a6 8e	   .next      ldx	aiMoveIndex
     26  4809		       86 a4		      stx	__aiMoveIndex
     27  480b		       30 41		      bmi	.skip	; no moves in list
     28  480d
     29  480d		       ad 84 02 	      lda	INTIM
     30  4810		       c9 14		      cmp	#20
     31  4812		       90 3a		      bcc	.skip
     32  4814
     33  4814		       c6 8e		      dec	aiMoveIndex
     34  4816
     35  4816		       20 cf fd 	      jsr	GetP_MoveFrom
     36  4819		       c5 85		      cmp	fromX12
     37  481b		       d0 ea		      bne	.next
     38  481d
     39  481d
     40  481d		       20 db fd 	      jsr	GetP_MoveTo
     41  4820		       85 a2		      sta	__toSquareX12
     42  4822		       a8		      tay
     43  4823		       20 e7 fc 	      jsr	GetBoard
     44  4826		       29 0f		      and	#PIECE_MASK
     45  4828		       f0 dd		      beq	.next
     46  482a
     47  482a							; There's something on the board at destination, so it's a capture
     48  482a							; Let's see if we are doing a pawn promote...
     49  482a
     50  482a		       a4 85		      ldy	fromX12
     51  482c		       20 e7 fc 	      jsr	GetBoard
     52  482f		       85 a3		      sta	__fromPiece
     53  4831
     54  4831		       20 e7 fd 	      jsr	GetP_MovePiece
     55  4834		       45 a3		      eor	__fromPiece
     56  4836		       29 0f		      and	#PIECE_MASK
     57  4838		       f0 06		      beq	.legit	; from == to, so not a promote
     58  483a
     59  483a							; Have detected a promotion duplicate - skip all 3 of them
     60  483a
     61  483a		       c6 8e		      dec	aiMoveIndex	; skip "KBRQ" promotes
     62  483c		       c6 8e		      dec	aiMoveIndex
     63  483e		       c6 8e		      dec	aiMoveIndex
     64  4840
     65  4840				   .legit
     66  4840
      0  4840					      TIMECHECK	COPYSINGLEPIECE, restoreIndex	; not enough time to draw
      1  4840		       ad 84 02 	      lda	INTIM
      2  4843		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
      3  4845		       90 0b		      bcc	restoreIndex
     68  4847
     69  4847		       a5 a2		      lda	__toSquareX12
     70  4849		       85 80		      sta	squareToDraw
     71  484b
     72  484b		       20 57 fd 	      jsr	CopySinglePiece
     73  484e
     74  484e		       68	   .skip      pla
     75  484f		       85 8b		      sta	savedBank
     76  4851		       60		      rts
     77  4852
     78  4852		       a5 a4	   restoreIndex lda	__aiMoveIndex
     79  4854		       85 8e		      sta	aiMoveIndex
     80  4856		       4c 4e f0 	      jmp	.skip
     81  4859
     82  4859
     83  4859							;---------------------------------------------------------------------------------------------------
     84  4859
      0  4859					      DEF	aiMarchToTargetA
      1  4859				   BANK_aiMarchToTargetA SET	_CURRENT_BANK
      2  4859				   aiMarchToTargetA
      3  4859				   TEMPORARY_VAR SET	Overlay
      4  4859				   TEMPORARY_OFFSET SET	0
      5  4859				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      6  4859				   FUNCTION_NAME SET	aiMarchToTargetA
      7  4859					      SUBROUTINE
     86  4859					      SUBROUTINE
     87  4859
      0  4859					      REFER	AiStateMachine
      1  4859				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4859				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4859					      ENDIF
      0  4859					      VAR	__fromRow, 1
      1  4859		       00 a2	   __fromRow  =	TEMPORARY_VAR
      2  4859				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4859
      4  4859				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4859				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4859				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4859					      ENDIF
      8  4859				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4859				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  4859				  -	      ERR
     11  4859					      ENDIF
     12  4859					      LIST	ON
      0  4859					      VAR	__boardIndex, 1
      1  4859		       00 a3	   __boardIndex =	TEMPORARY_VAR
      2  4859				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4859
      4  4859				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4859				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4859				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4859					      ENDIF
      8  4859				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4859				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  4859				  -	      ERR
     11  4859					      ENDIF
     12  4859					      LIST	ON
      0  4859					      VAR	__fromCol, 1
      1  4859		       00 a4	   __fromCol  =	TEMPORARY_VAR
      2  4859				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4859
      4  4859				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4859				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4859				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4859					      ENDIF
      8  4859				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4859				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  4859				  -	      ERR
     11  4859					      ENDIF
     12  4859					      LIST	ON
      0  4859					      VAR	__toCol, 1
      1  4859		       00 a5	   __toCol    =	TEMPORARY_VAR
      2  4859				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4859
      4  4859				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4859				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4859				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4859					      ENDIF
      8  4859				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4859				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  4859				  -	      ERR
     11  4859					      ENDIF
     12  4859					      LIST	ON
      0  4859					      VEND	aiMarchToTargetA
      1  4859				  -	      IFNCONST	aiMarchToTargetA
      2  4859				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  4859				  -	      ERR
      4  4859					      ENDIF
      5  4859		       00 a6	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
     94  4859
     95  4859
     96  4859							; Now we calculate move to new square
     97  4859
     98  4859		       a5 85		      lda	fromX12
     99  485b		       c5 86		      cmp	toX12
    100  485d		       f0 6a		      beq	.unmovedx
    101  485f		       85 83		      sta	lastSquareX12
    102  4861
    103  4861		       38		      sec
    104  4862		       a2 fd		      ldx	#-3
    105  4864		       e9 0a	   .sub10     sbc	#10
    106  4866		       e8		      inx
    107  4867		       b0 fb		      bcs	.sub10
    108  4869		       69 08		      adc	#8
    109  486b		       85 a4		      sta	__fromCol
    110  486d		       86 a2		      stx	__fromRow
    111  486f
    112  486f		       a5 86		      lda	toX12
    113  4871		       38		      sec
    114  4872		       a2 fd		      ldx	#-3
    115  4874		       e9 0a	   .sub10b    sbc	#10
    116  4876		       e8		      inx
    117  4877		       b0 fb		      bcs	.sub10b
    118  4879		       69 08		      adc	#8
    119  487b		       85 a5		      sta	__toCol
    120  487d
    121  487d
    122  487d		       e4 a2		      cpx	__fromRow
    123  487f		       f0 13		      beq	.rowDone
    124  4881
    125  4881		       b0 0a		      bcs	.incRow
    126  4883
    127  4883		       38		      sec
    128  4884		       a5 85		      lda	fromX12
    129  4886		       e9 0a		      sbc	#10
    130  4888		       85 85		      sta	fromX12
    131  488a		       4c 94 f0 	      jmp	.rowDone
    132  488d
    133  488d		       18	   .incRow    clc
    134  488e		       a5 85		      lda	fromX12
    135  4890		       69 0a		      adc	#10
    136  4892		       85 85		      sta	fromX12
    137  4894
    138  4894				   .rowDone
    139  4894
    140  4894		       a5 a5		      lda	__toCol
    141  4896		       c5 a4		      cmp	__fromCol
    142  4898		       f0 09		      beq	.colDone
    143  489a
    144  489a		       b0 05		      bcs	.incCol
    145  489c
    146  489c		       c6 85		      dec	fromX12
    147  489e		       4c a3 f0 	      jmp	.colDone
    148  48a1
    149  48a1		       e6 85	   .incCol    inc	fromX12
    150  48a3				   .colDone
    151  48a3
    152  48a3
    153  48a3
    154  48a3
    155  48a3							; erase object in new sqare --> blank
    156  48a3
    157  48a3		       a4 85		      ldy	fromX12
    158  48a5		       84 80		      sty	squareToDraw
    159  48a7
    160  48a7		       20 e7 fc 	      jsr	GetBoard
    161  48aa		       c9 00		      cmp	#0
    162  48ac		       f0 03		      beq	.skipbl
    163  48ae		       20 57 fd 	      jsr	CopySinglePiece	; erase next square along --> blank
    164  48b1
    165  48b1				   .skipbl
    166  48b1		       a4 85		      ldy	fromX12
    167  48b3		       84 a3		      sty	__boardIndex
    168  48b5
    169  48b5		       20 e7 fc 	      jsr	GetBoard
    170  48b8		       85 99		      sta	lastPiece	; what we are overwriting
    171  48ba		       a5 98		      lda	fromPiece
    172  48bc		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    173  48be		       29 df		      and	#~FLAG_ENPASSANT
    174  48c0		       a4 a3		      ldy	__boardIndex
    175  48c2		       20 ff fc 	      jsr	PutBoard
    176  48c5
      0  48c5					      PHASE	AI_MarchB
      1  48c5		       a9 18		      lda	#AI_MarchB
      2  48c7		       85 8c		      sta	aiState
    178  48c9
    179  48c9				   .unmovedx
    180  48c9		       60		      rts
    181  48ca
    182  48ca
    183  48ca							;---------------------------------------------------------------------------------------------------
    184  48ca
      0  48ca					      DEF	aiMarchB2
      1  48ca				   BANK_aiMarchB2 SET	_CURRENT_BANK
      2  48ca				   aiMarchB2
      3  48ca				   TEMPORARY_VAR SET	Overlay
      4  48ca				   TEMPORARY_OFFSET SET	0
      5  48ca				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      6  48ca				   FUNCTION_NAME SET	aiMarchB2
      7  48ca					      SUBROUTINE
    186  48ca					      SUBROUTINE
    187  48ca
      0  48ca					      REFER	AiStateMachine
      1  48ca				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  48ca				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  48ca					      ENDIF
      0  48ca					      VEND	aiMarchB2
      1  48ca				  -	      IFNCONST	aiMarchB2
      2  48ca				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  48ca				  -	      ERR
      4  48ca					      ENDIF
      5  48ca		       00 a2	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    190  48ca
    191  48ca		       a4 83		      ldy	lastSquareX12
    192  48cc		       84 80		      sty	squareToDraw
    193  48ce
    194  48ce		       20 e7 fc 	      jsr	GetBoard
    195  48d1		       c9 00		      cmp	#0
    196  48d3		       f0 03		      beq	.skipbl2
    197  48d5
    198  48d5		       20 57 fd 	      jsr	CopySinglePiece	; draw previous piece back in old position
    199  48d8				   .skipbl2
    200  48d8
    201  48d8		       a5 85		      lda	fromX12
    202  48da		       c5 86		      cmp	toX12
    203  48dc		       f0 09		      beq	xhalt
    204  48de
    205  48de		       a9 00		      lda	#0	; inter-move segment speed (can be 0)
    206  48e0		       85 82		      sta	drawDelay
      0  48e2					      PHASE	AI_MarchToTargetA
      1  48e2		       a9 17		      lda	#AI_MarchToTargetA
      2  48e4		       85 8c		      sta	aiState
    208  48e6
    209  48e6		       60		      rts
    210  48e7
    211  48e7				   xhalt
    212  48e7
    213  48e7							;??? jsr FinaliseMove
    214  48e7
    215  48e7		       a9 04		      lda	#4	; on/off count
    216  48e9		       85 84		      sta	drawCount	; flashing for piece about to move
    217  48eb		       a9 00		      lda	#0
    218  48ed		       85 82		      sta	drawDelay
    219  48ef
      0  48ef					      PHASE	AI_FinalFlash
      1  48ef		       a9 1b		      lda	#AI_FinalFlash
      2  48f1		       85 8c		      sta	aiState
    221  48f3		       60		      rts
    222  48f4
    223  48f4
    224  48f4							;---------------------------------------------------------------------------------------------------
    225  48f4
    226  48f4				  -	      if	0
    227  48f4				  -	      DEF	FinaliseMove
    228  48f4				  -	      SUBROUTINE
    229  48f4				  -
    230  48f4				  -	      REFER	aiMarchB2
    231  48f4				  -	      VEND	FinaliseMove
    232  48f4				  -
    233  48f4				  -			; Now the visible movement on the board has happened, fix up the pointers to the pieces
    234  48f4				  -			; for both sides.
    235  48f4				  -
    236  48f4				  -	      lda	#BANK_FinaliseMove
    237  48f4				  -	      sta	savedBank
    238  48f4				  -
    239  48f4				  -			;lda sideToMove
    240  48f4				  -			;asl
    241  48f4				  -			;lda #RAMBANK_PLY
    242  48f4				  -			;adc #0
    243  48f4				  -			;jsr GoFixPieceList
    244  48f4				  -
    245  48f4				  -	      lda	toX12
    246  48f4				  -	      sta	fromX12	; there MAY be no other-side piece at this square - that is OK!
    247  48f4				  -	      sta	originX12
    248  48f4				  -
    249  48f4				  -	      lda	#0
    250  48f4				  -	      sta	toX12	; --> deleted (square=0)
    251  48f4				  -
    252  48f4				  -			;lda lastPiece
    253  48f4				  -			;beq .notake
    254  48f4				  -
    255  48f4				  -			;lda sideToMove
    256  48f4				  -			;eor #128
    257  48f4				  -			;asl
    258  48f4				  -			;lda #RAMBANK_PLY
    259  48f4				  -			;adc #0
    260  48f4				  -			;jsr GoFixPieceList		    ; REMOVE any captured object
    261  48f4				  -
    262  48f4				  -.notake    rts
    263  48f4					      endif
    264  48f4
    265  48f4
    266  48f4							;---------------------------------------------------------------------------------------------------
    267  48f4
      0  48f4					      DEF	aiMarchToTargetB
      1  48f4				   BANK_aiMarchToTargetB SET	_CURRENT_BANK
      2  48f4				   aiMarchToTargetB
      3  48f4				   TEMPORARY_VAR SET	Overlay
      4  48f4				   TEMPORARY_OFFSET SET	0
      5  48f4				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      6  48f4				   FUNCTION_NAME SET	aiMarchToTargetB
      7  48f4					      SUBROUTINE
    269  48f4					      SUBROUTINE
    270  48f4
      0  48f4					      REFER	AiStateMachine
      1  48f4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  48f4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  48f4					      ENDIF
      0  48f4					      VEND	aiMarchToTargetB
      1  48f4				  -	      IFNCONST	aiMarchToTargetB
      2  48f4				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  48f4				  -	      ERR
      4  48f4					      ENDIF
      5  48f4		       00 a2	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    273  48f4
    274  48f4							; now we want to undraw the piece in the old square
    275  48f4
    276  48f4		       a5 83		      lda	lastSquareX12
    277  48f6		       85 80		      sta	squareToDraw
    278  48f8
    279  48f8		       20 57 fd 	      jsr	CopySinglePiece	; erase whatever was on the previous square (completely blank)
    280  48fb
    281  48fb		       a4 83		      ldy	lastSquareX12
    282  48fd		       a5 9a		      lda	previousPiece
    283  48ff		       20 ff fc 	      jsr	PutBoard
    284  4902
    285  4902		       a5 99		      lda	lastPiece
    286  4904		       85 9a		      sta	previousPiece
    287  4906
      0  4906					      PHASE	AI_MarchB2
      1  4906		       a9 1a		      lda	#AI_MarchB2
      2  4908		       85 8c		      sta	aiState
    289  490a		       60		      rts
    290  490b
    291  490b
    292  490b							;---------------------------------------------------------------------------------------------------
    293  490b
    294  490b
    295  490b							;---------------------------------------------------------------------------------------------------
    296  490b
      0  490b					      DEF	CopySetupForMarker
      1  490b				   BANK_CopySetupForMarker SET	_CURRENT_BANK
      2  490b				   CopySetupForMarker
      3  490b				   TEMPORARY_VAR SET	Overlay
      4  490b				   TEMPORARY_OFFSET SET	0
      5  490b				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      6  490b				   FUNCTION_NAME SET	CopySetupForMarker
      7  490b					      SUBROUTINE
    298  490b					      SUBROUTINE
    299  490b
      0  490b					      REFER	markerDraw
      1  490b					      IF	VAREND_markerDraw > TEMPORARY_VAR
      2  490b				   TEMPORARY_VAR SET	VAREND_markerDraw
      3  490b					      ENDIF
      0  490b					      REFER	showPromoteOptions
      1  490b				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  490b				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  490b					      ENDIF
      0  490b					      VAR	__pieceColour, 1
      1  490b		       00 a4	   __pieceColour =	TEMPORARY_VAR
      2  490b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  490b
      4  490b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  490b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  490b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  490b					      ENDIF
      8  490b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  490b				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  490b				  -	      ERR
     11  490b					      ENDIF
     12  490b					      LIST	ON
      0  490b					      VAR	__oddeven, 1
      1  490b		       00 a5	   __oddeven  =	TEMPORARY_VAR
      2  490b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  490b
      4  490b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  490b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  490b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  490b					      ENDIF
      8  490b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  490b				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  490b				  -	      ERR
     11  490b					      ENDIF
     12  490b					      LIST	ON
      0  490b					      VAR	__pmcol, 1
      1  490b		       00 a6	   __pmcol    =	TEMPORARY_VAR
      2  490b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  490b
      4  490b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  490b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  490b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  490b					      ENDIF
      8  490b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  490b				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  490b				  -	      ERR
     11  490b					      ENDIF
     12  490b					      LIST	ON
      0  490b					      VEND	CopySetupForMarker
      1  490b				  -	      IFNCONST	CopySetupForMarker
      2  490b				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  490b				  -	      ERR
      4  490b					      ENDIF
      5  490b		       00 a7	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    306  490b
    307  490b		       a5 80		      lda	squareToDraw
    308  490d		       38		      sec
    309  490e		       a0 0a		      ldy	#10
    310  4910		       e9 0a	   .sub10     sbc	#10
    311  4912		       88		      dey
    312  4913		       b0 fb		      bcs	.sub10
    313  4915		       84 a5		      sty	__oddeven
    314  4917		       69 08		      adc	#8
    315  4919		       85 a6		      sta	__pmcol
    316  491b		       65 a5		      adc	__oddeven
    317  491d
    318  491d		       29 01		      and	#1
    319  491f		       49 01		      eor	#1
    320  4921		       f0 02		      beq	.white
    321  4923		       a9 24		      lda	#36
    322  4925				   .white
    323  4925		       85 a4		      sta	__pieceColour	; actually SQUARE black/white
    324  4927
    325  4927		       8a		      txa
    326  4928		       18		      clc
    327  4929		       65 a4		      adc	__pieceColour
    328  492b		       85 a4		      sta	__pieceColour
    329  492d
    330  492d		       a5 a6		      lda	__pmcol
    331  492f		       29 03		      and	#3
    332  4931
    333  4931		       18		      clc
    334  4932		       65 a4		      adc	__pieceColour
    335  4934		       a8		      tay
    336  4935		       60		      rts
    337  4936
    338  4936							;---------------------------------------------------------------------------------------------------
    339  4936
      0  4936					      DEF	CopySetup
      1  4936				   BANK_CopySetup SET	_CURRENT_BANK
      2  4936				   CopySetup
      3  4936				   TEMPORARY_VAR SET	Overlay
      4  4936				   TEMPORARY_OFFSET SET	0
      5  4936				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      6  4936				   FUNCTION_NAME SET	CopySetup
      7  4936					      SUBROUTINE
    341  4936					      SUBROUTINE
    342  4936
      0  4936					      REFER	CopySinglePiece
      1  4936					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  4936				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  4936					      ENDIF
      0  4936					      VAR	__tmp, 1
      1  4936		       00 ad	   __tmp      =	TEMPORARY_VAR
      2  4936				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4936
      4  4936				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4936				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4936				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4936					      ENDIF
      8  4936				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4936				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  4936				  -	      ERR
     11  4936					      ENDIF
     12  4936					      LIST	ON
      0  4936					      VAR	__shiftx, 1
      1  4936		       00 ae	   __shiftx   =	TEMPORARY_VAR
      2  4936				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4936
      4  4936				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4936				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4936				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4936					      ENDIF
      8  4936				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4936				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  4936				  -	      ERR
     11  4936					      ENDIF
     12  4936					      LIST	ON
      0  4936					      VEND	CopySetup
      1  4936				  -	      IFNCONST	CopySetup
      2  4936				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  4936				  -	      ERR
      4  4936					      ENDIF
      5  4936		       00 af	   VAREND_CopySetup =	TEMPORARY_VAR
    347  4936
    348  4936		       a5 8b		      lda	savedBank
    349  4938		       48		      pha
    350  4939		       a9 09		      lda	#BANK_CopySetup
    351  493b		       85 8b		      sta	savedBank
    352  493d
    353  493d							; figure colouration of square
    354  493d
    355  493d		       a5 80		      lda	squareToDraw
    356  493f		       a2 0a		      ldx	#10
    357  4941		       38		      sec
    358  4942		       e9 0a	   .sub10     sbc	#10
    359  4944		       ca		      dex
    360  4945		       b0 fb		      bcs	.sub10
    361  4947		       69 08		      adc	#8
    362  4949		       85 ae		      sta	__shiftx
    363  494b		       86 ad		      stx	__tmp
    364  494d		       65 ad		      adc	__tmp
    365  494f
    366  494f
    367  494f		       29 01		      and	#1
    368  4951		       49 01		      eor	#1
    369  4953		       f0 02		      beq	.white
    370  4955		       a9 24		      lda	#36
    371  4957		       85 a4	   .white     sta	__pieceColour	; actually SQUARE black/white
    372  4959
    373  4959							; PieceColour = 0 for white square, 36 for black square
    374  4959
    375  4959							;lda #RAMBANK_BOARD
    376  4959							;sta SET_BANK_RAM
    377  4959
    378  4959		       a4 80		      ldy	squareToDraw
    379  495b		       20 e7 fc 	      jsr	GetBoard	;lda Board,x
    380  495e		       0a		      asl
    381  495f		       90 02		      bcc	.blackAdjust
    382  4961		       09 10		      ora	#16
    383  4963		       4a	   .blackAdjust lsr
    384  4964		       29 0f		      and	#%1111
    385  4966		       aa		      tax
    386  4967
    387  4967		       a5 ae		      lda	__shiftx
    388  4969		       29 03		      and	#3	; shift position in P
    389  496b
    390  496b		       18		      clc
    391  496c		       7d 77 f1 	      adc	PieceToShape,x
    392  496f		       18		      clc
    393  4970		       65 a4		      adc	__pieceColour
    394  4972		       a8		      tay
    395  4973
    396  4973		       68		      pla
    397  4974		       85 8b		      sta	savedBank
    398  4976		       60		      rts
    399  4977
    400  4977				   PieceToShape
    401  4977
    402  4977		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    403  4978		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    404  4979		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    405  497a		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    406  497b		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    407  497c		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    408  497d		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    409  497e		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    410  497f
    411  497f		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    412  4980		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    413  4981		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    414  4982		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    415  4983		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    416  4984		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    417  4985		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    418  4986		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    419  4987
    420  4987							;---------------------------------------------------------------------------------------------------
    421  4987
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  4987					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  4987					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  4987					      LIST	ON
      0  4987					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  4987				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  4987				   BLACK_BISHOP_on_BLACK_SQUARE_0
      3  4987				   TEMPORARY_VAR SET	Overlay
      4  4987				   TEMPORARY_OFFSET SET	0
      5  4987				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  4987				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      7  4987					      SUBROUTINE
      3  4987		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  499f		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  49b7		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  49cf					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  49cf					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  4a00					      LIST	ON
      0  4a00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  4a00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  4a00				   BLACK_BISHOP_on_BLACK_SQUARE_1
      3  4a00				   TEMPORARY_VAR SET	Overlay
      4  4a00				   TEMPORARY_OFFSET SET	0
      5  4a00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  4a00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      7  4a00					      SUBROUTINE
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  4a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  4a48					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  4a48					      LIST	ON
      0  4a48					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  4a48				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  4a48				   BLACK_BISHOP_on_BLACK_SQUARE_2
      3  4a48				   TEMPORARY_VAR SET	Overlay
      4  4a48				   TEMPORARY_OFFSET SET	0
      5  4a48				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  4a48				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      7  4a48					      SUBROUTINE
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  4a90					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  4a90					      LIST	ON
      0  4a90					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  4a90				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  4a90				   BLACK_BISHOP_on_BLACK_SQUARE_3
      3  4a90				   TEMPORARY_VAR SET	Overlay
      4  4a90				   TEMPORARY_OFFSET SET	0
      5  4a90				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4a90				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      7  4a90					      SUBROUTINE
      3  4a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ac0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  4ad8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  4b00					      LIST	ON
      0  4b00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  4b00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  4b00				   BLACK_ROOK_on_BLACK_SQUARE_0
      3  4b00				   TEMPORARY_VAR SET	Overlay
      4  4b00				   TEMPORARY_OFFSET SET	0
      5  4b00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  4b00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      7  4b00					      SUBROUTINE
      3  4b00		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  4b18		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  4b48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  4b48					      LIST	ON
      0  4b48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  4b48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  4b48				   BLACK_ROOK_on_BLACK_SQUARE_1
      3  4b48				   TEMPORARY_VAR SET	Overlay
      4  4b48				   TEMPORARY_OFFSET SET	0
      5  4b48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  4b48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      7  4b48					      SUBROUTINE
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  4b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  4b90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  4b90					      LIST	ON
      0  4b90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  4b90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  4b90				   BLACK_ROOK_on_BLACK_SQUARE_2
      3  4b90				   TEMPORARY_VAR SET	Overlay
      4  4b90				   TEMPORARY_OFFSET SET	0
      5  4b90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  4b90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      7  4b90					      SUBROUTINE
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  4bc0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  4bd8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  4bd8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  4c00					      LIST	ON
      0  4c00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  4c00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  4c00				   BLACK_ROOK_on_BLACK_SQUARE_3
      3  4c00				   TEMPORARY_VAR SET	Overlay
      4  4c00				   TEMPORARY_OFFSET SET	0
      5  4c00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4c00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      7  4c00					      SUBROUTINE
      3  4c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c30		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  4c48					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  4c48					      LIST	ON
      0  4c48					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  4c48				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  4c48				   BLACK_QUEEN_on_BLACK_SQUARE_0
      3  4c48				   TEMPORARY_VAR SET	Overlay
      4  4c48				   TEMPORARY_OFFSET SET	0
      5  4c48				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  4c48				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      7  4c48					      SUBROUTINE
      3  4c48		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  4c90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  4c90					      LIST	ON
      0  4c90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  4c90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  4c90				   BLACK_QUEEN_on_BLACK_SQUARE_1
      3  4c90				   TEMPORARY_VAR SET	Overlay
      4  4c90				   TEMPORARY_OFFSET SET	0
      5  4c90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  4c90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      7  4c90					      SUBROUTINE
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  4cd8					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  4d00					      LIST	ON
      0  4d00					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  4d00				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  4d00				   BLACK_QUEEN_on_BLACK_SQUARE_2
      3  4d00				   TEMPORARY_VAR SET	Overlay
      4  4d00				   TEMPORARY_OFFSET SET	0
      5  4d00				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  4d00				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      7  4d00					      SUBROUTINE
      3  4d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d18		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  4d48					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  4d48					      LIST	ON
      0  4d48					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  4d48				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  4d48				   BLACK_QUEEN_on_BLACK_SQUARE_3
      3  4d48				   TEMPORARY_VAR SET	Overlay
      4  4d48				   TEMPORARY_OFFSET SET	0
      5  4d48				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4d48				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      7  4d48					      SUBROUTINE
      3  4d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d78		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  4d90					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  4d90					      LIST	ON
      0  4d90					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  4d90				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  4d90				   BLACK_KING_on_BLACK_SQUARE_0
      3  4d90				   TEMPORARY_VAR SET	Overlay
      4  4d90				   TEMPORARY_OFFSET SET	0
      5  4d90				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  4d90				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      7  4d90					      SUBROUTINE
      3  4d90		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$a0,$00,$00,$b0,$00,$00	;PF0
      4  4da8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00	;PF1
      5  4dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  4dd8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  4e00					      LIST	ON
      0  4e00					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  4e00				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  4e00				   BLACK_KING_on_BLACK_SQUARE_1
      3  4e00				   TEMPORARY_VAR SET	Overlay
      4  4e00				   TEMPORARY_OFFSET SET	0
      5  4e00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  4e00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      7  4e00					      SUBROUTINE
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$28,$00,$00,$6c,$00,$00	;PF1
      5  4e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  4e48					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  4e48					      LIST	ON
      0  4e48					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  4e48				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  4e48				   BLACK_KING_on_BLACK_SQUARE_2
      3  4e48				   TEMPORARY_VAR SET	Overlay
      4  4e48				   TEMPORARY_OFFSET SET	0
      5  4e48				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  4e48				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      7  4e48					      SUBROUTINE
      3  4e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e60		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$01,$00,$00,$03,$00,$00	;PF1
      5  4e78		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$02,$00,$00,$06,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  4e90					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  4e90					      LIST	ON
      0  4e90					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  4e90				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  4e90				   BLACK_KING_on_BLACK_SQUARE_3
      3  4e90				   TEMPORARY_VAR SET	Overlay
      4  4e90				   TEMPORARY_OFFSET SET	0
      5  4e90				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4e90				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      7  4e90					      SUBROUTINE
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ec0		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$50,$00,$00,$d8,$00,$00	;PF2
------- FILE BANK_RECON.asm
    438  4ed8
    439  4ed8
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  4ed8					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  4f00					      LIST	ON
      0  4f00					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  4f00				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  4f00				   WHITE_MARKER_on_WHITE_SQUARE_3
      3  4f00				   TEMPORARY_VAR SET	Overlay
      4  4f00				   TEMPORARY_OFFSET SET	0
      5  4f00				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  4f00				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      7  4f00					      SUBROUTINE
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4f30		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
    441  4f48
      0  4f48					      CHECK_BANK_SIZE	"BANK_RECON"
      1  4f48		       07 48	   .TEMP      =	* - BANK_START
 BANK_RECON (2K) SIZE =  $748 , FREE= $b8
      2  4f48					      ECHO	"BANK_RECON", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4f48				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4f48				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4f48				  -	      ERR
      6  4f48					      endif
    443  4f48
    444  4f48							; EOF
------- FILE ./chess.asm
    584  4f48
    585  4f48							; The handlers for piece move generation
------- FILE Handler_BANK1.asm LEVEL 2 PASS 5
      0  4f48					      include	"Handler_BANK1.asm"
      1  4f48							; Copyright (C)2020 Andrew Davie
      2  4f48
      3  4f48							;---------------------------------------------------------------------------------------------------
      4  4f48
      0  4f48					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1  4f48
      2  4f48
      3  4f48
      4 U2000 ????				      SEG.U	BOARD
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	RAM_3E
      7 U2000				   BANK_START SET	*
      8 U2000				   RAMBANK_BOARD SET	ORIGIN_RAM / RAM_SIZE
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U2000					      NEWBANK	MOVES	; copy the following bank to RAMBANK_BOARD
      1  5648 ????				      SEG	MOVES
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   MOVES      SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	MOVES
      7  5000
      8  5000							; Board is a 10 x 12 object which simplifies the generation of moves
      9  5000							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     10  5000							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     11  5000
     12  5000							;     X12 numbering
     13  5000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     14  5000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     15  5000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     16  5000							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     17  5000							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     18  5000							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     19  5000							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     20  5000							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     21  5000							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     22  5000							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     23  5000							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     24  5000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     25  5000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     26  5000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     27  5000							;	0   1	2   3	4   5	6   7	8   9
     28  5000							;		A   B	C   D	E   F	G   H
     29  5000
     30  5000							;     HEX X12
     31  5000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     32  5000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     33  5000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     34  5000							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     35  5000							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     36  5000							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     37  5000							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     38  5000							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     39  5000							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     40  5000							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     41  5000							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     42  5000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     43  5000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     44  5000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     45  5000							;	0   1	2   3	4   5	6   7	8   9
     46  5000							;		A   B	C   D	E   F	G   H
     47  5000
     48  5000
     49  5000							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     50  5000							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     51  5000							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     52  5000							; be re-used for something else - we just need to guarantee there are 21 of them there
     53  5000
      0  5000					      ALLOCATE	Valid, 120 + 80 + 21
      0  5000					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  5000					      LIST	ON
      0  5000					      DEF	Valid
      1  5000				   BANK_Valid SET	_CURRENT_BANK
      2  5000				   Valid
      3  5000				   TEMPORARY_VAR SET	Overlay
      4  5000				   TEMPORARY_OFFSET SET	0
      5  5000				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      6  5000				   FUNCTION_NAME SET	Valid
      7  5000					      SUBROUTINE
     55  5000		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     56  5015
     57  5015							; Note, we will never index INTO the above bytes - x will always be >= 22
     58  5015							; We just need to make sure that the actual indexing will not have an address before
     59  5015							; the index of outside the page.
     60  5015
      0  5015					      DEF	ValidSquare
      1  5015				   BANK_ValidSquare SET	_CURRENT_BANK
      2  5015				   ValidSquare
      3  5015				   TEMPORARY_VAR SET	Overlay
      4  5015				   TEMPORARY_OFFSET SET	0
      5  5015				   VAR_BOUNDARY_ValidSquare SET	TEMPORARY_OFFSET
      6  5015				   FUNCTION_NAME SET	ValidSquare
      7  5015					      SUBROUTINE
     62  5015
     63  5015
     64  5015							; Use this table to
     65  5015							;   a) Determine if a square is valid (-1 = NO)
     66  5015							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     67  5015							;	if a white pawn on square "x" can move "up" the board.
     68  5015
     69  5015		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     70  501f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     71  5029		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     72  5033		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     73  503d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     74  5047		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     75  5051		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     76  505b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     77  5065		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     78  506f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     79  5079
      0  5079					      DEF	Board
      1  5079				   BANK_Board SET	_CURRENT_BANK
      2  5079				   Board
      3  5079				   TEMPORARY_VAR SET	Overlay
      4  5079				   TEMPORARY_OFFSET SET	0
      5  5079				   VAR_BOUNDARY_Board SET	TEMPORARY_OFFSET
      6  5079				   FUNCTION_NAME SET	Board
      7  5079					      SUBROUTINE
     81  5079
     82  5079							; A 10X10... we should never write using invalid square
     83  5079							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     84  5079							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     85  5079
     86  5079		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     87  5083		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     88  508d
     89  508d					      REPEAT	8
     90  508d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  508d					      REPEND
     90  5097		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  5097					      REPEND
     90  50a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50a1					      REPEND
     90  50ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50ab					      REPEND
     90  50b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50b5					      REPEND
     90  50bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50bf					      REPEND
     90  50c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     89  50c9					      REPEND
     90  50d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     91  50dd					      REPEND
     92  50dd
     93  50dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     94  50dd
     95  50dd							;DEF PieceList
     96  50dd							;ds 16
     97  50dd
     98  50dd
     99  50dd
    100  50dd							;---------------------------------------------------------------------------------------------------
    101  50dd
------- FILE Handler_QUEEN.asm LEVEL 3 PASS 5
      0  50dd					      include	"Handler_QUEEN.asm"
      1  50dd							; Copyright (C)2020 Andrew Davie
      2  50dd
      3  50dd							;---------------------------------------------------------------------------------------------------
      4  50dd							; QUEEN
      5  50dd							;---------------------------------------------------------------------------------------------------
      6  50dd
      0  50dd					      DEF	Handle_QUEEN
      1  50dd				   BANK_Handle_QUEEN SET	_CURRENT_BANK
      2  50dd				   Handle_QUEEN
      3  50dd				   TEMPORARY_VAR SET	Overlay
      4  50dd				   TEMPORARY_OFFSET SET	0
      5  50dd				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      6  50dd				   FUNCTION_NAME SET	Handle_QUEEN
      7  50dd					      SUBROUTINE
      8  50dd					      SUBROUTINE
      9  50dd
      0  50dd					      REFER	GenerateAllMoves
      1  50dd					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  50dd				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  50dd					      ENDIF
      0  50dd					      VEND	Handle_QUEEN
      1  50dd				  -	      IFNCONST	Handle_QUEEN
      2  50dd				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  50dd				  -	      ERR
      4  50dd					      ENDIF
      5  50dd		       00 b0	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  50dd
     13  50dd							; Pass...
     14  50dd							; x = currentSquare (square the piece is on)
     15  50dd							; currentPiece (with flags/colour attached)
     16  50dd
      0  50dd					      MOVE_TOWARDS	_DOWN+_LEFT
      1  50dd					      SUBROUTINE
      2  50dd
      3  50dd
      4  50dd
      5  50dd		       a9 00		      lda	#0
      6  50df		       85 9f		      sta	capture
      7  50e1
      8  50e1		       a6 93		      ldx	currentSquare
      9  50e3		       d0 03		      bne	.project
     10  50e5
     11  50e5		       20 4d fc    .empty     jsr	AddMove
     12  50e8		       bc 0a f0    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  50eb		       30 0e		      bmi	.invalid
     14  50ed		       b9 79 f0 	      lda	Board,y
     15  50f0		       f0 f3		      beq	.empty
     16  50f2		       85 9f		      sta	capture
     17  50f4		       45 92		      eor	currentPiece
     18  50f6		       10 03		      bpl	.invalid
     19  50f8		       20 4d fc 	      jsr	AddMove
     20  50fb
     21  50fb				   .invalid
      0  50fb					      MOVE_TOWARDS	_DOWN
      1  50fb					      SUBROUTINE
      2  50fb
      3  50fb
      4  50fb
      5  50fb		       a9 00		      lda	#0
      6  50fd		       85 9f		      sta	capture
      7  50ff
      8  50ff		       a6 93		      ldx	currentSquare
      9  5101		       d0 03		      bne	.project
     10  5103
     11  5103		       20 4d fc    .empty     jsr	AddMove
     12  5106		       bc 0b f0    .project   ldy	ValidSquare+_DOWN,x
     13  5109		       30 0e		      bmi	.invalid
     14  510b		       b9 79 f0 	      lda	Board,y
     15  510e		       f0 f3		      beq	.empty
     16  5110		       85 9f		      sta	capture
     17  5112		       45 92		      eor	currentPiece
     18  5114		       10 03		      bpl	.invalid
     19  5116		       20 4d fc 	      jsr	AddMove
     20  5119
     21  5119				   .invalid
      0  5119					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  5119					      SUBROUTINE
      2  5119
      3  5119
      4  5119
      5  5119		       a9 00		      lda	#0
      6  511b		       85 9f		      sta	capture
      7  511d
      8  511d		       a6 93		      ldx	currentSquare
      9  511f		       d0 03		      bne	.project
     10  5121
     11  5121		       20 4d fc    .empty     jsr	AddMove
     12  5124		       bc 0c f0    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  5127		       30 0e		      bmi	.invalid
     14  5129		       b9 79 f0 	      lda	Board,y
     15  512c		       f0 f3		      beq	.empty
     16  512e		       85 9f		      sta	capture
     17  5130		       45 92		      eor	currentPiece
     18  5132		       10 03		      bpl	.invalid
     19  5134		       20 4d fc 	      jsr	AddMove
     20  5137
     21  5137				   .invalid
      0  5137					      MOVE_TOWARDS	_RIGHT
      1  5137					      SUBROUTINE
      2  5137
      3  5137
      4  5137
      5  5137		       a9 00		      lda	#0
      6  5139		       85 9f		      sta	capture
      7  513b
      8  513b		       a6 93		      ldx	currentSquare
      9  513d		       d0 03		      bne	.project
     10  513f
     11  513f		       20 4d fc    .empty     jsr	AddMove
     12  5142		       bc 16 f0    .project   ldy	ValidSquare+_RIGHT,x
     13  5145		       30 0e		      bmi	.invalid
     14  5147		       b9 79 f0 	      lda	Board,y
     15  514a		       f0 f3		      beq	.empty
     16  514c		       85 9f		      sta	capture
     17  514e		       45 92		      eor	currentPiece
     18  5150		       10 03		      bpl	.invalid
     19  5152		       20 4d fc 	      jsr	AddMove
     20  5155
     21  5155				   .invalid
      0  5155					      MOVE_TOWARDS	_UP+_RIGHT
      1  5155					      SUBROUTINE
      2  5155
      3  5155
      4  5155
      5  5155		       a9 00		      lda	#0
      6  5157		       85 9f		      sta	capture
      7  5159
      8  5159		       a6 93		      ldx	currentSquare
      9  515b		       d0 03		      bne	.project
     10  515d
     11  515d		       20 4d fc    .empty     jsr	AddMove
     12  5160		       bc 20 f0    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  5163		       30 0e		      bmi	.invalid
     14  5165		       b9 79 f0 	      lda	Board,y
     15  5168		       f0 f3		      beq	.empty
     16  516a		       85 9f		      sta	capture
     17  516c		       45 92		      eor	currentPiece
     18  516e		       10 03		      bpl	.invalid
     19  5170		       20 4d fc 	      jsr	AddMove
     20  5173
     21  5173				   .invalid
      0  5173					      MOVE_TOWARDS	_UP
      1  5173					      SUBROUTINE
      2  5173
      3  5173
      4  5173
      5  5173		       a9 00		      lda	#0
      6  5175		       85 9f		      sta	capture
      7  5177
      8  5177		       a6 93		      ldx	currentSquare
      9  5179		       d0 03		      bne	.project
     10  517b
     11  517b		       20 4d fc    .empty     jsr	AddMove
     12  517e		       bc 1f f0    .project   ldy	ValidSquare+_UP,x
     13  5181		       30 0e		      bmi	.invalid
     14  5183		       b9 79 f0 	      lda	Board,y
     15  5186		       f0 f3		      beq	.empty
     16  5188		       85 9f		      sta	capture
     17  518a		       45 92		      eor	currentPiece
     18  518c		       10 03		      bpl	.invalid
     19  518e		       20 4d fc 	      jsr	AddMove
     20  5191
     21  5191				   .invalid
      0  5191					      MOVE_TOWARDS	_UP+_LEFT
      1  5191					      SUBROUTINE
      2  5191
      3  5191
      4  5191
      5  5191		       a9 00		      lda	#0
      6  5193		       85 9f		      sta	capture
      7  5195
      8  5195		       a6 93		      ldx	currentSquare
      9  5197		       d0 03		      bne	.project
     10  5199
     11  5199		       20 4d fc    .empty     jsr	AddMove
     12  519c		       bc 1e f0    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  519f		       30 0e		      bmi	.invalid
     14  51a1		       b9 79 f0 	      lda	Board,y
     15  51a4		       f0 f3		      beq	.empty
     16  51a6		       85 9f		      sta	capture
     17  51a8		       45 92		      eor	currentPiece
     18  51aa		       10 03		      bpl	.invalid
     19  51ac		       20 4d fc 	      jsr	AddMove
     20  51af
     21  51af				   .invalid
      0  51af					      MOVE_TOWARDS	_LEFT
      1  51af					      SUBROUTINE
      2  51af
      3  51af
      4  51af
      5  51af		       a9 00		      lda	#0
      6  51b1		       85 9f		      sta	capture
      7  51b3
      8  51b3		       a6 93		      ldx	currentSquare
      9  51b5		       d0 03		      bne	.project
     10  51b7
     11  51b7		       20 4d fc    .empty     jsr	AddMove
     12  51ba		       bc 14 f0    .project   ldy	ValidSquare+_LEFT,x
     13  51bd		       30 0e		      bmi	.invalid
     14  51bf		       b9 79 f0 	      lda	Board,y
     15  51c2		       f0 f3		      beq	.empty
     16  51c4		       85 9f		      sta	capture
     17  51c6		       45 92		      eor	currentPiece
     18  51c8		       10 03		      bpl	.invalid
     19  51ca		       20 4d fc 	      jsr	AddMove
     20  51cd
     21  51cd				   .invalid
     25  51cd
     26  51cd		       4c 02 f9 	      jmp	MoveReturn
     27  51d0
     28  51d0							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_BISHOP.asm LEVEL 3 PASS 5
      0  51d0					      include	"Handler_BISHOP.asm"
      1  51d0							; Copyright (C)2020 Andrew Davie
      2  51d0
      3  51d0							;---------------------------------------------------------------------------------------------------
      4  51d0							; BISHOP
      5  51d0							;---------------------------------------------------------------------------------------------------
      6  51d0
      0  51d0					      DEF	Handle_BISHOP
      1  51d0				   BANK_Handle_BISHOP SET	_CURRENT_BANK
      2  51d0				   Handle_BISHOP
      3  51d0				   TEMPORARY_VAR SET	Overlay
      4  51d0				   TEMPORARY_OFFSET SET	0
      5  51d0				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      6  51d0				   FUNCTION_NAME SET	Handle_BISHOP
      7  51d0					      SUBROUTINE
      8  51d0					      SUBROUTINE
      9  51d0
      0  51d0					      REFER	GenerateAllMoves
      1  51d0					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  51d0				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  51d0					      ENDIF
      0  51d0					      VEND	Handle_BISHOP
      1  51d0				  -	      IFNCONST	Handle_BISHOP
      2  51d0				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  51d0				  -	      ERR
      4  51d0					      ENDIF
      5  51d0		       00 b0	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  51d0
     13  51d0							; x = currentSquare (square the piece is on)
     14  51d0							; currentPiece (with flags/colour attached)
     15  51d0
      0  51d0					      MOVE_TOWARDS	_DOWN+_LEFT
      1  51d0					      SUBROUTINE
      2  51d0
      3  51d0
      4  51d0
      5  51d0		       a9 00		      lda	#0
      6  51d2		       85 9f		      sta	capture
      7  51d4
      8  51d4		       a6 93		      ldx	currentSquare
      9  51d6		       d0 03		      bne	.project
     10  51d8
     11  51d8		       20 4d fc    .empty     jsr	AddMove
     12  51db		       bc 0a f0    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  51de		       30 0e		      bmi	.invalid
     14  51e0		       b9 79 f0 	      lda	Board,y
     15  51e3		       f0 f3		      beq	.empty
     16  51e5		       85 9f		      sta	capture
     17  51e7		       45 92		      eor	currentPiece
     18  51e9		       10 03		      bpl	.invalid
     19  51eb		       20 4d fc 	      jsr	AddMove
     20  51ee
     21  51ee				   .invalid
      0  51ee					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  51ee					      SUBROUTINE
      2  51ee
      3  51ee
      4  51ee
      5  51ee		       a9 00		      lda	#0
      6  51f0		       85 9f		      sta	capture
      7  51f2
      8  51f2		       a6 93		      ldx	currentSquare
      9  51f4		       d0 03		      bne	.project
     10  51f6
     11  51f6		       20 4d fc    .empty     jsr	AddMove
     12  51f9		       bc 0c f0    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  51fc		       30 0e		      bmi	.invalid
     14  51fe		       b9 79 f0 	      lda	Board,y
     15  5201		       f0 f3		      beq	.empty
     16  5203		       85 9f		      sta	capture
     17  5205		       45 92		      eor	currentPiece
     18  5207		       10 03		      bpl	.invalid
     19  5209		       20 4d fc 	      jsr	AddMove
     20  520c
     21  520c				   .invalid
      0  520c					      MOVE_TOWARDS	_UP+_LEFT
      1  520c					      SUBROUTINE
      2  520c
      3  520c
      4  520c
      5  520c		       a9 00		      lda	#0
      6  520e		       85 9f		      sta	capture
      7  5210
      8  5210		       a6 93		      ldx	currentSquare
      9  5212		       d0 03		      bne	.project
     10  5214
     11  5214		       20 4d fc    .empty     jsr	AddMove
     12  5217		       bc 1e f0    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  521a		       30 0e		      bmi	.invalid
     14  521c		       b9 79 f0 	      lda	Board,y
     15  521f		       f0 f3		      beq	.empty
     16  5221		       85 9f		      sta	capture
     17  5223		       45 92		      eor	currentPiece
     18  5225		       10 03		      bpl	.invalid
     19  5227		       20 4d fc 	      jsr	AddMove
     20  522a
     21  522a				   .invalid
      0  522a					      MOVE_TOWARDS	_UP+_RIGHT
      1  522a					      SUBROUTINE
      2  522a
      3  522a
      4  522a
      5  522a		       a9 00		      lda	#0
      6  522c		       85 9f		      sta	capture
      7  522e
      8  522e		       a6 93		      ldx	currentSquare
      9  5230		       d0 03		      bne	.project
     10  5232
     11  5232		       20 4d fc    .empty     jsr	AddMove
     12  5235		       bc 20 f0    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  5238		       30 0e		      bmi	.invalid
     14  523a		       b9 79 f0 	      lda	Board,y
     15  523d		       f0 f3		      beq	.empty
     16  523f		       85 9f		      sta	capture
     17  5241		       45 92		      eor	currentPiece
     18  5243		       10 03		      bpl	.invalid
     19  5245		       20 4d fc 	      jsr	AddMove
     20  5248
     21  5248				   .invalid
     20  5248
     21  5248		       4c 02 f9 	      jmp	MoveReturn
     22  524b
     23  524b							;---------------------------------------------------------------------------------------------------
     24  524b							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_ROOK.asm LEVEL 3 PASS 5
      0  524b					      include	"Handler_ROOK.asm"
      1  524b							; Copyright (C)2020 Andrew Davie
      2  524b							; Rook move handler
      3  524b
      4  524b							;---------------------------------------------------------------------------------------------------
      5  524b							; ROOK
      6  524b							;---------------------------------------------------------------------------------------------------
      7  524b
      0  524b					      DEF	Handle_ROOK
      1  524b				   BANK_Handle_ROOK SET	_CURRENT_BANK
      2  524b				   Handle_ROOK
      3  524b				   TEMPORARY_VAR SET	Overlay
      4  524b				   TEMPORARY_OFFSET SET	0
      5  524b				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      6  524b				   FUNCTION_NAME SET	Handle_ROOK
      7  524b					      SUBROUTINE
      9  524b					      SUBROUTINE
     10  524b
      0  524b					      REFER	GenerateAllMoves
      1  524b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  524b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  524b					      ENDIF
      0  524b					      VEND	Handle_ROOK
      1  524b				  -	      IFNCONST	Handle_ROOK
      2  524b				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  524b				  -	      ERR
      4  524b					      ENDIF
      5  524b		       00 b0	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  524b
     14  524b							; Pass...
     15  524b							; x = currentSquare (square the piece is on)
     16  524b							; currentPiece (with flags/colour attached)
     17  524b
      0  524b					      MOVE_TOWARDS	_DOWN
      1  524b					      SUBROUTINE
      2  524b
      3  524b
      4  524b
      5  524b		       a9 00		      lda	#0
      6  524d		       85 9f		      sta	capture
      7  524f
      8  524f		       a6 93		      ldx	currentSquare
      9  5251		       d0 03		      bne	.project
     10  5253
     11  5253		       20 4d fc    .empty     jsr	AddMove
     12  5256		       bc 0b f0    .project   ldy	ValidSquare+_DOWN,x
     13  5259		       30 0e		      bmi	.invalid
     14  525b		       b9 79 f0 	      lda	Board,y
     15  525e		       f0 f3		      beq	.empty
     16  5260		       85 9f		      sta	capture
     17  5262		       45 92		      eor	currentPiece
     18  5264		       10 03		      bpl	.invalid
     19  5266		       20 4d fc 	      jsr	AddMove
     20  5269
     21  5269				   .invalid
      0  5269					      MOVE_TOWARDS	_RIGHT
      1  5269					      SUBROUTINE
      2  5269
      3  5269
      4  5269
      5  5269		       a9 00		      lda	#0
      6  526b		       85 9f		      sta	capture
      7  526d
      8  526d		       a6 93		      ldx	currentSquare
      9  526f		       d0 03		      bne	.project
     10  5271
     11  5271		       20 4d fc    .empty     jsr	AddMove
     12  5274		       bc 16 f0    .project   ldy	ValidSquare+_RIGHT,x
     13  5277		       30 0e		      bmi	.invalid
     14  5279		       b9 79 f0 	      lda	Board,y
     15  527c		       f0 f3		      beq	.empty
     16  527e		       85 9f		      sta	capture
     17  5280		       45 92		      eor	currentPiece
     18  5282		       10 03		      bpl	.invalid
     19  5284		       20 4d fc 	      jsr	AddMove
     20  5287
     21  5287				   .invalid
      0  5287					      MOVE_TOWARDS	_UP
      1  5287					      SUBROUTINE
      2  5287
      3  5287
      4  5287
      5  5287		       a9 00		      lda	#0
      6  5289		       85 9f		      sta	capture
      7  528b
      8  528b		       a6 93		      ldx	currentSquare
      9  528d		       d0 03		      bne	.project
     10  528f
     11  528f		       20 4d fc    .empty     jsr	AddMove
     12  5292		       bc 1f f0    .project   ldy	ValidSquare+_UP,x
     13  5295		       30 0e		      bmi	.invalid
     14  5297		       b9 79 f0 	      lda	Board,y
     15  529a		       f0 f3		      beq	.empty
     16  529c		       85 9f		      sta	capture
     17  529e		       45 92		      eor	currentPiece
     18  52a0		       10 03		      bpl	.invalid
     19  52a2		       20 4d fc 	      jsr	AddMove
     20  52a5
     21  52a5				   .invalid
      0  52a5					      MOVE_TOWARDS	_LEFT
      1  52a5					      SUBROUTINE
      2  52a5
      3  52a5
      4  52a5
      5  52a5		       a9 00		      lda	#0
      6  52a7		       85 9f		      sta	capture
      7  52a9
      8  52a9		       a6 93		      ldx	currentSquare
      9  52ab		       d0 03		      bne	.project
     10  52ad
     11  52ad		       20 4d fc    .empty     jsr	AddMove
     12  52b0		       bc 14 f0    .project   ldy	ValidSquare+_LEFT,x
     13  52b3		       30 0e		      bmi	.invalid
     14  52b5		       b9 79 f0 	      lda	Board,y
     15  52b8		       f0 f3		      beq	.empty
     16  52ba		       85 9f		      sta	capture
     17  52bc		       45 92		      eor	currentPiece
     18  52be		       10 03		      bpl	.invalid
     19  52c0		       20 4d fc 	      jsr	AddMove
     20  52c3
     21  52c3				   .invalid
     22  52c3
     23  52c3		       4c 02 f9 	      jmp	MoveReturn
     24  52c6
     25  52c6							;---------------------------------------------------------------------------------------------------
     26  52c6							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_KING.asm LEVEL 3 PASS 5
      0  52c6					      include	"Handler_KING.asm"
      1  52c6							; Copyright (C)2020 Andrew Davie
      2  52c6
      3  52c6							;---------------------------------------------------------------------------------------------------
      4  52c6							; KING
      5  52c6							; This is the move handler for a KING
      6  52c6							; "Check" is detected in the next ply of the search.
      7  52c6
      8  52c6
      9  52c6							;---------------------------------------------------------------------------------------------------
     10  52c6
     11  52c6							; MACRO - Castling
     12  52c6
     13  52c6		       00 03	   KINGSIDE   =	3
     14  52c6		       ff ff ff fc QUEENSIDE  =	-4
     15  52c6
     16  52c6					      MAC	castle
     17  52c6							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  52c6
     19  52c6					      ldx	currentSquare
     20  52c6					      lda	Board+{1},x	; kingside/queenside R position
     21  52c6					      and	#PIECE_MASK|FLAG_MOVED
     22  52c6					      cmp	#ROOK
     23  52c6					      bne	.noCastle	; not a R that hasn't moved
     24  52c6
     25  52c6							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  52c6							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  52c6
     28  52c6					      IF	{1} = QUEENSIDE
     29  52c6					      lda	Board-3,x	; N pos
     30  52c6					      ora	Board-2,x	; B pos
     31  52c6					      ora	Board-1,x	; Q pos
     32  52c6					      bne	.noCastle	; not vacant?
     33  52c6
     34  52c6					      ENDIF
     35  52c6
     36  52c6					      IF	{1} = KINGSIDE
     37  52c6					      lda	Board+2,x	; N pos
     38  52c6					      ora	Board+1,x	; B pos
     39  52c6					      bne	.noCastle	; not vacant?
     40  52c6					      ENDIF
     41  52c6
     42  52c6							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  52c6
     44  52c6							; FINALLY -- king can castle
     45  52c6							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  52c6							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  52c6							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  52c6
     49  52c6					      lda	currentPiece
     50  52c6					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  52c6					      sta	currentPiece
     52  52c6
     53  52c6					      IF	{1} = KINGSIDE
     54  52c6					      ldy	ValidSquare+2,x
     55  52c6					      ENDIF
     56  52c6
     57  52c6					      IF	{1} = QUEENSIDE
     58  52c6					      ldy	ValidSquare-2,x
     59  52c6					      ENDIF
     60  52c6
     61  52c6					      jsr	AddMove	; 57
     62  52c6
     63  52c6				   .noCastle
     64  52c6					      ENDM
     65  52c6
     66  52c6
     67  52c6							;---------------------------------------------------------------------------------------------------
     68  52c6
      0  52c6					      DEF	Handle_KING
      1  52c6				   BANK_Handle_KING SET	_CURRENT_BANK
      2  52c6				   Handle_KING
      3  52c6				   TEMPORARY_VAR SET	Overlay
      4  52c6				   TEMPORARY_OFFSET SET	0
      5  52c6				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      6  52c6				   FUNCTION_NAME SET	Handle_KING
      7  52c6					      SUBROUTINE
     70  52c6					      SUBROUTINE
     71  52c6
      0  52c6					      REFER	GenerateAllMoves
      1  52c6					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  52c6				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  52c6					      ENDIF
      0  52c6					      VEND	Handle_KING
      1  52c6				  -	      IFNCONST	Handle_KING
      2  52c6				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  52c6				  -	      ERR
      4  52c6					      ENDIF
      5  52c6		       00 b0	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  52c6
     75  52c6							; x = currentSquare (square the KING is on)
     76  52c6							; currentPiece (KING of course, but with flags/colour attached)
     77  52c6
      0  52c6					      MOVE_TO	_DOWN+_LEFT
      1  52c6					      SUBROUTINE
      2  52c6		       bc 0a f0 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  52c9		       30 0e		      bmi	.invalid
      4  52cb		       b9 79 f0 	      lda	Board,y
      5  52ce		       85 9f		      sta	capture
      6  52d0		       f0 04		      beq	.squareEmpty
      7  52d2		       45 92		      eor	currentPiece
      8  52d4		       10 03		      bpl	.invalid
      9  52d6		       20 4d fc    .squareEmpty jsr	AddMove
     10  52d9				   .invalid
      0  52d9					      MOVE_TO_X	_DOWN
      1  52d9		       a6 93		      ldx	currentSquare
      0  52db					      MOVE_TO	_DOWN
      1  52db					      SUBROUTINE
      2  52db		       bc 0b f0 	      ldy	ValidSquare+_DOWN,x
      3  52de		       30 0e		      bmi	.invalid
      4  52e0		       b9 79 f0 	      lda	Board,y
      5  52e3		       85 9f		      sta	capture
      6  52e5		       f0 04		      beq	.squareEmpty
      7  52e7		       45 92		      eor	currentPiece
      8  52e9		       10 03		      bpl	.invalid
      9  52eb		       20 4d fc    .squareEmpty jsr	AddMove
     10  52ee				   .invalid
      0  52ee					      MOVE_TO_X	_DOWN+_RIGHT
      1  52ee		       a6 93		      ldx	currentSquare
      0  52f0					      MOVE_TO	_DOWN+_RIGHT
      1  52f0					      SUBROUTINE
      2  52f0		       bc 0c f0 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  52f3		       30 0e		      bmi	.invalid
      4  52f5		       b9 79 f0 	      lda	Board,y
      5  52f8		       85 9f		      sta	capture
      6  52fa		       f0 04		      beq	.squareEmpty
      7  52fc		       45 92		      eor	currentPiece
      8  52fe		       10 03		      bpl	.invalid
      9  5300		       20 4d fc    .squareEmpty jsr	AddMove
     10  5303				   .invalid
      0  5303					      MOVE_TO_X	_RIGHT
      1  5303		       a6 93		      ldx	currentSquare
      0  5305					      MOVE_TO	_RIGHT
      1  5305					      SUBROUTINE
      2  5305		       bc 16 f0 	      ldy	ValidSquare+_RIGHT,x
      3  5308		       30 0e		      bmi	.invalid
      4  530a		       b9 79 f0 	      lda	Board,y
      5  530d		       85 9f		      sta	capture
      6  530f		       f0 04		      beq	.squareEmpty
      7  5311		       45 92		      eor	currentPiece
      8  5313		       10 03		      bpl	.invalid
      9  5315		       20 4d fc    .squareEmpty jsr	AddMove
     10  5318				   .invalid
      0  5318					      MOVE_TO_X	_UP+_RIGHT
      1  5318		       a6 93		      ldx	currentSquare
      0  531a					      MOVE_TO	_UP+_RIGHT
      1  531a					      SUBROUTINE
      2  531a		       bc 20 f0 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  531d		       30 0e		      bmi	.invalid
      4  531f		       b9 79 f0 	      lda	Board,y
      5  5322		       85 9f		      sta	capture
      6  5324		       f0 04		      beq	.squareEmpty
      7  5326		       45 92		      eor	currentPiece
      8  5328		       10 03		      bpl	.invalid
      9  532a		       20 4d fc    .squareEmpty jsr	AddMove
     10  532d				   .invalid
      0  532d					      MOVE_TO_X	_UP
      1  532d		       a6 93		      ldx	currentSquare
      0  532f					      MOVE_TO	_UP
      1  532f					      SUBROUTINE
      2  532f		       bc 1f f0 	      ldy	ValidSquare+_UP,x
      3  5332		       30 0e		      bmi	.invalid
      4  5334		       b9 79 f0 	      lda	Board,y
      5  5337		       85 9f		      sta	capture
      6  5339		       f0 04		      beq	.squareEmpty
      7  533b		       45 92		      eor	currentPiece
      8  533d		       10 03		      bpl	.invalid
      9  533f		       20 4d fc    .squareEmpty jsr	AddMove
     10  5342				   .invalid
      0  5342					      MOVE_TO_X	_UP+_LEFT
      1  5342		       a6 93		      ldx	currentSquare
      0  5344					      MOVE_TO	_UP+_LEFT
      1  5344					      SUBROUTINE
      2  5344		       bc 1e f0 	      ldy	ValidSquare+_UP+_LEFT,x
      3  5347		       30 0e		      bmi	.invalid
      4  5349		       b9 79 f0 	      lda	Board,y
      5  534c		       85 9f		      sta	capture
      6  534e		       f0 04		      beq	.squareEmpty
      7  5350		       45 92		      eor	currentPiece
      8  5352		       10 03		      bpl	.invalid
      9  5354		       20 4d fc    .squareEmpty jsr	AddMove
     10  5357				   .invalid
      0  5357					      MOVE_TO_X	_LEFT
      1  5357		       a6 93		      ldx	currentSquare
      0  5359					      MOVE_TO	_LEFT
      1  5359					      SUBROUTINE
      2  5359		       bc 14 f0 	      ldy	ValidSquare+_LEFT,x
      3  535c		       30 0e		      bmi	.invalid
      4  535e		       b9 79 f0 	      lda	Board,y
      5  5361		       85 9f		      sta	capture
      6  5363		       f0 04		      beq	.squareEmpty
      7  5365		       45 92		      eor	currentPiece
      8  5367		       10 03		      bpl	.invalid
      9  5369		       20 4d fc    .squareEmpty jsr	AddMove
     10  536c				   .invalid
     86  536c
     87  536c							;IF CASTLING_ENABLED
     88  536c
     89  536c		       24 92		      bit	currentPiece
     90  536e		       70 41		      bvs	.exit	; king has moved, so no castling
     91  5370
      0  5370					      CASTLE	KINGSIDE
      1  5370
      2  5370
      3  5370		       a6 93		      ldx	currentSquare
      4  5372		       bd 7c f0 	      lda	Board+KINGSIDE,x
      5  5375		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  5377		       c9 05		      cmp	#ROOK
      7  5379		       d0 14		      bne	.noCastle
      8  537b
      9  537b
     10  537b
     11  537b
     12  537b				  -	      IF	KINGSIDE = QUEENSIDE
     13  537b				  -	      lda	Board-3,x
     14  537b				  -	      ora	Board-2,x
     15  537b				  -	      ora	Board-1,x
     16  537b				  -	      bne	.noCastle
     17  537b				  -
     18  537b					      ENDIF
     19  537b
     20  537b					      IF	KINGSIDE = KINGSIDE
     21  537b		       bd 7b f0 	      lda	Board+2,x
     22  537e		       1d 7a f0 	      ora	Board+1,x
     23  5381		       d0 0c		      bne	.noCastle
     24  5383					      ENDIF
     25  5383
     26  5383
     27  5383
     28  5383
     29  5383
     30  5383
     31  5383
     32  5383
     33  5383		       a5 92		      lda	currentPiece
     34  5385		       09 10		      ora	#FLAG_CASTLE
     35  5387		       85 92		      sta	currentPiece
     36  5389
     37  5389					      IF	KINGSIDE = KINGSIDE
     38  5389		       bc 17 f0 	      ldy	ValidSquare+2,x
     39  538c					      ENDIF
     40  538c
     41  538c				  -	      IF	KINGSIDE = QUEENSIDE
     42  538c				  -	      ldy	ValidSquare-2,x
     43  538c					      ENDIF
     44  538c
     45  538c		       20 4d fc 	      jsr	AddMove
     46  538f
     47  538f				   .noCastle
      0  538f					      CASTLE	QUEENSIDE
      1  538f
      2  538f
      3  538f		       a6 93		      ldx	currentSquare
      4  5391		       bd 75 f0 	      lda	Board+QUEENSIDE,x
      5  5394		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  5396		       c9 05		      cmp	#ROOK
      7  5398		       d0 17		      bne	.noCastle
      8  539a
      9  539a
     10  539a
     11  539a
     12  539a					      IF	QUEENSIDE = QUEENSIDE
     13  539a		       bd 76 f0 	      lda	Board-3,x
     14  539d		       1d 77 f0 	      ora	Board-2,x
     15  53a0		       1d 78 f0 	      ora	Board-1,x
     16  53a3		       d0 0c		      bne	.noCastle
     17  53a5
     18  53a5					      ENDIF
     19  53a5
     20  53a5				  -	      IF	QUEENSIDE = KINGSIDE
     21  53a5				  -	      lda	Board+2,x
     22  53a5				  -	      ora	Board+1,x
     23  53a5				  -	      bne	.noCastle
     24  53a5					      ENDIF
     25  53a5
     26  53a5
     27  53a5
     28  53a5
     29  53a5
     30  53a5
     31  53a5
     32  53a5
     33  53a5		       a5 92		      lda	currentPiece
     34  53a7		       09 10		      ora	#FLAG_CASTLE
     35  53a9		       85 92		      sta	currentPiece
     36  53ab
     37  53ab				  -	      IF	QUEENSIDE = KINGSIDE
     38  53ab				  -	      ldy	ValidSquare+2,x
     39  53ab					      ENDIF
     40  53ab
     41  53ab					      IF	QUEENSIDE = QUEENSIDE
     42  53ab		       bc 13 f0 	      ldy	ValidSquare-2,x
     43  53ae					      ENDIF
     44  53ae
     45  53ae		       20 4d fc 	      jsr	AddMove
     46  53b1
     47  53b1				   .noCastle
     94  53b1
     95  53b1							;ENDIF
     96  53b1
     97  53b1		       4c 02 f9    .exit      jmp	MoveReturn
     98  53b4
     99  53b4							;---------------------------------------------------------------------------------------------------
    100  53b4							; EOF
------- FILE Handler_BANK1.asm
    106  53b4
    107  53b4
    108  53b4							;---------------------------------------------------------------------------------------------------
    109  53b4
      0  53b4					      CHECK_HALF_BANK_SIZE	"HANDLER_BANK1 -- 1K"
      1  53b4
      2  53b4
      3  53b4		       03 b4	   .TEMP      =	* - BANK_START
 HANDLER_BANK1 -- 1K (1K) SIZE =  $3b4 , FREE= $4c
      4  53b4					      ECHO	"HANDLER_BANK1 -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  53b4				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  53b4				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  53b4				  -	      ERR
      8  53b4					      endif
    111  53b4
    112  53b4
    113  53b4							; There is space here (1K) for use as ROM
    114  53b4							; but NOT when the above bank is switched in as RAM, of course!
    115  53b4
    116  53b4
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  53b4					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  53b4					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  53b4					      LIST	ON
      0  53b4					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  53b4				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  53b4				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  53b4				   TEMPORARY_VAR SET	Overlay
      4  53b4				   TEMPORARY_OFFSET SET	0
      5  53b4				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  53b4				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      7  53b4					      SUBROUTINE
      3  53b4		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  53cc		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53e4		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  53fc					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  53fc					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5400					      LIST	ON
      0  5400					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  5400				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5400				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  5400				   TEMPORARY_VAR SET	Overlay
      4  5400				   TEMPORARY_OFFSET SET	0
      5  5400				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5400				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      7  5400					      SUBROUTINE
      3  5400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5418		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5448					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5448					      LIST	ON
      0  5448					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  5448				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5448				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  5448				   TEMPORARY_VAR SET	Overlay
      4  5448				   TEMPORARY_OFFSET SET	0
      5  5448				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5448				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      7  5448					      SUBROUTINE
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  5478		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  5490					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5490					      LIST	ON
      0  5490					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  5490				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5490				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  5490				   TEMPORARY_VAR SET	Overlay
      4  5490				   TEMPORARY_OFFSET SET	0
      5  5490				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5490				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      7  5490					      SUBROUTINE
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  54c0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  54d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5500					      LIST	ON
      0  5500					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  5500				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  5500				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  5500				   TEMPORARY_VAR SET	Overlay
      4  5500				   TEMPORARY_OFFSET SET	0
      5  5500				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5500				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      7  5500					      SUBROUTINE
      3  5500		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  5548					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5548					      LIST	ON
      0  5548					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  5548				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  5548				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  5548				   TEMPORARY_VAR SET	Overlay
      4  5548				   TEMPORARY_OFFSET SET	0
      5  5548				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5548				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      7  5548					      SUBROUTINE
      3  5548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5560		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  5590					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5590					      LIST	ON
      0  5590					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  5590				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  5590				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  5590				   TEMPORARY_VAR SET	Overlay
      4  5590				   TEMPORARY_OFFSET SET	0
      5  5590				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5590				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      7  5590					      SUBROUTINE
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  55c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  55d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5600					      LIST	ON
      0  5600					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  5600				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  5600				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  5600				   TEMPORARY_VAR SET	Overlay
      4  5600				   TEMPORARY_OFFSET SET	0
      5  5600				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5600				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      7  5600					      SUBROUTINE
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5630		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
    125  5648
    126  5648							;---------------------------------------------------------------------------------------------------
    127  5648
      0  5648					      CHECK_BANK_SIZE	"HANDLER_BANK_1 -- full 2K"
      1  5648		       06 48	   .TEMP      =	* - BANK_START
 HANDLER_BANK_1 -- full 2K (2K) SIZE =  $648 , FREE= $1b8
      2  5648					      ECHO	"HANDLER_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5648				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5648				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5648				  -	      ERR
      6  5648					      endif
    129  5648
    130  5648							;---------------------------------------------------------------------------------------------------
    131  5648							; EOF
------- FILE ./chess.asm
------- FILE ply.asm LEVEL 2 PASS 5
      0  5648					      include	"ply.asm"
      1  5648							; Copyright (C)2020 Andrew Davie
      2  5648							; andrew@taswegian.com
      3  5648
      4  5648
      5  5648							;---------------------------------------------------------------------------------------------------
      6  5648							; Define the RAM banks
      7  5648							; A "PLY" bank represents all the data required on any single ply of the search tree.
      8  5648							; The banks are organised sequentially, MAX_PLY of them starting at RAMBANK_PLY
      9  5648							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     10  5648							; they act as independant switchable banks usable for data on each ply during the search.
     11  5648							; A ply will hold the move list for that position
     12  5648
     13  5648
     14  5648		       00 0a	   MAX_PLY    =	10
      0  5648					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  5648
      2  5648
      3  5648
      4 U2400 ????				      SEG.U	PLY
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	RAM_3E
      7 U2400				   BANK_START SET	*
      8 U2400				   RAMBANK_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U2400					      REPEAT	MAX_PLY-1
      0 U2400					      NEWRAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400
      3 U2400
      4 U4800 ????				      SEG.U	.DUMMY_PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	RAM_3E
      7 U2800				   BANK_START SET	*
      8 U2800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U2800					      REPEND
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U2800					      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	RAM_3E
      7 U2c00				   BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U2c00					      REPEND
      0 U2c00					      NEWRAMBANK	.DUMMY_PLY
      1 U2c00
      2 U2c00
      3 U2c00
      4 U2c00					      SEG.U	.DUMMY_PLY
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	RAM_3E
      7 U3000				   BANK_START SET	*
      8 U3000				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U3000					      REPEND
      0 U3000					      NEWRAMBANK	.DUMMY_PLY
      1 U3000
      2 U3000
      3 U3000
      4 U3000					      SEG.U	.DUMMY_PLY
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	RAM_3E
      7 U3400				   BANK_START SET	*
      8 U3400				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U3400					      REPEND
      0 U3400					      NEWRAMBANK	.DUMMY_PLY
      1 U3400
      2 U3400
      3 U3400
      4 U3400					      SEG.U	.DUMMY_PLY
      5 U3800					      ORG	ORIGIN_RAM
      6 U3800					      RORG	RAM_3E
      7 U3800				   BANK_START SET	*
      8 U3800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U3800					      REPEND
      0 U3800					      NEWRAMBANK	.DUMMY_PLY
      1 U3800
      2 U3800
      3 U3800
      4 U3800					      SEG.U	.DUMMY_PLY
      5 U3c00					      ORG	ORIGIN_RAM
      6 U3c00					      RORG	RAM_3E
      7 U3c00				   BANK_START SET	*
      8 U3c00				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U3c00					      REPEND
      0 U3c00					      NEWRAMBANK	.DUMMY_PLY
      1 U3c00
      2 U3c00
      3 U3c00
      4 U3c00					      SEG.U	.DUMMY_PLY
      5 U4000					      ORG	ORIGIN_RAM
      6 U4000					      RORG	RAM_3E
      7 U4000				   BANK_START SET	*
      8 U4000				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U4000					      REPEND
      0 U4000					      NEWRAMBANK	.DUMMY_PLY
      1 U4000
      2 U4000
      3 U4000
      4 U4000					      SEG.U	.DUMMY_PLY
      5 U4400					      ORG	ORIGIN_RAM
      6 U4400					      RORG	RAM_3E
      7 U4400				   BANK_START SET	*
      8 U4400				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     16 U4400					      REPEND
      0 U4400					      NEWRAMBANK	.DUMMY_PLY
      1 U4400
      2 U4400
      3 U4400
      4 U4400					      SEG.U	.DUMMY_PLY
      5 U4800					      ORG	ORIGIN_RAM
      6 U4800					      RORG	RAM_3E
      7 U4800				   BANK_START SET	*
      8 U4800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     18 U4800					      REPEND
     19 U4800
     20 U4800		       00 13	   MAX_PLY_DEPTH_BANK =	MAX_PLY + RAMBANK_PLY
     21 U4800
     22 U4800							;---------------------------------------------------------------------------------------------------
     23 U4800							; and now the ROM shadow - this is copied to ALL of the RAM ply banks
     24 U4800
      0 U4800					      NEWBANK	BANK_PLY	; ROM SHADOW
      1  5ad0 ????				      SEG	BANK_PLY
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   BANK_PLY   SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	BANK_PLY
     26  5800
     27  5800							;---------------------------------------------------------------------------------------------------
     28  5800							; The piece-lists
     29  5800							; ONLY the very first bank piecelist is used - all other banks switch to the first for
     30  5800							; piecelist usage. Note that this initialisation (below) comes from the shadow ROM/RAM copy
     31  5800							; but this needs to be initialised programatically on new game.
     32  5800
     33  5800							; We have TWO piecelists, in different banks
     34  5800							; WHITE pieces in bank BANK_PLY
     35  5800							; BLACK pieces in bank BANK_PLY+1
     36  5800
      0  5800					      VARIABLE	SavedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0  5800					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  5800					      LIST	ON
      2  5800		       00 00	   SavedEvaluation ds	2
     38  5802
     39  5802							;---------------------------------------------------------------------------------------------------
     40  5802
     41  5802		       00 46	   MAX_MOVES  =	70
     42  5802
      0  5802					      VARIABLE	MoveFrom, MAX_MOVES
      0  5802					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  5802					      LIST	ON
      2  5802		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0  5848					      VARIABLE	MoveTo, MAX_MOVES
      0  5848					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  5848					      LIST	ON
      2  5848		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0  588e					      VARIABLE	MovePiece, MAX_MOVES
      0  588e					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  588e					      LIST	ON
      2  588e		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0  58d4					      VARIABLE	MoveCapture, MAX_MOVES
      0  58d4					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  5900					      LIST	ON
      2  5900		       00 00 00 00*MoveCapture ds	MAX_MOVES
      0  5946					      VARIABLE	moveCounter, 1
      0  5946					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  5946					      LIST	ON
      2  5946		       00	   moveCounter ds	1
     48  5947
     49  5947							;---------------------------------------------------------------------------------------------------
     50  5947
     51  5947							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     52  5947							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     53  5947
      0  5947					      VARIABLE	enPassantSquare, 1
      0  5947					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  5947					      LIST	ON
      2  5947		       00	   enPassantSquare ds	1
      0  5948					      VARIABLE	capturedPiece, 1
      0  5948					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  5948					      LIST	ON
      2  5948		       00	   capturedPiece ds	1
      0  5949					      VARIABLE	originalPiece, 1
      0  5949					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  5949					      LIST	ON
      2  5949		       00	   originalPiece ds	1
      0  594a					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0  594a					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  594a					      LIST	ON
      2  594a		       00	   secondaryPiece ds	1
      0  594b					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0  594b					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  594b					      LIST	ON
      2  594b		       00	   secondarySquare ds	1
      0  594c					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0  594c					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  594c					      LIST	ON
      2  594c		       00	   secondaryBlank ds	1
      0  594d					      VARIABLE	quiescentEnabled, 1	; all child nodes to quiesce
      0  594d					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  594d					      LIST	ON
      2  594d		       00	   quiescentEnabled ds	1
      0  594e					      VARIABLE	captureMove, 1	; previous move was a capture
      0  594e					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  594e					      LIST	ON
      2  594e		       00	   captureMove ds	1
     62  594f
     63  594f							;---------------------------------------------------------------------------------------------------
     64  594f							; Move tables hold piece moves for this current ply
     65  594f
      0  594f					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0  594f					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  594f					      LIST	ON
      2  594f		       00	   moveIndex  ds	1
      0  5950					      VARIABLE	movePtr, 1
      0  5950					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  5950					      LIST	ON
      2  5950		       00	   movePtr    ds	1
      0  5951					      VARIABLE	bestMove, 1
      0  5951					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  5951					      LIST	ON
      2  5951		       00	   bestMove   ds	1
      0  5952					      VARIABLE	alpha, 2
      0  5952					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  5952					      LIST	ON
      2  5952		       00 00	   alpha      ds	2
      0  5954					      VARIABLE	beta, 2
      0  5954					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  5954					      LIST	ON
      2  5954		       00 00	   beta       ds	2
      0  5956					      VARIABLE	value, 2
      0  5956					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  5956					      LIST	ON
      2  5956		       00 00	   value      ds	2
     72  5958
     73  5958							;    VARIABLE bestValue, 2
      0  5958					      VARIABLE	depthLeft, 1
      0  5958					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  5958					      LIST	ON
      2  5958		       00	   depthLeft  ds	1
     75  5959							;    VARIABLE bestScore, 2
      0  5959					      VARIABLE	restorePiece, 1
      0  5959					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  5959					      LIST	ON
      2  5959		       00	   restorePiece ds	1
     77  595a
      0  595a					      VARIABLE	statusFlags, 1
      0  595a					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  595a					      LIST	ON
      2  595a		       00	   statusFlags ds	1
     79  595b
     80  595b		       00 80	   STATUS_CHECK =	$80
     81  595b		       00 40	   STATUS_STALEMATE =	$40
     82  595b
     83  595b							;---------------------------------------------------------------------------------------------------
     84  595b
      0  595b					      DEF	InitPieceLists
      1  595b				   BANK_InitPieceLists SET	_CURRENT_BANK
      2  595b				   InitPieceLists
      3  595b				   TEMPORARY_VAR SET	Overlay
      4  595b				   TEMPORARY_OFFSET SET	0
      5  595b				   VAR_BOUNDARY_InitPieceLists SET	TEMPORARY_OFFSET
      6  595b				   FUNCTION_NAME SET	InitPieceLists
      7  595b					      SUBROUTINE
     86  595b					      SUBROUTINE
     87  595b
      0  595b					      REFER	InitialisePieceSquares
      1  595b					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  595b				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  595b					      ENDIF
      0  595b					      VEND	InitPieceLists
      1  595b				  -	      IFNCONST	InitPieceLists
      2  595b				  -	      ECHO	"Incorrect VEND label", InitPieceLists
      3  595b				  -	      ERR
      4  595b					      ENDIF
      5  595b		       00 a5	   VAREND_InitPieceLists =	TEMPORARY_VAR
     90  595b
     91  595b		       a9 ff		      lda	#-1
     92  595d							;sta@RAM SquarePtr ;PieceListPtr
     93  595d
     94  595d							; TODO: move the following as they're called 2x due to double-call of InitPiecLists
     95  595d
     96  595d		       a9 00		      lda	#0
     97  595f		       85 90		      sta	Evaluation
     98  5961		       85 91		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
     99  5963
    100  5963
    101  5963							; General inits that are moved out of FIXED....
    102  5963
    103  5963		       a9 07		      lda	#%111	; 111= quad
    104  5965		       85 44		      sta	NUSIZ0
    105  5967		       85 45		      sta	NUSIZ1	; quad-width
    106  5969
    107  5969		       a9 04		      lda	#%00000100
    108  596b		       85 4a		      sta	CTRLPF
    109  596d		       a9 00		      lda	#BACKGCOL
    110  596f		       85 49		      sta	COLUBK
    111  5971
      0  5971					      PHASE	AI_StartClearBoard
      1  5971		       a9 0d		      lda	#AI_StartClearBoard
      2  5973		       85 8c		      sta	aiState
    113  5975		       60		      rts
    114  5976
    115  5976
    116  5976							;---------------------------------------------------------------------------------------------------
    117  5976
    118  5976				  -	      if	ASSERTS
    119  5976				  -
    120  5976				  -	      DEF	checkPiecesBank
    121  5976				  -	      SUBROUTINE
    122  5976				  -
    123  5976				  -	      REFER	DIAGNOSTIC_checkPiences
    124  5976				  -	      VAR	__x, 1
    125  5976				  -	      VAR	__bank, 1
    126  5976				  -	      VEND	checkPiecesBank
    127  5976				  -
    128  5976				  -			; odd usage - switches between concurrent bank code
    129  5976				  -
    130  5976				  -	      ldx	#15
    131  5976				  -.check     lda	__bank
    132  5976				  -	      sta	SET_BANK_RAM
    133  5976				  -	      ldy	PieceSquare,x
    134  5976				  -	      beq	.nonehere
    135  5976				  -
    136  5976				  -	      stx	__x
    137  5976				  -
    138  5976				  -	      jsr	GetBoard
    139  5976				  -.fail      beq	.fail
    140  5976				  -	      cmp	#-1
    141  5976				  -.fail2     beq	.fail2
    142  5976				  -
    143  5976				  -	      ldx	__x
    144  5976				  -
    145  5976				  -.nonehere  dex
    146  5976				  -	      bpl	.check
    147  5976				  -	      rts
    148  5976				  -
    149  5976					      endif
    150  5976
    151  5976
    152  5976							;---------------------------------------------------------------------------------------------------
    153  5976
    154  5976
    155  5976				   InitPieceList
    156  5976
------- FILE setup_board.asm LEVEL 3 PASS 5
      0  5976					      include	"setup_board.asm"
      1  5976
      2  5976					      if	!TEST_POSITION
      3  5976
      4  5976		       06 19		      .byte.b	WHITE|Q, 25
      5  5978		       04 18		      .byte.b	WHITE|B, 24
      6  597a		       04 1b		      .byte.b	WHITE|B, 27
      7  597c		       05 16		      .byte.b	WHITE|R, 22
      8  597e		       05 1d		      .byte.b	WHITE|R, 29
      9  5980		       03 17		      .byte.b	WHITE|N, 23
     10  5982		       03 1c		      .byte.b	WHITE|N, 28
     11  5984
     12  5984		       01 23		      .byte.b	WHITE|WP, 35
     13  5986		       01 24		      .byte.b	WHITE|WP, 36
     14  5988		       01 22		      .byte.b	WHITE|WP, 34
     15  598a		       01 25		      .byte.b	WHITE|WP, 37
     16  598c		       01 21		      .byte.b	WHITE|WP, 33
     17  598e		       01 26		      .byte.b	WHITE|WP, 38
     18  5990		       01 20		      .byte.b	WHITE|WP, 32
     19  5992		       01 27		      .byte.b	WHITE|WP, 39
     20  5994
     21  5994		       07 1a		      .byte.b	WHITE|K, 26
     22  5996
     23  5996		       86 5f		      .byte.b	BLACK|Q, 95
     24  5998		       84 5e		      .byte.b	BLACK|B, 94
     25  599a		       84 61		      .byte.b	BLACK|B, 97
     26  599c		       85 5c		      .byte.b	BLACK|R, 92
     27  599e		       85 63		      .byte.b	BLACK|R, 99
     28  59a0		       83 5d		      .byte.b	BLACK|N, 93
     29  59a2		       83 62		      .byte.b	BLACK|N, 98
     30  59a4
     31  59a4		       82 55		      .byte.b	BLACK|BP, 85
     32  59a6		       82 56		      .byte.b	BLACK|BP, 86
     33  59a8		       82 54		      .byte.b	BLACK|BP, 84
     34  59aa		       82 57		      .byte.b	BLACK|BP, 87
     35  59ac		       82 53		      .byte.b	BLACK|BP, 83
     36  59ae		       82 58		      .byte.b	BLACK|BP, 88
     37  59b0		       82 52		      .byte.b	BLACK|BP, 82
     38  59b2		       82 59		      .byte.b	BLACK|BP, 89
     39  59b4
     40  59b4		       87 60		      .byte.b	BLACK|K, 96
     41  59b6
     42  59b6		       00		      .byte.b	0	;end
     43  59b7
     44  59b7				  -	      else		; test position...
     45  59b7				  -
     46  59b7				  -	      .byte	WHITE|K, 26
     47  59b7				  -	      .byte	BLACK|Q, 82
     48  59b7				  -	      .byte	BLACK|K, 83
     49  59b7				  -	      .byte	0	;end
     50  59b7				  -
     51  59b7					      endif
------- FILE ply.asm
    158  59b7
    159  59b7
    160  59b7							;---------------------------------------------------------------------------------------------------
    161  59b7
      0  59b7					      DEF	NewPlyInitialise
      1  59b7				   BANK_NewPlyInitialise SET	_CURRENT_BANK
      2  59b7				   NewPlyInitialise
      3  59b7				   TEMPORARY_VAR SET	Overlay
      4  59b7				   TEMPORARY_OFFSET SET	0
      5  59b7				   VAR_BOUNDARY_NewPlyInitialise SET	TEMPORARY_OFFSET
      6  59b7				   FUNCTION_NAME SET	NewPlyInitialise
      7  59b7					      SUBROUTINE
    163  59b7					      SUBROUTINE
    164  59b7
      0  59b7					      REFER	aiFlipBuffers
      1  59b7				  -	      IF	VAREND_aiFlipBuffers > TEMPORARY_VAR
      2  59b7				  -TEMPORARY_VAR SET	VAREND_aiFlipBuffers
      3  59b7					      ENDIF
      0  59b7					      REFER	InitialiseMoveGeneration
      1  59b7				  -	      IF	VAREND_InitialiseMoveGeneration > TEMPORARY_VAR
      2  59b7				  -TEMPORARY_VAR SET	VAREND_InitialiseMoveGeneration
      3  59b7					      ENDIF
      0  59b7					      REFER	negamax
      1  59b7					      IF	VAREND_negamax > TEMPORARY_VAR
      2  59b7				   TEMPORARY_VAR SET	VAREND_negamax
      3  59b7					      ENDIF
      0  59b7					      VEND	NewPlyInitialise
      1  59b7				  -	      IFNCONST	NewPlyInitialise
      2  59b7				  -	      ECHO	"Incorrect VEND label", NewPlyInitialise
      3  59b7				  -	      ERR
      4  59b7					      ENDIF
      5  59b7		       00 ad	   VAREND_NewPlyInitialise =	TEMPORARY_VAR
    169  59b7
    170  59b7							; This MUST be called at the start of a new ply
    171  59b7							; It initialises the movelist to empty
    172  59b7							; x must be preserved
    173  59b7
    174  59b7							; note that 'alpha' and 'beta' are set externally!!
    175  59b7
    176  59b7
    177  59b7		       a9 ff		      lda	#-1
      0  59b9					      sta@PLY	moveIndex	; no valid moves
      1  59b9		       8d 4f f5 	      sta	[RAM]+moveIndex
      0  59bc					      sta@PLY	bestMove
      1  59bc		       8d 51 f5 	      sta	[RAM]+bestMove
    180  59bf
    181  59bf		       a5 94		      lda	enPassantPawn	; flag/square from last actual move made
      0  59c1					      sta@RAM	enPassantSquare	; used for backtracking, to reset the flag
      1  59c1		       8d 47 f5 	      sta	[RAM]+enPassantSquare
    183  59c4
    184  59c4
    185  59c4							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    186  59c4							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    187  59c4							; start of each new ply.
    188  59c4
    189  59c4		       a5 90		      lda	Evaluation
      0  59c6					      sta@RAM	SavedEvaluation
      1  59c6		       8d 00 f4 	      sta	[RAM]+SavedEvaluation
    191  59c9		       a5 91		      lda	Evaluation+1
      0  59cb					      sta@RAM	SavedEvaluation+1
      1  59cb		       8d 01 f4 	      sta	[RAM]+SavedEvaluation+1
    193  59ce
    194  59ce		       60		      rts
    195  59cf
    196  59cf
    197  59cf							;---------------------------------------------------------------------------------------------------
    198  59cf
      0  59cf					      DEF	CheckMoveListFromSquare
      1  59cf				   BANK_CheckMoveListFromSquare SET	_CURRENT_BANK
      2  59cf				   CheckMoveListFromSquare
      3  59cf				   TEMPORARY_VAR SET	Overlay
      4  59cf				   TEMPORARY_OFFSET SET	0
      5  59cf				   VAR_BOUNDARY_CheckMoveListFromSquare SET	TEMPORARY_OFFSET
      6  59cf				   FUNCTION_NAME SET	CheckMoveListFromSquare
      7  59cf					      SUBROUTINE
    200  59cf					      SUBROUTINE
    201  59cf
      0  59cf					      REFER	IsValidP_MoveFromSquare
      1  59cf				  -	      IF	VAREND_IsValidP_MoveFromSquare > TEMPORARY_VAR
      2  59cf				  -TEMPORARY_VAR SET	VAREND_IsValidP_MoveFromSquare
      3  59cf					      ENDIF
      0  59cf					      VEND	CheckMoveListFromSquare
      1  59cf				  -	      IFNCONST	CheckMoveListFromSquare
      2  59cf				  -	      ECHO	"Incorrect VEND label", CheckMoveListFromSquare
      3  59cf				  -	      ERR
      4  59cf					      ENDIF
      5  59cf		       00 a2	   VAREND_CheckMoveListFromSquare =	TEMPORARY_VAR
    204  59cf
    205  59cf							; X12 in A
    206  59cf							; y = -1 on return if NOT FOUND
    207  59cf
      0  59cf					      ldy@RAM	moveIndex
      1  59cf		       ac 4f f1 	      ldy	moveIndex
    209  59d2		       30 08		      bmi	.exit
    210  59d4
    211  59d4		       d9 02 f0    .scan      cmp	MoveFrom,y
    212  59d7		       f0 04		      beq	.scanned
    213  59d9		       88		      dey
    214  59da		       10 f8		      bpl	.scan
    215  59dc		       60	   .exit      rts
    216  59dd
      0  59dd				   .scanned   lda@PLY	MovePiece,y
      1  59dd		       b9 8e f0 	      lda	MovePiece,y
    218  59e0		       85 98		      sta	fromPiece
    219  59e2		       60		      rts
    220  59e3
    221  59e3
    222  59e3							;---------------------------------------------------------------------------------------------------
    223  59e3
      0  59e3					      DEF	GetPieceGivenFromToSquares
      1  59e3				   BANK_GetPieceGivenFromToSquares SET	_CURRENT_BANK
      2  59e3				   GetPieceGivenFromToSquares
      3  59e3				   TEMPORARY_VAR SET	Overlay
      4  59e3				   TEMPORARY_OFFSET SET	0
      5  59e3				   VAR_BOUNDARY_GetPieceGivenFromToSquares SET	TEMPORARY_OFFSET
      6  59e3				   FUNCTION_NAME SET	GetPieceGivenFromToSquares
      7  59e3					      SUBROUTINE
    225  59e3					      SUBROUTINE
    226  59e3
      0  59e3					      REFER	GetPiece
      1  59e3				  -	      IF	VAREND_GetPiece > TEMPORARY_VAR
      2  59e3				  -TEMPORARY_VAR SET	VAREND_GetPiece
      3  59e3					      ENDIF
      0  59e3					      VEND	GetPieceGivenFromToSquares
      1  59e3				  -	      IFNCONST	GetPieceGivenFromToSquares
      2  59e3				  -	      ECHO	"Incorrect VEND label", GetPieceGivenFromToSquares
      3  59e3				  -	      ERR
      4  59e3					      ENDIF
      5  59e3		       00 a2	   VAREND_GetPieceGivenFromToSquares =	TEMPORARY_VAR
    229  59e3
    230  59e3							; returns piece in A+fromPiece
    231  59e3							; or Y=-1 if not found
    232  59e3
    233  59e3							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
    234  59e3							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
    235  59e3							; This fixes the move with/without castle flag
    236  59e3
      0  59e3					      ldy@RAM	moveIndex
      1  59e3		       ac 4f f1 	      ldy	moveIndex
    238  59e6		       30 11		      bmi	.fail	; shouldn't happen
    239  59e8		       a5 85	   .scan      lda	fromX12
    240  59ea		       d9 02 f0 	      cmp	MoveFrom,y
    241  59ed		       d0 07		      bne	.next
    242  59ef		       a5 86		      lda	toX12
    243  59f1		       d9 48 f0 	      cmp	MoveTo,y
    244  59f4		       f0 04		      beq	.found
    245  59f6		       88	   .next      dey
    246  59f7		       10 ef		      bpl	.scan
    247  59f9		       60	   .fail      rts
    248  59fa
      0  59fa				   .found     lda@PLY	MovePiece,y
      1  59fa		       b9 8e f0 	      lda	MovePiece,y
    250  59fd		       85 98		      sta	fromPiece
    251  59ff		       60		      rts
    252  5a00
    253  5a00
    254  5a00
    255  5a00							;---------------------------------------------------------------------------------------------------
    256  5a00
    257  5a00				  -	      if	0
    258  5a00				  -	      DEF	CheckMoveListToSquare
    259  5a00				  -	      SUBROUTINE
    260  5a00				  -
    261  5a00				  -	      VEND	CheckMoveListToSquare
    262  5a00				  -
    263  5a00				  -			; y = -1 on return if NOT FOUND
    264  5a00				  -
    265  5a00				  -	      ldy@RAM	moveIndex
    266  5a00				  -	      bmi	.exit
    267  5a00				  -.scan      lda	toX12
    268  5a00				  -	      cmp	MoveTo,y
    269  5a00				  -	      bne	.xscanned
    270  5a00				  -	      lda@PLY	MoveFrom,y
    271  5a00				  -	      cmp	fromX12
    272  5a00				  -	      beq	.exit
    273  5a00				  -.xscanned  dey
    274  5a00				  -	      bpl	.scan
    275  5a00				  -
    276  5a00				  -.exit      rts
    277  5a00					      endif
    278  5a00
    279  5a00
    280  5a00							;---------------------------------------------------------------------------------------------------
    281  5a00
      0  5a00					      DEF	selectmove
      1  5a00				   BANK_selectmove SET	_CURRENT_BANK
      2  5a00				   selectmove
      3  5a00				   TEMPORARY_VAR SET	Overlay
      4  5a00				   TEMPORARY_OFFSET SET	0
      5  5a00				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      6  5a00				   FUNCTION_NAME SET	selectmove
      7  5a00					      SUBROUTINE
    283  5a00					      SUBROUTINE
    284  5a00
      0  5a00					      COMMON_VARS_ALPHABETA
      1  5a00
      0  5a00					      VAR	__bestMove, 1
      1  5a00		       00 a2	   __bestMove =	TEMPORARY_VAR
      2  5a00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a00
      4  5a00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a00					      ENDIF
      8  5a00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a00				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5a00				  -	      ERR
     11  5a00					      ENDIF
     12  5a00					      LIST	ON
      0  5a00					      VAR	__bestScore, 2
      1  5a00		       00 a3	   __bestScore =	TEMPORARY_VAR
      2  5a00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a00
      4  5a00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a00					      ENDIF
      8  5a00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a00				  -	      ECHO	"Temporary Variable", __bestScore, "overflow!"
     10  5a00				  -	      ERR
     11  5a00					      ENDIF
     12  5a00					      LIST	ON
      0  5a00					      VAR	__alpha, 2
      1  5a00		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  5a00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a00
      4  5a00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a00					      ENDIF
      8  5a00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a00				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5a00				  -	      ERR
     11  5a00					      ENDIF
     12  5a00					      LIST	ON
      0  5a00					      VAR	__beta, 2
      1  5a00		       00 a7	   __beta     =	TEMPORARY_VAR
      2  5a00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a00
      4  5a00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a00					      ENDIF
      8  5a00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a00				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5a00				  -	      ERR
     11  5a00					      ENDIF
     12  5a00					      LIST	ON
      0  5a00					      VAR	__negamax, 2
      1  5a00		       00 a9	   __negamax  =	TEMPORARY_VAR
      2  5a00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a00
      4  5a00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a00					      ENDIF
      8  5a00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a00				  -	      ECHO	"Temporary Variable", __negamax, "overflow!"
     10  5a00				  -	      ERR
     11  5a00					      ENDIF
     12  5a00					      LIST	ON
      0  5a00					      VAR	__value, 2
      1  5a00		       00 ab	   __value    =	TEMPORARY_VAR
      2  5a00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a00
      4  5a00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a00					      ENDIF
      8  5a00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a00				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5a00				  -	      ERR
     11  5a00					      ENDIF
     12  5a00					      LIST	ON
      8  5a00
      0  5a00					      REFER	aiComputerMove
      1  5a00				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  5a00				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  5a00					      ENDIF
      0  5a00					      VEND	selectmove
      1  5a00				  -	      IFNCONST	selectmove
      2  5a00				  -	      ECHO	"Incorrect VEND label", selectmove
      3  5a00				  -	      ERR
      4  5a00					      ENDIF
      5  5a00		       00 ad	   VAREND_selectmove =	TEMPORARY_VAR
    288  5a00
    289  5a00							; RAM bank already switched in!!!
    290  5a00
    291  5a00				  -	      IF	DIAGNOSTICS
    292  5a00				  -	      lda	#0
    293  5a00				  -	      sta	positionCount
    294  5a00				  -	      sta	positionCount+1
    295  5a00				  -	      sta	positionCount+2
    296  5a00				  -
    297  5a00				  -	      sta	maxPly
    298  5a00					      ENDIF
    299  5a00
    300  5a00
    301  5a00							;(* Initial call for Player A's root node *)
    302  5a00							;negamax(rootNode, depth, −∞, +∞, 1)
    303  5a00
    304  5a00
    305  5a00		       a9 ff		      lda	#<INFINITY
    306  5a02		       85 a7		      sta	__beta
    307  5a04		       a9 7f		      lda	#>INFINITY
    308  5a06		       85 a8		      sta	__beta+1
    309  5a08
    310  5a08		       a9 01		      lda	#<-INFINITY
    311  5a0a		       85 a5		      sta	__alpha
    312  5a0c		       a9 80		      lda	#>-INFINITY
    313  5a0e		       85 a6		      sta	__alpha+1	; player tries to maximise
    314  5a10
    315  5a10		       a2 03		      ldx	#SEARCH_DEPTH	; depth
    316  5a12		       20 ca fe 	      jsr	negamax
    317  5a15
      0  5a15					      ldx@PLY	bestMove
      1  5a15		       ae 51 f1 	      ldx	bestMove
    319  5a18		       30 11		      bmi	.nomove
    320  5a1a
      0  5a1a					      lda@PLY	MoveTo,x
      1  5a1a		       bd 48 f0 	      lda	MoveTo,x
    322  5a1d		       85 86		      sta	toX12
      0  5a1f					      lda@PLY	MoveFrom,x
      1  5a1f		       bd 02 f0 	      lda	MoveFrom,x
    324  5a22		       85 87		      sta	originX12
    325  5a24		       85 85		      sta	fromX12
      0  5a26					      lda@PLY	MovePiece,x
      1  5a26		       bd 8e f0 	      lda	MovePiece,x
    327  5a29		       85 98		      sta	fromPiece
    328  5a2b
    329  5a2b				   .nomove
      0  5a2b					      NEGEVAL
      1  5a2b
      2  5a2b		       38		      sec
      3  5a2c		       a9 00		      lda	#0
      4  5a2e		       e5 90		      sbc	Evaluation
      5  5a30		       85 90		      sta	Evaluation
      6  5a32		       a9 00		      lda	#0
      7  5a34		       e5 91		      sbc	Evaluation+1
      8  5a36		       85 91		      sta	Evaluation+1
    331  5a38		       60		      rts
    332  5a39
    333  5a39
    334  5a39							;---------------------------------------------------------------------------------------------------
    335  5a39
      0  5a39					      DEF	GenCastleMoveForRook
      1  5a39				   BANK_GenCastleMoveForRook SET	_CURRENT_BANK
      2  5a39				   GenCastleMoveForRook
      3  5a39				   TEMPORARY_VAR SET	Overlay
      4  5a39				   TEMPORARY_OFFSET SET	0
      5  5a39				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      6  5a39				   FUNCTION_NAME SET	GenCastleMoveForRook
      7  5a39					      SUBROUTINE
    337  5a39					      SUBROUTINE
    338  5a39
      0  5a39					      REFER	MakeMove
      1  5a39					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  5a39				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  5a39					      ENDIF
      0  5a39					      REFER	CastleFixupDraw
      1  5a39				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  5a39				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  5a39					      ENDIF
      0  5a39					      VEND	GenCastleMoveForRook
      1  5a39				  -	      IFNCONST	GenCastleMoveForRook
      2  5a39				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  5a39				  -	      ERR
      4  5a39					      ENDIF
      5  5a39		       00 af	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    342  5a39
    343  5a39		       18		      clc
    344  5a3a
    345  5a3a		       a5 98		      lda	fromPiece
    346  5a3c		       29 10		      and	#FLAG_CASTLE
    347  5a3e		       f0 2b		      beq	.exit	; NOT involved in castle!
    348  5a40
    349  5a40		       a2 04		      ldx	#4
    350  5a42		       a5 85		      lda	fromX12	; *destination*
    351  5a44		       18	   .findCast  clc
    352  5a45		       ca		      dex
    353  5a46		       30 23		      bmi	.exit
    354  5a48		       dd 7d f2 	      cmp	KSquare,x
    355  5a4b		       d0 f7		      bne	.findCast
    356  5a4d
    357  5a4d		       bd 85 f2 	      lda	RSquareEnd,x
    358  5a50		       85 86		      sta	toX12
      0  5a52					      sta@RAM	secondaryBlank
      1  5a52		       8d 4c f5 	      sta	[RAM]+secondaryBlank
    360  5a55		       bc 81 f2 	      ldy	RSquareStart,x
    361  5a58		       84 85		      sty	fromX12
    362  5a5a		       84 87		      sty	originX12
      0  5a5c					      sty@RAM	secondarySquare
      1  5a5c		       8c 4b f5 	      sty	[RAM]+secondarySquare
    364  5a5f
    365  5a5f		       a5 98		      lda	fromPiece
    366  5a61		       29 80		      and	#128	; colour bit
    367  5a63		       09 05		      ora	#ROOK	; preserve colour
    368  5a65		       85 98		      sta	fromPiece
      0  5a67					      sta@RAM	secondaryPiece
      1  5a67		       8d 4a f5 	      sta	[RAM]+secondaryPiece
    370  5a6a
    371  5a6a		       38		      sec
    372  5a6b		       60	   .exit      rts
    373  5a6c
    374  5a6c
    375  5a6c							;---------------------------------------------------------------------------------------------------
    376  5a6c
      0  5a6c					      DEF	CastleFixupDraw
      1  5a6c				   BANK_CastleFixupDraw SET	_CURRENT_BANK
      2  5a6c				   CastleFixupDraw
      3  5a6c				   TEMPORARY_VAR SET	Overlay
      4  5a6c				   TEMPORARY_OFFSET SET	0
      5  5a6c				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      6  5a6c				   FUNCTION_NAME SET	CastleFixupDraw
      7  5a6c					      SUBROUTINE
    378  5a6c					      SUBROUTINE
    379  5a6c
      0  5a6c					      REFER	SpecialBody
      1  5a6c					      IF	VAREND_SpecialBody > TEMPORARY_VAR
      2  5a6c				   TEMPORARY_VAR SET	VAREND_SpecialBody
      3  5a6c					      ENDIF
      0  5a6c					      VEND	CastleFixupDraw
      1  5a6c				  -	      IFNCONST	CastleFixupDraw
      2  5a6c				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  5a6c				  -	      ERR
      4  5a6c					      ENDIF
      5  5a6c		       00 ad	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    382  5a6c
    383  5a6c							; fixup any castling issues
    384  5a6c							; at this point the king has finished his two-square march
    385  5a6c							; based on the finish square, we determine which rook we're interacting with
    386  5a6c							; and generate a 'move' for the rook to position on the other side of the king
    387  5a6c
    388  5a6c
    389  5a6c					      IF	CASTLING_ENABLED
    390  5a6c		       20 39 f2 	      jsr	GenCastleMoveForRook
    391  5a6f		       b0 07		      bcs	.phase
    392  5a71					      ENDIF
    393  5a71
      0  5a71					      SWAP
      1  5a71		       a5 97		      lda	sideToMove
      2  5a73		       49 83		      eor	#SWAP_SIDE
      3  5a75		       85 97		      sta	sideToMove
    395  5a77		       60		      rts
    396  5a78
    397  5a78				   .phase
    398  5a78
    399  5a78							; in this siutation (castle, rook moving) we do not change sides yet!
    400  5a78
      0  5a78					      PHASE	AI_MoveIsSelected
      1  5a78		       a9 15		      lda	#AI_MoveIsSelected
      2  5a7a		       85 8c		      sta	aiState
    402  5a7c		       60		      rts
    403  5a7d
    404  5a7d
    405  5a7d
    406  5a7d		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    407  5a81		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    408  5a85		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    409  5a89
    410  5a89
    411  5a89							;---------------------------------------------------------------------------------------------------
    412  5a89
    413  5a89
      0  5a89					      DEF	Sort
      1  5a89				   BANK_Sort  SET	_CURRENT_BANK
      2  5a89				   Sort
      3  5a89				   TEMPORARY_VAR SET	Overlay
      4  5a89				   TEMPORARY_OFFSET SET	0
      5  5a89				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      6  5a89				   FUNCTION_NAME SET	Sort
      7  5a89					      SUBROUTINE
    415  5a89					      SUBROUTINE
    416  5a89
      0  5a89					      REFER	aiComputerMove
      1  5a89				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  5a89				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  5a89					      ENDIF
      0  5a89					      VAR	__xs, 1
      1  5a89		       00 a2	   __xs       =	TEMPORARY_VAR
      2  5a89				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a89
      4  5a89				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a89				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a89				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a89					      ENDIF
      8  5a89				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a89				  -	      ECHO	"Temporary Variable", __xs, "overflow!"
     10  5a89				  -	      ERR
     11  5a89					      ENDIF
     12  5a89					      LIST	ON
      0  5a89					      VAR	__swapped, 1
      1  5a89		       00 a3	   __swapped  =	TEMPORARY_VAR
      2  5a89				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a89
      4  5a89				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a89				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a89				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a89					      ENDIF
      8  5a89				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a89				  -	      ECHO	"Temporary Variable", __swapped, "overflow!"
     10  5a89				  -	      ERR
     11  5a89					      ENDIF
     12  5a89					      LIST	ON
      0  5a89					      VAR	__pc, 1
      1  5a89		       00 a4	   __pc       =	TEMPORARY_VAR
      2  5a89				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a89
      4  5a89				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a89				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a89				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a89					      ENDIF
      8  5a89				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a89				  -	      ECHO	"Temporary Variable", __pc, "overflow!"
     10  5a89				  -	      ERR
     11  5a89					      ENDIF
     12  5a89					      LIST	ON
      0  5a89					      VEND	Sort
      1  5a89				  -	      IFNCONST	Sort
      2  5a89				  -	      ECHO	"Incorrect VEND label", Sort
      3  5a89				  -	      ERR
      4  5a89					      ENDIF
      5  5a89		       00 a5	   VAREND_Sort =	TEMPORARY_VAR
    422  5a89
    423  5a89		       a5 95		      lda	currentPly
    424  5a8b		       85 8b		      sta	savedBank
    425  5a8d
      0  5a8d					      ldx@PLY	moveIndex
      1  5a8d		       ae 4f f1 	      ldx	moveIndex
    427  5a90		       30 3d		      bmi	.exit
    428  5a92		       f0 3b		      beq	.exit
    429  5a94
      0  5a94					      ldy@PLY	moveIndex
      1  5a94		       ac 4f f1 	      ldy	moveIndex
    431  5a97		       4c cc f2 	      jmp	.next
    432  5a9a				   .scan
    433  5a9a
      0  5a9a					      lda@PLY	MoveCapture,y
      1  5a9a		       b9 00 f1 	      lda	MoveCapture,y
    435  5a9d		       29 0f		      and	#PIECE_MASK
    436  5a9f		       f0 2b		      beq	.next
    437  5aa1
      0  5aa1					      lda@PLY	MoveTo,x
      1  5aa1		       bd 48 f0 	      lda	MoveTo,x
    439  5aa4		       48		      pha
      0  5aa5					      lda@PLY	MoveFrom,x
      1  5aa5		       bd 02 f0 	      lda	MoveFrom,x
    441  5aa8		       48		      pha
      0  5aa9					      lda@PLY	MovePiece,x
      1  5aa9		       bd 8e f0 	      lda	MovePiece,x
    443  5aac		       48		      pha
    444  5aad
      0  5aad					      lda@PLY	MovePiece,y
      1  5aad		       b9 8e f0 	      lda	MovePiece,y
      0  5ab0					      sta@PLY	MovePiece,x
      1  5ab0		       9d 8e f4 	      sta	[RAM]+MovePiece,x
    447  5ab3		       68		      pla
      0  5ab4					      sta@PLY	MovePiece,y
      1  5ab4		       99 8e f4 	      sta	[RAM]+MovePiece,y
    449  5ab7
      0  5ab7					      lda@PLY	MoveFrom,y
      1  5ab7		       b9 02 f0 	      lda	MoveFrom,y
      0  5aba					      sta@PLY	MoveFrom,x
      1  5aba		       9d 02 f4 	      sta	[RAM]+MoveFrom,x
    452  5abd		       68		      pla
      0  5abe					      sta@PLY	MoveFrom,y
      1  5abe		       99 02 f4 	      sta	[RAM]+MoveFrom,y
    454  5ac1
      0  5ac1					      lda@PLY	MoveTo,y
      1  5ac1		       b9 48 f0 	      lda	MoveTo,y
      0  5ac4					      sta@PLY	MoveTo,x
      1  5ac4		       9d 48 f4 	      sta	[RAM]+MoveTo,x
    457  5ac7		       68		      pla
      0  5ac8					      sta@PLY	MoveTo,y
      1  5ac8		       99 48 f4 	      sta	[RAM]+MoveTo,y
    459  5acb
    460  5acb		       ca		      dex
    461  5acc
    462  5acc		       88	   .next      dey
    463  5acd		       10 cb		      bpl	.scan
    464  5acf		       60	   .exit      rts
    465  5ad0
    466  5ad0
    467  5ad0							;---------------------------------------------------------------------------------------------------
    468  5ad0
      0  5ad0					      CHECK_HALF_BANK_SIZE	"PLY -- 1K"
      1  5ad0
      2  5ad0
      3  5ad0		       02 d0	   .TEMP      =	* - BANK_START
 PLY -- 1K (1K) SIZE =  $2d0 , FREE= $130
      4  5ad0					      ECHO	"PLY -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  5ad0				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  5ad0				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  5ad0				  -	      ERR
      8  5ad0					      endif
    470  5ad0
    471  5ad0							;---------------------------------------------------------------------------------------------------
    472  5ad0
    473  5ad0							; There is space here (1K) for use as ROM
    474  5ad0							; but NOT when the above bank is switched in as RAM, of course!
    475  5ad0
    476  5ad0
    477  5ad0
    478  5ad0
    479  5ad0							;---------------------------------------------------------------------------------------------------
    480  5ad0							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 5
      0  5ad0					      include	"BANK_EVAL.asm"
      0  5ad0					      NEWBANK	EVAL
      1  6330 ????				      SEG	EVAL
      2  6000					      ORG	ORIGIN
      3  6000					      RORG	$F000
      4  6000				   BANK_START SET	*
      5  6000				   EVAL       SET	ORIGIN / 2048
      6  6000				   ORIGIN     SET	ORIGIN + 2048
      7  6000				   _CURRENT_BANK SET	EVAL
      2  6000
      3  6000
      4  6000							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
      5  6000
      6  6000
      7  6000		       00 64	   VALUE_P    =	100
      8  6000		       01 45	   VALUE_N    =	325
      9  6000		       01 5e	   VALUE_B    =	350
     10  6000		       02 3f	   VALUE_R    =	575
     11  6000		       03 84	   VALUE_Q    =	900
     12  6000		       4e 20	   VALUE_K    =	20000
     13  6000
     14  6000
     15  6000					      MAC	vequ
     16  6000				   VALUE_{1}  =	{2}
     17  6000					      ENDM
     18  6000
     19  6000					      MAC	lobyte
     20  6000					      .byte	<{2}
     21  6000					      ENDM
     22  6000
     23  6000					      MAC	hibyte
     24  6000					      .byte	>{2}
     25  6000					      ENDM
     26  6000
     27  6000
     28  6000					      MAC	valuetable
     29  6000					      {1}	BLANK, 0
     30  6000					      {1}	PAWN, 100	; white
     31  6000					      {1}	PAWN, 100	; black
     32  6000					      {1}	KNIGHT, 320
     33  6000					      {1}	BISHOP, 330
     34  6000					      {1}	ROOK, 500
     35  6000					      {1}	QUEEN, 900
     36  6000					      {1}	KING, 20000
     37  6000					      ENDM
     38  6000
     39  6000
      0  6000					      VALUETABLE	VEQU
      0  6000					      VEQU	BLANK, 0
      1  6000		       00 00	   VALUE_BLANK =	0
      0  6000					      VEQU	PAWN, 100
      1  6000		       00 64	   VALUE_PAWN =	100
      0  6000					      VEQU	PAWN, 100
      1  6000		       00 64	   VALUE_PAWN =	100
      0  6000					      VEQU	KNIGHT, 320
      1  6000		       01 40	   VALUE_KNIGHT =	320
      0  6000					      VEQU	BISHOP, 330
      1  6000		       01 4a	   VALUE_BISHOP =	330
      0  6000					      VEQU	ROOK, 500
      1  6000		       01 f4	   VALUE_ROOK =	500
      0  6000					      VEQU	QUEEN, 900
      1  6000		       03 84	   VALUE_QUEEN =	900
      0  6000					      VEQU	KING, 20000
      1  6000		       4e 20	   VALUE_KING =	20000
     41  6000
      0  6000					      DEF	PieceValueLO
      1  6000				   BANK_PieceValueLO SET	_CURRENT_BANK
      2  6000				   PieceValueLO
      3  6000				   TEMPORARY_VAR SET	Overlay
      4  6000				   TEMPORARY_OFFSET SET	0
      5  6000				   VAR_BOUNDARY_PieceValueLO SET	TEMPORARY_OFFSET
      6  6000				   FUNCTION_NAME SET	PieceValueLO
      7  6000					      SUBROUTINE
      0  6000					      VALUETABLE	LOBYTE
      0  6000					      LOBYTE	BLANK, 0
      1  6000		       00		      .byte.b	<0
      0  6001					      LOBYTE	PAWN, 100
      1  6001		       64		      .byte.b	<100
      0  6002					      LOBYTE	PAWN, 100
      1  6002		       64		      .byte.b	<100
      0  6003					      LOBYTE	KNIGHT, 320
      1  6003		       40		      .byte.b	<320
      0  6004					      LOBYTE	BISHOP, 330
      1  6004		       4a		      .byte.b	<330
      0  6005					      LOBYTE	ROOK, 500
      1  6005		       f4		      .byte.b	<500
      0  6006					      LOBYTE	QUEEN, 900
      1  6006		       84		      .byte.b	<900
      0  6007					      LOBYTE	KING, 20000
      1  6007		       20		      .byte.b	<20000
     44  6008
      0  6008					      DEF	PieceValueHI
      1  6008				   BANK_PieceValueHI SET	_CURRENT_BANK
      2  6008				   PieceValueHI
      3  6008				   TEMPORARY_VAR SET	Overlay
      4  6008				   TEMPORARY_OFFSET SET	0
      5  6008				   VAR_BOUNDARY_PieceValueHI SET	TEMPORARY_OFFSET
      6  6008				   FUNCTION_NAME SET	PieceValueHI
      7  6008					      SUBROUTINE
      0  6008					      VALUETABLE	HIBYTE
      0  6008					      HIBYTE	BLANK, 0
      1  6008		       00		      .byte.b	>0
      0  6009					      HIBYTE	PAWN, 100
      1  6009		       00		      .byte.b	>100
      0  600a					      HIBYTE	PAWN, 100
      1  600a		       00		      .byte.b	>100
      0  600b					      HIBYTE	KNIGHT, 320
      1  600b		       01		      .byte.b	>320
      0  600c					      HIBYTE	BISHOP, 330
      1  600c		       01		      .byte.b	>330
      0  600d					      HIBYTE	ROOK, 500
      1  600d		       01		      .byte.b	>500
      0  600e					      HIBYTE	QUEEN, 900
      1  600e		       03		      .byte.b	>900
      0  600f					      HIBYTE	KING, 20000
      1  600f		       4e		      .byte.b	>20000
     47  6010
     48  6010
     49  6010							;---------------------------------------------------------------------------------------------------
     50  6010
      0  6010					      DEF	AddPieceMaterialValue
      1  6010				   BANK_AddPieceMaterialValue SET	_CURRENT_BANK
      2  6010				   AddPieceMaterialValue
      3  6010				   TEMPORARY_VAR SET	Overlay
      4  6010				   TEMPORARY_OFFSET SET	0
      5  6010				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      6  6010				   FUNCTION_NAME SET	AddPieceMaterialValue
      7  6010					      SUBROUTINE
     52  6010					      SUBROUTINE
     53  6010		       20 1b fa 	      jsr	debug
     54  6013
      0  6013					      REFER	AdjustMaterialPositionalValue
      1  6013					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  6013				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  6013					      ENDIF
      0  6013					      REFER	DeletePiece
      1  6013				  -	      IF	VAREND_DeletePiece > TEMPORARY_VAR
      2  6013				  -TEMPORARY_VAR SET	VAREND_DeletePiece
      3  6013					      ENDIF
      0  6013					      REFER	InitialisePieceSquares
      1  6013				  -	      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  6013				  -TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  6013					      ENDIF
      0  6013					      VEND	AddPieceMaterialValue
      1  6013				  -	      IFNCONST	AddPieceMaterialValue
      2  6013				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  6013				  -	      ERR
      4  6013					      ENDIF
      5  6013		       00 b1	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
     59  6013
     60  6013							; Adjust the material score based on the piece
     61  6013							; y = piece type
     62  6013
     63  6013		       18		      clc
     64  6014		       b9 00 f0 	      lda	PieceValueLO,y
     65  6017		       65 90		      adc	Evaluation
     66  6019		       85 90		      sta	Evaluation
     67  601b		       b9 08 f0 	      lda	PieceValueHI,y
     68  601e		       65 91		      adc	Evaluation+1
     69  6020		       85 91		      sta	Evaluation+1
     70  6022		       60		      rts
     71  6023
     72  6023
     73  6023							;---------------------------------------------------------------------------------------------------
     74  6023
      0  6023					      DEF	AddPiecePositionValue
      1  6023				   BANK_AddPiecePositionValue SET	_CURRENT_BANK
      2  6023				   AddPiecePositionValue
      3  6023				   TEMPORARY_VAR SET	Overlay
      4  6023				   TEMPORARY_OFFSET SET	0
      5  6023				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      6  6023				   FUNCTION_NAME SET	AddPiecePositionValue
      7  6023					      SUBROUTINE
     76  6023					      SUBROUTINE
     77  6023
      0  6023					      REFER	AdjustMaterialPositionalValue
      1  6023					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  6023				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  6023					      ENDIF
      0  6023					      REFER	DeletePiece
      1  6023				  -	      IF	VAREND_DeletePiece > TEMPORARY_VAR
      2  6023				  -TEMPORARY_VAR SET	VAREND_DeletePiece
      3  6023					      ENDIF
      0  6023					      VAR	__pval3, 2
      1  6023		       00 b1	   __pval3    =	TEMPORARY_VAR
      2  6023				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6023
      4  6023				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6023				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6023				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6023					      ENDIF
      8  6023				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6023				  -	      ECHO	"Temporary Variable", __pval3, "overflow!"
     10  6023				  -	      ERR
     11  6023					      ENDIF
     12  6023					      LIST	ON
      0  6023					      VEND	AddPiecePositionValue
      1  6023				  -	      IFNCONST	AddPiecePositionValue
      2  6023				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  6023				  -	      ERR
      4  6023					      ENDIF
      5  6023		       00 b3	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
     82  6023
     83  6023
     84  6023							; adds value of square piece is on to the evaluation
     85  6023							; note to do the subtraction as -( -x + val) == x - val
     86  6023
     87  6023							; y = square
     88  6023							; a = piece type (+flags)
     89  6023
     90  6023
     91  6023
     92  6023		       c9 80		      cmp	#128	; black = CS
     93  6025		       29 0f		      and	#PIECE_MASK
     94  6027		       aa		      tax
     95  6028
     96  6028				  -	      IF	ASSERTS
     97  6028				  -.kill      beq	.kill	; can't have a 0-piece. something is wrong.
     98  6028					      ENDIF
     99  6028
    100  6028							; black pieces flip rows so we can use the same eval tables
    101  6028
    102  6028		       98		      tya
    103  6029		       90 04		      bcc	.white
    104  602b		       b9 4c f0 	      lda	FlipSquareIndex,y
    105  602e		       18		      clc
    106  602f				   .white
    107  602f		       7d b0 f0 	      adc	PosValVecLO,x
    108  6032		       85 b1		      sta	__pval3
    109  6034		       bd b8 f0 	      lda	PosValVecHI,x
    110  6037		       69 00		      adc	#0
    111  6039		       85 b2		      sta	__pval3+1
    112  603b
    113  603b		       a0 00		      ldy	#0
    114  603d		       b1 b1		      lda	(__pval3),y
    115  603f		       10 01		      bpl	.pos
    116  6041		       88		      dey		; odd double-usage of y - now it's hi byte
    117  6042				   .pos
    118  6042
    119  6042							;clc
    120  6042		       65 90		      adc	Evaluation
    121  6044		       85 90		      sta	Evaluation
    122  6046		       98		      tya
    123  6047		       65 91		      adc	Evaluation+1
    124  6049		       85 91		      sta	Evaluation+1
    125  604b		       60		      rts
    126  604c
    127  604c
    128  604c							;---------------------------------------------------------------------------------------------------
    129  604c
      0  604c					      ALLOCATE	FlipSquareIndex, 100
      0  604c					      OPTIONAL_PAGEBREAK	"Table", 100
     12  604c					      LIST	ON
      0  604c					      DEF	FlipSquareIndex
      1  604c				   BANK_FlipSquareIndex SET	_CURRENT_BANK
      2  604c				   FlipSquareIndex
      3  604c				   TEMPORARY_VAR SET	Overlay
      4  604c				   TEMPORARY_OFFSET SET	0
      5  604c				   VAR_BOUNDARY_FlipSquareIndex SET	TEMPORARY_OFFSET
      6  604c				   FUNCTION_NAME SET	FlipSquareIndex
      7  604c					      SUBROUTINE
    131  604c
    132  604c		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    133  6056		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    134  6060
    135  6060				   .SQBASE    SET	90
    136  6060					      REPEAT	8
    137  6060		       00 00		      .byte.b	0,0
    138  6060				   .SQX       SET	2
    139  6062					      REPEAT	8
    140  6062		       5c		      .byte.b	(.SQBASE+.SQX)
    141  6062				   .SQX       SET	.SQX + 1
    139  6062					      REPEND
    140  6063		       5d		      .byte.b	(.SQBASE+.SQX)
    141  6063				   .SQX       SET	.SQX + 1
    139  6063					      REPEND
    140  6064		       5e		      .byte.b	(.SQBASE+.SQX)
    141  6064				   .SQX       SET	.SQX + 1
    139  6064					      REPEND
    140  6065		       5f		      .byte.b	(.SQBASE+.SQX)
    141  6065				   .SQX       SET	.SQX + 1
    139  6065					      REPEND
    140  6066		       60		      .byte.b	(.SQBASE+.SQX)
    141  6066				   .SQX       SET	.SQX + 1
    139  6066					      REPEND
    140  6067		       61		      .byte.b	(.SQBASE+.SQX)
    141  6067				   .SQX       SET	.SQX + 1
    139  6067					      REPEND
    140  6068		       62		      .byte.b	(.SQBASE+.SQX)
    141  6068				   .SQX       SET	.SQX + 1
    139  6068					      REPEND
    140  6069		       63		      .byte.b	(.SQBASE+.SQX)
    141  6069				   .SQX       SET	.SQX + 1
    142  606a					      REPEND
    143  606a				   .SQBASE    SET	.SQBASE - 10
    136  606a					      REPEND
    137  606a		       00 00		      .byte.b	0,0
    138  606a				   .SQX       SET	2
    139  606c					      REPEAT	8
    140  606c		       52		      .byte.b	(.SQBASE+.SQX)
    141  606c				   .SQX       SET	.SQX + 1
    139  606c					      REPEND
    140  606d		       53		      .byte.b	(.SQBASE+.SQX)
    141  606d				   .SQX       SET	.SQX + 1
    139  606d					      REPEND
    140  606e		       54		      .byte.b	(.SQBASE+.SQX)
    141  606e				   .SQX       SET	.SQX + 1
    139  606e					      REPEND
    140  606f		       55		      .byte.b	(.SQBASE+.SQX)
    141  606f				   .SQX       SET	.SQX + 1
    139  606f					      REPEND
    140  6070		       56		      .byte.b	(.SQBASE+.SQX)
    141  6070				   .SQX       SET	.SQX + 1
    139  6070					      REPEND
    140  6071		       57		      .byte.b	(.SQBASE+.SQX)
    141  6071				   .SQX       SET	.SQX + 1
    139  6071					      REPEND
    140  6072		       58		      .byte.b	(.SQBASE+.SQX)
    141  6072				   .SQX       SET	.SQX + 1
    139  6072					      REPEND
    140  6073		       59		      .byte.b	(.SQBASE+.SQX)
    141  6073				   .SQX       SET	.SQX + 1
    142  6074					      REPEND
    143  6074				   .SQBASE    SET	.SQBASE - 10
    136  6074					      REPEND
    137  6074		       00 00		      .byte.b	0,0
    138  6074				   .SQX       SET	2
    139  6076					      REPEAT	8
    140  6076		       48		      .byte.b	(.SQBASE+.SQX)
    141  6076				   .SQX       SET	.SQX + 1
    139  6076					      REPEND
    140  6077		       49		      .byte.b	(.SQBASE+.SQX)
    141  6077				   .SQX       SET	.SQX + 1
    139  6077					      REPEND
    140  6078		       4a		      .byte.b	(.SQBASE+.SQX)
    141  6078				   .SQX       SET	.SQX + 1
    139  6078					      REPEND
    140  6079		       4b		      .byte.b	(.SQBASE+.SQX)
    141  6079				   .SQX       SET	.SQX + 1
    139  6079					      REPEND
    140  607a		       4c		      .byte.b	(.SQBASE+.SQX)
    141  607a				   .SQX       SET	.SQX + 1
    139  607a					      REPEND
    140  607b		       4d		      .byte.b	(.SQBASE+.SQX)
    141  607b				   .SQX       SET	.SQX + 1
    139  607b					      REPEND
    140  607c		       4e		      .byte.b	(.SQBASE+.SQX)
    141  607c				   .SQX       SET	.SQX + 1
    139  607c					      REPEND
    140  607d		       4f		      .byte.b	(.SQBASE+.SQX)
    141  607d				   .SQX       SET	.SQX + 1
    142  607e					      REPEND
    143  607e				   .SQBASE    SET	.SQBASE - 10
    136  607e					      REPEND
    137  607e		       00 00		      .byte.b	0,0
    138  607e				   .SQX       SET	2
    139  6080					      REPEAT	8
    140  6080		       3e		      .byte.b	(.SQBASE+.SQX)
    141  6080				   .SQX       SET	.SQX + 1
    139  6080					      REPEND
    140  6081		       3f		      .byte.b	(.SQBASE+.SQX)
    141  6081				   .SQX       SET	.SQX + 1
    139  6081					      REPEND
    140  6082		       40		      .byte.b	(.SQBASE+.SQX)
    141  6082				   .SQX       SET	.SQX + 1
    139  6082					      REPEND
    140  6083		       41		      .byte.b	(.SQBASE+.SQX)
    141  6083				   .SQX       SET	.SQX + 1
    139  6083					      REPEND
    140  6084		       42		      .byte.b	(.SQBASE+.SQX)
    141  6084				   .SQX       SET	.SQX + 1
    139  6084					      REPEND
    140  6085		       43		      .byte.b	(.SQBASE+.SQX)
    141  6085				   .SQX       SET	.SQX + 1
    139  6085					      REPEND
    140  6086		       44		      .byte.b	(.SQBASE+.SQX)
    141  6086				   .SQX       SET	.SQX + 1
    139  6086					      REPEND
    140  6087		       45		      .byte.b	(.SQBASE+.SQX)
    141  6087				   .SQX       SET	.SQX + 1
    142  6088					      REPEND
    143  6088				   .SQBASE    SET	.SQBASE - 10
    136  6088					      REPEND
    137  6088		       00 00		      .byte.b	0,0
    138  6088				   .SQX       SET	2
    139  608a					      REPEAT	8
    140  608a		       34		      .byte.b	(.SQBASE+.SQX)
    141  608a				   .SQX       SET	.SQX + 1
    139  608a					      REPEND
    140  608b		       35		      .byte.b	(.SQBASE+.SQX)
    141  608b				   .SQX       SET	.SQX + 1
    139  608b					      REPEND
    140  608c		       36		      .byte.b	(.SQBASE+.SQX)
    141  608c				   .SQX       SET	.SQX + 1
    139  608c					      REPEND
    140  608d		       37		      .byte.b	(.SQBASE+.SQX)
    141  608d				   .SQX       SET	.SQX + 1
    139  608d					      REPEND
    140  608e		       38		      .byte.b	(.SQBASE+.SQX)
    141  608e				   .SQX       SET	.SQX + 1
    139  608e					      REPEND
    140  608f		       39		      .byte.b	(.SQBASE+.SQX)
    141  608f				   .SQX       SET	.SQX + 1
    139  608f					      REPEND
    140  6090		       3a		      .byte.b	(.SQBASE+.SQX)
    141  6090				   .SQX       SET	.SQX + 1
    139  6090					      REPEND
    140  6091		       3b		      .byte.b	(.SQBASE+.SQX)
    141  6091				   .SQX       SET	.SQX + 1
    142  6092					      REPEND
    143  6092				   .SQBASE    SET	.SQBASE - 10
    136  6092					      REPEND
    137  6092		       00 00		      .byte.b	0,0
    138  6092				   .SQX       SET	2
    139  6094					      REPEAT	8
    140  6094		       2a		      .byte.b	(.SQBASE+.SQX)
    141  6094				   .SQX       SET	.SQX + 1
    139  6094					      REPEND
    140  6095		       2b		      .byte.b	(.SQBASE+.SQX)
    141  6095				   .SQX       SET	.SQX + 1
    139  6095					      REPEND
    140  6096		       2c		      .byte.b	(.SQBASE+.SQX)
    141  6096				   .SQX       SET	.SQX + 1
    139  6096					      REPEND
    140  6097		       2d		      .byte.b	(.SQBASE+.SQX)
    141  6097				   .SQX       SET	.SQX + 1
    139  6097					      REPEND
    140  6098		       2e		      .byte.b	(.SQBASE+.SQX)
    141  6098				   .SQX       SET	.SQX + 1
    139  6098					      REPEND
    140  6099		       2f		      .byte.b	(.SQBASE+.SQX)
    141  6099				   .SQX       SET	.SQX + 1
    139  6099					      REPEND
    140  609a		       30		      .byte.b	(.SQBASE+.SQX)
    141  609a				   .SQX       SET	.SQX + 1
    139  609a					      REPEND
    140  609b		       31		      .byte.b	(.SQBASE+.SQX)
    141  609b				   .SQX       SET	.SQX + 1
    142  609c					      REPEND
    143  609c				   .SQBASE    SET	.SQBASE - 10
    136  609c					      REPEND
    137  609c		       00 00		      .byte.b	0,0
    138  609c				   .SQX       SET	2
    139  609e					      REPEAT	8
    140  609e		       20		      .byte.b	(.SQBASE+.SQX)
    141  609e				   .SQX       SET	.SQX + 1
    139  609e					      REPEND
    140  609f		       21		      .byte.b	(.SQBASE+.SQX)
    141  609f				   .SQX       SET	.SQX + 1
    139  609f					      REPEND
    140  60a0		       22		      .byte.b	(.SQBASE+.SQX)
    141  60a0				   .SQX       SET	.SQX + 1
    139  60a0					      REPEND
    140  60a1		       23		      .byte.b	(.SQBASE+.SQX)
    141  60a1				   .SQX       SET	.SQX + 1
    139  60a1					      REPEND
    140  60a2		       24		      .byte.b	(.SQBASE+.SQX)
    141  60a2				   .SQX       SET	.SQX + 1
    139  60a2					      REPEND
    140  60a3		       25		      .byte.b	(.SQBASE+.SQX)
    141  60a3				   .SQX       SET	.SQX + 1
    139  60a3					      REPEND
    140  60a4		       26		      .byte.b	(.SQBASE+.SQX)
    141  60a4				   .SQX       SET	.SQX + 1
    139  60a4					      REPEND
    140  60a5		       27		      .byte.b	(.SQBASE+.SQX)
    141  60a5				   .SQX       SET	.SQX + 1
    142  60a6					      REPEND
    143  60a6				   .SQBASE    SET	.SQBASE - 10
    136  60a6					      REPEND
    137  60a6		       00 00		      .byte.b	0,0
    138  60a6				   .SQX       SET	2
    139  60a8					      REPEAT	8
    140  60a8		       16		      .byte.b	(.SQBASE+.SQX)
    141  60a8				   .SQX       SET	.SQX + 1
    139  60a8					      REPEND
    140  60a9		       17		      .byte.b	(.SQBASE+.SQX)
    141  60a9				   .SQX       SET	.SQX + 1
    139  60a9					      REPEND
    140  60aa		       18		      .byte.b	(.SQBASE+.SQX)
    141  60aa				   .SQX       SET	.SQX + 1
    139  60aa					      REPEND
    140  60ab		       19		      .byte.b	(.SQBASE+.SQX)
    141  60ab				   .SQX       SET	.SQX + 1
    139  60ab					      REPEND
    140  60ac		       1a		      .byte.b	(.SQBASE+.SQX)
    141  60ac				   .SQX       SET	.SQX + 1
    139  60ac					      REPEND
    140  60ad		       1b		      .byte.b	(.SQBASE+.SQX)
    141  60ad				   .SQX       SET	.SQX + 1
    139  60ad					      REPEND
    140  60ae		       1c		      .byte.b	(.SQBASE+.SQX)
    141  60ae				   .SQX       SET	.SQX + 1
    139  60ae					      REPEND
    140  60af		       1d		      .byte.b	(.SQBASE+.SQX)
    141  60af				   .SQX       SET	.SQX + 1
    142  60b0					      REPEND
    143  60b0				   .SQBASE    SET	.SQBASE - 10
    144  60b0					      REPEND
    145  60b0
    146  60b0
    147  60b0							;---------------------------------------------------------------------------------------------------
    148  60b0							; Vectors to the position value tables for each piece
    149  60b0
    150  60b0					      MAC	posval
    151  60b0					      .byte	0
    152  60b0					      .byte	{1}(PositionalValue_PAWN - 22)
    153  60b0					      .byte	{1}(PositionalValue_PAWN - 22)
    154  60b0					      .byte	{1}(PositionalValue_KNIGHT - 22)
    155  60b0					      .byte	{1}(PositionalValue_BISHOP - 22)
    156  60b0					      .byte	{1}(PositionalValue_ROOK - 22)
    157  60b0					      .byte	{1}(PositionalValue_QUEEN - 22)
    158  60b0					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
    159  60b0					      ENDM
    160  60b0
      0  60b0					      ALLOCATE	PosValVecLO, 8
      0  60b0					      OPTIONAL_PAGEBREAK	"Table", 8
     12  60b0					      LIST	ON
      0  60b0					      DEF	PosValVecLO
      1  60b0				   BANK_PosValVecLO SET	_CURRENT_BANK
      2  60b0				   PosValVecLO
      3  60b0				   TEMPORARY_VAR SET	Overlay
      4  60b0				   TEMPORARY_OFFSET SET	0
      5  60b0				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      6  60b0				   FUNCTION_NAME SET	PosValVecLO
      7  60b0					      SUBROUTINE
      0  60b0					      POSVAL	<
      1  60b0		       00		      .byte.b	0
      2  60b1		       aa		      .byte.b	<(PositionalValue_PAWN - 22)
      3  60b2		       aa		      .byte.b	<(PositionalValue_PAWN - 22)
      4  60b3		       46		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  60b4		       94		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  60b5		       e2		      .byte.b	<(PositionalValue_ROOK - 22)
      7  60b6		       30		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  60b7		       7e		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  60b8					      ALLOCATE	PosValVecHI, 8
      0  60b8					      OPTIONAL_PAGEBREAK	"Table", 8
     12  60b8					      LIST	ON
      0  60b8					      DEF	PosValVecHI
      1  60b8				   BANK_PosValVecHI SET	_CURRENT_BANK
      2  60b8				   PosValVecHI
      3  60b8				   TEMPORARY_VAR SET	Overlay
      4  60b8				   TEMPORARY_OFFSET SET	0
      5  60b8				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      6  60b8				   FUNCTION_NAME SET	PosValVecHI
      7  60b8					      SUBROUTINE
      0  60b8					      POSVAL	>
      1  60b8		       00		      .byte.b	0
      2  60b9		       f0		      .byte.b	>(PositionalValue_PAWN - 22)
      3  60ba		       f0		      .byte.b	>(PositionalValue_PAWN - 22)
      4  60bb		       f1		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  60bc		       f1		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  60bd		       f1		      .byte.b	>(PositionalValue_ROOK - 22)
      7  60be		       f2		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  60bf		       f2		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
    165  60c0
    166  60c0
    167  60c0							;---------------------------------------------------------------------------------------------------
    168  60c0
    169  60c0				   PositionalValue_PAWN
    170  60c0
    171  60c0		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 0, 0, 0	; 20-29
    172  60c8		       00 00 05 0a*	      .byte.b	0,0, 5, 10, 10,-20,-20, 10, 10, 5	; 30-
    173  60d2		       00 00 05 fb*	      .byte.b	0,0, 5, -5,-10, 0, 0,-10, -5, 5	; 40-
    174  60dc		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 20, 20, 0, 0, 0	; 50-
    175  60e6		       00 00 05 0f*	      .byte.b	0,0, 5, 15, 20, 35, 35, 20, 15, 5	; 60-
    176  60f0		       00 00 0a 14*	      .byte.b	0,0, 10, 20, 30, 40, 40, 30, 20, 10	; 70-
    177  60fa		       00 00 32 32*	      .byte.b	0,0, 50, 50, 60, 70, 70, 60, 50, 50	; 80-
    178  6104		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 0, 0, 0, 0, 0	; 90-
    179  610e
    180  610e				   PositionalValue_PAWN_BLACK
    181  610e
    182  610e		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 0, 0, 0	; 20-29
    183  6116		       00 00 32 32*	      .byte.b	0,0, 50, 50, 60, 70, 70, 70, 60, 50	; 30-
    184  6120		       00 00 0a 14*	      .byte.b	0,0, 10, 20, 30, 40, 40, 30, 20, 10	; 40-
    185  612a		       00 00 05 0f*	      .byte.b	0,0, 5, 15, 10, 35, 35, 10, 15, 5	; 50-
    186  6134		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 20, 20, 0, 0, 0	; 60-
    187  613e		       00 00 05 fb*	      .byte.b	0,0, 5, -5,-10, 0, 0,-10, -5, 5	; 70-
    188  6148		       00 00 05 0a*	      .byte.b	0,0, 5, 10, 10,-20,-20, 10, 10, 5	; 80-
    189  6152		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 0, 0, 0, 0, 0	; 90-
    190  615c
    191  615c							;---------------------------------------------------------------------------------------------------
    192  615c
    193  615c				   PositionalValue_KNIGHT
    194  615c
    195  615c		       ce ec e2 e2*	      .byte.b	-50,-20,-30,-30,-30,-30,-20,-50
    196  6164		       00 00 d8 ec*	      .byte.b	0,0, -40,-20, 0, 5, 5, 0,-20,-40
    197  616e		       00 00 e2 00*	      .byte.b	0,0, -30, 0, 0, 15, 15, 0, 0,-30
    198  6178		       00 00 e2 00*	      .byte.b	0,0, -30, 0, 15, 60, 60, 15, 0,-30
    199  6182		       00 00 e2 05*	      .byte.b	0,0, -30, 5, 15, 60, 60, 15, 5,-30
    200  618c		       00 00 e2 00*	      .byte.b	0,0, -30, 0, 10, 15, 15, 10, 0,-30
    201  6196		       00 00 d8 ec*	      .byte.b	0,0, -40,-20, 30, 0, 0, 30,-20,-40
    202  61a0		       00 00 ce d8*	      .byte.b	0,0, -50,-40,-30,-30,-30,-30,-40,-50
    203  61aa
    204  61aa
    205  61aa							;---------------------------------------------------------------------------------------------------
    206  61aa
    207  61aa				   PositionalValue_BISHOP
    208  61aa
    209  61aa		       ec f6 f6 f6*	      .byte.b	-20,-10,-10,-10,-10,-10,-10,-20
    210  61b2		       00 00 f6 05*	      .byte.b	0,0, -10, 5, 0, 0, 0, 0, 5,-10
    211  61bc		       00 00 f6 0a*	      .byte.b	0,0, -10, 10, 10, 10, 10, 10, 10,-10
    212  61c6		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 10, 30, 30, 10, 0,-10
    213  61d0		       00 00 f6 05*	      .byte.b	0,0, -10, 5, 5, 30, 30, 5, 5,-10
    214  61da		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 5, 10, 10, 5, 0,-10
    215  61e4		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 0, 0, 0, 0, 0,-10
    216  61ee		       00 00 ec f6*	      .byte.b	0,0, -20,-10,-10,-10,-10,-10,-10,-20
    217  61f8
    218  61f8
    219  61f8							;---------------------------------------------------------------------------------------------------
    220  61f8
    221  61f8				   PositionalValue_ROOK
    222  61f8
    223  61f8		       00 00 0a 19*	      .byte.b	0, 0, 10, 25, 25, 10, 0, 0
    224  6200		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 0, 0, 0, 0, 0, -5
    225  620a		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 0, 0, 0, 0, 0, -5
    226  6214		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 0, 0, 0, 0, 0, -5
    227  621e		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 0, 0, 0, 0, 0, -5
    228  6228		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 10, 10, 10, 10, 0, -5
    229  6232		       00 00 05 0a*	      .byte.b	0,0, 5, 10, 30, 30, 30, 30, 10, 5
    230  623c		       00 00 00 00*	      .byte.b	0,0, 0, 0, 0, 0, 0, 0, 0, 0
    231  6246
    232  6246
    233  6246							;---------------------------------------------------------------------------------------------------
    234  6246
    235  6246				   PositionalValue_QUEEN
    236  6246
    237  6246		       ec f6 f6 fb*	      .byte.b	-20,-10,-10, -5, -5,-10,-10,-20
    238  624e		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 5, 0, 0, 0, 0,-10
    239  6258		       00 00 f6 05*	      .byte.b	0,0, -10, 5, 5, 5, 5, 5, 0,-10
    240  6262		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 5, 25, 25, 25, 0, -10
    241  626c		       00 00 fb 00*	      .byte.b	0,0, -5, 0, 15, 55, 55, 55, 0, -5
    242  6276		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 25, 75, 75, 75, 0,-10
    243  6280		       00 00 f6 00*	      .byte.b	0,0, -10, 0, 0, 0, 0, 0, 0,-10
    244  628a		       00 00 ec f6*	      .byte.b	0,0, -20,-10,-10, -5, -5,-10,-10,-20
    245  6294
    246  6294
    247  6294							;---------------------------------------------------------------------------------------------------
    248  6294
    249  6294				   PositionalValue_KING_MIDGAME
    250  6294
    251  6294		       14 1e 0a 00*	      .byte.b	20, 30, 10, 0, 0, 10, 30, 20
    252  629c		       00 00 14 14*	      .byte.b	0,0, 20, 20, 0, 0, 0, 0, 20, 20
    253  62a6		       00 00 f6 ec*	      .byte.b	0,0, -10,-20,-20,-20,-20,-20,-20,-10
    254  62b0		       00 00 ec e2*	      .byte.b	0,0, -20,-30,-30,-40,-40,-30,-30,-20
    255  62ba		       00 00 e2 d8*	      .byte.b	0,0, -30,-40,-40,-50,-50,-40,-40,-30
    256  62c4		       00 00 e2 d8*	      .byte.b	0,0, -30,-40,-40,-50,-50,-40,-40,-30
    257  62ce		       00 00 e2 d8*	      .byte.b	0,0, -30,-40,-40,-50,-50,-40,-40,-30
    258  62d8		       00 00 e2 d8*	      .byte.b	0,0, -30,-40,-40,-50,-50,-40,-40,-30
    259  62e2
    260  62e2
    261  62e2							;---------------------------------------------------------------------------------------------------
    262  62e2
    263  62e2				   PositionalValue_KING_ENDGAME
    264  62e2
    265  62e2		       ce e2 e2 e2*	      .byte.b	-50,-30,-30,-30,-30,-30,-30,-50
    266  62ea		       00 00 e2 e2*	      .byte.b	0,0, -30,-30, 0, 0, 0, 0,-30,-30
    267  62f4		       00 00 e2 f6*	      .byte.b	0,0, -30,-10, 20, 30, 30, 20,-10,-30
    268  62fe		       00 00 e2 f6*	      .byte.b	0,0, -30,-10, 30, 40, 40, 30,-10,-30
    269  6308		       00 00 e2 f6*	      .byte.b	0,0, -30,-10, 30, 40, 40, 30,-10,-30
    270  6312		       00 00 e2 f6*	      .byte.b	0,0, -30,-10, 20, 30, 30, 20,-10,-30
    271  631c		       00 00 e2 ec*	      .byte.b	0,0, -30,-20,-10, 0, 0,-10,-20,-30
    272  6326		       00 00 ce d8*	      .byte.b	0,0, -50,-40,-30,-20,-20,-30,-40,-50
    273  6330
    274  6330
      0  6330					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  6330		       03 30	   .TEMP      =	* - BANK_START
 BANK_EVAL (2K) SIZE =  $330 , FREE= $4d0
      2  6330					      ECHO	"BANK_EVAL", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  6330				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  6330				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  6330				  -	      ERR
      6  6330					      endif
    276  6330
    277  6330							;---------------------------------------------------------------------------------------------------
    278  6330							; EOF
------- FILE ./chess.asm
------- FILE BANK_SPEAK.asm LEVEL 2 PASS 5
      0  6330					      include	"BANK_SPEAK.asm"
      0  6330					      NEWBANK	SPEAK
      1  6876 ????				      SEG	SPEAK
      2  6800					      ORG	ORIGIN
      3  6800					      RORG	$F000
      4  6800				   BANK_START SET	*
      5  6800				   SPEAK      SET	ORIGIN / 2048
      6  6800				   ORIGIN     SET	ORIGIN + 2048
      7  6800				   _CURRENT_BANK SET	SPEAK
      2  6800
      3  6800							;
      4  6800							; speakjet.inc
      5  6800							;
      6  6800							;
      7  6800							; AtariVox Speech Synth Driver
      8  6800							;
      9  6800							; By Alex Herbert, 2004
     10  6800							;
     11  6800
     12  6800
     13  6800
     14  6800
     15  6800							; Constants
     16  6800
     17  6800
     18  6800		       00 01	   SERIAL_OUTMASK equ	$01
     19  6800		       00 02	   SERIAL_RDYMASK equ	$02
     20  6800
     21  6800
     22  6800
     23  6800							;---------------------------------------------------------------------------------------------------
     24  6800
     25  6800					      mac	speak
     26  6800
     27  6800					      lda	#<{1}
     28  6800					      sta	speech_addr
     29  6800					      lda	#>{1}
     30  6800					      sta	speech_addr+1
     31  6800
     32  6800					      endm
     33  6800
     34  6800
     35  6800							;---------------------------------------------------------------------------------------------------
     36  6800
      0  6800					      DEF	ShutYourMouth
      1  6800				   BANK_ShutYourMouth SET	_CURRENT_BANK
      2  6800				   ShutYourMouth
      3  6800				   TEMPORARY_VAR SET	Overlay
      4  6800				   TEMPORARY_OFFSET SET	0
      5  6800				   VAR_BOUNDARY_ShutYourMouth SET	TEMPORARY_OFFSET
      6  6800				   FUNCTION_NAME SET	ShutYourMouth
      7  6800					      SUBROUTINE
     38  6800					      SUBROUTINE
     39  6800
      0  6800					      REFER	Reset
      1  6800				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  6800				  -TEMPORARY_VAR SET	VAREND_Reset
      3  6800					      ENDIF
      0  6800					      VEND	ShutYourMouth
      1  6800				  -	      IFNCONST	ShutYourMouth
      2  6800				  -	      ECHO	"Incorrect VEND label", ShutYourMouth
      3  6800				  -	      ERR
      4  6800					      ENDIF
      5  6800		       00 a2	   VAREND_ShutYourMouth =	TEMPORARY_VAR
     42  6800
      0  6800					      SPEAK	silence_speech
      1  6800
      2  6800		       a9 74		      lda	#<silence_speech
      3  6802		       85 9c		      sta	speech_addr
      4  6804		       a9 f0		      lda	#>silence_speech
      5  6806		       85 9d		      sta	speech_addr+1
      6  6808
     44  6808		       60		      rts
     45  6809
     46  6809
     47  6809							;---------------------------------------------------------------------------------------------------
     48  6809
      0  6809					      DEF	GameSpeak
      1  6809				   BANK_GameSpeak SET	_CURRENT_BANK
      2  6809				   GameSpeak
      3  6809				   TEMPORARY_VAR SET	Overlay
      4  6809				   TEMPORARY_OFFSET SET	0
      5  6809				   VAR_BOUNDARY_GameSpeak SET	TEMPORARY_OFFSET
      6  6809				   FUNCTION_NAME SET	GameSpeak
      7  6809					      SUBROUTINE
     50  6809					      SUBROUTINE
     51  6809
      0  6809					      REFER	Reset
      1  6809				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  6809				  -TEMPORARY_VAR SET	VAREND_Reset
      3  6809					      ENDIF
      0  6809					      VAR	__speak_temp, 1
      1  6809		       00 a2	   __speak_temp =	TEMPORARY_VAR
      2  6809				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6809
      4  6809				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6809				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6809				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6809					      ENDIF
      8  6809				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6809				  -	      ECHO	"Temporary Variable", __speak_temp, "overflow!"
     10  6809				  -	      ERR
     11  6809					      ENDIF
     12  6809					      LIST	ON
      0  6809					      VEND	GameSpeak
      1  6809				  -	      IFNCONST	GameSpeak
      2  6809				  -	      ECHO	"Incorrect VEND label", GameSpeak
      3  6809				  -	      ERR
      4  6809					      ENDIF
      5  6809		       00 a3	   VAREND_GameSpeak =	TEMPORARY_VAR
     55  6809
     56  6809		       a0 00		      ldy	#0
     57  680b		       b1 9c		      lda	(speech_addr),y
     58  680d		       c9 ff		      cmp	#$ff
     59  680f		       d0 08		      bne	.talk
     60  6811
      0  6811					      SPEAK	left_speech
      1  6811
      2  6811		       a9 4a		      lda	#<left_speech
      3  6813		       85 9c		      sta	speech_addr
      4  6815		       a9 f0		      lda	#>left_speech
      5  6817		       85 9d		      sta	speech_addr+1
      6  6819
     62  6819
     63  6819
     64  6819				   .talk
     65  6819
     66  6819							; check buffer-full status
     67  6819
     68  6819		       ad 80 02 	      lda	SWCHA
     69  681c		       29 02		      and	#SERIAL_RDYMASK
     70  681e		       f0 29		      beq	.speech_done
     71  6820
     72  6820		       a0 00		      ldy	#0
     73  6822		       b1 9c		      lda	(speech_addr),y
     74  6824
     75  6824		       49 ff		      eor	#$ff
     76  6826		       f0 21		      beq	.speech_done
     77  6828		       85 a2		      sta	__speak_temp
     78  682a
     79  682a		       e6 9c		      inc	speech_addr
     80  682c		       d0 02		      bne	.incaddr_skip
     81  682e		       e6 9d		      inc	speech_addr+1
     82  6830				   .incaddr_skip
     83  6830
     84  6830		       38		      sec		; start bit
     85  6831				   .byteout_loop
     86  6831
     87  6831							; put carry flag into bit 0 of SWACNT, perserving other bits
     88  6831
     89  6831		       ad 81 02 	      lda	SWACNT	; 4
     90  6834		       29 fe		      and	#$fe	; 2 6
     91  6836		       69 00		      adc	#$00	; 2 8
     92  6838		       8d 81 02 	      sta	SWACNT	; 4 12
     93  683b
     94  683b							; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
     95  683b
     96  683b		       c0 09		      cpy	#$09	; 2 14
     97  683d		       f0 0a		      beq	.speech_done	; 2 16
     98  683f		       c8		      iny		; 2 18
     99  6840
    100  6840
    101  6840		       a2 07		      ldx	#$07	; 2 20
    102  6842		       ca	   .delay_loop dex		; { 2
    103  6843		       d0 fd		      bne	.delay_loop	;   3
    104  6845							; } = 7 * 5 - 1 = 34
    105  6845							; @54
    106  6845
    107  6845		       46 a2		      lsr	__speak_temp	; 5 59
    108  6847		       10 e8		      bpl	.byteout_loop	; 3 62 cycles for loop
    109  6849
    110  6849		       60	   .speech_done rts
    111  684a
    112  684a
    113  684a							;---------------------------------------------------------------------------------------------------
    114  684a
    115  684a							; Speech Data
    116  684a
    117  684a							;Dec. SpeakJet Use
    118  684a							;----- ------------------
    119  684a							;000 Pause 0
    120  684a							;001 Pause 1
    121  684a							;002 Pause 2
    122  684a							;003 Pause 3
    123  684a							;004 Pause 4
    124  684a							;005 Pause 5
    125  684a							;006 Pause 6
    126  684a							;007 Play Next Sound Fast
    127  684a							;008 Play Next Sound Slow
    128  684a							;014 Play Next Sound High Tone
    129  684a							;015 Play Next Sound Low Tone
    130  684a							;016 Wait
    131  684a							;020 Volume, X
    132  684a							;021 Speed, X
    133  684a							;022 Pitch, X
    134  684a							;023 Bend, X
    135  684a							;024 PortCtr, X
    136  684a							;025 Port, X
    137  684a							;026 Repeat, X
    138  684a							;028 Call Phrase, X
    139  684a							;029 Goto Phrase, X
    140  684a							;030 Delay, X
    141  684a							;031 Reset Defaults
    142  684a							;--------------------------------------------------------
    143  684a							;032 Reserved
    144  684a							;- to -
    145  684a							;127
    146  684a							;--------------------------------------------------------
    147  684a							;128 127 Sound codes
    148  684a							;- to -
    149  684a							;254
    150  684a							;--------------------------------------------------------
    151  684a							;255 End of Phrase.
    152  684a
    153  684a
    154  684a
    155  684a				   left_speech
    156  684a
    157  684a
    158  684a		       1f		      dc.b	31
    159  684b							;	  dc.b $ff
    160  684b
    161  684b
    162  684b
    163  684b
    164  684b
    165  684b
    166  684b
    167  684b		       15 74		      dc.b	21,116	; speed 116
    168  684d		       17 04		      dc.b	23,4	; bend, 4
    169  684f		       16 37		      dc.b	22,55	; pitch, 55
    170  6851		       b6		      dc.b	182	;CH
    171  6852		       81		      dc.b	129	;IH
    172  6853		       c2		      dc.b	194	;KE
    173  6854		       83		      dc.b	131	;EH
    174  6855		       8d		      dc.b	141	;NE
    175  6856		       02		      dc.b	2	; pause 2
    176  6857		       02		      dc.b	2	; pause 2
    177  6858
    178  6858
    179  6858		       08		      dc.b	8	; play next sound slow
    180  6859		       ba		      dc.b	186	;FF
    181  685a		       07		      dc.b	7	; play fast
    182  685b		       9b		      dc.b	155	;OHIY
    183  685c		       04		      dc.b	4	; pause 4
    184  685d		       bf		      dc.b	191	;TT
    185  685e		       06		      dc.b	6	; pause 6
    186  685f		       91		      dc.b	145	;LE
    187  6860		       07		      dc.b	7	; fast
    188  6861		       88		      dc.b	136	;AW
    189  6862		       07		      dc.b	7	; fast
    190  6863		       9b		      dc.b	155	;OHIY
    191  6864		       c4		      dc.b	196	;EK
    192  6865		       06		      dc.b	6	; pause 6
    193  6866		       9a		      dc.b	154	;EYIY
    194  6867		       80		      dc.b	128	;IY
    195  6868		       06		      dc.b	6	; pause 6
    196  6869		       94		      dc.b	148	;GR?
    197  686a		       07		      dc.b	7	; fast
    198  686b		       89		      dc.b	137	;OW
    199  686c		       07		      dc.b	7	; fast
    200  686d		       a4		      dc.b	164	;OWW
    201  686e		       12		      dc.b	18	;???
    202  686f		       ab		      dc.b	171	;BO
    203  6870		       88		      dc.b	136	;AW
    204  6871		       bf		      dc.b	191	;TT
    205  6872		       1f		      dc.b	31	; reset defaults
    206  6873		       ff		      dc.b	$ff
    207  6874
    208  6874
    209  6874				   silence_speech
    210  6874
    211  6874
    212  6874
    213  6874		       1f		      dc.b	31	;31
    214  6875
    215  6875
    216  6875		       ff		      dc.b	$ff
    217  6876
      0  6876					      CHECK_BANK_SIZE	"BANK_SPEAK"
      1  6876		       00 76	   .TEMP      =	* - BANK_START
 BANK_SPEAK (2K) SIZE =  $76 , FREE= $78a
      2  6876					      ECHO	"BANK_SPEAK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  6876				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  6876				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  6876				  -	      ERR
      6  6876					      endif
    219  6876
    220  6876				  -	      if	0
    221  6876				  -typedef    enum
    222  6876				  -	      182
    223  6876				  -	      183	Pause0 = 0, ///< Pause 0ms
    224  6876				  -	      184	Pause1 = 1, ///< Pause 100ms
    225  6876				  -	      185	Pause2 = 2, ///< Pause 200ms
    226  6876				  -	      186	Pause3 = 3, ///< Pause 700ms
    227  6876				  -	      187	Pause4 = 4, ///< Pause 30ms
    228  6876				  -	      188	Pause5 = 5, ///< Pause 60ms
    229  6876				  -	      189	Pause6 = 6, ///< Pause 90ms
    230  6876				  -	      190	Fast = 7, ///< Next phoneme at 0.5 speed
    231  6876				  -	      191	Slow = 8, ///< Next phoneme at 1.5 speed
    232  6876				  -	      192	Stress = 14, ///< Next phoneme with some stress
    233  6876				  -	      193	Relax = 15, ///< Next phoneme with relaxation
    234  6876				  -	      194	Wait = 16, ///< Stops and waits for a Start (see manual)
    235  6876				  -	      195	Soft = 18, ///< Stops and waits for a Start (see manual)
    236  6876				  -	      196	Volume = 20, ///< Next octet is volume 0 to 127. Default 96
    237  6876				  -	      197	Speed = 21, ///< Next octet is speed 0 to 127. Default 114
    238  6876				  -	      198	Pitch = 22, ///< Next octet is pitch in Hz = to 255
    239  6876				  -	      199	Bend = 23, ///< Next octet is frequency bend to 15. Default is 5
    240  6876				  -	      200	PortCtr = 24, ///< Next octet is port control value. See manual. Default is 7
    241  6876				  -	      201	Port = 25, ///< Next octet is Port Output Value. See manual. Default is 0
    242  6876				  -	      202	Repeat = 26, ///< Next octet is repeat count. 0 to 255
    243  6876				  -	      203	CallPhrase = 28, ///< Next octet is EEPROM phrase to play and return. See manual.
    244  6876				  -	      204	GotoPhrase = 29, ///< Next octet is EEPROM phgrase to go to. See manual.
    245  6876				  -	      205	Delay = 30, ///< Next octet is delay in multiples of 10ms. 0 to 255.
    246  6876				  -	      206	Reset = 31, ///< Reset Volume Speed, Pitch, Bend to defaults.
    247  6876				  -	      207
    248  6876				  -	      208	// 32 to 127 reserved
    249  6876				  -	      209
    250  6876				  -	      210	// 128 to 254 Sound codes
    251  6876				  -	      211	// Phonemes, standard names
    252  6876				  -	      212	Phoneme_IY = 128, ///< 70ms Voiced Long Vowel
    253  6876				  -	      213	Phoneme_IH = 129, ///< 70ms Voiced Long Vowel
    254  6876				  -	      214	Phoneme_EY = 130, ///< 70ms Voiced Long Vowel
    255  6876				  -	      215	Phoneme_EH = 131, ///< 70ms Voiced Long Vowel
    256  6876				  -	      216	Phoneme_AY = 132, ///< 70ms Voiced Long Vowel
    257  6876				  -	      217	Phoneme_AX = 133, ///< 70ms Voiced Long Vowel
    258  6876				  -	      218	Phoneme_UX = 134, ///< 70ms Voiced Long Vowel
    259  6876				  -	      219	Phoneme_OH = 135, ///< 70ms Voiced Long Vowel
    260  6876				  -	      220	Phoneme_AW = 136, ///< 70ms Voiced Long Vowel
    261  6876				  -	      221	Phoneme_OW = 137, ///< 70ms Voiced Long Vowel
    262  6876				  -	      222	Phoneme_UH = 138, ///< 70ms Voiced Long Vowel
    263  6876				  -	      223	Phoneme_UW = 139, ///< 70ms Voiced Long Vowel
    264  6876				  -	      224	Phoneme_MM = 140, ///< 70ms Voiced Nasal
    265  6876				  -	      225	Phoneme_NE = 141, ///< 70ms Voiced Nasal
    266  6876				  -	      226	Phoneme_NO = 142, ///< 70ms Voiced Nasal
    267  6876				  -	      227	Phoneme_NGE = 143, ///< 70ms Voiced Nasal
    268  6876				  -	      228	Phoneme_NGO = 144, ///< 70ms Voiced Nasal
    269  6876				  -	      229	Phoneme_LE = 145, ///< 70ms Voiced Resonate
    270  6876				  -	      230	Phoneme_LO = 146, ///< 70ms Voiced Resonate
    271  6876				  -	      231	Phoneme_WW = 147, ///< 70ms Voiced Resonate
    272  6876				  -	      232	Phoneme_RR = 149, //148? ///< 70ms Voiced Resonate
    273  6876				  -	      233	Phoneme_IYRR = 149, ///< 200ms Voiced R Color Vowel
    274  6876				  -	      234	Phoneme_EYRR = 150, ///< 200ms Voiced R Color Vowel
    275  6876				  -	      235	Phoneme_AXRR = 151, ///< 190ms Voiced R Color Vowel
    276  6876				  -	      236	Phoneme_AWRR = 152, ///< 200ms Voiced R Color Vowel
    277  6876				  -	      237	Phoneme_OWRR = 153, ///< 185ms Voiced R Color Vowel
    278  6876				  -	      238	Phoneme_EYIY = 154, ///< 165ms Voiced Diphthong
    279  6876				  -	      239	Phoneme_OHIY = 155, ///< 200ms Voiced Diphthong
    280  6876				  -	      240	Phoneme_OWIY = 156, ///< 225ms Voiced Diphthong
    281  6876				  -	      241	Phoneme_OHIH = 157, ///< 185ms Voiced Diphthong
    282  6876				  -	      242	Phoneme_IYEH = 158, ///< 170ms Voiced Diphthong
    283  6876				  -	      243	Phoneme_EHLE = 159, ///< 140ms Voiced Diphthong
    284  6876				  -	      244	Phoneme_IYUW = 160, ///< 180ms Voiced Diphthong
    285  6876				  -	      245	Phoneme_AXUW = 161, ///< 170ms Voiced Diphthong
    286  6876				  -	      246	Phoneme_IHWW = 162, ///< 170ms Voiced Diphthong
    287  6876				  -	      247	Phoneme_AYWW = 163, ///< 200ms Voiced Diphthong
    288  6876				  -	      248	Phoneme_OWWW = 164, ///< 131ms Voiced Diphthong
    289  6876				  -	      249	Phoneme_JH = 165, ///< 70ms Voiced Affricate
    290  6876				  -	      250	Phoneme_VV = 166, ///< 70ms Voiced Fricative
    291  6876				  -	      251	Phoneme_ZZ = 167, ///< 70ms Voiced Fricative
    292  6876				  -	      252	Phoneme_ZH = 168, ///< 70ms Voiced Fricative
    293  6876				  -	      253	Phoneme_DH = 169, ///< 70ms Voiced Fricative
    294  6876				  -	      254	Phoneme_BE = 170, ///< 45ms Voiced Stop
    295  6876				  -	      255	Phoneme_BO = 171, ///< 45ms Voiced Stop
    296  6876				  -	      256	Phoneme_EB = 172, ///< 10ms Voiced Stop
    297  6876				  -	      257	Phoneme_OB = 173, ///< 10ms Voiced Stop
    298  6876				  -	      258	Phoneme_DE = 174, ///< 45ms Voiced Stop
    299  6876				  -	      259	Phoneme_DO = 174, ///< 45ms Voiced Stop
    300  6876				  -	      260	Phoneme_ED = 176, ///< 10ms Voiced Stop
    301  6876				  -	      261	Phoneme_OD = 177, ///< 10ms Voiced Stop
    302  6876				  -	      262	Phoneme_GE = 178, ///< 55ms Voiced Stop
    303  6876				  -	      263	Phoneme_GO = 179, ///< 55ms Voiced Stop
    304  6876				  -	      264	Phoneme_EG = 180, ///< 55ms Voiced Stop
    305  6876				  -	      265	Phoneme_OG = 181, ///< 55ms Voiced Stop
    306  6876				  -	      266	Phoneme_CH = 182, ///< 70ms Voiceless Affricate
    307  6876				  -	      267	Phoneme_HE = 183, ///< 70ms Voiceless Fricative
    308  6876				  -	      268	Phoneme_HO = 184, ///< 70ms Voiceless Fricative
    309  6876				  -	      269	Phoneme_WH = 185, ///< 70ms Voiceless Fricative
    310  6876				  -	      270	Phoneme_FF = 186, ///< 70ms Voiceless Fricative
    311  6876				  -	      271	Phoneme_SE = 187, ///< 40ms Voiceless Fricative
    312  6876				  -	      272	Phoneme_SO = 188, ///< 40ms Voiceless Fricative
    313  6876				  -	      273	Phoneme_SH = 189, ///< 50ms Voiceless Fricative
    314  6876				  -	      274	Phoneme_TH = 190, ///< 40ms Voiceless Fricative
    315  6876				  -	      275	Phoneme_TT = 191, ///< 50ms Voiceless Stop
    316  6876				  -	      276	Phoneme_TU = 192, ///< 70ms Voiceless Stop
    317  6876				  -	      277	Phoneme_TS = 193, ///< 170ms Voiceless Stop
    318  6876				  -	      278	Phoneme_KE = 194, ///< 55ms Voiceless Stop
    319  6876				  -	      279	Phoneme_KO = 195, ///< 55ms Voiceless Stop
    320  6876				  -	      280	Phoneme_EK = 196, ///< 55ms Voiceless Stop
    321  6876				  -	      281	Phoneme_OK = 197, ///< 45ms Voiceless Stop
    322  6876				  -	      282	Phoneme_PE = 198, ///< 99ms Voiceless Stop
    323  6876				  -	      283	Phoneme_PO = 199, ///< 99ms Voiceless Stop
    324  6876				  -	      284	// Robot sound
    325  6876				  -	      285	Sound_R0 = 200, ///< 80ms Robot
    326  6876				  -	      286	Sound_R1 = 201, ///< 80ms Robot
    327  6876				  -	      287	Sound_R2 = 202, ///< 80ms Robot
    328  6876				  -	      288	Sound_R3 = 203, ///< 80ms Robot
    329  6876				  -	      289	Sound_R4 = 204, ///< 80ms Robot
    330  6876				  -	      290	Sound_R5 = 205, ///< 80ms Robot
    331  6876				  -	      291	Sound_R6 = 206, ///< 80ms Robot
    332  6876				  -	      292	Sound_R7 = 207, ///< 80ms Robot
    333  6876				  -	      293	Sound_R8 = 208, ///< 80ms Robot
    334  6876				  -	      294	Sound_R9 = 209, ///< 80ms Robot
    335  6876				  -	      295	// Alarm sound
    336  6876				  -	      296	Sound_A0 = 210, ///< 300ms Alarm
    337  6876				  -	      297	Sound_A1 = 211, ///< 101ms Alarm
    338  6876				  -	      298	Sound_A2 = 212, ///< 102ms Alarm
    339  6876				  -	      299	Sound_A3 = 213, ///< 540ms Alarm
    340  6876				  -	      300	Sound_A4 = 214, ///< 530ms Alarm
    341  6876				  -	      301	Sound_A5 = 215, ///< 500ms Alarm
    342  6876				  -	      302	Sound_A6 = 216, ///< 135ms Alarm
    343  6876				  -	      303	Sound_A7 = 217, ///< 600ms Alarm
    344  6876				  -	      304	Sound_A8 = 218, ///< 300ms Alarm
    345  6876				  -	      305	Sound_A9 = 219, ///< 250ms Alarm
    346  6876				  -	      306	// Beeps
    347  6876				  -	      307	Sound_B0 = 220, ///< 200ms Beep
    348  6876				  -	      308	Sound_B1 = 221, ///< 270ms Beep
    349  6876				  -	      309	Sound_B2 = 222, ///< 280ms Beep
    350  6876				  -	      310	Sound_B3 = 223, ///< 260ms Beep
    351  6876				  -	      311	Sound_B4 = 224, ///< 300ms Beep
    352  6876				  -	      312	Sound_B5 = 225, ///< 100ms Beep
    353  6876				  -	      313	Sound_B6 = 226, ///< 104ms Beep
    354  6876				  -	      314	Sound_B7 = 227, ///< 100ms Beep
    355  6876				  -	      315	Sound_B8 = 228, ///< 270ms Beep
    356  6876				  -	      316	Sound_B9 = 229, ///< 262ms Beep
    357  6876				  -	      317	// Biological
    358  6876				  -	      318	Sound_C0 = 230, ///< 160ms Biological
    359  6876				  -	      319	Sound_C1 = 231, ///< 300ms Biological
    360  6876				  -	      320	Sound_C2 = 232, ///< 182ms Biological
    361  6876				  -	      321	Sound_C3 = 233, ///< 120ms Biological
    362  6876				  -	      322	Sound_C4 = 234, ///< 175ms Biological
    363  6876				  -	      323	Sound_C5 = 235, ///< 350ms Biological
    364  6876				  -	      324	Sound_C6 = 236, ///< 160ms Biological
    365  6876				  -	      325	Sound_C7 = 237, ///< 260ms Biological
    366  6876				  -	      326	Sound_C8 = 238, ///< 95ms Biological
    367  6876				  -	      327	Sound_C9 = 239, ///< 75ms Biological
    368  6876				  -	      328	// DTMF
    369  6876				  -	      329	DTMF_0 = 240, ///< DTMF 0 95ms
    370  6876				  -	      330	DTMF_1 = 241, ///< DTMF 1 95ms
    371  6876				  -	      331	DTMF_2 = 242, ///< DTMF 2 95ms
    372  6876				  -	      332	DTMF_3 = 243, ///< DTMF 3 95ms
    373  6876				  -	      333	DTMF_4 = 244, ///< DTMF 4 95ms
    374  6876				  -	      334	DTMF_5 = 245, ///< DTMF 5 95ms
    375  6876				  -	      335	DTMF_6 = 246, ///< DTMF 6 95ms
    376  6876				  -	      336	DTMF_7 = 247, ///< DTMF 7 95ms
    377  6876				  -	      337	DTMF_8 = 248, ///< DTMF 8 95ms
    378  6876				  -	      338	DTMF_9 = 249, ///< DTMF 9 95ms
    379  6876				  -	      339	DTMF_STAR = 250, ///< DTMF * 95ms
    380  6876				  -	      340	DTMF_HASH = 251, ///< DTMF # 95ms
    381  6876				  -	      341	// Miscellaneous
    382  6876				  -	      342	Sound_M0 = 252, ///< Sonar ping 125ms
    383  6876				  -	      343	Sound_M1 = 253, ///< Pistol shot 250ms
    384  6876				  -	      344	Sound_M2 = 254, ///< WOW 530ms
    385  6876				  -	      345
    386  6876				  -	      346	EndOfPhrase = 255, ///< End of phrase marker. Required at end of code arrays
    387  6876				  -	      347
    388  6876				  -	      348	CommandCodes	;
    389  6876				  -	      349
    390  6876					      endif
------- FILE ./chess.asm
    590  6876
    591  6876							; MUST BE LAST...
------- FILE BANK_FIXED.asm LEVEL 2 PASS 5
      0  6876					      include	"BANK_FIXED.asm"
      1  6876							; Chess
      2  6876							; Copyright (c) 2019-2020 Andrew Davie
      3  6876							; andrew@taswegian.com
      4  6876
      5  6876
      6  6876							;---------------------------------------------------------------------------------------------------
      7  6876							;#########################################  FIXED BANK  ############################################
      8  6876							;---------------------------------------------------------------------------------------------------
      9  6876
     10  6876				   ORIGIN     SET	FIXED_BANK
     11  6876
      0  6876					      NEWBANK	THE_FIXED_BANK
      1  7fb4 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     13  7800					      RORG	$f800
     14  7800
     15  7800							;---------------------------------------------------------------------------------------------------
     16  7800
      0  7800					      DEF	Reset
      1  7800				   BANK_Reset SET	_CURRENT_BANK
      2  7800				   Reset
      3  7800				   TEMPORARY_VAR SET	Overlay
      4  7800				   TEMPORARY_OFFSET SET	0
      5  7800				   VAR_BOUNDARY_Reset SET	TEMPORARY_OFFSET
      6  7800				   FUNCTION_NAME SET	Reset
      7  7800					      SUBROUTINE
     18  7800					      SUBROUTINE
     19  7800
      0  7800					      VEND	Reset
      1  7800				  -	      IFNCONST	Reset
      2  7800				  -	      ECHO	"Incorrect VEND label", Reset
      3  7800				  -	      ERR
      4  7800					      ENDIF
      5  7800		       00 a2	   VAREND_Reset =	TEMPORARY_VAR
     21  7800
     22  7800		       a2 ff		      ldx	#$FF
     23  7802		       9a		      txs
     24  7803
      0  7803					      JSROM_SAFE	Cart_Init
      1  7803
      2  7803
      3  7803
      4  7803		       a9 00		      lda	#BANK_Cart_Init
      5  7805		       85 8b		      sta	savedBank
      6  7807		       85 3f		      sta	SET_BANK
      7  7809		       20 04 f0 	      jsr	Cart_Init
     26  780c
     27  780c							;JSROM TitleScreen
     28  780c
     29  780c							;JSROM ShutYourMouth
     30  780c
     31  780c							; Patch the final row's "loop" to a RTS
     32  780c
     33  780c		       a2 07		      ldx	#7
     34  780e		       86 3e		      stx	SET_BANK_RAM
     35  7810		       a9 60		      lda	#$60	; "rts"
      0  7812					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  7812		       8d 00 f6 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     37  7815
     38  7815		       20 77 fc 	      jsr	InitialisePieceSquares
     39  7818
     40  7818
     41  7818							;RESYNC
     42  7818				   .StartFrame
     43  7818
     44  7818
     45  7818							; START OF FRAME
     46  7818
     47  7818		       a9 0e		      lda	#%1110	; VSYNC ON
     48  781a		       85 42	   .loopVSync3 sta	WSYNC
     49  781c		       85 40		      sta	VSYNC
     50  781e		       4a		      lsr
     51  781f		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     52  7821
     53  7821		       85 41		      sta	VBLANK
     54  7823
     55  7823		       a0 2f		      ldy	#TIME_PART_1
     56  7825		       8c 96 02 	      sty	TIM64T
     57  7828
     58  7828							; LOTS OF PROCESSING TIME - USE IT
     59  7828
     60  7828		       20 6a f8 	      jsr	AiStateMachine
     61  782b
     62  782b				  -	      if	ASSERTS
     63  782b				  -			; Catch timer expired already
     64  782b				  -			;		      bit TIMINT
     65  782b				  -			;.whoops	      bmi .whoops
     66  782b					      endif
     67  782b
     68  782b		       2c 85 02    .wait      bit	TIMINT
     69  782e		       10 fb		      bpl	.wait
     70  7830
     71  7830
     72  7830							; START OF VISIBLE SCANLINES
     73  7830
     74  7830
      0  7830					      JSROM	longD
      1  7830
      2  7830		       a9 00		      lda	#BANK_longD
      3  7832		       85 3f		      sta	SET_BANK
      4  7834		       20 65 f0 	      jsr	longD
     76  7837
     77  7837		       86 3e		      stx	SET_BANK_RAM
     78  7839		       20 03 f2 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     79  783c
      0  783c					      JSROM	tidySc
      1  783c
      2  783c		       a9 00		      lda	#BANK_tidySc
      3  783e		       85 3f		      sta	SET_BANK
      4  7840		       20 4f f0 	      jsr	tidySc
      0  7843					      JSROM	GameSpeak
      1  7843
      2  7843		       a9 0d		      lda	#BANK_GameSpeak
      3  7845		       85 3f		      sta	SET_BANK
      4  7847		       20 09 f0 	      jsr	GameSpeak
     82  784a		       20 6a f8 	      jsr	AiStateMachine
     83  784d
      0  784d					      JSROM	PositionSprites
      1  784d
      2  784d		       a9 06		      lda	#BANK_PositionSprites
      3  784f		       85 3f		      sta	SET_BANK
      4  7851		       20 00 f4 	      jsr	PositionSprites
     85  7854
     86  7854
     87  7854							; "draw" sprite shapes into row banks
     88  7854
     89  7854		       a2 07		      ldx	#7
     90  7856		       86 3e	   zapem      stx	SET_BANK_RAM
     91  7858		       20 a6 f2 	      jsr	WriteBlank
     92  785b		       ca		      dex
     93  785c		       10 f8		      bpl	zapem
     94  785e
     95  785e		       20 cf f2 	      jsr	WriteCursor
     96  7861
     97  7861
     98  7861		       2c 85 02    Waitforit  bit	TIMINT
     99  7864		       10 fb		      bpl	Waitforit
    100  7866
    101  7866		       4c 18 f8 	      jmp	.StartFrame
    102  7869
    103  7869
    104  7869		       60	   _rts       rts
    105  786a
    106  786a
    107  786a							;---------------------------------------------------------------------------------------------------
    108  786a
      0  786a					      DEF	AiStateMachine
      1  786a				   BANK_AiStateMachine SET	_CURRENT_BANK
      2  786a				   AiStateMachine
      3  786a				   TEMPORARY_VAR SET	Overlay
      4  786a				   TEMPORARY_OFFSET SET	0
      5  786a				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      6  786a				   FUNCTION_NAME SET	AiStateMachine
      7  786a					      SUBROUTINE
    110  786a					      SUBROUTINE
    111  786a
      0  786a					      REFER	Reset
      1  786a				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  786a				  -TEMPORARY_VAR SET	VAREND_Reset
      3  786a					      ENDIF
      0  786a					      VEND	AiStateMachine
      1  786a				  -	      IFNCONST	AiStateMachine
      2  786a				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  786a				  -	      ERR
      4  786a					      ENDIF
      5  786a		       00 a2	   VAREND_AiStateMachine =	TEMPORARY_VAR
    114  786a
      0  786a					      JSROM	AiSetupVectors
      1  786a
      2  786a		       a9 06		      lda	#BANK_AiSetupVectors
      3  786c		       85 3f		      sta	SET_BANK
      4  786e		       20 6f f0 	      jsr	AiSetupVectors
    116  7871		       85 3f		      sta	SET_BANK
    117  7873		       6c ea 00 	      jmp	(__ptr)	; TODO: OR branch back to squeeze cycles
    118  7876
    119  7876
    120  7876							;---------------------------------------------------------------------------------------------------
    121  7876
      0  7876					      DEF	CallClear
      1  7876				   BANK_CallClear SET	_CURRENT_BANK
      2  7876				   CallClear
      3  7876				   TEMPORARY_VAR SET	Overlay
      4  7876				   TEMPORARY_OFFSET SET	0
      5  7876				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      6  7876				   FUNCTION_NAME SET	CallClear
      7  7876					      SUBROUTINE
    123  7876					      SUBROUTINE
    124  7876
      0  7876					      REFER	aiClearEachRow
      1  7876				  -	      IF	VAREND_aiClearEachRow > TEMPORARY_VAR
      2  7876				  -TEMPORARY_VAR SET	VAREND_aiClearEachRow
      3  7876					      ENDIF
      0  7876					      VEND	CallClear
      1  7876				  -	      IFNCONST	CallClear
      2  7876				  -	      ECHO	"Incorrect VEND label", CallClear
      3  7876				  -	      ERR
      4  7876					      ENDIF
      5  7876		       00 a2	   VAREND_CallClear =	TEMPORARY_VAR
    127  7876
    128  7876							; No transient variable dependencies/calls
    129  7876
    130  7876		       84 3e		      sty	SET_BANK_RAM
    131  7878		       20 90 f1 	      jsr	ClearRowBitmap
    132  787b		       60		      rts
    133  787c
    134  787c
    135  787c							;---------------------------------------------------------------------------------------------------
    136  787c
      0  787c					      DEF	aiDrawEntireBoard
      1  787c				   BANK_aiDrawEntireBoard SET	_CURRENT_BANK
      2  787c				   aiDrawEntireBoard
      3  787c				   TEMPORARY_VAR SET	Overlay
      4  787c				   TEMPORARY_OFFSET SET	0
      5  787c				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      6  787c				   FUNCTION_NAME SET	aiDrawEntireBoard
      7  787c					      SUBROUTINE
    138  787c					      SUBROUTINE
    139  787c
      0  787c					      REFER	AiStateMachine
      1  787c				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  787c				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  787c					      ENDIF
      0  787c					      VEND	aiDrawEntireBoard
      1  787c				  -	      IFNCONST	aiDrawEntireBoard
      2  787c				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  787c				  -	      ERR
      4  787c					      ENDIF
      5  787c		       00 a2	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    142  787c
    143  787c
    144  787c		       ad 84 02 	      lda	INTIM
    145  787f		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    146  7881		       90 2c		      bcc	.exit
    147  7883
    148  7883		       a9 08		      lda	#RAMBANK_BOARD
    149  7885		       85 3e		      sta	SET_BANK_RAM
    150  7887		       a4 80		      ldy	squareToDraw
    151  7889		       b9 15 f0 	      lda	ValidSquare,y
    152  788c		       30 1d		      bmi	.isablank2
    153  788e
    154  788e		       b9 79 f0 	      lda	Board,y
    155  7891		       f0 13		      beq	.isablank
    156  7893		       48		      pha
    157  7894		       a9 00		      lda	#BLANK
      0  7896					      sta@RAM	Board,y
      1  7896		       99 79 f4 	      sta	[RAM]+Board,y
    159  7899
    160  7899		       20 57 fd 	      jsr	CopySinglePiece
    161  789c
    162  789c		       a9 08		      lda	#RAMBANK_BOARD
    163  789e		       85 3e		      sta	SET_BANK_RAM
    164  78a0
    165  78a0		       a4 80		      ldy	squareToDraw
    166  78a2		       68		      pla
      0  78a3					      sta@RAM	Board,y
      1  78a3		       99 79 f4 	      sta	[RAM]+Board,y
    168  78a6
      0  78a6				   .isablank  PHASE	AI_DrawPart2
      1  78a6		       a9 10		      lda	#AI_DrawPart2
      2  78a8		       85 8c		      sta	aiState
    170  78aa		       60		      rts
    171  78ab
      0  78ab				   .isablank2 PHASE	AI_DrawPart3
      1  78ab		       a9 11		      lda	#AI_DrawPart3
      2  78ad		       85 8c		      sta	aiState
    173  78af		       60	   .exit      rts
    174  78b0
    175  78b0
    176  78b0							;---------------------------------------------------------------------------------------------------
    177  78b0
      0  78b0					      DEF	aiFlipBuffers
      1  78b0				   BANK_aiFlipBuffers SET	_CURRENT_BANK
      2  78b0				   aiFlipBuffers
      3  78b0				   TEMPORARY_VAR SET	Overlay
      4  78b0				   TEMPORARY_OFFSET SET	0
      5  78b0				   VAR_BOUNDARY_aiFlipBuffers SET	TEMPORARY_OFFSET
      6  78b0				   FUNCTION_NAME SET	aiFlipBuffers
      7  78b0					      SUBROUTINE
    179  78b0					      SUBROUTINE
    180  78b0
      0  78b0					      REFER	AiStateMachine
      1  78b0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  78b0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  78b0					      ENDIF
      0  78b0					      VEND	aiFlipBuffers
      1  78b0				  -	      IFNCONST	aiFlipBuffers
      2  78b0				  -	      ECHO	"Incorrect VEND label", aiFlipBuffers
      3  78b0				  -	      ERR
      4  78b0					      ENDIF
      5  78b0		       00 a2	   VAREND_aiFlipBuffers =	TEMPORARY_VAR
    183  78b0
    184  78b0							; Initialise for a new move
    185  78b0
    186  78b0							;PHASE AI_ComputerMove
    187  78b0							;rts
    188  78b0
    189  78b0		       a5 95		      lda	currentPly
    190  78b2		       85 3e		      sta	SET_BANK_RAM
    191  78b4
    192  78b4		       20 b7 f1 	      jsr	NewPlyInitialise	; zap movelist for this ply
    193  78b7
      0  78b7					      PHASE	AI_GenerateMoves
      1  78b7		       a9 13		      lda	#AI_GenerateMoves
      2  78b9		       85 8c		      sta	aiState
    195  78bb		       60		      rts
    196  78bc
    197  78bc
    198  78bc							;---------------------------------------------------------------------------------------------------
    199  78bc
      0  78bc					      DEF	InitialiseMoveGeneration
      1  78bc				   BANK_InitialiseMoveGeneration SET	_CURRENT_BANK
      2  78bc				   InitialiseMoveGeneration
      3  78bc				   TEMPORARY_VAR SET	Overlay
      4  78bc				   TEMPORARY_OFFSET SET	0
      5  78bc				   VAR_BOUNDARY_InitialiseMoveGeneration SET	TEMPORARY_OFFSET
      6  78bc				   FUNCTION_NAME SET	InitialiseMoveGeneration
      7  78bc					      SUBROUTINE
    201  78bc					      SUBROUTINE
    202  78bc
      0  78bc					      VEND	InitialiseMoveGeneration
      1  78bc				  -	      IFNCONST	InitialiseMoveGeneration
      2  78bc				  -	      ECHO	"Incorrect VEND label", InitialiseMoveGeneration
      3  78bc				  -	      ERR
      4  78bc					      ENDIF
      5  78bc		       00 a2	   VAREND_InitialiseMoveGeneration =	TEMPORARY_VAR
    204  78bc
    205  78bc		       a5 95		      lda	currentPly
    206  78be		       85 3e		      sta	SET_BANK_RAM
    207  78c0
    208  78c0		       20 b7 f1 	      jsr	NewPlyInitialise
    209  78c3
    210  78c3		       a5 8b		      lda	savedBank
    211  78c5		       85 3f		      sta	SET_BANK
    212  78c7		       60		      rts
    213  78c8
    214  78c8
    215  78c8							;---------------------------------------------------------------------------------------------------
    216  78c8
      0  78c8					      DEF	newGen
      1  78c8				   BANK_newGen SET	_CURRENT_BANK
      2  78c8				   newGen
      3  78c8				   TEMPORARY_VAR SET	Overlay
      4  78c8				   TEMPORARY_OFFSET SET	0
      5  78c8				   VAR_BOUNDARY_newGen SET	TEMPORARY_OFFSET
      6  78c8				   FUNCTION_NAME SET	newGen
      7  78c8					      SUBROUTINE
    218  78c8					      SUBROUTINE
    219  78c8
      0  78c8					      REFER	selectmove
      1  78c8					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  78c8				   TEMPORARY_VAR SET	VAREND_selectmove
      3  78c8					      ENDIF
      0  78c8					      VEND	newGen
      1  78c8				  -	      IFNCONST	newGen
      2  78c8				  -	      ECHO	"Incorrect VEND label", newGen
      3  78c8				  -	      ERR
      4  78c8					      ENDIF
      5  78c8		       00 ad	   VAREND_newGen =	TEMPORARY_VAR
    222  78c8
    223  78c8
    224  78c8		       20 b7 f1 	      jsr	NewPlyInitialise
    225  78cb		       4c e7 f8 	      jmp	GenerateAllMoves
    226  78ce
    227  78ce							;	  lda savedBank
    228  78ce							;	  sta SET_BANK_RAM
    229  78ce
    230  78ce							;	  rts
    231  78ce
    232  78ce
    233  78ce							;---------------------------------------------------------------------------------------------------
    234  78ce
      0  78ce					      DEF	aiGenerateMoves
      1  78ce				   BANK_aiGenerateMoves SET	_CURRENT_BANK
      2  78ce				   aiGenerateMoves
      3  78ce				   TEMPORARY_VAR SET	Overlay
      4  78ce				   TEMPORARY_OFFSET SET	0
      5  78ce				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      6  78ce				   FUNCTION_NAME SET	aiGenerateMoves
      7  78ce					      SUBROUTINE
    236  78ce					      SUBROUTINE
    237  78ce
      0  78ce					      REFER	AiStateMachine
      1  78ce				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  78ce				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  78ce					      ENDIF
      0  78ce					      VEND	aiGenerateMoves
      1  78ce				  -	      IFNCONST	aiGenerateMoves
      2  78ce				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  78ce				  -	      ERR
      4  78ce					      ENDIF
      5  78ce		       00 a2	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    240  78ce
    241  78ce							;		      jsr newGen
    242  78ce		       20 e7 f8 	      jsr	GenerateAllMoves
    243  78d1
    244  78d1				  -	      if	PVSP
    245  78d1				  -	      jmp	.player	;tmp
    246  78d1					      endif
    247  78d1
    248  78d1							;TODO -- mmh!!!!
    249  78d1
    250  78d1		       a6 97		      ldx	sideToMove
    251  78d3		       10 05		      bpl	.player
    252  78d5
    253  78d5
      0  78d5				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  78d5		       a9 14		      lda	#AI_ComputerMove
      2  78d7		       85 8c		      sta	aiState
    255  78d9		       60		      rts
    256  78da
    257  78da
      0  78da				   .player    PHASE	AI_StartMoveGen
      1  78da		       a9 0a		      lda	#AI_StartMoveGen
      2  78dc		       85 8c		      sta	aiState
    259  78de		       60	   .wait      rts
    260  78df
    261  78df
    262  78df							;---------------------------------------------------------------------------------------------------
    263  78df
      0  78df					      DEF	aiStepMoveGen
      1  78df				   BANK_aiStepMoveGen SET	_CURRENT_BANK
      2  78df				   aiStepMoveGen
      3  78df				   TEMPORARY_VAR SET	Overlay
      4  78df				   TEMPORARY_OFFSET SET	0
      5  78df				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      6  78df				   FUNCTION_NAME SET	aiStepMoveGen
      7  78df					      SUBROUTINE
    265  78df					      SUBROUTINE
    266  78df
      0  78df					      REFER	AiStateMachine
      1  78df				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  78df				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  78df					      ENDIF
      0  78df					      VEND	aiStepMoveGen
      1  78df				  -	      IFNCONST	aiStepMoveGen
      2  78df				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  78df				  -	      ERR
      4  78df					      ENDIF
      5  78df		       00 a2	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    269  78df
    270  78df
    271  78df							; Because we're (possibly) running with the screen on, processing time is very short and
    272  78df							; we generate the opponent moves piece by piece. Time isn't really an isssue here, so
    273  78df							; this happens over multiple frames.
    274  78df
    275  78df		       20 e7 f8 	      jsr	GenerateAllMoves
      0  78e2					      PHASE	AI_BeginSelectMovePhase	;LookForCheck
      1  78e2		       a9 00		      lda	#AI_BeginSelectMovePhase
      2  78e4		       85 8c		      sta	aiState
    277  78e6		       60	   .wait      rts
    278  78e7
    279  78e7
    280  78e7							;---------------------------------------------------------------------------------------------------
    281  78e7
    282  78e7
      0  78e7					      DEF	GenerateAllMoves
      1  78e7				   BANK_GenerateAllMoves SET	_CURRENT_BANK
      2  78e7				   GenerateAllMoves
      3  78e7				   TEMPORARY_VAR SET	Overlay
      4  78e7				   TEMPORARY_OFFSET SET	0
      5  78e7				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      6  78e7				   FUNCTION_NAME SET	GenerateAllMoves
      7  78e7					      SUBROUTINE
    284  78e7					      SUBROUTINE
    285  78e7
      0  78e7					      REFER	negamax
      1  78e7					      IF	VAREND_negamax > TEMPORARY_VAR
      2  78e7				   TEMPORARY_VAR SET	VAREND_negamax
      3  78e7					      ENDIF
      0  78e7					      REFER	aiStepMoveGen
      1  78e7				  -	      IF	VAREND_aiStepMoveGen > TEMPORARY_VAR
      2  78e7				  -TEMPORARY_VAR SET	VAREND_aiStepMoveGen
      3  78e7					      ENDIF
      0  78e7					      REFER	aiGenerateMoves
      1  78e7				  -	      IF	VAREND_aiGenerateMoves > TEMPORARY_VAR
      2  78e7				  -TEMPORARY_VAR SET	VAREND_aiGenerateMoves
      3  78e7					      ENDIF
      0  78e7					      VAR	__vector, 2
      1  78e7		       00 ad	   __vector   =	TEMPORARY_VAR
      2  78e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  78e7
      4  78e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  78e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  78e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  78e7					      ENDIF
      8  78e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  78e7				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  78e7				  -	      ERR
     11  78e7					      ENDIF
     12  78e7					      LIST	ON
      0  78e7					      VAR	__masker, 1
      1  78e7		       00 af	   __masker   =	TEMPORARY_VAR
      2  78e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  78e7
      4  78e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  78e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  78e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  78e7					      ENDIF
      8  78e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  78e7				  -	      ECHO	"Temporary Variable", __masker, "overflow!"
     10  78e7				  -	      ERR
     11  78e7					      ENDIF
     12  78e7					      LIST	ON
      0  78e7					      VEND	GenerateAllMoves
      1  78e7				  -	      IFNCONST	GenerateAllMoves
      2  78e7				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  78e7				  -	      ERR
      4  78e7					      ENDIF
      5  78e7		       00 b0	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    292  78e7
    293  78e7
    294  78e7		       a9 03		      lda	#3
    295  78e9		       85 af		      sta	__masker
    296  78eb		       a9 00		      lda	#0
    297  78ed		       85 b0		      sta	__masker+1
    298  78ef		       20 fe f8 	      jsr	GenMoves
    299  78f2
    300  78f2		       a9 08		      lda	#8
    301  78f4		       85 af		      sta	__masker
    302  78f6		       a9 03		      lda	#3
    303  78f8		       85 b0		      sta	__masker+1
    304  78fa		       20 fe f8 	      jsr	GenMoves
    305  78fd
    306  78fd
    307  78fd		       60		      rts
    308  78fe
    309  78fe
      0  78fe					      DEF	GenMoves
      1  78fe				   BANK_GenMoves SET	_CURRENT_BANK
      2  78fe				   GenMoves
      3  78fe				   TEMPORARY_VAR SET	Overlay
      4  78fe				   TEMPORARY_OFFSET SET	0
      5  78fe				   VAR_BOUNDARY_GenMoves SET	TEMPORARY_OFFSET
      6  78fe				   FUNCTION_NAME SET	GenMoves
      7  78fe					      SUBROUTINE
    311  78fe
    312  78fe		       a2 64		      ldx	#100
    313  7900		       d0 02		      bne	.next2
    314  7902
    315  7902		       a6 93	   MoveReturn ldx	currentSquare
    316  7904
    317  7904		       a9 08	   .next2     lda	#RAMBANK_BOARD
    318  7906		       85 3e		      sta	SET_BANK_RAM
    319  7908
    320  7908		       ca	   .next      dex
    321  7909		       e0 16		      cpx	#22
    322  790b		       90 2d		      bcc	.exit
    323  790d
    324  790d		       bd 79 f0 	      lda	Board,x
    325  7910		       f0 f6		      beq	.next
    326  7912		       c9 ff		      cmp	#-1
    327  7914		       f0 f2		      beq	.next
    328  7916		       45 97		      eor	sideToMove
    329  7918		       30 ee		      bmi	.next
    330  791a
    331  791a		       86 93		      stx	currentSquare
    332  791c
    333  791c		       45 97		      eor	sideToMove
    334  791e		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    335  7920		       85 92		      sta	currentPiece
    336  7922		       29 0f		      and	#PIECE_MASK
    337  7924		       c5 af		      cmp	__masker
    338  7926		       b0 e0		      bcs	.next	; pawns only!
    339  7928		       c5 b0		      cmp	__masker+1
    340  792a		       90 dc		      bcc	.next
    341  792c		       a8		      tay
    342  792d
    343  792d		       b9 59 f9 	      lda	HandlerVectorLO-1,y
    344  7930		       85 ad		      sta	__vector
    345  7932		       b9 60 f9 	      lda	HandlerVectorHI-1,y
    346  7935		       85 ae		      sta	__vector+1
    347  7937		       6c ad 00 	      jmp	(__vector)
    348  793a
    349  793a
    350  793a		       a5 95	   .exit      lda	currentPly	;savedBank
    351  793c		       85 3e		      sta	SET_BANK_RAM
    352  793e
    353  793e
    354  793e
    355  793e							; Scan for capture of king
    356  793e
    357  793e		       a9 00		      lda	#0
    358  7940		       85 a1		      sta	flagCheck
    359  7942		       ae 4f f1 	      ldx	moveIndex
    360  7945		       e8		      inx
      0  7946					      stx@RAM	moveCounter
      1  7946		       8e 46 f5 	      stx	[RAM]+moveCounter
    362  7949		       ca		      dex
    363  794a		       ca	   .nextCheck dex
    364  794b		       30 0b		      bmi	.end
      0  794d				   .scanCheck lda@PLY	MoveCapture,x
      1  794d		       bd 00 f1 	      lda	MoveCapture,x
    366  7950		       29 0f		      and	#PIECE_MASK
    367  7952		       c9 07		      cmp	#KING
    368  7954		       d0 f4		      bne	.nextCheck
    369  7956		       85 a1		      sta	flagCheck
    370  7958
    371  7958		       60	   .end       rts
    372  7959
    373  7959
    374  7959					      MAC	handlevec
    375  7959					      .byte	{1}Handle_WHITE_PAWN	; 1
    376  7959					      .byte	{1}Handle_BLACK_PAWN	; 2
    377  7959					      .byte	{1}Handle_KNIGHT	; 3
    378  7959					      .byte	{1}Handle_BISHOP	; 4
    379  7959					      .byte	{1}Handle_ROOK	; 5
    380  7959					      .byte	{1}Handle_QUEEN	; 6
    381  7959					      .byte	{1}Handle_KING	; 7
    382  7959					      ENDM
    383  7959
    384  7959
      0  7959					      ALLOCATE	Handlers, 15
      0  7959					      OPTIONAL_PAGEBREAK	"Table", 15
     12  7959					      LIST	ON
      0  7959					      DEF	Handlers
      1  7959				   BANK_Handlers SET	_CURRENT_BANK
      2  7959				   Handlers
      3  7959				   TEMPORARY_VAR SET	Overlay
      4  7959				   TEMPORARY_OFFSET SET	0
      5  7959				   VAR_BOUNDARY_Handlers SET	TEMPORARY_OFFSET
      6  7959				   FUNCTION_NAME SET	Handlers
      7  7959					      SUBROUTINE
    386  7959
    387  7959		       00		      .byte.b	0	; dummy to prevent page cross access on index 0
    388  795a
      0  795a				   HandlerVectorLO HANDLEVEC	<
      1  795a		       9d		      .byte.b	<Handle_WHITE_PAWN
      2  795b		       35		      .byte.b	<Handle_BLACK_PAWN
      3  795c		       a4		      .byte.b	<Handle_KNIGHT
      4  795d		       d0		      .byte.b	<Handle_BISHOP
      5  795e		       4b		      .byte.b	<Handle_ROOK
      6  795f		       dd		      .byte.b	<Handle_QUEEN
      7  7960		       c6		      .byte.b	<Handle_KING
      0  7961				   HandlerVectorHI HANDLEVEC	>
      1  7961		       fa		      .byte.b	>Handle_WHITE_PAWN
      2  7962		       fb		      .byte.b	>Handle_BLACK_PAWN
      3  7963		       fb		      .byte.b	>Handle_KNIGHT
      4  7964		       f1		      .byte.b	>Handle_BISHOP
      5  7965		       f2		      .byte.b	>Handle_ROOK
      6  7966		       f0		      .byte.b	>Handle_QUEEN
      7  7967		       f2		      .byte.b	>Handle_KING
    391  7968
    392  7968							;---------------------------------------------------------------------------------------------------
    393  7968
    394  7968							;TODO...
      0  7968					      DEF	SAFE_LookForCheck
      1  7968				   BANK_SAFE_LookForCheck SET	_CURRENT_BANK
      2  7968				   SAFE_LookForCheck
      3  7968				   TEMPORARY_VAR SET	Overlay
      4  7968				   TEMPORARY_OFFSET SET	0
      5  7968				   VAR_BOUNDARY_SAFE_LookForCheck SET	TEMPORARY_OFFSET
      6  7968				   FUNCTION_NAME SET	SAFE_LookForCheck
      7  7968					      SUBROUTINE
    396  7968					      SUBROUTINE
    397  7968
    398  7968		       a5 95		      lda	currentPly
    399  796a		       85 3e		      sta	SET_BANK_RAM
    400  796c
      0  796c					      ldy@RAM	moveIndex
      1  796c		       ac 4f f1 	      ldy	moveIndex
    402  796f		       30 0f		      bmi	.failed
    403  7971
    404  7971		       be 48 f0    .scan      ldx	MoveTo,y
    405  7974		       bd 79 f0 	      lda	Board,x
    406  7977		       29 0f		      and	#PIECE_MASK
    407  7979		       c9 07		      cmp	#KING
    408  797b		       f0 04		      beq	.inCheck	; --> CS too
    409  797d		       88		      dey
    410  797e		       10 f1		      bpl	.scan
    411  7980
    412  7980		       18	   .failed    clc
    413  7981
    414  7981		       a5 8b	   .inCheck   lda	savedBank	; CS or CC
    415  7983		       85 3f		      sta	SET_BANK
    416  7985		       60		      rts
    417  7986
    418  7986
    419  7986							;---------------------------------------------------------------------------------------------------
    420  7986
      0  7986					      DEF	aiComputerMove
      1  7986				   BANK_aiComputerMove SET	_CURRENT_BANK
      2  7986				   aiComputerMove
      3  7986				   TEMPORARY_VAR SET	Overlay
      4  7986				   TEMPORARY_OFFSET SET	0
      5  7986				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      6  7986				   FUNCTION_NAME SET	aiComputerMove
      7  7986					      SUBROUTINE
    422  7986					      SUBROUTINE
    423  7986
      0  7986					      REFER	AiStateMachine
      1  7986				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  7986				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  7986					      ENDIF
      0  7986					      VEND	aiComputerMove
      1  7986				  -	      IFNCONST	aiComputerMove
      2  7986				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  7986				  -	      ERR
      4  7986					      ENDIF
      5  7986		       00 a2	   VAREND_aiComputerMove =	TEMPORARY_VAR
    426  7986
    427  7986
    428  7986		       a9 09		      lda	#RAMBANK_PLY
    429  7988		       85 95		      sta	currentPly
    430  798a		       85 3e		      sta	SET_BANK_RAM	; switch in movelist
    431  798c
    432  798c		       20 00 f2 	      jsr	selectmove
    433  798f
    434  798f		       ad 51 f1 	      lda	bestMove
    435  7992		       10 17		      bpl	.notComputer
    436  7994
    437  7994							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
    438  7994
      0  7994					      SWAP
      1  7994		       a5 97		      lda	sideToMove
      2  7996		       49 83		      eor	#SWAP_SIDE
      3  7998		       85 97		      sta	sideToMove
    440  799a
    441  799a		       20 e7 f8 	      jsr	GenerateAllMoves
    442  799d		       a5 a1		      lda	flagCheck
    443  799f		       f0 05		      beq	.gameDrawn
    444  79a1
      0  79a1					      PHASE	AI_CheckMate
      1  79a1		       a9 23		      lda	#AI_CheckMate
      2  79a3		       85 8c		      sta	aiState
    446  79a5		       60		      rts
    447  79a6
    448  79a6
      0  79a6				   .gameDrawn PHASE	AI_Draw
      1  79a6		       a9 24		      lda	#AI_Draw
      2  79a8		       85 8c		      sta	aiState
    450  79aa		       60		      rts
    451  79ab
      0  79ab				   .notComputer PHASE	AI_MoveIsSelected
      1  79ab		       a9 15		      lda	#AI_MoveIsSelected
      2  79ad		       85 8c		      sta	aiState
    453  79af		       60	   .halted    rts
    454  79b0
    455  79b0
    456  79b0
    457  79b0							;---------------------------------------------------------------------------------------------------
    458  79b0
      0  79b0					      DEF	AdjustMaterialPositionalValue
      1  79b0				   BANK_AdjustMaterialPositionalValue SET	_CURRENT_BANK
      2  79b0				   AdjustMaterialPositionalValue
      3  79b0				   TEMPORARY_VAR SET	Overlay
      4  79b0				   TEMPORARY_OFFSET SET	0
      5  79b0				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      6  79b0				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
      7  79b0					      SUBROUTINE
    460  79b0					      SUBROUTINE
    461  79b0
    462  79b0							; A move is about to be made, so  adjust material and positional values based on from/to and
    463  79b0							; capture.
    464  79b0
    465  79b0							; First, nominate referencing subroutines so that local variables can be adjusted properly
    466  79b0
      0  79b0					      REFER	negamax
      1  79b0					      IF	VAREND_negamax > TEMPORARY_VAR
      2  79b0				   TEMPORARY_VAR SET	VAREND_negamax
      3  79b0					      ENDIF
      0  79b0					      REFER	MakeMove
      1  79b0					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  79b0				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  79b0					      ENDIF
      0  79b0					      REFER	aiMoveIsSelected
      1  79b0				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  79b0				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  79b0					      ENDIF
      0  79b0					      VAR	__originalPiece, 1
      1  79b0		       00 af	   __originalPiece =	TEMPORARY_VAR
      2  79b0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  79b0
      4  79b0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  79b0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  79b0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  79b0					      ENDIF
      8  79b0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  79b0				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  79b0				  -	      ERR
     11  79b0					      ENDIF
     12  79b0					      LIST	ON
      0  79b0					      VAR	__capturedPiece, 1
      1  79b0		       00 b0	   __capturedPiece =	TEMPORARY_VAR
      2  79b0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  79b0
      4  79b0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  79b0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  79b0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  79b0					      ENDIF
      8  79b0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  79b0				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  79b0				  -	      ERR
     11  79b0					      ENDIF
     12  79b0					      LIST	ON
      0  79b0					      VEND	AdjustMaterialPositionalValue
      1  79b0				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  79b0				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  79b0				  -	      ERR
      4  79b0					      ENDIF
      5  79b0		       00 b1	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    473  79b0
    474  79b0							; fromPiece	 piece doing the move (promoted type)
    475  79b0							; fromX12	 current square
    476  79b0							; originX12	 starting square
    477  79b0							; toX12	 ending square
    478  79b0
    479  79b0
    480  79b0							; get the piece types from the board
    481  79b0
    482  79b0		       a9 08		      lda	#RAMBANK_BOARD
    483  79b2		       85 3e		      sta	SET_BANK_RAM
    484  79b4		       a4 87		      ldy	originX12
    485  79b6		       b9 79 f0 	      lda	Board,y
    486  79b9		       85 af		      sta	__originalPiece
    487  79bb		       a4 86		      ldy	toX12
    488  79bd		       b9 79 f0 	      lda	Board,y
    489  79c0		       85 b0		      sta	__capturedPiece
    490  79c2
    491  79c2							; {
    492  79c2							;   adjust the positional value  (originX12 --> fromX12)
    493  79c2
    494  79c2		       a9 0c		      lda	#BANK_AddPiecePositionValue
    495  79c4		       85 3f		      sta	SET_BANK
    496  79c6
    497  79c6
    498  79c6							;ldy toX12
    499  79c6		       a5 98		      lda	fromPiece
    500  79c8		       20 23 f0 	      jsr	AddPiecePositionValue	; add pos value for new position
    501  79cb
    502  79cb
    503  79cb		       a5 af		      lda	__originalPiece
    504  79cd		       45 98		      eor	fromPiece	; the new piece
    505  79cf		       29 0f		      and	#PIECE_MASK
    506  79d1		       f0 08		      beq	.same1	; unchanged, so skip
    507  79d3
    508  79d3		       a5 98		      lda	fromPiece	; new piece
    509  79d5		       29 0f		      and	#PIECE_MASK
    510  79d7		       a8		      tay
    511  79d8		       20 10 f0 	      jsr	AddPieceMaterialValue
    512  79db
    513  79db				   .same1
    514  79db
    515  79db							; and now the 'subtracts'
    516  79db
      0  79db					      NEGEVAL
      1  79db
      2  79db		       38		      sec
      3  79dc		       a9 00		      lda	#0
      4  79de		       e5 90		      sbc	Evaluation
      5  79e0		       85 90		      sta	Evaluation
      6  79e2		       a9 00		      lda	#0
      7  79e4		       e5 91		      sbc	Evaluation+1
      8  79e6		       85 91		      sta	Evaluation+1
    518  79e8
    519  79e8		       a4 87		      ldy	originX12
    520  79ea		       a5 af		      lda	__originalPiece
    521  79ec		       20 23 f0 	      jsr	AddPiecePositionValue	; remove pos value for original position
    522  79ef
    523  79ef
    524  79ef		       a5 af		      lda	__originalPiece
    525  79f1		       45 98		      eor	fromPiece	; the new piece
    526  79f3		       29 0f		      and	#PIECE_MASK
    527  79f5		       f0 08		      beq	.same2	; unchanged, so skip
    528  79f7
    529  79f7		       a5 af		      lda	__originalPiece
    530  79f9		       29 0f		      and	#PIECE_MASK
    531  79fb		       a8		      tay
    532  79fc		       20 10 f0 	      jsr	AddPieceMaterialValue	; remove material for original type
    533  79ff				   .same2
    534  79ff
      0  79ff					      NEGEVAL
      1  79ff
      2  79ff		       38		      sec
      3  7a00		       a9 00		      lda	#0
      4  7a02		       e5 90		      sbc	Evaluation
      5  7a04		       85 90		      sta	Evaluation
      6  7a06		       a9 00		      lda	#0
      7  7a08		       e5 91		      sbc	Evaluation+1
      8  7a0a		       85 91		      sta	Evaluation+1
    536  7a0c
    537  7a0c							; If there's a capture, we adjust the material value
    538  7a0c
    539  7a0c							;		      lda __capturedPiece
    540  7a0c							;		      eor __originalPiece
    541  7a0c							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    542  7a0c
    543  7a0c
    544  7a0c		       a5 b0		      lda	__capturedPiece
    545  7a0e		       29 0f		      and	#PIECE_MASK
    546  7a10		       f0 04		      beq	.noCapture
    547  7a12		       a8		      tay
    548  7a13		       20 10 f0 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    549  7a16				   .noCapture
    550  7a16
    551  7a16							; }
    552  7a16		       a5 8b		      lda	savedBank
    553  7a18		       85 3f		      sta	SET_BANK
    554  7a1a		       60		      rts
    555  7a1b
    556  7a1b
    557  7a1b							;---------------------------------------------------------------------------------------------------
    558  7a1b
      0  7a1b					      DEF	debug
      1  7a1b				   BANK_debug SET	_CURRENT_BANK
      2  7a1b				   debug
      3  7a1b				   TEMPORARY_VAR SET	Overlay
      4  7a1b				   TEMPORARY_OFFSET SET	0
      5  7a1b				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      6  7a1b				   FUNCTION_NAME SET	debug
      7  7a1b					      SUBROUTINE
    560  7a1b					      SUBROUTINE
    561  7a1b
    562  7a1b							; Use this to trap breakpoints in "unknown" banks. Just "jsr debug" from wherever you want
    563  7a1b							; to catch the code, and put a breakpoint here instead. Then step, and you're at the place
    564  7a1b							; you wanted to see, without knowing the bank.
    565  7a1b
    566  7a1b		       60		      rts
    567  7a1c
    568  7a1c
    569  7a1c							;---------------------------------------------------------------------------------------------------
    570  7a1c
      0  7a1c					      DEF	EnPassantCheck
      1  7a1c				   BANK_EnPassantCheck SET	_CURRENT_BANK
      2  7a1c				   EnPassantCheck
      3  7a1c				   TEMPORARY_VAR SET	Overlay
      4  7a1c				   TEMPORARY_OFFSET SET	0
      5  7a1c				   VAR_BOUNDARY_EnPassantCheck SET	TEMPORARY_OFFSET
      6  7a1c				   FUNCTION_NAME SET	EnPassantCheck
      7  7a1c					      SUBROUTINE
    572  7a1c					      SUBROUTINE
    573  7a1c
    574  7a1c							; {
    575  7a1c							; With en-passant flag, it is essentially dual-use.
    576  7a1c							; First, it marks if the move is *involved* somehow in an en-passant
    577  7a1c							; if the piece has MOVED already, then it's an en-passant capture
    578  7a1c							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    579  7a1c
    580  7a1c		       a4 94		      ldy	enPassantPawn	; save from previous side move
    581  7a1e
    582  7a1e		       a2 00		      ldx	#0	; (probably) NO en-passant this time
    583  7a20		       a5 98		      lda	fromPiece
    584  7a22		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    585  7a24		       c9 20		      cmp	#FLAG_ENPASSANT
    586  7a26		       d0 06		      bne	.noep	; HAS moved, or not en-passant
    587  7a28
    588  7a28		       45 98		      eor	fromPiece	; clear FLAG_ENPASSANT
    589  7a2a		       85 98		      sta	fromPiece
    590  7a2c
    591  7a2c		       a6 85		      ldx	fromX12	; this IS an en-passantable opening, so record the square
    592  7a2e		       86 94	   .noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
    593  7a30
    594  7a30							; }
    595  7a30
    596  7a30
    597  7a30							; Check to see if we are doing an actual en-passant capture...
    598  7a30
    599  7a30							; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
    600  7a30							;  as the en-passant will fail if the taking piece does not have this flag set correctly
    601  7a30
    602  7a30							;sty originX12 		  ; rqd for FixPieceList
    603  7a30
    604  7a30		       a5 98		      lda	fromPiece
    605  7a32		       29 20		      and	#FLAG_ENPASSANT
    606  7a34							;beq .notEnPassant		  ; not an en-passant, or it's enpassant by a MOVED piece
    607  7a34		       60		      rts
    608  7a35
    609  7a35							;---------------------------------------------------------------------------------------------------
    610  7a35
      0  7a35					      DEF	EnPassantReP_MovePiece
      1  7a35				   BANK_EnPassantReP_MovePiece SET	_CURRENT_BANK
      2  7a35				   EnPassantReP_MovePiece
      3  7a35				   TEMPORARY_VAR SET	Overlay
      4  7a35				   TEMPORARY_OFFSET SET	0
      5  7a35				   VAR_BOUNDARY_EnPassantReP_MovePiece SET	TEMPORARY_OFFSET
      6  7a35				   FUNCTION_NAME SET	EnPassantReP_MovePiece
      7  7a35					      SUBROUTINE
    612  7a35					      SUBROUTINE
    613  7a35
      0  7a35					      REFER	SpecialBody
      1  7a35					      IF	VAREND_SpecialBody > TEMPORARY_VAR
      2  7a35				   TEMPORARY_VAR SET	VAREND_SpecialBody
      3  7a35					      ENDIF
      0  7a35					      VEND	EnPassantReP_MovePiece
      1  7a35				  -	      IFNCONST	EnPassantReP_MovePiece
      2  7a35				  -	      ECHO	"Incorrect VEND label", EnPassantReP_MovePiece
      3  7a35				  -	      ERR
      4  7a35					      ENDIF
      5  7a35		       00 ad	   VAREND_EnPassantReP_MovePiece =	TEMPORARY_VAR
    616  7a35
    617  7a35		       20 57 fa 	      jsr	DeletePiece	; adjust material/position evaluation
    618  7a38
    619  7a38		       a5 97		      lda	sideToMove
    620  7a3a		       29 7f		      and	#127
    621  7a3c		       85 3e		      sta	SET_BANK_RAM
    622  7a3e
    623  7a3e		       60		      rts
    624  7a3f
    625  7a3f
    626  7a3f							;---------------------------------------------------------------------------------------------------
    627  7a3f
      0  7a3f					      DEF	SpecialBody
      1  7a3f				   BANK_SpecialBody SET	_CURRENT_BANK
      2  7a3f				   SpecialBody
      3  7a3f				   TEMPORARY_VAR SET	Overlay
      4  7a3f				   TEMPORARY_OFFSET SET	0
      5  7a3f				   VAR_BOUNDARY_SpecialBody SET	TEMPORARY_OFFSET
      6  7a3f				   FUNCTION_NAME SET	SpecialBody
      7  7a3f					      SUBROUTINE
    629  7a3f					      SUBROUTINE
    630  7a3f
      0  7a3f					      COMMON_VARS_ALPHABETA
      1  7a3f
      0  7a3f					      VAR	__bestMove, 1
      1  7a3f		       00 a2	   __bestMove =	TEMPORARY_VAR
      2  7a3f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7a3f
      4  7a3f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a3f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a3f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a3f					      ENDIF
      8  7a3f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a3f				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  7a3f				  -	      ERR
     11  7a3f					      ENDIF
     12  7a3f					      LIST	ON
      0  7a3f					      VAR	__bestScore, 2
      1  7a3f		       00 a3	   __bestScore =	TEMPORARY_VAR
      2  7a3f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7a3f
      4  7a3f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a3f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a3f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a3f					      ENDIF
      8  7a3f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a3f				  -	      ECHO	"Temporary Variable", __bestScore, "overflow!"
     10  7a3f				  -	      ERR
     11  7a3f					      ENDIF
     12  7a3f					      LIST	ON
      0  7a3f					      VAR	__alpha, 2
      1  7a3f		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  7a3f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7a3f
      4  7a3f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a3f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a3f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a3f					      ENDIF
      8  7a3f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a3f				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  7a3f				  -	      ERR
     11  7a3f					      ENDIF
     12  7a3f					      LIST	ON
      0  7a3f					      VAR	__beta, 2
      1  7a3f		       00 a7	   __beta     =	TEMPORARY_VAR
      2  7a3f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7a3f
      4  7a3f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a3f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a3f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a3f					      ENDIF
      8  7a3f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a3f				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  7a3f				  -	      ERR
     11  7a3f					      ENDIF
     12  7a3f					      LIST	ON
      0  7a3f					      VAR	__negamax, 2
      1  7a3f		       00 a9	   __negamax  =	TEMPORARY_VAR
      2  7a3f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7a3f
      4  7a3f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a3f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a3f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a3f					      ENDIF
      8  7a3f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a3f				  -	      ECHO	"Temporary Variable", __negamax, "overflow!"
     10  7a3f				  -	      ERR
     11  7a3f					      ENDIF
     12  7a3f					      LIST	ON
      0  7a3f					      VAR	__value, 2
      1  7a3f		       00 ab	   __value    =	TEMPORARY_VAR
      2  7a3f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7a3f
      4  7a3f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a3f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a3f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a3f					      ENDIF
      8  7a3f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a3f				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  7a3f				  -	      ERR
     11  7a3f					      ENDIF
     12  7a3f					      LIST	ON
      8  7a3f
      0  7a3f					      REFER	aiSpecialMoveFixup
      1  7a3f				  -	      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  7a3f				  -TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  7a3f					      ENDIF
      0  7a3f					      VEND	SpecialBody
      1  7a3f				  -	      IFNCONST	SpecialBody
      2  7a3f				  -	      ECHO	"Incorrect VEND label", SpecialBody
      3  7a3f				  -	      ERR
      4  7a3f					      ENDIF
      5  7a3f		       00 ad	   VAREND_SpecialBody =	TEMPORARY_VAR
    634  7a3f
    635  7a3f				  -	      IF	ENPASSANT_ENABLED
    636  7a3f				  -
    637  7a3f				  -			; TODO - enpassant borked
    638  7a3f				  -
    639  7a3f				  -			; Handle en-passant captures
    640  7a3f				  -			; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
    641  7a3f				  -			; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
    642  7a3f				  -			; need to do the appropriate things...
    643  7a3f				  -
    644  7a3f				  -	      jsr	EnPassantCheck
    645  7a3f				  -	      beq	.notEnPassant
    646  7a3f				  -
    647  7a3f				  -			; {
    648  7a3f				  -
    649  7a3f				  -			; Here we are the aggressor and we need to take the pawn 'en passant' fashion
    650  7a3f				  -			; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
    651  7a3f				  -
    652  7a3f				  -			; Remove the pawn from the board and piecelist, and undraw
    653  7a3f				  -
    654  7a3f				  -	      sty	squareToDraw
    655  7a3f				  -	      jsr	CopySinglePiece	; undraw captured pawn
    656  7a3f				  -
    657  7a3f				  -	      ldy	originX12	; taken pawn's square
    658  7a3f				  -
    659  7a3f				  -	      jsr	EnPassantReP_MovePiece
    660  7a3f				  -
    661  7a3f				  -.notEnPassant
    662  7a3f				  -			; }
    663  7a3f				  -
    664  7a3f					      ENDIF
    665  7a3f
    666  7a3f
    667  7a3f		       a5 95		      lda	currentPly
    668  7a41		       85 3e		      sta	SET_BANK_RAM
    669  7a43		       20 6c f2 	      jsr	CastleFixupDraw
    670  7a46		       60		      rts
    671  7a47
    672  7a47
    673  7a47							;---------------------------------------------------------------------------------------------------
    674  7a47
      0  7a47					      DEF	aiSpecialMoveFixup
      1  7a47				   BANK_aiSpecialMoveFixup SET	_CURRENT_BANK
      2  7a47				   aiSpecialMoveFixup
      3  7a47				   TEMPORARY_VAR SET	Overlay
      4  7a47				   TEMPORARY_OFFSET SET	0
      5  7a47				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      6  7a47				   FUNCTION_NAME SET	aiSpecialMoveFixup
      7  7a47					      SUBROUTINE
    676  7a47					      SUBROUTINE
    677  7a47
      0  7a47					      REFER	AiStateMachine
      1  7a47				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  7a47				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  7a47					      ENDIF
      0  7a47					      VEND	aiSpecialMoveFixup
      1  7a47				  -	      IFNCONST	aiSpecialMoveFixup
      2  7a47				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  7a47				  -	      ERR
      4  7a47					      ENDIF
      5  7a47		       00 a2	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    680  7a47
    681  7a47		       ad 84 02 	      lda	INTIM
    682  7a4a		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    683  7a4c		       b0 01		      bcs	.cont
    684  7a4e		       60		      rts
    685  7a4f
    686  7a4f				   .cont
      0  7a4f					      PHASE	AI_FlipBuffers
      1  7a4f		       a9 12		      lda	#AI_FlipBuffers
      2  7a51		       85 8c		      sta	aiState
    688  7a53
    689  7a53		       20 3f fa 	      jsr	SpecialBody
    690  7a56		       60		      rts
    691  7a57
    692  7a57
    693  7a57							;---------------------------------------------------------------------------------------------------
    694  7a57
      0  7a57					      DEF	DeletePiece
      1  7a57				   BANK_DeletePiece SET	_CURRENT_BANK
      2  7a57				   DeletePiece
      3  7a57				   TEMPORARY_VAR SET	Overlay
      4  7a57				   TEMPORARY_OFFSET SET	0
      5  7a57				   VAR_BOUNDARY_DeletePiece SET	TEMPORARY_OFFSET
      6  7a57				   FUNCTION_NAME SET	DeletePiece
      7  7a57					      SUBROUTINE
    696  7a57					      SUBROUTINE
    697  7a57
    698  7a57
    699  7a57							; Based on piece square, adjust material and position value with piece deleted
    700  7a57							; y = piece square
    701  7a57
      0  7a57					      REFER	EnPassantReP_MovePiece
      1  7a57					      IF	VAREND_EnPassantReP_MovePiece > TEMPORARY_VAR
      2  7a57				   TEMPORARY_VAR SET	VAREND_EnPassantReP_MovePiece
      3  7a57					      ENDIF
      0  7a57					      REFER	SpecialBody
      1  7a57				  -	      IF	VAREND_SpecialBody > TEMPORARY_VAR
      2  7a57				  -TEMPORARY_VAR SET	VAREND_SpecialBody
      3  7a57					      ENDIF
      0  7a57					      VAR	__y, 1
      1  7a57		       00 ad	   __y	      =	TEMPORARY_VAR
      2  7a57				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7a57
      4  7a57				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a57				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a57				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a57					      ENDIF
      8  7a57				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a57				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  7a57				  -	      ERR
     11  7a57					      ENDIF
     12  7a57					      LIST	ON
      0  7a57					      VAR	__col, 1
      1  7a57		       00 ae	   __col      =	TEMPORARY_VAR
      2  7a57				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7a57
      4  7a57				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a57				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a57				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a57					      ENDIF
      8  7a57				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a57				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  7a57				  -	      ERR
     11  7a57					      ENDIF
     12  7a57					      LIST	ON
      0  7a57					      VEND	DeletePiece
      1  7a57				  -	      IFNCONST	DeletePiece
      2  7a57				  -	      ECHO	"Incorrect VEND label", DeletePiece
      3  7a57				  -	      ERR
      4  7a57					      ENDIF
      5  7a57		       00 af	   VAREND_DeletePiece =	TEMPORARY_VAR
    707  7a57
    708  7a57		       84 ad		      sty	__y
    709  7a59
    710  7a59		       a9 08		      lda	#RAMBANK_BOARD
    711  7a5b		       85 3e		      sta	SET_BANK_RAM
    712  7a5d		       b9 79 f0 	      lda	Board,y	; piece type
    713  7a60
    714  7a60		       85 ae		      sta	__col
    715  7a62		       29 0f		      and	#PIECE_MASK
    716  7a64		       a8		      tay
    717  7a65
    718  7a65		       a9 0c		      lda	#BANK_AddPieceMaterialValue
    719  7a67		       85 3f		      sta	SET_BANK
    720  7a69		       20 10 f0 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
    721  7a6c
    722  7a6c		       a5 ae		      lda	__col
    723  7a6e		       a4 ad		      ldy	__y
    724  7a70		       20 23 f0 	      jsr	AddPiecePositionValue	; adding for opponent = taking
    725  7a73
    726  7a73		       60		      rts
    727  7a74
    728  7a74
    729  7a74							;---------------------------------------------------------------------------------------------------
    730  7a74
------- FILE Handler_PAWN.asm LEVEL 3 PASS 5
      0  7a74					      include	"Handler_PAWN.asm"
      1  7a74							; Copyright (C)2020 Andrew Davie
      2  7a74							; Pawn move handlers
      3  7a74
      4  7a74							;---------------------------------------------------------------------------------------------------
      5  7a74							; WHITE PAWN
      6  7a74							;---------------------------------------------------------------------------------------------------
      7  7a74
      8  7a74		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  7a74		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  7a74
     11  7a74							;---------------------------------------------------------------------------------------------------
     12  7a74
     13  7a74					      MAC	en_passant
     14  7a74					      SUBROUTINE
     15  7a74							; {1} = _LEFT or _RIGHT
     16  7a74
     17  7a74					      ldx	currentSquare
     18  7a74					      ldy	ValidSquare+{1},x
     19  7a74					      cpy	enPassantPawn
     20  7a74					      bne	.invalid
     21  7a74					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  7a74					      lda	Board,y
     23  7a74					      bne	.invalid
     24  7a74					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  7a74				   .invalid
     26  7a74					      ENDM
     27  7a74
     28  7a74							;---------------------------------------------------------------------------------------------------
     29  7a74
     30  7a74					      MAC	promote_pawn
     31  7a74							;SUBROUTINE
     32  7a74
     33  7a74							;{1} = BLACK or WHITE
     34  7a74
     35  7a74
     36  7a74					      sty	__temp
     37  7a74					      lda	#{1}|QUEEN
     38  7a74					      sta	currentPiece
     39  7a74					      jsr	AddMove
     40  7a74
     41  7a74					      lda	#{1}|ROOK
     42  7a74					      sta	currentPiece
     43  7a74					      ldy	__temp
     44  7a74					      jsr	AddMove
     45  7a74
     46  7a74					      lda	#{1}|BISHOP
     47  7a74					      sta	currentPiece
     48  7a74					      ldy	__temp
     49  7a74					      jsr	AddMove
     50  7a74
     51  7a74					      lda	#{1}|KNIGHT
     52  7a74					      sta	currentPiece
     53  7a74					      ldy	__temp
     54  7a74					      jsr	AddMove
     55  7a74
     56  7a74					      IF	{1} = WHITE
     57  7a74					      lda	#WHITE|WP
     58  7a74					      ENDIF
     59  7a74					      IF	{1} = BLACK
     60  7a74					      lda	#BLACK|BP
     61  7a74					      ENDIF
     62  7a74					      sta	currentPiece
     63  7a74					      ENDM
     64  7a74
     65  7a74							;---------------------------------------------------------------------------------------------------
     66  7a74
     67  7a74					      MAC	move_or_promote_pawn
     68  7a74							;SUBROUTINE
     69  7a74							; {1} = BLACK or WHITE
     70  7a74
     71  7a74					      IF	{1} = WHITE
     72  7a74					      cpy	#90	; last rank?
     73  7a74					      bcc	.standard
     74  7a74					      jsr	PromoteWhitePawn
     75  7a74					      jmp	.pMoved
     76  7a74					      ENDIF
     77  7a74
     78  7a74					      IF	{1} = BLACK
     79  7a74					      cpy	#30	; last rank?
     80  7a74					      bcs	.standard
     81  7a74					      jsr	PromoteBlackPawn
     82  7a74					      jmp	.pMoved
     83  7a74					      ENDIF
     84  7a74
     85  7a74				   .standard  jsr	AddMove	; add +1UP move
     86  7a74				   .pMoved
     87  7a74
     88  7a74					      ENDM
     89  7a74
     90  7a74							;---------------------------------------------------------------------------------------------------
     91  7a74
     92  7a74					      MAC	take
     93  7a74							;SUBROUTINE
     94  7a74							; {1} = capture square offset
     95  7a74
     96  7a74					      ldx	currentSquare
     97  7a74					      ldy	ValidSquare+{1},x
     98  7a74					      bmi	.invalid
     99  7a74					      lda	Board,y
    100  7a74					      beq	.invalid	; square empty
    101  7a74					      sta	capture
    102  7a74					      eor	currentPiece
    103  7a74					      bpl	.invalid	; same colour
    104  7a74
    105  7a74					      MOVE_OR_PROMOTE_PAWN	{2}
    106  7a74				   .invalid
    107  7a74					      ENDM
    108  7a74
    109  7a74							;---------------------------------------------------------------------------------------------------
    110  7a74
      0  7a74					      DEF	PromoteWhitePawn
      1  7a74				   BANK_PromoteWhitePawn SET	_CURRENT_BANK
      2  7a74				   PromoteWhitePawn
      3  7a74				   TEMPORARY_VAR SET	Overlay
      4  7a74				   TEMPORARY_OFFSET SET	0
      5  7a74				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      6  7a74				   FUNCTION_NAME SET	PromoteWhitePawn
      7  7a74					      SUBROUTINE
    112  7a74					      SUBROUTINE
    113  7a74
      0  7a74					      REFER	Handle_WHITE_PAWN
      1  7a74					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  7a74				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  7a74					      ENDIF
      0  7a74					      VAR	__temp, 1
      1  7a74		       00 b0	   __temp     =	TEMPORARY_VAR
      2  7a74				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7a74
      4  7a74				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7a74				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7a74				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7a74					      ENDIF
      8  7a74				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7a74				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  7a74				  -	      ERR
     11  7a74					      ENDIF
     12  7a74					      LIST	ON
      0  7a74					      VEND	PromoteWhitePawn
      1  7a74				  -	      IFNCONST	PromoteWhitePawn
      2  7a74				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  7a74				  -	      ERR
      4  7a74					      ENDIF
      5  7a74		       00 b1	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    117  7a74
      0  7a74					      PROMOTE_PAWN	WHITE
      1  7a74
      2  7a74
      3  7a74
      4  7a74
      5  7a74
      6  7a74		       84 b0		      sty	__temp
      7  7a76		       a9 06		      lda	#WHITE|QUEEN
      8  7a78		       85 92		      sta	currentPiece
      9  7a7a		       20 4d fc 	      jsr	AddMove
     10  7a7d
     11  7a7d		       a9 05		      lda	#WHITE|ROOK
     12  7a7f		       85 92		      sta	currentPiece
     13  7a81		       a4 b0		      ldy	__temp
     14  7a83		       20 4d fc 	      jsr	AddMove
     15  7a86
     16  7a86		       a9 04		      lda	#WHITE|BISHOP
     17  7a88		       85 92		      sta	currentPiece
     18  7a8a		       a4 b0		      ldy	__temp
     19  7a8c		       20 4d fc 	      jsr	AddMove
     20  7a8f
     21  7a8f		       a9 03		      lda	#WHITE|KNIGHT
     22  7a91		       85 92		      sta	currentPiece
     23  7a93		       a4 b0		      ldy	__temp
     24  7a95		       20 4d fc 	      jsr	AddMove
     25  7a98
     26  7a98					      IF	WHITE = WHITE
     27  7a98		       a9 01		      lda	#WHITE|WP
     28  7a9a					      ENDIF
     29  7a9a				  -	      IF	WHITE = BLACK
     30  7a9a				  -	      lda	#BLACK|BP
     31  7a9a					      ENDIF
     32  7a9a		       85 92		      sta	currentPiece
    119  7a9c		       60		      rts
    120  7a9d
    121  7a9d							;---------------------------------------------------------------------------------------------------
    122  7a9d
      0  7a9d					      DEF	Handle_WHITE_PAWN
      1  7a9d				   BANK_Handle_WHITE_PAWN SET	_CURRENT_BANK
      2  7a9d				   Handle_WHITE_PAWN
      3  7a9d				   TEMPORARY_VAR SET	Overlay
      4  7a9d				   TEMPORARY_OFFSET SET	0
      5  7a9d				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      6  7a9d				   FUNCTION_NAME SET	Handle_WHITE_PAWN
      7  7a9d					      SUBROUTINE
    124  7a9d					      SUBROUTINE
    125  7a9d
      0  7a9d					      REFER	GenerateAllMoves
      1  7a9d					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7a9d				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7a9d					      ENDIF
      0  7a9d					      VEND	Handle_WHITE_PAWN
      1  7a9d				  -	      IFNCONST	Handle_WHITE_PAWN
      2  7a9d				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  7a9d				  -	      ERR
      4  7a9d					      ENDIF
      5  7a9d		       00 b0	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    128  7a9d
    129  7a9d		       bc 1f f0 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    130  7aa0		       b9 79 f0 	      lda	Board,y
    131  7aa3		       d0 26		      bne	.pMoved	; occupied
    132  7aa5		       85 9f		      sta	capture
    133  7aa7
    134  7aa7							; we may need to promote the pawn
    135  7aa7							; All possibilites (Q/R/B/N) are added as individual moves
    136  7aa7
      0  7aa7					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7aa7
      2  7aa7
      3  7aa7
      4  7aa7					      IF	WHITE = WHITE
      5  7aa7		       c0 5a		      cpy	#90
      6  7aa9		       90 06		      bcc	.standard
      7  7aab		       20 74 fa 	      jsr	PromoteWhitePawn
      8  7aae		       4c b4 fa 	      jmp	.pMoved
      9  7ab1					      ENDIF
     10  7ab1
     11  7ab1				  -	      IF	WHITE = BLACK
     12  7ab1				  -	      cpy	#30
     13  7ab1				  -	      bcs	.standard
     14  7ab1				  -	      jsr	PromoteBlackPawn
     15  7ab1				  -	      jmp	.pMoved
     16  7ab1					      ENDIF
     17  7ab1
     18  7ab1		       20 4d fc    .standard  jsr	AddMove
     19  7ab4				   .pMoved
     20  7ab4
    138  7ab4
    139  7ab4							; the +2 move off the home rank...
    140  7ab4
    141  7ab4		       a6 93		      ldx	currentSquare
    142  7ab6		       e0 28		      cpx	#WHITE_HOME_ROW
    143  7ab8		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    144  7aba		       bc 29 f0 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    145  7abd		       b9 79 f0 	      lda	Board,y
    146  7ac0		       d0 09		      bne	.pMoved	; destination square occupied
    147  7ac2
    148  7ac2		       a5 92		      lda	currentPiece
    149  7ac4		       09 20		      ora	#FLAG_ENPASSANT
    150  7ac6		       85 92		      sta	currentPiece	; GENERATE en-passant opportunity
    151  7ac8
    152  7ac8		       20 4d fc 	      jsr	AddMove	; add the +2UP move off home row
    153  7acb
    154  7acb				   .pMoved
    155  7acb
    156  7acb							; regular captures...
    157  7acb
      0  7acb					      TAKE	_UP+_LEFT, WHITE
      1  7acb
      2  7acb
      3  7acb
      4  7acb		       a6 93		      ldx	currentSquare
      5  7acd		       bc 1e f0 	      ldy	ValidSquare+_UP+_LEFT,x
      6  7ad0		       30 18		      bmi	.invalid
      7  7ad2		       b9 79 f0 	      lda	Board,y
      8  7ad5		       f0 13		      beq	.invalid
      9  7ad7		       85 9f		      sta	capture
     10  7ad9		       45 92		      eor	currentPiece
     11  7adb		       10 0d		      bpl	.invalid
     12  7add
      0  7add					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7add
      2  7add
      3  7add
      4  7add					      IF	WHITE = WHITE
      5  7add		       c0 5a		      cpy	#90
      6  7adf		       90 06		      bcc	.standard
      7  7ae1		       20 74 fa 	      jsr	PromoteWhitePawn
      8  7ae4		       4c ea fa 	      jmp	.pMoved
      9  7ae7					      ENDIF
     10  7ae7
     11  7ae7				  -	      IF	WHITE = BLACK
     12  7ae7				  -	      cpy	#30
     13  7ae7				  -	      bcs	.standard
     14  7ae7				  -	      jsr	PromoteBlackPawn
     15  7ae7				  -	      jmp	.pMoved
     16  7ae7					      ENDIF
     17  7ae7
     18  7ae7		       20 4d fc    .standard  jsr	AddMove
     19  7aea				   .pMoved
     20  7aea
     14  7aea				   .invalid
      0  7aea					      TAKE	_UP+_RIGHT, WHITE
      1  7aea
      2  7aea
      3  7aea
      4  7aea		       a6 93		      ldx	currentSquare
      5  7aec		       bc 20 f0 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  7aef		       30 18		      bmi	.invalid
      7  7af1		       b9 79 f0 	      lda	Board,y
      8  7af4		       f0 13		      beq	.invalid
      9  7af6		       85 9f		      sta	capture
     10  7af8		       45 92		      eor	currentPiece
     11  7afa		       10 0d		      bpl	.invalid
     12  7afc
      0  7afc					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  7afc
      2  7afc
      3  7afc
      4  7afc					      IF	WHITE = WHITE
      5  7afc		       c0 5a		      cpy	#90
      6  7afe		       90 06		      bcc	.standard
      7  7b00		       20 74 fa 	      jsr	PromoteWhitePawn
      8  7b03		       4c 09 fb 	      jmp	.pMoved
      9  7b06					      ENDIF
     10  7b06
     11  7b06				  -	      IF	WHITE = BLACK
     12  7b06				  -	      cpy	#30
     13  7b06				  -	      bcs	.standard
     14  7b06				  -	      jsr	PromoteBlackPawn
     15  7b06				  -	      jmp	.pMoved
     16  7b06					      ENDIF
     17  7b06
     18  7b06		       20 4d fc    .standard  jsr	AddMove
     19  7b09				   .pMoved
     20  7b09
     14  7b09				   .invalid
    160  7b09
    161  7b09
    162  7b09				  -	      IF	ENPASSANT_ENABLED
    163  7b09				  -			; en-passant captures...
    164  7b09				  -
    165  7b09				  -	      lda	enPassantPawn
    166  7b09				  -	      beq	.noEnPassant	; previous move (opponent) enpassant square?
    167  7b09				  -
    168  7b09				  -	      lda	currentPiece
    169  7b09				  -	      ora	#FLAG_ENPASSANT
    170  7b09				  -	      sta	currentPiece	; CONSUME en-passant opportunity
    171  7b09				  -
    172  7b09				  -	      EN_PASSANT	_LEFT, _UP
    173  7b09				  -	      EN_PASSANT	_RIGHT, _UP
    174  7b09				  -
    175  7b09				  -.noEnPassant
    176  7b09					      ENDIF
    177  7b09
    178  7b09		       4c 02 f9 	      jmp	MoveReturn
    179  7b0c
    180  7b0c
    181  7b0c							;---------------------------------------------------------------------------------------------------
    182  7b0c							; BLACK PAWN
    183  7b0c							;---------------------------------------------------------------------------------------------------
    184  7b0c
      0  7b0c					      DEF	PromoteBlackPawn
      1  7b0c				   BANK_PromoteBlackPawn SET	_CURRENT_BANK
      2  7b0c				   PromoteBlackPawn
      3  7b0c				   TEMPORARY_VAR SET	Overlay
      4  7b0c				   TEMPORARY_OFFSET SET	0
      5  7b0c				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      6  7b0c				   FUNCTION_NAME SET	PromoteBlackPawn
      7  7b0c					      SUBROUTINE
    186  7b0c					      SUBROUTINE
    187  7b0c
      0  7b0c					      REFER	Handle_BLACK_PAWN
      1  7b0c					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  7b0c				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  7b0c					      ENDIF
      0  7b0c					      VAR	__temp, 1
      1  7b0c		       00 b0	   __temp     =	TEMPORARY_VAR
      2  7b0c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7b0c
      4  7b0c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7b0c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7b0c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7b0c					      ENDIF
      8  7b0c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7b0c				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  7b0c				  -	      ERR
     11  7b0c					      ENDIF
     12  7b0c					      LIST	ON
      0  7b0c					      VEND	PromoteBlackPawn
      1  7b0c				  -	      IFNCONST	PromoteBlackPawn
      2  7b0c				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  7b0c				  -	      ERR
      4  7b0c					      ENDIF
      5  7b0c		       00 b1	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    191  7b0c
      0  7b0c					      PROMOTE_PAWN	BLACK
      1  7b0c
      2  7b0c
      3  7b0c
      4  7b0c
      5  7b0c
      6  7b0c		       84 b0		      sty	__temp
      7  7b0e		       a9 86		      lda	#BLACK|QUEEN
      8  7b10		       85 92		      sta	currentPiece
      9  7b12		       20 4d fc 	      jsr	AddMove
     10  7b15
     11  7b15		       a9 85		      lda	#BLACK|ROOK
     12  7b17		       85 92		      sta	currentPiece
     13  7b19		       a4 b0		      ldy	__temp
     14  7b1b		       20 4d fc 	      jsr	AddMove
     15  7b1e
     16  7b1e		       a9 84		      lda	#BLACK|BISHOP
     17  7b20		       85 92		      sta	currentPiece
     18  7b22		       a4 b0		      ldy	__temp
     19  7b24		       20 4d fc 	      jsr	AddMove
     20  7b27
     21  7b27		       a9 83		      lda	#BLACK|KNIGHT
     22  7b29		       85 92		      sta	currentPiece
     23  7b2b		       a4 b0		      ldy	__temp
     24  7b2d		       20 4d fc 	      jsr	AddMove
     25  7b30
     26  7b30				  -	      IF	BLACK = WHITE
     27  7b30				  -	      lda	#WHITE|WP
     28  7b30					      ENDIF
     29  7b30					      IF	BLACK = BLACK
     30  7b30		       a9 82		      lda	#BLACK|BP
     31  7b32					      ENDIF
     32  7b32		       85 92		      sta	currentPiece
    193  7b34		       60		      rts
    194  7b35
      0  7b35					      DEF	Handle_BLACK_PAWN
      1  7b35				   BANK_Handle_BLACK_PAWN SET	_CURRENT_BANK
      2  7b35				   Handle_BLACK_PAWN
      3  7b35				   TEMPORARY_VAR SET	Overlay
      4  7b35				   TEMPORARY_OFFSET SET	0
      5  7b35				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      6  7b35				   FUNCTION_NAME SET	Handle_BLACK_PAWN
      7  7b35					      SUBROUTINE
    196  7b35					      SUBROUTINE
    197  7b35
      0  7b35					      REFER	GenerateAllMoves
      1  7b35					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7b35				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7b35					      ENDIF
      0  7b35					      VEND	Handle_BLACK_PAWN
      1  7b35				  -	      IFNCONST	Handle_BLACK_PAWN
      2  7b35				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  7b35				  -	      ERR
      4  7b35					      ENDIF
      5  7b35		       00 b0	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    200  7b35
    201  7b35		       bc 0b f0 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    202  7b38		       b9 79 f0 	      lda	Board,y
    203  7b3b		       d0 26		      bne	.pMoved	; occupied
    204  7b3d		       85 9f		      sta	capture
    205  7b3f
    206  7b3f							; we may need to promote the pawn
    207  7b3f							; All possibilites (Q/R/B/N) are added as individual moves
    208  7b3f
      0  7b3f					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7b3f
      2  7b3f
      3  7b3f
      4  7b3f				  -	      IF	BLACK = WHITE
      5  7b3f				  -	      cpy	#90
      6  7b3f				  -	      bcc	.standard
      7  7b3f				  -	      jsr	PromoteWhitePawn
      8  7b3f				  -	      jmp	.pMoved
      9  7b3f					      ENDIF
     10  7b3f
     11  7b3f					      IF	BLACK = BLACK
     12  7b3f		       c0 1e		      cpy	#30
     13  7b41		       b0 06		      bcs	.standard
     14  7b43		       20 0c fb 	      jsr	PromoteBlackPawn
     15  7b46		       4c 4c fb 	      jmp	.pMoved
     16  7b49					      ENDIF
     17  7b49
     18  7b49		       20 4d fc    .standard  jsr	AddMove
     19  7b4c				   .pMoved
     20  7b4c
    210  7b4c
    211  7b4c							; the +2 move off the home rank...
    212  7b4c
    213  7b4c		       a6 93		      ldx	currentSquare
    214  7b4e		       e0 52		      cpx	#BLACK_HOME_ROW
    215  7b50		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    216  7b52
    217  7b52
    218  7b52		       bc 01 f0 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    219  7b55		       b9 79 f0 	      lda	Board,y
    220  7b58		       d0 09		      bne	.pMoved	; destination square occupied
    221  7b5a
    222  7b5a		       a5 92		      lda	currentPiece
    223  7b5c		       09 20		      ora	#FLAG_ENPASSANT
    224  7b5e		       85 92		      sta	currentPiece	; CAN en-passant
    225  7b60
    226  7b60		       20 4d fc 	      jsr	AddMove	; add the +2DOWN move off home row
    227  7b63
    228  7b63				   .pMoved
    229  7b63
    230  7b63							; regular captures... (with promotion)
    231  7b63
      0  7b63					      TAKE	_DOWN+_LEFT, BLACK
      1  7b63
      2  7b63
      3  7b63
      4  7b63		       a6 93		      ldx	currentSquare
      5  7b65		       bc 0a f0 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  7b68		       30 18		      bmi	.invalid
      7  7b6a		       b9 79 f0 	      lda	Board,y
      8  7b6d		       f0 13		      beq	.invalid
      9  7b6f		       85 9f		      sta	capture
     10  7b71		       45 92		      eor	currentPiece
     11  7b73		       10 0d		      bpl	.invalid
     12  7b75
      0  7b75					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7b75
      2  7b75
      3  7b75
      4  7b75				  -	      IF	BLACK = WHITE
      5  7b75				  -	      cpy	#90
      6  7b75				  -	      bcc	.standard
      7  7b75				  -	      jsr	PromoteWhitePawn
      8  7b75				  -	      jmp	.pMoved
      9  7b75					      ENDIF
     10  7b75
     11  7b75					      IF	BLACK = BLACK
     12  7b75		       c0 1e		      cpy	#30
     13  7b77		       b0 06		      bcs	.standard
     14  7b79		       20 0c fb 	      jsr	PromoteBlackPawn
     15  7b7c		       4c 82 fb 	      jmp	.pMoved
     16  7b7f					      ENDIF
     17  7b7f
     18  7b7f		       20 4d fc    .standard  jsr	AddMove
     19  7b82				   .pMoved
     20  7b82
     14  7b82				   .invalid
      0  7b82					      TAKE	_DOWN+_RIGHT, BLACK
      1  7b82
      2  7b82
      3  7b82
      4  7b82		       a6 93		      ldx	currentSquare
      5  7b84		       bc 0c f0 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  7b87		       30 18		      bmi	.invalid
      7  7b89		       b9 79 f0 	      lda	Board,y
      8  7b8c		       f0 13		      beq	.invalid
      9  7b8e		       85 9f		      sta	capture
     10  7b90		       45 92		      eor	currentPiece
     11  7b92		       10 0d		      bpl	.invalid
     12  7b94
      0  7b94					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  7b94
      2  7b94
      3  7b94
      4  7b94				  -	      IF	BLACK = WHITE
      5  7b94				  -	      cpy	#90
      6  7b94				  -	      bcc	.standard
      7  7b94				  -	      jsr	PromoteWhitePawn
      8  7b94				  -	      jmp	.pMoved
      9  7b94					      ENDIF
     10  7b94
     11  7b94					      IF	BLACK = BLACK
     12  7b94		       c0 1e		      cpy	#30
     13  7b96		       b0 06		      bcs	.standard
     14  7b98		       20 0c fb 	      jsr	PromoteBlackPawn
     15  7b9b		       4c a1 fb 	      jmp	.pMoved
     16  7b9e					      ENDIF
     17  7b9e
     18  7b9e		       20 4d fc    .standard  jsr	AddMove
     19  7ba1				   .pMoved
     20  7ba1
     14  7ba1				   .invalid
    234  7ba1
    235  7ba1
    236  7ba1				  -	      IF	ENPASSANT_ENABLED
    237  7ba1				  -			; en-passant captures...
    238  7ba1				  -
    239  7ba1				  -	      lda	enPassantPawn
    240  7ba1				  -	      beq	.noEnPassant	; was last move en-passantable?
    241  7ba1				  -
    242  7ba1				  -	      lda	currentPiece
    243  7ba1				  -	      ora	#FLAG_ENPASSANT
    244  7ba1				  -	      sta	currentPiece	; any en-passant move added will have flag set
    245  7ba1				  -
    246  7ba1				  -	      EN_PASSANT	_LEFT, _DOWN
    247  7ba1				  -	      EN_PASSANT	_RIGHT, _DOWN
    248  7ba1				  -
    249  7ba1				  -.noEnPassant
    250  7ba1					      ENDIF
    251  7ba1
    252  7ba1		       4c 02 f9 	      jmp	MoveReturn
    253  7ba4
    254  7ba4							; EOF
------- FILE BANK_FIXED.asm
------- FILE Handler_KNIGHT.asm LEVEL 3 PASS 5
      0  7ba4					      include	"Handler_KNIGHT.asm"
      1  7ba4							; Copyright (C)2020 Andrew Davie
      2  7ba4							; Knight move handler
      3  7ba4
      4  7ba4							;---------------------------------------------------------------------------------------------------
      5  7ba4							; KNIGHT
      6  7ba4							;---------------------------------------------------------------------------------------------------
      7  7ba4
      0  7ba4					      DEF	Handle_KNIGHT
      1  7ba4				   BANK_Handle_KNIGHT SET	_CURRENT_BANK
      2  7ba4				   Handle_KNIGHT
      3  7ba4				   TEMPORARY_VAR SET	Overlay
      4  7ba4				   TEMPORARY_OFFSET SET	0
      5  7ba4				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      6  7ba4				   FUNCTION_NAME SET	Handle_KNIGHT
      7  7ba4					      SUBROUTINE
      9  7ba4					      SUBROUTINE
     10  7ba4
      0  7ba4					      REFER	GenerateAllMoves
      1  7ba4					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  7ba4				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  7ba4					      ENDIF
      0  7ba4					      VEND	Handle_KNIGHT
      1  7ba4				  -	      IFNCONST	Handle_KNIGHT
      2  7ba4				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  7ba4				  -	      ERR
      4  7ba4					      ENDIF
      5  7ba4		       00 b0	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  7ba4
     14  7ba4							; x = currentSquare (square the piece is on)
     15  7ba4							; currentPiece (with flags/colour attached)
     16  7ba4
      0  7ba4					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  7ba4					      SUBROUTINE
      2  7ba4		       bc 00 f0 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  7ba7		       30 0e		      bmi	.invalid
      4  7ba9		       b9 79 f0 	      lda	Board,y
      5  7bac		       85 9f		      sta	capture
      6  7bae		       f0 04		      beq	.squareEmpty
      7  7bb0		       45 92		      eor	currentPiece
      8  7bb2		       10 03		      bpl	.invalid
      9  7bb4		       20 4d fc    .squareEmpty jsr	AddMove
     10  7bb7				   .invalid
      0  7bb7					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  7bb7		       a6 93		      ldx	currentSquare
      0  7bb9					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  7bb9					      SUBROUTINE
      2  7bb9		       bc 02 f0 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  7bbc		       30 0e		      bmi	.invalid
      4  7bbe		       b9 79 f0 	      lda	Board,y
      5  7bc1		       85 9f		      sta	capture
      6  7bc3		       f0 04		      beq	.squareEmpty
      7  7bc5		       45 92		      eor	currentPiece
      8  7bc7		       10 03		      bpl	.invalid
      9  7bc9		       20 4d fc    .squareEmpty jsr	AddMove
     10  7bcc				   .invalid
      0  7bcc					      MOVE_TO_X	_UP+_UP+_LEFT
      1  7bcc		       a6 93		      ldx	currentSquare
      0  7bce					      MOVE_TO	_UP+_UP+_LEFT
      1  7bce					      SUBROUTINE
      2  7bce		       bc 28 f0 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  7bd1		       30 0e		      bmi	.invalid
      4  7bd3		       b9 79 f0 	      lda	Board,y
      5  7bd6		       85 9f		      sta	capture
      6  7bd8		       f0 04		      beq	.squareEmpty
      7  7bda		       45 92		      eor	currentPiece
      8  7bdc		       10 03		      bpl	.invalid
      9  7bde		       20 4d fc    .squareEmpty jsr	AddMove
     10  7be1				   .invalid
      0  7be1					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  7be1		       a6 93		      ldx	currentSquare
      0  7be3					      MOVE_TO	_UP+_UP+_RIGHT
      1  7be3					      SUBROUTINE
      2  7be3		       bc 2a f0 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  7be6		       30 0e		      bmi	.invalid
      4  7be8		       b9 79 f0 	      lda	Board,y
      5  7beb		       85 9f		      sta	capture
      6  7bed		       f0 04		      beq	.squareEmpty
      7  7bef		       45 92		      eor	currentPiece
      8  7bf1		       10 03		      bpl	.invalid
      9  7bf3		       20 4d fc    .squareEmpty jsr	AddMove
     10  7bf6				   .invalid
     21  7bf6
      0  7bf6					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  7bf6		       a6 93		      ldx	currentSquare
      0  7bf8					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  7bf8					      SUBROUTINE
      2  7bf8		       bc 09 f0 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  7bfb		       30 0e		      bmi	.invalid
      4  7bfd		       b9 79 f0 	      lda	Board,y
      5  7c00		       85 9f		      sta	capture
      6  7c02		       f0 04		      beq	.squareEmpty
      7  7c04		       45 92		      eor	currentPiece
      8  7c06		       10 03		      bpl	.invalid
      9  7c08		       20 4d fc    .squareEmpty jsr	AddMove
     10  7c0b				   .invalid
      0  7c0b					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  7c0b		       a6 93		      ldx	currentSquare
      0  7c0d					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  7c0d					      SUBROUTINE
      2  7c0d		       bc 0d f0 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  7c10		       30 0e		      bmi	.invalid
      4  7c12		       b9 79 f0 	      lda	Board,y
      5  7c15		       85 9f		      sta	capture
      6  7c17		       f0 04		      beq	.squareEmpty
      7  7c19		       45 92		      eor	currentPiece
      8  7c1b		       10 03		      bpl	.invalid
      9  7c1d		       20 4d fc    .squareEmpty jsr	AddMove
     10  7c20				   .invalid
      0  7c20					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  7c20		       a6 93		      ldx	currentSquare
      0  7c22					      MOVE_TO	_UP+_LEFT+_LEFT
      1  7c22					      SUBROUTINE
      2  7c22		       bc 1d f0 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  7c25		       30 0e		      bmi	.invalid
      4  7c27		       b9 79 f0 	      lda	Board,y
      5  7c2a		       85 9f		      sta	capture
      6  7c2c		       f0 04		      beq	.squareEmpty
      7  7c2e		       45 92		      eor	currentPiece
      8  7c30		       10 03		      bpl	.invalid
      9  7c32		       20 4d fc    .squareEmpty jsr	AddMove
     10  7c35				   .invalid
      0  7c35					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  7c35		       a6 93		      ldx	currentSquare
      0  7c37					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  7c37					      SUBROUTINE
      2  7c37		       bc 21 f0 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  7c3a		       30 0e		      bmi	.invalid
      4  7c3c		       b9 79 f0 	      lda	Board,y
      5  7c3f		       85 9f		      sta	capture
      6  7c41		       f0 04		      beq	.squareEmpty
      7  7c43		       45 92		      eor	currentPiece
      8  7c45		       10 03		      bpl	.invalid
      9  7c47		       20 4d fc    .squareEmpty jsr	AddMove
     10  7c4a				   .invalid
     26  7c4a
     27  7c4a		       4c 02 f9 	      jmp	MoveReturn
     28  7c4d
     29  7c4d							; EOF
------- FILE BANK_FIXED.asm
    733  7c4d
    734  7c4d							;---------------------------------------------------------------------------------------------------
    735  7c4d
      0  7c4d					      DEF	AddMove
      1  7c4d				   BANK_AddMove SET	_CURRENT_BANK
      2  7c4d				   AddMove
      3  7c4d				   TEMPORARY_VAR SET	Overlay
      4  7c4d				   TEMPORARY_OFFSET SET	0
      5  7c4d				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      6  7c4d				   FUNCTION_NAME SET	AddMove
      7  7c4d					      SUBROUTINE
    737  7c4d					      SUBROUTINE
    738  7c4d							; =57 including call
    739  7c4d
    740  7c4d							; add square in y register to movelist as destination (X12 format)
    741  7c4d							; [y]		     to square (X12)
    742  7c4d							; currentSquare     from square (X12)
    743  7c4d							; currentPiece      piece. ENPASSANT flag set if pawn double-moving off opening rank
    744  7c4d							; capture	     captured piece
    745  7c4d
    746  7c4d		       a5 95		      lda	currentPly	; 3
    747  7c4f		       85 3e		      sta	SET_BANK_RAM	; 3
    748  7c51
    749  7c51		       98		      tya		; 2
    750  7c52
      0  7c52					      ldy@RAM	moveIndex	; 3
      1  7c52		       ac 4f f1 	      ldy	moveIndex
    752  7c55		       c8		      iny		; 2
      0  7c56					      sty@RAM	moveIndex	; 4
      1  7c56		       8c 4f f5 	      sty	[RAM]+moveIndex
    754  7c59
      0  7c59					      sta@PLY	MoveTo,y	; 5
      1  7c59		       99 48 f4 	      sta	[RAM]+MoveTo,y
    756  7c5c		       aa		      tax		; 2 new square (for projections)
    757  7c5d
    758  7c5d		       a5 93		      lda	currentSquare	; 3
      0  7c5f					      sta@PLY	MoveFrom,y	; 5
      1  7c5f		       99 02 f4 	      sta	[RAM]+MoveFrom,y
    760  7c62		       a5 92		      lda	currentPiece	; 3
      0  7c64					      sta@PLY	MovePiece,y	; 5
      1  7c64		       99 8e f4 	      sta	[RAM]+MovePiece,y
    762  7c67		       a5 9f		      lda	capture	; 3
      0  7c69					      sta@PLY	MoveCapture,y	; 5
      1  7c69		       99 00 f5 	      sta	[RAM]+MoveCapture,y
    764  7c6c
    765  7c6c		       29 0f		      and	#PIECE_MASK
    766  7c6e		       c9 07		      cmp	#KING
    767  7c70		       d0 00		      bne	.nKing
    768  7c72
    769  7c72
    770  7c72
    771  7c72		       a9 08	   .nKing     lda	#RAMBANK_BOARD	; 2 TODO: NOT NEEDED IF FIXED BANK CALLED THIS
    772  7c74		       85 3e		      sta	SET_BANK_RAM	; 3
    773  7c76		       60		      rts		; 6
    774  7c77
    775  7c77
    776  7c77							;---------------------------------------------------------------------------------------------------
    777  7c77
      0  7c77					      DEF	InitialisePieceSquares
      1  7c77				   BANK_InitialisePieceSquares SET	_CURRENT_BANK
      2  7c77				   InitialisePieceSquares
      3  7c77				   TEMPORARY_VAR SET	Overlay
      4  7c77				   TEMPORARY_OFFSET SET	0
      5  7c77				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      6  7c77				   FUNCTION_NAME SET	InitialisePieceSquares
      7  7c77					      SUBROUTINE
    779  7c77					      SUBROUTINE
    780  7c77
      0  7c77					      REFER	Reset
      1  7c77				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  7c77				  -TEMPORARY_VAR SET	VAREND_Reset
      3  7c77					      ENDIF
      0  7c77					      VAR	__initPiece, 1
      1  7c77		       00 a2	   __initPiece =	TEMPORARY_VAR
      2  7c77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7c77
      4  7c77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c77					      ENDIF
      8  7c77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c77				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  7c77				  -	      ERR
     11  7c77					      ENDIF
     12  7c77					      LIST	ON
      0  7c77					      VAR	__initSquare, 1
      1  7c77		       00 a3	   __initSquare =	TEMPORARY_VAR
      2  7c77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7c77
      4  7c77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c77					      ENDIF
      8  7c77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c77				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  7c77				  -	      ERR
     11  7c77					      ENDIF
     12  7c77					      LIST	ON
      0  7c77					      VAR	__initListPtr, 1
      1  7c77		       00 a4	   __initListPtr =	TEMPORARY_VAR
      2  7c77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7c77
      4  7c77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7c77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7c77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7c77					      ENDIF
      8  7c77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7c77				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  7c77				  -	      ERR
     11  7c77					      ENDIF
     12  7c77					      LIST	ON
      0  7c77					      VEND	InitialisePieceSquares
      1  7c77				  -	      IFNCONST	InitialisePieceSquares
      2  7c77				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  7c77				  -	      ERR
      4  7c77					      ENDIF
      5  7c77		       00 a5	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    786  7c77
    787  7c77		       a9 09		      lda	#RAMBANK_PLY
    788  7c79		       85 3e		      sta	SET_BANK_RAM
    789  7c7b		       20 5b f1 	      jsr	InitPieceLists
    790  7c7e
    791  7c7e		       a2 00		      ldx	#0
    792  7c80		       86 94		      stx	enPassantPawn	; no en-passant
    793  7c82
    794  7c82
    795  7c82							; Now setup the board/piecelists
    796  7c82
    797  7c82		       a9 09	   .fillPieceLists lda	#RAMBANK_PLY
    798  7c84		       85 3e		      sta	SET_BANK_RAM
    799  7c86
    800  7c86		       bd 76 f1 	      lda	InitPieceList,x	; colour/-1
    801  7c89		       f0 4f		      beq	.exit
    802  7c8b		       85 af		      sta	__originalPiece	; type
    803  7c8d
    804  7c8d		       bc 77 f1 	      ldy	InitPieceList+1,x	; square
    805  7c90		       84 a3		      sty	__initSquare
    806  7c92		       a9 08		      lda	#RAMBANK_BOARD
    807  7c94		       85 3e		      sta	SET_BANK_RAM
    808  7c96		       a5 af		      lda	__originalPiece
      0  7c98					      sta@RAM	Board,y
      1  7c98		       99 79 f4 	      sta	[RAM]+Board,y
    810  7c9b
    811  7c9b		       10 0d		      bpl	.white
      0  7c9d					      NEGEVAL
      1  7c9d
      2  7c9d		       38		      sec
      3  7c9e		       a9 00		      lda	#0
      4  7ca0		       e5 90		      sbc	Evaluation
      5  7ca2		       85 90		      sta	Evaluation
      6  7ca4		       a9 00		      lda	#0
      7  7ca6		       e5 91		      sbc	Evaluation+1
      8  7ca8		       85 91		      sta	Evaluation+1
    813  7caa				   .white
    814  7caa
    815  7caa							; Add the material value of the piece to the evaluation
    816  7caa
    817  7caa		       a5 af		      lda	__originalPiece
    818  7cac		       29 0f		      and	#PIECE_MASK
    819  7cae		       a8		      tay
    820  7caf
      0  7caf					      JSROM	AddPieceMaterialValue
      1  7caf
      2  7caf		       a9 0c		      lda	#BANK_AddPieceMaterialValue
      3  7cb1		       85 3f		      sta	SET_BANK
      4  7cb3		       20 10 f0 	      jsr	AddPieceMaterialValue
    822  7cb6
    823  7cb6		       86 a4		      stx	__initListPtr
    824  7cb8
    825  7cb8							; add the positional value of the piece to the evaluation
    826  7cb8
    827  7cb8		       a4 a3		      ldy	__initSquare
    828  7cba		       a5 af		      lda	__originalPiece
    829  7cbc
    830  7cbc		       a2 0c		      ldx	#BANK_AddPiecePositionValue
    831  7cbe		       86 3f		      stx	SET_BANK
    832  7cc0		       20 23 f0 	      jsr	AddPiecePositionValue
    833  7cc3
    834  7cc3
    835  7cc3
    836  7cc3		       a5 af		      lda	__originalPiece	; type/colour
    837  7cc5		       10 0d		      bpl	.white2
      0  7cc7					      NEGEVAL
      1  7cc7
      2  7cc7		       38		      sec
      3  7cc8		       a9 00		      lda	#0
      4  7cca		       e5 90		      sbc	Evaluation
      5  7ccc		       85 90		      sta	Evaluation
      6  7cce		       a9 00		      lda	#0
      7  7cd0		       e5 91		      sbc	Evaluation+1
      8  7cd2		       85 91		      sta	Evaluation+1
    839  7cd4				   .white2
    840  7cd4
    841  7cd4		       a6 a4		      ldx	__initListPtr
    842  7cd6		       e8		      inx
    843  7cd7		       e8		      inx
    844  7cd8		       10 a8		      bpl	.fillPieceLists
    845  7cda
    846  7cda		       60	   .exit      rts
    847  7cdb
    848  7cdb
    849  7cdb							;---------------------------------------------------------------------------------------------------
    850  7cdb
      0  7cdb					      DEF	GetValid
      1  7cdb				   BANK_GetValid SET	_CURRENT_BANK
      2  7cdb				   GetValid
      3  7cdb				   TEMPORARY_VAR SET	Overlay
      4  7cdb				   TEMPORARY_OFFSET SET	0
      5  7cdb				   VAR_BOUNDARY_GetValid SET	TEMPORARY_OFFSET
      6  7cdb				   FUNCTION_NAME SET	GetValid
      7  7cdb					      SUBROUTINE
    852  7cdb		       a9 08		      lda	#RAMBANK_BOARD
    853  7cdd		       85 3e		      sta	SET_BANK_RAM
    854  7cdf		       b9 15 f0 	      lda	ValidSquare,y
    855  7ce2		       a4 8b		      ldy	savedBank
    856  7ce4		       84 3f		      sty	SET_BANK
    857  7ce6		       60		      rts
    858  7ce7
    859  7ce7
    860  7ce7							;---------------------------------------------------------------------------------------------------
    861  7ce7
      0  7ce7					      DEF	GetBoard
      1  7ce7				   BANK_GetBoard SET	_CURRENT_BANK
      2  7ce7				   GetBoard
      3  7ce7				   TEMPORARY_VAR SET	Overlay
      4  7ce7				   TEMPORARY_OFFSET SET	0
      5  7ce7				   VAR_BOUNDARY_GetBoard SET	TEMPORARY_OFFSET
      6  7ce7				   FUNCTION_NAME SET	GetBoard
      7  7ce7					      SUBROUTINE
    863  7ce7		       a9 08		      lda	#RAMBANK_BOARD
    864  7ce9		       85 3e		      sta	SET_BANK_RAM
    865  7ceb		       b9 79 f0 	      lda	Board,y
    866  7cee		       a4 8b		      ldy	savedBank
    867  7cf0		       84 3f		      sty	SET_BANK
    868  7cf2		       60		      rts
    869  7cf3
      0  7cf3					      DEF	GetBoardRAM
      1  7cf3				   BANK_GetBoardRAM SET	_CURRENT_BANK
      2  7cf3				   GetBoardRAM
      3  7cf3				   TEMPORARY_VAR SET	Overlay
      4  7cf3				   TEMPORARY_OFFSET SET	0
      5  7cf3				   VAR_BOUNDARY_GetBoardRAM SET	TEMPORARY_OFFSET
      6  7cf3				   FUNCTION_NAME SET	GetBoardRAM
      7  7cf3					      SUBROUTINE
    871  7cf3		       a9 08		      lda	#RAMBANK_BOARD
    872  7cf5		       85 3e		      sta	SET_BANK_RAM
    873  7cf7		       b9 79 f0 	      lda	Board,y
    874  7cfa		       a4 8b		      ldy	savedBank
    875  7cfc		       84 3e		      sty	SET_BANK_RAM
    876  7cfe		       60		      rts
    877  7cff
    878  7cff							;---------------------------------------------------------------------------------------------------
    879  7cff
      0  7cff					      DEF	PutBoard
      1  7cff				   BANK_PutBoard SET	_CURRENT_BANK
      2  7cff				   PutBoard
      3  7cff				   TEMPORARY_VAR SET	Overlay
      4  7cff				   TEMPORARY_OFFSET SET	0
      5  7cff				   VAR_BOUNDARY_PutBoard SET	TEMPORARY_OFFSET
      6  7cff				   FUNCTION_NAME SET	PutBoard
      7  7cff					      SUBROUTINE
    881  7cff		       a2 08		      ldx	#RAMBANK_BOARD
    882  7d01		       86 3e		      stx	SET_BANK_RAM
      0  7d03					      sta@RAM	Board,y	; and what's actually moving there
      1  7d03		       99 79 f4 	      sta	[RAM]+Board,y
    884  7d06		       a6 8b		      ldx	savedBank
    885  7d08		       86 3f		      stx	SET_BANK
    886  7d0a		       60		      rts
    887  7d0b
    888  7d0b
    889  7d0b							;---------------------------------------------------------------------------------------------------
    890  7d0b
      0  7d0b					      DEF	IsValidP_MoveFromSquare
      1  7d0b				   BANK_IsValidP_MoveFromSquare SET	_CURRENT_BANK
      2  7d0b				   IsValidP_MoveFromSquare
      3  7d0b				   TEMPORARY_VAR SET	Overlay
      4  7d0b				   TEMPORARY_OFFSET SET	0
      5  7d0b				   VAR_BOUNDARY_IsValidP_MoveFromSquare SET	TEMPORARY_OFFSET
      6  7d0b				   FUNCTION_NAME SET	IsValidP_MoveFromSquare
      7  7d0b					      SUBROUTINE
    892  7d0b					      SUBROUTINE
    893  7d0b
      0  7d0b					      REFER	aiSelectStartSquare
      1  7d0b				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  7d0b				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  7d0b					      ENDIF
      0  7d0b					      VEND	IsValidP_MoveFromSquare
      1  7d0b				  -	      IFNCONST	IsValidP_MoveFromSquare
      2  7d0b				  -	      ECHO	"Incorrect VEND label", IsValidP_MoveFromSquare
      3  7d0b				  -	      ERR
      4  7d0b					      ENDIF
      5  7d0b		       00 a2	   VAREND_IsValidP_MoveFromSquare =	TEMPORARY_VAR
    896  7d0b
    897  7d0b							; Does the square exist in the movelist?
    898  7d0b							; Return: y = -1 if NOT FOUND
    899  7d0b
    900  7d0b		       a5 88		      lda	cursorX12
    901  7d0d		       85 85		      sta	fromX12
    902  7d0f
    903  7d0f		       a4 95		      ldy	currentPly
    904  7d11		       84 3e		      sty	SET_BANK_RAM
    905  7d13		       20 cf f1 	      jsr	CheckMoveListFromSquare
    906  7d16
    907  7d16		       a5 8b		      lda	savedBank
    908  7d18		       85 3f		      sta	SET_BANK
    909  7d1a		       60		      rts
    910  7d1b
    911  7d1b
    912  7d1b							;---------------------------------------------------------------------------------------------------
    913  7d1b
      0  7d1b					      DEF	GetPiece
      1  7d1b				   BANK_GetPiece SET	_CURRENT_BANK
      2  7d1b				   GetPiece
      3  7d1b				   TEMPORARY_VAR SET	Overlay
      4  7d1b				   TEMPORARY_OFFSET SET	0
      5  7d1b				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      6  7d1b				   FUNCTION_NAME SET	GetPiece
      7  7d1b					      SUBROUTINE
    915  7d1b					      SUBROUTINE
    916  7d1b
      0  7d1b					      REFER	aiSelectDestinationSquare
      1  7d1b				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  7d1b				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  7d1b					      ENDIF
      0  7d1b					      REFER	aiQuiescent
      1  7d1b				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  7d1b				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  7d1b					      ENDIF
      0  7d1b					      VEND	GetPiece
      1  7d1b				  -	      IFNCONST	GetPiece
      2  7d1b				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  7d1b				  -	      ERR
      4  7d1b					      ENDIF
      5  7d1b		       00 a2	   VAREND_GetPiece =	TEMPORARY_VAR
    920  7d1b
    921  7d1b							; Retrieve the piece+flags from the movelist, given from/to squares
    922  7d1b							; Required as moves have different flags but same origin squares (e.g., castling)
    923  7d1b
    924  7d1b		       a5 95		      lda	currentPly
    925  7d1d		       85 3e		      sta	SET_BANK_RAM
    926  7d1f
    927  7d1f		       20 e3 f1 	      jsr	GetPieceGivenFromToSquares
    928  7d22
    929  7d22		       a5 8b		      lda	savedBank
    930  7d24		       85 3f		      sta	SET_BANK
    931  7d26		       60		      rts
    932  7d27
    933  7d27
    934  7d27							;---------------------------------------------------------------------------------------------------
    935  7d27
    936  7d27
      0  7d27					      DEF	CopyShadowROMtoRAM
      1  7d27				   BANK_CopyShadowROMtoRAM SET	_CURRENT_BANK
      2  7d27				   CopyShadowROMtoRAM
      3  7d27				   TEMPORARY_VAR SET	Overlay
      4  7d27				   TEMPORARY_OFFSET SET	0
      5  7d27				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      6  7d27				   FUNCTION_NAME SET	CopyShadowROMtoRAM
      7  7d27					      SUBROUTINE
    938  7d27					      SUBROUTINE
    939  7d27
      0  7d27					      REFER	SetupBanks
      1  7d27					      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  7d27				   TEMPORARY_VAR SET	VAREND_SetupBanks
      3  7d27					      ENDIF
      0  7d27					      VAR	__destinationBank, 1
      1  7d27		       00 a3	   __destinationBank =	TEMPORARY_VAR
      2  7d27				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7d27
      4  7d27				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7d27				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7d27				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7d27					      ENDIF
      8  7d27				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7d27				  -	      ECHO	"Temporary Variable", __destinationBank, "overflow!"
     10  7d27				  -	      ERR
     11  7d27					      ENDIF
     12  7d27					      LIST	ON
      0  7d27					      VAR	__sourceBank, 1
      1  7d27		       00 a4	   __sourceBank =	TEMPORARY_VAR
      2  7d27				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7d27
      4  7d27				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7d27				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7d27				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7d27					      ENDIF
      8  7d27				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7d27				  -	      ECHO	"Temporary Variable", __sourceBank, "overflow!"
     10  7d27				  -	      ERR
     11  7d27					      ENDIF
     12  7d27					      LIST	ON
      0  7d27					      VEND	CopyShadowROMtoRAM
      1  7d27				  -	      IFNCONST	CopyShadowROMtoRAM
      2  7d27				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  7d27				  -	      ERR
      4  7d27					      ENDIF
      5  7d27		       00 a5	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    944  7d27
    945  7d27							; Copy a whole 1K ROM SHADOW into a destination RAM 1K bank
    946  7d27							; used to setup callable RAM code from ROM templates
    947  7d27
    948  7d27							; x = source ROM bank
    949  7d27							; y = destination RAM bank (preserved)
    950  7d27
    951  7d27		       86 a4		      stx	__sourceBank
    952  7d29
    953  7d29		       a2 00		      ldx	#0
    954  7d2b		       a5 a4	   .copyPage  lda	__sourceBank
    955  7d2d		       85 3f		      sta	SET_BANK
    956  7d2f
    957  7d2f		       bd 00 f0 	      lda	$F000,x
    958  7d32		       48		      pha
    959  7d33		       bd 00 f1 	      lda	$F100,x
    960  7d36		       48		      pha
    961  7d37		       bd 00 f2 	      lda	$F200,x
    962  7d3a		       48		      pha
    963  7d3b		       bd 00 f3 	      lda	$F300,x
    964  7d3e
    965  7d3e		       84 3e		      sty	SET_BANK_RAM
    966  7d40
      0  7d40					      sta@RAM	$F300,x
      1  7d40		       9d 00 f7 	      sta	[RAM]+$F300,x
    968  7d43		       68		      pla
      0  7d44					      sta@RAM	$F200,x
      1  7d44		       9d 00 f6 	      sta	[RAM]+$F200,x
    970  7d47		       68		      pla
      0  7d48					      sta@RAM	$F100,x
      1  7d48		       9d 00 f5 	      sta	[RAM]+$F100,x
    972  7d4b		       68		      pla
      0  7d4c					      sta@RAM	$F000,x
      1  7d4c		       9d 00 f4 	      sta	[RAM]+$F000,x
    974  7d4f
    975  7d4f		       ca		      dex
    976  7d50		       d0 d9		      bne	.copyPage
    977  7d52
    978  7d52		       a5 8b		      lda	savedBank
    979  7d54		       85 3f		      sta	SET_BANK
    980  7d56		       60		      rts
    981  7d57
    982  7d57
    983  7d57							;---------------------------------------------------------------------------------------------------
    984  7d57
      0  7d57					      DEF	CopySinglePiece
      1  7d57				   BANK_CopySinglePiece SET	_CURRENT_BANK
      2  7d57				   CopySinglePiece
      3  7d57				   TEMPORARY_VAR SET	Overlay
      4  7d57				   TEMPORARY_OFFSET SET	0
      5  7d57				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      6  7d57				   FUNCTION_NAME SET	CopySinglePiece
      7  7d57					      SUBROUTINE
    986  7d57					      SUBROUTINE
      0  7d57					      TIMING	COPYSINGLEPIECE, (2600)
      1  7d57		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    988  7d57
      0  7d57					      REFER	aiDrawEntireBoard
      1  7d57				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  7d57					      ENDIF
      0  7d57					      REFER	SpecialBody
      1  7d57					      IF	VAREND_SpecialBody > TEMPORARY_VAR
      2  7d57				   TEMPORARY_VAR SET	VAREND_SpecialBody
      3  7d57					      ENDIF
      0  7d57					      REFER	aiWriteStartPieceBlank
      1  7d57				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  7d57					      ENDIF
      0  7d57					      REFER	aiDrawPart2
      1  7d57				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  7d57					      ENDIF
      0  7d57					      REFER	aiMarchB
      1  7d57				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  7d57					      ENDIF
      0  7d57					      REFER	aiFinalFlash
      1  7d57				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  7d57					      ENDIF
      0  7d57					      REFER	UNSAFE_showP_MoveCaptures
      1  7d57				  -	      IF	VAREND_UNSAFE_showP_MoveCaptures > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_UNSAFE_showP_MoveCaptures
      3  7d57					      ENDIF
      0  7d57					      REFER	aiMarchToTargetA
      1  7d57				  -	      IF	VAREND_aiMarchToTargetA > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetA
      3  7d57					      ENDIF
      0  7d57					      REFER	aiMarchB2
      1  7d57				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  7d57					      ENDIF
      0  7d57					      REFER	aiMarchToTargetB
      1  7d57				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  7d57					      ENDIF
      0  7d57					      REFER	FlashPiece
      1  7d57				  -	      IF	VAREND_FlashPiece > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_FlashPiece
      3  7d57					      ENDIF
      0  7d57					      REFER	aiPromotePawnStart
      1  7d57				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  7d57					      ENDIF
      0  7d57					      REFER	aiChoosePromotePiece
      1  7d57				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  7d57				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  7d57					      ENDIF
      0  7d57					      VEND	CopySinglePiece
      1  7d57				  -	      IFNCONST	CopySinglePiece
      2  7d57				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  7d57				  -	      ERR
      4  7d57					      ENDIF
      5  7d57		       00 ad	   VAREND_CopySinglePiece =	TEMPORARY_VAR
   1003  7d57
   1004  7d57							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
   1005  7d57							; ALSO CAN'T USE IN THIS ROUTINE
   1006  7d57							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
   1007  7d57							; @2150 max
   1008  7d57							; = 33 TIM64T
   1009  7d57
      0  7d57					      JSROM	CopySetup
      1  7d57
      2  7d57		       a9 09		      lda	#BANK_CopySetup
      3  7d59		       85 3f		      sta	SET_BANK
      4  7d5b		       20 36 f1 	      jsr	CopySetup
   1011  7d5e
      0  7d5e					      DEF	InterceptMarkerCopy
      1  7d5e				   BANK_InterceptMarkerCopy SET	_CURRENT_BANK
      2  7d5e				   InterceptMarkerCopy
      3  7d5e				   TEMPORARY_VAR SET	Overlay
      4  7d5e				   TEMPORARY_OFFSET SET	0
      5  7d5e				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      6  7d5e				   FUNCTION_NAME SET	InterceptMarkerCopy
      7  7d5e					      SUBROUTINE
   1013  7d5e					      SUBROUTINE
   1014  7d5e
   1015  7d5e
   1016  7d5e							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
   1017  7d5e							; y = piece index
   1018  7d5e
   1019  7d5e		       a9 00		      lda	#BANK_PIECE_VECTOR_BANK
   1020  7d60		       85 3f		      sta	SET_BANK
   1021  7d62
   1022  7d62		       b9 17 f1 	      lda	PIECE_VECTOR_LO,y
   1023  7d65		       85 ea		      sta	__ptr
   1024  7d67		       b9 a7 f1 	      lda	PIECE_VECTOR_HI,y
   1025  7d6a		       85 eb		      sta	__ptr+1
   1026  7d6c		       b9 37 f2 	      lda	PIECE_VECTOR_BANK,y
   1027  7d6f		       85 3f		      sta	SET_BANK
   1028  7d71
   1029  7d71		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
   1030  7d73		       b1 ea	   .copy      lda	(__ptr),y
   1031  7d75		       99 a2 00 	      sta	__pieceShapeBuffer,y
   1032  7d78		       88		      dey
   1033  7d79		       10 f8		      bpl	.copy
   1034  7d7b
   1035  7d7b		       a5 80		      lda	squareToDraw
   1036  7d7d		       38		      sec
   1037  7d7e		       a2 0a		      ldx	#10
   1038  7d80		       e9 0a	   .sub10     sbc	#10
   1039  7d82		       ca		      dex
   1040  7d83		       b0 fb		      bcs	.sub10
   1041  7d85
   1042  7d85		       86 3e		      stx	SET_BANK_RAM	; row
   1043  7d87
   1044  7d87		       69 08		      adc	#8
   1045  7d89		       c9 04		      cmp	#4	; CS = right side of screen
   1046  7d8b
   1047  7d8b		       20 9b f1 	      jsr	CopyPieceToRowBitmap
   1048  7d8e
   1049  7d8e		       a5 8b		      lda	savedBank
   1050  7d90		       85 3f		      sta	SET_BANK
   1051  7d92		       60		      rts
   1052  7d93
   1053  7d93
   1054  7d93							;---------------------------------------------------------------------------------------------------
   1055  7d93
      0  7d93					      DEF	SAFE_getMoveIndex
      1  7d93				   BANK_SAFE_getMoveIndex SET	_CURRENT_BANK
      2  7d93				   SAFE_getMoveIndex
      3  7d93				   TEMPORARY_VAR SET	Overlay
      4  7d93				   TEMPORARY_OFFSET SET	0
      5  7d93				   VAR_BOUNDARY_SAFE_getMoveIndex SET	TEMPORARY_OFFSET
      6  7d93				   FUNCTION_NAME SET	SAFE_getMoveIndex
      7  7d93					      SUBROUTINE
   1057  7d93					      SUBROUTINE
   1058  7d93
   1059  7d93		       a9 09		      lda	#RAMBANK_PLY
   1060  7d95		       85 3e		      sta	SET_BANK_RAM
      0  7d97					      lda@PLY	moveIndex
      1  7d97		       ad 4f f1 	      lda	moveIndex
   1062  7d9a		       a6 8b		      ldx	savedBank
   1063  7d9c		       86 3f		      stx	SET_BANK
   1064  7d9e		       60		      rts
   1065  7d9f
   1066  7d9f
   1067  7d9f							;---------------------------------------------------------------------------------------------------
   1068  7d9f
   1069  7d9f				  -	      if	0
   1070  7d9f				  -	      DEF	GoFixPieceList
   1071  7d9f				  -
   1072  7d9f				  -	      sta	SET_BANK_RAM
   1073  7d9f				  -	      jsr	FixPieceList
   1074  7d9f				  -	      lda	savedBank
   1075  7d9f				  -	      sta	SET_BANK
   1076  7d9f				  -	      rts
   1077  7d9f					      endif
   1078  7d9f
   1079  7d9f							;---------------------------------------------------------------------------------------------------
   1080  7d9f
      0  7d9f					      DEF	markerDraw
      1  7d9f				   BANK_markerDraw SET	_CURRENT_BANK
      2  7d9f				   markerDraw
      3  7d9f				   TEMPORARY_VAR SET	Overlay
      4  7d9f				   TEMPORARY_OFFSET SET	0
      5  7d9f				   VAR_BOUNDARY_markerDraw SET	TEMPORARY_OFFSET
      6  7d9f				   FUNCTION_NAME SET	markerDraw
      7  7d9f					      SUBROUTINE
   1082  7d9f					      SUBROUTINE
   1083  7d9f
      0  7d9f					      REFER	SAFE_showMoveOptions
      1  7d9f					      IF	VAREND_SAFE_showMoveOptions > TEMPORARY_VAR
      2  7d9f				   TEMPORARY_VAR SET	VAREND_SAFE_showMoveOptions
      3  7d9f					      ENDIF
      0  7d9f					      VEND	markerDraw
      1  7d9f				  -	      IFNCONST	markerDraw
      2  7d9f				  -	      ECHO	"Incorrect VEND label", markerDraw
      3  7d9f				  -	      ERR
      4  7d9f					      ENDIF
      5  7d9f		       00 a4	   VAREND_markerDraw =	TEMPORARY_VAR
   1086  7d9f
   1087  7d9f		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
      0  7da1					      JSROM	CopySetupForMarker
      1  7da1
      2  7da1		       a9 09		      lda	#BANK_CopySetupForMarker
      3  7da3		       85 3f		      sta	SET_BANK
      4  7da5		       20 0b f1 	      jsr	CopySetupForMarker
   1089  7da8		       4c 5e fd 	      jmp	InterceptMarkerCopy
   1090  7dab
   1091  7dab
   1092  7dab							;---------------------------------------------------------------------------------------------------
   1093  7dab
      0  7dab					      DEF	showPromoteOptions
      1  7dab				   BANK_showPromoteOptions SET	_CURRENT_BANK
      2  7dab				   showPromoteOptions
      3  7dab				   TEMPORARY_VAR SET	Overlay
      4  7dab				   TEMPORARY_OFFSET SET	0
      5  7dab				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      6  7dab				   FUNCTION_NAME SET	showPromoteOptions
      7  7dab					      SUBROUTINE
   1095  7dab					      SUBROUTINE
   1096  7dab
      0  7dab					      REFER	aiRollPromotionPiece
      1  7dab				  -	      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  7dab				  -TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  7dab					      ENDIF
      0  7dab					      REFER	aiChoosePromotePiece
      1  7dab				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  7dab				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  7dab					      ENDIF
      0  7dab					      VEND	showPromoteOptions
      1  7dab				  -	      IFNCONST	showPromoteOptions
      2  7dab				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  7dab				  -	      ERR
      4  7dab					      ENDIF
      5  7dab		       00 a2	   VAREND_showPromoteOptions =	TEMPORARY_VAR
   1100  7dab
   1101  7dab							; X = character shape # (?/N/B/R/Q)
   1102  7dab
   1103  7dab		       a4 86		      ldy	toX12
   1104  7dad		       84 80		      sty	squareToDraw
   1105  7daf
      0  7daf					      JSROM	CopySetupForMarker
      1  7daf
      2  7daf		       a9 09		      lda	#BANK_CopySetupForMarker
      3  7db1		       85 3f		      sta	SET_BANK
      4  7db3		       20 0b f1 	      jsr	CopySetupForMarker
   1107  7db6		       4c 5e fd 	      jmp	InterceptMarkerCopy
   1108  7db9
   1109  7db9
   1110  7db9							;---------------------------------------------------------------------------------------------------
   1111  7db9
      0  7db9					      DEF	SAFE_BackupBitmaps
      1  7db9				   BANK_SAFE_BackupBitmaps SET	_CURRENT_BANK
      2  7db9				   SAFE_BackupBitmaps
      3  7db9				   TEMPORARY_VAR SET	Overlay
      4  7db9				   TEMPORARY_OFFSET SET	0
      5  7db9				   VAR_BOUNDARY_SAFE_BackupBitmaps SET	TEMPORARY_OFFSET
      6  7db9				   FUNCTION_NAME SET	SAFE_BackupBitmaps
      7  7db9					      SUBROUTINE
   1113  7db9					      SUBROUTINE
   1114  7db9
      0  7db9					      VEND	SAFE_BackupBitmaps
      1  7db9				  -	      IFNCONST	SAFE_BackupBitmaps
      2  7db9				  -	      ECHO	"Incorrect VEND label", SAFE_BackupBitmaps
      3  7db9				  -	      ERR
      4  7db9					      ENDIF
      5  7db9		       00 a2	   VAREND_SAFE_BackupBitmaps =	TEMPORARY_VAR
   1116  7db9
   1117  7db9		       84 3e		      sty	SET_BANK_RAM
   1118  7dbb		       20 f4 f2 	      jsr	SaveBitmap
   1119  7dbe		       a5 8b		      lda	savedBank
   1120  7dc0		       85 3f		      sta	SET_BANK
   1121  7dc2		       60		      rts
   1122  7dc3
   1123  7dc3
   1124  7dc3							;---------------------------------------------------------------------------------------------------
   1125  7dc3
   1126  7dc3				  -	      if	0
   1127  7dc3				  -	      DEF	Go_IsSquareUnderAttack
   1128  7dc3				  -	      SUBROUTINE
   1129  7dc3				  -
   1130  7dc3				  -			;REFER aiLookForCheck
   1131  7dc3				  -	      VEND	Go_IsSquareUnderAttack
   1132  7dc3				  -
   1133  7dc3				  -			; Check if passed X12 square is in the "TO" squares in the movelist (and thus under attack)
   1134  7dc3				  -
   1135  7dc3				  -			; Pass:	 currentPly = which movelist to check
   1136  7dc3				  -			;		 A = X12 square to check
   1137  7dc3				  -			; Return:	 CC = No, CS = Yes
   1138  7dc3				  -
   1139  7dc3				  -	      ldx	currentPly
   1140  7dc3				  -	      stx	SET_BANK_RAM
   1141  7dc3				  -	      jsr	IsSquareUnderAttack
   1142  7dc3				  -	      lda	savedBank
   1143  7dc3				  -	      sta	SET_BANK
   1144  7dc3				  -	      rts
   1145  7dc3					      endif
   1146  7dc3
   1147  7dc3							;---------------------------------------------------------------------------------------------------
   1148  7dc3
      0  7dc3					      DEF	SAFE_showP_MoveCaptures
      1  7dc3				   BANK_SAFE_showP_MoveCaptures SET	_CURRENT_BANK
      2  7dc3				   SAFE_showP_MoveCaptures
      3  7dc3				   TEMPORARY_VAR SET	Overlay
      4  7dc3				   TEMPORARY_OFFSET SET	0
      5  7dc3				   VAR_BOUNDARY_SAFE_showP_MoveCaptures SET	TEMPORARY_OFFSET
      6  7dc3				   FUNCTION_NAME SET	SAFE_showP_MoveCaptures
      7  7dc3					      SUBROUTINE
   1150  7dc3					      SUBROUTINE
   1151  7dc3
      0  7dc3					      VEND	SAFE_showP_MoveCaptures
      1  7dc3				  -	      IFNCONST	SAFE_showP_MoveCaptures
      2  7dc3				  -	      ECHO	"Incorrect VEND label", SAFE_showP_MoveCaptures
      3  7dc3				  -	      ERR
      4  7dc3					      ENDIF
      5  7dc3		       00 a2	   VAREND_SAFE_showP_MoveCaptures =	TEMPORARY_VAR
   1153  7dc3
      0  7dc3					      JSROM	UNSAFE_showP_MoveCaptures
      1  7dc3
      2  7dc3		       a9 09		      lda	#BANK_UNSAFE_showP_MoveCaptures
      3  7dc5		       85 3f		      sta	SET_BANK
      4  7dc7		       20 00 f0 	      jsr	UNSAFE_showP_MoveCaptures
   1155  7dca		       a5 8b		      lda	savedBank
   1156  7dcc		       85 3f		      sta	SET_BANK
   1157  7dce		       60		      rts
   1158  7dcf
   1159  7dcf
   1160  7dcf							;---------------------------------------------------------------------------------------------------
   1161  7dcf
      0  7dcf					      DEF	GetP_MoveFrom
      1  7dcf				   BANK_GetP_MoveFrom SET	_CURRENT_BANK
      2  7dcf				   GetP_MoveFrom
      3  7dcf				   TEMPORARY_VAR SET	Overlay
      4  7dcf				   TEMPORARY_OFFSET SET	0
      5  7dcf				   VAR_BOUNDARY_GetP_MoveFrom SET	TEMPORARY_OFFSET
      6  7dcf				   FUNCTION_NAME SET	GetP_MoveFrom
      7  7dcf					      SUBROUTINE
   1163  7dcf		       a9 09		      lda	#RAMBANK_PLY
   1164  7dd1		       85 3e		      sta	SET_BANK_RAM
   1165  7dd3		       a4 8b		      ldy	savedBank
      0  7dd5					      lda@PLY	MoveFrom,x
      1  7dd5		       bd 02 f0 	      lda	MoveFrom,x
   1167  7dd8		       84 3f		      sty	SET_BANK
   1168  7dda		       60		      rts
   1169  7ddb
   1170  7ddb
   1171  7ddb							;---------------------------------------------------------------------------------------------------
   1172  7ddb
      0  7ddb					      DEF	GetP_MoveTo
      1  7ddb				   BANK_GetP_MoveTo SET	_CURRENT_BANK
      2  7ddb				   GetP_MoveTo
      3  7ddb				   TEMPORARY_VAR SET	Overlay
      4  7ddb				   TEMPORARY_OFFSET SET	0
      5  7ddb				   VAR_BOUNDARY_GetP_MoveTo SET	TEMPORARY_OFFSET
      6  7ddb				   FUNCTION_NAME SET	GetP_MoveTo
      7  7ddb					      SUBROUTINE
   1174  7ddb					      SUBROUTINE
   1175  7ddb
   1176  7ddb		       a9 09		      lda	#RAMBANK_PLY
   1177  7ddd		       85 3e		      sta	SET_BANK_RAM
   1178  7ddf		       a4 8b		      ldy	savedBank
      0  7de1					      lda@PLY	MoveTo,x
      1  7de1		       bd 48 f0 	      lda	MoveTo,x
   1180  7de4		       84 3f		      sty	SET_BANK
   1181  7de6		       60		      rts
   1182  7de7
   1183  7de7
   1184  7de7							;---------------------------------------------------------------------------------------------------
   1185  7de7
      0  7de7					      DEF	GetP_MovePiece
      1  7de7				   BANK_GetP_MovePiece SET	_CURRENT_BANK
      2  7de7				   GetP_MovePiece
      3  7de7				   TEMPORARY_VAR SET	Overlay
      4  7de7				   TEMPORARY_OFFSET SET	0
      5  7de7				   VAR_BOUNDARY_GetP_MovePiece SET	TEMPORARY_OFFSET
      6  7de7				   FUNCTION_NAME SET	GetP_MovePiece
      7  7de7					      SUBROUTINE
   1187  7de7					      SUBROUTINE
   1188  7de7
   1189  7de7		       a9 09		      lda	#RAMBANK_PLY
   1190  7de9		       85 3e		      sta	SET_BANK_RAM
   1191  7deb		       a4 8b		      ldy	savedBank
      0  7ded					      lda@PLY	MovePiece,x
      1  7ded		       bd 8e f0 	      lda	MovePiece,x
   1193  7df0		       84 3f		      sty	SET_BANK
   1194  7df2		       60		      rts
   1195  7df3
   1196  7df3
   1197  7df3							;---------------------------------------------------------------------------------------------------
   1198  7df3
      0  7df3					      DEF	MakeMove
      1  7df3				   BANK_MakeMove SET	_CURRENT_BANK
      2  7df3				   MakeMove
      3  7df3				   TEMPORARY_VAR SET	Overlay
      4  7df3				   TEMPORARY_OFFSET SET	0
      5  7df3				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      6  7df3				   FUNCTION_NAME SET	MakeMove
      7  7df3					      SUBROUTINE
   1200  7df3					      SUBROUTINE
   1201  7df3
      0  7df3					      REFER	negamax
      1  7df3					      IF	VAREND_negamax > TEMPORARY_VAR
      2  7df3				   TEMPORARY_VAR SET	VAREND_negamax
      3  7df3					      ENDIF
      0  7df3					      VAR	__capture, 1
      1  7df3		       00 ad	   __capture  =	TEMPORARY_VAR
      2  7df3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7df3
      4  7df3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7df3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7df3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7df3					      ENDIF
      8  7df3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7df3				  -	      ECHO	"Temporary Variable", __capture, "overflow!"
     10  7df3				  -	      ERR
     11  7df3					      ENDIF
     12  7df3					      LIST	ON
      0  7df3					      VAR	__restore, 1
      1  7df3		       00 ae	   __restore  =	TEMPORARY_VAR
      2  7df3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7df3
      4  7df3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7df3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7df3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7df3					      ENDIF
      8  7df3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7df3				  -	      ECHO	"Temporary Variable", __restore, "overflow!"
     10  7df3				  -	      ERR
     11  7df3					      ENDIF
     12  7df3					      LIST	ON
      0  7df3					      VEND	MakeMove
      1  7df3				  -	      IFNCONST	MakeMove
      2  7df3				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  7df3				  -	      ERR
      4  7df3					      ENDIF
      5  7df3		       00 af	   VAREND_MakeMove =	TEMPORARY_VAR
   1206  7df3
   1207  7df3							; Do a move without any GUI stuff
   1208  7df3							; This function is ALWAYS paired with "unmake_move" - a call to both will leave board
   1209  7df3							; and all relevant flags in original state. This is NOT used for the visible move on the
   1210  7df3							; screen.
   1211  7df3
   1212  7df3
   1213  7df3							; fromPiece	 piece doing the move
   1214  7df3							; fromX12	 current square X12
   1215  7df3							; originX12	 starting square X12
   1216  7df3							; toX12	 ending square X12
   1217  7df3
   1218  7df3
   1219  7df3							; There are potentially "two" moves, with the following
   1220  7df3							; a) Castling, moving both rook and king
   1221  7df3							; b) en-Passant, capturing pawn on "odd" square
   1222  7df3							; These both set "secondary" movers which are used for restoring during unmake_move
   1223  7df3
   1224  7df3		       a9 00		      lda	#0
      0  7df5					      sta@RAM	secondaryPiece
      1  7df5		       8d 4a f5 	      sta	[RAM]+secondaryPiece
   1226  7df8
   1227  7df8		       ae 50 f1 	      ldx	movePtr
      0  7dfb					      lda@PLY	MoveFrom,x
      1  7dfb		       bd 02 f0 	      lda	MoveFrom,x
   1229  7dfe		       85 85		      sta	fromX12
   1230  7e00		       85 87		      sta	originX12
      0  7e02					      lda@PLY	MoveTo,x
      1  7e02		       bd 48 f0 	      lda	MoveTo,x
   1232  7e05		       85 86		      sta	toX12
      0  7e07					      lda@PLY	MovePiece,x
      1  7e07		       bd 8e f0 	      lda	MovePiece,x
   1234  7e0a		       85 98		      sta	fromPiece
   1235  7e0c
   1236  7e0c		       20 b0 f9    .move      jsr	AdjustMaterialPositionalValue
   1237  7e0f
   1238  7e0f							; Modify the board
   1239  7e0f
   1240  7e0f		       a0 08		      ldy	#RAMBANK_BOARD
   1241  7e11		       84 3e		      sty	SET_BANK_RAM
   1242  7e13		       a4 87		      ldy	originX12
   1243  7e15		       b9 79 f0 	      lda	Board,y
   1244  7e18		       85 ae		      sta	__restore
   1245  7e1a		       a9 00		      lda	#0
      0  7e1c					      sta@RAM	Board,y
      1  7e1c		       99 79 f4 	      sta	[RAM]+Board,y
   1247  7e1f		       a4 86		      ldy	toX12
   1248  7e21		       b9 79 f0 	      lda	Board,y
   1249  7e24		       85 ad		      sta	__capture
   1250  7e26		       a5 98		      lda	fromPiece
   1251  7e28		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
   1252  7e2a		       09 40		      ora	#FLAG_MOVED
      0  7e2c					      sta@RAM	Board,y
      1  7e2c		       99 79 f4 	      sta	[RAM]+Board,y
   1254  7e2f
   1255  7e2f		       a5 95		      lda	currentPly
   1256  7e31		       85 3e		      sta	SET_BANK_RAM
   1257  7e33		       a5 ad		      lda	__capture
      0  7e35					      sta@RAM	capturedPiece
      1  7e35		       8d 48 f5 	      sta	[RAM]+capturedPiece
   1259  7e38		       a5 ae		      lda	__restore
      0  7e3a					      sta@RAM	restorePiece
      1  7e3a		       8d 59 f5 	      sta	[RAM]+restorePiece
   1261  7e3d
   1262  7e3d					      IF	CASTLING_ENABLED
   1263  7e3d
   1264  7e3d							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
   1265  7e3d							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
   1266  7e3d							; redo the moving code (for the rook, this time).
   1267  7e3d
   1268  7e3d		       20 39 f2 	      jsr	GenCastleMoveForRook
   1269  7e40		       b0 ca		      bcs	.move	; move the rook!
   1270  7e42					      ENDIF
   1271  7e42
   1272  7e42
   1273  7e42				  -	      IF	ENPASSANT_ENABLED
   1274  7e42				  -
   1275  7e42				  -	      JSROM	EnPassantCheck
   1276  7e42				  -	      beq	.notEnPassant
   1277  7e42				  -	      jsr	EnPassantReP_MovePiece	; y = origin X12
   1278  7e42				  -.notEnPassant
   1279  7e42					      ENDIF
   1280  7e42
   1281  7e42							; Swap over sides
   1282  7e42
      0  7e42					      NEGEVAL
      1  7e42
      2  7e42		       38		      sec
      3  7e43		       a9 00		      lda	#0
      4  7e45		       e5 90		      sbc	Evaluation
      5  7e47		       85 90		      sta	Evaluation
      6  7e49		       a9 00		      lda	#0
      7  7e4b		       e5 91		      sbc	Evaluation+1
      8  7e4d		       85 91		      sta	Evaluation+1
      0  7e4f					      SWAP
      1  7e4f		       a5 97		      lda	sideToMove
      2  7e51		       49 83		      eor	#SWAP_SIDE
      3  7e53		       85 97		      sta	sideToMove
   1285  7e55
   1286  7e55		       60		      rts
   1287  7e56
   1288  7e56
   1289  7e56							;---------------------------------------------------------------------------------------------------
   1290  7e56
      0  7e56					      DEF	unmake_move
      1  7e56				   BANK_unmake_move SET	_CURRENT_BANK
      2  7e56				   unmake_move
      3  7e56				   TEMPORARY_VAR SET	Overlay
      4  7e56				   TEMPORARY_OFFSET SET	0
      5  7e56				   VAR_BOUNDARY_unmake_move SET	TEMPORARY_OFFSET
      6  7e56				   FUNCTION_NAME SET	unmake_move
      7  7e56					      SUBROUTINE
   1292  7e56					      SUBROUTINE
   1293  7e56
      0  7e56					      REFER	negamax
      1  7e56					      IF	VAREND_negamax > TEMPORARY_VAR
      2  7e56				   TEMPORARY_VAR SET	VAREND_negamax
      3  7e56					      ENDIF
      0  7e56					      VAR	__unmake_capture, 1
      1  7e56		       00 ad	   __unmake_capture =	TEMPORARY_VAR
      2  7e56				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7e56
      4  7e56				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7e56				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7e56				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7e56					      ENDIF
      8  7e56				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7e56				  -	      ECHO	"Temporary Variable", __unmake_capture, "overflow!"
     10  7e56				  -	      ERR
     11  7e56					      ENDIF
     12  7e56					      LIST	ON
      0  7e56					      VAR	__secondaryBlank, 1
      1  7e56		       00 ae	   __secondaryBlank =	TEMPORARY_VAR
      2  7e56				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7e56
      4  7e56				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7e56				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7e56				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7e56					      ENDIF
      8  7e56				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7e56				  -	      ECHO	"Temporary Variable", __secondaryBlank, "overflow!"
     10  7e56				  -	      ERR
     11  7e56					      ENDIF
     12  7e56					      LIST	ON
      0  7e56					      VEND	unmake_move
      1  7e56				  -	      IFNCONST	unmake_move
      2  7e56				  -	      ECHO	"Incorrect VEND label", unmake_move
      3  7e56				  -	      ERR
      4  7e56					      ENDIF
      5  7e56		       00 af	   VAREND_unmake_move =	TEMPORARY_VAR
   1298  7e56
   1299  7e56							; restore the board evaluation to what it was at the start of this ply
   1300  7e56							; TODO: note: moved flag seems wrong on restoration
   1301  7e56
   1302  7e56		       ad 00 f0 	      lda	SavedEvaluation
   1303  7e59		       85 90		      sta	Evaluation
   1304  7e5b		       ad 01 f0 	      lda	SavedEvaluation+1
   1305  7e5e		       85 91		      sta	Evaluation+1
   1306  7e60
   1307  7e60		       ae 50 f1 	      ldx	movePtr
      0  7e63					      lda@PLY	MoveFrom,x
      1  7e63		       bd 02 f0 	      lda	MoveFrom,x
   1309  7e66		       85 85		      sta	fromX12
   1310  7e68		       bc 48 f0 	      ldy	MoveTo,x
   1311  7e6b
   1312  7e6b		       ad 59 f1 	      lda	restorePiece
   1313  7e6e		       48		      pha
   1314  7e6f		       ad 48 f1 	      lda	capturedPiece
   1315  7e72
   1316  7e72		       a2 08		      ldx	#RAMBANK_BOARD
   1317  7e74		       86 3e		      stx	SET_BANK_RAM
      0  7e76					      sta@RAM	Board,y
      1  7e76		       99 79 f4 	      sta	[RAM]+Board,y
   1319  7e79		       a4 85		      ldy	fromX12
   1320  7e7b		       68		      pla
      0  7e7c					      sta@RAM	Board,y
      1  7e7c		       99 79 f4 	      sta	[RAM]+Board,y
   1322  7e7f
   1323  7e7f
   1324  7e7f		       a5 95		      lda	currentPly
   1325  7e81		       85 3e		      sta	SET_BANK_RAM
   1326  7e83
   1327  7e83							; See if there are any 'secondary' pieces that moved
   1328  7e83							; here we're dealing with reverting a castling or enPassant move
   1329  7e83
   1330  7e83		       ad 4a f1 	      lda	secondaryPiece
   1331  7e86		       f0 1a		      beq	.noSecondary
   1332  7e88		       ac 4c f1 	      ldy	secondaryBlank
   1333  7e8b		       84 ae		      sty	__secondaryBlank
   1334  7e8d		       ac 4b f1 	      ldy	secondarySquare
   1335  7e90
   1336  7e90
   1337  7e90		       a2 08		      ldx	#RAMBANK_BOARD
   1338  7e92		       86 3e		      stx	SET_BANK_RAM
      0  7e94					      sta@RAM	Board,y	; put piece back
      1  7e94		       99 79 f4 	      sta	[RAM]+Board,y
   1340  7e97
   1341  7e97		       a4 ae		      ldy	__secondaryBlank
   1342  7e99		       a9 00		      lda	#0
      0  7e9b					      sta@RAM	Board,y	; blank piece origin
      1  7e9b		       99 79 f4 	      sta	[RAM]+Board,y
   1344  7e9e
   1345  7e9e		       a5 95		      lda	currentPly
   1346  7ea0		       85 3e		      sta	SET_BANK_RAM
   1347  7ea2
   1348  7ea2
   1349  7ea2				   .noSecondary
      0  7ea2					      SWAP
      1  7ea2		       a5 97		      lda	sideToMove
      2  7ea4		       49 83		      eor	#SWAP_SIDE
      3  7ea6		       85 97		      sta	sideToMove
   1351  7ea8		       60		      rts
   1352  7ea9
   1353  7ea9
   1354  7ea9							;---------------------------------------------------------------------------------------------------
   1355  7ea9
   1356  7ea9							;function negamax(node, depth, α, β, color) is
   1357  7ea9							;    if depth = 0 or node is a terminal node then
   1358  7ea9							;	  return color × the heuristic value of node
   1359  7ea9
   1360  7ea9							;    childNodes := generateMoves(node)
   1361  7ea9							;    childNodes := orderMoves(childNodes)
   1362  7ea9							;    value := −∞
   1363  7ea9							;    foreach child in childNodes do
   1364  7ea9							;	  value := max(value, −negamax(child, depth − 1, −β, −α, −color))
   1365  7ea9							;	  α := max(α, value)
   1366  7ea9							;	  if α ≥ β then
   1367  7ea9							;	      break (* cut-off *)
   1368  7ea9							;    return value
   1369  7ea9							;(* Initial call for Player A's root node *)
   1370  7ea9							;negamax(rootNode, depth, −∞, +∞, 1)
   1371  7ea9
   1372  7ea9
   1373  7ea9					      SUBROUTINE
   1374  7ea9
   1375  7ea9				   .terminal
   1376  7ea9
      0  7ea9					      NEXT_RANDOM
      1  7ea9		       a5 81		      lda	rnd
      2  7eab		       4a		      lsr
      3  7eac		       90 02		      bcc	.skipEOR
      4  7eae		       49 fe		      eor	#RND_EOR_VAL
      5  7eb0		       85 81	   .skipEOR   sta	rnd
   1378  7eb2		       29 3f		      and	#63
   1379  7eb4		       65 90		      adc	Evaluation
   1380  7eb6		       85 a9		      sta	__negamax
   1381  7eb8		       a5 91		      lda	Evaluation+1
   1382  7eba		       69 00		      adc	#0
   1383  7ebc		       85 aa		      sta	__negamax+1
   1384  7ebe		       60		      rts
   1385  7ebf
      0  7ebf				   .exit      lda@PLY	value
      1  7ebf		       ad 56 f1 	      lda	value
   1387  7ec2		       85 a9		      sta	__negamax
      0  7ec4					      lda@PLY	value+1
      1  7ec4		       ad 57 f1 	      lda	value+1
   1389  7ec7		       85 aa		      sta	__negamax+1
   1390  7ec9		       60		      rts
   1391  7eca
   1392  7eca
      0  7eca					      DEF	negamax
      1  7eca				   BANK_negamax SET	_CURRENT_BANK
      2  7eca				   negamax
      3  7eca				   TEMPORARY_VAR SET	Overlay
      4  7eca				   TEMPORARY_OFFSET SET	0
      5  7eca				   VAR_BOUNDARY_negamax SET	TEMPORARY_OFFSET
      6  7eca				   FUNCTION_NAME SET	negamax
      7  7eca					      SUBROUTINE
   1394  7eca
   1395  7eca							; pass...
   1396  7eca							; x = depthleft
   1397  7eca							; SET_BANK_RAM      --> current ply
   1398  7eca							; __alpha[2] = param alpha
   1399  7eca							; __beta[2] = param beta
   1400  7eca
   1401  7eca
      0  7eca					      COMMON_VARS_ALPHABETA
      1  7eca
      0  7eca					      VAR	__bestMove, 1
      1  7eca		       00 a2	   __bestMove =	TEMPORARY_VAR
      2  7eca				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7eca
      4  7eca				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7eca				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7eca				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7eca					      ENDIF
      8  7eca				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7eca				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  7eca				  -	      ERR
     11  7eca					      ENDIF
     12  7eca					      LIST	ON
      0  7eca					      VAR	__bestScore, 2
      1  7eca		       00 a3	   __bestScore =	TEMPORARY_VAR
      2  7eca				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7eca
      4  7eca				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7eca				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7eca				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7eca					      ENDIF
      8  7eca				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7eca				  -	      ECHO	"Temporary Variable", __bestScore, "overflow!"
     10  7eca				  -	      ERR
     11  7eca					      ENDIF
     12  7eca					      LIST	ON
      0  7eca					      VAR	__alpha, 2
      1  7eca		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  7eca				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7eca
      4  7eca				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7eca				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7eca				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7eca					      ENDIF
      8  7eca				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7eca				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  7eca				  -	      ERR
     11  7eca					      ENDIF
     12  7eca					      LIST	ON
      0  7eca					      VAR	__beta, 2
      1  7eca		       00 a7	   __beta     =	TEMPORARY_VAR
      2  7eca				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7eca
      4  7eca				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7eca				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7eca				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7eca					      ENDIF
      8  7eca				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7eca				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  7eca				  -	      ERR
     11  7eca					      ENDIF
     12  7eca					      LIST	ON
      0  7eca					      VAR	__negamax, 2
      1  7eca		       00 a9	   __negamax  =	TEMPORARY_VAR
      2  7eca				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7eca
      4  7eca				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7eca				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7eca				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7eca					      ENDIF
      8  7eca				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7eca				  -	      ECHO	"Temporary Variable", __negamax, "overflow!"
     10  7eca				  -	      ERR
     11  7eca					      ENDIF
     12  7eca					      LIST	ON
      0  7eca					      VAR	__value, 2
      1  7eca		       00 ab	   __value    =	TEMPORARY_VAR
      2  7eca				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7eca
      4  7eca				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7eca				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7eca				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7eca					      ENDIF
      8  7eca				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7eca				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  7eca				  -	      ERR
     11  7eca					      ENDIF
     12  7eca					      LIST	ON
      8  7eca
      0  7eca					      REFER	selectmove
      1  7eca				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  7eca				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  7eca					      ENDIF
      0  7eca					      VEND	negamax
      1  7eca				  -	      IFNCONST	negamax
      2  7eca				  -	      ECHO	"Incorrect VEND label", negamax
      3  7eca				  -	      ERR
      4  7eca					      ENDIF
      5  7eca		       00 ad	   VAREND_negamax =	TEMPORARY_VAR
   1405  7eca
   1406  7eca		       ca		      dex
   1407  7ecb		       30 dc		      bmi	.terminal
      0  7ecd					      stx@PLY	depthLeft
      1  7ecd		       8e 58 f5 	      stx	[RAM]+depthLeft
   1409  7ed0
   1410  7ed0		       a5 a5		      lda	__alpha
      0  7ed2					      sta@PLY	alpha
      1  7ed2		       8d 52 f5 	      sta	[RAM]+alpha
   1412  7ed5		       a5 a6		      lda	__alpha+1
      0  7ed7					      sta@PLY	alpha+1
      1  7ed7		       8d 53 f5 	      sta	[RAM]+alpha+1
   1414  7eda
   1415  7eda		       a5 a7		      lda	__beta
      0  7edc					      sta@PLY	beta
      1  7edc		       8d 54 f5 	      sta	[RAM]+beta
   1417  7edf		       a5 a8		      lda	__beta+1
      0  7ee1					      sta@PLY	beta+1
      1  7ee1		       8d 55 f5 	      sta	[RAM]+beta+1
   1419  7ee4
   1420  7ee4
   1421  7ee4		       20 b7 f1 	      jsr	NewPlyInitialise
   1422  7ee7		       20 e7 f8 	      jsr	GenerateAllMoves
   1423  7eea
   1424  7eea							;lda flagCheck
   1425  7eea							;bne .terminate		  ; we can capture the king, so just return for that to be fixed on previous ply
   1426  7eea
   1427  7eea		       20 89 f2 	      jsr	Sort
   1428  7eed
   1429  7eed
   1430  7eed					      if	1
      0  7eed					      lda@PLY	moveIndex
      1  7eed		       ad 4f f1 	      lda	moveIndex
   1432  7ef0		       0a		      asl
   1433  7ef1		       0a		      asl
      0  7ef2					      adc@PLY	SavedEvaluation
      1  7ef2		       6d 00 f0 	      adc	SavedEvaluation
      0  7ef5					      sta@PLY	SavedEvaluation
      1  7ef5		       8d 00 f4 	      sta	[RAM]+SavedEvaluation
      0  7ef8					      lda@PLY	SavedEvaluation+1
      1  7ef8		       ad 01 f0 	      lda	SavedEvaluation+1
   1437  7efb		       69 00		      adc	#0
      0  7efd					      sta@PLY	SavedEvaluation+1	; + mobility (kind of odd/bad - happens every level)
      1  7efd		       8d 01 f4 	      sta	[RAM]+SavedEvaluation+1
   1439  7f00					      endif
   1440  7f00
   1441  7f00
   1442  7f00		       a9 01		      lda	#<-INFINITY
      0  7f02					      sta@PLY	value
      1  7f02		       8d 56 f5 	      sta	[RAM]+value
   1444  7f05		       a9 80		      lda	#>-INFINITY
      0  7f07					      sta@PLY	value+1
      1  7f07		       8d 57 f5 	      sta	[RAM]+value+1
   1446  7f0a
      0  7f0a					      ldx@PLY	moveIndex
      1  7f0a		       ae 4f f1 	      ldx	moveIndex
   1448  7f0d		       30 b0		      bmi	.exit
   1449  7f0f
      0  7f0f				   .forChild  stx@PLY	movePtr
      1  7f0f		       8e 50 f5 	      stx	[RAM]+movePtr
   1451  7f12
   1452  7f12		       20 f3 fd 	      jsr	MakeMove
   1453  7f15
   1454  7f15
   1455  7f15
   1456  7f15							;	  value := max(value, −negamax(child, depth − 1, −β, −α, −color))
   1457  7f15
   1458  7f15							; PARAMS depth-1, -beta, -alpha
   1459  7f15							; pased through temporary variables (__alpha, __beta) and X reg
   1460  7f15
   1461  7f15		       38		      sec
   1462  7f16		       a9 00		      lda	#0
      0  7f18					      sbc@PLY	beta
      1  7f18		       ed 54 f1 	      sbc	beta
   1464  7f1b		       85 a5		      sta	__alpha
   1465  7f1d		       a9 00		      lda	#0
      0  7f1f					      sbc@PLY	beta+1
      1  7f1f		       ed 55 f1 	      sbc	beta+1
   1467  7f22		       85 a6		      sta	__alpha+1
   1468  7f24
   1469  7f24		       38		      sec
   1470  7f25		       a9 00		      lda	#0
      0  7f27					      sbc@PLY	alpha
      1  7f27		       ed 52 f1 	      sbc	alpha
   1472  7f2a		       85 a7		      sta	__beta
   1473  7f2c		       a9 00		      lda	#0
      0  7f2e					      sbc@PLY	alpha+1
      1  7f2e		       ed 53 f1 	      sbc	alpha+1
   1475  7f31		       85 a8		      sta	__beta+1
   1476  7f33
      0  7f33					      ldx@PLY	depthLeft
      1  7f33		       ae 58 f1 	      ldx	depthLeft
   1478  7f36
   1479  7f36		       e6 95		      inc	currentPly
   1480  7f38		       a5 95		      lda	currentPly
   1481  7f3a		       85 3e		      sta	SET_BANK_RAM	; self-switch
   1482  7f3c
   1483  7f3c		       20 ca fe 	      jsr	negamax
   1484  7f3f
   1485  7f3f		       c6 95		      dec	currentPly
   1486  7f41		       a5 95		      lda	currentPly
   1487  7f43		       85 3e		      sta	SET_BANK_RAM
   1488  7f45
   1489  7f45		       20 56 fe 	      jsr	unmake_move
   1490  7f48
   1491  7f48		       38		      sec
   1492  7f49		       a9 00		      lda	#0
   1493  7f4b		       e5 a9		      sbc	__negamax
   1494  7f4d		       85 a9		      sta	__negamax
   1495  7f4f		       a9 00		      lda	#0
   1496  7f51		       e5 aa		      sbc	__negamax+1
   1497  7f53		       85 aa		      sta	__negamax+1	; -negamax(...)
   1498  7f55
   1499  7f55
   1500  7f55		       38		      sec
      0  7f56					      lda@PLY	value
      1  7f56		       ad 56 f1 	      lda	value
   1502  7f59		       e5 a9		      sbc	__negamax
      0  7f5b					      lda@PLY	value+1
      1  7f5b		       ad 57 f1 	      lda	value+1
   1504  7f5e		       e5 aa		      sbc	__negamax+1
   1505  7f60		       50 02		      bvc	.lab0
   1506  7f62		       49 80		      eor	#$80
   1507  7f64		       10 10	   .lab0      bpl	.lt0	; branch if value >= negamax
   1508  7f66
   1509  7f66							; so, negamax > value!
   1510  7f66
   1511  7f66		       a5 a9		      lda	__negamax
      0  7f68					      sta@PLY	value
      1  7f68		       8d 56 f5 	      sta	[RAM]+value
   1513  7f6b		       a5 aa		      lda	__negamax+1
      0  7f6d					      sta@PLY	value+1	; max(value, -negamax)
      1  7f6d		       8d 57 f5 	      sta	[RAM]+value+1
   1515  7f70
      0  7f70					      lda@PLY	movePtr
      1  7f70		       ad 50 f1 	      lda	movePtr
      0  7f73					      sta@PLY	bestMove
      1  7f73		       8d 51 f5 	      sta	[RAM]+bestMove
   1518  7f76				   .lt0
   1519  7f76
   1520  7f76							;	  α := max(α, value)
   1521  7f76
   1522  7f76		       38		      sec
      0  7f77					      lda@PLY	value
      1  7f77		       ad 56 f1 	      lda	value
      0  7f7a					      sbc@PLY	alpha
      1  7f7a		       ed 52 f1 	      sbc	alpha
      0  7f7d					      lda@PLY	value+1
      1  7f7d		       ad 57 f1 	      lda	value+1
      0  7f80					      sbc@PLY	alpha+1
      1  7f80		       ed 53 f1 	      sbc	alpha+1
   1527  7f83		       50 02		      bvc	.lab1
   1528  7f85		       49 80		      eor	#$80
   1529  7f87		       30 0c	   .lab1      bmi	.lt1	; value < alpha
   1530  7f89
      0  7f89					      lda@PLY	value
      1  7f89		       ad 56 f1 	      lda	value
      0  7f8c					      sta@PLY	alpha
      1  7f8c		       8d 52 f5 	      sta	[RAM]+alpha
      0  7f8f					      lda@PLY	value+1
      1  7f8f		       ad 57 f1 	      lda	value+1
      0  7f92					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  7f92		       8d 53 f5 	      sta	[RAM]+alpha+1
   1535  7f95
   1536  7f95				   .lt1
   1537  7f95
   1538  7f95							;	  if α ≥ β then
   1539  7f95							;	      break (* cut-off *)
   1540  7f95
   1541  7f95		       38		      sec
      0  7f96					      lda@PLY	alpha
      1  7f96		       ad 52 f1 	      lda	alpha
      0  7f99					      sbc@PLY	beta
      1  7f99		       ed 54 f1 	      sbc	beta
      0  7f9c					      lda@PLY	alpha+1
      1  7f9c		       ad 53 f1 	      lda	alpha+1
      0  7f9f					      sbc@PLY	beta+1
      1  7f9f		       ed 55 f1 	      sbc	beta+1
   1546  7fa2		       50 02		      bvc	.lab2
   1547  7fa4		       49 80		      eor	#$80
   1548  7fa6		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
   1549  7fa8
   1550  7fa8
      0  7fa8					      ldx@PLY	movePtr
      1  7fa8		       ae 50 f1 	      ldx	movePtr
   1552  7fab		       ca		      dex
   1553  7fac		       30 03		      bmi	.retrn
   1554  7fae		       4c 0f ff 	      jmp	.forChild
   1555  7fb1
   1556  7fb1		       4c bf fe    .retrn     jmp	.exit
   1557  7fb4
   1558  7fb4							;---------------------------------------------------------------------------------------------------
   1559  7fb4
 FREE BYTES IN FIXED BANK =  $48
   1560  7fb4					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFC - *
   1561  7fb4
   1562  7fb4							;---------------------------------------------------------------------------------------------------
   1563  7fb4							; The reset vectors
   1564  7fb4							; these must live in the fixed bank (last 2K of any ROM image in "3E" scheme)
   1565  7fb4
   1566  8000 ????				      SEG	InterruptVectors
   1567  7ffc					      ORG	FIXED_BANK + $7FC
   1568  7ffc					      RORG	$7ffC
   1569  7ffc
   1570  7ffc		       00 f8		      .word.w	Reset	; RESET
   1571  7ffe		       00 f8		      .word.w	Reset	; IRQ	      (not used)
   1572  8000
   1573  8000							;---------------------------------------------------------------------------------------------------
   1574  8000							; EOF
------- FILE ./chess.asm
    593  8000
    594  8000							;END
