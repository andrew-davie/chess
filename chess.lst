------- FILE ./chess.asm LEVEL 1 PASS 5
      1  10000 ????						; Chess
      2  10000 ????						; Atari 2600 Chess display system
      3  10000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  10000 ????						; andrew@taswegian.com
      5  10000 ????
      6  10000 ????
      7  10000 ????		00 40	    TIA_BASE_ADDRESS =	$40
      8  10000 ????
      9  10000 ????				       processor	6502
------- FILE vcs.h LEVEL 2 PASS 5
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; This file defines hardware registers and memory mapping for the
      7  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  10000 ????						; available at at http://www.atari2600.org/dasm
     10  10000 ????						;
     11  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  10000 ????						; with your views.  Please contribute, if you think you can improve this
     15  10000 ????						; file!
     16  10000 ????						;
     17  10000 ????						; Latest Revisions...
     18  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  10000 ????						;			    This will allow conditional code to verify VCS.H being
     21  10000 ????						;			    used for code assembly.
     22  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  10000 ????						;			 mirrored reading/writing differences.	This is more a
     25  10000 ????						;			 readability issue, and binary compatibility with disassembled
     26  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  10000 ????						;			 which was broken by the use of segments in this file, as
     29  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  10000 ????						;						   it is safe to leave it undefined, and the base address will
     34  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  10000 ????						;			  - register definitions are now generated through assignment
     37  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  10000 ????						;			    address architecture.
     39  10000 ????						; 1.0	22/MAR/2003		Initial release
     40  10000 ????
     41  10000 ????
     42  10000 ????						;-------------------------------------------------------------------------------
     43  10000 ????
     44  10000 ????						; TIA_BASE_ADDRESS
     45  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  10000 ????						; Normally 0, the base address should (externally, before including this file)
     47  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  10000 ????						; < $40 as a bankswitch.
     50  10000 ????
     51  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     52  10000 ????			   -TIA_BASE_ADDRESS =	0
     53  10000 ????				       ENDIF
     54  10000 ????
     55  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  10000 ????						; *OR* by declaring the label before including this file, eg:
     58  10000 ????						; TIA_BASE_ADDRESS = $40
     59  10000 ????						;   include "vcs.h"
     60  10000 ????
     61  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  10000 ????						; for the mirrored ROM hardware registers.
     64  10000 ????
     65  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  10000 ????
     69  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     70  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  10000 ????				       ENDIF
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????						;-------------------------------------------------------------------------------
     78  10000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 5
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 5
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????	       00 08	   MARKER     =	8
     34  0000 ????
     35  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     36  0000 ????
     37  0000 ????						;---------------------------------------------------------------------------------------------------
     38  0000 ????
     39  0000 ????						; Movements
     40  0000 ????
     41  0000 ????	       00 0a	   _UP	      =	10	; up
     42  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     43  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     44  0000 ????	       00 01	   _RIGHT     =	1	; right
     45  0000 ????
     46  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 5
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						; Pathways
     94  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
     95  0000 ????						; if QuickDraw does immediate exit, 58✅
     96  0000 ????
     97  0000 ????						;---------------------------------------------------------------------------------------------------
     98  0000 ????
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIME, 95	;✅ processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	(95+32)/64 + 2
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    101  0000 ????
    102  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    103  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    104  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    105  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    106  0000 ????						; uses ...
    107  0000 ????
    108  0000 ????
    109  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    110  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    111  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    112  0000 ????
    113  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    114  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    115  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./chess.asm
     20  0000 ????
     21  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     22  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     23  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     24  0000 ????	       f8 00	   FIXED_BANK =	31 * 2048	; ->> 64K
     25  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     26  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     27  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     28  0000 ????
     29  0000 ????	       00 01	   YES	      =	1
     30  0000 ????	       00 00	   NO	      =	0
     31  0000 ????
     32  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     33  0000 ????
     34  0000 ????
     35  0000 ????						; assemble diagnostics. Remove for release.
     36  0000 ????
     37  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     38  0000 ????	       00 01	   DIAGNOSTICS =	1
     39  0000 ????	       00 01	   QUIESCENCE =	1
     40  0000 ????	       00 00	   ASSERTS    =	0
     41  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     42  0000 ????	       00 00	   ENPASSANT_ENABLED =	0
     43  0000 ????	       00 01	   CASTLING_ENABLED =	1
     44  0000 ????						;PIECELIST_ENABLED	  = 0
     45  0000 ????
     46  0000 ????	       00 04	   SEARCH_DEPTH =	4
     47  0000 ????	       00 04	   QUIESCE_EXTRA_DEPTH =	4
     48  0000 ????
     49  0000 ????	       00 08	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     50  0000 ????	       00 12	   MAX_PLY_DEPTH_BANK =	RAMBANK_PLY + PLY_BANKS
     51  0000 ????
     52  0000 ????			  -	      IF	MAX_PLY_DEPTH_BANK > 31
     53  0000 ????			  -	      ERR	"Not enough RAM for PLY banks"
     54  0000 ????				      ENDIF
     55  0000 ????
     56  0000 ????
     57  0000 ????
     58  0000 ????
     59  0000 ????	       00 81	   SWAP_SIDE  =	128 + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     60  0000 ????
     61  0000 ????
     62  0000 ????
     63  0000 ????						; DELAYS
     64  0000 ????
     65  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     66  0000 ????
     67  0000 ????						;===================================
     68  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     69  0000 ????						;===================================
     70  0000 ????
     71  0000 ????						;-------------------------------------------------------------------------------
     72  0000 ????						; The following are optional YES/NO depending on phase of the moon
     73  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     74  0000 ????						;-------------------------------------------------------------------------------
     75  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     76  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     77  0000 ????			  -	      IF	FINAL_VERSION = YES
     78  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     79  0000 ????				      ENDIF
     80  0000 ????
     81  0000 ????						;-------------------------------------------------------------------------------
     82  0000 ????
     83  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     84  0000 ????
     85  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     86  0000 ????
     87  0000 ????						;------------------------------------------------------------------------------
     88  0000 ????
     89  0000 ????	       00 01	   PLUSCART   =	YES
     90  0000 ????
     91  0000 ????						;------------------------------------------------------------------------------
     92  0000 ????
     93  0000 ????
     94  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
     95  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
     96  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
     97  0000 ????
     98  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
     99  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    100  0000 ????
    101  0000 ????
    102  0000 ????	       10 00	   RAM_3E     =	$1000
    103  0000 ????	       04 00	   RAM_SIZE   =	$400
    104  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    105  0000 ????	       04 00	   RAM	      =	RAM_WRITE
    106  0000 ????
    107  0000 ????
    108  0000 ????
    109  0000 ????						; Platform constants:
    110  0000 ????	       00 02	   PAL	      =	%10
    111  0000 ????	       00 02	   PAL_50     =	PAL|0
    112  0000 ????	       00 03	   PAL_60     =	PAL|1
    113  0000 ????
    114  0000 ????
    115  0000 ????				      IF	L276
    116  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    117  0000 ????			  -	      ELSE
    118  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    119  0000 ????				      ENDIF
    120  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    121  0000 ????
    122  0000 ????				      IF	L276
    123  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    124  0000 ????			  -	      ELSE
    125  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    126  0000 ????				      ENDIF
    127  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    128  0000 ????
    129  0000 ????				      IF	L276
    130  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    131  0000 ????			  -	      ELSE
    132  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    133  0000 ????				      ENDIF
    134  0000 ????	       01 38	   SCANLINES_PAL =	312
    135  0000 ????
    136  0000 ????
    137  0000 ????	       00 2e	   TIME_PART_2 =	46
    138  0000 ????	       00 2e	   TIME_PART_1 =	46
    139  0000 ????
    140  0000 ????
    141  0000 ????						;------------------------------------------------------------------------------
    142  0000 ????						; MACRO definitions
    143  0000 ????
    144  0000 ????
    145  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    146  0000 ????
    147  0000 ????				      MAC	newbank
    148  0000 ????				      SEG	{1}
    149  0000 ????				      ORG	ORIGIN
    150  0000 ????				      RORG	$F000
    151  0000 ????			   BANK_START SET	*
    152  0000 ????			   {1}	      SET	ORIGIN / 2048
    153  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    154  0000 ????			   _CURRENT_BANK SET	{1}
    155  0000 ????				      ENDM		; bank name
    156  0000 ????
    157  0000 ????				      MAC	define_1k_segment
    158  0000 ????				      ALIGN	$400
    159  0000 ????			   SEGMENT_{1} SET	*
    160  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    161  0000 ????				      ENDM		; {seg name}
    162  0000 ????
    163  0000 ????				      MAC	check_bank_size
    164  0000 ????			   .TEMP      =	* - BANK_START
    165  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    166  0000 ????				      IF	( .TEMP ) > ROM_BANK_SIZE
    167  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    168  0000 ????				      ERR
    169  0000 ????				      ENDIF
    170  0000 ????
    171  0000 ????				      ENDM		; name
    172  0000 ????
    173  0000 ????
    174  0000 ????				      MAC	check_half_bank_size
    175  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    176  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    177  0000 ????			   .TEMP      =	* - BANK_START
    178  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    179  0000 ????				      IF	( .TEMP ) > ROM_BANK_SIZE/2
    180  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    181  0000 ????				      ERR
    182  0000 ????				      ENDIF
    183  0000 ????				      ENDM		; name
    184  0000 ????
    185  0000 ????
    186  0000 ????						;---------------------------------------------------------------------------------------------------
    187  0000 ????
    188  0000 ????						; Macro inserts a page break if the object would overlap a page
    189  0000 ????
    190  0000 ????				      MAC	optional_pagebreak
    191  0000 ????				      LIST	OFF
    192  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    193  0000 ????			   EARLY_LOCATION SET	*
    194  0000 ????				      ALIGN	256
    195  0000 ????				      IF	VERBOSE=1
    196  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    197  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    198  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    199  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    200  0000 ????				      ENDIF
    201  0000 ????				      ENDIF
    202  0000 ????				      LIST	ON
    203  0000 ????				      ENDM		; { string, size }
    204  0000 ????
    205  0000 ????
    206  0000 ????				      MAC	check_page_crossing
    207  0000 ????				      LIST	OFF
    208  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    209  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    210  0000 ????				      ENDIF
    211  0000 ????				      LIST	ON
    212  0000 ????				      ENDM
    213  0000 ????
    214  0000 ????				      MAC	checkpage
    215  0000 ????				      LIST	OFF
    216  0000 ????				      IF	>. != >{1}
    217  0000 ????				      ECHO	""
    218  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    219  0000 ????				      ECHO	""
    220  0000 ????				      ERR
    221  0000 ????				      ENDIF
    222  0000 ????				      LIST	ON
    223  0000 ????				      ENDM
    224  0000 ????
    225  0000 ????				      MAC	checkpagex
    226  0000 ????				      LIST	OFF
    227  0000 ????				      IF	>. != >{1}
    228  0000 ????				      ECHO	""
    229  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    230  0000 ????				      ECHO	{2}
    231  0000 ????				      ECHO	""
    232  0000 ????				      ERR
    233  0000 ????				      ENDIF
    234  0000 ????				      LIST	ON
    235  0000 ????				      ENDM
    236  0000 ????
    237  0000 ????						;---------------------------------------------------------------------------------------------------
    238  0000 ????
    239  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    240  0000 ????				      MAC	variable
    241  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    242  0000 ????			   {1}	      ds	{2}
    243  0000 ????				      ENDM		; {name, size}
    244  0000 ????
    245  0000 ????
    246  0000 ????						;---------------------------------------------------------------------------------------------------
    247  0000 ????
    248  0000 ????				      MAC	def
    249  0000 ????			   BANK_{1}   SET	_CURRENT_BANK	; bank in which this subroutine resides
    250  0000 ????			   {1}			; entry point
    251  0000 ????			   TEMPORARY_VAR SET	Overlay
    252  0000 ????			   TEMPORARY_OFFSET SET	0
    253  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    254  0000 ????			   FUNCTION_NAME SET	{1}
    255  0000 ????				      SUBROUTINE
    256  0000 ????				      ENDM		; name of subroutine
    257  0000 ????
    258  0000 ????
    259  0000 ????						;---------------------------------------------------------------------------------------------------
    260  0000 ????
    261  0000 ????				      MAC	allocate
    262  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    263  0000 ????				      DEF	{1}
    264  0000 ????				      ENDM
    265  0000 ????
    266  0000 ????
    267  0000 ????						;---------------------------------------------------------------------------------------------------
    268  0000 ????
    269  0000 ????				      MAC	negeval
    270  0000 ????
    271  0000 ????				      sec
    272  0000 ????				      lda	#0
    273  0000 ????				      sbc	Evaluation
    274  0000 ????				      sta	Evaluation
    275  0000 ????				      lda	#0
    276  0000 ????				      sbc	Evaluation+1
    277  0000 ????				      sta	Evaluation+1
    278  0000 ????				      ENDM
    279  0000 ????
    280  0000 ????
    281  0000 ????				      MAC	swap
    282  0000 ????				      lda	sideToMove
    283  0000 ????				      eor	#SWAP_SIDE
    284  0000 ????				      sta	sideToMove
    285  0000 ????				      ENDM
    286  0000 ????
    287  0000 ????
    288  0000 ????						;---------------------------------------------------------------------------------------------------
    289  0000 ????
    290  0000 ????			   TEMPORARY_OFFSET SET	0
    291  0000 ????
    292  0000 ????
    293  0000 ????				      MAC	vend
    294  0000 ????				      IFNCONST	{1}
    295  0000 ????				      ECHO	"Incorrect VEND label", {1}
    296  0000 ????				      ERR
    297  0000 ????				      ENDIF
    298  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    299  0000 ????				      ENDM		; {1}
    300  0000 ????
    301  0000 ????
    302  0000 ????				      MAC	refer
    303  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    304  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    305  0000 ????				      ENDIF
    306  0000 ????				      ENDM		; {1}
    307  0000 ????
    308  0000 ????
    309  0000 ????
    310  0000 ????						; Define a temporary variable for use in a subroutine
    311  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    312  0000 ????
    313  0000 ????				      MAC	var
    314  0000 ????			   {1}	      =	TEMPORARY_VAR
    315  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    316  0000 ????
    317  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    318  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    319  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    320  0000 ????				      ENDIF
    321  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    322  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    323  0000 ????				      ERR
    324  0000 ????				      ENDIF
    325  0000 ????				      LIST	ON
    326  0000 ????				      ENDM		; { name, size }
    327  0000 ????
    328  0000 ????
    329  0000 ????						;---------------------------------------------------------------------------------------------------
    330  0000 ????
    331  0000 ????				      MAC	tag
    332  0000 ????						; {0}
    333  0000 ????				      ENDM		; {ident/tag}
    334  0000 ????
    335  0000 ????						;---------------------------------------------------------------------------------------------------
    336  0000 ????
    337  0000 ????				      MAC	sta@ram
    338  0000 ????				      sta	[RAM]+{0}
    339  0000 ????				      ENDM		;{}
    340  0000 ????
    341  0000 ????				      MAC	stx@ram
    342  0000 ????				      stx	[RAM]+{0}
    343  0000 ????				      ENDM
    344  0000 ????
    345  0000 ????				      MAC	sty@ram
    346  0000 ????				      sty	[RAM]+{0}
    347  0000 ????				      ENDM
    348  0000 ????
    349  0000 ????				      MAC	sta@ply
    350  0000 ????				      sta	[RAM]+{0}
    351  0000 ????				      ENDM		;{}
    352  0000 ????
    353  0000 ????				      MAC	stx@ply
    354  0000 ????				      stx	[RAM]+{0}
    355  0000 ????				      ENDM
    356  0000 ????
    357  0000 ????				      MAC	sty@ply
    358  0000 ????				      sty	[RAM]+{0}
    359  0000 ????				      ENDM
    360  0000 ????
    361  0000 ????
    362  0000 ????				      MAC	lda@ram
    363  0000 ????				      lda	{0}
    364  0000 ????				      ENDM		;{}
    365  0000 ????
    366  0000 ????				      MAC	ldx@ram
    367  0000 ????				      ldx	{0}
    368  0000 ????				      ENDM		;{}
    369  0000 ????
    370  0000 ????				      MAC	ldy@ram
    371  0000 ????				      ldy	{0}
    372  0000 ????				      ENDM		;{}
    373  0000 ????
    374  0000 ????
    375  0000 ????				      MAC	lda@ply
    376  0000 ????				      lda	{0}
    377  0000 ????				      ENDM		;{}
    378  0000 ????
    379  0000 ????				      MAC	ldx@ply
    380  0000 ????				      ldx	{0}
    381  0000 ????				      ENDM		;{}
    382  0000 ????
    383  0000 ????				      MAC	ldy@ply
    384  0000 ????				      ldy	{0}
    385  0000 ????				      ENDM		;{}
    386  0000 ????
    387  0000 ????
    388  0000 ????				      MAC	adc@ply
    389  0000 ????				      adc	{0}
    390  0000 ????				      ENDM		;{}
    391  0000 ????
    392  0000 ????				      MAC	sbc@ply
    393  0000 ????				      sbc	{0}
    394  0000 ????				      ENDM		;{}
    395  0000 ????
    396  0000 ????
    397  0000 ????						;---------------------------------------------------------------------------------------------------
    398  0000 ????
    399  0000 ????				      MAC	newrambank
    400  0000 ????						; {1}	     bank name
    401  0000 ????						; {2}	     RAM bank number
    402  0000 ????
    403  0000 ????				      SEG.U	{1}
    404  0000 ????				      ORG	ORIGIN_RAM
    405  0000 ????				      RORG	RAM_3E
    406  0000 ????			   BANK_START SET	*
    407  0000 ????			   RAMBANK_{1} SET	ORIGIN_RAM / RAM_SIZE
    408  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    409  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    410  0000 ????				      ENDM		; bank name
    411  0000 ????
    412  0000 ????						; TODO - fix - this is faulty....
    413  0000 ????				      MAC	validate_ram_size
    414  0000 ????			   .RAM_BANK_SIZE SET	* - RAM_3E
    415  0000 ????				      IF	.RAM_BANK_SIZE > RAM_SIZE
    416  0000 ????				      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
    417  0000 ????				      ERR
    418  0000 ????				      ENDIF
    419  0000 ????				      ENDM
    420  0000 ????
    421  0000 ????						;---------------------------------------------------------------------------------------------------
    422  0000 ????
    423  0000 ????				      MAC	resync
    424  0000 ????						; resync screen, X and Y == 0 afterwards
    425  0000 ????				      lda	#%10	; make sure VBLANK is ON
    426  0000 ????				      sta	VBLANK
    427  0000 ????
    428  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    429  0000 ????			   .loopResync
    430  0000 ????				      VERTICAL_SYNC
    431  0000 ????
    432  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    433  0000 ????				      lda	Platform
    434  0000 ????				      eor	#PAL_50	; PAL-50?
    435  0000 ????				      bne	.ntsc
    436  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    437  0000 ????			   .ntsc
    438  0000 ????			   .loopWait
    439  0000 ????				      sta	WSYNC
    440  0000 ????				      sta	WSYNC
    441  0000 ????				      dey
    442  0000 ????				      bne	.loopWait
    443  0000 ????				      dex
    444  0000 ????				      bne	.loopResync
    445  0000 ????				      ENDM
    446  0000 ????
    447  0000 ????				      MAC	set_platform
    448  0000 ????						; 00 = NTSC
    449  0000 ????						; 01 = NTSC
    450  0000 ????						; 10 = PAL-50
    451  0000 ????						; 11 = PAL-60
    452  0000 ????				      lda	SWCHB
    453  0000 ????				      rol
    454  0000 ????				      rol
    455  0000 ????				      rol
    456  0000 ????				      and	#%11
    457  0000 ????				      eor	#PAL
    458  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    459  0000 ????				      ENDM
    460  0000 ????
    461  0000 ????
    462  0000 ????						;---------------------------------------------------------------------------------------------------
    463  0000 ????
    464  0000 ????				      MAC	jsrom_safe
    465  0000 ????						; Saves bank of routine to variable for later restore.
    466  0000 ????						; Switches to the bank and does a JSR to the routine.
    467  0000 ????
    468  0000 ????				      lda	#BANK_{1}
    469  0000 ????				      sta	savedBank
    470  0000 ????				      sta	SET_BANK
    471  0000 ????				      jsr	{1}
    472  0000 ????				      ENDM		; {routine}
    473  0000 ????
    474  0000 ????
    475  0000 ????				      MAC	jsrom
    476  0000 ????
    477  0000 ????				      lda	#BANK_{1}
    478  0000 ????				      sta	SET_BANK
    479  0000 ????				      jsr	{1}
    480  0000 ????				      ENDM		; {routine}
    481  0000 ????
    482  0000 ????
    483  0000 ????				      MAC	jsram
    484  0000 ????				      lda	#BANK_{1}
    485  0000 ????				      sta	SET_BANK_RAM
    486  0000 ????				      jsr	{1}
    487  0000 ????				      ENDM
    488  0000 ????
    489  0000 ????
    490  0000 ????
    491  0000 ????				      MAC	timecheck
    492  0000 ????				      lda	INTIM
    493  0000 ????				      cmp	#SPEEDOF_{1}
    494  0000 ????				      bcc	{2}
    495  0000 ????				      ENDM		; {ident}, {branch if out of time}
    496  0000 ????
    497  0000 ????
    498  0000 ????				      MAC	timing
    499  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    500  0000 ????				      ENDM		; {label}, {cycles}
    501  0000 ????
    502  0000 ????
    503  0000 ????						;---------------------------------------------------------------------------------------------------
    504  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 5
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00ff ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   savedBank  ds	1	; switched-in bank for FIXED returns
     24 U008c		       00	   aiState    ds	1	; state
     25 U008d		       00	   aiFlashDelay ds	1
     26 U008e
     27 U008e		       00	   aiMoveIndex ds	1
     28 U008f
     29 U008f		       00	   aiFlashPhase ds	1
     30 U0090
     31 U0090		       00 00	   Evaluation ds	2	; tracks value of the board position
     32 U0092
     33 U0092		       00	   currentPiece ds	1
     34 U0093		       00	   currentSquare ds	1
     35 U0094		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     36 U0095		       00	   currentPly ds	1
     37 U0096
     38 U0096							;    IFCONST PIECELIST_ENABLED
     39 U0096							;piecelistIndex		  ds 1
     40 U0096							;    ELSE
     41 U0096		       00	   squareIndex ds	1
     42 U0097							;    ENDIF
     43 U0097
     44 U0097
     45 U0097		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     46 U0098		       00	   fromPiece  ds	1
     47 U0099		       00	   lastPiece  ds	1
     48 U009a		       00	   previousPiece ds	1
     49 U009b
     50 U009b		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     51 U009c		       00 00	   speech_addr ds	2
     52 U009e		       00	   bg	      ds	1
     53 U009f
     54 U009f		       00	   capture    ds	1
     55 U00a0		       00	   captureLastPly ds	1
     56 U00a1
     57 U00a1					      IF	DIAGNOSTICS
     58 U00a1		       00 00 00    positionCount ds	3
     59 U00a4					      ENDIF
     60 U00a4
     61 U00a4							;maxPly			  ds 1
     62 U00a4		       00	   flagCheck  ds	1
     63 U00a5		       00	   protecting ds	1
     64 U00a6		       00	   spiral     ds	1
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 5
      0 U00a7					      include	"overlays.asm"
      1 U00a7							; Chess
      2 U00a7							; Atari 2600 Chess display system
      3 U00a7							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a7							; andrew@taswegian.com
      5 U00a7
      6 U00a7							;---------------------------------------------------------------------------------------------------
      7 U00a7							; OVERLAYS!
      8 U00a7							; These variables are overlays, and should be managed with care
      9 U00a7							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a7							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a7							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a7							; overlay #2
     13 U00a7
     14 U00a7							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a7
     16 U00a7							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a7							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a7							;---------------------------------------------------------------------------------------------------
     19 U00a7
     20 U00a7					      MAC	overlay
     21 U00a7				   OVERLAY_NAME SET	{1}
     22 U00a7					      SEG.U	OVERLAY_{1}
     23 U00a7					      org	Overlay
     24 U00a7					      ENDM		; {name}
     25 U00a7
     26 U00a7							;---------------------------------------------------------------------------------------------------
     27 U00a7
     28 U00a7					      MAC	validate_overlay
     29 U00a7					      LIST	OFF
     30 U00a7				   OVERLAY_DELTA SET	* - Overlay
     31 U00a7					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a7					      ENDIF
     34 U00a7					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a7					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a7					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a7					      ERR
     38 U00a7					      ENDIF
     39 U00a7					      LIST	ON
     40 U00a7					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a7					      ENDM
     42 U00a7
     43 U00a7							;---------------------------------------------------------------------------------------------------
     44 U00a7
     45 U00a7				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a7
     48 U00a7
     49 U00a7							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a7							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a7							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a7							; (especially the latter ones) are only used in rare occasions.
     53 U00a7
     54 U00a7							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a7							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a7
      0 U00a7					      DEF	Overlay
      1 U00a7				   BANK_Overlay SET	_CURRENT_BANK
      2 U00a7				   Overlay
      3 U00a7				   TEMPORARY_VAR SET	Overlay
      4 U00a7				   TEMPORARY_OFFSET SET	0
      5 U00a7				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      6 U00a7				   FUNCTION_NAME SET	Overlay
      7 U00a7					      SUBROUTINE
     58 U00a7		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00f3				   END_OF_OVERLAY
     60 U00f3
     61 U00f3							;---------------------------------------------------------------------------------------------------
     62 U00f3							; And now... the overlays....
     63 U00f3
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00f3					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00f3
     66 U00f3							;---------------------------------------------------------------------------------------------------
     67 U00f3
     68 U00f3							; Some overlays are used across multiple routines/calls, and they will need to be defined
     69 U00f3							; "globally" in this file.
     70 U00f3
      0 U00f3					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00f3		       00 a7	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00f3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00f3
      4 U00f3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00f3					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00f3				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00f3					      ENDIF
      8 U00f3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00f3				  -	      ECHO	"Temporary Variable", __pieceShapeBuffer, "overflow!"
     10 U00f3				  -	      ERR
     11 U00f3					      ENDIF
     12 U00f3					      LIST	ON
      0 U00f3					      VAR	__ptr, 2
      1 U00f3		       00 ef	   __ptr      =	TEMPORARY_VAR
      2 U00f3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00f3
      4 U00f3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00f3					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00f3				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00f3					      ENDIF
      8 U00f3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00f3				  -	      ECHO	"Temporary Variable", __ptr, "overflow!"
     10 U00f3				  -	      ERR
     11 U00f3					      ENDIF
     12 U00f3					      LIST	ON
      0 U00f3					      VAR	__ptr2, 2
      1 U00f3		       00 f1	   __ptr2     =	TEMPORARY_VAR
      2 U00f3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00f3
      4 U00f3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00f3					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00f3				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00f3					      ENDIF
      8 U00f3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00f3				  -	      ECHO	"Temporary Variable", __ptr2, "overflow!"
     10 U00f3				  -	      ERR
     11 U00f3					      ENDIF
     12 U00f3					      LIST	ON
     74 U00f3
     75 U00f3							;---------------------------------------------------------------------------------------------------
     76 U00f3
     77 U00f3
     78 U00f3					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     79 U00f3					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $4c
     80 U00f3					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     81 U00f3
     82 U00f3							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 5
      0 U00f3					      include	"stack.asm"
      1 U00f3							; Chess
      2 U00f3							; Atari 2600 Chess display system
      3 U00f3							; Copyright (c) 2019-2020 Andrew Davie
      4 U00f3							; andrew@taswegian.com
      5 U00f3
      6 U00f3
      7 U00f3		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00f3
      9 U00f3		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00ff
     11 U00ff							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00ff							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00ff							;  but since overlay is not generally stressed during alphabeta, we're good.
------- FILE ./chess.asm
    508 U00ff
 FREE BYTES IN ZERO PAGE =  $0
    509 U00ff					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    510 U00ff				  -	      IF	* > $FF
    511 U00ff				  -	      ERR	"Zero Page overflow!"
    512 U00ff					      ENDIF
    513 U00ff
    514 U00ff							;------------------------------------------------------------------------------
    515 U00ff							;##############################################################################
    516 U00ff							;------------------------------------------------------------------------------
    517 U00ff
    518 U00ff							; NOW THE VERY INTERESTING '3E' RAM BANKS
    519 U00ff							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 1k TOTAL ACCESSIBLE
    520 U00ff							; IN A 2K MEMORY SPACE
    521 U00ff
      0 U00ff					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00ff
      2 U00ff
      3 U00ff
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	RAM_3E
      7 U0000				   BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	ORIGIN_RAM / RAM_SIZE
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    523 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	RAM_3E
      7 U0400				   BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0400				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0400				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0400				  -	      ERR
      5 U0400					      ENDIF
    523 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	RAM_3E
      7 U0800				   BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0800				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0800				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0800				  -	      ERR
      5 U0800					      ENDIF
    523 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	RAM_3E
      7 U0c00				   BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0c00				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0c00				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0c00				  -	      ERR
      5 U0c00					      ENDIF
    523 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	RAM_3E
      7 U1000				   BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1000				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1000				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1000				  -	      ERR
      5 U1000					      ENDIF
    523 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	RAM_3E
      7 U1400				   BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1400				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1400				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1400				  -	      ERR
      5 U1400					      ENDIF
    523 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	RAM_3E
      7 U1800				   BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1800				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1800				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1800				  -	      ERR
      5 U1800					      ENDIF
    523 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	RAM_3E
      7 U1c00				   BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1c00				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1c00				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1c00				  -	      ERR
      5 U1c00					      ENDIF
    526 U1c00					      REPEND
    527 U1c00
    528 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    529 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    530 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    531 U1c00
    532 U1c00							; A neat feature of having multiple copies of the same code in different RAM banks
    533 U1c00							; is that we can use that code to switch between banks, and the system will happily
    534 U1c00							; execute the next instruction from the newly switched-in bank without a problem.
    535 U1c00
    536 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    537 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    538 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    539 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    540 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    541 U1c00
    542 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    543 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    544 U1c00
    545 U1c00							;------------------------------------------------------------------------------
    546 U1c00
    547 U1c00
    548 U1c00							;---------------------------------------------------------------------------------------------------
    549 U1c00
    550 U1c00
    551 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    552 U1c00
    553 U1c00					      MAC	next_random
    554 U1c00					      lda	rnd
    555 U1c00					      lsr
    556 U1c00					      bcc	.skipEOR
    557 U1c00					      eor	#RND_EOR_VAL
    558 U1c00				   .skipEOR   sta	rnd
    559 U1c00					      ENDM
    560 U1c00
    561 U1c00							;--------------------------------------------------------------------------------
    562 U1c00
    563 U1c00					      MAC	phase
    564 U1c00					      lda	#{1}
    565 U1c00					      sta	aiState
    566 U1c00					      ENDM		;#
    567 U1c00
    568 U1c00
    569 U1c00							;--------------------------------------------------------------------------------
    570 U1c00
    571 U1c00					      MAC	common_vars_alphabeta
    572 U1c00
    573 U1c00					      VAR	__thinkbar, 1
    574 U1c00					      VAR	__toggle, 1
    575 U1c00
    576 U1c00					      VAR	__bestMove, 1
    577 U1c00					      VAR	__alpha, 2
    578 U1c00					      VAR	__beta, 2
    579 U1c00					      VAR	__negaMax, 2
    580 U1c00					      VAR	__value, 2
    581 U1c00
    582 U1c00					      VAR	__quiesceCapOnly, 1
    583 U1c00
    584 U1c00					      ENDM
    585 U1c00
    586 U1c00
    587 U1c00							;--------------------------------------------------------------------------------
    588 U1c00
    589 U1c00							;ORIGIN      SET 0
    590 U1c00
------- FILE Handler_MACROS.asm LEVEL 2 PASS 5
      0 U1c00					      include	"Handler_MACROS.asm"
      1 U1c00							; Copyright (C)2020 Andrew Davie
      2 U1c00							; Common macros for piece move handlers
      3 U1c00
      4 U1c00							;---------------------------------------------------------------------------------------------------
      5 U1c00							; Looks at a square offset {1} to see if piece can move to it
      6 U1c00							; Adds the square to the movelist if it can
      7 U1c00							; Keeps moving in the same direction until it's blocked/off=board
      8 U1c00
      9 U1c00					      MAC	move_towards
     10 U1c00					      SUBROUTINE
     11 U1c00
     12 U1c00							; = 76 for single square (empty/take)
     13 U1c00
     14 U1c00					      lda	#0
     15 U1c00					      sta	capture
     16 U1c00
     17 U1c00					      ldx	currentSquare	; 3
     18 U1c00					      bne	.project	; 3   unconditional
     19 U1c00
     20 U1c00				   .empty     jsr	AddMove	; 57
     21 U1c00				   .project   ldy	ValidSquare+{1},x	; 4
     22 U1c00					      bmi	.invalid	; 2/3 off board!
     23 U1c00					      lda	Board,y	; 4   piece @ destination
     24 U1c00					      beq	.empty	; 2/3
     25 U1c00					      sta	capture
     26 U1c00					      eor	currentPiece	; 3
     27 U1c00					      bpl	.invalid	; 2/3 same colour
     28 U1c00					      jsr	AddMove	; 57  and exit
     29 U1c00
     30 U1c00				   .invalid
     31 U1c00					      ENDM
     32 U1c00
     33 U1c00
     34 U1c00							;---------------------------------------------------------------------------------------------------
     35 U1c00
     36 U1c00					      MAC	move_to
     37 U1c00					      SUBROUTINE
     38 U1c00					      ldy	ValidSquare+{1},x
     39 U1c00					      bmi	.invalid	; off board!
     40 U1c00					      lda	Board,y	; piece @ destination
     41 U1c00					      sta	capture
     42 U1c00					      beq	.squareEmpty
     43 U1c00					      eor	currentPiece
     44 U1c00					      bpl	.invalid	; same colour
     45 U1c00				   .squareEmpty jsr	AddMove
     46 U1c00				   .invalid
     47 U1c00					      ENDM
     48 U1c00
     49 U1c00
     50 U1c00							;---------------------------------------------------------------------------------------------------
     51 U1c00
     52 U1c00					      MAC	move_to_x
     53 U1c00					      ldx	currentSquare
     54 U1c00					      MOVE_TO	{1}
     55 U1c00					      ENDM
     56 U1c00
     57 U1c00
     58 U1c00							;---------------------------------------------------------------------------------------------------
     59 U1c00							; EOF
------- FILE ./chess.asm
    592 U1c00
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 5
      0 U1c00					      include	"BANK_GENERIC.asm"
      1 U1c00
      0 U1c00					      NEWBANK	GENERIC_BANK_1
      1  07d8 ????				      SEG	GENERIC_BANK_1
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	GENERIC_BANK_1
      3  0000
      0  0000					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  0000					      ALIGN	$400
      2  0000				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  0000				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
      5  0000
      6  0000				  -	      IF	0
      7  0000				  -	      IF	PLUSCART = YES
      8  0000				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
      9  0000				  -	      .byte	"pluscart.firmaplus.de", #0
     10  0000				  -	      ENDIF
     11  0000					      ENDIF
     12  0000
     13  0000		       85 3e a9 00 STELLA_AUTODETECT .byte.b	$85,$3e,$a9,$00	; 3E
     14  0004
     15  0004
     16  0004							;---------------------------------------------------------------------------------------------------
     17  0004							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     18  0004							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     19  0004							; bank finishes.  Just continue on from where it left off...
     20  0004							;---------------------------------------------------------------------------------------------------
     21  0004
      0  0004					      DEF	cartInit
      1  0004				   BANK_cartInit SET	_CURRENT_BANK
      2  0004				   cartInit
      3  0004				   TEMPORARY_VAR SET	Overlay
      4  0004				   TEMPORARY_OFFSET SET	0
      5  0004				   VAR_BOUNDARY_cartInit SET	TEMPORARY_OFFSET
      6  0004				   FUNCTION_NAME SET	cartInit
      7  0004					      SUBROUTINE
     23  0004					      SUBROUTINE
     24  0004
      0  0004					      REFER	Reset
      1  0004				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0004				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0004					      ENDIF
      0  0004					      VEND	cartInit
      1  0004				  -	      IFNCONST	cartInit
      2  0004				  -	      ECHO	"Incorrect VEND label", cartInit
      3  0004				  -	      ERR
      4  0004					      ENDIF
      5  0004		       00 a7	   VAREND_cartInit =	TEMPORARY_VAR
     27  0004
     28  0004		       78		      sei
     29  0005		       d8		      cld
     30  0006
     31  0006							; See if we can come up with something 'random' for startup
     32  0006
     33  0006		       ac 84 02 	      ldy	INTIM
     34  0009		       d0 02		      bne	.toR
     35  000b		       a0 9a		      ldy	#$9A
     36  000d		       84 81	   .toR       sty	rnd
     37  000f
     38  000f
     39  000f		       a9 00		      lda	#0
     40  0011		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     41  0014		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     42  0017		       85 6b		      sta	HMCLR
     43  0019
     44  0019							; cleanup remains of title screen
     45  0019		       85 5b		      sta	GRP0
     46  001b		       85 5c		      sta	GRP1
     47  001d
     48  001d		       a9 10		      lda	#%00010000	; double width missile, double width player
     49  001f		       85 44		      sta	NUSIZ0
     50  0021		       85 45		      sta	NUSIZ1
     51  0023
     52  0023		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     53  0025		       85 4a		      sta	CTRLPF
     54  0027
     55  0027		       a9 0a		      lda	#WHITE+RAMBANK_PLY
     56  0029		       85 97		      sta	sideToMove
     57  002b
     58  002b
     59  002b							;		      rts
     60  002b							;   ; fall through...
     61  002b
     62  002b							;---------------------------------------------------------------------------------------------------
     63  002b
      0  002b					      DEF	SetupBanks
      1  002b				   BANK_SetupBanks SET	_CURRENT_BANK
      2  002b				   SetupBanks
      3  002b				   TEMPORARY_VAR SET	Overlay
      4  002b				   TEMPORARY_OFFSET SET	0
      5  002b				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      6  002b				   FUNCTION_NAME SET	SetupBanks
      7  002b					      SUBROUTINE
     65  002b					      SUBROUTINE
     66  002b
     67  002b							; Move a copy of the row bank template to the first 8 banks of RAM
     68  002b							; and then terminate the draw subroutine by substituting in a RTS on the last one
     69  002b
      0  002b					      REFER	Reset
      1  002b				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  002b				  -TEMPORARY_VAR SET	VAREND_Reset
      3  002b					      ENDIF
      0  002b					      VAR	__plyBank, 1
      1  002b		       00 a7	   __plyBank  =	TEMPORARY_VAR
      2  002b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  002b
      4  002b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  002b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  002b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  002b					      ENDIF
      8  002b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  002b				  -	      ECHO	"Temporary Variable", __plyBank, "overflow!"
     10  002b				  -	      ERR
     11  002b					      ENDIF
     12  002b					      LIST	ON
      0  002b					      VEND	SetupBanks
      1  002b				  -	      IFNCONST	SetupBanks
      2  002b				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  002b				  -	      ERR
      4  002b					      ENDIF
      5  002b		       00 a8	   VAREND_SetupBanks =	TEMPORARY_VAR
     73  002b
     74  002b							; SAFE
     75  002b
     76  002b		       a0 07		      ldy	#7
     77  002d		       a2 02	   .copyRowBanks ldx	#BANK_ROM_SHADOW_OF_CHESS_BITMAP
     78  002f		       20 bd fc 	      jsr	CopyShadowROMtoRAM
     79  0032		       88		      dey
     80  0033		       10 f8		      bpl	.copyRowBanks
     81  0035
     82  0035
     83  0035							; copy the BOARD/MOVES bank
     84  0035
     85  0035		       a0 09		      ldy	#RAMBANK_BOARD
     86  0037		       a2 0c		      ldx	#MOVES
     87  0039		       20 bd fc 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
     88  003c
     89  003c							; copy the PLY banks
     90  003c
     91  003c		       a9 08		      lda	#PLY_BANKS
     92  003e		       85 a7		      sta	__plyBank
     93  0040		       a0 0a		      ldy	#RAMBANK_PLY
     94  0042		       84 95		      sty	currentPly
     95  0044		       a2 0d	   .copyPlyBanks ldx	#BANK_PLY
     96  0046		       20 bd fc 	      jsr	CopyShadowROMtoRAM
     97  0049		       c8		      iny
     98  004a		       c6 a7		      dec	__plyBank
     99  004c		       d0 f6		      bne	.copyPlyBanks
    100  004e
    101  004e							; copy the evaluation code/tables
    102  004e
    103  004e		       a0 12		      ldy	#RAMBANK_BANK_EVAL
    104  0050		       a2 0e		      ldx	#EVAL
    105  0052		       20 bd fc 	      jsr	CopyShadowROMtoRAM
    106  0055
    107  0055		       a0 08		      ldy	#RAMBANK_RAM_PIECELIST
    108  0057		       a2 09		      ldx	#ROM_PIECELIST
    109  0059		       20 bd fc 	      jsr	CopyShadowROMtoRAM
    110  005c
    111  005c		       60		      rts
    112  005d
    113  005d
    114  005d							;---------------------------------------------------------------------------------------------------
    115  005d
      0  005d					      DEF	tidySc
      1  005d				   BANK_tidySc SET	_CURRENT_BANK
      2  005d				   tidySc
      3  005d				   TEMPORARY_VAR SET	Overlay
      4  005d				   TEMPORARY_OFFSET SET	0
      5  005d				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      6  005d				   FUNCTION_NAME SET	tidySc
      7  005d					      SUBROUTINE
    117  005d					      SUBROUTINE
    118  005d
    119  005d		       a9 00		      lda	#0
    120  005f		       85 4d		      sta	PF0
    121  0061		       85 4e		      sta	PF1
    122  0063		       85 4f		      sta	PF2
    123  0065		       85 5b		      sta	GRP0
    124  0067		       85 5c		      sta	GRP1
    125  0069
    126  0069		       a9 42		      lda	#%01000010	; bit6 is not required
    127  006b							;sta VBLANK			  ; end of screen - enter blanking
    128  006b
    129  006b
    130  006b							; END OF VISIBLE SCREEN
    131  006b							; HERE'S SOME TIME TO DO STUFF
    132  006b
    133  006b		       a9 2e		      lda	#TIME_PART_2
    134  006d		       8d 96 02 	      sta	TIM64T
    135  0070		       60		      rts
    136  0071
    137  0071
    138  0071							;---------------------------------------------------------------------------------------------------
    139  0071
      0  0071					      DEF	longD
      1  0071				   BANK_longD SET	_CURRENT_BANK
      2  0071				   longD
      3  0071				   TEMPORARY_VAR SET	Overlay
      4  0071				   TEMPORARY_OFFSET SET	0
      5  0071				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      6  0071				   FUNCTION_NAME SET	longD
      7  0071					      SUBROUTINE
    141  0071					      SUBROUTINE
    142  0071
    143  0071		       85 42		      sta	WSYNC
    144  0073
    145  0073		       20 70 f8 	      jsr	_rts
    146  0076		       20 70 f8 	      jsr	_rts
    147  0079		       20 70 f8 	      jsr	_rts
      0  007c					      SLEEP	7
      1  007c				   .CYCLES    SET	7
      2  007c
      3  007c				  -	      IF	.CYCLES < 2
      4  007c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  007c				  -	      ERR
      6  007c					      ENDIF
      7  007c
      8  007c					      IF	.CYCLES & 1
      9  007c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  007c		       04 00		      nop	0
     11  007e				  -	      ELSE
     12  007e				  -	      bit	VSYNC
     13  007e					      ENDIF
     14  007e				   .CYCLES    SET	.CYCLES - 3
     15  007e					      ENDIF
     16  007e
     17  007e					      REPEAT	.CYCLES / 2
     18  007e		       ea		      nop
     17  007e					      REPEND
     18  007f		       ea		      nop
     19  0080					      REPEND
    149  0080
    150  0080		       a2 00		      ldx	#0
    151  0082		       86 41		      stx	VBLANK
    152  0084		       60		      rts
    153  0085
    154  0085				  -	      IF	0
    155  0085				  -	      DEF	Resync
    156  0085				  -	      SUBROUTINE
    157  0085				  -
    158  0085				  -	      RESYNC
    159  0085				  -	      rts
    160  0085					      ENDIF
    161  0085
    162  0085
    163  0085							;---------------------------------------------------------------------------------------------------
    164  0085
      0  0085					      DEF	aiStartClearBoard
      1  0085				   BANK_aiStartClearBoard SET	_CURRENT_BANK
      2  0085				   aiStartClearBoard
      3  0085				   TEMPORARY_VAR SET	Overlay
      4  0085				   TEMPORARY_OFFSET SET	0
      5  0085				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      6  0085				   FUNCTION_NAME SET	aiStartClearBoard
      7  0085					      SUBROUTINE
    166  0085					      SUBROUTINE
    167  0085
      0  0085					      REFER	AiStateMachine
      1  0085				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0085				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0085					      ENDIF
      0  0085					      VEND	aiStartClearBoard
      1  0085				  -	      IFNCONST	aiStartClearBoard
      2  0085				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  0085				  -	      ERR
      4  0085					      ENDIF
      5  0085		       00 a7	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
    170  0085
    171  0085		       a2 08		      ldx	#8
    172  0087		       86 84		      stx	drawCount	; = bank
    173  0089
    174  0089		       a9 ff		      lda	#-1
    175  008b		       85 88		      sta	cursorX12
    176  008d
      0  008d					      PHASE	AI_ClearEachRow
      1  008d		       a9 0e		      lda	#AI_ClearEachRow
      2  008f		       85 8c		      sta	aiState
    178  0091		       60		      rts
    179  0092
    180  0092							;---------------------------------------------------------------------------------------------------
    181  0092
      0  0092					      DEF	aiClearEachRow
      1  0092				   BANK_aiClearEachRow SET	_CURRENT_BANK
      2  0092				   aiClearEachRow
      3  0092				   TEMPORARY_VAR SET	Overlay
      4  0092				   TEMPORARY_OFFSET SET	0
      5  0092				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      6  0092				   FUNCTION_NAME SET	aiClearEachRow
      7  0092					      SUBROUTINE
    183  0092					      SUBROUTINE
    184  0092
      0  0092					      REFER	AiStateMachine
      1  0092				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0092				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0092					      ENDIF
      0  0092					      VEND	aiClearEachRow
      1  0092				  -	      IFNCONST	aiClearEachRow
      2  0092				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  0092				  -	      ERR
      4  0092					      ENDIF
      5  0092		       00 a7	   VAREND_aiClearEachRow =	TEMPORARY_VAR
    187  0092
    188  0092		       c6 84		      dec	drawCount
    189  0094		       30 05		      bmi	.bitmapCleared
    190  0096		       a4 84		      ldy	drawCount
    191  0098		       4c 7d f8 	      jmp	CallClear
    192  009b
    193  009b				   .bitmapCleared
    194  009b
    195  009b		       a9 63		      lda	#99
    196  009d		       85 80		      sta	squareToDraw
    197  009f
      0  009f					      PHASE	AI_DrawEntireBoard
      1  009f		       a9 0f		      lda	#AI_DrawEntireBoard
      2  00a1		       85 8c		      sta	aiState
    199  00a3		       60		      rts
    200  00a4
    201  00a4
    202  00a4
    203  00a4							;---------------------------------------------------------------------------------------------------
    204  00a4
      0  00a4					      DEF	aiMoveIsSelected
      1  00a4				   BANK_aiMoveIsSelected SET	_CURRENT_BANK
      2  00a4				   aiMoveIsSelected
      3  00a4				   TEMPORARY_VAR SET	Overlay
      4  00a4				   TEMPORARY_OFFSET SET	0
      5  00a4				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      6  00a4				   FUNCTION_NAME SET	aiMoveIsSelected
      7  00a4					      SUBROUTINE
    206  00a4					      SUBROUTINE
    207  00a4
      0  00a4					      REFER	AiStateMachine
      1  00a4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00a4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00a4					      ENDIF
      0  00a4					      VEND	aiMoveIsSelected
      1  00a4				  -	      IFNCONST	aiMoveIsSelected
      2  00a4				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  00a4				  -	      ERR
      4  00a4					      ENDIF
      5  00a4		       00 a7	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    210  00a4
    211  00a4
    212  00a4							; Both computer and human have now seleted a move, and converge here
    213  00a4
    214  00a4
    215  00a4							; fromPiece	 piece doing the move
    216  00a4							; fromX12	 current square X12
    217  00a4							; originX12	 starting square X12
    218  00a4							; toX12	 ending square X12
    219  00a4
    220  00a4
    221  00a4
    222  00a4		       20 82 f9 	      jsr	AdjustMaterialPositionalValue
    223  00a7
    224  00a7		       a9 00		      lda	#BLANK
    225  00a9		       85 9a		      sta	previousPiece
    226  00ab
    227  00ab							;lda toSquare
    228  00ab							;cmp fromSquare
    229  00ab							;beq .idleErase
    230  00ab
    231  00ab		       a9 0a		      lda	#10	; on/off count
    232  00ad		       85 84		      sta	drawCount	; flashing for piece about to move
    233  00af		       a9 00		      lda	#0
    234  00b1		       85 82		      sta	drawDelay
    235  00b3
      0  00b3					      PHASE	AI_WriteStartPieceBlank
      1  00b3		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  00b5		       85 8c		      sta	aiState
    237  00b7		       60	   .idleErase rts
    238  00b8
    239  00b8
    240  00b8							;---------------------------------------------------------------------------------------------------
    241  00b8
      0  00b8					      DEF	aiWriteStartPieceBlank
      1  00b8				   BANK_aiWriteStartPieceBlank SET	_CURRENT_BANK
      2  00b8				   aiWriteStartPieceBlank
      3  00b8				   TEMPORARY_VAR SET	Overlay
      4  00b8				   TEMPORARY_OFFSET SET	0
      5  00b8				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      6  00b8				   FUNCTION_NAME SET	aiWriteStartPieceBlank
      7  00b8					      SUBROUTINE
    243  00b8					      SUBROUTINE
    244  00b8
      0  00b8					      REFER	AiStateMachine
      1  00b8				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00b8				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00b8					      ENDIF
      0  00b8					      VEND	aiWriteStartPieceBlank
      1  00b8				  -	      IFNCONST	aiWriteStartPieceBlank
      2  00b8				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  00b8				  -	      ERR
      4  00b8					      ENDIF
      5  00b8		       00 a7	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    247  00b8
    248  00b8							; Flash the piece in-place preparatory to moving it.
    249  00b8							; drawDelay = flash speed
    250  00b8							; drawCount = # of flashes
    251  00b8
    252  00b8		       a5 87		      lda	originX12
    253  00ba		       85 88		      sta	cursorX12
    254  00bc
    255  00bc		       a9 04		      lda	#%100
    256  00be		       85 4a		      sta	CTRLPF
    257  00c0		       a9 02		      lda	#2
    258  00c2		       85 46		      sta	COLUP0
    259  00c4
    260  00c4
    261  00c4		       a5 82		      lda	drawDelay
    262  00c6		       f0 03		      beq	deCount
    263  00c8		       c6 82		      dec	drawDelay
    264  00ca		       60		      rts
    265  00cb				   deCount
    266  00cb
    267  00cb		       a5 84		      lda	drawCount
    268  00cd		       f0 0e		      beq	flashDone
    269  00cf		       c6 84		      dec	drawCount
    270  00d1
    271  00d1		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    272  00d3		       85 82		      sta	drawDelay	; "getting ready to move" flash
    273  00d5
    274  00d5		       a5 85		      lda	fromX12
    275  00d7		       85 80		      sta	squareToDraw
    276  00d9
    277  00d9		       20 ed fc 	      jsr	CopySinglePiece	; EOR-draw = flash
    278  00dc		       60		      rts
    279  00dd
    280  00dd				   flashDone
    281  00dd
      0  00dd					      PHASE	AI_MarchToTargetA
      1  00dd		       a9 16		      lda	#AI_MarchToTargetA
      2  00df		       85 8c		      sta	aiState
    283  00e1		       60		      rts
    284  00e2
    285  00e2
    286  00e2							;---------------------------------------------------------------------------------------------------
    287  00e2
      0  00e2					      DEF	aiDrawPart2
      1  00e2				   BANK_aiDrawPart2 SET	_CURRENT_BANK
      2  00e2				   aiDrawPart2
      3  00e2				   TEMPORARY_VAR SET	Overlay
      4  00e2				   TEMPORARY_OFFSET SET	0
      5  00e2				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      6  00e2				   FUNCTION_NAME SET	aiDrawPart2
      7  00e2					      SUBROUTINE
    289  00e2					      SUBROUTINE
    290  00e2
      0  00e2					      REFER	AiStateMachine
      1  00e2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00e2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00e2					      ENDIF
      0  00e2					      VEND	aiDrawPart2
      1  00e2				  -	      IFNCONST	aiDrawPart2
      2  00e2				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  00e2				  -	      ERR
      4  00e2					      ENDIF
      5  00e2		       00 a7	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
    293  00e2
    294  00e2		       20 ed fc 	      jsr	CopySinglePiece
    295  00e5
      0  00e5					      DEF	aiDrawPart3
      1  00e5				   BANK_aiDrawPart3 SET	_CURRENT_BANK
      2  00e5				   aiDrawPart3
      3  00e5				   TEMPORARY_VAR SET	Overlay
      4  00e5				   TEMPORARY_OFFSET SET	0
      5  00e5				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      6  00e5				   FUNCTION_NAME SET	aiDrawPart3
      7  00e5					      SUBROUTINE
    297  00e5					      SUBROUTINE
    298  00e5
    299  00e5		       c6 80		      dec	squareToDraw
    300  00e7		       a5 80		      lda	squareToDraw
    301  00e9		       c9 16		      cmp	#22
    302  00eb		       90 05		      bcc	.comp
    303  00ed
      0  00ed					      PHASE	AI_DrawEntireBoard
      1  00ed		       a9 0f		      lda	#AI_DrawEntireBoard
      2  00ef		       85 8c		      sta	aiState
    305  00f1		       60		      rts
    306  00f2
    307  00f2				   .comp
    308  00f2
    309  00f2		       a9 ff		      lda	#-1
    310  00f4		       85 86		      sta	toX12	; becomes startup flash square
    311  00f6		       a9 24		      lda	#36	; becomes cursor position
    312  00f8		       85 87		      sta	originX12
    313  00fa
    314  00fa
      0  00fa					      PHASE	AI_GenerateMoves
      1  00fa		       a9 12		      lda	#AI_GenerateMoves
      2  00fc		       85 8c		      sta	aiState
    316  00fe		       60		      rts
    317  00ff
    318  00ff
    319  00ff
    320  00ff
    321  00ff							;---------------------------------------------------------------------------------------------------
    322  00ff
      0  00ff					      DEF	aiMarchB
      1  00ff				   BANK_aiMarchB SET	_CURRENT_BANK
      2  00ff				   aiMarchB
      3  00ff				   TEMPORARY_VAR SET	Overlay
      4  00ff				   TEMPORARY_OFFSET SET	0
      5  00ff				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      6  00ff				   FUNCTION_NAME SET	aiMarchB
      7  00ff					      SUBROUTINE
    324  00ff					      SUBROUTINE
    325  00ff
      0  00ff					      REFER	AiStateMachine
      1  00ff				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00ff				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00ff					      ENDIF
      0  00ff					      VEND	aiMarchB
      1  00ff				  -	      IFNCONST	aiMarchB
      2  00ff				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  00ff				  -	      ERR
      4  00ff					      ENDIF
      5  00ff		       00 a7	   VAREND_aiMarchB =	TEMPORARY_VAR
    328  00ff
    329  00ff							; Draw the piece in the new square
    330  00ff
    331  00ff		       a5 85		      lda	fromX12
    332  0101		       85 80		      sta	squareToDraw
    333  0103
    334  0103		       20 ed fc 	      jsr	CopySinglePiece	; draw the moving piece into the new square
    335  0106
    336  0106		       a9 06		      lda	#6	; snail trail delay
    337  0108		       85 82		      sta	drawDelay
    338  010a
      0  010a					      PHASE	AI_MarchToTargetB
      1  010a		       a9 19		      lda	#AI_MarchToTargetB
      2  010c		       85 8c		      sta	aiState
    340  010e		       60		      rts
    341  010f
    342  010f
    343  010f							;---------------------------------------------------------------------------------------------------
    344  010f
      0  010f					      DEF	aiFinalFlash
      1  010f				   BANK_aiFinalFlash SET	_CURRENT_BANK
      2  010f				   aiFinalFlash
      3  010f				   TEMPORARY_VAR SET	Overlay
      4  010f				   TEMPORARY_OFFSET SET	0
      5  010f				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      6  010f				   FUNCTION_NAME SET	aiFinalFlash
      7  010f					      SUBROUTINE
    346  010f					      SUBROUTINE
    347  010f
      0  010f					      REFER	AiStateMachine
      1  010f				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  010f				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  010f					      ENDIF
      0  010f					      VEND	aiFinalFlash
      1  010f				  -	      IFNCONST	aiFinalFlash
      2  010f				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  010f				  -	      ERR
      4  010f					      ENDIF
      5  010f		       00 a7	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    350  010f
    351  010f
    352  010f		       a5 82		      lda	drawDelay
    353  0111		       f0 03		      beq	.deCount
    354  0113		       c6 82		      dec	drawDelay
    355  0115		       60		      rts
    356  0116
    357  0116		       a5 84	   .deCount   lda	drawCount
    358  0118		       f0 0e		      beq	.flashDone2
    359  011a		       c6 84		      dec	drawCount
    360  011c
    361  011c		       a9 0a		      lda	#10
    362  011e		       85 82		      sta	drawDelay	; "getting ready to move" flash
    363  0120
    364  0120		       a5 85		      lda	fromX12
    365  0122		       85 80		      sta	squareToDraw
    366  0124
    367  0124		       20 ed fc 	      jsr	CopySinglePiece
    368  0127		       60		      rts
    369  0128
    370  0128				   .flashDone2
    371  0128
    372  0128		       a9 64		      lda	#100
    373  012a		       85 8d		      sta	aiFlashDelay
    374  012c
      0  012c					      PHASE	AI_SpecialMoveFixup
      1  012c		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  012e		       85 8c		      sta	aiState
    376  0130		       60		      rts
    377  0131
    378  0131
    379  0131							;---------------------------------------------------------------------------------------------------
    380  0131
      0  0131					      DEF	aiDraw
      1  0131				   BANK_aiDraw SET	_CURRENT_BANK
      2  0131				   aiDraw
      3  0131				   TEMPORARY_VAR SET	Overlay
      4  0131				   TEMPORARY_OFFSET SET	0
      5  0131				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      6  0131				   FUNCTION_NAME SET	aiDraw
      7  0131					      SUBROUTINE
    382  0131					      SUBROUTINE
    383  0131		       a9 c0		      lda	#$C0
    384  0133		       85 49		      sta	COLUBK
    385  0135		       60		      rts
    386  0136
    387  0136
    388  0136							;---------------------------------------------------------------------------------------------------
    389  0136
      0  0136					      DEF	aiCheckMate
      1  0136				   BANK_aiCheckMate SET	_CURRENT_BANK
      2  0136				   aiCheckMate
      3  0136				   TEMPORARY_VAR SET	Overlay
      4  0136				   TEMPORARY_OFFSET SET	0
      5  0136				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      6  0136				   FUNCTION_NAME SET	aiCheckMate
      7  0136					      SUBROUTINE
    391  0136					      SUBROUTINE
    392  0136		       a9 44		      lda	#$44
    393  0138		       85 49		      sta	COLUBK
    394  013a		       60		      rts
    395  013b
    396  013b
    397  013b							;---------------------------------------------------------------------------------------------------
    398  013b
      0  013b					      DEF	InitPieceLists
      1  013b				   BANK_InitPieceLists SET	_CURRENT_BANK
      2  013b				   InitPieceLists
      3  013b				   TEMPORARY_VAR SET	Overlay
      4  013b				   TEMPORARY_OFFSET SET	0
      5  013b				   VAR_BOUNDARY_InitPieceLists SET	TEMPORARY_OFFSET
      6  013b				   FUNCTION_NAME SET	InitPieceLists
      7  013b					      SUBROUTINE
    400  013b					      SUBROUTINE
    401  013b
      0  013b					      REFER	InitialisePieceSquares
      1  013b					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  013b				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  013b					      ENDIF
      0  013b					      VEND	InitPieceLists
      1  013b				  -	      IFNCONST	InitPieceLists
      2  013b				  -	      ECHO	"Incorrect VEND label", InitPieceLists
      3  013b				  -	      ERR
      4  013b					      ENDIF
      5  013b		       00 aa	   VAREND_InitPieceLists =	TEMPORARY_VAR
    404  013b
    405  013b							;lda #-1
    406  013b							;sta@RAM SquarePtr ;PieceListPtr
    407  013b
    408  013b							; TODO: move the following as they're called 2x due to double-call of InitPiecLists
    409  013b
    410  013b		       a9 00		      lda	#0
    411  013d		       85 90		      sta	Evaluation
    412  013f		       85 91		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    413  0141
    414  0141
    415  0141							; General inits that are moved out of FIXED....
    416  0141
    417  0141		       a9 07		      lda	#%111
    418  0143		       85 44		      sta	NUSIZ0
    419  0145		       85 45		      sta	NUSIZ1	; quad-width
    420  0147
    421  0147		       a9 04		      lda	#%00000100
    422  0149		       85 4a		      sta	CTRLPF
    423  014b		       a9 00		      lda	#BACKGCOL
    424  014d		       85 49		      sta	COLUBK
    425  014f
      0  014f					      PHASE	AI_StartClearBoard
      1  014f		       a9 0d		      lda	#AI_StartClearBoard
      2  0151		       85 8c		      sta	aiState
    427  0153		       60		      rts
    428  0154
    429  0154							;---------------------------------------------------------------------------------------------------
    430  0154
    431  0154
      0  0154					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1"
      1  0154
      2  0154
      3  0154		       01 54	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (1K) SIZE =  $154 , FREE= $2ac
      4  0154					      ECHO	"GENERIC_BANK_1", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0154				  -	      IF	( .TEMP ) > ROM_BANK_SIZE/2
      6  0154				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0154				  -	      ERR
      8  0154					      ENDIF
    433  0154
    434  0154
    435  0154							;---------------------------------------------------------------------------------------------------
    436  0154
------- FILE piece_vectors.asm LEVEL 3 PASS 5
      0  0154					      include	"piece_vectors.asm"
      1  0154							; Created by ConvertChessPieces.py
      0  0154					      DEF	PIECE_VECTOR_LO
      1  0154				   BANK_PIECE_VECTOR_LO SET	_CURRENT_BANK
      2  0154				   PIECE_VECTOR_LO
      3  0154				   TEMPORARY_VAR SET	Overlay
      4  0154				   TEMPORARY_OFFSET SET	0
      5  0154				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      6  0154				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      7  0154					      SUBROUTINE
      3  0154		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  0155		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  0156		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  0157		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  0158		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  0159		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  015a		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  015b		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  015c		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  015d		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  015e		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  015f		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  0160		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  0161		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  0162		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  0163		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  0164		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  0165		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  0166		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  0167		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  0168		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  0169		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  016a		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  016b		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  016c		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  016d		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  016e		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  016f		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  0170		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  0171		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  0172		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  0173		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  0174		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  0175		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  0176		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  0177		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  0178		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  0179		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  017a		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  017b		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  017c		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  017d		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  017e		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  017f		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  0180		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  0181		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  0182		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  0183		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  0184		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  0185		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  0186		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  0187		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  0188		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  0189		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  018a		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  018b		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  018c		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  018d		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  018e		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  018f		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  0190		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  0191		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  0192		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  0193		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  0194		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  0195		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  0196		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  0197		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  0198		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  0199		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  019a		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  019b		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  019c		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  019d		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  019e		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  019f		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  01a0		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  01a1		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  01a2		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  01a3		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  01a4		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  01a5		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  01a6		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  01a7		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  01a8		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  01a9		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  01aa		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  01ab		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  01ac		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  01ad		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  01ae		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  01af		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  01b0		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  01b1		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  01b2		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  01b3		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  01b4		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  01b5		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  01b6		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  01b7		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  01b8		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  01b9		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  01ba		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  01bb		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  01bc		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  01bd		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  01be		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  01bf		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  01c0		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  01c1		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  01c2		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  01c3		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  01c4		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  01c5		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  01c6		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  01c7		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  01c8		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  01c9		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  01ca		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  01cb		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  01cc		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  01cd		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  01ce		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  01cf		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  01d0		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  01d1		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  01d2		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  01d3		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  01d4		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  01d5		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  01d6		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  01d7		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  01d8		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  01d9		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  01da		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  01db		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  01dc		       38		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  01dd		       80		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  01de		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  01df		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  01e0		       04		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  01e1		       4c		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  01e2		       94		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  01e3		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  01e4					      DEF	PIECE_VECTOR_HI
      1  01e4				   BANK_PIECE_VECTOR_HI SET	_CURRENT_BANK
      2  01e4				   PIECE_VECTOR_HI
      3  01e4				   TEMPORARY_VAR SET	Overlay
      4  01e4				   TEMPORARY_OFFSET SET	0
      5  01e4				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      6  01e4				   FUNCTION_NAME SET	PIECE_VECTOR_HI
      7  01e4					      SUBROUTINE
    148  01e4		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  01e5		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  01e6		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  01e7		       f1		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  01e8		       f1		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  01e9		       f1		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  01ea		       f2		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  01eb		       f2		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  01ec		       f2		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  01ed		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  01ee		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  01ef		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  01f0		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  01f1		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  01f2		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  01f3		       f5		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  01f4		       f5		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  01f5		       f5		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  01f6		       f6		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  01f7		       f6		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  01f8		       f6		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  01f9		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  01fa		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  01fb		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  01fc		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  01fd		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  01fe		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  01ff		       f1		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  0200		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  0201		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  0202		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  0203		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  0204		       f5		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  0205		       f5		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  0206		       f6		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  0207		       f6		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  0208		       f1		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  0209		       f1		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  020a		       f2		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  020b		       f2		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  020c		       f2		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  020d		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  020e		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  020f		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  0210		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  0211		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  0212		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  0213		       f5		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  0214		       f5		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  0215		       f5		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  0216		       f6		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  0217		       f6		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  0218		       f6		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  0219		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  021a		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  021b		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  021c		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  021d		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  021e		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  021f		       f1		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  0220		       f1		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  0221		       f1		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  0222		       f2		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  0223		       f2		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  0224		       f5		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  0225		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  0226		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  0227		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  0228		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  0229		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  022a		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  022b		       f5		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  022c		       f2		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  022d		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  022e		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  022f		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  0230		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  0231		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  0232		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  0233		       f5		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  0234		       f5		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  0235		       f5		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  0236		       f6		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  0237		       f6		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  0238		       f6		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  0239		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  023a		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  023b		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  023c		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  023d		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  023e		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  023f		       f1		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  0240		       f1		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  0241		       f1		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  0242		       f2		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  0243		       f2		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  0244		       f2		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  0245		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  0246		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  0247		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  0248		       f5		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  0249		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  024a		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  024b		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  024c		       f4		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  024d		       f4		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  024e		       f5		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  024f		       f5		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  0250		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  0251		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  0252		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  0253		       f5		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  0254		       f5		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  0255		       f5		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  0256		       f6		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  0257		       f6		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  0258		       f6		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  0259		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  025a		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  025b		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  025c		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  025d		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  025e		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  025f		       f3		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  0260		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  0261		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  0262		       f4		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  0263		       f4		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  0264		       f4		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  0265		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  0266		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  0267		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  0268		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  0269		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  026a		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  026b		       f7		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  026c		       f4		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  026d		       f4		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  026e		       f5		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  026f		       f5		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  0270		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  0271		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  0272		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  0273		       f4		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  0274					      DEF	PIECE_VECTOR_BANK
      1  0274				   BANK_PIECE_VECTOR_BANK SET	_CURRENT_BANK
      2  0274				   PIECE_VECTOR_BANK
      3  0274				   TEMPORARY_VAR SET	Overlay
      4  0274				   TEMPORARY_OFFSET SET	0
      5  0274				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      6  0274				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
      7  0274					      SUBROUTINE
    293  0274		       03		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  0275		       03		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  0276		       03		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  0277		       03		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  0278		       03		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  0279		       03		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  027a		       03		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  027b		       03		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  027c		       03		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  027d		       03		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  027e		       03		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  027f		       03		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  0280		       03		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  0281		       03		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  0282		       03		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  0283		       03		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  0284		       03		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  0285		       03		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  0286		       03		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  0287		       03		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  0288		       03		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  0289		       03		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  028a		       03		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  028b		       03		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  028c		       04		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  028d		       04		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  028e		       04		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  028f		       04		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  0290		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  0291		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  0292		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  0293		       0b		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  0294		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  0295		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  0296		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  0297		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  0298		       04		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  0299		       04		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  029a		       04		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  029b		       04		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  029c		       04		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  029d		       04		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  029e		       04		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  029f		       04		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  02a0		       04		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  02a1		       04		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  02a2		       04		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  02a3		       04		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  02a4		       04		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  02a5		       04		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  02a6		       04		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  02a7		       04		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  02a8		       04		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  02a9		       04		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  02aa		       04		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  02ab		       04		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  02ac		       05		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  02ad		       05		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  02ae		       05		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  02af		       05		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  02b0		       05		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  02b1		       05		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  02b2		       05		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  02b3		       05		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  02b4		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  02b5		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  02b6		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  02b7		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  02b8		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  02b9		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  02ba		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  02bb		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  02bc		       05		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  02bd		       05		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  02be		       05		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  02bf		       05		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  02c0		       05		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  02c1		       05		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  02c2		       05		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  02c3		       05		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  02c4		       05		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  02c5		       05		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  02c6		       05		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  02c7		       05		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  02c8		       05		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  02c9		       05		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  02ca		       05		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  02cb		       05		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  02cc		       06		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  02cd		       06		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  02ce		       06		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  02cf		       06		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  02d0		       06		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  02d1		       06		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  02d2		       06		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  02d3		       06		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  02d4		       06		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  02d5		       06		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  02d6		       06		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  02d7		       06		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  02d8		       07		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  02d9		       07		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  02da		       07		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  02db		       07		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  02dc		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  02dd		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  02de		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  02df		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  02e0		       06		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  02e1		       06		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  02e2		       06		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  02e3		       06		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  02e4		       06		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  02e5		       06		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  02e6		       06		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  02e7		       06		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  02e8		       06		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  02e9		       06		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  02ea		       06		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  02eb		       06		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  02ec		       0b		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  02ed		       0b		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  02ee		       0b		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  02ef		       0b		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  02f0		       0b		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  02f1		       0b		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  02f2		       0b		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  02f3		       0b		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  02f4		       0b		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  02f5		       0b		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  02f6		       0b		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  02f7		       0b		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  02f8		       0b		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  02f9		       0b		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  02fa		       0b		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  02fb		       0b		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  02fc		       07		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  02fd		       07		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  02fe		       07		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  02ff		       07		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  0300		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  0301		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  0302		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  0303		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  0304
    438  0304							; piece index equates...
    439  0304		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  0304		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  0304		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  0304		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  0304		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  0304		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  0304		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  0304		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  0304		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  0304		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  0304		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  0304		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  0304		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  0304		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  0304		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  0304		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  0304		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  0304		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  0304		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  0304		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  0304		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  0304		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  0304		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  0304		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  0304		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  0304		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  0304		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  0304		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  0304		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  0304		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  0304		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  0304		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  0304		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  0304		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  0304		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  0304		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  0304		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  0304		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  0304		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  0304		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  0304		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  0304		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  0304		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  0304		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  0304		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  0304		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  0304		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  0304		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  0304		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  0304		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  0304		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  0304		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  0304		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  0304		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  0304		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  0304		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  0304		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  0304		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  0304		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  0304		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  0304		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  0304		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  0304		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  0304		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  0304		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  0304		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  0304		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  0304		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  0304		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  0304		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  0304		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  0304		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  0304		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  0304		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  0304		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  0304		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  0304		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  0304		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  0304		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  0304		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  0304		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  0304		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  0304		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  0304		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  0304		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  0304		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  0304		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  0304		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  0304		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  0304		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  0304		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  0304		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  0304		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  0304		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  0304		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  0304		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  0304		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  0304		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  0304		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  0304		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  0304		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  0304		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  0304		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  0304		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  0304		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  0304		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  0304		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  0304		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  0304		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  0304		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  0304		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  0304		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  0304		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  0304		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  0304		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  0304		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  0304		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  0304		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  0304		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  0304		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  0304		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  0304		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  0304		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  0304		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  0304		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  0304		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  0304		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  0304		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  0304		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  0304		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  0304		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  0304		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  0304		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  0304		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  0304		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  0304		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  0304		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  0304		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  0304		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  0304		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  0304		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  0304		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  0304		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  0304		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC.asm
    438  0304
    439  0304							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
    440  0304							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
    441  0304							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
    442  0304							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
    443  0304							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
    444  0304							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
    445  0304							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
    446  0304							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
    447  0304
    448  0304							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
    449  0304							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
    450  0304							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
    451  0304							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
    452  0304							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
    453  0304							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
    454  0304							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
    455  0304							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
    456  0304
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  0304					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  0304					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  0304					      LIST	ON
      0  0304					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  0304				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  0304				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  0304				   TEMPORARY_VAR SET	Overlay
      4  0304				   TEMPORARY_OFFSET SET	0
      5  0304				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0304				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      7  0304					      SUBROUTINE
      3  0304		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  031c		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0334		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  034c					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  034c					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  034c					      LIST	ON
      0  034c					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  034c				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  034c				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  034c				   TEMPORARY_VAR SET	Overlay
      4  034c				   TEMPORARY_OFFSET SET	0
      5  034c				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  034c				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      7  034c					      SUBROUTINE
      3  034c		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0364		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  037c		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  0394					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  0394					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  0394					      LIST	ON
      0  0394					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  0394				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  0394				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  0394				   TEMPORARY_VAR SET	Overlay
      4  0394				   TEMPORARY_OFFSET SET	0
      5  0394				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0394				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      7  0394					      SUBROUTINE
      3  0394		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  03ac		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  03c4		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  03dc					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  03dc					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  0400					      LIST	ON
      0  0400					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  0400				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  0400				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  0400				   TEMPORARY_VAR SET	Overlay
      4  0400				   TEMPORARY_OFFSET SET	0
      5  0400				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0400				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      7  0400					      SUBROUTINE
      3  0400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0430		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  0448					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  0448					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  0448					      LIST	ON
      0  0448					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  0448				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  0448				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  0448				   TEMPORARY_VAR SET	Overlay
      4  0448				   TEMPORARY_OFFSET SET	0
      5  0448				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0448				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      7  0448					      SUBROUTINE
      3  0448		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  0460		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  0490					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  0490					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  0490					      LIST	ON
      0  0490					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  0490				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  0490				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  0490				   TEMPORARY_VAR SET	Overlay
      4  0490				   TEMPORARY_OFFSET SET	0
      5  0490				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0490				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      7  0490					      SUBROUTINE
      3  0490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  04a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  04c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  04d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  04d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  0500					      LIST	ON
      0  0500					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  0500				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  0500				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  0500				   TEMPORARY_VAR SET	Overlay
      4  0500				   TEMPORARY_OFFSET SET	0
      5  0500				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0500				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      7  0500					      SUBROUTINE
      3  0500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  0530		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  0548					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  0548					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  0548					      LIST	ON
      0  0548					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  0548				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  0548				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  0548				   TEMPORARY_VAR SET	Overlay
      4  0548				   TEMPORARY_OFFSET SET	0
      5  0548				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0548				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      7  0548					      SUBROUTINE
      3  0548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0578		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE BANK_GENERIC.asm
    465  0590
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  0590					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  0590					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  0590					      LIST	ON
      0  0590					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  0590				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  0590				   WHITE_MARKER_on_BLACK_SQUARE_0
      3  0590				   TEMPORARY_VAR SET	Overlay
      4  0590				   TEMPORARY_OFFSET SET	0
      5  0590				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0590				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      7  0590					      SUBROUTINE
      3  0590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$e0,$e0,$e0,$e0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  05a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  05c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  05d8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  05d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  0600					      LIST	ON
      0  0600					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  0600				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  0600				   WHITE_MARKER_on_BLACK_SQUARE_1
      3  0600				   TEMPORARY_VAR SET	Overlay
      4  0600				   TEMPORARY_OFFSET SET	0
      5  0600				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0600				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      7  0600					      SUBROUTINE
      3  0600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$38,$38,$38,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  0648					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  0648					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  0648					      LIST	ON
      0  0648					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  0648				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  0648				   WHITE_MARKER_on_BLACK_SQUARE_2
      3  0648				   TEMPORARY_VAR SET	Overlay
      4  0648				   TEMPORARY_OFFSET SET	0
      5  0648				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0648				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      7  0648					      SUBROUTINE
      3  0648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  0690					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  0690					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  0690					      LIST	ON
      0  0690					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  0690				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  0690				   WHITE_MARKER_on_BLACK_SQUARE_3
      3  0690				   TEMPORARY_VAR SET	Overlay
      4  0690				   TEMPORARY_OFFSET SET	0
      5  0690				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0690				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      7  0690					      SUBROUTINE
      3  0690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  06a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  06c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$70,$70,$70,$70,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  06d8					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  06d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  0700					      LIST	ON
      0  0700					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  0700				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  0700				   WHITE_MARKER_on_WHITE_SQUARE_0
      3  0700				   TEMPORARY_VAR SET	Overlay
      4  0700				   TEMPORARY_OFFSET SET	0
      5  0700				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0700				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      7  0700					      SUBROUTINE
      3  0700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$e0,$e0,$e0,$e0,$00,$00,$00,$e0,$e0,$e0,$e0,$e0,$00,$00	;PF0
      4  0718		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  0748					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  0748					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  0748					      LIST	ON
      0  0748					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  0748				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  0748				   WHITE_MARKER_on_WHITE_SQUARE_1
      3  0748				   TEMPORARY_VAR SET	Overlay
      4  0748				   TEMPORARY_OFFSET SET	0
      5  0748				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0748				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      7  0748					      SUBROUTINE
      3  0748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$38,$38,$38,$38,$00,$00,$00,$38,$38,$38,$38,$38,$00,$00	;PF1
      5  0778		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  0790					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  0790					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  0790					      LIST	ON
      0  0790					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  0790				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  0790				   WHITE_MARKER_on_WHITE_SQUARE_2
      3  0790				   TEMPORARY_VAR SET	Overlay
      4  0790				   TEMPORARY_OFFSET SET	0
      5  0790				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0790				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      7  0790					      SUBROUTINE
      3  0790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  07a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$00,$00,$00,$01,$01,$01,$01,$01,$00,$00	;PF1
      5  07c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$00,$00,$00,$03,$03,$03,$03,$03,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
    473  07d8
      0  07d8					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  07d8		       07 d8	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $7d8 , FREE= $28
      2  07d8					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  07d8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  07d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  07d8				  -	      ERR
      6  07d8					      ENDIF
      7  07d8
------- FILE ./chess.asm
------- FILE BANK_GENERIC2.asm LEVEL 2 PASS 5
      0  07d8					      include	"BANK_GENERIC2.asm"
      1  07d8
      0  07d8					      NEWBANK	GENERIC_BANK_2
      1  0800 ????				      SEG	GENERIC_BANK_2
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   GENERIC_BANK_2 SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	GENERIC_BANK_2
      3  0800
      4  0800				  -	      IF	ENPASSANT_ENABLED
      5  0800				  -
      6  0800				  -	      DEF	EnPassantCheck
      7  0800				  -	      SUBROUTINE
      8  0800				  -
      9  0800				  -	      REFER	MakeMove
     10  0800				  -	      REFER	aiSpecialMoveFixup
     11  0800				  -	      VEND	EnPassantCheck
     12  0800				  -
     13  0800				  -			; {
     14  0800				  -			; With en-passant flag, it is essentially dual-use.
     15  0800				  -			; First, it marks if the move is *involved* somehow in an en-passant
     16  0800				  -			; if the piece has MOVED already, then it's an en-passant capture
     17  0800				  -			; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
     18  0800				  -
     19  0800				  -	      ldy	enPassantPawn	; save from previous side move
     20  0800				  -
     21  0800				  -	      ldx	#0	; (probably) NO en-passant this time
     22  0800				  -	      lda	fromPiece
     23  0800				  -	      and	#FLAG_ENPASSANT|FLAG_MOVED
     24  0800				  -	      cmp	#FLAG_ENPASSANT
     25  0800				  -	      bne	.noep	; HAS moved, or not en-passant
     26  0800				  -
     27  0800				  -	      eor	fromPiece	; clear FLAG_ENPASSANT
     28  0800				  -	      sta	fromPiece
     29  0800				  -
     30  0800				  -	      ldx	fromX12	; this IS an en-passantable opening, so record the square
     31  0800				  -.noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
     32  0800				  -
     33  0800				  -			; }
     34  0800				  -
     35  0800				  -
     36  0800				  -			; Check to see if we are doing an actual en-passant capture...
     37  0800				  -
     38  0800				  -			; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
     39  0800				  -			;  as the en-passant will fail if the taking piece does not have this flag set correctly
     40  0800				  -
     41  0800				  -	      lda	fromPiece
     42  0800				  -	      and	#FLAG_ENPASSANT
     43  0800				  -	      beq	.notEnPassant	; not an en-passant, or it's enpassant by a MOVED piece
     44  0800				  -
     45  0800				  -
     46  0800				  -			; {
     47  0800				  -
     48  0800				  -			; Here we are the aggressor and we need to take the pawn 'en passant' fashion
     49  0800				  -			; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
     50  0800				  -
     51  0800				  -			; Remove the pawn from the board and piecelist, and undraw
     52  0800				  -
     53  0800				  -	      sty	squareToDraw
     54  0800				  -	      jsr	CopySinglePiece	; undraw captured pawn
     55  0800				  -
     56  0800				  -	      lda	#RAMBANK_BANK_EVAL
     57  0800				  -	      sta	SET_BANK_RAM
     58  0800				  -	      sta	savedBank
     59  0800				  -
     60  0800				  -	      ldy	originX12	; taken pawn's square
     61  0800				  -	      jsr	EnPassantRemovePiece
     62  0800				  -
     63  0800				  -.notEnPassant
     64  0800				  -			; }
     65  0800				  -
     66  0800				  -	      rts
     67  0800				  -
     68  0800					      ENDIF
     69  0800
     70  0800
      0  0800					      CHECK_BANK_SIZE	"GENERIC_BANK_2 -- full 2K"
      1  0800		       00 00	   .TEMP      =	* - BANK_START
 GENERIC_BANK_2 -- full 2K (2K) SIZE =  $0 , FREE= $800
      2  0800					      ECHO	"GENERIC_BANK_2 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0800				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  0800				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0800				  -	      ERR
      6  0800					      ENDIF
      7  0800
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 5
      0  0800					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  0800
      0  0800					      NEWBANK	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      1  1306 ????				      SEG	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   BANK_ROM_SHADOW_OF_CHESS_BITMAP SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      3  1000
      4  1000							; Template bank for a SINGLE ROW of the chessboard display.
      5  1000							; There are 8x of these.
      6  1000							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
      7  1000							; The bank is copied from ROM into RAM at startup.
      8  1000							; The draw switches between consecutive row banks, with the last returning
      9  1000							; we effectively have 1K
     10  1000							;---------------------------------------------------------------------------------------------------
     11  1000
     12  1000		       00 84	   COLOUR_LINE_1 =	$84
     13  1000		       00 4a	   COLOUR_LINE_2 =	$4A
     14  1000		       00 16	   COLOUR_LINE_3 =	$16
     15  1000		       00 00	   BACKGCOL   =	$00
     16  1000
     17  1000							;COLOUR_LINE_1 = $94
     18  1000							;COLOUR_LINE_2 = $48
     19  1000							;COLOUR_LINE_3 = $2C
     20  1000							;BACKGCOL	= $00
     21  1000
     22  1000							;
     23  1000
     24  1000							; good/contrast
     25  1000							;COLOUR_LINE_1 = $a6
     26  1000							;COLOUR_LINE_2 = $4a
     27  1000							;COLOUR_LINE_3 = $2A
     28  1000
     29  1000							;COLOUR_LINE_1 = $94 ; square col
     30  1000							;COLOUR_LINE_2 = $C6
     31  1000							;COLOUR_LINE_3 = $48
     32  1000							;BACKGCOL	= 0 ;$F0
     33  1000
     34  1000
     35  1000							; good 94/46/28/0
     36  1000							; good 94/44/26/0
     37  1000
     38  1000
     39  1000		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     40  1000
     41  1000
      0  1000					      ALLOCATE	ChessBitmap, ROW_BITMAP_SIZE
      0  1000					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  1000					      LIST	ON
      0  1000					      DEF	ChessBitmap
      1  1000				   BANK_ChessBitmap SET	_CURRENT_BANK
      2  1000				   ChessBitmap
      3  1000				   TEMPORARY_VAR SET	Overlay
      4  1000				   TEMPORARY_OFFSET SET	0
      5  1000				   VAR_BOUNDARY_ChessBitmap SET	TEMPORARY_OFFSET
      6  1000				   FUNCTION_NAME SET	ChessBitmap
      7  1000					      SUBROUTINE
     43  1000		       00 00 00 00*ChessBitmap0 ds	24
     44  1018		       00 00 00 00*ChessBitmap1 ds	24
     45  1030		       00 00 00 00*ChessBitmap2 ds	24
     46  1048		       00 00 00 00*ChessBitmap3 ds	24
     47  1060		       00 00 00 00*ChessBitmap4 ds	24
     48  1078		       00 00 00 00*ChessBitmap5 ds	24
     49  1090
      0  1090					      ALLOCATE	BlankSprite, 8
      0  1090					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1090					      LIST	ON
      0  1090					      DEF	BlankSprite
      1  1090				   BANK_BlankSprite SET	_CURRENT_BANK
      2  1090				   BlankSprite
      3  1090				   TEMPORARY_VAR SET	Overlay
      4  1090				   TEMPORARY_OFFSET SET	0
      5  1090				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      6  1090				   FUNCTION_NAME SET	BlankSprite
      7  1090					      SUBROUTINE
     51  1090		       00 00 00 00*	      ds	8, 0
     52  1098
      0  1098					      ALLOCATE	SpriteBuffer, 24
      0  1098					      OPTIONAL_PAGEBREAK	"Table", 24
     12  1098					      LIST	ON
      0  1098					      DEF	SpriteBuffer
      1  1098				   BANK_SpriteBuffer SET	_CURRENT_BANK
      2  1098				   SpriteBuffer
      3  1098				   TEMPORARY_VAR SET	Overlay
      4  1098				   TEMPORARY_OFFSET SET	0
      5  1098				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      6  1098				   FUNCTION_NAME SET	SpriteBuffer
      7  1098					      SUBROUTINE
     54  1098				   SpriteBuffer2
     55  1098					      REPEAT	24
     56  1098		       f8		      .byte.b	%11111000
     55  1098					      REPEND
     56  1099		       f8		      .byte.b	%11111000
     55  1099					      REPEND
     56  109a		       f8		      .byte.b	%11111000
     55  109a					      REPEND
     56  109b		       f8		      .byte.b	%11111000
     55  109b					      REPEND
     56  109c		       f8		      .byte.b	%11111000
     55  109c					      REPEND
     56  109d		       f8		      .byte.b	%11111000
     55  109d					      REPEND
     56  109e		       f8		      .byte.b	%11111000
     55  109e					      REPEND
     56  109f		       f8		      .byte.b	%11111000
     55  109f					      REPEND
     56  10a0		       f8		      .byte.b	%11111000
     55  10a0					      REPEND
     56  10a1		       f8		      .byte.b	%11111000
     55  10a1					      REPEND
     56  10a2		       f8		      .byte.b	%11111000
     55  10a2					      REPEND
     56  10a3		       f8		      .byte.b	%11111000
     55  10a3					      REPEND
     56  10a4		       f8		      .byte.b	%11111000
     55  10a4					      REPEND
     56  10a5		       f8		      .byte.b	%11111000
     55  10a5					      REPEND
     56  10a6		       f8		      .byte.b	%11111000
     55  10a6					      REPEND
     56  10a7		       f8		      .byte.b	%11111000
     55  10a7					      REPEND
     56  10a8		       f8		      .byte.b	%11111000
     55  10a8					      REPEND
     56  10a9		       f8		      .byte.b	%11111000
     55  10a9					      REPEND
     56  10aa		       f8		      .byte.b	%11111000
     55  10aa					      REPEND
     56  10ab		       f8		      .byte.b	%11111000
     55  10ab					      REPEND
     56  10ac		       f8		      .byte.b	%11111000
     55  10ac					      REPEND
     56  10ad		       f8		      .byte.b	%11111000
     55  10ad					      REPEND
     56  10ae		       f8		      .byte.b	%11111000
     55  10ae					      REPEND
     56  10af		       f8		      .byte.b	%11111000
     57  10b0					      REPEND
     58  10b0
      0  10b0					      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
      0  10b0					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  1100					      LIST	ON
      0  1100					      DEF	BackupBitmap
      1  1100				   BANK_BackupBitmap SET	_CURRENT_BANK
      2  1100				   BackupBitmap
      3  1100				   TEMPORARY_VAR SET	Overlay
      4  1100				   TEMPORARY_OFFSET SET	0
      5  1100				   VAR_BOUNDARY_BackupBitmap SET	TEMPORARY_OFFSET
      6  1100				   FUNCTION_NAME SET	BackupBitmap
      7  1100					      SUBROUTINE
     60  1100		       00 00 00 00*	      ds	ROW_BITMAP_SIZE, 0
     61  1190
     62  1190							;---------------------------------------------------------------------------------------------------
     63  1190
      0  1190					      DEF	ClearRowBitmap
      1  1190				   BANK_ClearRowBitmap SET	_CURRENT_BANK
      2  1190				   ClearRowBitmap
      3  1190				   TEMPORARY_VAR SET	Overlay
      4  1190				   TEMPORARY_OFFSET SET	0
      5  1190				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      6  1190				   FUNCTION_NAME SET	ClearRowBitmap
      7  1190					      SUBROUTINE
     65  1190					      SUBROUTINE
     66  1190
      0  1190					      REFER	CallClear
      1  1190				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  1190				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  1190					      ENDIF
      0  1190					      VEND	ClearRowBitmap
      1  1190				  -	      IFNCONST	ClearRowBitmap
      2  1190				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  1190				  -	      ERR
      4  1190					      ENDIF
      5  1190		       00 a7	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     69  1190
     70  1190							; No transient variable dependencies/calls
     71  1190
     72  1190		       a9 00		      lda	#0
     73  1192		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  1194				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  1194		       99 ff f3 	      sta	[RAM]+ChessBitmap-1,y
     75  1197		       88		      dey
     76  1198		       d0 fa		      bne	.clearRow
     77  119a		       60		      rts
     78  119b
     79  119b
     80  119b							;---------------------------------------------------------------------------------------------------
     81  119b
      0  119b					      DEF	CopyPieceToRowBitmap
      1  119b				   BANK_CopyPieceToRowBitmap SET	_CURRENT_BANK
      2  119b				   CopyPieceToRowBitmap
      3  119b				   TEMPORARY_VAR SET	Overlay
      4  119b				   TEMPORARY_OFFSET SET	0
      5  119b				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      6  119b				   FUNCTION_NAME SET	CopyPieceToRowBitmap
      7  119b					      SUBROUTINE
     83  119b					      SUBROUTINE
     84  119b
      0  119b					      REFER	CopySinglePiece	; special-case due to 'intercept'
      1  119b					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  119b				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  119b					      ENDIF
      0  119b					      VEND	CopyPieceToRowBitmap
      1  119b				  -	      IFNCONST	CopyPieceToRowBitmap
      2  119b				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  119b				  -	      ERR
      4  119b					      ENDIF
      5  119b		       00 b3	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
     87  119b
     88  119b		       a0 11		      ldy	#17
     89  119d		       b0 30		      bcs	.rightSide
     90  119f
     91  119f		       b9 a7 00    .copyPiece lda	__pieceShapeBuffer,y
     92  11a2		       f0 06		      beq	.blank1
     93  11a4		       59 00 f0 	      eor	ChessBitmap,y
      0  11a7					      sta@RAM	ChessBitmap,y
      1  11a7		       99 00 f4 	      sta	[RAM]+ChessBitmap,y
     95  11aa
     96  11aa		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
     97  11ad		       f0 06		      beq	.blank2
     98  11af		       59 12 f0 	      eor	ChessBitmap+18,y
      0  11b2					      sta@RAM	ChessBitmap+18,y
      1  11b2		       99 12 f4 	      sta	[RAM]+ChessBitmap+18,y
    100  11b5
    101  11b5		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    102  11b8		       f0 06		      beq	.blank3
    103  11ba		       59 24 f0 	      eor	ChessBitmap+36,y
      0  11bd					      sta@RAM	ChessBitmap+36,y
      1  11bd		       99 24 f4 	      sta	[RAM]+ChessBitmap+36,y
    105  11c0
    106  11c0		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    107  11c3		       f0 06		      beq	.blank4
    108  11c5		       59 36 f0 	      eor	ChessBitmap+54,y
      0  11c8					      sta@RAM	ChessBitmap+54,y
      1  11c8		       99 36 f4 	      sta	[RAM]+ChessBitmap+54,y
    110  11cb
    111  11cb		       88	   .blank4    dey
    112  11cc		       10 d1		      bpl	.copyPiece
    113  11ce		       60		      rts
    114  11cf
    115  11cf				   .rightSide
    116  11cf
    117  11cf					      SUBROUTINE
    118  11cf
    119  11cf		       b9 a7 00    .copyPieceR lda	__pieceShapeBuffer,y
    120  11d2		       f0 06		      beq	.blank1
    121  11d4		       59 48 f0 	      eor	ChessBitmap+72,y
      0  11d7					      sta@RAM	ChessBitmap+72,y
      1  11d7		       99 48 f4 	      sta	[RAM]+ChessBitmap+72,y
    123  11da
    124  11da		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    125  11dd		       f0 06		      beq	.blank2
    126  11df		       59 5a f0 	      eor	ChessBitmap+72+18,y
      0  11e2					      sta@RAM	ChessBitmap+72+18,y
      1  11e2		       99 5a f4 	      sta	[RAM]+ChessBitmap+72+18,y
    128  11e5
    129  11e5		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    130  11e8		       f0 06		      beq	.blank3
    131  11ea		       59 6c f0 	      eor	ChessBitmap+72+36,y
      0  11ed					      sta@RAM	ChessBitmap+72+36,y
      1  11ed		       99 6c f4 	      sta	[RAM]+ChessBitmap+72+36,y
    133  11f0
    134  11f0		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    135  11f3		       f0 06		      beq	.blank4
    136  11f5		       59 7e f0 	      eor	ChessBitmap+72+54,y
      0  11f8					      sta@RAM	ChessBitmap+72+54,y
      1  11f8		       99 7e f4 	      sta	[RAM]+ChessBitmap+72+54,y
    138  11fb
    139  11fb		       88	   .blank4    dey
    140  11fc		       10 d1		      bpl	.copyPieceR
    141  11fe		       60		      rts
    142  11ff
    143  11ff
    144  11ff							;---------------------------------------------------------------------------------------------------
    145  11ff
    146  1200		       00		      ALIGN	256
    147  1200					      SUBROUTINE
    148  1200
      0  1200					      REFER	Reset
      1  1200				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  1200				  -TEMPORARY_VAR SET	VAREND_Reset
      3  1200					      ENDIF
    150  1200				   __dummy
      0  1200					      VEND	__dummy
      1  1200				  -	      IFNCONST	__dummy
      2  1200				  -	      ECHO	"Incorrect VEND label", __dummy
      3  1200				  -	      ERR
      4  1200					      ENDIF
      5  1200		       00 b3	   VAREND___dummy =	TEMPORARY_VAR
    152  1200
    153  1200							; x = row # (and bank#)
    154  1200
    155  1200				   .endline
    156  1200
    157  1200							;@59
    158  1200
    159  1200							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
    160  1200							; Note that the other 7 row banks are unmodified (keeping the 'inx')
    161  1200				   SELFMOD_RTS_ON_LAST_ROW
    162  1200
    163  1200		       e8		      inx		; 2
    164  1201		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
    165  1203
      0  1203					      DEF	DrawRow
      1  1203				   BANK_DrawRow SET	_CURRENT_BANK
      2  1203				   DrawRow
      3  1203				   TEMPORARY_VAR SET	Overlay
      4  1203				   TEMPORARY_OFFSET SET	0
      5  1203				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      6  1203				   FUNCTION_NAME SET	DrawRow
      7  1203					      SUBROUTINE
    167  1203
    168  1203							;@64
    169  1203		       a0 07		      ldy	#7	; 2
    170  1205		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
    171  1207
    172  1207							;@58...
    173  1207
    174  1207				   .l3
    175  1207
    176  1207		       b9 a8 f0    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
    177  120a		       85 5b		      sta	GRP0	; 3
    178  120c		       b9 a8 f0    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
    179  120f		       85 5c		      sta	GRP1	; 3
    180  1211
    181  1211							;@-4
    182  1211
    183  1211		       a9 84		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    184  1213		       85 48		      sta	COLUPF	; 3 @1
    185  1215
    186  1215		       b9 10 f0 	      lda	ChessBitmap0+16,y	; 4
    187  1218		       85 4d		      sta	PF0	; 3
    188  121a		       b9 28 f0 	      lda	ChessBitmap1+16,y	; 4
    189  121d		       85 4e		      sta	PF1	; 3
    190  121f		       b9 40 f0 	      lda	ChessBitmap2+16,y	; 4
    191  1222		       85 4f		      sta	PF2	; 3 @22
    192  1224
      0  1224					      SLEEP	6	; 6 @28
      1  1224				   .CYCLES    SET	6
      2  1224
      3  1224				  -	      IF	.CYCLES < 2
      4  1224				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1224				  -	      ERR
      6  1224					      ENDIF
      7  1224
      8  1224				  -	      IF	.CYCLES & 1
      9  1224				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1224				  -	      nop	0
     11  1224				  -	      ELSE
     12  1224				  -	      bit	VSYNC
     13  1224				  -	      ENDIF
     14  1224				  -.CYCLES    SET	.CYCLES - 3
     15  1224					      ENDIF
     16  1224
     17  1224					      REPEAT	.CYCLES / 2
     18  1224		       ea		      nop
     17  1224					      REPEND
     18  1225		       ea		      nop
     17  1225					      REPEND
     18  1226		       ea		      nop
     19  1227					      REPEND
    194  1227
    195  1227		       b9 58 f0 	      lda	ChessBitmap3+16,y	; 4
    196  122a		       85 4d		      sta	PF0	; 3
    197  122c		       b9 70 f0 	      lda	ChessBitmap4+16,y	; 4
    198  122f		       85 4e		      sta	PF1	; 3
    199  1231		       b9 88 f0 	      lda	ChessBitmap5+16,y	; 4
    200  1234		       8d 4f 00 	      sta.w	PF2	; 4 @50
    201  1237
      0  1237					      SLEEP	4	; 4
      1  1237				   .CYCLES    SET	4
      2  1237
      3  1237				  -	      IF	.CYCLES < 2
      4  1237				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1237				  -	      ERR
      6  1237					      ENDIF
      7  1237
      8  1237				  -	      IF	.CYCLES & 1
      9  1237				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1237				  -	      nop	0
     11  1237				  -	      ELSE
     12  1237				  -	      bit	VSYNC
     13  1237				  -	      ENDIF
     14  1237				  -.CYCLES    SET	.CYCLES - 3
     15  1237					      ENDIF
     16  1237
     17  1237					      REPEAT	.CYCLES / 2
     18  1237		       ea		      nop
     17  1237					      REPEND
     18  1238		       ea		      nop
     19  1239					      REPEND
    203  1239
    204  1239		       88		      dey		; 2
    205  123a		       30 c4		      bmi	.endline	; 2 (3)
    206  123c
    207  123c							;@57
    208  123c				   .drawLine
    209  123c
      0  123c					      SLEEP	11
      1  123c				   .CYCLES    SET	11
      2  123c
      3  123c				  -	      IF	.CYCLES < 2
      4  123c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  123c				  -	      ERR
      6  123c					      ENDIF
      7  123c
      8  123c					      IF	.CYCLES & 1
      9  123c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  123c		       04 00		      nop	0
     11  123e				  -	      ELSE
     12  123e				  -	      bit	VSYNC
     13  123e					      ENDIF
     14  123e				   .CYCLES    SET	.CYCLES - 3
     15  123e					      ENDIF
     16  123e
     17  123e					      REPEAT	.CYCLES / 2
     18  123e		       ea		      nop
     17  123e					      REPEND
     18  123f		       ea		      nop
     17  123f					      REPEND
     18  1240		       ea		      nop
     17  1240					      REPEND
     18  1241		       ea		      nop
     19  1242					      REPEND
    211  1242
    212  1242				   .dl2
    213  1242		       b9 98 f0    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    214  1245		       85 5b		      sta	GRP0	; 3
    215  1247		       b9 98 f0    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    216  124a		       85 5c		      sta	GRP1	; 3
    217  124c
    218  124c							;@7
    219  124c
    220  124c		       a9 4a		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    221  124e		       85 48		      sta	COLUPF	; 3 @12
    222  1250
    223  1250		       b9 00 f0 	      lda	ChessBitmap0,y	; 4
    224  1253		       85 4d		      sta	PF0	; 3
    225  1255		       b9 18 f0 	      lda	ChessBitmap1,y	; 4
    226  1258		       85 4e		      sta	PF1	; 3
    227  125a		       b9 30 f0 	      lda	ChessBitmap2,y	; 4
    228  125d		       85 4f		      sta	PF2	; 3 @33
    229  125f
      0  125f					      SLEEP	3	; 3 @36
      1  125f				   .CYCLES    SET	3
      2  125f
      3  125f				  -	      IF	.CYCLES < 2
      4  125f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  125f				  -	      ERR
      6  125f					      ENDIF
      7  125f
      8  125f					      IF	.CYCLES & 1
      9  125f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  125f		       04 00		      nop	0
     11  1261				  -	      ELSE
     12  1261				  -	      bit	VSYNC
     13  1261					      ENDIF
     14  1261				   .CYCLES    SET	.CYCLES - 3
     15  1261					      ENDIF
     16  1261
     17  1261				  -	      REPEAT	.CYCLES / 2
     18  1261				  -	      nop
     19  1261					      REPEND
    231  1261
    232  1261		       b9 48 f0 	      lda	ChessBitmap3,y	; 4
    233  1264		       85 4d		      sta	PF0	; 3
    234  1266		       b9 60 f0 	      lda	ChessBitmap4,y	; 4
    235  1269		       85 4e		      sta	PF1	; 3
    236  126b		       b9 78 f0 	      lda	ChessBitmap5,y	; 4
    237  126e		       85 4f		      sta	PF2	; 3 @57
    238  1270
      0  1270					      SLEEP	5
      1  1270				   .CYCLES    SET	5
      2  1270
      3  1270				  -	      IF	.CYCLES < 2
      4  1270				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1270				  -	      ERR
      6  1270					      ENDIF
      7  1270
      8  1270					      IF	.CYCLES & 1
      9  1270					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1270		       04 00		      nop	0
     11  1272				  -	      ELSE
     12  1272				  -	      bit	VSYNC
     13  1272					      ENDIF
     14  1272				   .CYCLES    SET	.CYCLES - 3
     15  1272					      ENDIF
     16  1272
     17  1272					      REPEAT	.CYCLES / 2
     18  1272		       ea		      nop
     19  1273					      REPEND
    240  1273
    241  1273		       b9 a0 f0    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    242  1276		       85 5b		      sta	GRP0	; 3
    243  1278		       b9 a0 f0    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    244  127b		       85 5c		      sta	GRP1	; 3
    245  127d
    246  127d							;@0
    247  127d		       a9 16		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    248  127f		       85 48		      sta	COLUPF	; 3 @5
    249  1281
    250  1281		       b9 08 f0 	      lda	ChessBitmap0+8,y	; 4
    251  1284		       85 4d		      sta	PF0	; 3
    252  1286		       b9 20 f0 	      lda	ChessBitmap1+8,y	; 4
    253  1289		       85 4e		      sta	PF1	; 3
    254  128b		       b9 38 f0 	      lda	ChessBitmap2+8,y	; 4
    255  128e		       85 4f		      sta	PF2	; 3 @26
    256  1290
      0  1290					      SLEEP	8	; 6 @34
      1  1290				   .CYCLES    SET	8
      2  1290
      3  1290				  -	      IF	.CYCLES < 2
      4  1290				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1290				  -	      ERR
      6  1290					      ENDIF
      7  1290
      8  1290				  -	      IF	.CYCLES & 1
      9  1290				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1290				  -	      nop	0
     11  1290				  -	      ELSE
     12  1290				  -	      bit	VSYNC
     13  1290				  -	      ENDIF
     14  1290				  -.CYCLES    SET	.CYCLES - 3
     15  1290					      ENDIF
     16  1290
     17  1290					      REPEAT	.CYCLES / 2
     18  1290		       ea		      nop
     17  1290					      REPEND
     18  1291		       ea		      nop
     17  1291					      REPEND
     18  1292		       ea		      nop
     17  1292					      REPEND
     18  1293		       ea		      nop
     19  1294					      REPEND
    258  1294
    259  1294		       b9 50 f0 	      lda	ChessBitmap3+8,y	; 4
    260  1297		       85 4d		      sta	PF0	; 3
    261  1299		       b9 68 f0 	      lda	ChessBitmap4+8,y	; 4
    262  129c		       85 4e		      sta	PF1	; 3
    263  129e		       b9 80 f0 	      lda	ChessBitmap5+8,y	; 4
    264  12a1		       85 4f		      sta	PF2	; 3 @55
    265  12a3
    266  12a3		       4c 07 f2 	      jmp	.l3	; 3 @58
    267  12a6
    268  12a6
    269  12a6							;---------------------------------------------------------------------------------------------------
    270  12a6
      0  12a6					      DEF	WriteBlank
      1  12a6				   BANK_WriteBlank SET	_CURRENT_BANK
      2  12a6				   WriteBlank
      3  12a6				   TEMPORARY_VAR SET	Overlay
      4  12a6				   TEMPORARY_OFFSET SET	0
      5  12a6				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      6  12a6				   FUNCTION_NAME SET	WriteBlank
      7  12a6					      SUBROUTINE
    272  12a6					      SUBROUTINE
    273  12a6
      0  12a6					      REFER	Reset
      1  12a6				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  12a6				  -TEMPORARY_VAR SET	VAREND_Reset
      3  12a6					      ENDIF
      0  12a6					      VEND	WriteBlank
      1  12a6				  -	      IFNCONST	WriteBlank
      2  12a6				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  12a6				  -	      ERR
      4  12a6					      ENDIF
      5  12a6		       00 a7	   VAREND_WriteBlank =	TEMPORARY_VAR
    276  12a6
    277  12a6		       a9 90		      lda	#<BlankSprite
      0  12a8					      sta@RAM	SMSPRITE0_0+1
      1  12a8		       8d 43 f6 	      sta	[RAM]+SMSPRITE0_0+1
      0  12ab					      sta@RAM	SMSPRITE8_0+1
      1  12ab		       8d 74 f6 	      sta	[RAM]+SMSPRITE8_0+1
      0  12ae					      sta@RAM	SMSPRITE16_0+1
      1  12ae		       8d 08 f6 	      sta	[RAM]+SMSPRITE16_0+1
      0  12b1					      sta@RAM	SMSPRITE0_1+1
      1  12b1		       8d 48 f6 	      sta	[RAM]+SMSPRITE0_1+1
      0  12b4					      sta@RAM	SMSPRITE8_1+1
      1  12b4		       8d 79 f6 	      sta	[RAM]+SMSPRITE8_1+1
      0  12b7					      sta@RAM	SMSPRITE16_1+1
      1  12b7		       8d 0d f6 	      sta	[RAM]+SMSPRITE16_1+1
    284  12ba
    285  12ba		       a9 f0		      lda	#>BlankSprite
      0  12bc					      sta@RAM	SMSPRITE0_0+2
      1  12bc		       8d 44 f6 	      sta	[RAM]+SMSPRITE0_0+2
      0  12bf					      sta@RAM	SMSPRITE8_0+2
      1  12bf		       8d 75 f6 	      sta	[RAM]+SMSPRITE8_0+2
      0  12c2					      sta@RAM	SMSPRITE16_0+2
      1  12c2		       8d 09 f6 	      sta	[RAM]+SMSPRITE16_0+2
      0  12c5					      sta@RAM	SMSPRITE0_1+2
      1  12c5		       8d 49 f6 	      sta	[RAM]+SMSPRITE0_1+2
      0  12c8					      sta@RAM	SMSPRITE8_1+2
      1  12c8		       8d 7a f6 	      sta	[RAM]+SMSPRITE8_1+2
      0  12cb					      sta@RAM	SMSPRITE16_1+2
      1  12cb		       8d 0e f6 	      sta	[RAM]+SMSPRITE16_1+2
    292  12ce
    293  12ce		       60		      rts
    294  12cf
    295  12cf
    296  12cf							;---------------------------------------------------------------------------------------------------
    297  12cf
      0  12cf					      DEF	WriteCursor
      1  12cf				   BANK_WriteCursor SET	_CURRENT_BANK
      2  12cf				   WriteCursor
      3  12cf				   TEMPORARY_VAR SET	Overlay
      4  12cf				   TEMPORARY_OFFSET SET	0
      5  12cf				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      6  12cf				   FUNCTION_NAME SET	WriteCursor
      7  12cf					      SUBROUTINE
    299  12cf					      SUBROUTINE
    300  12cf
      0  12cf					      REFER	Reset
      1  12cf				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  12cf				  -TEMPORARY_VAR SET	VAREND_Reset
      3  12cf					      ENDIF
      0  12cf					      VEND	WriteCursor
      1  12cf				  -	      IFNCONST	WriteCursor
      2  12cf				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  12cf				  -	      ERR
      4  12cf					      ENDIF
      5  12cf		       00 a7	   VAREND_WriteCursor =	TEMPORARY_VAR
    303  12cf
    304  12cf		       38		      sec
    305  12d0		       a5 88		      lda	cursorX12
    306  12d2		       30 1f		      bmi	.exit
    307  12d4		       a2 0a		      ldx	#10
    308  12d6		       e9 0a	   .sub10     sbc	#10
    309  12d8		       ca		      dex
    310  12d9		       b0 fb		      bcs	.sub10
    311  12db
    312  12db		       86 3e		      stx	SET_BANK_RAM
    313  12dd		       a9 98		      lda	#<SpriteBuffer
      0  12df					      sta@RAM	SMSPRITE0_0+1
      1  12df		       8d 43 f6 	      sta	[RAM]+SMSPRITE0_0+1
      0  12e2					      sta@RAM	SMSPRITE8_0+1
      1  12e2		       8d 74 f6 	      sta	[RAM]+SMSPRITE8_0+1
      0  12e5					      sta@RAM	SMSPRITE16_0+1
      1  12e5		       8d 08 f6 	      sta	[RAM]+SMSPRITE16_0+1
    317  12e8		       a9 f0		      lda	#>SpriteBuffer
      0  12ea					      sta@RAM	SMSPRITE0_0+2
      1  12ea		       8d 44 f6 	      sta	[RAM]+SMSPRITE0_0+2
      0  12ed					      sta@RAM	SMSPRITE8_0+2
      1  12ed		       8d 75 f6 	      sta	[RAM]+SMSPRITE8_0+2
      0  12f0					      sta@RAM	SMSPRITE16_0+2
      1  12f0		       8d 09 f6 	      sta	[RAM]+SMSPRITE16_0+2
    321  12f3
    322  12f3		       60	   .exit      rts
    323  12f4
    324  12f4
    325  12f4							;---------------------------------------------------------------------------------------------------
    326  12f4
      0  12f4					      DEF	SaveBitmap
      1  12f4				   BANK_SaveBitmap SET	_CURRENT_BANK
      2  12f4				   SaveBitmap
      3  12f4				   TEMPORARY_VAR SET	Overlay
      4  12f4				   TEMPORARY_OFFSET SET	0
      5  12f4				   VAR_BOUNDARY_SaveBitmap SET	TEMPORARY_OFFSET
      6  12f4				   FUNCTION_NAME SET	SaveBitmap
      7  12f4					      SUBROUTINE
    328  12f4					      SUBROUTINE
    329  12f4
      0  12f4					      REFER	SAFE_BackupBitmaps
      1  12f4				  -	      IF	VAREND_SAFE_BackupBitmaps > TEMPORARY_VAR
      2  12f4				  -TEMPORARY_VAR SET	VAREND_SAFE_BackupBitmaps
      3  12f4					      ENDIF
      0  12f4					      VEND	SaveBitmap
      1  12f4				  -	      IFNCONST	SaveBitmap
      2  12f4				  -	      ECHO	"Incorrect VEND label", SaveBitmap
      3  12f4				  -	      ERR
      4  12f4					      ENDIF
      5  12f4		       00 a7	   VAREND_SaveBitmap =	TEMPORARY_VAR
    332  12f4
    333  12f4		       a0 47		      ldy	#71
    334  12f6		       b9 00 f0    .fromTo    lda	ChessBitmap,y
      0  12f9					      sta@RAM	BackupBitmap,y
      1  12f9		       99 00 f5 	      sta	[RAM]+BackupBitmap,y
    336  12fc		       b9 48 f0 	      lda	ChessBitmap+72,y
      0  12ff					      sta@RAM	BackupBitmap+72,y
      1  12ff		       99 48 f5 	      sta	[RAM]+BackupBitmap+72,y
    338  1302		       88		      dey
    339  1303		       10 f1		      bpl	.fromTo
    340  1305		       60		      rts
    341  1306
    342  1306
    343  1306							;---------------------------------------------------------------------------------------------------
    344  1306
    345  1306				  -	      IF	0
    346  1306				  -
    347  1306				  -	      DEF	RestoreBitmap
    348  1306				  -	      SUBROUTINE
    349  1306				  -
    350  1306				  -	      VEND	RestoreBitmap
    351  1306				  -
    352  1306				  -	      ldy	#71
    353  1306				  -.fromTo    lda	BackupBitmap,y
    354  1306				  -	      sta@RAM	ChessBitmap,y
    355  1306				  -	      lda	BackupBitmap+72,y
    356  1306				  -	      sta@RAM	ChessBitmap+72,y
    357  1306				  -	      dey
    358  1306				  -	      bpl	.fromTo
    359  1306				  -	      rts
    360  1306					      ENDIF
    361  1306
    362  1306							;---------------------------------------------------------------------------------------------------
    363  1306
    364  1306				  -	      IF	0
    365  1306				  -
    366  1306				  -	      DEF	CopyTextToRowBitmap
    367  1306				  -	      SUBROUTINE
    368  1306				  -
    369  1306				  -	      VEND	CopyTextToRowBitmap
    370  1306				  -
    371  1306				  -			; An OR-draw, used for placing matricies/text onscreen
    372  1306				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    373  1306				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    374  1306				  -			; in original state once text disappears
    375  1306				  -
    376  1306				  -	      ldy	#71
    377  1306				  -	      bcs	.rightSide
    378  1306				  -
    379  1306				  -.copy      lda	__pieceShapeBuffer,y
    380  1306				  -	      ora	ChessBitmap,y
    381  1306				  -	      sta@RAM	ChessBitmap,y
    382  1306				  -	      dey
    383  1306				  -	      bpl	.copy
    384  1306				  -
    385  1306				  -	      rts
    386  1306				  -
    387  1306				  -.rightSide
    388  1306				  -
    389  1306				  -	      SUBROUTINE
    390  1306				  -
    391  1306				  -.copy      lda	__pieceShapeBuffer,y
    392  1306				  -	      ora	ChessBitmap+72,y
    393  1306				  -	      sta@RAM	ChessBitmap+72,y
    394  1306				  -	      dey
    395  1306				  -	      bpl	.copy
    396  1306				  -
    397  1306				  -	      rts
    398  1306				  -
    399  1306					      ENDIF
    400  1306
    401  1306							;---------------------------------------------------------------------------------------------------
    402  1306
      0  1306					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  1306
      2  1306
      3  1306		       03 06	   .TEMP      =	* - BANK_START
 ROM_SHADOW_SCREEN (1K) SIZE =  $306 , FREE= $fa
      4  1306					      ECHO	"ROM_SHADOW_SCREEN", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1306				  -	      IF	( .TEMP ) > ROM_BANK_SIZE/2
      6  1306				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1306				  -	      ERR
      8  1306					      ENDIF
    404  1306							;VALIDATE_RAM_SIZE
------- FILE ./chess.asm
------- FILE BANK_CHESS_INCLUDES.asm LEVEL 2 PASS 5
      0  1306					      include	"BANK_CHESS_INCLUDES.asm"
      1  1306							; Copyright (c) 2019-2020 Andrew Davie
      2  1306							; andrew@taswegian.com
      3  1306
      4  1306
      5  1306							; Each piece is defined as 3 PF bytes (horizontal) x 24 scanlines (vertical)
      6  1306							; The pieces are converted by ConvertChessPieces.py (in tools), which takes
      7  1306							; a single gif of the format..
      8  1306							; a row of white pieces on black squares
      9  1306							; a row of white pieces on white squares
     10  1306							; a row of black pieces on black squares
     11  1306							; a row of black pieces on white squares
     12  1306
     13  1306							; each row has the pieces ordered thus:
     14  1306							; a blank, then pawn, knight, bishop, rook, queen, king
     15  1306							; each piece is 5 pixels wide x 8 pixels deep
     16  1306							; each pixel is from an 8-colour palette.
     17  1306							; Given a pixel colour 0-7 (represented in binary 000 - 111) then if the bits
     18  1306							; for the colour are abc (i.e., colour #3 = binary 011 = bits 0bc)
     19  1306							; then bit "a" becomes the first interleaved chronocolour pixel (line 1)
     20  1306							; bit "b" becomes the second ICC pixel line (2)
     21  1306							; bit "c" becomes the third ICC pixel line (3)
     22  1306							; Thus, a 5 pxel x 8 pixel shape becomes 24 lines deep
     23  1306							; The tool produces 4 variants of the piece; shifted into the 4 squares
     24  1306							; in the PF - thus, at pixel 0, pixel 5, pixel 10, pixel 15.
     25  1306							; These 4 shifted positions are stored consecutively in the shape definition
     26  1306
     27  1306							; Example...
     28  1306							;DEF WHITE_BISHOP_on_BLACK_SQUARE_0
     29  1306							;.byte $00,$40,$40,$40,$00,$00,$e0,$e0,$e0,$d0,$d0,$d0,$b0,$b0,$b0,$f0,$f0,$f0,$e0,$60,$e0,$f0,$f0,$f0 ;PF0
     30  1306							;.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$80,$80,$00,$80,$80,$00,$80,$00,$00,$00,$00,$80,$00 ;PF1
     31  1306							;.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00 ;PF2
     32  1306
     33  1306							; The above defines the three 24-byte vertical strips for the 3 PF bytes that
     34  1306							; the piece (could) overlay. In this case, on square 0 (leftmost), it doesn't
     35  1306							; actually have any data in PF1 or PF2.
     36  1306
------- FILE piece_graphics.asm LEVEL 3 PASS 5
      0  1306					      include	"piece_graphics.asm"
      1  1306							; Import the graphics definitions generated by ConvertChessPieces.py
      0  1306					      NEWBANK	PIECES_0
      1  1fd8 ????				      SEG	PIECES_0
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   PIECES_0   SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	PIECES_0
      3  1800
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1800					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  1800					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  1800					      LIST	ON
      0  1800					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  1800				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1800				   WHITE_BLANK_on_WHITE_SQUARE_0
      3  1800				   TEMPORARY_VAR SET	Overlay
      4  1800				   TEMPORARY_OFFSET SET	0
      5  1800				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1800				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      7  1800					      SUBROUTINE
      3  1800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  1818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  1830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1848					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  1848					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  1848					      LIST	ON
      0  1848					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  1848				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1848				   WHITE_BLANK_on_WHITE_SQUARE_1
      3  1848				   TEMPORARY_VAR SET	Overlay
      4  1848				   TEMPORARY_OFFSET SET	0
      5  1848				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1848				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      7  1848					      SUBROUTINE
      3  1848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  1878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1890					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  1890					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  1890					      LIST	ON
      0  1890					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  1890				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1890				   WHITE_BLANK_on_WHITE_SQUARE_2
      3  1890				   TEMPORARY_VAR SET	Overlay
      4  1890				   TEMPORARY_OFFSET SET	0
      5  1890				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1890				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      7  1890					      SUBROUTINE
      3  1890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  18a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  18c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  18d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  18d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  1900					      LIST	ON
      0  1900					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  1900				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1900				   WHITE_BLANK_on_WHITE_SQUARE_3
      3  1900				   TEMPORARY_VAR SET	Overlay
      4  1900				   TEMPORARY_OFFSET SET	0
      5  1900				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1900				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      7  1900					      SUBROUTINE
      3  1900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1948					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  1948					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  1948					      LIST	ON
      0  1948					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  1948				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1948				   WHITE_PAWN_on_WHITE_SQUARE_0
      3  1948				   TEMPORARY_VAR SET	Overlay
      4  1948				   TEMPORARY_OFFSET SET	0
      5  1948				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1948				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      7  1948					      SUBROUTINE
      3  1948		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1990					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  1990					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  1990					      LIST	ON
      0  1990					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  1990				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1990				   WHITE_PAWN_on_WHITE_SQUARE_1
      3  1990				   TEMPORARY_VAR SET	Overlay
      4  1990				   TEMPORARY_OFFSET SET	0
      5  1990				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1990				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      7  1990					      SUBROUTINE
      3  1990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  19a8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  19c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  19d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  19d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  1a00					      LIST	ON
      0  1a00					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  1a00				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1a00				   WHITE_PAWN_on_WHITE_SQUARE_2
      3  1a00				   TEMPORARY_VAR SET	Overlay
      4  1a00				   TEMPORARY_OFFSET SET	0
      5  1a00				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1a00				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      7  1a00					      SUBROUTINE
      3  1a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1a18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a30		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1a48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  1a48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  1a48					      LIST	ON
      0  1a48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  1a48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1a48				   WHITE_PAWN_on_WHITE_SQUARE_3
      3  1a48				   TEMPORARY_VAR SET	Overlay
      4  1a48				   TEMPORARY_OFFSET SET	0
      5  1a48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1a48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      7  1a48					      SUBROUTINE
      3  1a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a78		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1a90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  1a90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  1a90					      LIST	ON
      0  1a90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  1a90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1a90				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  1a90				   TEMPORARY_VAR SET	Overlay
      4  1a90				   TEMPORARY_OFFSET SET	0
      5  1a90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1a90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      7  1a90					      SUBROUTINE
      3  1a90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1aa8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1ad8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  1ad8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  1b00					      LIST	ON
      0  1b00					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  1b00				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1b00				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  1b00				   TEMPORARY_VAR SET	Overlay
      4  1b00				   TEMPORARY_OFFSET SET	0
      5  1b00				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1b00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      7  1b00					      SUBROUTINE
      3  1b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1b48					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  1b48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  1b48					      LIST	ON
      0  1b48					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  1b48				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1b48				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  1b48				   TEMPORARY_VAR SET	Overlay
      4  1b48				   TEMPORARY_OFFSET SET	0
      5  1b48				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1b48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      7  1b48					      SUBROUTINE
      3  1b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1b78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1b90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  1b90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  1b90					      LIST	ON
      0  1b90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  1b90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1b90				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  1b90				   TEMPORARY_VAR SET	Overlay
      4  1b90				   TEMPORARY_OFFSET SET	0
      5  1b90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1b90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      7  1b90					      SUBROUTINE
      3  1b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1bc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1bd8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  1bd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  1c00					      LIST	ON
      0  1c00					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  1c00				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1c00				   WHITE_BISHOP_on_WHITE_SQUARE_0
      3  1c00				   TEMPORARY_VAR SET	Overlay
      4  1c00				   TEMPORARY_OFFSET SET	0
      5  1c00				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1c00				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      7  1c00					      SUBROUTINE
      3  1c00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  1c18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1c48					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  1c48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  1c48					      LIST	ON
      0  1c48					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  1c48				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1c48				   WHITE_BISHOP_on_WHITE_SQUARE_1
      3  1c48				   TEMPORARY_VAR SET	Overlay
      4  1c48				   TEMPORARY_OFFSET SET	0
      5  1c48				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1c48				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      7  1c48					      SUBROUTINE
      3  1c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1c60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  1c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1c90					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  1c90					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  1c90					      LIST	ON
      0  1c90					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  1c90				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1c90				   WHITE_BISHOP_on_WHITE_SQUARE_2
      3  1c90				   TEMPORARY_VAR SET	Overlay
      4  1c90				   TEMPORARY_OFFSET SET	0
      5  1c90				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1c90				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      7  1c90					      SUBROUTINE
      3  1c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ca8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  1cc0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1cd8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  1cd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  1d00					      LIST	ON
      0  1d00					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  1d00				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1d00				   WHITE_BISHOP_on_WHITE_SQUARE_3
      3  1d00				   TEMPORARY_VAR SET	Overlay
      4  1d00				   TEMPORARY_OFFSET SET	0
      5  1d00				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1d00				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      7  1d00					      SUBROUTINE
      3  1d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1d30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1d48					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  1d48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  1d48					      LIST	ON
      0  1d48					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  1d48				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1d48				   WHITE_ROOK_on_WHITE_SQUARE_0
      3  1d48				   TEMPORARY_VAR SET	Overlay
      4  1d48				   TEMPORARY_OFFSET SET	0
      5  1d48				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1d48				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      7  1d48					      SUBROUTINE
      3  1d48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1d60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1d90					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  1d90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  1d90					      LIST	ON
      0  1d90					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  1d90				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1d90				   WHITE_ROOK_on_WHITE_SQUARE_1
      3  1d90				   TEMPORARY_VAR SET	Overlay
      4  1d90				   TEMPORARY_OFFSET SET	0
      5  1d90				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1d90				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      7  1d90					      SUBROUTINE
      3  1d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1da8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1dd8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  1dd8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  1e00					      LIST	ON
      0  1e00					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  1e00				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1e00				   WHITE_ROOK_on_WHITE_SQUARE_2
      3  1e00				   TEMPORARY_VAR SET	Overlay
      4  1e00				   TEMPORARY_OFFSET SET	0
      5  1e00				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1e00				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      7  1e00					      SUBROUTINE
      3  1e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1e30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1e48					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  1e48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  1e48					      LIST	ON
      0  1e48					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  1e48				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1e48				   WHITE_ROOK_on_WHITE_SQUARE_3
      3  1e48				   TEMPORARY_VAR SET	Overlay
      4  1e48				   TEMPORARY_OFFSET SET	0
      5  1e48				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1e48				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      7  1e48					      SUBROUTINE
      3  1e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1e78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1e90					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  1e90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  1e90					      LIST	ON
      0  1e90					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  1e90				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1e90				   WHITE_QUEEN_on_WHITE_SQUARE_0
      3  1e90				   TEMPORARY_VAR SET	Overlay
      4  1e90				   TEMPORARY_OFFSET SET	0
      5  1e90				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1e90				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      7  1e90					      SUBROUTINE
      3  1e90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ea8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1ed8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  1ed8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  1f00					      LIST	ON
      0  1f00					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  1f00				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1f00				   WHITE_QUEEN_on_WHITE_SQUARE_1
      3  1f00				   TEMPORARY_VAR SET	Overlay
      4  1f00				   TEMPORARY_OFFSET SET	0
      5  1f00				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1f00				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      7  1f00					      SUBROUTINE
      3  1f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f18		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1f48					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  1f48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  1f48					      LIST	ON
      0  1f48					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  1f48				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1f48				   WHITE_QUEEN_on_WHITE_SQUARE_2
      3  1f48				   TEMPORARY_VAR SET	Overlay
      4  1f48				   TEMPORARY_OFFSET SET	0
      5  1f48				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1f48				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      7  1f48					      SUBROUTINE
      3  1f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f60		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1f78		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1f90					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  1f90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  1f90					      LIST	ON
      0  1f90					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  1f90				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1f90				   WHITE_QUEEN_on_WHITE_SQUARE_3
      3  1f90				   TEMPORARY_VAR SET	Overlay
      4  1f90				   TEMPORARY_OFFSET SET	0
      5  1f90				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1f90				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      7  1f90					      SUBROUTINE
      3  1f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1fc0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  1fd8					      CHECK_BANK_SIZE	"PIECE_0 (2K)"
      1  1fd8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_0 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  1fd8					      ECHO	"PIECE_0 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1fd8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  1fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1fd8				  -	      ERR
      6  1fd8					      ENDIF
      7  1fd8
      0  1fd8					      NEWBANK	PIECES_1
      1  27d8 ????				      SEG	PIECES_1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   PIECES_1   SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	PIECES_1
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2000					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  2000					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  2000					      LIST	ON
      0  2000					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  2000				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2000				   WHITE_KING_on_WHITE_SQUARE_0
      3  2000				   TEMPORARY_VAR SET	Overlay
      4  2000				   TEMPORARY_OFFSET SET	0
      5  2000				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2000				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      7  2000					      SUBROUTINE
      3  2000		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$a0,$80,$40,$00,$00	;PF0
      4  2018		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2048					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  2048					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  2048					      LIST	ON
      0  2048					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  2048				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2048				   WHITE_KING_on_WHITE_SQUARE_1
      3  2048				   TEMPORARY_VAR SET	Overlay
      4  2048				   TEMPORARY_OFFSET SET	0
      5  2048				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2048				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      7  2048					      SUBROUTINE
      3  2048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2060		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$28,$08,$10,$00,$00	;PF1
      5  2078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2090					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  2090					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  2090					      LIST	ON
      0  2090					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  2090				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2090				   WHITE_KING_on_WHITE_SQUARE_2
      3  2090				   TEMPORARY_VAR SET	Overlay
      4  2090				   TEMPORARY_OFFSET SET	0
      5  2090				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2090				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      7  2090					      SUBROUTINE
      3  2090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  20a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$01,$00,$00,$00,$00	;PF1
      5  20c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$02,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  20d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  20d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  2100					      LIST	ON
      0  2100					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  2100				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2100				   WHITE_KING_on_WHITE_SQUARE_3
      3  2100				   TEMPORARY_VAR SET	Overlay
      4  2100				   TEMPORARY_OFFSET SET	0
      5  2100				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2100				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      7  2100					      SUBROUTINE
      3  2100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2130		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$50,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2148					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  2148					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  2148					      LIST	ON
      0  2148					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  2148				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2148				   WHITE_BLANK_on_BLACK_SQUARE_0
      3  2148				   TEMPORARY_VAR SET	Overlay
      4  2148				   TEMPORARY_OFFSET SET	0
      5  2148				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2148				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      7  2148					      SUBROUTINE
      3  2148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2190					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  2190					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  2190					      LIST	ON
      0  2190					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  2190				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2190				   WHITE_BLANK_on_BLACK_SQUARE_1
      3  2190				   TEMPORARY_VAR SET	Overlay
      4  2190				   TEMPORARY_OFFSET SET	0
      5  2190				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2190				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      7  2190					      SUBROUTINE
      3  2190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  21a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  21c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  21d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  21d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  2200					      LIST	ON
      0  2200					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  2200				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2200				   WHITE_BLANK_on_BLACK_SQUARE_2
      3  2200				   TEMPORARY_VAR SET	Overlay
      4  2200				   TEMPORARY_OFFSET SET	0
      5  2200				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2200				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      7  2200					      SUBROUTINE
      3  2200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2230		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2248					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  2248					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  2248					      LIST	ON
      0  2248					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  2248				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2248				   WHITE_BLANK_on_BLACK_SQUARE_3
      3  2248				   TEMPORARY_VAR SET	Overlay
      4  2248				   TEMPORARY_OFFSET SET	0
      5  2248				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2248				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      7  2248					      SUBROUTINE
      3  2248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2290					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  2290					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  2290					      LIST	ON
      0  2290					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  2290				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2290				   WHITE_PAWN_on_BLACK_SQUARE_0
      3  2290				   TEMPORARY_VAR SET	Overlay
      4  2290				   TEMPORARY_OFFSET SET	0
      5  2290				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2290				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      7  2290					      SUBROUTINE
      3  2290		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  22a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  22c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  22d8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  22d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  2300					      LIST	ON
      0  2300					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  2300				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2300				   WHITE_PAWN_on_BLACK_SQUARE_1
      3  2300				   TEMPORARY_VAR SET	Overlay
      4  2300				   TEMPORARY_OFFSET SET	0
      5  2300				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2300				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      7  2300					      SUBROUTINE
      3  2300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2318		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2348					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  2348					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  2348					      LIST	ON
      0  2348					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  2348				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2348				   WHITE_PAWN_on_BLACK_SQUARE_2
      3  2348				   TEMPORARY_VAR SET	Overlay
      4  2348				   TEMPORARY_OFFSET SET	0
      5  2348				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2348				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      7  2348					      SUBROUTINE
      3  2348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2360		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  2378		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2390					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  2390					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  2390					      LIST	ON
      0  2390					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  2390				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2390				   WHITE_PAWN_on_BLACK_SQUARE_3
      3  2390				   TEMPORARY_VAR SET	Overlay
      4  2390				   TEMPORARY_OFFSET SET	0
      5  2390				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2390				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      7  2390					      SUBROUTINE
      3  2390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  23a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  23c0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  23d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  23d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  2400					      LIST	ON
      0  2400					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  2400				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2400				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  2400				   TEMPORARY_VAR SET	Overlay
      4  2400				   TEMPORARY_OFFSET SET	0
      5  2400				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2400				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      7  2400					      SUBROUTINE
      3  2400		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  2418		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2448					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  2448					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  2448					      LIST	ON
      0  2448					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  2448				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2448				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  2448				   TEMPORARY_VAR SET	Overlay
      4  2448				   TEMPORARY_OFFSET SET	0
      5  2448				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2448				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      7  2448					      SUBROUTINE
      3  2448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2460		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  2478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2490					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  2490					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  2490					      LIST	ON
      0  2490					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  2490				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2490				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  2490				   TEMPORARY_VAR SET	Overlay
      4  2490				   TEMPORARY_OFFSET SET	0
      5  2490				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2490				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      7  2490					      SUBROUTINE
      3  2490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  24a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  24c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  24d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  24d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  2500					      LIST	ON
      0  2500					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  2500				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2500				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  2500				   TEMPORARY_VAR SET	Overlay
      4  2500				   TEMPORARY_OFFSET SET	0
      5  2500				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2500				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      7  2500					      SUBROUTINE
      3  2500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2530		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2548					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  2548					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  2548					      LIST	ON
      0  2548					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  2548				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2548				   WHITE_BISHOP_on_BLACK_SQUARE_0
      3  2548				   TEMPORARY_VAR SET	Overlay
      4  2548				   TEMPORARY_OFFSET SET	0
      5  2548				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2548				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      7  2548					      SUBROUTINE
      3  2548		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  2560		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  2578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2590					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  2590					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  2590					      LIST	ON
      0  2590					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  2590				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2590				   WHITE_BISHOP_on_BLACK_SQUARE_1
      3  2590				   TEMPORARY_VAR SET	Overlay
      4  2590				   TEMPORARY_OFFSET SET	0
      5  2590				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2590				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      7  2590					      SUBROUTINE
      3  2590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  25a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  25c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  25d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  25d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  2600					      LIST	ON
      0  2600					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  2600				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2600				   WHITE_BISHOP_on_BLACK_SQUARE_2
      3  2600				   TEMPORARY_VAR SET	Overlay
      4  2600				   TEMPORARY_OFFSET SET	0
      5  2600				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2600				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      7  2600					      SUBROUTINE
      3  2600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2618		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  2630		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2648					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  2648					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  2648					      LIST	ON
      0  2648					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  2648				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2648				   WHITE_BISHOP_on_BLACK_SQUARE_3
      3  2648				   TEMPORARY_VAR SET	Overlay
      4  2648				   TEMPORARY_OFFSET SET	0
      5  2648				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2648				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      7  2648					      SUBROUTINE
      3  2648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2678		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2690					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  2690					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  2690					      LIST	ON
      0  2690					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  2690				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2690				   WHITE_ROOK_on_BLACK_SQUARE_0
      3  2690				   TEMPORARY_VAR SET	Overlay
      4  2690				   TEMPORARY_OFFSET SET	0
      5  2690				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2690				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      7  2690					      SUBROUTINE
      3  2690		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  26a8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  26c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  26d8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  26d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  2700					      LIST	ON
      0  2700					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  2700				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2700				   WHITE_ROOK_on_BLACK_SQUARE_1
      3  2700				   TEMPORARY_VAR SET	Overlay
      4  2700				   TEMPORARY_OFFSET SET	0
      5  2700				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2700				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      7  2700					      SUBROUTINE
      3  2700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2718		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  2730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2748					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  2748					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  2748					      LIST	ON
      0  2748					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  2748				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2748				   WHITE_ROOK_on_BLACK_SQUARE_2
      3  2748				   TEMPORARY_VAR SET	Overlay
      4  2748				   TEMPORARY_OFFSET SET	0
      5  2748				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2748				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      7  2748					      SUBROUTINE
      3  2748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2760		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  2778		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2790					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  2790					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  2790					      LIST	ON
      0  2790					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  2790				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2790				   WHITE_ROOK_on_BLACK_SQUARE_3
      3  2790				   TEMPORARY_VAR SET	Overlay
      4  2790				   TEMPORARY_OFFSET SET	0
      5  2790				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2790				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      7  2790					      SUBROUTINE
      3  2790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  27a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  27c0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  27d8					      CHECK_BANK_SIZE	"PIECE_1 (2K)"
      1  27d8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_1 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  27d8					      ECHO	"PIECE_1 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27d8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  27d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27d8				  -	      ERR
      6  27d8					      ENDIF
      7  27d8
      0  27d8					      NEWBANK	PIECES_2
      1  2fd8 ????				      SEG	PIECES_2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   PIECES_2   SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	PIECES_2
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2800					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  2800				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2800				   WHITE_QUEEN_on_BLACK_SQUARE_0
      3  2800				   TEMPORARY_VAR SET	Overlay
      4  2800				   TEMPORARY_OFFSET SET	0
      5  2800				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2800				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      7  2800					      SUBROUTINE
      3  2800		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  2818		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2848					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  2848				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2848				   WHITE_QUEEN_on_BLACK_SQUARE_1
      3  2848				   TEMPORARY_VAR SET	Overlay
      4  2848				   TEMPORARY_OFFSET SET	0
      5  2848				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2848				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      7  2848					      SUBROUTINE
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2890					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  2890				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2890				   WHITE_QUEEN_on_BLACK_SQUARE_2
      3  2890				   TEMPORARY_VAR SET	Overlay
      4  2890				   TEMPORARY_OFFSET SET	0
      5  2890				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2890				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      7  2890					      SUBROUTINE
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  28c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  28d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  2900				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2900				   WHITE_QUEEN_on_BLACK_SQUARE_3
      3  2900				   TEMPORARY_VAR SET	Overlay
      4  2900				   TEMPORARY_OFFSET SET	0
      5  2900				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2900				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      7  2900					      SUBROUTINE
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2948					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  2948				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2948				   WHITE_KING_on_BLACK_SQUARE_0
      3  2948				   TEMPORARY_VAR SET	Overlay
      4  2948				   TEMPORARY_OFFSET SET	0
      5  2948				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2948				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      7  2948					      SUBROUTINE
      3  2948		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$f0,$50,$70,$b0,$e0,$40	;PF0
      4  2960		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$00,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2990					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  2990				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2990				   WHITE_KING_on_BLACK_SQUARE_1
      3  2990				   TEMPORARY_VAR SET	Overlay
      4  2990				   TEMPORARY_OFFSET SET	0
      5  2990				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2990				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      7  2990					      SUBROUTINE
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$7c,$54,$74,$6c,$38,$10	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  29d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  2a00				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2a00				   WHITE_KING_on_BLACK_SQUARE_2
      3  2a00				   TEMPORARY_VAR SET	Overlay
      4  2a00				   TEMPORARY_OFFSET SET	0
      5  2a00				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2a00				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      7  2a00					      SUBROUTINE
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$03,$02,$03,$03,$01,$00	;PF1
      5  2a30		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$07,$05,$05,$06,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2a48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  2a48				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2a48				   WHITE_KING_on_BLACK_SQUARE_3
      3  2a48				   TEMPORARY_VAR SET	Overlay
      4  2a48				   TEMPORARY_OFFSET SET	0
      5  2a48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2a48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      7  2a48					      SUBROUTINE
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$f8,$a8,$b8,$d8,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2a90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  2a90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2a90				   BLACK_BLANK_on_WHITE_SQUARE_0
      3  2a90				   TEMPORARY_VAR SET	Overlay
      4  2a90				   TEMPORARY_OFFSET SET	0
      5  2a90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2a90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      7  2a90					      SUBROUTINE
      3  2a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  2aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2ad8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  2b00				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2b00				   BLACK_BLANK_on_WHITE_SQUARE_1
      3  2b00				   TEMPORARY_VAR SET	Overlay
      4  2b00				   TEMPORARY_OFFSET SET	0
      5  2b00				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2b00				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      7  2b00					      SUBROUTINE
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2b48					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  2b48				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2b48				   BLACK_BLANK_on_WHITE_SQUARE_2
      3  2b48				   TEMPORARY_VAR SET	Overlay
      4  2b48				   TEMPORARY_OFFSET SET	0
      5  2b48				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2b48				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      7  2b48					      SUBROUTINE
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  2b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2b90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  2b90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2b90				   BLACK_BLANK_on_WHITE_SQUARE_3
      3  2b90				   TEMPORARY_VAR SET	Overlay
      4  2b90				   TEMPORARY_OFFSET SET	0
      5  2b90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2b90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      7  2b90					      SUBROUTINE
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2bd8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  2bd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  2c00				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2c00				   BLACK_PAWN_on_WHITE_SQUARE_0
      3  2c00				   TEMPORARY_VAR SET	Overlay
      4  2c00				   TEMPORARY_OFFSET SET	0
      5  2c00				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2c00				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      7  2c00					      SUBROUTINE
      3  2c00		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$00,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  2c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2c48					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  2c48				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2c48				   BLACK_PAWN_on_WHITE_SQUARE_1
      3  2c48				   TEMPORARY_VAR SET	Overlay
      4  2c48				   TEMPORARY_OFFSET SET	0
      5  2c48				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2c48				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      7  2c48					      SUBROUTINE
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$00,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2c90					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  2c90				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2c90				   BLACK_PAWN_on_WHITE_SQUARE_2
      3  2c90				   TEMPORARY_VAR SET	Overlay
      4  2c90				   TEMPORARY_OFFSET SET	0
      5  2c90				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2c90				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      7  2c90					      SUBROUTINE
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  2cc0		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$00,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2cd8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  2d00				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2d00				   BLACK_PAWN_on_WHITE_SQUARE_3
      3  2d00				   TEMPORARY_VAR SET	Overlay
      4  2d00				   TEMPORARY_OFFSET SET	0
      5  2d00				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2d00				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      7  2d00					      SUBROUTINE
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$00,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2d48					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  2d48				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2d48				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  2d48				   TEMPORARY_VAR SET	Overlay
      4  2d48				   TEMPORARY_OFFSET SET	0
      5  2d48				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2d48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      7  2d48					      SUBROUTINE
      3  2d48		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  2d60		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2d90					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  2d90				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2d90				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  2d90				   TEMPORARY_VAR SET	Overlay
      4  2d90				   TEMPORARY_OFFSET SET	0
      5  2d90				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2d90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      7  2d90					      SUBROUTINE
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2dd8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  2e00				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2e00				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  2e00				   TEMPORARY_VAR SET	Overlay
      4  2e00				   TEMPORARY_OFFSET SET	0
      5  2e00				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2e00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      7  2e00					      SUBROUTINE
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  2e30		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2e48					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  2e48				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2e48				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  2e48				   TEMPORARY_VAR SET	Overlay
      4  2e48				   TEMPORARY_OFFSET SET	0
      5  2e48				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2e48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      7  2e48					      SUBROUTINE
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2e90					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  2e90				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2e90				   BLACK_BISHOP_on_WHITE_SQUARE_0
      3  2e90				   TEMPORARY_VAR SET	Overlay
      4  2e90				   TEMPORARY_OFFSET SET	0
      5  2e90				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2e90				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      7  2e90					      SUBROUTINE
      3  2e90		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  2ea8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2ed8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  2f00				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2f00				   BLACK_BISHOP_on_WHITE_SQUARE_1
      3  2f00				   TEMPORARY_VAR SET	Overlay
      4  2f00				   TEMPORARY_OFFSET SET	0
      5  2f00				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2f00				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      7  2f00					      SUBROUTINE
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2f48					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  2f48				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2f48				   BLACK_BISHOP_on_WHITE_SQUARE_2
      3  2f48				   TEMPORARY_VAR SET	Overlay
      4  2f48				   TEMPORARY_OFFSET SET	0
      5  2f48				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2f48				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      7  2f48					      SUBROUTINE
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  2f78		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2f90					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  2f90				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2f90				   BLACK_BISHOP_on_WHITE_SQUARE_3
      3  2f90				   TEMPORARY_VAR SET	Overlay
      4  2f90				   TEMPORARY_OFFSET SET	0
      5  2f90				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2f90				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      7  2f90					      SUBROUTINE
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECE_2 (2K)"
      1  2fd8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_2 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  2fd8					      ECHO	"PIECE_2 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      7  2fd8
      0  2fd8					      NEWBANK	PIECES_3
      1  37d8 ????				      SEG	PIECES_3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   PIECES_3   SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	PIECES_3
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  3000					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  3000				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3000				   BLACK_ROOK_on_WHITE_SQUARE_0
      3  3000				   TEMPORARY_VAR SET	Overlay
      4  3000				   TEMPORARY_OFFSET SET	0
      5  3000				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3000				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      7  3000					      SUBROUTINE
      3  3000		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  3018		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  3048					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  3048				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3048				   BLACK_ROOK_on_WHITE_SQUARE_1
      3  3048				   TEMPORARY_VAR SET	Overlay
      4  3048				   TEMPORARY_OFFSET SET	0
      5  3048				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3048				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      7  3048					      SUBROUTINE
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  3090					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  3090				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3090				   BLACK_ROOK_on_WHITE_SQUARE_2
      3  3090				   TEMPORARY_VAR SET	Overlay
      4  3090				   TEMPORARY_OFFSET SET	0
      5  3090				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3090				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      7  3090					      SUBROUTINE
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  30c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  30d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  3100				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3100				   BLACK_ROOK_on_WHITE_SQUARE_3
      3  3100				   TEMPORARY_VAR SET	Overlay
      4  3100				   TEMPORARY_OFFSET SET	0
      5  3100				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3100				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      7  3100					      SUBROUTINE
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  3148					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  3148				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3148				   BLACK_QUEEN_on_WHITE_SQUARE_0
      3  3148				   TEMPORARY_VAR SET	Overlay
      4  3148				   TEMPORARY_OFFSET SET	0
      5  3148				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3148				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      7  3148					      SUBROUTINE
      3  3148		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3160		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  3190					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  3190				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3190				   BLACK_QUEEN_on_WHITE_SQUARE_1
      3  3190				   TEMPORARY_VAR SET	Overlay
      4  3190				   TEMPORARY_OFFSET SET	0
      5  3190				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3190				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      7  3190					      SUBROUTINE
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  31d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  3200				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3200				   BLACK_QUEEN_on_WHITE_SQUARE_2
      3  3200				   TEMPORARY_VAR SET	Overlay
      4  3200				   TEMPORARY_OFFSET SET	0
      5  3200				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3200				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      7  3200					      SUBROUTINE
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  3230		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  3248					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  3248				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3248				   BLACK_QUEEN_on_WHITE_SQUARE_3
      3  3248				   TEMPORARY_VAR SET	Overlay
      4  3248				   TEMPORARY_OFFSET SET	0
      5  3248				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3248				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      7  3248					      SUBROUTINE
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  3290					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  3290				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3290				   BLACK_KING_on_WHITE_SQUARE_0
      3  3290				   TEMPORARY_VAR SET	Overlay
      4  3290				   TEMPORARY_OFFSET SET	0
      5  3290				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3290				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      7  3290					      SUBROUTINE
      3  3290		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$f0,$f0,$40,$e0,$40	;PF0
      4  32a8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  32d8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  3300				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3300				   BLACK_KING_on_WHITE_SQUARE_1
      3  3300				   TEMPORARY_VAR SET	Overlay
      4  3300				   TEMPORARY_OFFSET SET	0
      5  3300				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3300				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      7  3300					      SUBROUTINE
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$7c,$7c,$10,$38,$10	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  3348					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  3348				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3348				   BLACK_KING_on_WHITE_SQUARE_2
      3  3348				   TEMPORARY_VAR SET	Overlay
      4  3348				   TEMPORARY_OFFSET SET	0
      5  3348				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3348				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      7  3348					      SUBROUTINE
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$03,$03,$00,$01,$00	;PF1
      5  3378		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$07,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  3390					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  3390				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3390				   BLACK_KING_on_WHITE_SQUARE_3
      3  3390				   TEMPORARY_VAR SET	Overlay
      4  3390				   TEMPORARY_OFFSET SET	0
      5  3390				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3390				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      7  3390					      SUBROUTINE
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$f8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  33d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  33d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  3400				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3400				   BLACK_BLANK_on_BLACK_SQUARE_0
      3  3400				   TEMPORARY_VAR SET	Overlay
      4  3400				   TEMPORARY_OFFSET SET	0
      5  3400				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3400				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      7  3400					      SUBROUTINE
      3  3400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  3448					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  3448				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3448				   BLACK_BLANK_on_BLACK_SQUARE_1
      3  3448				   TEMPORARY_VAR SET	Overlay
      4  3448				   TEMPORARY_OFFSET SET	0
      5  3448				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3448				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      7  3448					      SUBROUTINE
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  3490					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  3490				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3490				   BLACK_BLANK_on_BLACK_SQUARE_2
      3  3490				   TEMPORARY_VAR SET	Overlay
      4  3490				   TEMPORARY_OFFSET SET	0
      5  3490				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3490				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      7  3490					      SUBROUTINE
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  34c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  34d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  3500				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3500				   BLACK_BLANK_on_BLACK_SQUARE_3
      3  3500				   TEMPORARY_VAR SET	Overlay
      4  3500				   TEMPORARY_OFFSET SET	0
      5  3500				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3500				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      7  3500					      SUBROUTINE
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  3548					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  3548				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3548				   BLACK_PAWN_on_BLACK_SQUARE_0
      3  3548				   TEMPORARY_VAR SET	Overlay
      4  3548				   TEMPORARY_OFFSET SET	0
      5  3548				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3548				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      7  3548					      SUBROUTINE
      3  3548		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  3590					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  3590				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3590				   BLACK_PAWN_on_BLACK_SQUARE_1
      3  3590				   TEMPORARY_VAR SET	Overlay
      4  3590				   TEMPORARY_OFFSET SET	0
      5  3590				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3590				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      7  3590					      SUBROUTINE
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  35d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  3600				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3600				   BLACK_PAWN_on_BLACK_SQUARE_2
      3  3600				   TEMPORARY_VAR SET	Overlay
      4  3600				   TEMPORARY_OFFSET SET	0
      5  3600				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3600				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      7  3600					      SUBROUTINE
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3630		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  3648					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  3648				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3648				   BLACK_PAWN_on_BLACK_SQUARE_3
      3  3648				   TEMPORARY_VAR SET	Overlay
      4  3648				   TEMPORARY_OFFSET SET	0
      5  3648				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3648				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      7  3648					      SUBROUTINE
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  3690					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  3690				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3690				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  3690				   TEMPORARY_VAR SET	Overlay
      4  3690				   TEMPORARY_OFFSET SET	0
      5  3690				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3690				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      7  3690					      SUBROUTINE
      3  3690		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  36a8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  36d8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  3700				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3700				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  3700				   TEMPORARY_VAR SET	Overlay
      4  3700				   TEMPORARY_OFFSET SET	0
      5  3700				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3700				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      7  3700					      SUBROUTINE
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  3748					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  3748				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3748				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  3748				   TEMPORARY_VAR SET	Overlay
      4  3748				   TEMPORARY_OFFSET SET	0
      5  3748				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3748				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      7  3748					      SUBROUTINE
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3778		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  3790					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  3790				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3790				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  3790				   TEMPORARY_VAR SET	Overlay
      4  3790				   TEMPORARY_OFFSET SET	0
      5  3790				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3790				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      7  3790					      SUBROUTINE
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECES_3 (2K)"
      1  37d8		       07 d8	   .TEMP      =	* - BANK_START
 PIECES_3 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  37d8					      ECHO	"PIECES_3 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      7  37d8
    107  37d8							;    NEWBANK PIECES_4
    108  37d8
    109  37d8							;    CHECK_BANK_SIZE "PIECES_4 (2K)"
    110  37d8
    111  37d8							;    NEWBANK PIECES_5
    112  37d8
    113  37d8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    114  37d8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    115  37d8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    116  37d8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    117  37d8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    118  37d8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    119  37d8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    120  37d8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    121  37d8
    122  37d8
    123  37d8				  -	      IF	0
    124  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    125  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    126  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    127  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    128  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    129  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    130  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    131  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    132  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    133  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    134  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    135  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    136  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    137  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    138  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    139  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    140  37d8					      ENDIF
    141  37d8
    142  37d8							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    143  37d8
    144  37d8				  -	      IF	0
    145  37d8				  -	      NEWBANK	PIECES_6
    146  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    147  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    148  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    149  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    150  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    151  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    152  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    153  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    154  37d8				  -
    155  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    156  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    157  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    158  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    159  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    160  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    161  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    162  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    163  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    164  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    165  37d8				  -
    166  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    167  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    168  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    169  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    170  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    171  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    172  37d8				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    173  37d8				  -
    174  37d8				  -
    175  37d8				  -	      NEWBANK	PIECES_7
    176  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    177  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    178  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    179  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    180  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    181  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    182  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    183  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    184  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    185  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    186  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    187  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    188  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    189  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    190  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    191  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    192  37d8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    193  37d8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    194  37d8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    195  37d8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    196  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    197  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    198  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    199  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    200  37d8				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    201  37d8				  -
    202  37d8				  -
    203  37d8				  -	      NEWBANK	PIECES_8
    204  37d8				  -
    205  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    206  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    207  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    208  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    209  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    210  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    211  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    212  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    213  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    214  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    215  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    216  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    217  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    218  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    219  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    220  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    221  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    222  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    223  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    224  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    225  37d8				  -
    226  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    227  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    228  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    229  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    230  37d8				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    231  37d8				  -
    232  37d8					      ENDIF
    233  37d8
    234  37d8							;    NEWBANK PIECES_9
    235  37d8
    236  37d8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    237  37d8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    238  37d8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    239  37d8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    240  37d8							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    241  37d8
    242  37d8				  -	      IF	0
    243  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    244  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    245  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    246  37d8					      ENDIF
    247  37d8
    248  37d8							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    249  37d8
    250  37d8				  -	      IF	0
    251  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    252  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    253  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    254  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    255  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    256  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    257  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    258  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    259  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    260  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    261  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    262  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    263  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    264  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    265  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    266  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    267  37d8					      ENDIF
------- FILE BANK_CHESS_INCLUDES.asm
     38  37d8
     39  37d8							;    NEWBANK PIECE_VECTORS
     40  37d8							;    include "piece_vectors.asm"
     41  37d8							;    CHECK_BANK_SIZE "PIECE_VECTORS (2K)"
------- FILE ./chess.asm
------- FILE BANK_StateMachine.asm LEVEL 2 PASS 5
      0  37d8					      include	"BANK_StateMachine.asm"
      0  37d8					      NEWBANK	STATEMACHINE
      1  3ed8 ????				      SEG	STATEMACHINE
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   STATEMACHINE SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	STATEMACHINE
      2  3800
      3  3800
      4  3800							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      5  3800
      6  3800
      7  3800		       00 10	   CURSOR_MOVE_SPEED =	16
      8  3800		       00 14	   CAP_SPEED  =	20
      9  3800		       00 28	   HOLD_DELAY =	40
     10  3800
     11  3800
     12  3800							;---------------------------------------------------------------------------------------------------
     13  3800
     14  3800				   P	      SET	0
     15  3800					      MAC	ain
     16  3800				   AI_{1}     SET	P
     17  3800				   P	      SET	P+1
     18  3800					      ENDM
     19  3800
     20  3800					      MAC	lo
     21  3800					      .byte	<ai{1}
     22  3800					      ENDM
     23  3800
     24  3800					      MAC	hi
     25  3800					      .byte	>ai{1}
     26  3800					      ENDM
     27  3800
     28  3800					      MAC	bk
     29  3800					      .byte	BANK_ai{1}
     30  3800					      ENDM
     31  3800
     32  3800
     33  3800		       00 28	   ONCEPERFRAME =	40
     34  3800
     35  3800					      MAC	tabdef
     36  3800
     37  3800					      {1}	FlashComputerMove
     38  3800					      {1}	BeginSelectMovePhase
     39  3800					      {1}	SelectStartSquare
     40  3800					      {1}	StartSquareSelected
     41  3800					      {1}	DrawMoves
     42  3800					      {1}	ShowMoveCaptures
     43  3800					      {1}	SlowFlash
     44  3800					      {1}	UnDrawTargetSquares
     45  3800					      {1}	SelectDestinationSquare
     46  3800					      {1}	Quiescent
     47  3800					      {1}	ReselectDebounce
     48  3800					      {1}	StartMoveGen
     49  3800					      {1}	StepMoveGen
     50  3800					      {1}	StartClearBoard
     51  3800					      {1}	ClearEachRow
     52  3800					      {1}	DrawEntireBoard
     53  3800					      {1}	DrawPart2
     54  3800					      {1}	DrawPart3
     55  3800					      {1}	GenerateMoves
     56  3800					      {1}	ComputerMove
     57  3800					      {1}	MoveIsSelected
     58  3800					      {1}	WriteStartPieceBlank
     59  3800					      {1}	MarchToTargetA
     60  3800					      {1}	MarchA2
     61  3800					      {1}	MarchB
     62  3800					      {1}	MarchToTargetB
     63  3800					      {1}	MarchB2
     64  3800					      {1}	FinalFlash
     65  3800					      {1}	SpecialMoveFixup
     66  3800					      {1}	InCheckBackup
     67  3800					      {1}	InCheckDelay
     68  3800					      {1}	PromotePawnStart
     69  3800					      {1}	RollPromotionPiece
     70  3800					      {1}	ChoosePromotePiece
     71  3800					      {1}	ChooseDebounce
     72  3800					      {1}	CheckMate
     73  3800					      {1}	Draw
     74  3800					      {1}	DelayAfterMove
     75  3800					      {1}	DelayAfterPlaced
     76  3800
     77  3800					      ENDM		; {1} = macro to use
     78  3800
      0  3800					      TABDEF	AIN
      1  3800
      0  3800					      AIN	FlashComputerMove
      1  3800				   AI_FlashComputerMove SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	BeginSelectMovePhase
      1  3800				   AI_BeginSelectMovePhase SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	SelectStartSquare
      1  3800				   AI_SelectStartSquare SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	StartSquareSelected
      1  3800				   AI_StartSquareSelected SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DrawMoves
      1  3800				   AI_DrawMoves SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ShowMoveCaptures
      1  3800				   AI_ShowMoveCaptures SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	SlowFlash
      1  3800				   AI_SlowFlash SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	UnDrawTargetSquares
      1  3800				   AI_UnDrawTargetSquares SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	SelectDestinationSquare
      1  3800				   AI_SelectDestinationSquare SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	Quiescent
      1  3800				   AI_Quiescent SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ReselectDebounce
      1  3800				   AI_ReselectDebounce SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	StartMoveGen
      1  3800				   AI_StartMoveGen SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	StepMoveGen
      1  3800				   AI_StepMoveGen SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	StartClearBoard
      1  3800				   AI_StartClearBoard SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ClearEachRow
      1  3800				   AI_ClearEachRow SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DrawEntireBoard
      1  3800				   AI_DrawEntireBoard SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DrawPart2
      1  3800				   AI_DrawPart2 SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DrawPart3
      1  3800				   AI_DrawPart3 SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	GenerateMoves
      1  3800				   AI_GenerateMoves SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ComputerMove
      1  3800				   AI_ComputerMove SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MoveIsSelected
      1  3800				   AI_MoveIsSelected SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	WriteStartPieceBlank
      1  3800				   AI_WriteStartPieceBlank SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchToTargetA
      1  3800				   AI_MarchToTargetA SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchA2
      1  3800				   AI_MarchA2 SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchB
      1  3800				   AI_MarchB  SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchToTargetB
      1  3800				   AI_MarchToTargetB SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchB2
      1  3800				   AI_MarchB2 SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	FinalFlash
      1  3800				   AI_FinalFlash SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	SpecialMoveFixup
      1  3800				   AI_SpecialMoveFixup SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	InCheckBackup
      1  3800				   AI_InCheckBackup SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	InCheckDelay
      1  3800				   AI_InCheckDelay SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	PromotePawnStart
      1  3800				   AI_PromotePawnStart SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	RollPromotionPiece
      1  3800				   AI_RollPromotionPiece SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ChoosePromotePiece
      1  3800				   AI_ChoosePromotePiece SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ChooseDebounce
      1  3800				   AI_ChooseDebounce SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	CheckMate
      1  3800				   AI_CheckMate SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	Draw
      1  3800				   AI_Draw    SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DelayAfterMove
      1  3800				   AI_DelayAfterMove SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DelayAfterPlaced
      1  3800				   AI_DelayAfterPlaced SET	P
      2  3800				   P	      SET	P+1
     41  3800
     80  3800
      0  3800					      DEF	AiVectorLO
      1  3800				   BANK_AiVectorLO SET	_CURRENT_BANK
      2  3800				   AiVectorLO
      3  3800				   TEMPORARY_VAR SET	Overlay
      4  3800				   TEMPORARY_OFFSET SET	0
      5  3800				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      6  3800				   FUNCTION_NAME SET	AiVectorLO
      7  3800					      SUBROUTINE
      0  3800					      TABDEF	LO
      1  3800
      0  3800					      LO	FlashComputerMove
      1  3800		       c4		      .byte.b	<aiFlashComputerMove
      0  3801					      LO	BeginSelectMovePhase
      1  3801		       a7		      .byte.b	<aiBeginSelectMovePhase
      0  3802					      LO	SelectStartSquare
      1  3802		       ec		      .byte.b	<aiSelectStartSquare
      0  3803					      LO	StartSquareSelected
      1  3803		       53		      .byte.b	<aiStartSquareSelected
      0  3804					      LO	DrawMoves
      1  3804		       6e		      .byte.b	<aiDrawMoves
      0  3805					      LO	ShowMoveCaptures
      1  3805		       12		      .byte.b	<aiShowMoveCaptures
      0  3806					      LO	SlowFlash
      1  3806		       30		      .byte.b	<aiSlowFlash
      0  3807					      LO	UnDrawTargetSquares
      1  3807		       f0		      .byte.b	<aiUnDrawTargetSquares
      0  3808					      LO	SelectDestinationSquare
      1  3808		       89		      .byte.b	<aiSelectDestinationSquare
      0  3809					      LO	Quiescent
      1  3809		       e7		      .byte.b	<aiQuiescent
      0  380a					      LO	ReselectDebounce
      1  380a		       de		      .byte.b	<aiReselectDebounce
      0  380b					      LO	StartMoveGen
      1  380b		       87		      .byte.b	<aiStartMoveGen
      0  380c					      LO	StepMoveGen
      1  380c		       c9		      .byte.b	<aiStepMoveGen
      0  380d					      LO	StartClearBoard
      1  380d		       85		      .byte.b	<aiStartClearBoard
      0  380e					      LO	ClearEachRow
      1  380e		       92		      .byte.b	<aiClearEachRow
      0  380f					      LO	DrawEntireBoard
      1  380f		       83		      .byte.b	<aiDrawEntireBoard
      0  3810					      LO	DrawPart2
      1  3810		       e2		      .byte.b	<aiDrawPart2
      0  3811					      LO	DrawPart3
      1  3811		       e5		      .byte.b	<aiDrawPart3
      0  3812					      LO	GenerateMoves
      1  3812		       b7		      .byte.b	<aiGenerateMoves
      0  3813					      LO	ComputerMove
      1  3813		       47		      .byte.b	<aiComputerMove
      0  3814					      LO	MoveIsSelected
      1  3814		       a4		      .byte.b	<aiMoveIsSelected
      0  3815					      LO	WriteStartPieceBlank
      1  3815		       b8		      .byte.b	<aiWriteStartPieceBlank
      0  3816					      LO	MarchToTargetA
      1  3816		       93		      .byte.b	<aiMarchToTargetA
      0  3817					      LO	MarchA2
      1  3817		       e2		      .byte.b	<aiMarchA2
      0  3818					      LO	MarchB
      1  3818		       ff		      .byte.b	<aiMarchB
      0  3819					      LO	MarchToTargetB
      1  3819		       33		      .byte.b	<aiMarchToTargetB
      0  381a					      LO	MarchB2
      1  381a		       09		      .byte.b	<aiMarchB2
      0  381b					      LO	FinalFlash
      1  381b		       0f		      .byte.b	<aiFinalFlash
      0  381c					      LO	SpecialMoveFixup
      1  381c		       e7		      .byte.b	<aiSpecialMoveFixup
      0  381d					      LO	InCheckBackup
      1  381d		       8c		      .byte.b	<aiInCheckBackup
      0  381e					      LO	InCheckDelay
      1  381e		       9a		      .byte.b	<aiInCheckDelay
      0  381f					      LO	PromotePawnStart
      1  381f		       07		      .byte.b	<aiPromotePawnStart
      0  3820					      LO	RollPromotionPiece
      1  3820		       27		      .byte.b	<aiRollPromotionPiece
      0  3821					      LO	ChoosePromotePiece
      1  3821		       6d		      .byte.b	<aiChoosePromotePiece
      0  3822					      LO	ChooseDebounce
      1  3822		       d8		      .byte.b	<aiChooseDebounce
      0  3823					      LO	CheckMate
      1  3823		       36		      .byte.b	<aiCheckMate
      0  3824					      LO	Draw
      1  3824		       31		      .byte.b	<aiDraw
      0  3825					      LO	DelayAfterMove
      1  3825		       ea		      .byte.b	<aiDelayAfterMove
      0  3826					      LO	DelayAfterPlaced
      1  3826		       f3		      .byte.b	<aiDelayAfterPlaced
     41  3827
     83  3827
      0  3827					      DEF	AiVectorHI
      1  3827				   BANK_AiVectorHI SET	_CURRENT_BANK
      2  3827				   AiVectorHI
      3  3827				   TEMPORARY_VAR SET	Overlay
      4  3827				   TEMPORARY_OFFSET SET	0
      5  3827				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      6  3827				   FUNCTION_NAME SET	AiVectorHI
      7  3827					      SUBROUTINE
      0  3827					      TABDEF	HI
      1  3827
      0  3827					      HI	FlashComputerMove
      1  3827		       f0		      .byte.b	>aiFlashComputerMove
      0  3828					      HI	BeginSelectMovePhase
      1  3828		       f0		      .byte.b	>aiBeginSelectMovePhase
      0  3829					      HI	SelectStartSquare
      1  3829		       f0		      .byte.b	>aiSelectStartSquare
      0  382a					      HI	StartSquareSelected
      1  382a		       f1		      .byte.b	>aiStartSquareSelected
      0  382b					      HI	DrawMoves
      1  382b		       f1		      .byte.b	>aiDrawMoves
      0  382c					      HI	ShowMoveCaptures
      1  382c		       f2		      .byte.b	>aiShowMoveCaptures
      0  382d					      HI	SlowFlash
      1  382d		       f2		      .byte.b	>aiSlowFlash
      0  382e					      HI	UnDrawTargetSquares
      1  382e		       f1		      .byte.b	>aiUnDrawTargetSquares
      0  382f					      HI	SelectDestinationSquare
      1  382f		       f2		      .byte.b	>aiSelectDestinationSquare
      0  3830					      HI	Quiescent
      1  3830		       f2		      .byte.b	>aiQuiescent
      0  3831					      HI	ReselectDebounce
      1  3831		       f2		      .byte.b	>aiReselectDebounce
      0  3832					      HI	StartMoveGen
      1  3832		       f0		      .byte.b	>aiStartMoveGen
      0  3833					      HI	StepMoveGen
      1  3833		       f8		      .byte.b	>aiStepMoveGen
      0  3834					      HI	StartClearBoard
      1  3834		       f0		      .byte.b	>aiStartClearBoard
      0  3835					      HI	ClearEachRow
      1  3835		       f0		      .byte.b	>aiClearEachRow
      0  3836					      HI	DrawEntireBoard
      1  3836		       f8		      .byte.b	>aiDrawEntireBoard
      0  3837					      HI	DrawPart2
      1  3837		       f0		      .byte.b	>aiDrawPart2
      0  3838					      HI	DrawPart3
      1  3838		       f0		      .byte.b	>aiDrawPart3
      0  3839					      HI	GenerateMoves
      1  3839		       f8		      .byte.b	>aiGenerateMoves
      0  383a					      HI	ComputerMove
      1  383a		       f9		      .byte.b	>aiComputerMove
      0  383b					      HI	MoveIsSelected
      1  383b		       f0		      .byte.b	>aiMoveIsSelected
      0  383c					      HI	WriteStartPieceBlank
      1  383c		       f0		      .byte.b	>aiWriteStartPieceBlank
      0  383d					      HI	MarchToTargetA
      1  383d		       f0		      .byte.b	>aiMarchToTargetA
      0  383e					      HI	MarchA2
      1  383e		       f0		      .byte.b	>aiMarchA2
      0  383f					      HI	MarchB
      1  383f		       f0		      .byte.b	>aiMarchB
      0  3840					      HI	MarchToTargetB
      1  3840		       f1		      .byte.b	>aiMarchToTargetB
      0  3841					      HI	MarchB2
      1  3841		       f1		      .byte.b	>aiMarchB2
      0  3842					      HI	FinalFlash
      1  3842		       f1		      .byte.b	>aiFinalFlash
      0  3843					      HI	SpecialMoveFixup
      1  3843		       f9		      .byte.b	>aiSpecialMoveFixup
      0  3844					      HI	InCheckBackup
      1  3844		       f0		      .byte.b	>aiInCheckBackup
      0  3845					      HI	InCheckDelay
      1  3845		       f0		      .byte.b	>aiInCheckDelay
      0  3846					      HI	PromotePawnStart
      1  3846		       f3		      .byte.b	>aiPromotePawnStart
      0  3847					      HI	RollPromotionPiece
      1  3847		       f3		      .byte.b	>aiRollPromotionPiece
      0  3848					      HI	ChoosePromotePiece
      1  3848		       f3		      .byte.b	>aiChoosePromotePiece
      0  3849					      HI	ChooseDebounce
      1  3849		       f3		      .byte.b	>aiChooseDebounce
      0  384a					      HI	CheckMate
      1  384a		       f1		      .byte.b	>aiCheckMate
      0  384b					      HI	Draw
      1  384b		       f1		      .byte.b	>aiDraw
      0  384c					      HI	DelayAfterMove
      1  384c		       f3		      .byte.b	>aiDelayAfterMove
      0  384d					      HI	DelayAfterPlaced
      1  384d		       f3		      .byte.b	>aiDelayAfterPlaced
     41  384e
     86  384e
      0  384e					      DEF	AiVectorBANK
      1  384e				   BANK_AiVectorBANK SET	_CURRENT_BANK
      2  384e				   AiVectorBANK
      3  384e				   TEMPORARY_VAR SET	Overlay
      4  384e				   TEMPORARY_OFFSET SET	0
      5  384e				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      6  384e				   FUNCTION_NAME SET	AiVectorBANK
      7  384e					      SUBROUTINE
      0  384e					      TABDEF	BK
      1  384e
      0  384e					      BK	FlashComputerMove
      1  384e		       07		      .byte.b	BANK_aiFlashComputerMove
      0  384f					      BK	BeginSelectMovePhase
      1  384f		       07		      .byte.b	BANK_aiBeginSelectMovePhase
      0  3850					      BK	SelectStartSquare
      1  3850		       07		      .byte.b	BANK_aiSelectStartSquare
      0  3851					      BK	StartSquareSelected
      1  3851		       07		      .byte.b	BANK_aiStartSquareSelected
      0  3852					      BK	DrawMoves
      1  3852		       07		      .byte.b	BANK_aiDrawMoves
      0  3853					      BK	ShowMoveCaptures
      1  3853		       07		      .byte.b	BANK_aiShowMoveCaptures
      0  3854					      BK	SlowFlash
      1  3854		       07		      .byte.b	BANK_aiSlowFlash
      0  3855					      BK	UnDrawTargetSquares
      1  3855		       07		      .byte.b	BANK_aiUnDrawTargetSquares
      0  3856					      BK	SelectDestinationSquare
      1  3856		       07		      .byte.b	BANK_aiSelectDestinationSquare
      0  3857					      BK	Quiescent
      1  3857		       07		      .byte.b	BANK_aiQuiescent
      0  3858					      BK	ReselectDebounce
      1  3858		       07		      .byte.b	BANK_aiReselectDebounce
      0  3859					      BK	StartMoveGen
      1  3859		       07		      .byte.b	BANK_aiStartMoveGen
      0  385a					      BK	StepMoveGen
      1  385a		       1f		      .byte.b	BANK_aiStepMoveGen
      0  385b					      BK	StartClearBoard
      1  385b		       00		      .byte.b	BANK_aiStartClearBoard
      0  385c					      BK	ClearEachRow
      1  385c		       00		      .byte.b	BANK_aiClearEachRow
      0  385d					      BK	DrawEntireBoard
      1  385d		       1f		      .byte.b	BANK_aiDrawEntireBoard
      0  385e					      BK	DrawPart2
      1  385e		       00		      .byte.b	BANK_aiDrawPart2
      0  385f					      BK	DrawPart3
      1  385f		       00		      .byte.b	BANK_aiDrawPart3
      0  3860					      BK	GenerateMoves
      1  3860		       1f		      .byte.b	BANK_aiGenerateMoves
      0  3861					      BK	ComputerMove
      1  3861		       1f		      .byte.b	BANK_aiComputerMove
      0  3862					      BK	MoveIsSelected
      1  3862		       00		      .byte.b	BANK_aiMoveIsSelected
      0  3863					      BK	WriteStartPieceBlank
      1  3863		       00		      .byte.b	BANK_aiWriteStartPieceBlank
      0  3864					      BK	MarchToTargetA
      1  3864		       0b		      .byte.b	BANK_aiMarchToTargetA
      0  3865					      BK	MarchA2
      1  3865		       0b		      .byte.b	BANK_aiMarchA2
      0  3866					      BK	MarchB
      1  3866		       00		      .byte.b	BANK_aiMarchB
      0  3867					      BK	MarchToTargetB
      1  3867		       0b		      .byte.b	BANK_aiMarchToTargetB
      0  3868					      BK	MarchB2
      1  3868		       0b		      .byte.b	BANK_aiMarchB2
      0  3869					      BK	FinalFlash
      1  3869		       00		      .byte.b	BANK_aiFinalFlash
      0  386a					      BK	SpecialMoveFixup
      1  386a		       1f		      .byte.b	BANK_aiSpecialMoveFixup
      0  386b					      BK	InCheckBackup
      1  386b		       07		      .byte.b	BANK_aiInCheckBackup
      0  386c					      BK	InCheckDelay
      1  386c		       07		      .byte.b	BANK_aiInCheckDelay
      0  386d					      BK	PromotePawnStart
      1  386d		       07		      .byte.b	BANK_aiPromotePawnStart
      0  386e					      BK	RollPromotionPiece
      1  386e		       07		      .byte.b	BANK_aiRollPromotionPiece
      0  386f					      BK	ChoosePromotePiece
      1  386f		       07		      .byte.b	BANK_aiChoosePromotePiece
      0  3870					      BK	ChooseDebounce
      1  3870		       07		      .byte.b	BANK_aiChooseDebounce
      0  3871					      BK	CheckMate
      1  3871		       00		      .byte.b	BANK_aiCheckMate
      0  3872					      BK	Draw
      1  3872		       00		      .byte.b	BANK_aiDraw
      0  3873					      BK	DelayAfterMove
      1  3873		       07		      .byte.b	BANK_aiDelayAfterMove
      0  3874					      BK	DelayAfterPlaced
      1  3874		       07		      .byte.b	BANK_aiDelayAfterPlaced
     41  3875
     89  3875
     90  3875
     91  3875							;---------------------------------------------------------------------------------------------------
     92  3875
      0  3875					      DEF	AiSetupVectors
      1  3875				   BANK_AiSetupVectors SET	_CURRENT_BANK
      2  3875				   AiSetupVectors
      3  3875				   TEMPORARY_VAR SET	Overlay
      4  3875				   TEMPORARY_OFFSET SET	0
      5  3875				   VAR_BOUNDARY_AiSetupVectors SET	TEMPORARY_OFFSET
      6  3875				   FUNCTION_NAME SET	AiSetupVectors
      7  3875					      SUBROUTINE
     94  3875					      SUBROUTINE
     95  3875
      0  3875					      REFER	AiStateMachine
      1  3875				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3875				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3875					      ENDIF
      0  3875					      VEND	AiSetupVectors
      1  3875				  -	      IFNCONST	AiSetupVectors
      2  3875				  -	      ECHO	"Incorrect VEND label", AiSetupVectors
      3  3875				  -	      ERR
      4  3875					      ENDIF
      5  3875		       00 a7	   VAREND_AiSetupVectors =	TEMPORARY_VAR
     98  3875
     99  3875							; State machine vector setup - points to current routine to execute
    100  3875
    101  3875		       a6 8c		      ldx	aiState
    102  3877		       bd 00 f0 	      lda	AiVectorLO,x
    103  387a		       85 ef		      sta	__ptr
    104  387c		       bd 27 f0 	      lda	AiVectorHI,x
    105  387f		       85 f0		      sta	__ptr+1
    106  3881
    107  3881		       bd 4e f0 	      lda	AiVectorBANK,x
    108  3884		       85 8b		      sta	savedBank
    109  3886
    110  3886		       60		      rts
    111  3887
    112  3887
    113  3887							;---------------------------------------------------------------------------------------------------
    114  3887
      0  3887					      DEF	aiStartMoveGen
      1  3887				   BANK_aiStartMoveGen SET	_CURRENT_BANK
      2  3887				   aiStartMoveGen
      3  3887				   TEMPORARY_VAR SET	Overlay
      4  3887				   TEMPORARY_OFFSET SET	0
      5  3887				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      6  3887				   FUNCTION_NAME SET	aiStartMoveGen
      7  3887					      SUBROUTINE
    116  3887					      SUBROUTINE
    117  3887
      0  3887					      REFER	AiStateMachine
      1  3887				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3887				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3887					      ENDIF
      0  3887					      VEND	aiStartMoveGen
      1  3887				  -	      IFNCONST	aiStartMoveGen
      2  3887				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  3887				  -	      ERR
      4  3887					      ENDIF
      5  3887		       00 a7	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
    120  3887
    121  3887							; To assist with castling, generate the moves for the opponent, giving us effectively
    122  3887							; a list of squares that are being attacked. The castling can't happen if the king is
    123  3887							; in check or if the squares it would have to move over are in check
    124  3887
    125  3887							; we don't need to worry about this if K has moved, or relevant R has moved or if
    126  3887							; the squares between are occupied. We can tell THAT by examining the movelist to see
    127  3887							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
    128  3887
    129  3887							;inc currentPly
    130  3887							;jsr InitialiseMoveGeneration
    131  3887
      0  3887					      PHASE	AI_StepMoveGen
      1  3887		       a9 0c		      lda	#AI_StepMoveGen
      2  3889		       85 8c		      sta	aiState
    133  388b		       60		      rts
    134  388c
    135  388c
    136  388c							;---------------------------------------------------------------------------------------------------
    137  388c
      0  388c					      DEF	aiInCheckBackup
      1  388c				   BANK_aiInCheckBackup SET	_CURRENT_BANK
      2  388c				   aiInCheckBackup
      3  388c				   TEMPORARY_VAR SET	Overlay
      4  388c				   TEMPORARY_OFFSET SET	0
      5  388c				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      6  388c				   FUNCTION_NAME SET	aiInCheckBackup
      7  388c					      SUBROUTINE
    139  388c					      SUBROUTINE
    140  388c
      0  388c					      REFER	AiStateMachine
      1  388c				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  388c				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  388c					      ENDIF
      0  388c					      VEND	aiInCheckBackup
      1  388c				  -	      IFNCONST	aiInCheckBackup
      2  388c				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  388c				  -	      ERR
      4  388c					      ENDIF
      5  388c		       00 a7	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
    143  388c
    144  388c							; We're about to draw some large text on the screen
    145  388c							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
    146  388c
    147  388c		       c6 84		      dec	drawCount
    148  388e		       30 05		      bmi	.exit	; done all rows
    149  3890		       a4 84		      ldy	drawCount
    150  3892		       4c 4f fd 	      jmp	SAFE_BackupBitmaps
    151  3895
      0  3895				   .exit      PHASE	AI_InCheckDelay
      1  3895		       a9 1e		      lda	#AI_InCheckDelay
      2  3897		       85 8c		      sta	aiState
    153  3899		       60		      rts
    154  389a
    155  389a
    156  389a							;---------------------------------------------------------------------------------------------------
    157  389a
      0  389a					      DEF	aiInCheckDelay
      1  389a				   BANK_aiInCheckDelay SET	_CURRENT_BANK
      2  389a				   aiInCheckDelay
      3  389a				   TEMPORARY_VAR SET	Overlay
      4  389a				   TEMPORARY_OFFSET SET	0
      5  389a				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      6  389a				   FUNCTION_NAME SET	aiInCheckDelay
      7  389a					      SUBROUTINE
    159  389a					      SUBROUTINE
    160  389a
      0  389a					      REFER	AiStateMachine
      1  389a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  389a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  389a					      ENDIF
      0  389a					      VEND	aiInCheckDelay
      1  389a				  -	      IFNCONST	aiInCheckDelay
      2  389a				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  389a				  -	      ERR
      4  389a					      ENDIF
      5  389a		       00 a7	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
    163  389a
    164  389a		       c6 89		      dec	mdelay
    165  389c		       d0 08		      bne	.exit
    166  389e
    167  389e		       a9 00		      lda	#0
    168  38a0		       85 49		      sta	COLUBK
    169  38a2
      0  38a2					      PHASE	AI_BeginSelectMovePhase
      1  38a2		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  38a4		       85 8c		      sta	aiState
    171  38a6		       60	   .exit      rts
    172  38a7
    173  38a7
    174  38a7							;---------------------------------------------------------------------------------------------------
    175  38a7
      0  38a7					      DEF	aiBeginSelectMovePhase
      1  38a7				   BANK_aiBeginSelectMovePhase SET	_CURRENT_BANK
      2  38a7				   aiBeginSelectMovePhase
      3  38a7				   TEMPORARY_VAR SET	Overlay
      4  38a7				   TEMPORARY_OFFSET SET	0
      5  38a7				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      6  38a7				   FUNCTION_NAME SET	aiBeginSelectMovePhase
      7  38a7					      SUBROUTINE
    177  38a7					      SUBROUTINE
    178  38a7
      0  38a7					      REFER	AiStateMachine
      1  38a7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  38a7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  38a7					      ENDIF
      0  38a7					      VEND	aiBeginSelectMovePhase
      1  38a7				  -	      IFNCONST	aiBeginSelectMovePhase
      2  38a7				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  38a7				  -	      ERR
      4  38a7					      ENDIF
      5  38a7		       00 a7	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
    181  38a7
    182  38a7		       a9 02		      lda	#$2
    183  38a9		       85 46		      sta	COLUP0
    184  38ab		       a2 04		      ldx	#%100
    185  38ad		       86 4a		      stx	CTRLPF	; under
    186  38af
    187  38af		       a9 00		      lda	#0
    188  38b1		       85 89		      sta	mdelay	;?
    189  38b3		       85 8f		      sta	aiFlashPhase	; odd/even for flashing pieces
    190  38b5
    191  38b5		       a9 28		      lda	#CAP_SPEED*2
    192  38b7		       85 8d		      sta	aiFlashDelay
    193  38b9
    194  38b9		       a9 ff		      lda	#-1
    195  38bb		       85 85		      sta	fromX12
    196  38bd		       85 86		      sta	toX12
    197  38bf
      0  38bf					      PHASE	AI_FlashComputerMove
      1  38bf		       a9 00		      lda	#AI_FlashComputerMove
      2  38c1		       85 8c		      sta	aiState
    199  38c3		       60		      rts
    200  38c4
    201  38c4
    202  38c4							;---------------------------------------------------------------------------------------------------
    203  38c4
      0  38c4					      DEF	aiFlashComputerMove
      1  38c4				   BANK_aiFlashComputerMove SET	_CURRENT_BANK
      2  38c4				   aiFlashComputerMove
      3  38c4				   TEMPORARY_VAR SET	Overlay
      4  38c4				   TEMPORARY_OFFSET SET	0
      5  38c4				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      6  38c4				   FUNCTION_NAME SET	aiFlashComputerMove
      7  38c4					      SUBROUTINE
    205  38c4					      SUBROUTINE
    206  38c4
    207  38c4
    208  38c4		       a5 80		      lda	squareToDraw
    209  38c6		       30 1f		      bmi	.initial	; startup - no computer move to show
    210  38c8
    211  38c8							; "squareToDraw" is the piece that should flash while human waits
    212  38c8
    213  38c8		       ad 80 02 	      lda	SWCHA
    214  38cb		       29 f0		      and	#$F0
    215  38cd		       c9 f0		      cmp	#$F0
    216  38cf		       f0 08		      beq	.nodir
    217  38d1
    218  38d1		       a9 01		      lda	#1
    219  38d3		       85 8d		      sta	aiFlashDelay
    220  38d5		       25 8f		      and	aiFlashPhase
    221  38d7		       f0 0e		      beq	.initial
    222  38d9
    223  38d9		       c6 8d	   .nodir     dec	aiFlashDelay
    224  38db		       d0 0e		      bne	.exit	; don't flash
    225  38dd		       a9 28		      lda	#CAP_SPEED*2
    226  38df		       85 8d		      sta	aiFlashDelay
    227  38e1
    228  38e1		       e6 8f		      inc	aiFlashPhase
    229  38e3
    230  38e3		       20 ed fc 	      jsr	CopySinglePiece
    231  38e6		       60		      rts
    232  38e7
      0  38e7				   .initial   PHASE	AI_SelectStartSquare
      1  38e7		       a9 02		      lda	#AI_SelectStartSquare
      2  38e9		       85 8c		      sta	aiState
    234  38eb
    235  38eb		       60	   .exit      rts
    236  38ec
    237  38ec
    238  38ec							;---------------------------------------------------------------------------------------------------
    239  38ec
      0  38ec					      DEF	aiSelectStartSquare
      1  38ec				   BANK_aiSelectStartSquare SET	_CURRENT_BANK
      2  38ec				   aiSelectStartSquare
      3  38ec				   TEMPORARY_VAR SET	Overlay
      4  38ec				   TEMPORARY_OFFSET SET	0
      5  38ec				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      6  38ec				   FUNCTION_NAME SET	aiSelectStartSquare
      7  38ec					      SUBROUTINE
    241  38ec					      SUBROUTINE
    242  38ec
      0  38ec					      REFER	AiStateMachine
      1  38ec				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  38ec				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  38ec					      ENDIF
      0  38ec					      VEND	aiSelectStartSquare
      1  38ec				  -	      IFNCONST	aiSelectStartSquare
      2  38ec				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  38ec				  -	      ERR
      4  38ec					      ENDIF
      5  38ec		       00 a7	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    245  38ec
      0  38ec					      NEXT_RANDOM
      1  38ec		       a5 81		      lda	rnd
      2  38ee		       4a		      lsr
      3  38ef		       90 02		      bcc	.skipEOR
      4  38f1		       49 fe		      eor	#RND_EOR_VAL
      5  38f3		       85 81	   .skipEOR   sta	rnd
    247  38f5
    248  38f5		       20 55 f2 	      jsr	moveCursor
    249  38f8		       20 a1 fc 	      jsr	IsValidP_MoveFromSquare
    250  38fb
    251  38fb		       c6 8a		      dec	ccur	; pulse colour for valid squares
    252  38fd		       20 20 f1 	      jsr	setCursorColours
    253  3900
    254  3900		       98		      tya
    255  3901		       05 4c		      ora	INPT4
    256  3903		       30 04		      bmi	.exit	; illegal square or no button press
    257  3905
      0  3905					      PHASE	AI_StartSquareSelected
      1  3905		       a9 03		      lda	#AI_StartSquareSelected
      2  3907		       85 8c		      sta	aiState
    259  3909
    260  3909		       60	   .exit      rts
    261  390a
    262  390a							;---------------------------------------------------------------------------------------------------
    263  390a
      0  390a					      DEF	setCursorPriority
      1  390a				   BANK_setCursorPriority SET	_CURRENT_BANK
      2  390a				   setCursorPriority
      3  390a				   TEMPORARY_VAR SET	Overlay
      4  390a				   TEMPORARY_OFFSET SET	0
      5  390a				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      6  390a				   FUNCTION_NAME SET	setCursorPriority
      7  390a					      SUBROUTINE
    265  390a					      SUBROUTINE
    266  390a
      0  390a					      REFER	moveCursor
      1  390a					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  390a				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  390a					      ENDIF
      0  390a					      VEND	setCursorPriority
      1  390a				  -	      IFNCONST	setCursorPriority
      2  390a				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  390a				  -	      ERR
      4  390a					      ENDIF
      5  390a		       00 a8	   VAREND_setCursorPriority =	TEMPORARY_VAR
    269  390a
    270  390a		       98		      tya
    271  390b		       48		      pha
    272  390c
    273  390c		       a2 04		      ldx	#%100
    274  390e
    275  390e		       a4 88		      ldy	cursorX12
    276  3910		       30 09		      bmi	.under
    277  3912		       20 7d fc 	      jsr	GetBoard
    278  3915		       c9 00		      cmp	#0
    279  3917		       d0 02		      bne	.under
    280  3919		       a2 00		      ldx	#0
    281  391b		       86 4a	   .under     stx	CTRLPF	; UNDER
    282  391d
    283  391d		       68		      pla
    284  391e		       a8		      tay
    285  391f		       60		      rts
    286  3920
    287  3920							;---------------------------------------------------------------------------------------------------
    288  3920
      0  3920					      DEF	setCursorColours
      1  3920				   BANK_setCursorColours SET	_CURRENT_BANK
      2  3920				   setCursorColours
      3  3920				   TEMPORARY_VAR SET	Overlay
      4  3920				   TEMPORARY_OFFSET SET	0
      5  3920				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      6  3920				   FUNCTION_NAME SET	setCursorColours
      7  3920					      SUBROUTINE
    290  3920					      SUBROUTINE
    291  3920
      0  3920					      REFER	aiSelectStartSquare
      1  3920				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  3920				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  3920					      ENDIF
      0  3920					      REFER	aiDrawMoves
      1  3920				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  3920				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  3920					      ENDIF
      0  3920					      REFER	aiUnDrawTargetSquares
      1  3920				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  3920				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  3920					      ENDIF
      0  3920					      REFER	aiShowMoveCaptures
      1  3920				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  3920				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  3920					      ENDIF
      0  3920					      REFER	aiSlowFlash
      1  3920				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  3920				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  3920					      ENDIF
      0  3920					      REFER	aiSelectDestinationSquare
      1  3920				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  3920				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  3920					      ENDIF
      0  3920					      VEND	setCursorColours
      1  3920				  -	      IFNCONST	setCursorColours
      2  3920				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  3920				  -	      ERR
      4  3920					      ENDIF
      5  3920		       00 a7	   VAREND_setCursorColours =	TEMPORARY_VAR
    299  3920
    300  3920							; pass y=-1 if move is NOT in the movelist
    301  3920							; preserve y
    302  3920
    303  3920		       a9 44		      lda	#$44
    304  3922
    305  3922		       c0 ff		      cpy	#-1
    306  3924		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    307  3926
    308  3926		       a5 8a		      lda	ccur
    309  3928		       4a		      lsr
    310  3929		       4a		      lsr
    311  392a		       4a		      lsr
    312  392b		       29 03		      and	#3
    313  392d		       18		      clc
    314  392e		       69 c0		      adc	#$C0	;COLOUR_LINE_1
    315  3930
    316  3930		       85 46	   .writeCursorCol sta	COLUP0
    317  3932		       60		      rts
    318  3933
    319  3933
    320  3933							;---------------------------------------------------------------------------------------------------
    321  3933
    322  3933							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    323  3933							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    324  3933
      0  3933					      ALLOCATE	JoyCombined, 16
      0  3933					      OPTIONAL_PAGEBREAK	"Table", 16
     12  3933					      LIST	ON
      0  3933					      DEF	JoyCombined
      1  3933				   BANK_JoyCombined SET	_CURRENT_BANK
      2  3933				   JoyCombined
      3  3933				   TEMPORARY_VAR SET	Overlay
      4  3933				   TEMPORARY_OFFSET SET	0
      5  3933				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      6  3933				   FUNCTION_NAME SET	JoyCombined
      7  3933					      SUBROUTINE
    326  3933		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    327  3943
      0  3943					      ALLOCATE	JoyMoveCursor, 16
      0  3943					      OPTIONAL_PAGEBREAK	"Table", 16
     12  3943					      LIST	ON
      0  3943					      DEF	JoyMoveCursor
      1  3943				   BANK_JoyMoveCursor SET	_CURRENT_BANK
      2  3943				   JoyMoveCursor
      3  3943				   TEMPORARY_VAR SET	Overlay
      4  3943				   TEMPORARY_OFFSET SET	0
      5  3943				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      6  3943				   FUNCTION_NAME SET	JoyMoveCursor
      7  3943					      SUBROUTINE
    329  3943		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    330  3953
    331  3953
    332  3953							;---------------------------------------------------------------------------------------------------
    333  3953
      0  3953					      DEF	aiStartSquareSelected
      1  3953				   BANK_aiStartSquareSelected SET	_CURRENT_BANK
      2  3953				   aiStartSquareSelected
      3  3953				   TEMPORARY_VAR SET	Overlay
      4  3953				   TEMPORARY_OFFSET SET	0
      5  3953				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      6  3953				   FUNCTION_NAME SET	aiStartSquareSelected
      7  3953					      SUBROUTINE
    335  3953					      SUBROUTINE
    336  3953
      0  3953					      REFER	AiStateMachine
      1  3953				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3953				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3953					      ENDIF
      0  3953					      VEND	aiStartSquareSelected
      1  3953				  -	      IFNCONST	aiStartSquareSelected
      2  3953				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  3953				  -	      ERR
      4  3953					      ENDIF
      5  3953		       00 a7	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    339  3953
    340  3953
    341  3953							; Mark all the valid moves for the selected piece on the board
    342  3953							; and then start pulsing the piece
    343  3953							; AND start choosing for selection of TO square
    344  3953
    345  3953							; Iterate the movelist and for all from squares which = drawPieceNumber
    346  3953							; then draw a BLANK at that square
    347  3953							; do 1 by one, when none found then increment state
    348  3953
    349  3953		       a5 88		      lda	cursorX12
    350  3955		       85 80		      sta	squareToDraw
    351  3957
    352  3957		       a9 0a		      lda	#10
    353  3959		       85 8d		      sta	aiFlashDelay
    354  395b
    355  395b		       a9 00		      lda	#0
    356  395d		       85 86		      sta	toX12	;aiToSquareX12
    357  395f		       85 8f		      sta	aiFlashPhase	; for debounce exit timing
    358  3961
    359  3961		       a9 ff		      lda	#-1
    360  3963		       85 8e		      sta	aiMoveIndex
    361  3965
    362  3965		       a9 28		      lda	#HOLD_DELAY
    363  3967		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    364  3969
      0  3969					      PHASE	AI_DrawMoves
      1  3969		       a9 04		      lda	#AI_DrawMoves
      2  396b		       85 8c		      sta	aiState
    366  396d		       60		      rts
    367  396e
    368  396e
    369  396e							;---------------------------------------------------------------------------------------------------
    370  396e
      0  396e					      DEF	aiDrawMoves
      1  396e				   BANK_aiDrawMoves SET	_CURRENT_BANK
      2  396e				   aiDrawMoves
      3  396e				   TEMPORARY_VAR SET	Overlay
      4  396e				   TEMPORARY_OFFSET SET	0
      5  396e				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      6  396e				   FUNCTION_NAME SET	aiDrawMoves
      7  396e					      SUBROUTINE
    372  396e					      SUBROUTINE
    373  396e
      0  396e					      REFER	AiStateMachine
      1  396e				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  396e				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  396e					      ENDIF
      0  396e					      VEND	aiDrawMoves
      1  396e				  -	      IFNCONST	aiDrawMoves
      2  396e				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  396e				  -	      ERR
      4  396e					      ENDIF
      5  396e		       00 a7	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    376  396e
    377  396e		       c6 8a		      dec	ccur
    378  3970		       20 20 f1 	      jsr	setCursorColours
    379  3973
    380  3973		       c6 89		      dec	mdelay
    381  3975		       d0 21		      bne	.exit
    382  3977		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    383  3979		       85 89		      sta	mdelay	; once triggered, runs always
    384  397b
    385  397b		       a5 8e		      lda	aiMoveIndex
    386  397d		       10 05		      bpl	.valid
    387  397f		       20 29 fd 	      jsr	SAFE_getMoveIndex
    388  3982		       85 8e		      sta	aiMoveIndex
    389  3984				   .valid
    390  3984
    391  3984		       20 a5 f1 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    392  3987		       a5 8e		      lda	aiMoveIndex
    393  3989		       10 19		      bpl	.unsure	; still drawing in this phase
    394  398b
    395  398b		       a9 14		      lda	#CAP_SPEED
    396  398d		       85 89		      sta	mdelay
    397  398f
    398  398f		       a9 00		      lda	#0
    399  3991		       85 8f		      sta	aiFlashPhase	; controls odd/even exit of flashing
    400  3993
      0  3993					      PHASE	AI_ShowMoveCaptures
      1  3993		       a9 05		      lda	#AI_ShowMoveCaptures
      2  3995		       85 8c		      sta	aiState
    402  3997		       60		      rts
    403  3998
    404  3998				   .exit
    405  3998
    406  3998							; Initial piece selection has happened, but the button hasn't been released yet
    407  3998							; AND we're still in the waiting phase to see if the button was held long enough for move show
    408  3998
    409  3998		       a5 4c		      lda	INPT4
    410  399a		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    411  399c
    412  399c							; Aha! Button released, so we know the selected piece and can start flashing it
    413  399c							; and allowing movement of the selector to a destination square...
    414  399c
    415  399c		       a9 18		      lda	#6*4
    416  399e		       85 8a		      sta	ccur	; bright green square for selection
    417  39a0
      0  39a0					      PHASE	AI_SelectDestinationSquare
      1  39a0		       a9 08		      lda	#AI_SelectDestinationSquare
      2  39a2		       85 8c		      sta	aiState
    419  39a4
    420  39a4		       60	   .unsure    rts
    421  39a5
    422  39a5
    423  39a5							;---------------------------------------------------------------------------------------------------
    424  39a5
      0  39a5					      DEF	SAFE_showMoveOptions
      1  39a5				   BANK_SAFE_showMoveOptions SET	_CURRENT_BANK
      2  39a5				   SAFE_showMoveOptions
      3  39a5				   TEMPORARY_VAR SET	Overlay
      4  39a5				   TEMPORARY_OFFSET SET	0
      5  39a5				   VAR_BOUNDARY_SAFE_showMoveOptions SET	TEMPORARY_OFFSET
      6  39a5				   FUNCTION_NAME SET	SAFE_showMoveOptions
      7  39a5					      SUBROUTINE
    426  39a5					      SUBROUTINE
    427  39a5
      0  39a5					      REFER	aiDrawMoves
      1  39a5				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  39a5				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  39a5					      ENDIF
      0  39a5					      REFER	aiUnDrawTargetSquares
      1  39a5				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  39a5				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  39a5					      ENDIF
      0  39a5					      VAR	__saveIdx, 1
      1  39a5		       00 a7	   __saveIdx  =	TEMPORARY_VAR
      2  39a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  39a5
      4  39a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  39a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  39a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  39a5					      ENDIF
      8  39a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  39a5				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  39a5				  -	      ERR
     11  39a5					      ENDIF
     12  39a5					      LIST	ON
      0  39a5					      VAR	__piece, 1
      1  39a5		       00 a8	   __piece    =	TEMPORARY_VAR
      2  39a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  39a5
      4  39a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  39a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  39a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  39a5					      ENDIF
      8  39a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  39a5				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  39a5				  -	      ERR
     11  39a5					      ENDIF
     12  39a5					      LIST	ON
      0  39a5					      VEND	SAFE_showMoveOptions
      1  39a5				  -	      IFNCONST	SAFE_showMoveOptions
      2  39a5				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveOptions
      3  39a5				  -	      ERR
      4  39a5					      ENDIF
      5  39a5		       00 a9	   VAREND_SAFE_showMoveOptions =	TEMPORARY_VAR
    433  39a5
    434  39a5							; place a marker on the board for any square matching the piece
    435  39a5							; EXCEPT for squares which are occupied (we'll flash those later)
    436  39a5
    437  39a5		       a6 8e	   .next      ldx	aiMoveIndex
    438  39a7		       86 a7		      stx	__saveIdx
    439  39a9		       30 40		      bmi	.skip
    440  39ab
    441  39ab		       ad 84 02 	      lda	INTIM
    442  39ae		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    443  39b0		       90 39		      bcc	.skip
    444  39b2
    445  39b2		       c6 8e		      dec	aiMoveIndex
    446  39b4
    447  39b4		       20 65 fd 	      jsr	GetP_MoveFrom
    448  39b7		       c5 85		      cmp	fromX12
    449  39b9		       d0 ea		      bne	.next
    450  39bb
    451  39bb		       20 71 fd 	      jsr	GetP_MoveTo
    452  39be		       85 80		      sta	squareToDraw
    453  39c0
    454  39c0		       20 7d fd 	      jsr	GetP_MovePiece
    455  39c3		       85 a8		      sta	__piece
    456  39c5
    457  39c5							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    458  39c5							; TODO this could/will fail on sorted lists. MMh.
    459  39c5
    460  39c5		       ca	   .sk	      dex
    461  39c6		       30 16		      bmi	.prom
    462  39c8		       20 71 fd 	      jsr	GetP_MoveTo
    463  39cb		       c5 80		      cmp	squareToDraw
    464  39cd		       d0 0f		      bne	.prom
    465  39cf		       20 7d fd 	      jsr	GetP_MovePiece
    466  39d2		       45 a8		      eor	__piece
    467  39d4		       29 0f		      and	#PIECE_MASK
    468  39d6		       f0 06		      beq	.prom	; same piece type so not a promote
    469  39d8
    470  39d8		       c6 8e		      dec	aiMoveIndex
    471  39da		       c6 8e		      dec	aiMoveIndex
    472  39dc		       c6 8e		      dec	aiMoveIndex
    473  39de				   .prom
    474  39de
    475  39de		       a4 80		      ldy	squareToDraw
    476  39e0		       20 7d fc 	      jsr	GetBoard
    477  39e3		       29 0f		      and	#PIECE_MASK
    478  39e5		       d0 be		      bne	.next	; don't draw dots on captures - they are flashed later
    479  39e7
    480  39e7
    481  39e7							;lda INTIM
    482  39e7							;cmp #SPEEDOF_COPYSINGLEPIECE
    483  39e7							;bcc .skip
    484  39e7
    485  39e7							;lda aiMoveIndex
    486  39e7							;sta __saveIdx
    487  39e7
    488  39e7		       20 35 fd 	      jsr	markerDraw
    489  39ea		       60		      rts
    490  39eb
    491  39eb		       a5 a7	   .skip      lda	__saveIdx
    492  39ed		       85 8e		      sta	aiMoveIndex
    493  39ef		       60		      rts
    494  39f0
    495  39f0
    496  39f0							;---------------------------------------------------------------------------------------------------
    497  39f0
      0  39f0					      DEF	aiUnDrawTargetSquares
      1  39f0				   BANK_aiUnDrawTargetSquares SET	_CURRENT_BANK
      2  39f0				   aiUnDrawTargetSquares
      3  39f0				   TEMPORARY_VAR SET	Overlay
      4  39f0				   TEMPORARY_OFFSET SET	0
      5  39f0				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      6  39f0				   FUNCTION_NAME SET	aiUnDrawTargetSquares
      7  39f0					      SUBROUTINE
    499  39f0					      SUBROUTINE
    500  39f0
      0  39f0					      REFER	AiStateMachine
      1  39f0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  39f0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  39f0					      ENDIF
      0  39f0					      VEND	aiUnDrawTargetSquares
      1  39f0				  -	      IFNCONST	aiUnDrawTargetSquares
      2  39f0				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  39f0				  -	      ERR
      4  39f0					      ENDIF
      5  39f0		       00 a7	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    503  39f0
    504  39f0
    505  39f0		       c6 8a		      dec	ccur
    506  39f2		       20 20 f1 	      jsr	setCursorColours
    507  39f5
    508  39f5		       c6 89		      dec	mdelay
    509  39f7		       d0 18		      bne	.exit
    510  39f9		       a9 01		      lda	#1
    511  39fb		       85 89		      sta	mdelay	; once triggered, runs always
    512  39fd
    513  39fd		       a5 8e		      lda	aiMoveIndex
    514  39ff		       10 05		      bpl	.valid
    515  3a01		       20 29 fd 	      jsr	SAFE_getMoveIndex
    516  3a04		       85 8e		      sta	aiMoveIndex
    517  3a06				   .valid
    518  3a06
    519  3a06		       20 a5 f1 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    520  3a09		       a5 8e		      lda	aiMoveIndex
    521  3a0b		       10 04		      bpl	.exit	; still drawing in this phase
    522  3a0d
      0  3a0d					      PHASE	AI_SelectStartSquare
      1  3a0d		       a9 02		      lda	#AI_SelectStartSquare
      2  3a0f		       85 8c		      sta	aiState
    524  3a11
    525  3a11		       60	   .exit      rts
    526  3a12
    527  3a12
    528  3a12							;---------------------------------------------------------------------------------------------------
    529  3a12
    530  3a12
      0  3a12					      DEF	aiShowMoveCaptures
      1  3a12				   BANK_aiShowMoveCaptures SET	_CURRENT_BANK
      2  3a12				   aiShowMoveCaptures
      3  3a12				   TEMPORARY_VAR SET	Overlay
      4  3a12				   TEMPORARY_OFFSET SET	0
      5  3a12				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      6  3a12				   FUNCTION_NAME SET	aiShowMoveCaptures
      7  3a12					      SUBROUTINE
    532  3a12					      SUBROUTINE
    533  3a12
      0  3a12					      REFER	AiStateMachine
      1  3a12				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3a12				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3a12					      ENDIF
      0  3a12					      VEND	aiShowMoveCaptures
      1  3a12				  -	      IFNCONST	aiShowMoveCaptures
      2  3a12				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  3a12				  -	      ERR
      4  3a12					      ENDIF
      5  3a12		       00 a7	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    536  3a12
    537  3a12							; draw/undraw ALL captured pieces
    538  3a12							; we should do this an even number of times so that pieces don't disappEOR
    539  3a12
    540  3a12		       c6 8a		      dec	ccur
    541  3a14		       20 20 f1 	      jsr	setCursorColours
    542  3a17
    543  3a17		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    544  3a19
    545  3a19		       a5 8e		      lda	aiMoveIndex
    546  3a1b		       10 05		      bpl	.valid	; guaranteed -1 on 1st call
    547  3a1d		       20 29 fd 	      jsr	SAFE_getMoveIndex
    548  3a20		       85 8e		      sta	aiMoveIndex
    549  3a22				   .valid
    550  3a22
    551  3a22		       20 59 fd 	      jsr	SAFE_showMoveCaptures
    552  3a25		       a5 8e		      lda	aiMoveIndex
    553  3a27		       10 06		      bpl	.exit
    554  3a29
    555  3a29		       e6 8f		      inc	aiFlashPhase
    556  3a2b
      0  3a2b					      PHASE	AI_SlowFlash
      1  3a2b		       a9 06		      lda	#AI_SlowFlash
      2  3a2d		       85 8c		      sta	aiState
    558  3a2f
    559  3a2f		       60	   .exit      rts
    560  3a30
    561  3a30
    562  3a30							;---------------------------------------------------------------------------------------------------
    563  3a30
      0  3a30					      DEF	aiSlowFlash
      1  3a30				   BANK_aiSlowFlash SET	_CURRENT_BANK
      2  3a30				   aiSlowFlash
      3  3a30				   TEMPORARY_VAR SET	Overlay
      4  3a30				   TEMPORARY_OFFSET SET	0
      5  3a30				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      6  3a30				   FUNCTION_NAME SET	aiSlowFlash
      7  3a30					      SUBROUTINE
    565  3a30					      SUBROUTINE
    566  3a30
      0  3a30					      REFER	AiStateMachine
      1  3a30				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3a30				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3a30					      ENDIF
      0  3a30					      VEND	aiSlowFlash
      1  3a30				  -	      IFNCONST	aiSlowFlash
      2  3a30				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  3a30				  -	      ERR
      4  3a30					      ENDIF
      5  3a30		       00 a7	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    569  3a30
    570  3a30							; Joystick button is held down, so we're displaying the available moves
    571  3a30							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    572  3a30
    573  3a30		       c6 8a		      dec	ccur
    574  3a32		       20 20 f1 	      jsr	setCursorColours
    575  3a35
    576  3a35		       a5 8f		      lda	aiFlashPhase
    577  3a37		       29 01		      and	#1
    578  3a39		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    579  3a3b
    580  3a3b		       a5 4c		      lda	INPT4
    581  3a3d		       30 0d		      bmi	.butpress	; exit on button release
    582  3a3f
    583  3a3f				   .notEven
    584  3a3f
    585  3a3f							; Wait for delay to expire then back and flash 'em again
    586  3a3f
    587  3a3f		       c6 89		      dec	mdelay
    588  3a41		       10 08		      bpl	.slowWait
    589  3a43
    590  3a43		       a9 14		      lda	#CAP_SPEED
    591  3a45		       85 89		      sta	mdelay
    592  3a47
      0  3a47					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  3a47		       a9 05		      lda	#AI_ShowMoveCaptures
      2  3a49		       85 8c		      sta	aiState
    594  3a4b
    595  3a4b		       60	   .slowWait  rts
    596  3a4c
    597  3a4c
    598  3a4c		       a9 01	   .butpress  lda	#1
    599  3a4e		       85 89		      sta	mdelay
    600  3a50
      0  3a50					      PHASE	AI_UnDrawTargetSquares
      1  3a50		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  3a52		       85 8c		      sta	aiState
    602  3a54		       60		      rts
    603  3a55
    604  3a55
    605  3a55							;---------------------------------------------------------------------------------------------------
    606  3a55
      0  3a55					      DEF	moveCursor
      1  3a55				   BANK_moveCursor SET	_CURRENT_BANK
      2  3a55				   moveCursor
      3  3a55				   TEMPORARY_VAR SET	Overlay
      4  3a55				   TEMPORARY_OFFSET SET	0
      5  3a55				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      6  3a55				   FUNCTION_NAME SET	moveCursor
      7  3a55					      SUBROUTINE
    608  3a55					      SUBROUTINE
    609  3a55
      0  3a55					      REFER	aiSelectStartSquare
      1  3a55				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  3a55				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  3a55					      ENDIF
      0  3a55					      REFER	aiSelectDestinationSquare
      1  3a55				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  3a55				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  3a55					      ENDIF
      0  3a55					      VAR	__newCursor, 1
      1  3a55		       00 a7	   __newCursor =	TEMPORARY_VAR
      2  3a55				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3a55
      4  3a55				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3a55				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3a55				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3a55					      ENDIF
      8  3a55				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3a55				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  3a55				  -	      ERR
     11  3a55					      ENDIF
     12  3a55					      LIST	ON
      0  3a55					      VEND	moveCursor
      1  3a55				  -	      IFNCONST	moveCursor
      2  3a55				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  3a55				  -	      ERR
      4  3a55					      ENDIF
      5  3a55		       00 a8	   VAREND_moveCursor =	TEMPORARY_VAR
    614  3a55
    615  3a55							; Part (a) move cursor around the board waiting for joystick press
    616  3a55
    617  3a55
    618  3a55		       ad 80 02 	      lda	SWCHA
    619  3a58		       4a		      lsr
    620  3a59		       4a		      lsr
    621  3a5a		       4a		      lsr
    622  3a5b		       4a		      lsr
    623  3a5c		       a8		      tay
    624  3a5d
    625  3a5d		       c9 0f		      cmp	#15
    626  3a5f		       f0 20		      beq	.cursor	; nothing pressed - skip delays
    627  3a61
    628  3a61		       c6 89		      dec	mdelay
    629  3a63		       10 23		      bpl	.delaym
    630  3a65
    631  3a65		       18		      clc
    632  3a66		       a5 88		      lda	cursorX12
    633  3a68		       79 43 f1 	      adc	JoyMoveCursor,y
    634  3a6b		       85 a7		      sta	__newCursor
    635  3a6d		       a8		      tay
    636  3a6e		       20 71 fc 	      jsr	GetValid
    637  3a71		       c9 ff		      cmp	#-1
    638  3a73		       f0 04		      beq	.invalid
    639  3a75		       a5 a7		      lda	__newCursor
    640  3a77		       85 88		      sta	cursorX12
    641  3a79				   .invalid
    642  3a79
    643  3a79		       a9 10		      lda	#CURSOR_MOVE_SPEED
    644  3a7b		       85 89		      sta	mdelay
    645  3a7d		       20 0a f1 	      jsr	setCursorPriority
    646  3a80		       60		      rts
    647  3a81
    648  3a81
    649  3a81		       a9 00	   .cursor    lda	#0
    650  3a83		       85 89		      sta	mdelay
    651  3a85		       20 0a f1 	      jsr	setCursorPriority
    652  3a88
    653  3a88		       60	   .delaym    rts
    654  3a89
    655  3a89
    656  3a89							;---------------------------------------------------------------------------------------------------
    657  3a89
      0  3a89					      DEF	aiSelectDestinationSquare
      1  3a89				   BANK_aiSelectDestinationSquare SET	_CURRENT_BANK
      2  3a89				   aiSelectDestinationSquare
      3  3a89				   TEMPORARY_VAR SET	Overlay
      4  3a89				   TEMPORARY_OFFSET SET	0
      5  3a89				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      6  3a89				   FUNCTION_NAME SET	aiSelectDestinationSquare
      7  3a89					      SUBROUTINE
    659  3a89					      SUBROUTINE
    660  3a89
      0  3a89					      REFER	AiStateMachine
      1  3a89				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3a89				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3a89					      ENDIF
      0  3a89					      VEND	aiSelectDestinationSquare
      1  3a89				  -	      IFNCONST	aiSelectDestinationSquare
      2  3a89				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  3a89				  -	      ERR
      4  3a89					      ENDIF
      5  3a89		       00 a7	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    663  3a89
    664  3a89							; Piece is selected and now we're looking for a button press on a destination square
    665  3a89							; we flash the piece on-and-off while we're doing that
    666  3a89							; Flash the selected piece
    667  3a89
    668  3a89		       ad 84 02 	      lda	INTIM
    669  3a8c		       c9 28		      cmp	#ONCEPERFRAME
    670  3a8e		       90 0e		      bcc	.exit
    671  3a90
    672  3a90
    673  3a90		       c6 8d		      dec	aiFlashDelay
    674  3a92		       d0 0a		      bne	.exit	; don't flash
    675  3a94		       a9 14		      lda	#CAP_SPEED
    676  3a96		       85 8d		      sta	aiFlashDelay
    677  3a98
    678  3a98		       e6 8f		      inc	aiFlashPhase
    679  3a9a
    680  3a9a		       20 ed fc 	      jsr	CopySinglePiece
    681  3a9d		       60		      rts
    682  3a9e
    683  3a9e				   .exit
    684  3a9e		       20 55 f2 	      jsr	moveCursor
    685  3aa1
    686  3aa1		       ad 84 02 	      lda	INTIM
    687  3aa4		       c9 14		      cmp	#20
    688  3aa6		       90 35		      bcc	.noButton
    689  3aa8
    690  3aa8
    691  3aa8		       a4 88		      ldy	cursorX12
    692  3aaa		       84 86		      sty	toX12
    693  3aac
    694  3aac		       20 b1 fc 	      jsr	GetPiece
    695  3aaf		       20 20 f1 	      jsr	setCursorColours
    696  3ab2
    697  3ab2
    698  3ab2							; y = valid square
    699  3ab2
    700  3ab2		       a5 4c		      lda	INPT4
    701  3ab4		       30 27		      bmi	.noButton
    702  3ab6
    703  3ab6		       a5 86		      lda	toX12
    704  3ab8		       c5 85		      cmp	fromX12
    705  3aba		       f0 0d		      beq	.cancel
    706  3abc
    707  3abc		       c0 ff		      cpy	#-1
    708  3abe		       f0 1d		      beq	.noButton	; not a valid square
    709  3ac0
    710  3ac0		       a5 8f		      lda	aiFlashPhase
    711  3ac2		       29 01		      and	#1
    712  3ac4		       f0 13		      beq	.done
    713  3ac6		       85 8d		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    714  3ac8		       60		      rts
    715  3ac9
    716  3ac9				   .cancel
    717  3ac9
    718  3ac9		       a5 8f		      lda	aiFlashPhase
    719  3acb		       29 01		      and	#1
    720  3acd		       f0 05		      beq	.doCancel
    721  3acf
    722  3acf							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    723  3acf
    724  3acf		       a9 01		      lda	#1
    725  3ad1		       85 8d		      sta	aiFlashDelay
    726  3ad3		       60		      rts
    727  3ad4
    728  3ad4
      0  3ad4				   .doCancel  PHASE	AI_ReselectDebounce
      1  3ad4		       a9 0a		      lda	#AI_ReselectDebounce
      2  3ad6		       85 8c		      sta	aiState
    730  3ad8		       60		      rts
    731  3ad9
      0  3ad9				   .done      PHASE	AI_Quiescent	; destination selected!
      1  3ad9		       a9 09		      lda	#AI_Quiescent
      2  3adb		       85 8c		      sta	aiState
    733  3add		       60	   .noButton  rts
    734  3ade
    735  3ade
    736  3ade							;---------------------------------------------------------------------------------------------------
    737  3ade
      0  3ade					      DEF	aiReselectDebounce
      1  3ade				   BANK_aiReselectDebounce SET	_CURRENT_BANK
      2  3ade				   aiReselectDebounce
      3  3ade				   TEMPORARY_VAR SET	Overlay
      4  3ade				   TEMPORARY_OFFSET SET	0
      5  3ade				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      6  3ade				   FUNCTION_NAME SET	aiReselectDebounce
      7  3ade					      SUBROUTINE
    739  3ade					      SUBROUTINE
    740  3ade
      0  3ade					      REFER	AiStateMachine
      1  3ade				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3ade				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3ade					      ENDIF
      0  3ade					      VEND	aiReselectDebounce
      1  3ade				  -	      IFNCONST	aiReselectDebounce
      2  3ade				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  3ade				  -	      ERR
      4  3ade					      ENDIF
      5  3ade		       00 a7	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    743  3ade
    744  3ade							; We've just cancelled the move. Wait for the button to be released
    745  3ade							; and then go back to selecting a piece to move
    746  3ade
    747  3ade		       a5 4c		      lda	INPT4
    748  3ae0		       10 04		      bpl	.exit	; button still pressed, so wait
    749  3ae2
      0  3ae2					      PHASE	AI_SelectStartSquare
      1  3ae2		       a9 02		      lda	#AI_SelectStartSquare
      2  3ae4		       85 8c		      sta	aiState
    751  3ae6		       60	   .exit      rts
    752  3ae7
    753  3ae7
    754  3ae7							;---------------------------------------------------------------------------------------------------
    755  3ae7
      0  3ae7					      DEF	aiQuiescent
      1  3ae7				   BANK_aiQuiescent SET	_CURRENT_BANK
      2  3ae7				   aiQuiescent
      3  3ae7				   TEMPORARY_VAR SET	Overlay
      4  3ae7				   TEMPORARY_OFFSET SET	0
      5  3ae7				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      6  3ae7				   FUNCTION_NAME SET	aiQuiescent
      7  3ae7					      SUBROUTINE
    757  3ae7					      SUBROUTINE
    758  3ae7
      0  3ae7					      REFER	AiStateMachine
      1  3ae7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3ae7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3ae7					      ENDIF
      0  3ae7					      VEND	aiQuiescent
      1  3ae7				  -	      IFNCONST	aiQuiescent
      2  3ae7				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  3ae7				  -	      ERR
      4  3ae7					      ENDIF
      5  3ae7		       00 a7	   VAREND_aiQuiescent =	TEMPORARY_VAR
    761  3ae7
    762  3ae7							; Move has been selected
    763  3ae7
    764  3ae7		       a9 ff		      lda	#-1
    765  3ae9		       85 88		      sta	cursorX12
    766  3aeb
    767  3aeb		       a5 85		      lda	fromX12
    768  3aed		       85 87		      sta	originX12
    769  3aef		       20 b1 fc 	      jsr	GetPiece	; from the movelist
    770  3af2
    771  3af2		       a4 85		      ldy	fromX12
    772  3af4		       20 7d fc 	      jsr	GetBoard	; get the piece from the board itself
    773  3af7
    774  3af7		       45 98		      eor	fromPiece
    775  3af9		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    776  3afb		       d0 05		      bne	.promote	; promote a pawn
    777  3afd
      0  3afd					      PHASE	AI_MoveIsSelected
      1  3afd		       a9 14		      lda	#AI_MoveIsSelected
      2  3aff		       85 8c		      sta	aiState
    779  3b01		       60		      rts
    780  3b02
      0  3b02				   .promote   PHASE	AI_PromotePawnStart
      1  3b02		       a9 1f		      lda	#AI_PromotePawnStart
      2  3b04		       85 8c		      sta	aiState
    782  3b06		       60		      rts
    783  3b07
    784  3b07
    785  3b07							;---------------------------------------------------------------------------------------------------
    786  3b07
      0  3b07					      DEF	aiPromotePawnStart
      1  3b07				   BANK_aiPromotePawnStart SET	_CURRENT_BANK
      2  3b07				   aiPromotePawnStart
      3  3b07				   TEMPORARY_VAR SET	Overlay
      4  3b07				   TEMPORARY_OFFSET SET	0
      5  3b07				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      6  3b07				   FUNCTION_NAME SET	aiPromotePawnStart
      7  3b07					      SUBROUTINE
    788  3b07					      SUBROUTINE
    789  3b07
      0  3b07					      REFER	AiStateMachine
      1  3b07				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3b07				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3b07					      ENDIF
      0  3b07					      VEND	aiPromotePawnStart
      1  3b07				  -	      IFNCONST	aiPromotePawnStart
      2  3b07				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  3b07				  -	      ERR
      4  3b07					      ENDIF
      5  3b07		       00 a7	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    792  3b07
    793  3b07
    794  3b07		       ad 84 02 	      lda	INTIM
    795  3b0a		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    796  3b0c		       90 18		      bcc	.exit
    797  3b0e
    798  3b0e		       a9 00		      lda	#0
    799  3b10		       85 8f		      sta	aiFlashPhase
    800  3b12		       85 8d		      sta	aiFlashDelay
    801  3b14
    802  3b14		       a4 86		      ldy	toX12
    803  3b16		       84 80		      sty	squareToDraw
    804  3b18
    805  3b18		       20 7d fc 	      jsr	GetBoard
    806  3b1b		       29 0f		      and	#PIECE_MASK
    807  3b1d		       f0 03		      beq	.empty
    808  3b1f
    809  3b1f		       20 ed fc 	      jsr	CopySinglePiece	; remove any capturable piece for display purposes
    810  3b22
      0  3b22				   .empty     PHASE	AI_RollPromotionPiece
      1  3b22		       a9 20		      lda	#AI_RollPromotionPiece
      2  3b24		       85 8c		      sta	aiState
    812  3b26		       60	   .exit      rts
    813  3b27
    814  3b27
    815  3b27							;---------------------------------------------------------------------------------------------------
    816  3b27
      0  3b27					      DEF	aiRollPromotionPiece
      1  3b27				   BANK_aiRollPromotionPiece SET	_CURRENT_BANK
      2  3b27				   aiRollPromotionPiece
      3  3b27				   TEMPORARY_VAR SET	Overlay
      4  3b27				   TEMPORARY_OFFSET SET	0
      5  3b27				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      6  3b27				   FUNCTION_NAME SET	aiRollPromotionPiece
      7  3b27					      SUBROUTINE
    818  3b27					      SUBROUTINE
    819  3b27
      0  3b27					      REFER	AiStateMachine
      1  3b27				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3b27				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3b27					      ENDIF
      0  3b27					      VEND	aiRollPromotionPiece
      1  3b27				  -	      IFNCONST	aiRollPromotionPiece
      2  3b27				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  3b27				  -	      ERR
      4  3b27					      ENDIF
      5  3b27		       00 a7	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    822  3b27
    823  3b27							; Flash the '?' and wait for an UDLR move
    824  3b27
    825  3b27		       ad 84 02 	      lda	INTIM
    826  3b2a		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    827  3b2c		       90 28		      bcc	.exit
    828  3b2e
    829  3b2e		       ad 80 02 	      lda	SWCHA
    830  3b31		       29 f0		      and	#$F0
    831  3b33		       c9 f0		      cmp	#$F0
    832  3b35		       f0 0a		      beq	.nojoy
    833  3b37
    834  3b37		       a9 00		      lda	#0
    835  3b39		       85 8d		      sta	aiFlashDelay
    836  3b3b
    837  3b3b		       a5 8f		      lda	aiFlashPhase
    838  3b3d		       29 01		      and	#1
    839  3b3f		       f0 16		      beq	.even
    840  3b41
    841  3b41		       c6 8d	   .nojoy     dec	aiFlashDelay
    842  3b43		       10 11		      bpl	.exit
    843  3b45
    844  3b45		       a9 0a		      lda	#10
    845  3b47		       85 8d		      sta	aiFlashDelay
    846  3b49
    847  3b49		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    848  3b4b		       a5 97		      lda	sideToMove
    849  3b4d		       10 02		      bpl	.wtm
    850  3b4f		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    851  3b51				   .wtm
    852  3b51		       20 41 fd 	      jsr	showPromoteOptions
    853  3b54
    854  3b54		       e6 8f		      inc	aiFlashPhase
    855  3b56
    856  3b56		       60	   .exit      rts
    857  3b57
    858  3b57
    859  3b57		       a9 03	   .even      lda	#3	; QUEEN
    860  3b59		       85 98		      sta	fromPiece	; cycles as index to NBRQ
    861  3b5b
    862  3b5b		       e6 8f		      inc	aiFlashPhase
    863  3b5d
    864  3b5d
    865  3b5d		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    866  3b5f		       a5 97		      lda	sideToMove
    867  3b61		       10 02		      bpl	.whiteToMove
    868  3b63		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    869  3b65				   .whiteToMove
    870  3b65
    871  3b65		       20 41 fd 	      jsr	showPromoteOptions
    872  3b68
      0  3b68					      PHASE	AI_ChooseDebounce
      1  3b68		       a9 22		      lda	#AI_ChooseDebounce
      2  3b6a		       85 8c		      sta	aiState
    874  3b6c		       60		      rts
    875  3b6d
    876  3b6d
    877  3b6d							;---------------------------------------------------------------------------------------------------
    878  3b6d
      0  3b6d					      DEF	aiChoosePromotePiece
      1  3b6d				   BANK_aiChoosePromotePiece SET	_CURRENT_BANK
      2  3b6d				   aiChoosePromotePiece
      3  3b6d				   TEMPORARY_VAR SET	Overlay
      4  3b6d				   TEMPORARY_OFFSET SET	0
      5  3b6d				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      6  3b6d				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  3b6d					      SUBROUTINE
    880  3b6d					      SUBROUTINE
    881  3b6d
      0  3b6d					      REFER	AiStateMachine
      1  3b6d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3b6d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3b6d					      ENDIF
      0  3b6d					      VEND	aiChoosePromotePiece
      1  3b6d				  -	      IFNCONST	aiChoosePromotePiece
      2  3b6d				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  3b6d				  -	      ERR
      4  3b6d					      ENDIF
      5  3b6d		       00 a7	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
    884  3b6d
    885  3b6d							; Question-mark phase has exited via joystick direction
    886  3b6d							; Now we cycle through the selectable pieces
    887  3b6d
    888  3b6d		       ad 84 02 	      lda	INTIM
    889  3b70		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    890  3b72		       90 40		      bcc	.exit
    891  3b74
    892  3b74		       a5 4c		      lda	INPT4
    893  3b76		       30 0a		      bmi	.nobut	; no press
    894  3b78
    895  3b78							; button pressed but make sure phase is correct for exit
    896  3b78
    897  3b78		       a9 00		      lda	#0
    898  3b7a		       85 8d		      sta	aiFlashDelay
    899  3b7c
    900  3b7c		       a5 8f		      lda	aiFlashPhase
    901  3b7e		       29 01		      and	#1
    902  3b80		       f0 33		      beq	.chosen	; button pressed --> selection made
    903  3b82
    904  3b82				   .nobut
    905  3b82		       ad 80 02 	      lda	SWCHA
    906  3b85		       29 f0		      and	#$F0
    907  3b87		       c9 f0		      cmp	#$F0
    908  3b89		       f0 17		      beq	.odd	; no direction pressed
    909  3b8b
    910  3b8b		       4a		      lsr
    911  3b8c		       4a		      lsr
    912  3b8d		       4a		      lsr
    913  3b8e		       4a		      lsr
    914  3b8f		       a8		      tay
    915  3b90
    916  3b90							; joystick but make sure phase is correct
    917  3b90
    918  3b90		       a5 8f		      lda	aiFlashPhase
    919  3b92		       4a		      lsr
    920  3b93		       b0 0d		      bcs	.odd	; must wait until piece undrawn
    921  3b95
    922  3b95							; cycle to the next promotable piece (N/B/R/Q)
    923  3b95							; TODO; use joy table for mod instead of just incrementing all the time
    924  3b95
    925  3b95							;clc
    926  3b95		       a5 98		      lda	fromPiece
    927  3b97		       79 33 f1 	      adc	JoyCombined,y
    928  3b9a		       29 03		      and	#3
    929  3b9c		       85 98		      sta	fromPiece
    930  3b9e
      0  3b9e					      PHASE	AI_ChooseDebounce	; wait for release
      1  3b9e		       a9 22		      lda	#AI_ChooseDebounce
      2  3ba0		       85 8c		      sta	aiState
    932  3ba2
    933  3ba2		       c6 8d	   .odd       dec	aiFlashDelay
    934  3ba4		       10 0e		      bpl	.exit
    935  3ba6
    936  3ba6		       a9 0a	   .force     lda	#10
    937  3ba8		       85 8d		      sta	aiFlashDelay
    938  3baa
    939  3baa		       e6 8f		      inc	aiFlashPhase
    940  3bac
    941  3bac		       a4 98		      ldy	fromPiece
    942  3bae		       be d0 f3 	      ldx	promotePiece,y
    943  3bb1		       20 41 fd 	      jsr	showPromoteOptions
    944  3bb4
    945  3bb4		       60	   .exit      rts
    946  3bb5
    947  3bb5
    948  3bb5				   .chosen
    949  3bb5		       a5 98		      lda	fromPiece
    950  3bb7		       29 0f		      and	#PIECE_MASK
    951  3bb9		       aa		      tax
    952  3bba
    953  3bba		       bd d4 f3 	      lda	promoteType,x
    954  3bbd		       85 98		      sta	fromPiece
    955  3bbf
    956  3bbf		       a4 86		      ldy	toX12
    957  3bc1		       20 7d fc 	      jsr	GetBoard
    958  3bc4		       29 0f		      and	#PIECE_MASK
    959  3bc6		       f0 03		      beq	.nothing
    960  3bc8
    961  3bc8		       20 ed fc 	      jsr	CopySinglePiece	; put back whatever was there to start
    962  3bcb
      0  3bcb				   .nothing   PHASE	AI_MoveIsSelected
      1  3bcb		       a9 14		      lda	#AI_MoveIsSelected
      2  3bcd		       85 8c		      sta	aiState
    964  3bcf		       60		      rts
    965  3bd0
      0  3bd0					      ALLOCATE	promotePiece, 4
      0  3bd0					      OPTIONAL_PAGEBREAK	"Table", 4
     12  3bd0					      LIST	ON
      0  3bd0					      DEF	promotePiece
      1  3bd0				   BANK_promotePiece SET	_CURRENT_BANK
      2  3bd0				   promotePiece
      3  3bd0				   TEMPORARY_VAR SET	Overlay
      4  3bd0				   TEMPORARY_OFFSET SET	0
      5  3bd0				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      6  3bd0				   FUNCTION_NAME SET	promotePiece
      7  3bd0					      SUBROUTINE
    967  3bd0		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    968  3bd1		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    969  3bd2		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    970  3bd3		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    971  3bd4
      0  3bd4					      ALLOCATE	promoteType,4
      0  3bd4					      OPTIONAL_PAGEBREAK	"Table", 4
     12  3bd4					      LIST	ON
      0  3bd4					      DEF	promoteType
      1  3bd4				   BANK_promoteType SET	_CURRENT_BANK
      2  3bd4				   promoteType
      3  3bd4				   TEMPORARY_VAR SET	Overlay
      4  3bd4				   TEMPORARY_OFFSET SET	0
      5  3bd4				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      6  3bd4				   FUNCTION_NAME SET	promoteType
      7  3bd4					      SUBROUTINE
    973  3bd4		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    974  3bd8
    975  3bd8
    976  3bd8							;---------------------------------------------------------------------------------------------------
    977  3bd8
      0  3bd8					      DEF	aiChooseDebounce
      1  3bd8				   BANK_aiChooseDebounce SET	_CURRENT_BANK
      2  3bd8				   aiChooseDebounce
      3  3bd8				   TEMPORARY_VAR SET	Overlay
      4  3bd8				   TEMPORARY_OFFSET SET	0
      5  3bd8				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      6  3bd8				   FUNCTION_NAME SET	aiChooseDebounce
      7  3bd8					      SUBROUTINE
    979  3bd8					      SUBROUTINE
    980  3bd8
      0  3bd8					      REFER	AiStateMachine
      1  3bd8				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3bd8				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3bd8					      ENDIF
      0  3bd8					      VEND	aiChooseDebounce
      1  3bd8				  -	      IFNCONST	aiChooseDebounce
      2  3bd8				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  3bd8				  -	      ERR
      4  3bd8					      ENDIF
      5  3bd8		       00 a7	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    983  3bd8
    984  3bd8							; We've changed promotion piece, but wait for joystick to be released
    985  3bd8
    986  3bd8		       ad 80 02 	      lda	SWCHA
    987  3bdb		       29 f0		      and	#$F0
    988  3bdd		       c9 f0		      cmp	#$F0
    989  3bdf		       d0 08		      bne	.exit	; wait while joystick still pressed
    990  3be1
    991  3be1		       a9 01		      lda	#1
    992  3be3		       85 8d		      sta	aiFlashDelay
    993  3be5
      0  3be5					      PHASE	AI_ChoosePromotePiece
      1  3be5		       a9 21		      lda	#AI_ChoosePromotePiece
      2  3be7		       85 8c		      sta	aiState
    995  3be9		       60	   .exit      rts
    996  3bea
    997  3bea
    998  3bea							;---------------------------------------------------------------------------------------------------
    999  3bea
      0  3bea					      DEF	aiDelayAfterMove
      1  3bea				   BANK_aiDelayAfterMove SET	_CURRENT_BANK
      2  3bea				   aiDelayAfterMove
      3  3bea				   TEMPORARY_VAR SET	Overlay
      4  3bea				   TEMPORARY_OFFSET SET	0
      5  3bea				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      6  3bea				   FUNCTION_NAME SET	aiDelayAfterMove
      7  3bea					      SUBROUTINE
   1001  3bea					      SUBROUTINE
   1002  3bea
      0  3bea					      VEND	aiDelayAfterMove
      1  3bea				  -	      IFNCONST	aiDelayAfterMove
      2  3bea				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  3bea				  -	      ERR
      4  3bea					      ENDIF
      5  3bea		       00 a7	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
   1004  3bea
   1005  3bea		       c6 8d		      dec	aiFlashDelay
   1006  3bec		       d0 04		      bne	.exit
      0  3bee					      PHASE	AI_MoveIsSelected
      1  3bee		       a9 14		      lda	#AI_MoveIsSelected
      2  3bf0		       85 8c		      sta	aiState
   1008  3bf2		       60	   .exit      rts
   1009  3bf3
   1010  3bf3
   1011  3bf3							;---------------------------------------------------------------------------------------------------
   1012  3bf3
      0  3bf3					      DEF	aiDelayAfterPlaced
      1  3bf3				   BANK_aiDelayAfterPlaced SET	_CURRENT_BANK
      2  3bf3				   aiDelayAfterPlaced
      3  3bf3				   TEMPORARY_VAR SET	Overlay
      4  3bf3				   TEMPORARY_OFFSET SET	0
      5  3bf3				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      6  3bf3				   FUNCTION_NAME SET	aiDelayAfterPlaced
      7  3bf3					      SUBROUTINE
   1014  3bf3					      SUBROUTINE
   1015  3bf3
      0  3bf3					      VEND	aiDelayAfterPlaced
      1  3bf3				  -	      IFNCONST	aiDelayAfterPlaced
      2  3bf3				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  3bf3				  -	      ERR
      4  3bf3					      ENDIF
      5  3bf3		       00 a7	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
   1017  3bf3
   1018  3bf3		       a9 ff		      lda	#-1
   1019  3bf5							;sta cursorX12
   1020  3bf5
   1021  3bf5		       c6 8d		      dec	aiFlashDelay
   1022  3bf7		       d0 04		      bne	.exit
      0  3bf9					      PHASE	AI_GenerateMoves
      1  3bf9		       a9 12		      lda	#AI_GenerateMoves
      2  3bfb		       85 8c		      sta	aiState
   1024  3bfd		       60	   .exit      rts
   1025  3bfe
   1026  3bfe
   1027  3bfe							;---------------------------------------------------------------------------------------------------
   1028  3bfe
   1029  3c00		       00 00		      align	256
      0  3c00					      DEF	PositionSprites
      1  3c00				   BANK_PositionSprites SET	_CURRENT_BANK
      2  3c00				   PositionSprites
      3  3c00				   TEMPORARY_VAR SET	Overlay
      4  3c00				   TEMPORARY_OFFSET SET	0
      5  3c00				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      6  3c00				   FUNCTION_NAME SET	PositionSprites
      7  3c00					      SUBROUTINE
   1031  3c00					      SUBROUTINE
   1032  3c00
      0  3c00					      REFER	Reset
      1  3c00				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  3c00				  -TEMPORARY_VAR SET	VAREND_Reset
      3  3c00					      ENDIF
      0  3c00					      VEND	PositionSprites
      1  3c00				  -	      IFNCONST	PositionSprites
      2  3c00				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  3c00				  -	      ERR
      4  3c00					      ENDIF
      5  3c00		       00 a7	   VAREND_PositionSprites =	TEMPORARY_VAR
   1035  3c00
   1036  3c00
   1037  3c00		       a5 88		      lda	cursorX12
   1038  3c02		       38		      sec
   1039  3c03		       e9 0a	   .sub10     sbc	#10
   1040  3c05		       b0 fc		      bcs	.sub10
   1041  3c07		       69 08		      adc	#8
   1042  3c09		       a8		      tay
   1043  3c0a
   1044  3c0a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
   1045  3c0c
   1046  3c0c		       b9 30 f4 	      lda	colToPixel,y
   1047  3c0f
   1048  3c0f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
   1049  3c10		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
   1050  3c12		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
   1051  3c14
   1052  3c14		       a8		      tay
   1053  3c15		       b9 30 f3 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
   1054  3c18		       85 60		      sta	HMP0
   1055  3c1a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
   1056  3c1c
   1057  3c1c		       85 42		      sta	WSYNC
   1058  3c1e		       85 6a		      sta	HMOVE
   1059  3c20
   1060  3c20		       60		      rts
   1061  3c21
   1062  3c21							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
   1063  3c21							; fine adjustment value. This table is on a page boundary to guarantee the processor
   1064  3c21							; will cross a page boundary and waste a cycle in order to be at the precise position
   1065  3c21							; for a RESP0,x write
   1066  3c21
   1067  3c21				   fineAdjustBegin
   1068  3c21
   1069  3c21		       70		      DC.B	%01110000	; Left 7
   1070  3c22		       60		      DC.B	%01100000	; Left 6
   1071  3c23		       50		      DC.B	%01010000	; Left 5
   1072  3c24		       40		      DC.B	%01000000	; Left 4
   1073  3c25		       30		      DC.B	%00110000	; Left 3
   1074  3c26		       20		      DC.B	%00100000	; Left 2
   1075  3c27		       10		      DC.B	%00010000	; Left 1
   1076  3c28		       00		      DC.B	%00000000	; No movement.
   1077  3c29		       f0		      DC.B	%11110000	; Right 1
   1078  3c2a		       e0		      DC.B	%11100000	; Right 2
   1079  3c2b		       d0		      DC.B	%11010000	; Right 3
   1080  3c2c		       c0		      DC.B	%11000000	; Right 4
   1081  3c2d		       b0		      DC.B	%10110000	; Right 5
   1082  3c2e		       a0		      DC.B	%10100000	; Right 6
   1083  3c2f		       90		      DC.B	%10010000	; Right 7
   1084  3c30
   1085  3c30		       f3 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
   1086  3c30
   1087  3c30
      0  3c30					      ALLOCATE	colToPixel, 8
      0  3c30					      OPTIONAL_PAGEBREAK	"Table", 8
     12  3c30					      LIST	ON
      0  3c30					      DEF	colToPixel
      1  3c30				   BANK_colToPixel SET	_CURRENT_BANK
      2  3c30				   colToPixel
      3  3c30				   TEMPORARY_VAR SET	Overlay
      4  3c30				   TEMPORARY_OFFSET SET	0
      5  3c30				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      6  3c30				   FUNCTION_NAME SET	colToPixel
      7  3c30					      SUBROUTINE
   1089  3c30		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
   1090  3c38
   1091  3c38							;---------------------------------------------------------------------------------------------------
   1092  3c38
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  3c38					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  3c38					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  3c38					      LIST	ON
      0  3c38					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  3c38				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3c38				   BLACK_MARKER_on_BLACK_SQUARE_0
      3  3c38				   TEMPORARY_VAR SET	Overlay
      4  3c38				   TEMPORARY_OFFSET SET	0
      5  3c38				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3c38				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      7  3c38					      SUBROUTINE
      3  3c38		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c50		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c68		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  3c80					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  3c80					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  3c80					      LIST	ON
      0  3c80					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  3c80				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3c80				   BLACK_MARKER_on_BLACK_SQUARE_1
      3  3c80				   TEMPORARY_VAR SET	Overlay
      4  3c80				   TEMPORARY_OFFSET SET	0
      5  3c80				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3c80				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      7  3c80					      SUBROUTINE
      3  3c80		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c98		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3cb0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  3cc8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  3cc8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  3d00				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3d00				   BLACK_MARKER_on_BLACK_SQUARE_2
      3  3d00				   TEMPORARY_VAR SET	Overlay
      4  3d00				   TEMPORARY_OFFSET SET	0
      5  3d00				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3d00				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      7  3d00					      SUBROUTINE
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  3d48					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  3d48				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3d48				   BLACK_MARKER_on_BLACK_SQUARE_3
      3  3d48				   TEMPORARY_VAR SET	Overlay
      4  3d48				   TEMPORARY_OFFSET SET	0
      5  3d48				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3d48				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      7  3d48					      SUBROUTINE
      3  3d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d78		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  3d90					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  3d90				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3d90				   BLACK_MARKER_on_WHITE_SQUARE_0
      3  3d90				   TEMPORARY_VAR SET	Overlay
      4  3d90				   TEMPORARY_OFFSET SET	0
      5  3d90				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3d90				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      7  3d90					      SUBROUTINE
      3  3d90		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  3da8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  3dd8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  3e00				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3e00				   BLACK_MARKER_on_WHITE_SQUARE_1
      3  3e00				   TEMPORARY_VAR SET	Overlay
      4  3e00				   TEMPORARY_OFFSET SET	0
      5  3e00				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3e00				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      7  3e00					      SUBROUTINE
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  3e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  3e48					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  3e48				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3e48				   BLACK_MARKER_on_WHITE_SQUARE_2
      3  3e48				   TEMPORARY_VAR SET	Overlay
      4  3e48				   TEMPORARY_OFFSET SET	0
      5  3e48				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3e48				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      7  3e48					      SUBROUTINE
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  3e90					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  3e90				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3e90				   BLACK_MARKER_on_WHITE_SQUARE_3
      3  3e90				   TEMPORARY_VAR SET	Overlay
      4  3e90				   TEMPORARY_OFFSET SET	0
      5  3e90				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3e90				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      7  3e90					      SUBROUTINE
      3  3e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
   1101  3ed8
   1102  3ed8							;---------------------------------------------------------------------------------------------------
   1103  3ed8
      0  3ed8					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  3ed8		       06 d8	   .TEMP      =	* - BANK_START
 BANK_StateMachine (2K) SIZE =  $6d8 , FREE= $128
      2  3ed8					      ECHO	"BANK_StateMachine", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3ed8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  3ed8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3ed8				  -	      ERR
      6  3ed8					      ENDIF
      7  3ed8
   1105  3ed8
   1106  3ed8
   1107  3ed8							;---------------------------------------------------------------------------------------------------
   1108  3ed8
   1109  3ed8							; EOF
------- FILE ./chess.asm
------- FILE BANK_TEXT_OVERLAYS.asm LEVEL 2 PASS 5
      0  3ed8					      include	"BANK_TEXT_OVERLAYS.asm"
      0  3ed8					      NEWBANK	TEXT_OVERLAYS
      1  4002 ????				      SEG	TEXT_OVERLAYS
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   TEXT_OVERLAYS SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	TEXT_OVERLAYS
      2  4000
      3  4000
      4  4000
      5  4000
      6  4000				   sample
      7  4000		       48 aa		      .byte.b	72,%10101010
      8  4002
      9  4002
     10  4002
     11  4002							;EOF
------- FILE ./chess.asm
------- FILE BANK_PLIST.asm LEVEL 2 PASS 5
      0  4002					      include	"BANK_PLIST.asm"
      0  4002					      NEWRAMBANK	RAM_PIECELIST
      1  4002
      2  4002
      3  4002
      4 U2000 ????				      SEG.U	RAM_PIECELIST
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	RAM_3E
      7 U2000				   BANK_START SET	*
      8 U2000				   RAMBANK_RAM_PIECELIST SET	ORIGIN_RAM / RAM_SIZE
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_RAM_PIECELIST
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U2000					      NEWBANK	ROM_PIECELIST
      1  4820 ????				      SEG	ROM_PIECELIST
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   ROM_PIECELIST SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	ROM_PIECELIST
      3  4800
      4  4800
      5  4800
      6  4800							; We have 16 white pieces, followed by 16 black pieces
      7  4800
      8  4800
      0  4800					      VARIABLE	PiecePointer, 32
      0  4800					      OPTIONAL_PAGEBREAK	"Variable", 32
     12  4800					      LIST	ON
      2  4800		       00 00 00 00*PiecePointer ds	32
     10  4820
     11  4820
     12  4820
     13  4820
     14  4820
      0  4820					      CHECK_BANK_SIZE	"BANK_PIECELIST"
      1  4820		       00 20	   .TEMP      =	* - BANK_START
 BANK_PIECELIST (2K) SIZE =  $20 , FREE= $7e0
      2  4820					      ECHO	"BANK_PIECELIST", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4820				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  4820				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4820				  -	      ERR
      6  4820					      ENDIF
      7  4820
     16  4820
     17  4820							;---------------------------------------------------------------------------------------------------
     18  4820							; EOF
------- FILE ./chess.asm
    600  4820
------- FILE titleScreen.asm LEVEL 2 PASS 5
      0  4820					      include	"titleScreen.asm"
      0  4820					      NEWBANK	TITLESCREEN
      1  57c0 ????				      SEG	TITLESCREEN
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   TITLESCREEN SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	TITLESCREEN
      2  5000
      3  5000				   OverscanTime2
      4  5000		       1a 1a		      .byte.b	26, 26
      5  5002		       20 20		      .byte.b	32, 32
      6  5004
      7  5004				   colvec
      8  5004		       00 f1 d8 f1	      .word.w	colr_ntsc2, colr_pal
      9  5008
     10  5008
     11  5008		       32 32	   VBlankTime .byte.b	50,50
     12  500a
      0  500a					      DEF	TitleScreen
      1  500a				   BANK_TitleScreen SET	_CURRENT_BANK
      2  500a				   TitleScreen
      3  500a				   TEMPORARY_VAR SET	Overlay
      4  500a				   TEMPORARY_OFFSET SET	0
      5  500a				   VAR_BOUNDARY_TitleScreen SET	TEMPORARY_OFFSET
      6  500a				   FUNCTION_NAME SET	TitleScreen
      7  500a					      SUBROUTINE
     14  500a					      SUBROUTINE
     15  500a
      0  500a					      VAR	__colour_table, 2
      1  500a		       00 a7	   __colour_table =	TEMPORARY_VAR
      2  500a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  500a
      4  500a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  500a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  500a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  500a					      ENDIF
      8  500a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  500a				  -	      ECHO	"Temporary Variable", __colour_table, "overflow!"
     10  500a				  -	      ERR
     11  500a					      ENDIF
     12  500a					      LIST	ON
     17  500a
     18  500a							; Start of new frame
     19  500a
     20  500a							; Start of vertical blank processing
     21  500a
     22  500a				   TitleSequence
     23  500a
     24  500a		       a9 00		      lda	#%00000000
     25  500c		       85 4a		      sta	CTRLPF
     26  500e		       85 49		      sta	COLUBK
     27  5010
     28  5010		       a2 00		      ldx	#0	;Platform
     29  5012		       a9 00		      lda	#<colr_ntsc2	;colvec,x
     30  5014		       85 a7		      sta	__colour_table
     31  5016		       a9 f1		      lda	#>colr_ntsc2	;colvec+1,x
     32  5018		       85 a8		      sta	__colour_table+1
     33  501a
     34  501a							;		  sta rndHi
     35  501a							;		  sta rnd
     36  501a
     37  501a
     38  501a				  -	      IF	0
     39  501a				  -	      lda	#0
     40  501a				  -	      sta	digit
     41  501a				  -	      lda	#$10
     42  501a				  -	      sta	digit+1
     43  501a				  -	      lda	#$20
     44  501a				  -	      sta	digit+2
     45  501a					      ENDIF
     46  501a
     47  501a
     48  501a
     49  501a
     50  501a							;RESYNC
     51  501a
     52  501a				   RestartFrame0
     53  501a
     54  501a				  -	      IF	0
     55  501a				  -	      ldx	#2
     56  501a				  -rollcols   clc
     57  501a				  -	      lda	digit+2
     58  501a				  -	      adc	#$10
     59  501a				  -	      sta	digit+2
     60  501a				  -	      bcc	finxc
     61  501a				  -	      dex
     62  501a				  -	      bpl	rollcols
     63  501a				  -finxc
     64  501a					      ENDIF
     65  501a
      0  501a					      DEF	RestartFrame
      1  501a				   BANK_RestartFrame SET	_CURRENT_BANK
      2  501a				   RestartFrame
      3  501a				   TEMPORARY_VAR SET	Overlay
      4  501a				   TEMPORARY_OFFSET SET	0
      5  501a				   VAR_BOUNDARY_RestartFrame SET	TEMPORARY_OFFSET
      6  501a				   FUNCTION_NAME SET	RestartFrame
      7  501a					      SUBROUTINE
     67  501a		       a9 00		      LDA	#0
     68  501c		       a9 0e		      lda	#%1110	; VSYNC ON
     69  501e		       85 42	   .loopVSync2 sta	WSYNC
     70  5020		       85 40		      sta	VSYNC
     71  5022		       4a		      lsr
     72  5023		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     73  5025
     74  5025							;------------------------------------------------------------------
     75  5025
     76  5025		       a6 9b		      ldx	Platform
     77  5027		       bc 08 f0 	      ldy	VBlankTime,x
     78  502a		       8c 96 02 	      sty	TIM64T
     79  502d
     80  502d
     81  502d				  -	      IF	0
     82  502d				  -	      lda	SWCHB
     83  502d				  -	      rol
     84  502d				  -	      rol
     85  502d				  -	      rol
     86  502d				  -	      and	#%11
     87  502d				  -	      eor	#PAL
     88  502d				  -	      cmp	Platform
     89  502d				  -	      beq	platOK
     90  502d				  -	      sta	Platform
     91  502d				  -	      jmp	TitleSequence
     92  502d				  -platOK
     93  502d					      ENDIF
     94  502d
     95  502d		       e6 81	   k2	      inc	rnd
     96  502f		       f0 fc		      beq	k2
     97  5031
     98  5031
     99  5031		       85 42	   VerticalBlank sta	WSYNC
    100  5033		       ad 84 02 	      lda	INTIM
    101  5036		       d0 f9		      bne	VerticalBlank
    102  5038		       85 41		      sta	VBLANK
    103  503a
    104  503a							;sta COLUBK
    105  503a
    106  503a							;------------------------------------------------------------------
    107  503a
    108  503a							; Do X scanlines of color-changing (our picture)
    109  503a
    110  503a		       a0 d1		      ldy	#210-1	; this counts our scanline number
    111  503c		       a2 03	   SokoLogo   ldx	#3
    112  503e		       b1 a7	   triplet    lda	(__colour_table),y
    113  5040							;    eor digit-1,x
    114  5040		       85 42		      sta	WSYNC
    115  5042		       85 48		      sta	COLUPF	; 3
    116  5044
    117  5044		       b9 b0 f2 	      lda	COL_0,y	; 5
    118  5047		       85 4d		      sta	PF0	; 3   @11
    119  5049		       b9 88 f3 	      lda	COL_1,y	; 5
    120  504c		       85 4e		      sta	PF1	; 3   @19
    121  504e		       b9 60 f4 	      lda	COL_2,y	; 5
    122  5051		       85 4f		      sta	PF2	; 3   @27
    123  5053
    124  5053		       b9 38 f5 	      lda	COL_3,y	; 5
    125  5056		       85 4d		      sta	PF0	; 3   @35
      0  5058					      SLEEP	2	; @37
      1  5058				   .CYCLES    SET	2
      2  5058
      3  5058				  -	      IF	.CYCLES < 2
      4  5058				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  5058				  -	      ERR
      6  5058					      ENDIF
      7  5058
      8  5058				  -	      IF	.CYCLES & 1
      9  5058				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  5058				  -	      nop	0
     11  5058				  -	      ELSE
     12  5058				  -	      bit	VSYNC
     13  5058				  -	      ENDIF
     14  5058				  -.CYCLES    SET	.CYCLES - 3
     15  5058					      ENDIF
     16  5058
     17  5058					      REPEAT	.CYCLES / 2
     18  5058		       ea		      nop
     19  5059					      REPEND
    127  5059		       b9 10 f6 	      lda	COL_4,y	; 5
    128  505c		       85 4e		      sta	PF1	; 3   @45
      0  505e					      SLEEP	3	; @45
      1  505e				   .CYCLES    SET	3
      2  505e
      3  505e				  -	      IF	.CYCLES < 2
      4  505e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  505e				  -	      ERR
      6  505e					      ENDIF
      7  505e
      8  505e					      IF	.CYCLES & 1
      9  505e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  505e		       04 00		      nop	0
     11  5060				  -	      ELSE
     12  5060				  -	      bit	VSYNC
     13  5060					      ENDIF
     14  5060				   .CYCLES    SET	.CYCLES - 3
     15  5060					      ENDIF
     16  5060
     17  5060				  -	      REPEAT	.CYCLES / 2
     18  5060				  -	      nop
     19  5060					      REPEND
    130  5060		       b9 e8 f6 	      lda	COL_5,y	; 5
    131  5063		       85 4f		      sta	PF2	; 3
    132  5065
    133  5065		       88		      dey		; 2
    134  5066		       ca		      dex		; 2
    135  5067		       d0 d5		      bne	triplet	; 2(3)
    136  5069
    137  5069		       c0 ff		      cpy	#-1	; 2
    138  506b		       d0 cf		      bne	SokoLogo	; 2(3)
    139  506d
    140  506d							;lda #0
    141  506d							;sta PF0
    142  506d							;sta PF1
    143  506d							;sta PF2
    144  506d
    145  506d		       a6 9b		      ldx	Platform
    146  506f		       bd 00 f0 	      lda	OverscanTime2,x
    147  5072		       8d 96 02 	      sta	TIM64T
    148  5075
    149  5075				  -	      IF	0
    150  5075				  -	      sta	WSYNC
    151  5075				  -	      sta	WSYNC
    152  5075				  -	      sta	WSYNC
    153  5075				  -	      sta	WSYNC
    154  5075				  -	      sta	WSYNC
    155  5075				  -	      SLEEP	8
    156  5075				  -	      jsr	SokoScreen
    157  5075				  -
    158  5075				  -	      lda	#0
    159  5075				  -	      sta	BoardScrollX
    160  5075				  -	      sta	BoardScrollY
    161  5075					      ENDIF
    162  5075
    163  5075							;		ldy #63
    164  5075							;bot2		 sta WSYNC
    165  5075							;		dey
    166  5075							;		bpl bot2
    167  5075
    168  5075							;--------------------------------------------------------------------------
    169  5075
    170  5075		       a9 00		      lda	#0
    171  5077		       85 4d		      sta	PF0
    172  5079		       85 4e		      sta	PF1
    173  507b		       85 4f		      sta	PF2
    174  507d
    175  507d
      0  507d					      NEXT_RANDOM
      1  507d		       a5 81		      lda	rnd
      2  507f		       4a		      lsr
      3  5080		       90 02		      bcc	.skipEOR
      4  5082		       49 fe		      eor	#RND_EOR_VAL
      5  5084		       85 81	   .skipEOR   sta	rnd
    177  5086
    178  5086							; D1 VBLANK turns off beam
    179  5086							; It needs to be turned on 37 scanlines later
    180  5086
    181  5086				   oscan
    182  5086		       ad 84 02 	      lda	INTIM
    183  5089		       d0 fb		      bne	oscan
    184  508b
    185  508b		       a9 42		      lda	#%01000010	; bit6 is not required
    186  508d		       85 41		      sta	VBLANK	; end of screen - enter blanking
    187  508f
    188  508f				  -	      IF	0
    189  508f				  -	      inc	rnd
    190  508f				  -	      bne	rdd
    191  508f				  -	      inc	rndHi
    192  508f				  -rdd
    193  508f				  -
    194  508f				  -	      dec	digitick
    195  508f				  -	      bpl	ret2
    196  508f				  -	      lda	#40
    197  508f				  -	      sta	digitick
    198  508f				  -
    199  508f				  -	      jsr	Random
    200  508f				  -	      and	#3
    201  508f				  -	      beq	ret2
    202  508f				  -	      tax
    203  508f				  -	      jsr	Random
    204  508f				  -	      and	#$F0
    205  508f				  -	      sta	digit-1,x
    206  508f				  -	      jmp	RestartFrame0
    207  508f				  -
    208  508f				  -ret2
    209  508f					      ENDIF
    210  508f
    211  508f
    212  508f		       a5 4c		      lda	INPT4
    213  5091		       10 03		      bpl	ret
    214  5093
    215  5093		       4c 1a f0 	      jmp	RestartFrame
    216  5096
    217  5096				   ret
    218  5096		       60		      rts
    219  5097
    220  5097
    221  5097
    222  5097					      MAC	lumtable
    223  5097							; {4} MIN LUM 1
    224  5097							; {5} MIN LUM 2
    225  5097							; {6} MIN LUM 3
    226  5097
    227  5097				   .LUM1      SET	{4}*256
    228  5097				   .LUM2      SET	{5}*256
    229  5097				   .LUM3      SET	{6}*256
    230  5097
    231  5097				   .STEP1     =	(256*({7}-{4}))/72
    232  5097				   .STEP2     =	(256*({8}-{5}))/72
    233  5097				   .STEP3     =	(256*({9}-{6}))/72
    234  5097
    235  5097					      REPEAT	72
    236  5097					      .byte	{1}+(.LUM1/256)
    237  5097					      .byte	{2}+(.LUM2/256)
    238  5097					      .byte	{3}+(.LUM3/256)
    239  5097
    240  5097							;    ECHO {1}+(.LUM1/256)
    241  5097							;    ECHO {2}+(.LUM1/256)
    242  5097							;    ECHO {3}+(.LUM1/256)
    243  5097
    244  5097				   .LUM1      SET	.LUM1 + .STEP1
    245  5097				   .LUM2      SET	.LUM2 + .STEP2
    246  5097				   .LUM3      SET	.LUM3 + .STEP3
    247  5097					      REPEND
    248  5097					      ENDM		;{1}{2}{3} base colours
    249  5097
    250  5097							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    251  5097							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    252  5097
    253  5100		       00 00 00 00*	      align	256
    254  5100							;    ECHO "NTSC LUMS"
    255  5100				   colr_ntsc2
      0  5100					      LUMTABLE	$40,$20,$90,$4,$6,$8,$4,$6,$8
      1  5100
      2  5100
      3  5100
      4  5100
      5  5100				   .LUM1      SET	$4*256
      6  5100				   .LUM2      SET	$6*256
      7  5100				   .LUM3      SET	$8*256
      8  5100
      9  5100		       00 00	   .STEP1     =	(256*($4-$4))/72
     10  5100		       00 00	   .STEP2     =	(256*($6-$6))/72
     11  5100		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  5100
     13  5100					      REPEAT	72
     14  5100		       44		      .byte.b	$40+(.LUM1/256)
     15  5101		       26		      .byte.b	$20+(.LUM2/256)
     16  5102		       98		      .byte.b	$90+(.LUM3/256)
     17  5103
     18  5103
     19  5103
     20  5103
     21  5103
     22  5103				   .LUM1      SET	.LUM1 + .STEP1
     23  5103				   .LUM2      SET	.LUM2 + .STEP2
     24  5103				   .LUM3      SET	.LUM3 + .STEP3
     13  5103					      REPEND
     14  5103		       44		      .byte.b	$40+(.LUM1/256)
     15  5104		       26		      .byte.b	$20+(.LUM2/256)
     16  5105		       98		      .byte.b	$90+(.LUM3/256)
     17  5106
     18  5106
     19  5106
     20  5106
     21  5106
     22  5106				   .LUM1      SET	.LUM1 + .STEP1
     23  5106				   .LUM2      SET	.LUM2 + .STEP2
     24  5106				   .LUM3      SET	.LUM3 + .STEP3
     13  5106					      REPEND
     14  5106		       44		      .byte.b	$40+(.LUM1/256)
     15  5107		       26		      .byte.b	$20+(.LUM2/256)
     16  5108		       98		      .byte.b	$90+(.LUM3/256)
     17  5109
     18  5109
     19  5109
     20  5109
     21  5109
     22  5109				   .LUM1      SET	.LUM1 + .STEP1
     23  5109				   .LUM2      SET	.LUM2 + .STEP2
     24  5109				   .LUM3      SET	.LUM3 + .STEP3
     13  5109					      REPEND
     14  5109		       44		      .byte.b	$40+(.LUM1/256)
     15  510a		       26		      .byte.b	$20+(.LUM2/256)
     16  510b		       98		      .byte.b	$90+(.LUM3/256)
     17  510c
     18  510c
     19  510c
     20  510c
     21  510c
     22  510c				   .LUM1      SET	.LUM1 + .STEP1
     23  510c				   .LUM2      SET	.LUM2 + .STEP2
     24  510c				   .LUM3      SET	.LUM3 + .STEP3
     13  510c					      REPEND
     14  510c		       44		      .byte.b	$40+(.LUM1/256)
     15  510d		       26		      .byte.b	$20+(.LUM2/256)
     16  510e		       98		      .byte.b	$90+(.LUM3/256)
     17  510f
     18  510f
     19  510f
     20  510f
     21  510f
     22  510f				   .LUM1      SET	.LUM1 + .STEP1
     23  510f				   .LUM2      SET	.LUM2 + .STEP2
     24  510f				   .LUM3      SET	.LUM3 + .STEP3
     13  510f					      REPEND
     14  510f		       44		      .byte.b	$40+(.LUM1/256)
     15  5110		       26		      .byte.b	$20+(.LUM2/256)
     16  5111		       98		      .byte.b	$90+(.LUM3/256)
     17  5112
     18  5112
     19  5112
     20  5112
     21  5112
     22  5112				   .LUM1      SET	.LUM1 + .STEP1
     23  5112				   .LUM2      SET	.LUM2 + .STEP2
     24  5112				   .LUM3      SET	.LUM3 + .STEP3
     13  5112					      REPEND
     14  5112		       44		      .byte.b	$40+(.LUM1/256)
     15  5113		       26		      .byte.b	$20+(.LUM2/256)
     16  5114		       98		      .byte.b	$90+(.LUM3/256)
     17  5115
     18  5115
     19  5115
     20  5115
     21  5115
     22  5115				   .LUM1      SET	.LUM1 + .STEP1
     23  5115				   .LUM2      SET	.LUM2 + .STEP2
     24  5115				   .LUM3      SET	.LUM3 + .STEP3
     13  5115					      REPEND
     14  5115		       44		      .byte.b	$40+(.LUM1/256)
     15  5116		       26		      .byte.b	$20+(.LUM2/256)
     16  5117		       98		      .byte.b	$90+(.LUM3/256)
     17  5118
     18  5118
     19  5118
     20  5118
     21  5118
     22  5118				   .LUM1      SET	.LUM1 + .STEP1
     23  5118				   .LUM2      SET	.LUM2 + .STEP2
     24  5118				   .LUM3      SET	.LUM3 + .STEP3
     13  5118					      REPEND
     14  5118		       44		      .byte.b	$40+(.LUM1/256)
     15  5119		       26		      .byte.b	$20+(.LUM2/256)
     16  511a		       98		      .byte.b	$90+(.LUM3/256)
     17  511b
     18  511b
     19  511b
     20  511b
     21  511b
     22  511b				   .LUM1      SET	.LUM1 + .STEP1
     23  511b				   .LUM2      SET	.LUM2 + .STEP2
     24  511b				   .LUM3      SET	.LUM3 + .STEP3
     13  511b					      REPEND
     14  511b		       44		      .byte.b	$40+(.LUM1/256)
     15  511c		       26		      .byte.b	$20+(.LUM2/256)
     16  511d		       98		      .byte.b	$90+(.LUM3/256)
     17  511e
     18  511e
     19  511e
     20  511e
     21  511e
     22  511e				   .LUM1      SET	.LUM1 + .STEP1
     23  511e				   .LUM2      SET	.LUM2 + .STEP2
     24  511e				   .LUM3      SET	.LUM3 + .STEP3
     13  511e					      REPEND
     14  511e		       44		      .byte.b	$40+(.LUM1/256)
     15  511f		       26		      .byte.b	$20+(.LUM2/256)
     16  5120		       98		      .byte.b	$90+(.LUM3/256)
     17  5121
     18  5121
     19  5121
     20  5121
     21  5121
     22  5121				   .LUM1      SET	.LUM1 + .STEP1
     23  5121				   .LUM2      SET	.LUM2 + .STEP2
     24  5121				   .LUM3      SET	.LUM3 + .STEP3
     13  5121					      REPEND
     14  5121		       44		      .byte.b	$40+(.LUM1/256)
     15  5122		       26		      .byte.b	$20+(.LUM2/256)
     16  5123		       98		      .byte.b	$90+(.LUM3/256)
     17  5124
     18  5124
     19  5124
     20  5124
     21  5124
     22  5124				   .LUM1      SET	.LUM1 + .STEP1
     23  5124				   .LUM2      SET	.LUM2 + .STEP2
     24  5124				   .LUM3      SET	.LUM3 + .STEP3
     13  5124					      REPEND
     14  5124		       44		      .byte.b	$40+(.LUM1/256)
     15  5125		       26		      .byte.b	$20+(.LUM2/256)
     16  5126		       98		      .byte.b	$90+(.LUM3/256)
     17  5127
     18  5127
     19  5127
     20  5127
     21  5127
     22  5127				   .LUM1      SET	.LUM1 + .STEP1
     23  5127				   .LUM2      SET	.LUM2 + .STEP2
     24  5127				   .LUM3      SET	.LUM3 + .STEP3
     13  5127					      REPEND
     14  5127		       44		      .byte.b	$40+(.LUM1/256)
     15  5128		       26		      .byte.b	$20+(.LUM2/256)
     16  5129		       98		      .byte.b	$90+(.LUM3/256)
     17  512a
     18  512a
     19  512a
     20  512a
     21  512a
     22  512a				   .LUM1      SET	.LUM1 + .STEP1
     23  512a				   .LUM2      SET	.LUM2 + .STEP2
     24  512a				   .LUM3      SET	.LUM3 + .STEP3
     13  512a					      REPEND
     14  512a		       44		      .byte.b	$40+(.LUM1/256)
     15  512b		       26		      .byte.b	$20+(.LUM2/256)
     16  512c		       98		      .byte.b	$90+(.LUM3/256)
     17  512d
     18  512d
     19  512d
     20  512d
     21  512d
     22  512d				   .LUM1      SET	.LUM1 + .STEP1
     23  512d				   .LUM2      SET	.LUM2 + .STEP2
     24  512d				   .LUM3      SET	.LUM3 + .STEP3
     13  512d					      REPEND
     14  512d		       44		      .byte.b	$40+(.LUM1/256)
     15  512e		       26		      .byte.b	$20+(.LUM2/256)
     16  512f		       98		      .byte.b	$90+(.LUM3/256)
     17  5130
     18  5130
     19  5130
     20  5130
     21  5130
     22  5130				   .LUM1      SET	.LUM1 + .STEP1
     23  5130				   .LUM2      SET	.LUM2 + .STEP2
     24  5130				   .LUM3      SET	.LUM3 + .STEP3
     13  5130					      REPEND
     14  5130		       44		      .byte.b	$40+(.LUM1/256)
     15  5131		       26		      .byte.b	$20+(.LUM2/256)
     16  5132		       98		      .byte.b	$90+(.LUM3/256)
     17  5133
     18  5133
     19  5133
     20  5133
     21  5133
     22  5133				   .LUM1      SET	.LUM1 + .STEP1
     23  5133				   .LUM2      SET	.LUM2 + .STEP2
     24  5133				   .LUM3      SET	.LUM3 + .STEP3
     13  5133					      REPEND
     14  5133		       44		      .byte.b	$40+(.LUM1/256)
     15  5134		       26		      .byte.b	$20+(.LUM2/256)
     16  5135		       98		      .byte.b	$90+(.LUM3/256)
     17  5136
     18  5136
     19  5136
     20  5136
     21  5136
     22  5136				   .LUM1      SET	.LUM1 + .STEP1
     23  5136				   .LUM2      SET	.LUM2 + .STEP2
     24  5136				   .LUM3      SET	.LUM3 + .STEP3
     13  5136					      REPEND
     14  5136		       44		      .byte.b	$40+(.LUM1/256)
     15  5137		       26		      .byte.b	$20+(.LUM2/256)
     16  5138		       98		      .byte.b	$90+(.LUM3/256)
     17  5139
     18  5139
     19  5139
     20  5139
     21  5139
     22  5139				   .LUM1      SET	.LUM1 + .STEP1
     23  5139				   .LUM2      SET	.LUM2 + .STEP2
     24  5139				   .LUM3      SET	.LUM3 + .STEP3
     13  5139					      REPEND
     14  5139		       44		      .byte.b	$40+(.LUM1/256)
     15  513a		       26		      .byte.b	$20+(.LUM2/256)
     16  513b		       98		      .byte.b	$90+(.LUM3/256)
     17  513c
     18  513c
     19  513c
     20  513c
     21  513c
     22  513c				   .LUM1      SET	.LUM1 + .STEP1
     23  513c				   .LUM2      SET	.LUM2 + .STEP2
     24  513c				   .LUM3      SET	.LUM3 + .STEP3
     13  513c					      REPEND
     14  513c		       44		      .byte.b	$40+(.LUM1/256)
     15  513d		       26		      .byte.b	$20+(.LUM2/256)
     16  513e		       98		      .byte.b	$90+(.LUM3/256)
     17  513f
     18  513f
     19  513f
     20  513f
     21  513f
     22  513f				   .LUM1      SET	.LUM1 + .STEP1
     23  513f				   .LUM2      SET	.LUM2 + .STEP2
     24  513f				   .LUM3      SET	.LUM3 + .STEP3
     13  513f					      REPEND
     14  513f		       44		      .byte.b	$40+(.LUM1/256)
     15  5140		       26		      .byte.b	$20+(.LUM2/256)
     16  5141		       98		      .byte.b	$90+(.LUM3/256)
     17  5142
     18  5142
     19  5142
     20  5142
     21  5142
     22  5142				   .LUM1      SET	.LUM1 + .STEP1
     23  5142				   .LUM2      SET	.LUM2 + .STEP2
     24  5142				   .LUM3      SET	.LUM3 + .STEP3
     13  5142					      REPEND
     14  5142		       44		      .byte.b	$40+(.LUM1/256)
     15  5143		       26		      .byte.b	$20+(.LUM2/256)
     16  5144		       98		      .byte.b	$90+(.LUM3/256)
     17  5145
     18  5145
     19  5145
     20  5145
     21  5145
     22  5145				   .LUM1      SET	.LUM1 + .STEP1
     23  5145				   .LUM2      SET	.LUM2 + .STEP2
     24  5145				   .LUM3      SET	.LUM3 + .STEP3
     13  5145					      REPEND
     14  5145		       44		      .byte.b	$40+(.LUM1/256)
     15  5146		       26		      .byte.b	$20+(.LUM2/256)
     16  5147		       98		      .byte.b	$90+(.LUM3/256)
     17  5148
     18  5148
     19  5148
     20  5148
     21  5148
     22  5148				   .LUM1      SET	.LUM1 + .STEP1
     23  5148				   .LUM2      SET	.LUM2 + .STEP2
     24  5148				   .LUM3      SET	.LUM3 + .STEP3
     13  5148					      REPEND
     14  5148		       44		      .byte.b	$40+(.LUM1/256)
     15  5149		       26		      .byte.b	$20+(.LUM2/256)
     16  514a		       98		      .byte.b	$90+(.LUM3/256)
     17  514b
     18  514b
     19  514b
     20  514b
     21  514b
     22  514b				   .LUM1      SET	.LUM1 + .STEP1
     23  514b				   .LUM2      SET	.LUM2 + .STEP2
     24  514b				   .LUM3      SET	.LUM3 + .STEP3
     13  514b					      REPEND
     14  514b		       44		      .byte.b	$40+(.LUM1/256)
     15  514c		       26		      .byte.b	$20+(.LUM2/256)
     16  514d		       98		      .byte.b	$90+(.LUM3/256)
     17  514e
     18  514e
     19  514e
     20  514e
     21  514e
     22  514e				   .LUM1      SET	.LUM1 + .STEP1
     23  514e				   .LUM2      SET	.LUM2 + .STEP2
     24  514e				   .LUM3      SET	.LUM3 + .STEP3
     13  514e					      REPEND
     14  514e		       44		      .byte.b	$40+(.LUM1/256)
     15  514f		       26		      .byte.b	$20+(.LUM2/256)
     16  5150		       98		      .byte.b	$90+(.LUM3/256)
     17  5151
     18  5151
     19  5151
     20  5151
     21  5151
     22  5151				   .LUM1      SET	.LUM1 + .STEP1
     23  5151				   .LUM2      SET	.LUM2 + .STEP2
     24  5151				   .LUM3      SET	.LUM3 + .STEP3
     13  5151					      REPEND
     14  5151		       44		      .byte.b	$40+(.LUM1/256)
     15  5152		       26		      .byte.b	$20+(.LUM2/256)
     16  5153		       98		      .byte.b	$90+(.LUM3/256)
     17  5154
     18  5154
     19  5154
     20  5154
     21  5154
     22  5154				   .LUM1      SET	.LUM1 + .STEP1
     23  5154				   .LUM2      SET	.LUM2 + .STEP2
     24  5154				   .LUM3      SET	.LUM3 + .STEP3
     13  5154					      REPEND
     14  5154		       44		      .byte.b	$40+(.LUM1/256)
     15  5155		       26		      .byte.b	$20+(.LUM2/256)
     16  5156		       98		      .byte.b	$90+(.LUM3/256)
     17  5157
     18  5157
     19  5157
     20  5157
     21  5157
     22  5157				   .LUM1      SET	.LUM1 + .STEP1
     23  5157				   .LUM2      SET	.LUM2 + .STEP2
     24  5157				   .LUM3      SET	.LUM3 + .STEP3
     13  5157					      REPEND
     14  5157		       44		      .byte.b	$40+(.LUM1/256)
     15  5158		       26		      .byte.b	$20+(.LUM2/256)
     16  5159		       98		      .byte.b	$90+(.LUM3/256)
     17  515a
     18  515a
     19  515a
     20  515a
     21  515a
     22  515a				   .LUM1      SET	.LUM1 + .STEP1
     23  515a				   .LUM2      SET	.LUM2 + .STEP2
     24  515a				   .LUM3      SET	.LUM3 + .STEP3
     13  515a					      REPEND
     14  515a		       44		      .byte.b	$40+(.LUM1/256)
     15  515b		       26		      .byte.b	$20+(.LUM2/256)
     16  515c		       98		      .byte.b	$90+(.LUM3/256)
     17  515d
     18  515d
     19  515d
     20  515d
     21  515d
     22  515d				   .LUM1      SET	.LUM1 + .STEP1
     23  515d				   .LUM2      SET	.LUM2 + .STEP2
     24  515d				   .LUM3      SET	.LUM3 + .STEP3
     13  515d					      REPEND
     14  515d		       44		      .byte.b	$40+(.LUM1/256)
     15  515e		       26		      .byte.b	$20+(.LUM2/256)
     16  515f		       98		      .byte.b	$90+(.LUM3/256)
     17  5160
     18  5160
     19  5160
     20  5160
     21  5160
     22  5160				   .LUM1      SET	.LUM1 + .STEP1
     23  5160				   .LUM2      SET	.LUM2 + .STEP2
     24  5160				   .LUM3      SET	.LUM3 + .STEP3
     13  5160					      REPEND
     14  5160		       44		      .byte.b	$40+(.LUM1/256)
     15  5161		       26		      .byte.b	$20+(.LUM2/256)
     16  5162		       98		      .byte.b	$90+(.LUM3/256)
     17  5163
     18  5163
     19  5163
     20  5163
     21  5163
     22  5163				   .LUM1      SET	.LUM1 + .STEP1
     23  5163				   .LUM2      SET	.LUM2 + .STEP2
     24  5163				   .LUM3      SET	.LUM3 + .STEP3
     13  5163					      REPEND
     14  5163		       44		      .byte.b	$40+(.LUM1/256)
     15  5164		       26		      .byte.b	$20+(.LUM2/256)
     16  5165		       98		      .byte.b	$90+(.LUM3/256)
     17  5166
     18  5166
     19  5166
     20  5166
     21  5166
     22  5166				   .LUM1      SET	.LUM1 + .STEP1
     23  5166				   .LUM2      SET	.LUM2 + .STEP2
     24  5166				   .LUM3      SET	.LUM3 + .STEP3
     13  5166					      REPEND
     14  5166		       44		      .byte.b	$40+(.LUM1/256)
     15  5167		       26		      .byte.b	$20+(.LUM2/256)
     16  5168		       98		      .byte.b	$90+(.LUM3/256)
     17  5169
     18  5169
     19  5169
     20  5169
     21  5169
     22  5169				   .LUM1      SET	.LUM1 + .STEP1
     23  5169				   .LUM2      SET	.LUM2 + .STEP2
     24  5169				   .LUM3      SET	.LUM3 + .STEP3
     13  5169					      REPEND
     14  5169		       44		      .byte.b	$40+(.LUM1/256)
     15  516a		       26		      .byte.b	$20+(.LUM2/256)
     16  516b		       98		      .byte.b	$90+(.LUM3/256)
     17  516c
     18  516c
     19  516c
     20  516c
     21  516c
     22  516c				   .LUM1      SET	.LUM1 + .STEP1
     23  516c				   .LUM2      SET	.LUM2 + .STEP2
     24  516c				   .LUM3      SET	.LUM3 + .STEP3
     13  516c					      REPEND
     14  516c		       44		      .byte.b	$40+(.LUM1/256)
     15  516d		       26		      .byte.b	$20+(.LUM2/256)
     16  516e		       98		      .byte.b	$90+(.LUM3/256)
     17  516f
     18  516f
     19  516f
     20  516f
     21  516f
     22  516f				   .LUM1      SET	.LUM1 + .STEP1
     23  516f				   .LUM2      SET	.LUM2 + .STEP2
     24  516f				   .LUM3      SET	.LUM3 + .STEP3
     13  516f					      REPEND
     14  516f		       44		      .byte.b	$40+(.LUM1/256)
     15  5170		       26		      .byte.b	$20+(.LUM2/256)
     16  5171		       98		      .byte.b	$90+(.LUM3/256)
     17  5172
     18  5172
     19  5172
     20  5172
     21  5172
     22  5172				   .LUM1      SET	.LUM1 + .STEP1
     23  5172				   .LUM2      SET	.LUM2 + .STEP2
     24  5172				   .LUM3      SET	.LUM3 + .STEP3
     13  5172					      REPEND
     14  5172		       44		      .byte.b	$40+(.LUM1/256)
     15  5173		       26		      .byte.b	$20+(.LUM2/256)
     16  5174		       98		      .byte.b	$90+(.LUM3/256)
     17  5175
     18  5175
     19  5175
     20  5175
     21  5175
     22  5175				   .LUM1      SET	.LUM1 + .STEP1
     23  5175				   .LUM2      SET	.LUM2 + .STEP2
     24  5175				   .LUM3      SET	.LUM3 + .STEP3
     13  5175					      REPEND
     14  5175		       44		      .byte.b	$40+(.LUM1/256)
     15  5176		       26		      .byte.b	$20+(.LUM2/256)
     16  5177		       98		      .byte.b	$90+(.LUM3/256)
     17  5178
     18  5178
     19  5178
     20  5178
     21  5178
     22  5178				   .LUM1      SET	.LUM1 + .STEP1
     23  5178				   .LUM2      SET	.LUM2 + .STEP2
     24  5178				   .LUM3      SET	.LUM3 + .STEP3
     13  5178					      REPEND
     14  5178		       44		      .byte.b	$40+(.LUM1/256)
     15  5179		       26		      .byte.b	$20+(.LUM2/256)
     16  517a		       98		      .byte.b	$90+(.LUM3/256)
     17  517b
     18  517b
     19  517b
     20  517b
     21  517b
     22  517b				   .LUM1      SET	.LUM1 + .STEP1
     23  517b				   .LUM2      SET	.LUM2 + .STEP2
     24  517b				   .LUM3      SET	.LUM3 + .STEP3
     13  517b					      REPEND
     14  517b		       44		      .byte.b	$40+(.LUM1/256)
     15  517c		       26		      .byte.b	$20+(.LUM2/256)
     16  517d		       98		      .byte.b	$90+(.LUM3/256)
     17  517e
     18  517e
     19  517e
     20  517e
     21  517e
     22  517e				   .LUM1      SET	.LUM1 + .STEP1
     23  517e				   .LUM2      SET	.LUM2 + .STEP2
     24  517e				   .LUM3      SET	.LUM3 + .STEP3
     13  517e					      REPEND
     14  517e		       44		      .byte.b	$40+(.LUM1/256)
     15  517f		       26		      .byte.b	$20+(.LUM2/256)
     16  5180		       98		      .byte.b	$90+(.LUM3/256)
     17  5181
     18  5181
     19  5181
     20  5181
     21  5181
     22  5181				   .LUM1      SET	.LUM1 + .STEP1
     23  5181				   .LUM2      SET	.LUM2 + .STEP2
     24  5181				   .LUM3      SET	.LUM3 + .STEP3
     13  5181					      REPEND
     14  5181		       44		      .byte.b	$40+(.LUM1/256)
     15  5182		       26		      .byte.b	$20+(.LUM2/256)
     16  5183		       98		      .byte.b	$90+(.LUM3/256)
     17  5184
     18  5184
     19  5184
     20  5184
     21  5184
     22  5184				   .LUM1      SET	.LUM1 + .STEP1
     23  5184				   .LUM2      SET	.LUM2 + .STEP2
     24  5184				   .LUM3      SET	.LUM3 + .STEP3
     13  5184					      REPEND
     14  5184		       44		      .byte.b	$40+(.LUM1/256)
     15  5185		       26		      .byte.b	$20+(.LUM2/256)
     16  5186		       98		      .byte.b	$90+(.LUM3/256)
     17  5187
     18  5187
     19  5187
     20  5187
     21  5187
     22  5187				   .LUM1      SET	.LUM1 + .STEP1
     23  5187				   .LUM2      SET	.LUM2 + .STEP2
     24  5187				   .LUM3      SET	.LUM3 + .STEP3
     13  5187					      REPEND
     14  5187		       44		      .byte.b	$40+(.LUM1/256)
     15  5188		       26		      .byte.b	$20+(.LUM2/256)
     16  5189		       98		      .byte.b	$90+(.LUM3/256)
     17  518a
     18  518a
     19  518a
     20  518a
     21  518a
     22  518a				   .LUM1      SET	.LUM1 + .STEP1
     23  518a				   .LUM2      SET	.LUM2 + .STEP2
     24  518a				   .LUM3      SET	.LUM3 + .STEP3
     13  518a					      REPEND
     14  518a		       44		      .byte.b	$40+(.LUM1/256)
     15  518b		       26		      .byte.b	$20+(.LUM2/256)
     16  518c		       98		      .byte.b	$90+(.LUM3/256)
     17  518d
     18  518d
     19  518d
     20  518d
     21  518d
     22  518d				   .LUM1      SET	.LUM1 + .STEP1
     23  518d				   .LUM2      SET	.LUM2 + .STEP2
     24  518d				   .LUM3      SET	.LUM3 + .STEP3
     13  518d					      REPEND
     14  518d		       44		      .byte.b	$40+(.LUM1/256)
     15  518e		       26		      .byte.b	$20+(.LUM2/256)
     16  518f		       98		      .byte.b	$90+(.LUM3/256)
     17  5190
     18  5190
     19  5190
     20  5190
     21  5190
     22  5190				   .LUM1      SET	.LUM1 + .STEP1
     23  5190				   .LUM2      SET	.LUM2 + .STEP2
     24  5190				   .LUM3      SET	.LUM3 + .STEP3
     13  5190					      REPEND
     14  5190		       44		      .byte.b	$40+(.LUM1/256)
     15  5191		       26		      .byte.b	$20+(.LUM2/256)
     16  5192		       98		      .byte.b	$90+(.LUM3/256)
     17  5193
     18  5193
     19  5193
     20  5193
     21  5193
     22  5193				   .LUM1      SET	.LUM1 + .STEP1
     23  5193				   .LUM2      SET	.LUM2 + .STEP2
     24  5193				   .LUM3      SET	.LUM3 + .STEP3
     13  5193					      REPEND
     14  5193		       44		      .byte.b	$40+(.LUM1/256)
     15  5194		       26		      .byte.b	$20+(.LUM2/256)
     16  5195		       98		      .byte.b	$90+(.LUM3/256)
     17  5196
     18  5196
     19  5196
     20  5196
     21  5196
     22  5196				   .LUM1      SET	.LUM1 + .STEP1
     23  5196				   .LUM2      SET	.LUM2 + .STEP2
     24  5196				   .LUM3      SET	.LUM3 + .STEP3
     13  5196					      REPEND
     14  5196		       44		      .byte.b	$40+(.LUM1/256)
     15  5197		       26		      .byte.b	$20+(.LUM2/256)
     16  5198		       98		      .byte.b	$90+(.LUM3/256)
     17  5199
     18  5199
     19  5199
     20  5199
     21  5199
     22  5199				   .LUM1      SET	.LUM1 + .STEP1
     23  5199				   .LUM2      SET	.LUM2 + .STEP2
     24  5199				   .LUM3      SET	.LUM3 + .STEP3
     13  5199					      REPEND
     14  5199		       44		      .byte.b	$40+(.LUM1/256)
     15  519a		       26		      .byte.b	$20+(.LUM2/256)
     16  519b		       98		      .byte.b	$90+(.LUM3/256)
     17  519c
     18  519c
     19  519c
     20  519c
     21  519c
     22  519c				   .LUM1      SET	.LUM1 + .STEP1
     23  519c				   .LUM2      SET	.LUM2 + .STEP2
     24  519c				   .LUM3      SET	.LUM3 + .STEP3
     13  519c					      REPEND
     14  519c		       44		      .byte.b	$40+(.LUM1/256)
     15  519d		       26		      .byte.b	$20+(.LUM2/256)
     16  519e		       98		      .byte.b	$90+(.LUM3/256)
     17  519f
     18  519f
     19  519f
     20  519f
     21  519f
     22  519f				   .LUM1      SET	.LUM1 + .STEP1
     23  519f				   .LUM2      SET	.LUM2 + .STEP2
     24  519f				   .LUM3      SET	.LUM3 + .STEP3
     13  519f					      REPEND
     14  519f		       44		      .byte.b	$40+(.LUM1/256)
     15  51a0		       26		      .byte.b	$20+(.LUM2/256)
     16  51a1		       98		      .byte.b	$90+(.LUM3/256)
     17  51a2
     18  51a2
     19  51a2
     20  51a2
     21  51a2
     22  51a2				   .LUM1      SET	.LUM1 + .STEP1
     23  51a2				   .LUM2      SET	.LUM2 + .STEP2
     24  51a2				   .LUM3      SET	.LUM3 + .STEP3
     13  51a2					      REPEND
     14  51a2		       44		      .byte.b	$40+(.LUM1/256)
     15  51a3		       26		      .byte.b	$20+(.LUM2/256)
     16  51a4		       98		      .byte.b	$90+(.LUM3/256)
     17  51a5
     18  51a5
     19  51a5
     20  51a5
     21  51a5
     22  51a5				   .LUM1      SET	.LUM1 + .STEP1
     23  51a5				   .LUM2      SET	.LUM2 + .STEP2
     24  51a5				   .LUM3      SET	.LUM3 + .STEP3
     13  51a5					      REPEND
     14  51a5		       44		      .byte.b	$40+(.LUM1/256)
     15  51a6		       26		      .byte.b	$20+(.LUM2/256)
     16  51a7		       98		      .byte.b	$90+(.LUM3/256)
     17  51a8
     18  51a8
     19  51a8
     20  51a8
     21  51a8
     22  51a8				   .LUM1      SET	.LUM1 + .STEP1
     23  51a8				   .LUM2      SET	.LUM2 + .STEP2
     24  51a8				   .LUM3      SET	.LUM3 + .STEP3
     13  51a8					      REPEND
     14  51a8		       44		      .byte.b	$40+(.LUM1/256)
     15  51a9		       26		      .byte.b	$20+(.LUM2/256)
     16  51aa		       98		      .byte.b	$90+(.LUM3/256)
     17  51ab
     18  51ab
     19  51ab
     20  51ab
     21  51ab
     22  51ab				   .LUM1      SET	.LUM1 + .STEP1
     23  51ab				   .LUM2      SET	.LUM2 + .STEP2
     24  51ab				   .LUM3      SET	.LUM3 + .STEP3
     13  51ab					      REPEND
     14  51ab		       44		      .byte.b	$40+(.LUM1/256)
     15  51ac		       26		      .byte.b	$20+(.LUM2/256)
     16  51ad		       98		      .byte.b	$90+(.LUM3/256)
     17  51ae
     18  51ae
     19  51ae
     20  51ae
     21  51ae
     22  51ae				   .LUM1      SET	.LUM1 + .STEP1
     23  51ae				   .LUM2      SET	.LUM2 + .STEP2
     24  51ae				   .LUM3      SET	.LUM3 + .STEP3
     13  51ae					      REPEND
     14  51ae		       44		      .byte.b	$40+(.LUM1/256)
     15  51af		       26		      .byte.b	$20+(.LUM2/256)
     16  51b0		       98		      .byte.b	$90+(.LUM3/256)
     17  51b1
     18  51b1
     19  51b1
     20  51b1
     21  51b1
     22  51b1				   .LUM1      SET	.LUM1 + .STEP1
     23  51b1				   .LUM2      SET	.LUM2 + .STEP2
     24  51b1				   .LUM3      SET	.LUM3 + .STEP3
     13  51b1					      REPEND
     14  51b1		       44		      .byte.b	$40+(.LUM1/256)
     15  51b2		       26		      .byte.b	$20+(.LUM2/256)
     16  51b3		       98		      .byte.b	$90+(.LUM3/256)
     17  51b4
     18  51b4
     19  51b4
     20  51b4
     21  51b4
     22  51b4				   .LUM1      SET	.LUM1 + .STEP1
     23  51b4				   .LUM2      SET	.LUM2 + .STEP2
     24  51b4				   .LUM3      SET	.LUM3 + .STEP3
     13  51b4					      REPEND
     14  51b4		       44		      .byte.b	$40+(.LUM1/256)
     15  51b5		       26		      .byte.b	$20+(.LUM2/256)
     16  51b6		       98		      .byte.b	$90+(.LUM3/256)
     17  51b7
     18  51b7
     19  51b7
     20  51b7
     21  51b7
     22  51b7				   .LUM1      SET	.LUM1 + .STEP1
     23  51b7				   .LUM2      SET	.LUM2 + .STEP2
     24  51b7				   .LUM3      SET	.LUM3 + .STEP3
     13  51b7					      REPEND
     14  51b7		       44		      .byte.b	$40+(.LUM1/256)
     15  51b8		       26		      .byte.b	$20+(.LUM2/256)
     16  51b9		       98		      .byte.b	$90+(.LUM3/256)
     17  51ba
     18  51ba
     19  51ba
     20  51ba
     21  51ba
     22  51ba				   .LUM1      SET	.LUM1 + .STEP1
     23  51ba				   .LUM2      SET	.LUM2 + .STEP2
     24  51ba				   .LUM3      SET	.LUM3 + .STEP3
     13  51ba					      REPEND
     14  51ba		       44		      .byte.b	$40+(.LUM1/256)
     15  51bb		       26		      .byte.b	$20+(.LUM2/256)
     16  51bc		       98		      .byte.b	$90+(.LUM3/256)
     17  51bd
     18  51bd
     19  51bd
     20  51bd
     21  51bd
     22  51bd				   .LUM1      SET	.LUM1 + .STEP1
     23  51bd				   .LUM2      SET	.LUM2 + .STEP2
     24  51bd				   .LUM3      SET	.LUM3 + .STEP3
     13  51bd					      REPEND
     14  51bd		       44		      .byte.b	$40+(.LUM1/256)
     15  51be		       26		      .byte.b	$20+(.LUM2/256)
     16  51bf		       98		      .byte.b	$90+(.LUM3/256)
     17  51c0
     18  51c0
     19  51c0
     20  51c0
     21  51c0
     22  51c0				   .LUM1      SET	.LUM1 + .STEP1
     23  51c0				   .LUM2      SET	.LUM2 + .STEP2
     24  51c0				   .LUM3      SET	.LUM3 + .STEP3
     13  51c0					      REPEND
     14  51c0		       44		      .byte.b	$40+(.LUM1/256)
     15  51c1		       26		      .byte.b	$20+(.LUM2/256)
     16  51c2		       98		      .byte.b	$90+(.LUM3/256)
     17  51c3
     18  51c3
     19  51c3
     20  51c3
     21  51c3
     22  51c3				   .LUM1      SET	.LUM1 + .STEP1
     23  51c3				   .LUM2      SET	.LUM2 + .STEP2
     24  51c3				   .LUM3      SET	.LUM3 + .STEP3
     13  51c3					      REPEND
     14  51c3		       44		      .byte.b	$40+(.LUM1/256)
     15  51c4		       26		      .byte.b	$20+(.LUM2/256)
     16  51c5		       98		      .byte.b	$90+(.LUM3/256)
     17  51c6
     18  51c6
     19  51c6
     20  51c6
     21  51c6
     22  51c6				   .LUM1      SET	.LUM1 + .STEP1
     23  51c6				   .LUM2      SET	.LUM2 + .STEP2
     24  51c6				   .LUM3      SET	.LUM3 + .STEP3
     13  51c6					      REPEND
     14  51c6		       44		      .byte.b	$40+(.LUM1/256)
     15  51c7		       26		      .byte.b	$20+(.LUM2/256)
     16  51c8		       98		      .byte.b	$90+(.LUM3/256)
     17  51c9
     18  51c9
     19  51c9
     20  51c9
     21  51c9
     22  51c9				   .LUM1      SET	.LUM1 + .STEP1
     23  51c9				   .LUM2      SET	.LUM2 + .STEP2
     24  51c9				   .LUM3      SET	.LUM3 + .STEP3
     13  51c9					      REPEND
     14  51c9		       44		      .byte.b	$40+(.LUM1/256)
     15  51ca		       26		      .byte.b	$20+(.LUM2/256)
     16  51cb		       98		      .byte.b	$90+(.LUM3/256)
     17  51cc
     18  51cc
     19  51cc
     20  51cc
     21  51cc
     22  51cc				   .LUM1      SET	.LUM1 + .STEP1
     23  51cc				   .LUM2      SET	.LUM2 + .STEP2
     24  51cc				   .LUM3      SET	.LUM3 + .STEP3
     13  51cc					      REPEND
     14  51cc		       44		      .byte.b	$40+(.LUM1/256)
     15  51cd		       26		      .byte.b	$20+(.LUM2/256)
     16  51ce		       98		      .byte.b	$90+(.LUM3/256)
     17  51cf
     18  51cf
     19  51cf
     20  51cf
     21  51cf
     22  51cf				   .LUM1      SET	.LUM1 + .STEP1
     23  51cf				   .LUM2      SET	.LUM2 + .STEP2
     24  51cf				   .LUM3      SET	.LUM3 + .STEP3
     13  51cf					      REPEND
     14  51cf		       44		      .byte.b	$40+(.LUM1/256)
     15  51d0		       26		      .byte.b	$20+(.LUM2/256)
     16  51d1		       98		      .byte.b	$90+(.LUM3/256)
     17  51d2
     18  51d2
     19  51d2
     20  51d2
     21  51d2
     22  51d2				   .LUM1      SET	.LUM1 + .STEP1
     23  51d2				   .LUM2      SET	.LUM2 + .STEP2
     24  51d2				   .LUM3      SET	.LUM3 + .STEP3
     13  51d2					      REPEND
     14  51d2		       44		      .byte.b	$40+(.LUM1/256)
     15  51d3		       26		      .byte.b	$20+(.LUM2/256)
     16  51d4		       98		      .byte.b	$90+(.LUM3/256)
     17  51d5
     18  51d5
     19  51d5
     20  51d5
     21  51d5
     22  51d5				   .LUM1      SET	.LUM1 + .STEP1
     23  51d5				   .LUM2      SET	.LUM2 + .STEP2
     24  51d5				   .LUM3      SET	.LUM3 + .STEP3
     13  51d5					      REPEND
     14  51d5		       44		      .byte.b	$40+(.LUM1/256)
     15  51d6		       26		      .byte.b	$20+(.LUM2/256)
     16  51d7		       98		      .byte.b	$90+(.LUM3/256)
     17  51d8
     18  51d8
     19  51d8
     20  51d8
     21  51d8
     22  51d8				   .LUM1      SET	.LUM1 + .STEP1
     23  51d8				   .LUM2      SET	.LUM2 + .STEP2
     24  51d8				   .LUM3      SET	.LUM3 + .STEP3
     25  51d8					      REPEND
    257  51d8							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    258  51d8
    259  51d8							;    ECHO "PAL LUMS"
    260  51d8							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
      0  51d8				   colr_pal   LUMTABLE	$60, $80, $10, $6,$4,$8,$6,$4,$8
      1  51d8
      2  51d8
      3  51d8
      4  51d8
      5  51d8				   .LUM1      SET	$6*256
      6  51d8				   .LUM2      SET	$4*256
      7  51d8				   .LUM3      SET	$8*256
      8  51d8
      9  51d8		       00 00	   .STEP1     =	(256*($6-$6))/72
     10  51d8		       00 00	   .STEP2     =	(256*($4-$4))/72
     11  51d8		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  51d8
     13  51d8					      REPEAT	72
     14  51d8		       66		      .byte.b	$60+(.LUM1/256)
     15  51d9		       84		      .byte.b	$80+(.LUM2/256)
     16  51da		       18		      .byte.b	$10+(.LUM3/256)
     17  51db
     18  51db
     19  51db
     20  51db
     21  51db
     22  51db				   .LUM1      SET	.LUM1 + .STEP1
     23  51db				   .LUM2      SET	.LUM2 + .STEP2
     24  51db				   .LUM3      SET	.LUM3 + .STEP3
     13  51db					      REPEND
     14  51db		       66		      .byte.b	$60+(.LUM1/256)
     15  51dc		       84		      .byte.b	$80+(.LUM2/256)
     16  51dd		       18		      .byte.b	$10+(.LUM3/256)
     17  51de
     18  51de
     19  51de
     20  51de
     21  51de
     22  51de				   .LUM1      SET	.LUM1 + .STEP1
     23  51de				   .LUM2      SET	.LUM2 + .STEP2
     24  51de				   .LUM3      SET	.LUM3 + .STEP3
     13  51de					      REPEND
     14  51de		       66		      .byte.b	$60+(.LUM1/256)
     15  51df		       84		      .byte.b	$80+(.LUM2/256)
     16  51e0		       18		      .byte.b	$10+(.LUM3/256)
     17  51e1
     18  51e1
     19  51e1
     20  51e1
     21  51e1
     22  51e1				   .LUM1      SET	.LUM1 + .STEP1
     23  51e1				   .LUM2      SET	.LUM2 + .STEP2
     24  51e1				   .LUM3      SET	.LUM3 + .STEP3
     13  51e1					      REPEND
     14  51e1		       66		      .byte.b	$60+(.LUM1/256)
     15  51e2		       84		      .byte.b	$80+(.LUM2/256)
     16  51e3		       18		      .byte.b	$10+(.LUM3/256)
     17  51e4
     18  51e4
     19  51e4
     20  51e4
     21  51e4
     22  51e4				   .LUM1      SET	.LUM1 + .STEP1
     23  51e4				   .LUM2      SET	.LUM2 + .STEP2
     24  51e4				   .LUM3      SET	.LUM3 + .STEP3
     13  51e4					      REPEND
     14  51e4		       66		      .byte.b	$60+(.LUM1/256)
     15  51e5		       84		      .byte.b	$80+(.LUM2/256)
     16  51e6		       18		      .byte.b	$10+(.LUM3/256)
     17  51e7
     18  51e7
     19  51e7
     20  51e7
     21  51e7
     22  51e7				   .LUM1      SET	.LUM1 + .STEP1
     23  51e7				   .LUM2      SET	.LUM2 + .STEP2
     24  51e7				   .LUM3      SET	.LUM3 + .STEP3
     13  51e7					      REPEND
     14  51e7		       66		      .byte.b	$60+(.LUM1/256)
     15  51e8		       84		      .byte.b	$80+(.LUM2/256)
     16  51e9		       18		      .byte.b	$10+(.LUM3/256)
     17  51ea
     18  51ea
     19  51ea
     20  51ea
     21  51ea
     22  51ea				   .LUM1      SET	.LUM1 + .STEP1
     23  51ea				   .LUM2      SET	.LUM2 + .STEP2
     24  51ea				   .LUM3      SET	.LUM3 + .STEP3
     13  51ea					      REPEND
     14  51ea		       66		      .byte.b	$60+(.LUM1/256)
     15  51eb		       84		      .byte.b	$80+(.LUM2/256)
     16  51ec		       18		      .byte.b	$10+(.LUM3/256)
     17  51ed
     18  51ed
     19  51ed
     20  51ed
     21  51ed
     22  51ed				   .LUM1      SET	.LUM1 + .STEP1
     23  51ed				   .LUM2      SET	.LUM2 + .STEP2
     24  51ed				   .LUM3      SET	.LUM3 + .STEP3
     13  51ed					      REPEND
     14  51ed		       66		      .byte.b	$60+(.LUM1/256)
     15  51ee		       84		      .byte.b	$80+(.LUM2/256)
     16  51ef		       18		      .byte.b	$10+(.LUM3/256)
     17  51f0
     18  51f0
     19  51f0
     20  51f0
     21  51f0
     22  51f0				   .LUM1      SET	.LUM1 + .STEP1
     23  51f0				   .LUM2      SET	.LUM2 + .STEP2
     24  51f0				   .LUM3      SET	.LUM3 + .STEP3
     13  51f0					      REPEND
     14  51f0		       66		      .byte.b	$60+(.LUM1/256)
     15  51f1		       84		      .byte.b	$80+(.LUM2/256)
     16  51f2		       18		      .byte.b	$10+(.LUM3/256)
     17  51f3
     18  51f3
     19  51f3
     20  51f3
     21  51f3
     22  51f3				   .LUM1      SET	.LUM1 + .STEP1
     23  51f3				   .LUM2      SET	.LUM2 + .STEP2
     24  51f3				   .LUM3      SET	.LUM3 + .STEP3
     13  51f3					      REPEND
     14  51f3		       66		      .byte.b	$60+(.LUM1/256)
     15  51f4		       84		      .byte.b	$80+(.LUM2/256)
     16  51f5		       18		      .byte.b	$10+(.LUM3/256)
     17  51f6
     18  51f6
     19  51f6
     20  51f6
     21  51f6
     22  51f6				   .LUM1      SET	.LUM1 + .STEP1
     23  51f6				   .LUM2      SET	.LUM2 + .STEP2
     24  51f6				   .LUM3      SET	.LUM3 + .STEP3
     13  51f6					      REPEND
     14  51f6		       66		      .byte.b	$60+(.LUM1/256)
     15  51f7		       84		      .byte.b	$80+(.LUM2/256)
     16  51f8		       18		      .byte.b	$10+(.LUM3/256)
     17  51f9
     18  51f9
     19  51f9
     20  51f9
     21  51f9
     22  51f9				   .LUM1      SET	.LUM1 + .STEP1
     23  51f9				   .LUM2      SET	.LUM2 + .STEP2
     24  51f9				   .LUM3      SET	.LUM3 + .STEP3
     13  51f9					      REPEND
     14  51f9		       66		      .byte.b	$60+(.LUM1/256)
     15  51fa		       84		      .byte.b	$80+(.LUM2/256)
     16  51fb		       18		      .byte.b	$10+(.LUM3/256)
     17  51fc
     18  51fc
     19  51fc
     20  51fc
     21  51fc
     22  51fc				   .LUM1      SET	.LUM1 + .STEP1
     23  51fc				   .LUM2      SET	.LUM2 + .STEP2
     24  51fc				   .LUM3      SET	.LUM3 + .STEP3
     13  51fc					      REPEND
     14  51fc		       66		      .byte.b	$60+(.LUM1/256)
     15  51fd		       84		      .byte.b	$80+(.LUM2/256)
     16  51fe		       18		      .byte.b	$10+(.LUM3/256)
     17  51ff
     18  51ff
     19  51ff
     20  51ff
     21  51ff
     22  51ff				   .LUM1      SET	.LUM1 + .STEP1
     23  51ff				   .LUM2      SET	.LUM2 + .STEP2
     24  51ff				   .LUM3      SET	.LUM3 + .STEP3
     13  51ff					      REPEND
     14  51ff		       66		      .byte.b	$60+(.LUM1/256)
     15  5200		       84		      .byte.b	$80+(.LUM2/256)
     16  5201		       18		      .byte.b	$10+(.LUM3/256)
     17  5202
     18  5202
     19  5202
     20  5202
     21  5202
     22  5202				   .LUM1      SET	.LUM1 + .STEP1
     23  5202				   .LUM2      SET	.LUM2 + .STEP2
     24  5202				   .LUM3      SET	.LUM3 + .STEP3
     13  5202					      REPEND
     14  5202		       66		      .byte.b	$60+(.LUM1/256)
     15  5203		       84		      .byte.b	$80+(.LUM2/256)
     16  5204		       18		      .byte.b	$10+(.LUM3/256)
     17  5205
     18  5205
     19  5205
     20  5205
     21  5205
     22  5205				   .LUM1      SET	.LUM1 + .STEP1
     23  5205				   .LUM2      SET	.LUM2 + .STEP2
     24  5205				   .LUM3      SET	.LUM3 + .STEP3
     13  5205					      REPEND
     14  5205		       66		      .byte.b	$60+(.LUM1/256)
     15  5206		       84		      .byte.b	$80+(.LUM2/256)
     16  5207		       18		      .byte.b	$10+(.LUM3/256)
     17  5208
     18  5208
     19  5208
     20  5208
     21  5208
     22  5208				   .LUM1      SET	.LUM1 + .STEP1
     23  5208				   .LUM2      SET	.LUM2 + .STEP2
     24  5208				   .LUM3      SET	.LUM3 + .STEP3
     13  5208					      REPEND
     14  5208		       66		      .byte.b	$60+(.LUM1/256)
     15  5209		       84		      .byte.b	$80+(.LUM2/256)
     16  520a		       18		      .byte.b	$10+(.LUM3/256)
     17  520b
     18  520b
     19  520b
     20  520b
     21  520b
     22  520b				   .LUM1      SET	.LUM1 + .STEP1
     23  520b				   .LUM2      SET	.LUM2 + .STEP2
     24  520b				   .LUM3      SET	.LUM3 + .STEP3
     13  520b					      REPEND
     14  520b		       66		      .byte.b	$60+(.LUM1/256)
     15  520c		       84		      .byte.b	$80+(.LUM2/256)
     16  520d		       18		      .byte.b	$10+(.LUM3/256)
     17  520e
     18  520e
     19  520e
     20  520e
     21  520e
     22  520e				   .LUM1      SET	.LUM1 + .STEP1
     23  520e				   .LUM2      SET	.LUM2 + .STEP2
     24  520e				   .LUM3      SET	.LUM3 + .STEP3
     13  520e					      REPEND
     14  520e		       66		      .byte.b	$60+(.LUM1/256)
     15  520f		       84		      .byte.b	$80+(.LUM2/256)
     16  5210		       18		      .byte.b	$10+(.LUM3/256)
     17  5211
     18  5211
     19  5211
     20  5211
     21  5211
     22  5211				   .LUM1      SET	.LUM1 + .STEP1
     23  5211				   .LUM2      SET	.LUM2 + .STEP2
     24  5211				   .LUM3      SET	.LUM3 + .STEP3
     13  5211					      REPEND
     14  5211		       66		      .byte.b	$60+(.LUM1/256)
     15  5212		       84		      .byte.b	$80+(.LUM2/256)
     16  5213		       18		      .byte.b	$10+(.LUM3/256)
     17  5214
     18  5214
     19  5214
     20  5214
     21  5214
     22  5214				   .LUM1      SET	.LUM1 + .STEP1
     23  5214				   .LUM2      SET	.LUM2 + .STEP2
     24  5214				   .LUM3      SET	.LUM3 + .STEP3
     13  5214					      REPEND
     14  5214		       66		      .byte.b	$60+(.LUM1/256)
     15  5215		       84		      .byte.b	$80+(.LUM2/256)
     16  5216		       18		      .byte.b	$10+(.LUM3/256)
     17  5217
     18  5217
     19  5217
     20  5217
     21  5217
     22  5217				   .LUM1      SET	.LUM1 + .STEP1
     23  5217				   .LUM2      SET	.LUM2 + .STEP2
     24  5217				   .LUM3      SET	.LUM3 + .STEP3
     13  5217					      REPEND
     14  5217		       66		      .byte.b	$60+(.LUM1/256)
     15  5218		       84		      .byte.b	$80+(.LUM2/256)
     16  5219		       18		      .byte.b	$10+(.LUM3/256)
     17  521a
     18  521a
     19  521a
     20  521a
     21  521a
     22  521a				   .LUM1      SET	.LUM1 + .STEP1
     23  521a				   .LUM2      SET	.LUM2 + .STEP2
     24  521a				   .LUM3      SET	.LUM3 + .STEP3
     13  521a					      REPEND
     14  521a		       66		      .byte.b	$60+(.LUM1/256)
     15  521b		       84		      .byte.b	$80+(.LUM2/256)
     16  521c		       18		      .byte.b	$10+(.LUM3/256)
     17  521d
     18  521d
     19  521d
     20  521d
     21  521d
     22  521d				   .LUM1      SET	.LUM1 + .STEP1
     23  521d				   .LUM2      SET	.LUM2 + .STEP2
     24  521d				   .LUM3      SET	.LUM3 + .STEP3
     13  521d					      REPEND
     14  521d		       66		      .byte.b	$60+(.LUM1/256)
     15  521e		       84		      .byte.b	$80+(.LUM2/256)
     16  521f		       18		      .byte.b	$10+(.LUM3/256)
     17  5220
     18  5220
     19  5220
     20  5220
     21  5220
     22  5220				   .LUM1      SET	.LUM1 + .STEP1
     23  5220				   .LUM2      SET	.LUM2 + .STEP2
     24  5220				   .LUM3      SET	.LUM3 + .STEP3
     13  5220					      REPEND
     14  5220		       66		      .byte.b	$60+(.LUM1/256)
     15  5221		       84		      .byte.b	$80+(.LUM2/256)
     16  5222		       18		      .byte.b	$10+(.LUM3/256)
     17  5223
     18  5223
     19  5223
     20  5223
     21  5223
     22  5223				   .LUM1      SET	.LUM1 + .STEP1
     23  5223				   .LUM2      SET	.LUM2 + .STEP2
     24  5223				   .LUM3      SET	.LUM3 + .STEP3
     13  5223					      REPEND
     14  5223		       66		      .byte.b	$60+(.LUM1/256)
     15  5224		       84		      .byte.b	$80+(.LUM2/256)
     16  5225		       18		      .byte.b	$10+(.LUM3/256)
     17  5226
     18  5226
     19  5226
     20  5226
     21  5226
     22  5226				   .LUM1      SET	.LUM1 + .STEP1
     23  5226				   .LUM2      SET	.LUM2 + .STEP2
     24  5226				   .LUM3      SET	.LUM3 + .STEP3
     13  5226					      REPEND
     14  5226		       66		      .byte.b	$60+(.LUM1/256)
     15  5227		       84		      .byte.b	$80+(.LUM2/256)
     16  5228		       18		      .byte.b	$10+(.LUM3/256)
     17  5229
     18  5229
     19  5229
     20  5229
     21  5229
     22  5229				   .LUM1      SET	.LUM1 + .STEP1
     23  5229				   .LUM2      SET	.LUM2 + .STEP2
     24  5229				   .LUM3      SET	.LUM3 + .STEP3
     13  5229					      REPEND
     14  5229		       66		      .byte.b	$60+(.LUM1/256)
     15  522a		       84		      .byte.b	$80+(.LUM2/256)
     16  522b		       18		      .byte.b	$10+(.LUM3/256)
     17  522c
     18  522c
     19  522c
     20  522c
     21  522c
     22  522c				   .LUM1      SET	.LUM1 + .STEP1
     23  522c				   .LUM2      SET	.LUM2 + .STEP2
     24  522c				   .LUM3      SET	.LUM3 + .STEP3
     13  522c					      REPEND
     14  522c		       66		      .byte.b	$60+(.LUM1/256)
     15  522d		       84		      .byte.b	$80+(.LUM2/256)
     16  522e		       18		      .byte.b	$10+(.LUM3/256)
     17  522f
     18  522f
     19  522f
     20  522f
     21  522f
     22  522f				   .LUM1      SET	.LUM1 + .STEP1
     23  522f				   .LUM2      SET	.LUM2 + .STEP2
     24  522f				   .LUM3      SET	.LUM3 + .STEP3
     13  522f					      REPEND
     14  522f		       66		      .byte.b	$60+(.LUM1/256)
     15  5230		       84		      .byte.b	$80+(.LUM2/256)
     16  5231		       18		      .byte.b	$10+(.LUM3/256)
     17  5232
     18  5232
     19  5232
     20  5232
     21  5232
     22  5232				   .LUM1      SET	.LUM1 + .STEP1
     23  5232				   .LUM2      SET	.LUM2 + .STEP2
     24  5232				   .LUM3      SET	.LUM3 + .STEP3
     13  5232					      REPEND
     14  5232		       66		      .byte.b	$60+(.LUM1/256)
     15  5233		       84		      .byte.b	$80+(.LUM2/256)
     16  5234		       18		      .byte.b	$10+(.LUM3/256)
     17  5235
     18  5235
     19  5235
     20  5235
     21  5235
     22  5235				   .LUM1      SET	.LUM1 + .STEP1
     23  5235				   .LUM2      SET	.LUM2 + .STEP2
     24  5235				   .LUM3      SET	.LUM3 + .STEP3
     13  5235					      REPEND
     14  5235		       66		      .byte.b	$60+(.LUM1/256)
     15  5236		       84		      .byte.b	$80+(.LUM2/256)
     16  5237		       18		      .byte.b	$10+(.LUM3/256)
     17  5238
     18  5238
     19  5238
     20  5238
     21  5238
     22  5238				   .LUM1      SET	.LUM1 + .STEP1
     23  5238				   .LUM2      SET	.LUM2 + .STEP2
     24  5238				   .LUM3      SET	.LUM3 + .STEP3
     13  5238					      REPEND
     14  5238		       66		      .byte.b	$60+(.LUM1/256)
     15  5239		       84		      .byte.b	$80+(.LUM2/256)
     16  523a		       18		      .byte.b	$10+(.LUM3/256)
     17  523b
     18  523b
     19  523b
     20  523b
     21  523b
     22  523b				   .LUM1      SET	.LUM1 + .STEP1
     23  523b				   .LUM2      SET	.LUM2 + .STEP2
     24  523b				   .LUM3      SET	.LUM3 + .STEP3
     13  523b					      REPEND
     14  523b		       66		      .byte.b	$60+(.LUM1/256)
     15  523c		       84		      .byte.b	$80+(.LUM2/256)
     16  523d		       18		      .byte.b	$10+(.LUM3/256)
     17  523e
     18  523e
     19  523e
     20  523e
     21  523e
     22  523e				   .LUM1      SET	.LUM1 + .STEP1
     23  523e				   .LUM2      SET	.LUM2 + .STEP2
     24  523e				   .LUM3      SET	.LUM3 + .STEP3
     13  523e					      REPEND
     14  523e		       66		      .byte.b	$60+(.LUM1/256)
     15  523f		       84		      .byte.b	$80+(.LUM2/256)
     16  5240		       18		      .byte.b	$10+(.LUM3/256)
     17  5241
     18  5241
     19  5241
     20  5241
     21  5241
     22  5241				   .LUM1      SET	.LUM1 + .STEP1
     23  5241				   .LUM2      SET	.LUM2 + .STEP2
     24  5241				   .LUM3      SET	.LUM3 + .STEP3
     13  5241					      REPEND
     14  5241		       66		      .byte.b	$60+(.LUM1/256)
     15  5242		       84		      .byte.b	$80+(.LUM2/256)
     16  5243		       18		      .byte.b	$10+(.LUM3/256)
     17  5244
     18  5244
     19  5244
     20  5244
     21  5244
     22  5244				   .LUM1      SET	.LUM1 + .STEP1
     23  5244				   .LUM2      SET	.LUM2 + .STEP2
     24  5244				   .LUM3      SET	.LUM3 + .STEP3
     13  5244					      REPEND
     14  5244		       66		      .byte.b	$60+(.LUM1/256)
     15  5245		       84		      .byte.b	$80+(.LUM2/256)
     16  5246		       18		      .byte.b	$10+(.LUM3/256)
     17  5247
     18  5247
     19  5247
     20  5247
     21  5247
     22  5247				   .LUM1      SET	.LUM1 + .STEP1
     23  5247				   .LUM2      SET	.LUM2 + .STEP2
     24  5247				   .LUM3      SET	.LUM3 + .STEP3
     13  5247					      REPEND
     14  5247		       66		      .byte.b	$60+(.LUM1/256)
     15  5248		       84		      .byte.b	$80+(.LUM2/256)
     16  5249		       18		      .byte.b	$10+(.LUM3/256)
     17  524a
     18  524a
     19  524a
     20  524a
     21  524a
     22  524a				   .LUM1      SET	.LUM1 + .STEP1
     23  524a				   .LUM2      SET	.LUM2 + .STEP2
     24  524a				   .LUM3      SET	.LUM3 + .STEP3
     13  524a					      REPEND
     14  524a		       66		      .byte.b	$60+(.LUM1/256)
     15  524b		       84		      .byte.b	$80+(.LUM2/256)
     16  524c		       18		      .byte.b	$10+(.LUM3/256)
     17  524d
     18  524d
     19  524d
     20  524d
     21  524d
     22  524d				   .LUM1      SET	.LUM1 + .STEP1
     23  524d				   .LUM2      SET	.LUM2 + .STEP2
     24  524d				   .LUM3      SET	.LUM3 + .STEP3
     13  524d					      REPEND
     14  524d		       66		      .byte.b	$60+(.LUM1/256)
     15  524e		       84		      .byte.b	$80+(.LUM2/256)
     16  524f		       18		      .byte.b	$10+(.LUM3/256)
     17  5250
     18  5250
     19  5250
     20  5250
     21  5250
     22  5250				   .LUM1      SET	.LUM1 + .STEP1
     23  5250				   .LUM2      SET	.LUM2 + .STEP2
     24  5250				   .LUM3      SET	.LUM3 + .STEP3
     13  5250					      REPEND
     14  5250		       66		      .byte.b	$60+(.LUM1/256)
     15  5251		       84		      .byte.b	$80+(.LUM2/256)
     16  5252		       18		      .byte.b	$10+(.LUM3/256)
     17  5253
     18  5253
     19  5253
     20  5253
     21  5253
     22  5253				   .LUM1      SET	.LUM1 + .STEP1
     23  5253				   .LUM2      SET	.LUM2 + .STEP2
     24  5253				   .LUM3      SET	.LUM3 + .STEP3
     13  5253					      REPEND
     14  5253		       66		      .byte.b	$60+(.LUM1/256)
     15  5254		       84		      .byte.b	$80+(.LUM2/256)
     16  5255		       18		      .byte.b	$10+(.LUM3/256)
     17  5256
     18  5256
     19  5256
     20  5256
     21  5256
     22  5256				   .LUM1      SET	.LUM1 + .STEP1
     23  5256				   .LUM2      SET	.LUM2 + .STEP2
     24  5256				   .LUM3      SET	.LUM3 + .STEP3
     13  5256					      REPEND
     14  5256		       66		      .byte.b	$60+(.LUM1/256)
     15  5257		       84		      .byte.b	$80+(.LUM2/256)
     16  5258		       18		      .byte.b	$10+(.LUM3/256)
     17  5259
     18  5259
     19  5259
     20  5259
     21  5259
     22  5259				   .LUM1      SET	.LUM1 + .STEP1
     23  5259				   .LUM2      SET	.LUM2 + .STEP2
     24  5259				   .LUM3      SET	.LUM3 + .STEP3
     13  5259					      REPEND
     14  5259		       66		      .byte.b	$60+(.LUM1/256)
     15  525a		       84		      .byte.b	$80+(.LUM2/256)
     16  525b		       18		      .byte.b	$10+(.LUM3/256)
     17  525c
     18  525c
     19  525c
     20  525c
     21  525c
     22  525c				   .LUM1      SET	.LUM1 + .STEP1
     23  525c				   .LUM2      SET	.LUM2 + .STEP2
     24  525c				   .LUM3      SET	.LUM3 + .STEP3
     13  525c					      REPEND
     14  525c		       66		      .byte.b	$60+(.LUM1/256)
     15  525d		       84		      .byte.b	$80+(.LUM2/256)
     16  525e		       18		      .byte.b	$10+(.LUM3/256)
     17  525f
     18  525f
     19  525f
     20  525f
     21  525f
     22  525f				   .LUM1      SET	.LUM1 + .STEP1
     23  525f				   .LUM2      SET	.LUM2 + .STEP2
     24  525f				   .LUM3      SET	.LUM3 + .STEP3
     13  525f					      REPEND
     14  525f		       66		      .byte.b	$60+(.LUM1/256)
     15  5260		       84		      .byte.b	$80+(.LUM2/256)
     16  5261		       18		      .byte.b	$10+(.LUM3/256)
     17  5262
     18  5262
     19  5262
     20  5262
     21  5262
     22  5262				   .LUM1      SET	.LUM1 + .STEP1
     23  5262				   .LUM2      SET	.LUM2 + .STEP2
     24  5262				   .LUM3      SET	.LUM3 + .STEP3
     13  5262					      REPEND
     14  5262		       66		      .byte.b	$60+(.LUM1/256)
     15  5263		       84		      .byte.b	$80+(.LUM2/256)
     16  5264		       18		      .byte.b	$10+(.LUM3/256)
     17  5265
     18  5265
     19  5265
     20  5265
     21  5265
     22  5265				   .LUM1      SET	.LUM1 + .STEP1
     23  5265				   .LUM2      SET	.LUM2 + .STEP2
     24  5265				   .LUM3      SET	.LUM3 + .STEP3
     13  5265					      REPEND
     14  5265		       66		      .byte.b	$60+(.LUM1/256)
     15  5266		       84		      .byte.b	$80+(.LUM2/256)
     16  5267		       18		      .byte.b	$10+(.LUM3/256)
     17  5268
     18  5268
     19  5268
     20  5268
     21  5268
     22  5268				   .LUM1      SET	.LUM1 + .STEP1
     23  5268				   .LUM2      SET	.LUM2 + .STEP2
     24  5268				   .LUM3      SET	.LUM3 + .STEP3
     13  5268					      REPEND
     14  5268		       66		      .byte.b	$60+(.LUM1/256)
     15  5269		       84		      .byte.b	$80+(.LUM2/256)
     16  526a		       18		      .byte.b	$10+(.LUM3/256)
     17  526b
     18  526b
     19  526b
     20  526b
     21  526b
     22  526b				   .LUM1      SET	.LUM1 + .STEP1
     23  526b				   .LUM2      SET	.LUM2 + .STEP2
     24  526b				   .LUM3      SET	.LUM3 + .STEP3
     13  526b					      REPEND
     14  526b		       66		      .byte.b	$60+(.LUM1/256)
     15  526c		       84		      .byte.b	$80+(.LUM2/256)
     16  526d		       18		      .byte.b	$10+(.LUM3/256)
     17  526e
     18  526e
     19  526e
     20  526e
     21  526e
     22  526e				   .LUM1      SET	.LUM1 + .STEP1
     23  526e				   .LUM2      SET	.LUM2 + .STEP2
     24  526e				   .LUM3      SET	.LUM3 + .STEP3
     13  526e					      REPEND
     14  526e		       66		      .byte.b	$60+(.LUM1/256)
     15  526f		       84		      .byte.b	$80+(.LUM2/256)
     16  5270		       18		      .byte.b	$10+(.LUM3/256)
     17  5271
     18  5271
     19  5271
     20  5271
     21  5271
     22  5271				   .LUM1      SET	.LUM1 + .STEP1
     23  5271				   .LUM2      SET	.LUM2 + .STEP2
     24  5271				   .LUM3      SET	.LUM3 + .STEP3
     13  5271					      REPEND
     14  5271		       66		      .byte.b	$60+(.LUM1/256)
     15  5272		       84		      .byte.b	$80+(.LUM2/256)
     16  5273		       18		      .byte.b	$10+(.LUM3/256)
     17  5274
     18  5274
     19  5274
     20  5274
     21  5274
     22  5274				   .LUM1      SET	.LUM1 + .STEP1
     23  5274				   .LUM2      SET	.LUM2 + .STEP2
     24  5274				   .LUM3      SET	.LUM3 + .STEP3
     13  5274					      REPEND
     14  5274		       66		      .byte.b	$60+(.LUM1/256)
     15  5275		       84		      .byte.b	$80+(.LUM2/256)
     16  5276		       18		      .byte.b	$10+(.LUM3/256)
     17  5277
     18  5277
     19  5277
     20  5277
     21  5277
     22  5277				   .LUM1      SET	.LUM1 + .STEP1
     23  5277				   .LUM2      SET	.LUM2 + .STEP2
     24  5277				   .LUM3      SET	.LUM3 + .STEP3
     13  5277					      REPEND
     14  5277		       66		      .byte.b	$60+(.LUM1/256)
     15  5278		       84		      .byte.b	$80+(.LUM2/256)
     16  5279		       18		      .byte.b	$10+(.LUM3/256)
     17  527a
     18  527a
     19  527a
     20  527a
     21  527a
     22  527a				   .LUM1      SET	.LUM1 + .STEP1
     23  527a				   .LUM2      SET	.LUM2 + .STEP2
     24  527a				   .LUM3      SET	.LUM3 + .STEP3
     13  527a					      REPEND
     14  527a		       66		      .byte.b	$60+(.LUM1/256)
     15  527b		       84		      .byte.b	$80+(.LUM2/256)
     16  527c		       18		      .byte.b	$10+(.LUM3/256)
     17  527d
     18  527d
     19  527d
     20  527d
     21  527d
     22  527d				   .LUM1      SET	.LUM1 + .STEP1
     23  527d				   .LUM2      SET	.LUM2 + .STEP2
     24  527d				   .LUM3      SET	.LUM3 + .STEP3
     13  527d					      REPEND
     14  527d		       66		      .byte.b	$60+(.LUM1/256)
     15  527e		       84		      .byte.b	$80+(.LUM2/256)
     16  527f		       18		      .byte.b	$10+(.LUM3/256)
     17  5280
     18  5280
     19  5280
     20  5280
     21  5280
     22  5280				   .LUM1      SET	.LUM1 + .STEP1
     23  5280				   .LUM2      SET	.LUM2 + .STEP2
     24  5280				   .LUM3      SET	.LUM3 + .STEP3
     13  5280					      REPEND
     14  5280		       66		      .byte.b	$60+(.LUM1/256)
     15  5281		       84		      .byte.b	$80+(.LUM2/256)
     16  5282		       18		      .byte.b	$10+(.LUM3/256)
     17  5283
     18  5283
     19  5283
     20  5283
     21  5283
     22  5283				   .LUM1      SET	.LUM1 + .STEP1
     23  5283				   .LUM2      SET	.LUM2 + .STEP2
     24  5283				   .LUM3      SET	.LUM3 + .STEP3
     13  5283					      REPEND
     14  5283		       66		      .byte.b	$60+(.LUM1/256)
     15  5284		       84		      .byte.b	$80+(.LUM2/256)
     16  5285		       18		      .byte.b	$10+(.LUM3/256)
     17  5286
     18  5286
     19  5286
     20  5286
     21  5286
     22  5286				   .LUM1      SET	.LUM1 + .STEP1
     23  5286				   .LUM2      SET	.LUM2 + .STEP2
     24  5286				   .LUM3      SET	.LUM3 + .STEP3
     13  5286					      REPEND
     14  5286		       66		      .byte.b	$60+(.LUM1/256)
     15  5287		       84		      .byte.b	$80+(.LUM2/256)
     16  5288		       18		      .byte.b	$10+(.LUM3/256)
     17  5289
     18  5289
     19  5289
     20  5289
     21  5289
     22  5289				   .LUM1      SET	.LUM1 + .STEP1
     23  5289				   .LUM2      SET	.LUM2 + .STEP2
     24  5289				   .LUM3      SET	.LUM3 + .STEP3
     13  5289					      REPEND
     14  5289		       66		      .byte.b	$60+(.LUM1/256)
     15  528a		       84		      .byte.b	$80+(.LUM2/256)
     16  528b		       18		      .byte.b	$10+(.LUM3/256)
     17  528c
     18  528c
     19  528c
     20  528c
     21  528c
     22  528c				   .LUM1      SET	.LUM1 + .STEP1
     23  528c				   .LUM2      SET	.LUM2 + .STEP2
     24  528c				   .LUM3      SET	.LUM3 + .STEP3
     13  528c					      REPEND
     14  528c		       66		      .byte.b	$60+(.LUM1/256)
     15  528d		       84		      .byte.b	$80+(.LUM2/256)
     16  528e		       18		      .byte.b	$10+(.LUM3/256)
     17  528f
     18  528f
     19  528f
     20  528f
     21  528f
     22  528f				   .LUM1      SET	.LUM1 + .STEP1
     23  528f				   .LUM2      SET	.LUM2 + .STEP2
     24  528f				   .LUM3      SET	.LUM3 + .STEP3
     13  528f					      REPEND
     14  528f		       66		      .byte.b	$60+(.LUM1/256)
     15  5290		       84		      .byte.b	$80+(.LUM2/256)
     16  5291		       18		      .byte.b	$10+(.LUM3/256)
     17  5292
     18  5292
     19  5292
     20  5292
     21  5292
     22  5292				   .LUM1      SET	.LUM1 + .STEP1
     23  5292				   .LUM2      SET	.LUM2 + .STEP2
     24  5292				   .LUM3      SET	.LUM3 + .STEP3
     13  5292					      REPEND
     14  5292		       66		      .byte.b	$60+(.LUM1/256)
     15  5293		       84		      .byte.b	$80+(.LUM2/256)
     16  5294		       18		      .byte.b	$10+(.LUM3/256)
     17  5295
     18  5295
     19  5295
     20  5295
     21  5295
     22  5295				   .LUM1      SET	.LUM1 + .STEP1
     23  5295				   .LUM2      SET	.LUM2 + .STEP2
     24  5295				   .LUM3      SET	.LUM3 + .STEP3
     13  5295					      REPEND
     14  5295		       66		      .byte.b	$60+(.LUM1/256)
     15  5296		       84		      .byte.b	$80+(.LUM2/256)
     16  5297		       18		      .byte.b	$10+(.LUM3/256)
     17  5298
     18  5298
     19  5298
     20  5298
     21  5298
     22  5298				   .LUM1      SET	.LUM1 + .STEP1
     23  5298				   .LUM2      SET	.LUM2 + .STEP2
     24  5298				   .LUM3      SET	.LUM3 + .STEP3
     13  5298					      REPEND
     14  5298		       66		      .byte.b	$60+(.LUM1/256)
     15  5299		       84		      .byte.b	$80+(.LUM2/256)
     16  529a		       18		      .byte.b	$10+(.LUM3/256)
     17  529b
     18  529b
     19  529b
     20  529b
     21  529b
     22  529b				   .LUM1      SET	.LUM1 + .STEP1
     23  529b				   .LUM2      SET	.LUM2 + .STEP2
     24  529b				   .LUM3      SET	.LUM3 + .STEP3
     13  529b					      REPEND
     14  529b		       66		      .byte.b	$60+(.LUM1/256)
     15  529c		       84		      .byte.b	$80+(.LUM2/256)
     16  529d		       18		      .byte.b	$10+(.LUM3/256)
     17  529e
     18  529e
     19  529e
     20  529e
     21  529e
     22  529e				   .LUM1      SET	.LUM1 + .STEP1
     23  529e				   .LUM2      SET	.LUM2 + .STEP2
     24  529e				   .LUM3      SET	.LUM3 + .STEP3
     13  529e					      REPEND
     14  529e		       66		      .byte.b	$60+(.LUM1/256)
     15  529f		       84		      .byte.b	$80+(.LUM2/256)
     16  52a0		       18		      .byte.b	$10+(.LUM3/256)
     17  52a1
     18  52a1
     19  52a1
     20  52a1
     21  52a1
     22  52a1				   .LUM1      SET	.LUM1 + .STEP1
     23  52a1				   .LUM2      SET	.LUM2 + .STEP2
     24  52a1				   .LUM3      SET	.LUM3 + .STEP3
     13  52a1					      REPEND
     14  52a1		       66		      .byte.b	$60+(.LUM1/256)
     15  52a2		       84		      .byte.b	$80+(.LUM2/256)
     16  52a3		       18		      .byte.b	$10+(.LUM3/256)
     17  52a4
     18  52a4
     19  52a4
     20  52a4
     21  52a4
     22  52a4				   .LUM1      SET	.LUM1 + .STEP1
     23  52a4				   .LUM2      SET	.LUM2 + .STEP2
     24  52a4				   .LUM3      SET	.LUM3 + .STEP3
     13  52a4					      REPEND
     14  52a4		       66		      .byte.b	$60+(.LUM1/256)
     15  52a5		       84		      .byte.b	$80+(.LUM2/256)
     16  52a6		       18		      .byte.b	$10+(.LUM3/256)
     17  52a7
     18  52a7
     19  52a7
     20  52a7
     21  52a7
     22  52a7				   .LUM1      SET	.LUM1 + .STEP1
     23  52a7				   .LUM2      SET	.LUM2 + .STEP2
     24  52a7				   .LUM3      SET	.LUM3 + .STEP3
     13  52a7					      REPEND
     14  52a7		       66		      .byte.b	$60+(.LUM1/256)
     15  52a8		       84		      .byte.b	$80+(.LUM2/256)
     16  52a9		       18		      .byte.b	$10+(.LUM3/256)
     17  52aa
     18  52aa
     19  52aa
     20  52aa
     21  52aa
     22  52aa				   .LUM1      SET	.LUM1 + .STEP1
     23  52aa				   .LUM2      SET	.LUM2 + .STEP2
     24  52aa				   .LUM3      SET	.LUM3 + .STEP3
     13  52aa					      REPEND
     14  52aa		       66		      .byte.b	$60+(.LUM1/256)
     15  52ab		       84		      .byte.b	$80+(.LUM2/256)
     16  52ac		       18		      .byte.b	$10+(.LUM3/256)
     17  52ad
     18  52ad
     19  52ad
     20  52ad
     21  52ad
     22  52ad				   .LUM1      SET	.LUM1 + .STEP1
     23  52ad				   .LUM2      SET	.LUM2 + .STEP2
     24  52ad				   .LUM3      SET	.LUM3 + .STEP3
     13  52ad					      REPEND
     14  52ad		       66		      .byte.b	$60+(.LUM1/256)
     15  52ae		       84		      .byte.b	$80+(.LUM2/256)
     16  52af		       18		      .byte.b	$10+(.LUM3/256)
     17  52b0
     18  52b0
     19  52b0
     20  52b0
     21  52b0
     22  52b0				   .LUM1      SET	.LUM1 + .STEP1
     23  52b0				   .LUM2      SET	.LUM2 + .STEP2
     24  52b0				   .LUM3      SET	.LUM3 + .STEP3
     25  52b0					      REPEND
    262  52b0							;colr_pal	  LUMTABLE $90, $20, $60, $6,$A,$a,$C,$6,$8
    263  52b0
------- FILE titleData.asm LEVEL 3 PASS 5
      0  52b0					      include	"titleData.asm"
      1  52b0				   COL_0
      2  52b0		       00		      .byte.b	0	;R (71)
      3  52b1		       00		      .byte.b	0	;G
      4  52b2		       00		      .byte.b	0	;B
      5  52b3		       40		      .byte.b	64	;R (70)
      6  52b4		       40		      .byte.b	64	;G
      7  52b5		       00		      .byte.b	0	;B
      8  52b6		       00		      .byte.b	0	;R (69)
      9  52b7		       00		      .byte.b	0	;G
     10  52b8		       00		      .byte.b	0	;B
     11  52b9		       00		      .byte.b	0	;R (68)
     12  52ba		       80		      .byte.b	128	;G
     13  52bb		       00		      .byte.b	0	;B
     14  52bc		       00		      .byte.b	0	;R (67)
     15  52bd		       20		      .byte.b	32	;G
     16  52be		       00		      .byte.b	0	;B
     17  52bf		       80		      .byte.b	128	;R (66)
     18  52c0		       80		      .byte.b	128	;G
     19  52c1		       00		      .byte.b	0	;B
     20  52c2		       c0		      .byte.b	192	;R (65)
     21  52c3		       c0		      .byte.b	192	;G
     22  52c4		       00		      .byte.b	0	;B
     23  52c5		       40		      .byte.b	64	;R (64)
     24  52c6		       c0		      .byte.b	192	;G
     25  52c7		       00		      .byte.b	0	;B
     26  52c8		       00		      .byte.b	0	;R (63)
     27  52c9		       a0		      .byte.b	160	;G
     28  52ca		       00		      .byte.b	0	;B
     29  52cb		       10		      .byte.b	16	;R (62)
     30  52cc		       70		      .byte.b	112	;G
     31  52cd		       00		      .byte.b	0	;B
     32  52ce		       00		      .byte.b	0	;R (61)
     33  52cf		       80		      .byte.b	128	;G
     34  52d0		       40		      .byte.b	64	;B
     35  52d1		       00		      .byte.b	0	;R (60)
     36  52d2		       c0		      .byte.b	192	;G
     37  52d3		       00		      .byte.b	0	;B
     38  52d4		       00		      .byte.b	0	;R (59)
     39  52d5		       c0		      .byte.b	192	;G
     40  52d6		       00		      .byte.b	0	;B
     41  52d7		       00		      .byte.b	0	;R (58)
     42  52d8		       40		      .byte.b	64	;G
     43  52d9		       00		      .byte.b	0	;B
     44  52da		       00		      .byte.b	0	;R (57)
     45  52db		       c0		      .byte.b	192	;G
     46  52dc		       00		      .byte.b	0	;B
     47  52dd		       00		      .byte.b	0	;R (56)
     48  52de		       60		      .byte.b	96	;G
     49  52df		       00		      .byte.b	0	;B
     50  52e0		       00		      .byte.b	0	;R (55)
     51  52e1		       80		      .byte.b	128	;G
     52  52e2		       00		      .byte.b	0	;B
     53  52e3		       00		      .byte.b	0	;R (54)
     54  52e4		       40		      .byte.b	64	;G
     55  52e5		       00		      .byte.b	0	;B
     56  52e6		       00		      .byte.b	0	;R (53)
     57  52e7		       80		      .byte.b	128	;G
     58  52e8		       00		      .byte.b	0	;B
     59  52e9		       00		      .byte.b	0	;R (52)
     60  52ea		       80		      .byte.b	128	;G
     61  52eb		       00		      .byte.b	0	;B
     62  52ec		       00		      .byte.b	0	;R (51)
     63  52ed		       10		      .byte.b	16	;G
     64  52ee		       00		      .byte.b	0	;B
     65  52ef		       00		      .byte.b	0	;R (50)
     66  52f0		       00		      .byte.b	0	;G
     67  52f1		       00		      .byte.b	0	;B
     68  52f2		       00		      .byte.b	0	;R (49)
     69  52f3		       00		      .byte.b	0	;G
     70  52f4		       00		      .byte.b	0	;B
     71  52f5		       00		      .byte.b	0	;R (48)
     72  52f6		       00		      .byte.b	0	;G
     73  52f7		       00		      .byte.b	0	;B
     74  52f8		       00		      .byte.b	0	;R (47)
     75  52f9		       00		      .byte.b	0	;G
     76  52fa		       00		      .byte.b	0	;B
     77  52fb		       00		      .byte.b	0	;R (46)
     78  52fc		       40		      .byte.b	64	;G
     79  52fd		       00		      .byte.b	0	;B
     80  52fe		       00		      .byte.b	0	;R (45)
     81  52ff		       00		      .byte.b	0	;G
     82  5300		       00		      .byte.b	0	;B
     83  5301		       00		      .byte.b	0	;R (44)
     84  5302		       00		      .byte.b	0	;G
     85  5303		       00		      .byte.b	0	;B
     86  5304		       00		      .byte.b	0	;R (43)
     87  5305		       00		      .byte.b	0	;G
     88  5306		       00		      .byte.b	0	;B
     89  5307		       00		      .byte.b	0	;R (42)
     90  5308		       40		      .byte.b	64	;G
     91  5309		       00		      .byte.b	0	;B
     92  530a		       00		      .byte.b	0	;R (41)
     93  530b		       00		      .byte.b	0	;G
     94  530c		       00		      .byte.b	0	;B
     95  530d		       00		      .byte.b	0	;R (40)
     96  530e		       00		      .byte.b	0	;G
     97  530f		       00		      .byte.b	0	;B
     98  5310		       00		      .byte.b	0	;R (39)
     99  5311		       20		      .byte.b	32	;G
    100  5312		       00		      .byte.b	0	;B
    101  5313		       00		      .byte.b	0	;R (38)
    102  5314		       00		      .byte.b	0	;G
    103  5315		       00		      .byte.b	0	;B
    104  5316		       00		      .byte.b	0	;R (37)
    105  5317		       10		      .byte.b	16	;G
    106  5318		       00		      .byte.b	0	;B
    107  5319		       00		      .byte.b	0	;R (36)
    108  531a		       00		      .byte.b	0	;G
    109  531b		       00		      .byte.b	0	;B
    110  531c		       00		      .byte.b	0	;R (35)
    111  531d		       40		      .byte.b	64	;G
    112  531e		       00		      .byte.b	0	;B
    113  531f		       00		      .byte.b	0	;R (34)
    114  5320		       20		      .byte.b	32	;G
    115  5321		       00		      .byte.b	0	;B
    116  5322		       00		      .byte.b	0	;R (33)
    117  5323		       00		      .byte.b	0	;G
    118  5324		       00		      .byte.b	0	;B
    119  5325		       00		      .byte.b	0	;R (32)
    120  5326		       00		      .byte.b	0	;G
    121  5327		       00		      .byte.b	0	;B
    122  5328		       00		      .byte.b	0	;R (31)
    123  5329		       20		      .byte.b	32	;G
    124  532a		       00		      .byte.b	0	;B
    125  532b		       00		      .byte.b	0	;R (30)
    126  532c		       00		      .byte.b	0	;G
    127  532d		       00		      .byte.b	0	;B
    128  532e		       00		      .byte.b	0	;R (29)
    129  532f		       80		      .byte.b	128	;G
    130  5330		       00		      .byte.b	0	;B
    131  5331		       00		      .byte.b	0	;R (28)
    132  5332		       00		      .byte.b	0	;G
    133  5333		       00		      .byte.b	0	;B
    134  5334		       00		      .byte.b	0	;R (27)
    135  5335		       20		      .byte.b	32	;G
    136  5336		       00		      .byte.b	0	;B
    137  5337		       00		      .byte.b	0	;R (26)
    138  5338		       00		      .byte.b	0	;G
    139  5339		       00		      .byte.b	0	;B
    140  533a		       00		      .byte.b	0	;R (25)
    141  533b		       00		      .byte.b	0	;G
    142  533c		       00		      .byte.b	0	;B
    143  533d		       00		      .byte.b	0	;R (24)
    144  533e		       20		      .byte.b	32	;G
    145  533f		       00		      .byte.b	0	;B
    146  5340		       00		      .byte.b	0	;R (23)
    147  5341		       00		      .byte.b	0	;G
    148  5342		       00		      .byte.b	0	;B
    149  5343		       00		      .byte.b	0	;R (22)
    150  5344		       00		      .byte.b	0	;G
    151  5345		       00		      .byte.b	0	;B
    152  5346		       00		      .byte.b	0	;R (21)
    153  5347		       20		      .byte.b	32	;G
    154  5348		       00		      .byte.b	0	;B
    155  5349		       00		      .byte.b	0	;R (20)
    156  534a		       00		      .byte.b	0	;G
    157  534b		       00		      .byte.b	0	;B
    158  534c		       00		      .byte.b	0	;R (19)
    159  534d		       00		      .byte.b	0	;G
    160  534e		       00		      .byte.b	0	;B
    161  534f		       00		      .byte.b	0	;R (18)
    162  5350		       00		      .byte.b	0	;G
    163  5351		       00		      .byte.b	0	;B
    164  5352		       00		      .byte.b	0	;R (17)
    165  5353		       80		      .byte.b	128	;G
    166  5354		       00		      .byte.b	0	;B
    167  5355		       00		      .byte.b	0	;R (16)
    168  5356		       00		      .byte.b	0	;G
    169  5357		       00		      .byte.b	0	;B
    170  5358		       00		      .byte.b	0	;R (15)
    171  5359		       10		      .byte.b	16	;G
    172  535a		       00		      .byte.b	0	;B
    173  535b		       00		      .byte.b	0	;R (14)
    174  535c		       00		      .byte.b	0	;G
    175  535d		       00		      .byte.b	0	;B
    176  535e		       00		      .byte.b	0	;R (13)
    177  535f		       00		      .byte.b	0	;G
    178  5360		       00		      .byte.b	0	;B
    179  5361		       00		      .byte.b	0	;R (12)
    180  5362		       80		      .byte.b	128	;G
    181  5363		       00		      .byte.b	0	;B
    182  5364		       00		      .byte.b	0	;R (11)
    183  5365		       00		      .byte.b	0	;G
    184  5366		       00		      .byte.b	0	;B
    185  5367		       00		      .byte.b	0	;R (10)
    186  5368		       00		      .byte.b	0	;G
    187  5369		       00		      .byte.b	0	;B
    188  536a		       00		      .byte.b	0	;R (9)
    189  536b		       80		      .byte.b	128	;G
    190  536c		       00		      .byte.b	0	;B
    191  536d		       00		      .byte.b	0	;R (8)
    192  536e		       00		      .byte.b	0	;G
    193  536f		       00		      .byte.b	0	;B
    194  5370		       00		      .byte.b	0	;R (7)
    195  5371		       20		      .byte.b	32	;G
    196  5372		       00		      .byte.b	0	;B
    197  5373		       00		      .byte.b	0	;R (6)
    198  5374		       00		      .byte.b	0	;G
    199  5375		       00		      .byte.b	0	;B
    200  5376		       00		      .byte.b	0	;R (5)
    201  5377		       10		      .byte.b	16	;G
    202  5378		       00		      .byte.b	0	;B
    203  5379		       00		      .byte.b	0	;R (4)
    204  537a		       00		      .byte.b	0	;G
    205  537b		       00		      .byte.b	0	;B
    206  537c		       00		      .byte.b	0	;R (3)
    207  537d		       00		      .byte.b	0	;G
    208  537e		       00		      .byte.b	0	;B
    209  537f		       00		      .byte.b	0	;R (2)
    210  5380		       40		      .byte.b	64	;G
    211  5381		       00		      .byte.b	0	;B
    212  5382		       00		      .byte.b	0	;R (1)
    213  5383		       00		      .byte.b	0	;G
    214  5384		       00		      .byte.b	0	;B
    215  5385		       00		      .byte.b	0	;R (0)
    216  5386		       00		      .byte.b	0	;G
    217  5387		       00		      .byte.b	0	;B
    218  5388				   COL_1
    219  5388		       80		      .byte.b	128	;R (71)
    220  5389		       80		      .byte.b	128	;G
    221  538a		       00		      .byte.b	0	;B
    222  538b		       10		      .byte.b	16	;R (70)
    223  538c		       14		      .byte.b	20	;G
    224  538d		       00		      .byte.b	0	;B
    225  538e		       00		      .byte.b	0	;R (69)
    226  538f		       41		      .byte.b	65	;G
    227  5390		       00		      .byte.b	0	;B
    228  5391		       00		      .byte.b	0	;R (68)
    229  5392		       08		      .byte.b	8	;G
    230  5393		       00		      .byte.b	0	;B
    231  5394		       20		      .byte.b	32	;R (67)
    232  5395		       20		      .byte.b	32	;G
    233  5396		       00		      .byte.b	0	;B
    234  5397		       63		      .byte.b	99	;R (66)
    235  5398		       6b		      .byte.b	107	;G
    236  5399		       00		      .byte.b	0	;B
    237  539a		       ff		      .byte.b	255	;R (65)
    238  539b		       f5		      .byte.b	245	;G
    239  539c		       00		      .byte.b	0	;B
    240  539d		       80		      .byte.b	128	;R (64)
    241  539e		       fb		      .byte.b	251	;G
    242  539f		       04		      .byte.b	4	;B
    243  53a0		       00		      .byte.b	0	;R (63)
    244  53a1		       b7		      .byte.b	183	;G
    245  53a2		       00		      .byte.b	0	;B
    246  53a3		       00		      .byte.b	0	;R (62)
    247  53a4		       b5		      .byte.b	181	;G
    248  53a5		       00		      .byte.b	0	;B
    249  53a6		       00		      .byte.b	0	;R (61)
    250  53a7		       ef		      .byte.b	239	;G
    251  53a8		       10		      .byte.b	16	;B
    252  53a9		       00		      .byte.b	0	;R (60)
    253  53aa		       bd		      .byte.b	189	;G
    254  53ab		       42		      .byte.b	66	;B
    255  53ac		       00		      .byte.b	0	;R (59)
    256  53ad		       77		      .byte.b	119	;G
    257  53ae		       00		      .byte.b	0	;B
    258  53af		       00		      .byte.b	0	;R (58)
    259  53b0		       ee		      .byte.b	238	;G
    260  53b1		       00		      .byte.b	0	;B
    261  53b2		       00		      .byte.b	0	;R (57)
    262  53b3		       9b		      .byte.b	155	;G
    263  53b4		       00		      .byte.b	0	;B
    264  53b5		       00		      .byte.b	0	;R (56)
    265  53b6		       f2		      .byte.b	242	;G
    266  53b7		       00		      .byte.b	0	;B
    267  53b8		       00		      .byte.b	0	;R (55)
    268  53b9		       40		      .byte.b	64	;G
    269  53ba		       00		      .byte.b	0	;B
    270  53bb		       00		      .byte.b	0	;R (54)
    271  53bc		       df		      .byte.b	223	;G
    272  53bd		       00		      .byte.b	0	;B
    273  53be		       10		      .byte.b	16	;R (53)
    274  53bf		       69		      .byte.b	105	;G
    275  53c0		       10		      .byte.b	16	;B
    276  53c1		       00		      .byte.b	0	;R (52)
    277  53c2		       4b		      .byte.b	75	;G
    278  53c3		       00		      .byte.b	0	;B
    279  53c4		       00		      .byte.b	0	;R (51)
    280  53c5		       b0		      .byte.b	176	;G
    281  53c6		       00		      .byte.b	0	;B
    282  53c7		       00		      .byte.b	0	;R (50)
    283  53c8		       a7		      .byte.b	167	;G
    284  53c9		       00		      .byte.b	0	;B
    285  53ca		       00		      .byte.b	0	;R (49)
    286  53cb		       7d		      .byte.b	125	;G
    287  53cc		       02		      .byte.b	2	;B
    288  53cd		       00		      .byte.b	0	;R (48)
    289  53ce		       db		      .byte.b	219	;G
    290  53cf		       20		      .byte.b	32	;B
    291  53d0		       00		      .byte.b	0	;R (47)
    292  53d1		       6d		      .byte.b	109	;G
    293  53d2		       00		      .byte.b	0	;B
    294  53d3		       00		      .byte.b	0	;R (46)
    295  53d4		       ea		      .byte.b	234	;G
    296  53d5		       00		      .byte.b	0	;B
    297  53d6		       00		      .byte.b	0	;R (45)
    298  53d7		       13		      .byte.b	19	;G
    299  53d8		       00		      .byte.b	0	;B
    300  53d9		       00		      .byte.b	0	;R (44)
    301  53da		       7e		      .byte.b	126	;G
    302  53db		       01		      .byte.b	1	;B
    303  53dc		       22		      .byte.b	34	;R (43)
    304  53dd		       77		      .byte.b	119	;G
    305  53de		       08		      .byte.b	8	;B
    306  53df		       04		      .byte.b	4	;R (42)
    307  53e0		       5f		      .byte.b	95	;G
    308  53e1		       00		      .byte.b	0	;B
    309  53e2		       00		      .byte.b	0	;R (41)
    310  53e3		       6f		      .byte.b	111	;G
    311  53e4		       00		      .byte.b	0	;B
    312  53e5		       00		      .byte.b	0	;R (40)
    313  53e6		       b5		      .byte.b	181	;G
    314  53e7		       00		      .byte.b	0	;B
    315  53e8		       00		      .byte.b	0	;R (39)
    316  53e9		       5b		      .byte.b	91	;G
    317  53ea		       00		      .byte.b	0	;B
    318  53eb		       00		      .byte.b	0	;R (38)
    319  53ec		       57		      .byte.b	87	;G
    320  53ed		       00		      .byte.b	0	;B
    321  53ee		       20		      .byte.b	32	;R (37)
    322  53ef		       4d		      .byte.b	77	;G
    323  53f0		       22		      .byte.b	34	;B
    324  53f1		       00		      .byte.b	0	;R (36)
    325  53f2		       55		      .byte.b	85	;G
    326  53f3		       00		      .byte.b	0	;B
    327  53f4		       01		      .byte.b	1	;R (35)
    328  53f5		       56		      .byte.b	86	;G
    329  53f6		       00		      .byte.b	0	;B
    330  53f7		       02		      .byte.b	2	;R (34)
    331  53f8		       57		      .byte.b	87	;G
    332  53f9		       00		      .byte.b	0	;B
    333  53fa		       00		      .byte.b	0	;R (33)
    334  53fb		       2a		      .byte.b	42	;G
    335  53fc		       01		      .byte.b	1	;B
    336  53fd		       01		      .byte.b	1	;R (32)
    337  53fe		       ab		      .byte.b	171	;G
    338  53ff		       00		      .byte.b	0	;B
    339  5400		       22		      .byte.b	34	;R (31)
    340  5401		       17		      .byte.b	23	;G
    341  5402		       20		      .byte.b	32	;B
    342  5403		       00		      .byte.b	0	;R (30)
    343  5404		       55		      .byte.b	85	;G
    344  5405		       02		      .byte.b	2	;B
    345  5406		       22		      .byte.b	34	;R (29)
    346  5407		       17		      .byte.b	23	;G
    347  5408		       20		      .byte.b	32	;B
    348  5409		       00		      .byte.b	0	;R (28)
    349  540a		       2b		      .byte.b	43	;G
    350  540b		       00		      .byte.b	0	;B
    351  540c		       00		      .byte.b	0	;R (27)
    352  540d		       95		      .byte.b	149	;G
    353  540e		       02		      .byte.b	2	;B
    354  540f		       00		      .byte.b	0	;R (26)
    355  5410		       17		      .byte.b	23	;G
    356  5411		       00		      .byte.b	0	;B
    357  5412		       00		      .byte.b	0	;R (25)
    358  5413		       2d		      .byte.b	45	;G
    359  5414		       00		      .byte.b	0	;B
    360  5415		       00		      .byte.b	0	;R (24)
    361  5416		       b4		      .byte.b	180	;G
    362  5417		       00		      .byte.b	0	;B
    363  5418		       00		      .byte.b	0	;R (23)
    364  5419		       0a		      .byte.b	10	;G
    365  541a		       00		      .byte.b	0	;B
    366  541b		       10		      .byte.b	16	;R (22)
    367  541c		       3c		      .byte.b	60	;G
    368  541d		       00		      .byte.b	0	;B
    369  541e		       10		      .byte.b	16	;R (21)
    370  541f		       98		      .byte.b	152	;G
    371  5420		       00		      .byte.b	0	;B
    372  5421		       10		      .byte.b	16	;R (20)
    373  5422		       1a		      .byte.b	26	;G
    374  5423		       00		      .byte.b	0	;B
    375  5424		       00		      .byte.b	0	;R (19)
    376  5425		       14		      .byte.b	20	;G
    377  5426		       00		      .byte.b	0	;B
    378  5427		       00		      .byte.b	0	;R (18)
    379  5428		       5a		      .byte.b	90	;G
    380  5429		       00		      .byte.b	0	;B
    381  542a		       00		      .byte.b	0	;R (17)
    382  542b		       09		      .byte.b	9	;G
    383  542c		       00		      .byte.b	0	;B
    384  542d		       08		      .byte.b	8	;R (16)
    385  542e		       1d		      .byte.b	29	;G
    386  542f		       00		      .byte.b	0	;B
    387  5430		       00		      .byte.b	0	;R (15)
    388  5431		       1a		      .byte.b	26	;G
    389  5432		       00		      .byte.b	0	;B
    390  5433		       20		      .byte.b	32	;R (14)
    391  5434		       ba		      .byte.b	186	;G
    392  5435		       00		      .byte.b	0	;B
    393  5436		       00		      .byte.b	0	;R (13)
    394  5437		       12		      .byte.b	18	;G
    395  5438		       00		      .byte.b	0	;B
    396  5439		       00		      .byte.b	0	;R (12)
    397  543a		       1a		      .byte.b	26	;G
    398  543b		       00		      .byte.b	0	;B
    399  543c		       00		      .byte.b	0	;R (11)
    400  543d		       2d		      .byte.b	45	;G
    401  543e		       10		      .byte.b	16	;B
    402  543f		       10		      .byte.b	16	;R (10)
    403  5440		       3b		      .byte.b	59	;G
    404  5441		       00		      .byte.b	0	;B
    405  5442		       24		      .byte.b	36	;R (9)
    406  5443		       39		      .byte.b	57	;G
    407  5444		       04		      .byte.b	4	;B
    408  5445		       20		      .byte.b	32	;R (8)
    409  5446		       35		      .byte.b	53	;G
    410  5447		       00		      .byte.b	0	;B
    411  5448		       00		      .byte.b	0	;R (7)
    412  5449		       3d		      .byte.b	61	;G
    413  544a		       00		      .byte.b	0	;B
    414  544b		       00		      .byte.b	0	;R (6)
    415  544c		       32		      .byte.b	50	;G
    416  544d		       00		      .byte.b	0	;B
    417  544e		       00		      .byte.b	0	;R (5)
    418  544f		       98		      .byte.b	152	;G
    419  5450		       00		      .byte.b	0	;B
    420  5451		       00		      .byte.b	0	;R (4)
    421  5452		       12		      .byte.b	18	;G
    422  5453		       00		      .byte.b	0	;B
    423  5454		       00		      .byte.b	0	;R (3)
    424  5455		       20		      .byte.b	32	;G
    425  5456		       00		      .byte.b	0	;B
    426  5457		       01		      .byte.b	1	;R (2)
    427  5458		       49		      .byte.b	73	;G
    428  5459		       00		      .byte.b	0	;B
    429  545a		       20		      .byte.b	32	;R (1)
    430  545b		       20		      .byte.b	32	;G
    431  545c		       00		      .byte.b	0	;B
    432  545d		       00		      .byte.b	0	;R (0)
    433  545e		       00		      .byte.b	0	;G
    434  545f		       00		      .byte.b	0	;B
    435  5460				   COL_2
    436  5460		       14		      .byte.b	20	;R (71)
    437  5461		       14		      .byte.b	20	;G
    438  5462		       00		      .byte.b	0	;B
    439  5463		       40		      .byte.b	64	;R (70)
    440  5464		       42		      .byte.b	66	;G
    441  5465		       00		      .byte.b	0	;B
    442  5466		       a8		      .byte.b	168	;R (69)
    443  5467		       a8		      .byte.b	168	;G
    444  5468		       00		      .byte.b	0	;B
    445  5469		       fd		      .byte.b	253	;R (68)
    446  546a		       1d		      .byte.b	29	;G
    447  546b		       00		      .byte.b	0	;B
    448  546c		       f0		      .byte.b	240	;R (67)
    449  546d		       44		      .byte.b	68	;G
    450  546e		       08		      .byte.b	8	;B
    451  546f		       ff		      .byte.b	255	;R (66)
    452  5470		       2f		      .byte.b	47	;G
    453  5471		       00		      .byte.b	0	;B
    454  5472		       ff		      .byte.b	255	;R (65)
    455  5473		       0e		      .byte.b	14	;G
    456  5474		       00		      .byte.b	0	;B
    457  5475		       f8		      .byte.b	248	;R (64)
    458  5476		       0f		      .byte.b	15	;G
    459  5477		       00		      .byte.b	0	;B
    460  5478		       f8		      .byte.b	248	;R (63)
    461  5479		       2e		      .byte.b	46	;G
    462  547a		       00		      .byte.b	0	;B
    463  547b		       f8		      .byte.b	248	;R (62)
    464  547c		       1e		      .byte.b	30	;G
    465  547d		       01		      .byte.b	1	;B
    466  547e		       74		      .byte.b	116	;R (61)
    467  547f		       23		      .byte.b	35	;G
    468  5480		       88		      .byte.b	136	;B
    469  5481		       fc		      .byte.b	252	;R (60)
    470  5482		       0f		      .byte.b	15	;G
    471  5483		       00		      .byte.b	0	;B
    472  5484		       f8		      .byte.b	248	;R (59)
    473  5485		       06		      .byte.b	6	;G
    474  5486		       01		      .byte.b	1	;B
    475  5487		       f8		      .byte.b	248	;R (58)
    476  5488		       8f		      .byte.b	143	;G
    477  5489		       00		      .byte.b	0	;B
    478  548a		       e8		      .byte.b	232	;R (57)
    479  548b		       0e		      .byte.b	14	;G
    480  548c		       10		      .byte.b	16	;B
    481  548d		       e0		      .byte.b	224	;R (56)
    482  548e		       97		      .byte.b	151	;G
    483  548f		       00		      .byte.b	0	;B
    484  5490		       f0		      .byte.b	240	;R (55)
    485  5491		       3a		      .byte.b	58	;G
    486  5492		       00		      .byte.b	0	;B
    487  5493		       e0		      .byte.b	224	;R (54)
    488  5494		       bb		      .byte.b	187	;G
    489  5495		       04		      .byte.b	4	;B
    490  5496		       e0		      .byte.b	224	;R (53)
    491  5497		       3e		      .byte.b	62	;G
    492  5498		       00		      .byte.b	0	;B
    493  5499		       c0		      .byte.b	192	;R (52)
    494  549a		       2a		      .byte.b	42	;G
    495  549b		       00		      .byte.b	0	;B
    496  549c		       80		      .byte.b	128	;R (51)
    497  549d		       3f		      .byte.b	63	;G
    498  549e		       40		      .byte.b	64	;B
    499  549f		       f5		      .byte.b	245	;R (50)
    500  54a0		       3f		      .byte.b	63	;G
    501  54a1		       00		      .byte.b	0	;B
    502  54a2		       e8		      .byte.b	232	;R (49)
    503  54a3		       7f		      .byte.b	127	;G
    504  54a4		       00		      .byte.b	0	;B
    505  54a5		       e0		      .byte.b	224	;R (48)
    506  54a6		       7a		      .byte.b	122	;G
    507  54a7		       04		      .byte.b	4	;B
    508  54a8		       c0		      .byte.b	192	;R (47)
    509  54a9		       5f		      .byte.b	95	;G
    510  54aa		       00		      .byte.b	0	;B
    511  54ab		       90		      .byte.b	144	;R (46)
    512  54ac		       dd		      .byte.b	221	;G
    513  54ad		       02		      .byte.b	2	;B
    514  54ae		       84		      .byte.b	132	;R (45)
    515  54af		       9f		      .byte.b	159	;G
    516  54b0		       00		      .byte.b	0	;B
    517  54b1		       c4		      .byte.b	196	;R (44)
    518  54b2		       cf		      .byte.b	207	;G
    519  54b3		       00		      .byte.b	0	;B
    520  54b4		       c5		      .byte.b	197	;R (43)
    521  54b5		       1f		      .byte.b	31	;G
    522  54b6		       00		      .byte.b	0	;B
    523  54b7		       d4		      .byte.b	212	;R (42)
    524  54b8		       9f		      .byte.b	159	;G
    525  54b9		       20		      .byte.b	32	;B
    526  54ba		       c8		      .byte.b	200	;R (41)
    527  54bb		       1e		      .byte.b	30	;G
    528  54bc		       01		      .byte.b	1	;B
    529  54bd		       c8		      .byte.b	200	;R (40)
    530  54be		       5f		      .byte.b	95	;G
    531  54bf		       00		      .byte.b	0	;B
    532  54c0		       cd		      .byte.b	205	;R (39)
    533  54c1		       5e		      .byte.b	94	;G
    534  54c2		       00		      .byte.b	0	;B
    535  54c3		       c7		      .byte.b	199	;R (38)
    536  54c4		       5b		      .byte.b	91	;G
    537  54c5		       00		      .byte.b	0	;B
    538  54c6		       8b		      .byte.b	139	;R (37)
    539  54c7		       1c		      .byte.b	28	;G
    540  54c8		       00		      .byte.b	0	;B
    541  54c9		       81		      .byte.b	129	;R (36)
    542  54ca		       9a		      .byte.b	154	;G
    543  54cb		       04		      .byte.b	4	;B
    544  54cc		       8e		      .byte.b	142	;R (35)
    545  54cd		       9d		      .byte.b	157	;G
    546  54ce		       00		      .byte.b	0	;B
    547  54cf		       2b		      .byte.b	43	;R (34)
    548  54d0		       36		      .byte.b	54	;G
    549  54d1		       00		      .byte.b	0	;B
    550  54d2		       3a		      .byte.b	58	;R (33)
    551  54d3		       0d		      .byte.b	13	;G
    552  54d4		       00		      .byte.b	0	;B
    553  54d5		       3e		      .byte.b	62	;R (32)
    554  54d6		       85		      .byte.b	133	;G
    555  54d7		       40		      .byte.b	64	;B
    556  54d8		       fa		      .byte.b	250	;R (31)
    557  54d9		       17		      .byte.b	23	;G
    558  54da		       00		      .byte.b	0	;B
    559  54db		       ff		      .byte.b	255	;R (30)
    560  54dc		       03		      .byte.b	3	;G
    561  54dd		       00		      .byte.b	0	;B
    562  54de		       fc		      .byte.b	252	;R (29)
    563  54df		       93		      .byte.b	147	;G
    564  54e0		       00		      .byte.b	0	;B
    565  54e1		       f7		      .byte.b	247	;R (28)
    566  54e2		       81		      .byte.b	129	;G
    567  54e3		       08		      .byte.b	8	;B
    568  54e4		       ff		      .byte.b	255	;R (27)
    569  54e5		       03		      .byte.b	3	;G
    570  54e6		       00		      .byte.b	0	;B
    571  54e7		       fe		      .byte.b	254	;R (26)
    572  54e8		       2b		      .byte.b	43	;G
    573  54e9		       00		      .byte.b	0	;B
    574  54ea		       fe		      .byte.b	254	;R (25)
    575  54eb		       0a		      .byte.b	10	;G
    576  54ec		       00		      .byte.b	0	;B
    577  54ed		       fc		      .byte.b	252	;R (24)
    578  54ee		       4f		      .byte.b	79	;G
    579  54ef		       00		      .byte.b	0	;B
    580  54f0		       fc		      .byte.b	252	;R (23)
    581  54f1		       55		      .byte.b	85	;G
    582  54f2		       00		      .byte.b	0	;B
    583  54f3		       f8		      .byte.b	248	;R (22)
    584  54f4		       45		      .byte.b	69	;G
    585  54f5		       00		      .byte.b	0	;B
    586  54f6		       e8		      .byte.b	232	;R (21)
    587  54f7		       05		      .byte.b	5	;G
    588  54f8		       10		      .byte.b	16	;B
    589  54f9		       f8		      .byte.b	248	;R (20)
    590  54fa		       5b		      .byte.b	91	;G
    591  54fb		       00		      .byte.b	0	;B
    592  54fc		       f8		      .byte.b	248	;R (19)
    593  54fd		       1d		      .byte.b	29	;G
    594  54fe		       00		      .byte.b	0	;B
    595  54ff		       f0		      .byte.b	240	;R (18)
    596  5500		       55		      .byte.b	85	;G
    597  5501		       00		      .byte.b	0	;B
    598  5502		       f0		      .byte.b	240	;R (17)
    599  5503		       16		      .byte.b	22	;G
    600  5504		       00		      .byte.b	0	;B
    601  5505		       f0		      .byte.b	240	;R (16)
    602  5506		       b2		      .byte.b	178	;G
    603  5507		       00		      .byte.b	0	;B
    604  5508		       e0		      .byte.b	224	;R (15)
    605  5509		       0e		      .byte.b	14	;G
    606  550a		       10		      .byte.b	16	;B
    607  550b		       f0		      .byte.b	240	;R (14)
    608  550c		       93		      .byte.b	147	;G
    609  550d		       00		      .byte.b	0	;B
    610  550e		       e0		      .byte.b	224	;R (13)
    611  550f		       25		      .byte.b	37	;G
    612  5510		       00		      .byte.b	0	;B
    613  5511		       c0		      .byte.b	192	;R (12)
    614  5512		       e5		      .byte.b	229	;G
    615  5513		       00		      .byte.b	0	;B
    616  5514		       80		      .byte.b	128	;R (11)
    617  5515		       0e		      .byte.b	14	;G
    618  5516		       00		      .byte.b	0	;B
    619  5517		       c0		      .byte.b	192	;R (10)
    620  5518		       ca		      .byte.b	202	;G
    621  5519		       00		      .byte.b	0	;B
    622  551a		       84		      .byte.b	132	;R (9)
    623  551b		       8e		      .byte.b	142	;G
    624  551c		       00		      .byte.b	0	;B
    625  551d		       00		      .byte.b	0	;R (8)
    626  551e		       8e		      .byte.b	142	;G
    627  551f		       00		      .byte.b	0	;B
    628  5520		       00		      .byte.b	0	;R (7)
    629  5521		       15		      .byte.b	21	;G
    630  5522		       00		      .byte.b	0	;B
    631  5523		       00		      .byte.b	0	;R (6)
    632  5524		       14		      .byte.b	20	;G
    633  5525		       00		      .byte.b	0	;B
    634  5526		       00		      .byte.b	0	;R (5)
    635  5527		       14		      .byte.b	20	;G
    636  5528		       00		      .byte.b	0	;B
    637  5529		       00		      .byte.b	0	;R (4)
    638  552a		       0a		      .byte.b	10	;G
    639  552b		       00		      .byte.b	0	;B
    640  552c		       00		      .byte.b	0	;R (3)
    641  552d		       10		      .byte.b	16	;G
    642  552e		       00		      .byte.b	0	;B
    643  552f		       08		      .byte.b	8	;R (2)
    644  5530		       88		      .byte.b	136	;G
    645  5531		       00		      .byte.b	0	;B
    646  5532		       40		      .byte.b	64	;R (1)
    647  5533		       42		      .byte.b	66	;G
    648  5534		       00		      .byte.b	0	;B
    649  5535		       00		      .byte.b	0	;R (0)
    650  5536		       00		      .byte.b	0	;G
    651  5537		       00		      .byte.b	0	;B
    652  5538				   COL_3
    653  5538		       90		      .byte.b	144	;R (71)
    654  5539		       90		      .byte.b	144	;G
    655  553a		       00		      .byte.b	0	;B
    656  553b		       40		      .byte.b	64	;R (70)
    657  553c		       40		      .byte.b	64	;G
    658  553d		       00		      .byte.b	0	;B
    659  553e		       b0		      .byte.b	176	;R (69)
    660  553f		       b0		      .byte.b	176	;G
    661  5540		       00		      .byte.b	0	;B
    662  5541		       d0		      .byte.b	208	;R (68)
    663  5542		       00		      .byte.b	0	;G
    664  5543		       20		      .byte.b	32	;B
    665  5544		       f0		      .byte.b	240	;R (67)
    666  5545		       00		      .byte.b	0	;G
    667  5546		       00		      .byte.b	0	;B
    668  5547		       f0		      .byte.b	240	;R (66)
    669  5548		       d0		      .byte.b	208	;G
    670  5549		       00		      .byte.b	0	;B
    671  554a		       f0		      .byte.b	240	;R (65)
    672  554b		       00		      .byte.b	0	;G
    673  554c		       00		      .byte.b	0	;B
    674  554d		       f0		      .byte.b	240	;R (64)
    675  554e		       00		      .byte.b	0	;G
    676  554f		       00		      .byte.b	0	;B
    677  5550		       f0		      .byte.b	240	;R (63)
    678  5551		       50		      .byte.b	80	;G
    679  5552		       00		      .byte.b	0	;B
    680  5553		       f0		      .byte.b	240	;R (62)
    681  5554		       00		      .byte.b	0	;G
    682  5555		       00		      .byte.b	0	;B
    683  5556		       f0		      .byte.b	240	;R (61)
    684  5557		       a0		      .byte.b	160	;G
    685  5558		       00		      .byte.b	0	;B
    686  5559		       f0		      .byte.b	240	;R (60)
    687  555a		       00		      .byte.b	0	;G
    688  555b		       00		      .byte.b	0	;B
    689  555c		       f0		      .byte.b	240	;R (59)
    690  555d		       d0		      .byte.b	208	;G
    691  555e		       00		      .byte.b	0	;B
    692  555f		       f0		      .byte.b	240	;R (58)
    693  5560		       c0		      .byte.b	192	;G
    694  5561		       00		      .byte.b	0	;B
    695  5562		       f0		      .byte.b	240	;R (57)
    696  5563		       90		      .byte.b	144	;G
    697  5564		       00		      .byte.b	0	;B
    698  5565		       f0		      .byte.b	240	;R (56)
    699  5566		       80		      .byte.b	128	;G
    700  5567		       00		      .byte.b	0	;B
    701  5568		       f0		      .byte.b	240	;R (55)
    702  5569		       40		      .byte.b	64	;G
    703  556a		       00		      .byte.b	0	;B
    704  556b		       70		      .byte.b	112	;R (54)
    705  556c		       00		      .byte.b	0	;G
    706  556d		       80		      .byte.b	128	;B
    707  556e		       d0		      .byte.b	208	;R (53)
    708  556f		       00		      .byte.b	0	;G
    709  5570		       20		      .byte.b	32	;B
    710  5571		       f0		      .byte.b	240	;R (52)
    711  5572		       80		      .byte.b	128	;G
    712  5573		       00		      .byte.b	0	;B
    713  5574		       f0		      .byte.b	240	;R (51)
    714  5575		       00		      .byte.b	0	;G
    715  5576		       00		      .byte.b	0	;B
    716  5577		       f0		      .byte.b	240	;R (50)
    717  5578		       a0		      .byte.b	160	;G
    718  5579		       00		      .byte.b	0	;B
    719  557a		       f0		      .byte.b	240	;R (49)
    720  557b		       80		      .byte.b	128	;G
    721  557c		       00		      .byte.b	0	;B
    722  557d		       f0		      .byte.b	240	;R (48)
    723  557e		       40		      .byte.b	64	;G
    724  557f		       00		      .byte.b	0	;B
    725  5580		       f0		      .byte.b	240	;R (47)
    726  5581		       20		      .byte.b	32	;G
    727  5582		       00		      .byte.b	0	;B
    728  5583		       f0		      .byte.b	240	;R (46)
    729  5584		       00		      .byte.b	0	;G
    730  5585		       00		      .byte.b	0	;B
    731  5586		       f0		      .byte.b	240	;R (45)
    732  5587		       80		      .byte.b	128	;G
    733  5588		       00		      .byte.b	0	;B
    734  5589		       f0		      .byte.b	240	;R (44)
    735  558a		       00		      .byte.b	0	;G
    736  558b		       00		      .byte.b	0	;B
    737  558c		       f0		      .byte.b	240	;R (43)
    738  558d		       40		      .byte.b	64	;G
    739  558e		       00		      .byte.b	0	;B
    740  558f		       f0		      .byte.b	240	;R (42)
    741  5590		       00		      .byte.b	0	;G
    742  5591		       00		      .byte.b	0	;B
    743  5592		       f0		      .byte.b	240	;R (41)
    744  5593		       20		      .byte.b	32	;G
    745  5594		       00		      .byte.b	0	;B
    746  5595		       f0		      .byte.b	240	;R (40)
    747  5596		       20		      .byte.b	32	;G
    748  5597		       00		      .byte.b	0	;B
    749  5598		       f0		      .byte.b	240	;R (39)
    750  5599		       50		      .byte.b	80	;G
    751  559a		       00		      .byte.b	0	;B
    752  559b		       f0		      .byte.b	240	;R (38)
    753  559c		       10		      .byte.b	16	;G
    754  559d		       00		      .byte.b	0	;B
    755  559e		       70		      .byte.b	112	;R (37)
    756  559f		       80		      .byte.b	128	;G
    757  55a0		       80		      .byte.b	128	;B
    758  55a1		       f0		      .byte.b	240	;R (36)
    759  55a2		       50		      .byte.b	80	;G
    760  55a3		       00		      .byte.b	0	;B
    761  55a4		       f0		      .byte.b	240	;R (35)
    762  55a5		       00		      .byte.b	0	;G
    763  55a6		       00		      .byte.b	0	;B
    764  55a7		       f0		      .byte.b	240	;R (34)
    765  55a8		       40		      .byte.b	64	;G
    766  55a9		       00		      .byte.b	0	;B
    767  55aa		       f0		      .byte.b	240	;R (33)
    768  55ab		       10		      .byte.b	16	;G
    769  55ac		       00		      .byte.b	0	;B
    770  55ad		       f0		      .byte.b	240	;R (32)
    771  55ae		       b0		      .byte.b	176	;G
    772  55af		       00		      .byte.b	0	;B
    773  55b0		       e0		      .byte.b	224	;R (31)
    774  55b1		       00		      .byte.b	0	;G
    775  55b2		       10		      .byte.b	16	;B
    776  55b3		       e0		      .byte.b	224	;R (30)
    777  55b4		       40		      .byte.b	64	;G
    778  55b5		       00		      .byte.b	0	;B
    779  55b6		       e0		      .byte.b	224	;R (29)
    780  55b7		       20		      .byte.b	32	;G
    781  55b8		       00		      .byte.b	0	;B
    782  55b9		       c0		      .byte.b	192	;R (28)
    783  55ba		       00		      .byte.b	0	;G
    784  55bb		       00		      .byte.b	0	;B
    785  55bc		       c0		      .byte.b	192	;R (27)
    786  55bd		       10		      .byte.b	16	;G
    787  55be		       00		      .byte.b	0	;B
    788  55bf		       c0		      .byte.b	192	;R (26)
    789  55c0		       40		      .byte.b	64	;G
    790  55c1		       10		      .byte.b	16	;B
    791  55c2		       90		      .byte.b	144	;R (25)
    792  55c3		       00		      .byte.b	0	;G
    793  55c4		       00		      .byte.b	0	;B
    794  55c5		       f0		      .byte.b	240	;R (24)
    795  55c6		       60		      .byte.b	96	;G
    796  55c7		       00		      .byte.b	0	;B
    797  55c8		       f0		      .byte.b	240	;R (23)
    798  55c9		       00		      .byte.b	0	;G
    799  55ca		       00		      .byte.b	0	;B
    800  55cb		       f0		      .byte.b	240	;R (22)
    801  55cc		       40		      .byte.b	64	;G
    802  55cd		       00		      .byte.b	0	;B
    803  55ce		       f0		      .byte.b	240	;R (21)
    804  55cf		       10		      .byte.b	16	;G
    805  55d0		       00		      .byte.b	0	;B
    806  55d1		       f0		      .byte.b	240	;R (20)
    807  55d2		       00		      .byte.b	0	;G
    808  55d3		       00		      .byte.b	0	;B
    809  55d4		       f0		      .byte.b	240	;R (19)
    810  55d5		       60		      .byte.b	96	;G
    811  55d6		       00		      .byte.b	0	;B
    812  55d7		       f0		      .byte.b	240	;R (18)
    813  55d8		       20		      .byte.b	32	;G
    814  55d9		       00		      .byte.b	0	;B
    815  55da		       f0		      .byte.b	240	;R (17)
    816  55db		       50		      .byte.b	80	;G
    817  55dc		       00		      .byte.b	0	;B
    818  55dd		       f0		      .byte.b	240	;R (16)
    819  55de		       40		      .byte.b	64	;G
    820  55df		       00		      .byte.b	0	;B
    821  55e0		       f0		      .byte.b	240	;R (15)
    822  55e1		       80		      .byte.b	128	;G
    823  55e2		       00		      .byte.b	0	;B
    824  55e3		       f0		      .byte.b	240	;R (14)
    825  55e4		       40		      .byte.b	64	;G
    826  55e5		       00		      .byte.b	0	;B
    827  55e6		       f0		      .byte.b	240	;R (13)
    828  55e7		       00		      .byte.b	0	;G
    829  55e8		       00		      .byte.b	0	;B
    830  55e9		       f0		      .byte.b	240	;R (12)
    831  55ea		       10		      .byte.b	16	;G
    832  55eb		       00		      .byte.b	0	;B
    833  55ec		       f0		      .byte.b	240	;R (11)
    834  55ed		       50		      .byte.b	80	;G
    835  55ee		       00		      .byte.b	0	;B
    836  55ef		       f0		      .byte.b	240	;R (10)
    837  55f0		       00		      .byte.b	0	;G
    838  55f1		       00		      .byte.b	0	;B
    839  55f2		       f0		      .byte.b	240	;R (9)
    840  55f3		       b0		      .byte.b	176	;G
    841  55f4		       00		      .byte.b	0	;B
    842  55f5		       f0		      .byte.b	240	;R (8)
    843  55f6		       90		      .byte.b	144	;G
    844  55f7		       00		      .byte.b	0	;B
    845  55f8		       e0		      .byte.b	224	;R (7)
    846  55f9		       e0		      .byte.b	224	;G
    847  55fa		       00		      .byte.b	0	;B
    848  55fb		       f0		      .byte.b	240	;R (6)
    849  55fc		       d0		      .byte.b	208	;G
    850  55fd		       00		      .byte.b	0	;B
    851  55fe		       60		      .byte.b	96	;R (5)
    852  55ff		       00		      .byte.b	0	;G
    853  5600		       00		      .byte.b	0	;B
    854  5601		       60		      .byte.b	96	;R (4)
    855  5602		       40		      .byte.b	64	;G
    856  5603		       00		      .byte.b	0	;B
    857  5604		       40		      .byte.b	64	;R (3)
    858  5605		       50		      .byte.b	80	;G
    859  5606		       00		      .byte.b	0	;B
    860  5607		       00		      .byte.b	0	;R (2)
    861  5608		       00		      .byte.b	0	;G
    862  5609		       00		      .byte.b	0	;B
    863  560a		       00		      .byte.b	0	;R (1)
    864  560b		       80		      .byte.b	128	;G
    865  560c		       00		      .byte.b	0	;B
    866  560d		       00		      .byte.b	0	;R (0)
    867  560e		       00		      .byte.b	0	;G
    868  560f		       00		      .byte.b	0	;B
    869  5610				   COL_4
    870  5610		       25		      .byte.b	37	;R (71)
    871  5611		       25		      .byte.b	37	;G
    872  5612		       00		      .byte.b	0	;B
    873  5613		       48		      .byte.b	72	;R (70)
    874  5614		       48		      .byte.b	72	;G
    875  5615		       00		      .byte.b	0	;B
    876  5616		       25		      .byte.b	37	;R (69)
    877  5617		       25		      .byte.b	37	;G
    878  5618		       88		      .byte.b	136	;B
    879  5619		       ff		      .byte.b	255	;R (68)
    880  561a		       00		      .byte.b	0	;G
    881  561b		       00		      .byte.b	0	;B
    882  561c		       ff		      .byte.b	255	;R (67)
    883  561d		       04		      .byte.b	4	;G
    884  561e		       00		      .byte.b	0	;B
    885  561f		       ef		      .byte.b	239	;R (66)
    886  5620		       40		      .byte.b	64	;G
    887  5621		       10		      .byte.b	16	;B
    888  5622		       ff		      .byte.b	255	;R (65)
    889  5623		       00		      .byte.b	0	;G
    890  5624		       00		      .byte.b	0	;B
    891  5625		       ff		      .byte.b	255	;R (64)
    892  5626		       02		      .byte.b	2	;G
    893  5627		       00		      .byte.b	0	;B
    894  5628		       ff		      .byte.b	255	;R (63)
    895  5629		       20		      .byte.b	32	;G
    896  562a		       00		      .byte.b	0	;B
    897  562b		       ff		      .byte.b	255	;R (62)
    898  562c		       a5		      .byte.b	165	;G
    899  562d		       00		      .byte.b	0	;B
    900  562e		       ff		      .byte.b	255	;R (61)
    901  562f		       09		      .byte.b	9	;G
    902  5630		       00		      .byte.b	0	;B
    903  5631		       ff		      .byte.b	255	;R (60)
    904  5632		       00		      .byte.b	0	;G
    905  5633		       00		      .byte.b	0	;B
    906  5634		       7f		      .byte.b	127	;R (59)
    907  5635		       42		      .byte.b	66	;G
    908  5636		       80		      .byte.b	128	;B
    909  5637		       ff		      .byte.b	255	;R (58)
    910  5638		       88		      .byte.b	136	;G
    911  5639		       00		      .byte.b	0	;B
    912  563a		       ff		      .byte.b	255	;R (57)
    913  563b		       40		      .byte.b	64	;G
    914  563c		       00		      .byte.b	0	;B
    915  563d		       ff		      .byte.b	255	;R (56)
    916  563e		       09		      .byte.b	9	;G
    917  563f		       00		      .byte.b	0	;B
    918  5640		       7f		      .byte.b	127	;R (55)
    919  5641		       01		      .byte.b	1	;G
    920  5642		       80		      .byte.b	128	;B
    921  5643		       ff		      .byte.b	255	;R (54)
    922  5644		       91		      .byte.b	145	;G
    923  5645		       00		      .byte.b	0	;B
    924  5646		       fe		      .byte.b	254	;R (53)
    925  5647		       81		      .byte.b	129	;G
    926  5648		       00		      .byte.b	0	;B
    927  5649		       fe		      .byte.b	254	;R (52)
    928  564a		       20		      .byte.b	32	;G
    929  564b		       00		      .byte.b	0	;B
    930  564c		       ff		      .byte.b	255	;R (51)
    931  564d		       03		      .byte.b	3	;G
    932  564e		       00		      .byte.b	0	;B
    933  564f		       ff		      .byte.b	255	;R (50)
    934  5650		       83		      .byte.b	131	;G
    935  5651		       00		      .byte.b	0	;B
    936  5652		       fe		      .byte.b	254	;R (49)
    937  5653		       90		      .byte.b	144	;G
    938  5654		       00		      .byte.b	0	;B
    939  5655		       fe		      .byte.b	254	;R (48)
    940  5656		       83		      .byte.b	131	;G
    941  5657		       00		      .byte.b	0	;B
    942  5658		       7e		      .byte.b	126	;R (47)
    943  5659		       12		      .byte.b	18	;G
    944  565a		       80		      .byte.b	128	;B
    945  565b		       fc		      .byte.b	252	;R (46)
    946  565c		       00		      .byte.b	0	;G
    947  565d		       00		      .byte.b	0	;B
    948  565e		       fe		      .byte.b	254	;R (45)
    949  565f		       07		      .byte.b	7	;G
    950  5660		       00		      .byte.b	0	;B
    951  5661		       ef		      .byte.b	239	;R (44)
    952  5662		       03		      .byte.b	3	;G
    953  5663		       10		      .byte.b	16	;B
    954  5664		       ff		      .byte.b	255	;R (43)
    955  5665		       40		      .byte.b	64	;G
    956  5666		       00		      .byte.b	0	;B
    957  5667		       ff		      .byte.b	255	;R (42)
    958  5668		       01		      .byte.b	1	;G
    959  5669		       00		      .byte.b	0	;B
    960  566a		       ff		      .byte.b	255	;R (41)
    961  566b		       01		      .byte.b	1	;G
    962  566c		       00		      .byte.b	0	;B
    963  566d		       bf		      .byte.b	191	;R (40)
    964  566e		       01		      .byte.b	1	;G
    965  566f		       40		      .byte.b	64	;B
    966  5670		       f7		      .byte.b	247	;R (39)
    967  5671		       80		      .byte.b	128	;G
    968  5672		       08		      .byte.b	8	;B
    969  5673		       ff		      .byte.b	255	;R (38)
    970  5674		       40		      .byte.b	64	;G
    971  5675		       00		      .byte.b	0	;B
    972  5676		       ff		      .byte.b	255	;R (37)
    973  5677		       00		      .byte.b	0	;G
    974  5678		       00		      .byte.b	0	;B
    975  5679		       ff		      .byte.b	255	;R (36)
    976  567a		       40		      .byte.b	64	;G
    977  567b		       00		      .byte.b	0	;B
    978  567c		       ff		      .byte.b	255	;R (35)
    979  567d		       a1		      .byte.b	161	;G
    980  567e		       00		      .byte.b	0	;B
    981  567f		       7f		      .byte.b	127	;R (34)
    982  5680		       05		      .byte.b	5	;G
    983  5681		       80		      .byte.b	128	;B
    984  5682		       ff		      .byte.b	255	;R (33)
    985  5683		       21		      .byte.b	33	;G
    986  5684		       00		      .byte.b	0	;B
    987  5685		       bf		      .byte.b	191	;R (32)
    988  5686		       40		      .byte.b	64	;G
    989  5687		       40		      .byte.b	64	;B
    990  5688		       ff		      .byte.b	255	;R (31)
    991  5689		       61		      .byte.b	97	;G
    992  568a		       00		      .byte.b	0	;B
    993  568b		       7f		      .byte.b	127	;R (30)
    994  568c		       81		      .byte.b	129	;G
    995  568d		       80		      .byte.b	128	;B
    996  568e		       f7		      .byte.b	247	;R (29)
    997  568f		       60		      .byte.b	96	;G
    998  5690		       08		      .byte.b	8	;B
    999  5691		       ff		      .byte.b	255	;R (28)
   1000  5692		       81		      .byte.b	129	;G
   1001  5693		       00		      .byte.b	0	;B
   1002  5694		       ef		      .byte.b	239	;R (27)
   1003  5695		       40		      .byte.b	64	;G
   1004  5696		       10		      .byte.b	16	;B
   1005  5697		       ff		      .byte.b	255	;R (26)
   1006  5698		       60		      .byte.b	96	;G
   1007  5699		       00		      .byte.b	0	;B
   1008  569a		       ff		      .byte.b	255	;R (25)
   1009  569b		       18		      .byte.b	24	;G
   1010  569c		       00		      .byte.b	0	;B
   1011  569d		       ff		      .byte.b	255	;R (24)
   1012  569e		       20		      .byte.b	32	;G
   1013  569f		       00		      .byte.b	0	;B
   1014  56a0		       ff		      .byte.b	255	;R (23)
   1015  56a1		       8a		      .byte.b	138	;G
   1016  56a2		       00		      .byte.b	0	;B
   1017  56a3		       f7		      .byte.b	247	;R (22)
   1018  56a4		       10		      .byte.b	16	;G
   1019  56a5		       08		      .byte.b	8	;B
   1020  56a6		       ff		      .byte.b	255	;R (21)
   1021  56a7		       04		      .byte.b	4	;G
   1022  56a8		       00		      .byte.b	0	;B
   1023  56a9		       df		      .byte.b	223	;R (20)
   1024  56aa		       10		      .byte.b	16	;G
   1025  56ab		       20		      .byte.b	32	;B
   1026  56ac		       ff		      .byte.b	255	;R (19)
   1027  56ad		       90		      .byte.b	144	;G
   1028  56ae		       00		      .byte.b	0	;B
   1029  56af		       ff		      .byte.b	255	;R (18)
   1030  56b0		       12		      .byte.b	18	;G
   1031  56b1		       00		      .byte.b	0	;B
   1032  56b2		       ff		      .byte.b	255	;R (17)
   1033  56b3		       00		      .byte.b	0	;G
   1034  56b4		       00		      .byte.b	0	;B
   1035  56b5		       ff		      .byte.b	255	;R (16)
   1036  56b6		       45		      .byte.b	69	;G
   1037  56b7		       00		      .byte.b	0	;B
   1038  56b8		       ff		      .byte.b	255	;R (15)
   1039  56b9		       10		      .byte.b	16	;G
   1040  56ba		       00		      .byte.b	0	;B
   1041  56bb		       ff		      .byte.b	255	;R (14)
   1042  56bc		       23		      .byte.b	35	;G
   1043  56bd		       00		      .byte.b	0	;B
   1044  56be		       fc		      .byte.b	252	;R (13)
   1045  56bf		       12		      .byte.b	18	;G
   1046  56c0		       00		      .byte.b	0	;B
   1047  56c1		       fc		      .byte.b	252	;R (12)
   1048  56c2		       20		      .byte.b	32	;G
   1049  56c3		       00		      .byte.b	0	;B
   1050  56c4		       fe		      .byte.b	254	;R (11)
   1051  56c5		       46		      .byte.b	70	;G
   1052  56c6		       00		      .byte.b	0	;B
   1053  56c7		       f8		      .byte.b	248	;R (10)
   1054  56c8		       48		      .byte.b	72	;G
   1055  56c9		       00		      .byte.b	0	;B
   1056  56ca		       f0		      .byte.b	240	;R (9)
   1057  56cb		       04		      .byte.b	4	;G
   1058  56cc		       00		      .byte.b	0	;B
   1059  56cd		       e0		      .byte.b	224	;R (8)
   1060  56ce		       20		      .byte.b	32	;G
   1061  56cf		       00		      .byte.b	0	;B
   1062  56d0		       e0		      .byte.b	224	;R (7)
   1063  56d1		       29		      .byte.b	41	;G
   1064  56d2		       00		      .byte.b	0	;B
   1065  56d3		       e0		      .byte.b	224	;R (6)
   1066  56d4		       20		      .byte.b	32	;G
   1067  56d5		       00		      .byte.b	0	;B
   1068  56d6		       e0		      .byte.b	224	;R (5)
   1069  56d7		       84		      .byte.b	132	;G
   1070  56d8		       00		      .byte.b	0	;B
   1071  56d9		       60		      .byte.b	96	;R (4)
   1072  56da		       40		      .byte.b	64	;G
   1073  56db		       00		      .byte.b	0	;B
   1074  56dc		       00		      .byte.b	0	;R (3)
   1075  56dd		       88		      .byte.b	136	;G
   1076  56de		       00		      .byte.b	0	;B
   1077  56df		       00		      .byte.b	0	;R (2)
   1078  56e0		       11		      .byte.b	17	;G
   1079  56e1		       00		      .byte.b	0	;B
   1080  56e2		       24		      .byte.b	36	;R (1)
   1081  56e3		       24		      .byte.b	36	;G
   1082  56e4		       00		      .byte.b	0	;B
   1083  56e5		       00		      .byte.b	0	;R (0)
   1084  56e6		       00		      .byte.b	0	;G
   1085  56e7		       00		      .byte.b	0	;B
   1086  56e8				   COL_5
   1087  56e8		       02		      .byte.b	2	;R (71)
   1088  56e9		       12		      .byte.b	18	;G
   1089  56ea		       00		      .byte.b	0	;B
   1090  56eb		       00		      .byte.b	0	;R (70)
   1091  56ec		       00		      .byte.b	0	;G
   1092  56ed		       00		      .byte.b	0	;B
   1093  56ee		       00		      .byte.b	0	;R (69)
   1094  56ef		       02		      .byte.b	2	;G
   1095  56f0		       00		      .byte.b	0	;B
   1096  56f1		       03		      .byte.b	3	;R (68)
   1097  56f2		       12		      .byte.b	18	;G
   1098  56f3		       00		      .byte.b	0	;B
   1099  56f4		       0b		      .byte.b	11	;R (67)
   1100  56f5		       09		      .byte.b	9	;G
   1101  56f6		       00		      .byte.b	0	;B
   1102  56f7		       07		      .byte.b	7	;R (66)
   1103  56f8		       05		      .byte.b	5	;G
   1104  56f9		       00		      .byte.b	0	;B
   1105  56fa		       03		      .byte.b	3	;R (65)
   1106  56fb		       06		      .byte.b	6	;G
   1107  56fc		       00		      .byte.b	0	;B
   1108  56fd		       01		      .byte.b	1	;R (64)
   1109  56fe		       20		      .byte.b	32	;G
   1110  56ff		       00		      .byte.b	0	;B
   1111  5700		       03		      .byte.b	3	;R (63)
   1112  5701		       03		      .byte.b	3	;G
   1113  5702		       00		      .byte.b	0	;B
   1114  5703		       03		      .byte.b	3	;R (62)
   1115  5704		       0a		      .byte.b	10	;G
   1116  5705		       00		      .byte.b	0	;B
   1117  5706		       03		      .byte.b	3	;R (61)
   1118  5707		       02		      .byte.b	2	;G
   1119  5708		       00		      .byte.b	0	;B
   1120  5709		       03		      .byte.b	3	;R (60)
   1121  570a		       00		      .byte.b	0	;G
   1122  570b		       00		      .byte.b	0	;B
   1123  570c		       03		      .byte.b	3	;R (59)
   1124  570d		       0a		      .byte.b	10	;G
   1125  570e		       00		      .byte.b	0	;B
   1126  570f		       03		      .byte.b	3	;R (58)
   1127  5710		       02		      .byte.b	2	;G
   1128  5711		       00		      .byte.b	0	;B
   1129  5712		       01		      .byte.b	1	;R (57)
   1130  5713		       03		      .byte.b	3	;G
   1131  5714		       00		      .byte.b	0	;B
   1132  5715		       01		      .byte.b	1	;R (56)
   1133  5716		       01		      .byte.b	1	;G
   1134  5717		       00		      .byte.b	0	;B
   1135  5718		       00		      .byte.b	0	;R (55)
   1136  5719		       25		      .byte.b	37	;G
   1137  571a		       00		      .byte.b	0	;B
   1138  571b		       00		      .byte.b	0	;R (54)
   1139  571c		       00		      .byte.b	0	;G
   1140  571d		       00		      .byte.b	0	;B
   1141  571e		       00		      .byte.b	0	;R (53)
   1142  571f		       20		      .byte.b	32	;G
   1143  5720		       00		      .byte.b	0	;B
   1144  5721		       00		      .byte.b	0	;R (52)
   1145  5722		       08		      .byte.b	8	;G
   1146  5723		       00		      .byte.b	0	;B
   1147  5724		       00		      .byte.b	0	;R (51)
   1148  5725		       02		      .byte.b	2	;G
   1149  5726		       00		      .byte.b	0	;B
   1150  5727		       00		      .byte.b	0	;R (50)
   1151  5728		       40		      .byte.b	64	;G
   1152  5729		       00		      .byte.b	0	;B
   1153  572a		       00		      .byte.b	0	;R (49)
   1154  572b		       11		      .byte.b	17	;G
   1155  572c		       00		      .byte.b	0	;B
   1156  572d		       00		      .byte.b	0	;R (48)
   1157  572e		       00		      .byte.b	0	;G
   1158  572f		       00		      .byte.b	0	;B
   1159  5730		       00		      .byte.b	0	;R (47)
   1160  5731		       20		      .byte.b	32	;G
   1161  5732		       00		      .byte.b	0	;B
   1162  5733		       00		      .byte.b	0	;R (46)
   1163  5734		       08		      .byte.b	8	;G
   1164  5735		       00		      .byte.b	0	;B
   1165  5736		       00		      .byte.b	0	;R (45)
   1166  5737		       00		      .byte.b	0	;G
   1167  5738		       00		      .byte.b	0	;B
   1168  5739		       00		      .byte.b	0	;R (44)
   1169  573a		       24		      .byte.b	36	;G
   1170  573b		       00		      .byte.b	0	;B
   1171  573c		       00		      .byte.b	0	;R (43)
   1172  573d		       00		      .byte.b	0	;G
   1173  573e		       00		      .byte.b	0	;B
   1174  573f		       00		      .byte.b	0	;R (42)
   1175  5740		       04		      .byte.b	4	;G
   1176  5741		       00		      .byte.b	0	;B
   1177  5742		       00		      .byte.b	0	;R (41)
   1178  5743		       21		      .byte.b	33	;G
   1179  5744		       00		      .byte.b	0	;B
   1180  5745		       01		      .byte.b	1	;R (40)
   1181  5746		       01		      .byte.b	1	;G
   1182  5747		       00		      .byte.b	0	;B
   1183  5748		       01		      .byte.b	1	;R (39)
   1184  5749		       25		      .byte.b	37	;G
   1185  574a		       00		      .byte.b	0	;B
   1186  574b		       01		      .byte.b	1	;R (38)
   1187  574c		       01		      .byte.b	1	;G
   1188  574d		       00		      .byte.b	0	;B
   1189  574e		       03		      .byte.b	3	;R (37)
   1190  574f		       23		      .byte.b	35	;G
   1191  5750		       00		      .byte.b	0	;B
   1192  5751		       03		      .byte.b	3	;R (36)
   1193  5752		       13		      .byte.b	19	;G
   1194  5753		       00		      .byte.b	0	;B
   1195  5754		       01		      .byte.b	1	;R (35)
   1196  5755		       02		      .byte.b	2	;G
   1197  5756		       00		      .byte.b	0	;B
   1198  5757		       01		      .byte.b	1	;R (34)
   1199  5758		       10		      .byte.b	16	;G
   1200  5759		       00		      .byte.b	0	;B
   1201  575a		       03		      .byte.b	3	;R (33)
   1202  575b		       02		      .byte.b	2	;G
   1203  575c		       00		      .byte.b	0	;B
   1204  575d		       01		      .byte.b	1	;R (32)
   1205  575e		       08		      .byte.b	8	;G
   1206  575f		       00		      .byte.b	0	;B
   1207  5760		       03		      .byte.b	3	;R (31)
   1208  5761		       20		      .byte.b	32	;G
   1209  5762		       00		      .byte.b	0	;B
   1210  5763		       03		      .byte.b	3	;R (30)
   1211  5764		       00		      .byte.b	0	;G
   1212  5765		       00		      .byte.b	0	;B
   1213  5766		       03		      .byte.b	3	;R (29)
   1214  5767		       10		      .byte.b	16	;G
   1215  5768		       00		      .byte.b	0	;B
   1216  5769		       03		      .byte.b	3	;R (28)
   1217  576a		       00		      .byte.b	0	;G
   1218  576b		       00		      .byte.b	0	;B
   1219  576c		       07		      .byte.b	7	;R (27)
   1220  576d		       0e		      .byte.b	14	;G
   1221  576e		       00		      .byte.b	0	;B
   1222  576f		       03		      .byte.b	3	;R (26)
   1223  5770		       41		      .byte.b	65	;G
   1224  5771		       00		      .byte.b	0	;B
   1225  5772		       07		      .byte.b	7	;R (25)
   1226  5773		       04		      .byte.b	4	;G
   1227  5774		       00		      .byte.b	0	;B
   1228  5775		       03		      .byte.b	3	;R (24)
   1229  5776		       21		      .byte.b	33	;G
   1230  5777		       00		      .byte.b	0	;B
   1231  5778		       03		      .byte.b	3	;R (23)
   1232  5779		       04		      .byte.b	4	;G
   1233  577a		       00		      .byte.b	0	;B
   1234  577b		       03		      .byte.b	3	;R (22)
   1235  577c		       02		      .byte.b	2	;G
   1236  577d		       00		      .byte.b	0	;B
   1237  577e		       03		      .byte.b	3	;R (21)
   1238  577f		       26		      .byte.b	38	;G
   1239  5780		       00		      .byte.b	0	;B
   1240  5781		       01		      .byte.b	1	;R (20)
   1241  5782		       01		      .byte.b	1	;G
   1242  5783		       00		      .byte.b	0	;B
   1243  5784		       00		      .byte.b	0	;R (19)
   1244  5785		       21		      .byte.b	33	;G
   1245  5786		       00		      .byte.b	0	;B
   1246  5787		       01		      .byte.b	1	;R (18)
   1247  5788		       09		      .byte.b	9	;G
   1248  5789		       00		      .byte.b	0	;B
   1249  578a		       23		      .byte.b	35	;R (17)
   1250  578b		       22		      .byte.b	34	;G
   1251  578c		       00		      .byte.b	0	;B
   1252  578d		       01		      .byte.b	1	;R (16)
   1253  578e		       01		      .byte.b	1	;G
   1254  578f		       00		      .byte.b	0	;B
   1255  5790		       00		      .byte.b	0	;R (15)
   1256  5791		       29		      .byte.b	41	;G
   1257  5792		       00		      .byte.b	0	;B
   1258  5793		       00		      .byte.b	0	;R (14)
   1259  5794		       00		      .byte.b	0	;G
   1260  5795		       00		      .byte.b	0	;B
   1261  5796		       00		      .byte.b	0	;R (13)
   1262  5797		       04		      .byte.b	4	;G
   1263  5798		       00		      .byte.b	0	;B
   1264  5799		       00		      .byte.b	0	;R (12)
   1265  579a		       20		      .byte.b	32	;G
   1266  579b		       00		      .byte.b	0	;B
   1267  579c		       10		      .byte.b	16	;R (11)
   1268  579d		       12		      .byte.b	18	;G
   1269  579e		       00		      .byte.b	0	;B
   1270  579f		       00		      .byte.b	0	;R (10)
   1271  57a0		       00		      .byte.b	0	;G
   1272  57a1		       00		      .byte.b	0	;B
   1273  57a2		       00		      .byte.b	0	;R (9)
   1274  57a3		       21		      .byte.b	33	;G
   1275  57a4		       00		      .byte.b	0	;B
   1276  57a5		       00		      .byte.b	0	;R (8)
   1277  57a6		       08		      .byte.b	8	;G
   1278  57a7		       00		      .byte.b	0	;B
   1279  57a8		       00		      .byte.b	0	;R (7)
   1280  57a9		       20		      .byte.b	32	;G
   1281  57aa		       00		      .byte.b	0	;B
   1282  57ab		       00		      .byte.b	0	;R (6)
   1283  57ac		       04		      .byte.b	4	;G
   1284  57ad		       00		      .byte.b	0	;B
   1285  57ae		       20		      .byte.b	32	;R (5)
   1286  57af		       20		      .byte.b	32	;G
   1287  57b0		       00		      .byte.b	0	;B
   1288  57b1		       00		      .byte.b	0	;R (4)
   1289  57b2		       09		      .byte.b	9	;G
   1290  57b3		       00		      .byte.b	0	;B
   1291  57b4		       00		      .byte.b	0	;R (3)
   1292  57b5		       00		      .byte.b	0	;G
   1293  57b6		       00		      .byte.b	0	;B
   1294  57b7		       00		      .byte.b	0	;R (2)
   1295  57b8		       48		      .byte.b	72	;G
   1296  57b9		       00		      .byte.b	0	;B
   1297  57ba		       02		      .byte.b	2	;R (1)
   1298  57bb		       02		      .byte.b	2	;G
   1299  57bc		       00		      .byte.b	0	;B
   1300  57bd		       00		      .byte.b	0	;R (0)
   1301  57be		       00		      .byte.b	0	;G
   1302  57bf		       00		      .byte.b	0	;B
------- FILE titleScreen.asm
    265  57c0							;    include "pizza.asm"
    266  57c0
      0  57c0					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  57c0		       07 c0	   .TEMP      =	* - BANK_START
 TITLESCREEN (2K) SIZE =  $7c0 , FREE= $40
      2  57c0					      ECHO	"TITLESCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  57c0				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  57c0				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  57c0				  -	      ERR
      6  57c0					      ENDIF
      7  57c0
------- FILE ./chess.asm
------- FILE BANK_RECON.asm LEVEL 2 PASS 5
      0  57c0					      include	"BANK_RECON.asm"
      0  57c0					      NEWBANK	RECON
      1  5f90 ????				      SEG	RECON
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   RECON      SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	RECON
      2  5800
      3  5800							;---------------------------------------------------------------------------------------------------
      4  5800
      0  5800					      DEF	InitPieceList
      1  5800				   BANK_InitPieceList SET	_CURRENT_BANK
      2  5800				   InitPieceList
      3  5800				   TEMPORARY_VAR SET	Overlay
      4  5800				   TEMPORARY_OFFSET SET	0
      5  5800				   VAR_BOUNDARY_InitPieceList SET	TEMPORARY_OFFSET
      6  5800				   FUNCTION_NAME SET	InitPieceList
      7  5800					      SUBROUTINE
      6  5800					      SUBROUTINE
      7  5800
------- FILE setup_board.asm LEVEL 3 PASS 5
      0  5800					      include	"setup_board.asm"
      1  5800
      2  5800					      IF	!TEST_POSITION
      3  5800
      4  5800		       06 19		      .byte.b	WHITE|Q, 25
      5  5802		       04 18		      .byte.b	WHITE|B, 24
      6  5804		       04 1b		      .byte.b	WHITE|B, 27
      7  5806		       05 16		      .byte.b	WHITE|R, 22
      8  5808		       05 1d		      .byte.b	WHITE|R, 29
      9  580a		       03 17		      .byte.b	WHITE|N, 23
     10  580c		       03 1c		      .byte.b	WHITE|N, 28
     11  580e
     12  580e		       01 23		      .byte.b	WHITE|WP, 35
     13  5810		       01 24		      .byte.b	WHITE|WP, 36
     14  5812		       01 22		      .byte.b	WHITE|WP, 34
     15  5814		       01 25		      .byte.b	WHITE|WP, 37
     16  5816		       01 21		      .byte.b	WHITE|WP, 33
     17  5818		       01 26		      .byte.b	WHITE|WP, 38
     18  581a		       01 20		      .byte.b	WHITE|WP, 32
     19  581c		       01 27		      .byte.b	WHITE|WP, 39
     20  581e
     21  581e		       07 1a		      .byte.b	WHITE|K, 26
     22  5820
     23  5820		       86 5f		      .byte.b	BLACK|Q, 95
     24  5822		       84 5e		      .byte.b	BLACK|B, 94
     25  5824		       84 61		      .byte.b	BLACK|B, 97
     26  5826		       85 5c		      .byte.b	BLACK|R, 92
     27  5828		       85 63		      .byte.b	BLACK|R, 99
     28  582a		       83 5d		      .byte.b	BLACK|N, 93
     29  582c		       83 62		      .byte.b	BLACK|N, 98
     30  582e
     31  582e		       82 55		      .byte.b	BLACK|BP, 85
     32  5830		       82 56		      .byte.b	BLACK|BP, 86
     33  5832		       82 54		      .byte.b	BLACK|BP, 84
     34  5834		       82 57		      .byte.b	BLACK|BP, 87
     35  5836		       82 53		      .byte.b	BLACK|BP, 83
     36  5838		       82 58		      .byte.b	BLACK|BP, 88
     37  583a		       82 52		      .byte.b	BLACK|BP, 82
     38  583c		       82 59		      .byte.b	BLACK|BP, 89
     39  583e
     40  583e		       87 60		      .byte.b	BLACK|K, 96
     41  5840
     42  5840		       00		      .byte.b	0	;end
     43  5841
     44  5841				  -	      ELSE		; test position...
     45  5841				  -
     46  5841				  -
     47  5841				  -	      IF	1
     48  5841				  -
     49  5841				  -
     50  5841				  -			;.byte BLACK|R, 97
     51  5841				  -	      .byte	BLACK|K, 98
     52  5841				  -	      .byte	BLACK|BP, 87
     53  5841				  -	      .byte	BLACK|BP, 88
     54  5841				  -	      .byte	BLACK|BP, 89
     55  5841				  -			;    .byte BLACK|B, 76
     56  5841				  -
     57  5841				  -
     58  5841				  -	      .byte	WHITE|R,28
     59  5841				  -	      .byte	WHITE|Q,58
     60  5841				  -			;   .byte WHITE|N,65
     61  5841				  -	      ENDIF
     62  5841				  -
     63  5841				  -	      IF	0
     64  5841				  -			;.byte WHITE|WP, 56
     65  5841				  -
     66  5841				  -
     67  5841				  -	      .byte	BLACK|K, 98
     68  5841				  -
     69  5841				  -
     70  5841				  -	      .byte	WHITE|R,29
     71  5841				  -	      .byte	WHITE|Q,49
     72  5841				  -	      .byte	WHITE|N,65
     73  5841				  -	      ENDIF
     74  5841				  -	      .byte	0	;end
     75  5841				  -
     76  5841					      ENDIF
     77  5841
     78  5841
------- FILE BANK_RECON.asm
      9  5841
     10  5841
     11  5841							;---------------------------------------------------------------------------------------------------
     12  5841
      0  5841					      DEF	UNSAFE_showMoveCaptures
      1  5841				   BANK_UNSAFE_showMoveCaptures SET	_CURRENT_BANK
      2  5841				   UNSAFE_showMoveCaptures
      3  5841				   TEMPORARY_VAR SET	Overlay
      4  5841				   TEMPORARY_OFFSET SET	0
      5  5841				   VAR_BOUNDARY_UNSAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      6  5841				   FUNCTION_NAME SET	UNSAFE_showMoveCaptures
      7  5841					      SUBROUTINE
     14  5841					      SUBROUTINE
     15  5841
      0  5841					      REFER	SAFE_showMoveCaptures
      1  5841				  -	      IF	VAREND_SAFE_showMoveCaptures > TEMPORARY_VAR
      2  5841				  -TEMPORARY_VAR SET	VAREND_SAFE_showMoveCaptures
      3  5841					      ENDIF
      0  5841					      VAR	__toSquareX12, 1
      1  5841		       00 a7	   __toSquareX12 =	TEMPORARY_VAR
      2  5841				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5841
      4  5841				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5841				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5841				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5841					      ENDIF
      8  5841				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5841				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  5841				  -	      ERR
     11  5841					      ENDIF
     12  5841					      LIST	ON
      0  5841					      VAR	__fromPiece, 1
      1  5841		       00 a8	   __fromPiece =	TEMPORARY_VAR
      2  5841				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5841
      4  5841				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5841				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5841				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5841					      ENDIF
      8  5841				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5841				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  5841				  -	      ERR
     11  5841					      ENDIF
     12  5841					      LIST	ON
      0  5841					      VAR	__aiMoveIndex, 1
      1  5841		       00 a9	   __aiMoveIndex =	TEMPORARY_VAR
      2  5841				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5841
      4  5841				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5841				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5841				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5841					      ENDIF
      8  5841				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5841				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  5841				  -	      ERR
     11  5841					      ENDIF
     12  5841					      LIST	ON
      0  5841					      VEND	UNSAFE_showMoveCaptures
      1  5841				  -	      IFNCONST	UNSAFE_showMoveCaptures
      2  5841				  -	      ECHO	"Incorrect VEND label", UNSAFE_showMoveCaptures
      3  5841				  -	      ERR
      4  5841					      ENDIF
      5  5841		       00 aa	   VAREND_UNSAFE_showMoveCaptures =	TEMPORARY_VAR
     21  5841
     22  5841							; place a marker on the board for any square matching the piece
     23  5841							; EXCEPT for squares which are occupied (we'll flash those later)
     24  5841							; x = movelist item # being checked
     25  5841
     26  5841		       a5 8b		      lda	savedBank
     27  5843		       48		      pha
     28  5844
     29  5844		       a9 0b		      lda	#BANK_UNSAFE_showMoveCaptures
     30  5846		       85 8b		      sta	savedBank
     31  5848
     32  5848
     33  5848		       a6 8e	   .next      ldx	aiMoveIndex
     34  584a		       86 a9		      stx	__aiMoveIndex
     35  584c		       30 3a		      bmi	.skip	; no moves in list
     36  584e
     37  584e		       ad 84 02 	      lda	INTIM
     38  5851		       c9 14		      cmp	#20
     39  5853		       90 33		      bcc	.skip
     40  5855
     41  5855		       c6 8e		      dec	aiMoveIndex
     42  5857
     43  5857		       20 65 fd 	      jsr	GetP_MoveFrom
     44  585a		       c5 85		      cmp	fromX12
     45  585c		       d0 ea		      bne	.next
     46  585e
     47  585e
     48  585e		       20 71 fd 	      jsr	GetP_MoveTo
     49  5861		       85 a7		      sta	__toSquareX12
     50  5863		       a8		      tay
     51  5864		       20 7d fc 	      jsr	GetBoard
     52  5867		       29 0f		      and	#PIECE_MASK
     53  5869		       f0 dd		      beq	.next
     54  586b
     55  586b							; There's something on the board at destination, so it's a capture
     56  586b							; Let's see if we are doing a pawn promote...
     57  586b
     58  586b		       a4 85		      ldy	fromX12
     59  586d		       20 7d fc 	      jsr	GetBoard
     60  5870		       85 a8		      sta	__fromPiece
     61  5872
     62  5872		       20 7d fd 	      jsr	GetP_MovePiece
     63  5875		       45 a8		      eor	__fromPiece
     64  5877		       29 0f		      and	#PIECE_MASK
     65  5879		       f0 06		      beq	.legit	; from == to, so not a promote
     66  587b
     67  587b							; Have detected a promotion duplicate - skip all 3 of them
     68  587b
     69  587b		       c6 8e		      dec	aiMoveIndex	; skip "KBRQ" promotes
     70  587d		       c6 8e		      dec	aiMoveIndex
     71  587f		       c6 8e		      dec	aiMoveIndex
     72  5881
     73  5881				   .legit
     74  5881
     75  5881							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
     76  5881
     77  5881		       a5 a7		      lda	__toSquareX12
     78  5883		       85 80		      sta	squareToDraw
     79  5885
     80  5885		       20 ed fc 	      jsr	CopySinglePiece
     81  5888
     82  5888		       68	   .skip      pla
     83  5889		       85 8b		      sta	savedBank
     84  588b		       60		      rts
     85  588c
     86  588c		       a5 a9	   restoreIndex lda	__aiMoveIndex
     87  588e		       85 8e		      sta	aiMoveIndex
     88  5890		       4c 88 f0 	      jmp	.skip
     89  5893
     90  5893
     91  5893							;---------------------------------------------------------------------------------------------------
     92  5893
      0  5893					      DEF	aiMarchToTargetA
      1  5893				   BANK_aiMarchToTargetA SET	_CURRENT_BANK
      2  5893				   aiMarchToTargetA
      3  5893				   TEMPORARY_VAR SET	Overlay
      4  5893				   TEMPORARY_OFFSET SET	0
      5  5893				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      6  5893				   FUNCTION_NAME SET	aiMarchToTargetA
      7  5893					      SUBROUTINE
     94  5893					      SUBROUTINE
     95  5893
      0  5893					      REFER	AiStateMachine
      1  5893				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5893				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5893					      ENDIF
      0  5893					      VAR	__fromRow, 1
      1  5893		       00 a7	   __fromRow  =	TEMPORARY_VAR
      2  5893				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5893
      4  5893				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5893				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5893				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5893					      ENDIF
      8  5893				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5893				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  5893				  -	      ERR
     11  5893					      ENDIF
     12  5893					      LIST	ON
      0  5893					      VAR	__boardIndex, 1
      1  5893		       00 a8	   __boardIndex =	TEMPORARY_VAR
      2  5893				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5893
      4  5893				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5893				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5893				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5893					      ENDIF
      8  5893				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5893				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  5893				  -	      ERR
     11  5893					      ENDIF
     12  5893					      LIST	ON
      0  5893					      VAR	__fromCol, 1
      1  5893		       00 a9	   __fromCol  =	TEMPORARY_VAR
      2  5893				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5893
      4  5893				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5893				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5893				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5893					      ENDIF
      8  5893				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5893				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  5893				  -	      ERR
     11  5893					      ENDIF
     12  5893					      LIST	ON
      0  5893					      VAR	__toCol, 1
      1  5893		       00 aa	   __toCol    =	TEMPORARY_VAR
      2  5893				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5893
      4  5893				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5893				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5893				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5893					      ENDIF
      8  5893				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5893				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  5893				  -	      ERR
     11  5893					      ENDIF
     12  5893					      LIST	ON
      0  5893					      VEND	aiMarchToTargetA
      1  5893				  -	      IFNCONST	aiMarchToTargetA
      2  5893				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  5893				  -	      ERR
      4  5893					      ENDIF
      5  5893		       00 ab	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    102  5893
    103  5893
    104  5893							; Now we calculate move to new square
    105  5893
    106  5893		       a5 85		      lda	fromX12
    107  5895		       c5 86		      cmp	toX12
    108  5897		       f0 44		      beq	.unmovedx
    109  5899		       85 83		      sta	lastSquareX12
    110  589b
    111  589b		       38		      sec
    112  589c		       a2 fd		      ldx	#-3
    113  589e		       e9 0a	   .sub10     sbc	#10
    114  58a0		       e8		      inx
    115  58a1		       b0 fb		      bcs	.sub10
    116  58a3		       69 08		      adc	#8
    117  58a5		       85 a9		      sta	__fromCol
    118  58a7		       86 a7		      stx	__fromRow
    119  58a9
    120  58a9		       a5 86		      lda	toX12
    121  58ab		       38		      sec
    122  58ac		       a2 fd		      ldx	#-3
    123  58ae		       e9 0a	   .sub10b    sbc	#10
    124  58b0		       e8		      inx
    125  58b1		       b0 fb		      bcs	.sub10b
    126  58b3		       69 08		      adc	#8
    127  58b5		       85 aa		      sta	__toCol
    128  58b7
    129  58b7
    130  58b7		       e4 a7		      cpx	__fromRow
    131  58b9		       f0 13		      beq	.rowDone
    132  58bb
    133  58bb		       b0 0a		      bcs	.incRow
    134  58bd
    135  58bd		       38		      sec
    136  58be		       a5 85		      lda	fromX12
    137  58c0		       e9 0a		      sbc	#10
    138  58c2		       85 85		      sta	fromX12
    139  58c4		       4c ce f0 	      jmp	.rowDone
    140  58c7
    141  58c7		       18	   .incRow    clc
    142  58c8		       a5 85		      lda	fromX12
    143  58ca		       69 0a		      adc	#10
    144  58cc		       85 85		      sta	fromX12
    145  58ce
    146  58ce				   .rowDone
    147  58ce
    148  58ce		       a5 aa		      lda	__toCol
    149  58d0		       c5 a9		      cmp	__fromCol
    150  58d2		       f0 09		      beq	.colDone
    151  58d4
    152  58d4		       b0 05		      bcs	.incCol
    153  58d6
    154  58d6		       c6 85		      dec	fromX12
    155  58d8		       4c dd f0 	      jmp	.colDone
    156  58db
    157  58db		       e6 85	   .incCol    inc	fromX12
    158  58dd				   .colDone
    159  58dd				   .unmovedx
    160  58dd
      0  58dd					      PHASE	AI_MarchA2
      1  58dd		       a9 17		      lda	#AI_MarchA2
      2  58df		       85 8c		      sta	aiState
    162  58e1		       60		      rts
    163  58e2
    164  58e2
      0  58e2					      DEF	aiMarchA2
      1  58e2				   BANK_aiMarchA2 SET	_CURRENT_BANK
      2  58e2				   aiMarchA2
      3  58e2				   TEMPORARY_VAR SET	Overlay
      4  58e2				   TEMPORARY_OFFSET SET	0
      5  58e2				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      6  58e2				   FUNCTION_NAME SET	aiMarchA2
      7  58e2					      SUBROUTINE
    166  58e2					      SUBROUTINE
    167  58e2
    168  58e2
    169  58e2							; erase object in new sqare --> blank
    170  58e2
    171  58e2		       a4 85		      ldy	fromX12
    172  58e4		       84 80		      sty	squareToDraw
    173  58e6
    174  58e6		       20 7d fc 	      jsr	GetBoard
    175  58e9		       c9 00		      cmp	#0
    176  58eb		       f0 03		      beq	.skipbl
    177  58ed		       20 ed fc 	      jsr	CopySinglePiece	; erase next square along --> blank
    178  58f0
    179  58f0				   .skipbl
    180  58f0		       a4 85		      ldy	fromX12
    181  58f2		       84 a8		      sty	__boardIndex
    182  58f4
    183  58f4		       20 7d fc 	      jsr	GetBoard
    184  58f7		       85 99		      sta	lastPiece	; what we are overwriting
    185  58f9		       a5 98		      lda	fromPiece
    186  58fb		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    187  58fd		       29 df		      and	#~FLAG_ENPASSANT
    188  58ff		       a4 a8		      ldy	__boardIndex
    189  5901		       20 95 fc 	      jsr	PutBoard
    190  5904
      0  5904					      PHASE	AI_MarchB
      1  5904		       a9 18		      lda	#AI_MarchB
      2  5906		       85 8c		      sta	aiState
    192  5908		       60		      rts
    193  5909
    194  5909							;---------------------------------------------------------------------------------------------------
    195  5909
      0  5909					      DEF	aiMarchB2
      1  5909				   BANK_aiMarchB2 SET	_CURRENT_BANK
      2  5909				   aiMarchB2
      3  5909				   TEMPORARY_VAR SET	Overlay
      4  5909				   TEMPORARY_OFFSET SET	0
      5  5909				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      6  5909				   FUNCTION_NAME SET	aiMarchB2
      7  5909					      SUBROUTINE
    197  5909					      SUBROUTINE
    198  5909
      0  5909					      REFER	AiStateMachine
      1  5909				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5909				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5909					      ENDIF
      0  5909					      VEND	aiMarchB2
      1  5909				  -	      IFNCONST	aiMarchB2
      2  5909				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  5909				  -	      ERR
      4  5909					      ENDIF
      5  5909		       00 a7	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    201  5909
    202  5909		       a4 83		      ldy	lastSquareX12
    203  590b		       84 80		      sty	squareToDraw
    204  590d
    205  590d		       20 7d fc 	      jsr	GetBoard
    206  5910		       c9 00		      cmp	#0
    207  5912		       f0 03		      beq	.skipbl2
    208  5914
    209  5914		       20 ed fc 	      jsr	CopySinglePiece	; draw previous piece back in old position
    210  5917				   .skipbl2
    211  5917
    212  5917		       a5 85		      lda	fromX12
    213  5919		       c5 86		      cmp	toX12
    214  591b		       f0 09		      beq	xhalt
    215  591d
    216  591d		       a9 00		      lda	#0	; inter-move segment speed (can be 0)
    217  591f		       85 82		      sta	drawDelay
      0  5921					      PHASE	AI_MarchToTargetA
      1  5921		       a9 16		      lda	#AI_MarchToTargetA
      2  5923		       85 8c		      sta	aiState
    219  5925
    220  5925		       60		      rts
    221  5926
    222  5926				   xhalt
    223  5926
    224  5926							;??? jsr FinaliseMove
    225  5926
    226  5926		       a9 04		      lda	#4	; on/off count
    227  5928		       85 84		      sta	drawCount	; flashing for piece about to move
    228  592a		       a9 00		      lda	#0
    229  592c		       85 82		      sta	drawDelay
    230  592e
      0  592e					      PHASE	AI_FinalFlash
      1  592e		       a9 1b		      lda	#AI_FinalFlash
      2  5930		       85 8c		      sta	aiState
    232  5932		       60		      rts
    233  5933
    234  5933
    235  5933							;---------------------------------------------------------------------------------------------------
    236  5933
      0  5933					      DEF	aiMarchToTargetB
      1  5933				   BANK_aiMarchToTargetB SET	_CURRENT_BANK
      2  5933				   aiMarchToTargetB
      3  5933				   TEMPORARY_VAR SET	Overlay
      4  5933				   TEMPORARY_OFFSET SET	0
      5  5933				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      6  5933				   FUNCTION_NAME SET	aiMarchToTargetB
      7  5933					      SUBROUTINE
    238  5933					      SUBROUTINE
    239  5933
      0  5933					      REFER	AiStateMachine
      1  5933				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5933				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5933					      ENDIF
      0  5933					      VEND	aiMarchToTargetB
      1  5933				  -	      IFNCONST	aiMarchToTargetB
      2  5933				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  5933				  -	      ERR
      4  5933					      ENDIF
      5  5933		       00 a7	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    242  5933
    243  5933							; now we want to undraw the piece in the old square
    244  5933
    245  5933		       a5 83		      lda	lastSquareX12
    246  5935		       85 80		      sta	squareToDraw
    247  5937
    248  5937		       20 ed fc 	      jsr	CopySinglePiece	; erase whatever was on the previous square (completely blank)
    249  593a
    250  593a		       a4 83		      ldy	lastSquareX12
    251  593c		       a5 9a		      lda	previousPiece
    252  593e		       20 95 fc 	      jsr	PutBoard
    253  5941
    254  5941		       a5 99		      lda	lastPiece
    255  5943		       85 9a		      sta	previousPiece
    256  5945
      0  5945					      PHASE	AI_MarchB2
      1  5945		       a9 1a		      lda	#AI_MarchB2
      2  5947		       85 8c		      sta	aiState
    258  5949		       60		      rts
    259  594a
    260  594a
    261  594a							;---------------------------------------------------------------------------------------------------
    262  594a
      0  594a					      DEF	CopySetupForMarker
      1  594a				   BANK_CopySetupForMarker SET	_CURRENT_BANK
      2  594a				   CopySetupForMarker
      3  594a				   TEMPORARY_VAR SET	Overlay
      4  594a				   TEMPORARY_OFFSET SET	0
      5  594a				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      6  594a				   FUNCTION_NAME SET	CopySetupForMarker
      7  594a					      SUBROUTINE
    264  594a					      SUBROUTINE
    265  594a
      0  594a					      REFER	markerDraw
      1  594a					      IF	VAREND_markerDraw > TEMPORARY_VAR
      2  594a				   TEMPORARY_VAR SET	VAREND_markerDraw
      3  594a					      ENDIF
      0  594a					      REFER	showPromoteOptions
      1  594a				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  594a				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  594a					      ENDIF
      0  594a					      VAR	__pieceColour, 1
      1  594a		       00 a9	   __pieceColour =	TEMPORARY_VAR
      2  594a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  594a
      4  594a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  594a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  594a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  594a					      ENDIF
      8  594a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  594a				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  594a				  -	      ERR
     11  594a					      ENDIF
     12  594a					      LIST	ON
      0  594a					      VAR	__oddeven, 1
      1  594a		       00 aa	   __oddeven  =	TEMPORARY_VAR
      2  594a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  594a
      4  594a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  594a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  594a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  594a					      ENDIF
      8  594a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  594a				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  594a				  -	      ERR
     11  594a					      ENDIF
     12  594a					      LIST	ON
      0  594a					      VAR	__pmcol, 1
      1  594a		       00 ab	   __pmcol    =	TEMPORARY_VAR
      2  594a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  594a
      4  594a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  594a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  594a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  594a					      ENDIF
      8  594a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  594a				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  594a				  -	      ERR
     11  594a					      ENDIF
     12  594a					      LIST	ON
      0  594a					      VEND	CopySetupForMarker
      1  594a				  -	      IFNCONST	CopySetupForMarker
      2  594a				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  594a				  -	      ERR
      4  594a					      ENDIF
      5  594a		       00 ac	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    272  594a
    273  594a		       a5 80		      lda	squareToDraw
    274  594c		       38		      sec
    275  594d		       a0 0a		      ldy	#10
    276  594f		       e9 0a	   .sub10     sbc	#10
    277  5951		       88		      dey
    278  5952		       b0 fb		      bcs	.sub10
    279  5954		       84 aa		      sty	__oddeven
    280  5956		       69 08		      adc	#8
    281  5958		       85 ab		      sta	__pmcol
    282  595a		       65 aa		      adc	__oddeven
    283  595c
    284  595c		       29 01		      and	#1
    285  595e		       49 01		      eor	#1
    286  5960		       f0 02		      beq	.white
    287  5962		       a9 24		      lda	#36
    288  5964				   .white
    289  5964		       85 a9		      sta	__pieceColour	; actually SQUARE black/white
    290  5966
    291  5966		       8a		      txa
    292  5967		       18		      clc
    293  5968		       65 a9		      adc	__pieceColour
    294  596a		       85 a9		      sta	__pieceColour
    295  596c
    296  596c		       a5 ab		      lda	__pmcol
    297  596e		       29 03		      and	#3
    298  5970
    299  5970		       18		      clc
    300  5971		       65 a9		      adc	__pieceColour
    301  5973		       a8		      tay
    302  5974		       60		      rts
    303  5975
    304  5975							;---------------------------------------------------------------------------------------------------
    305  5975
      0  5975					      DEF	CopySetup
      1  5975				   BANK_CopySetup SET	_CURRENT_BANK
      2  5975				   CopySetup
      3  5975				   TEMPORARY_VAR SET	Overlay
      4  5975				   TEMPORARY_OFFSET SET	0
      5  5975				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      6  5975				   FUNCTION_NAME SET	CopySetup
      7  5975					      SUBROUTINE
    307  5975					      SUBROUTINE
    308  5975
      0  5975					      REFER	CopySinglePiece
      1  5975					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  5975				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  5975					      ENDIF
      0  5975					      VAR	__tmp, 1
      1  5975		       00 b3	   __tmp      =	TEMPORARY_VAR
      2  5975				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5975
      4  5975				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5975				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5975				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5975					      ENDIF
      8  5975				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5975				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  5975				  -	      ERR
     11  5975					      ENDIF
     12  5975					      LIST	ON
      0  5975					      VAR	__shiftx, 1
      1  5975		       00 b4	   __shiftx   =	TEMPORARY_VAR
      2  5975				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5975
      4  5975				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5975				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5975				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5975					      ENDIF
      8  5975				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5975				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  5975				  -	      ERR
     11  5975					      ENDIF
     12  5975					      LIST	ON
      0  5975					      VEND	CopySetup
      1  5975				  -	      IFNCONST	CopySetup
      2  5975				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  5975				  -	      ERR
      4  5975					      ENDIF
      5  5975		       00 b5	   VAREND_CopySetup =	TEMPORARY_VAR
    313  5975
    314  5975		       a5 8b		      lda	savedBank
    315  5977		       48		      pha
    316  5978		       a9 0b		      lda	#BANK_CopySetup
    317  597a		       85 8b		      sta	savedBank
    318  597c
    319  597c							; figure colouration of square
    320  597c
    321  597c		       a5 80		      lda	squareToDraw
    322  597e
    323  597e					      IF	DIAGNOSTICS
    324  597e							; Catch out-of-range piece square
    325  597e							; will not catch off left/right edge
    326  597e
    327  597e		       c9 64	   .fail      cmp	#100
    328  5980		       b0 fc		      bcs	.fail
    329  5982		       c9 16		      cmp	#22
    330  5984		       90 f8		      bcc	.fail
    331  5986					      ENDIF
    332  5986
    333  5986
    334  5986		       a2 0a		      ldx	#10
    335  5988		       38		      sec
    336  5989		       e9 0a	   .sub10     sbc	#10
    337  598b		       ca		      dex
    338  598c		       b0 fb		      bcs	.sub10
    339  598e		       69 08		      adc	#8
    340  5990		       85 b4		      sta	__shiftx
    341  5992					      IF	DIAGNOSTICS
    342  5992		       c9 08	   .fail2     cmp	#8
    343  5994		       b0 fc		      bcs	.fail2
    344  5996		       e0 08		      cpx	#8
    345  5998		       b0 f8		      bcs	.fail2
    346  599a					      ENDIF
    347  599a		       86 b3		      stx	__tmp
    348  599c		       65 b3		      adc	__tmp
    349  599e
    350  599e
    351  599e
    352  599e
    353  599e		       29 01		      and	#1
    354  59a0							;eor #1
    355  59a0		       f0 02		      beq	.white
    356  59a2		       a9 24		      lda	#36
    357  59a4		       85 a9	   .white     sta	__pieceColour	; actually SQUARE black/white
    358  59a6
    359  59a6							; PieceColour = 0 for white square, 36 for black square
    360  59a6
    361  59a6							;lda #RAMBANK_BOARD
    362  59a6							;sta SET_BANK_RAM
    363  59a6
    364  59a6		       a4 80		      ldy	squareToDraw
    365  59a8		       20 7d fc 	      jsr	GetBoard	;lda Board,x
    366  59ab		       0a		      asl
    367  59ac		       90 02		      bcc	.blackAdjust
    368  59ae		       09 10		      ora	#16
    369  59b0		       4a	   .blackAdjust lsr
    370  59b1		       29 0f		      and	#%1111
    371  59b3		       aa		      tax
    372  59b4
    373  59b4		       a5 b4		      lda	__shiftx
    374  59b6		       29 03		      and	#3	; shift position in P
    375  59b8
    376  59b8		       18		      clc
    377  59b9		       7d c4 f1 	      adc	PieceToShape,x
    378  59bc		       18		      clc
    379  59bd		       65 a9		      adc	__pieceColour
    380  59bf		       a8		      tay
    381  59c0
    382  59c0		       68		      pla
    383  59c1		       85 8b		      sta	savedBank
    384  59c3		       60		      rts
    385  59c4
    386  59c4				   PieceToShape
    387  59c4
    388  59c4		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    389  59c5		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    390  59c6		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    391  59c7		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    392  59c8		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    393  59c9		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    394  59ca		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    395  59cb		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    396  59cc
    397  59cc		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    398  59cd		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    399  59ce		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    400  59cf		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    401  59d0		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    402  59d1		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    403  59d2		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    404  59d3		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    405  59d4
    406  59d4							;---------------------------------------------------------------------------------------------------
    407  59d4
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  59d4					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  59d4					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  5a00					      LIST	ON
      0  5a00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  5a00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  5a00				   BLACK_BISHOP_on_BLACK_SQUARE_0
      3  5a00				   TEMPORARY_VAR SET	Overlay
      4  5a00				   TEMPORARY_OFFSET SET	0
      5  5a00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5a00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      7  5a00					      SUBROUTINE
      3  5a00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  5a18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  5a48					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  5a48					      LIST	ON
      0  5a48					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  5a48				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5a48				   BLACK_BISHOP_on_BLACK_SQUARE_1
      3  5a48				   TEMPORARY_VAR SET	Overlay
      4  5a48				   TEMPORARY_OFFSET SET	0
      5  5a48				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5a48				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      7  5a48					      SUBROUTINE
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  5a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5a90					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  5a90					      LIST	ON
      0  5a90					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  5a90				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5a90				   BLACK_BISHOP_on_BLACK_SQUARE_2
      3  5a90				   TEMPORARY_VAR SET	Overlay
      4  5a90				   TEMPORARY_OFFSET SET	0
      5  5a90				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5a90				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      7  5a90					      SUBROUTINE
      3  5a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  5ad8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  5b00					      LIST	ON
      0  5b00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  5b00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5b00				   BLACK_BISHOP_on_BLACK_SQUARE_3
      3  5b00				   TEMPORARY_VAR SET	Overlay
      4  5b00				   TEMPORARY_OFFSET SET	0
      5  5b00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5b00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      7  5b00					      SUBROUTINE
      3  5b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  5b48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  5b48					      LIST	ON
      0  5b48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  5b48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  5b48				   BLACK_ROOK_on_BLACK_SQUARE_0
      3  5b48				   TEMPORARY_VAR SET	Overlay
      4  5b48				   TEMPORARY_OFFSET SET	0
      5  5b48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5b48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      7  5b48					      SUBROUTINE
      3  5b48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  5b60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  5b90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  5b90					      LIST	ON
      0  5b90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  5b90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5b90				   BLACK_ROOK_on_BLACK_SQUARE_1
      3  5b90				   TEMPORARY_VAR SET	Overlay
      4  5b90				   TEMPORARY_OFFSET SET	0
      5  5b90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5b90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      7  5b90					      SUBROUTINE
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  5bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5bd8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  5bd8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  5c00					      LIST	ON
      0  5c00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  5c00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5c00				   BLACK_ROOK_on_BLACK_SQUARE_2
      3  5c00				   TEMPORARY_VAR SET	Overlay
      4  5c00				   TEMPORARY_OFFSET SET	0
      5  5c00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5c00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      7  5c00					      SUBROUTINE
      3  5c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  5c30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  5c48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  5c48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  5c48					      LIST	ON
      0  5c48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  5c48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5c48				   BLACK_ROOK_on_BLACK_SQUARE_3
      3  5c48				   TEMPORARY_VAR SET	Overlay
      4  5c48				   TEMPORARY_OFFSET SET	0
      5  5c48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5c48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      7  5c48					      SUBROUTINE
      3  5c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  5c90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  5c90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  5c90					      LIST	ON
      0  5c90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  5c90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  5c90				   BLACK_QUEEN_on_BLACK_SQUARE_0
      3  5c90				   TEMPORARY_VAR SET	Overlay
      4  5c90				   TEMPORARY_OFFSET SET	0
      5  5c90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5c90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      7  5c90					      SUBROUTINE
      3  5c90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ca8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  5cd8					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  5cd8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  5d00					      LIST	ON
      0  5d00					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  5d00				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5d00				   BLACK_QUEEN_on_BLACK_SQUARE_1
      3  5d00				   TEMPORARY_VAR SET	Overlay
      4  5d00				   TEMPORARY_OFFSET SET	0
      5  5d00				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5d00				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      7  5d00					      SUBROUTINE
      3  5d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5d18		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5d48					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  5d48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  5d48					      LIST	ON
      0  5d48					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  5d48				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5d48				   BLACK_QUEEN_on_BLACK_SQUARE_2
      3  5d48				   TEMPORARY_VAR SET	Overlay
      4  5d48				   TEMPORARY_OFFSET SET	0
      5  5d48				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5d48				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      7  5d48					      SUBROUTINE
      3  5d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5d60		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d78		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  5d90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  5d90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  5d90					      LIST	ON
      0  5d90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  5d90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5d90				   BLACK_QUEEN_on_BLACK_SQUARE_3
      3  5d90				   TEMPORARY_VAR SET	Overlay
      4  5d90				   TEMPORARY_OFFSET SET	0
      5  5d90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5d90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      7  5d90					      SUBROUTINE
      3  5d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5da8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5dc0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  5dd8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  5dd8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  5e00					      LIST	ON
      0  5e00					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  5e00				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  5e00				   BLACK_KING_on_BLACK_SQUARE_0
      3  5e00				   TEMPORARY_VAR SET	Overlay
      4  5e00				   TEMPORARY_OFFSET SET	0
      5  5e00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5e00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      7  5e00					      SUBROUTINE
      3  5e00		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$a0,$00,$00,$b0,$00,$00	;PF0
      4  5e18		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00	;PF1
      5  5e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  5e48					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  5e48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  5e48					      LIST	ON
      0  5e48					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  5e48				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5e48				   BLACK_KING_on_BLACK_SQUARE_1
      3  5e48				   TEMPORARY_VAR SET	Overlay
      4  5e48				   TEMPORARY_OFFSET SET	0
      5  5e48				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5e48				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      7  5e48					      SUBROUTINE
      3  5e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5e60		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$28,$00,$00,$6c,$00,$00	;PF1
      5  5e78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5e90					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  5e90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  5e90					      LIST	ON
      0  5e90					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  5e90				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5e90				   BLACK_KING_on_BLACK_SQUARE_2
      3  5e90				   TEMPORARY_VAR SET	Overlay
      4  5e90				   TEMPORARY_OFFSET SET	0
      5  5e90				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5e90				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      7  5e90					      SUBROUTINE
      3  5e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ea8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$01,$00,$00,$03,$00,$00	;PF1
      5  5ec0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$02,$00,$00,$06,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  5ed8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  5ed8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  5f00					      LIST	ON
      0  5f00					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  5f00				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5f00				   BLACK_KING_on_BLACK_SQUARE_3
      3  5f00				   TEMPORARY_VAR SET	Overlay
      4  5f00				   TEMPORARY_OFFSET SET	0
      5  5f00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5f00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      7  5f00					      SUBROUTINE
      3  5f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$50,$00,$00,$d8,$00,$00	;PF2
------- FILE BANK_RECON.asm
    424  5f48
    425  5f48
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  5f48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  5f48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  5f48					      LIST	ON
      0  5f48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  5f48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  5f48				   WHITE_MARKER_on_WHITE_SQUARE_3
      3  5f48				   TEMPORARY_VAR SET	Overlay
      4  5f48				   TEMPORARY_OFFSET SET	0
      5  5f48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5f48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      7  5f48					      SUBROUTINE
      3  5f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$70,$70,$70,$70,$00,$00,$00,$70,$70,$70,$70,$70,$00,$00	;PF2
------- FILE BANK_RECON.asm
    427  5f90
      0  5f90					      CHECK_BANK_SIZE	"BANK_RECON"
      1  5f90		       07 90	   .TEMP      =	* - BANK_START
 BANK_RECON (2K) SIZE =  $790 , FREE= $70
      2  5f90					      ECHO	"BANK_RECON", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5f90				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  5f90				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5f90				  -	      ERR
      6  5f90					      ENDIF
      7  5f90
    429  5f90
    430  5f90							; EOF
------- FILE ./chess.asm
    603  5f90
    604  5f90							; The handlers for piece move generation
------- FILE Handler_BANK1.asm LEVEL 2 PASS 5
      0  5f90					      include	"Handler_BANK1.asm"
      1  5f90							; Copyright (C)2020 Andrew Davie
      2  5f90
      3  5f90							;---------------------------------------------------------------------------------------------------
      4  5f90
      0  5f90					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1  5f90
      2  5f90
      3  5f90
      4 U2400 ????				      SEG.U	BOARD
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	RAM_3E
      7 U2400				   BANK_START SET	*
      8 U2400				   RAMBANK_BOARD SET	ORIGIN_RAM / RAM_SIZE
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U2400					      NEWBANK	MOVES	; copy the following bank to RAMBANK_BOARD
      1  6690 ????				      SEG	MOVES
      2  6000					      ORG	ORIGIN
      3  6000					      RORG	$F000
      4  6000				   BANK_START SET	*
      5  6000				   MOVES      SET	ORIGIN / 2048
      6  6000				   ORIGIN     SET	ORIGIN + 2048
      7  6000				   _CURRENT_BANK SET	MOVES
      7  6000
      8  6000							; Board is a 10 x 12 object which simplifies the generation of moves
      9  6000							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     10  6000							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     11  6000
     12  6000							;     X12 numbering
     13  6000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     14  6000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     15  6000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     16  6000							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     17  6000							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     18  6000							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     19  6000							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     20  6000							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     21  6000							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     22  6000							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     23  6000							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     24  6000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     25  6000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     26  6000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     27  6000							;	0   1	2   3	4   5	6   7	8   9
     28  6000							;		A   B	C   D	E   F	G   H
     29  6000
     30  6000							;     HEX X12
     31  6000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     32  6000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     33  6000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     34  6000							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     35  6000							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     36  6000							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     37  6000							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     38  6000							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     39  6000							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     40  6000							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     41  6000							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     42  6000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     43  6000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     44  6000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     45  6000							;	0   1	2   3	4   5	6   7	8   9
     46  6000							;		A   B	C   D	E   F	G   H
     47  6000
     48  6000
     49  6000							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     50  6000							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     51  6000							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     52  6000							; be re-used for something else - we just need to guarantee there are 21 of them there
     53  6000
      0  6000					      ALLOCATE	Valid, 120 + 80 + 32	;21
      0  6000					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 32
     12  6000					      LIST	ON
      0  6000					      DEF	Valid
      1  6000				   BANK_Valid SET	_CURRENT_BANK
      2  6000				   Valid
      3  6000				   TEMPORARY_VAR SET	Overlay
      4  6000				   TEMPORARY_OFFSET SET	0
      5  6000				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      6  6000				   FUNCTION_NAME SET	Valid
      7  6000					      SUBROUTINE
     55  6000							;ds 21 		     ; so indexing of "ValidSquare-21,x" won't fail
     56  6000
     57  6000							;DEF PieceList
     58  6000							;ds 16
     59  6000
     60  6000					      MAC	handlevec
     61  6000					      .byte	{1}MoveReturn
     62  6000					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
     63  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
     64  6000					      .byte	{1}Handle_KNIGHT	; 3
     65  6000					      .byte	{1}Handle_BISHOP	; 4
     66  6000					      .byte	{1}Handle_ROOK	; 5
     67  6000					      .byte	{1}Handle_QUEEN	; 6
     68  6000					      .byte	{1}Handle_KING	; 7
     69  6000
     70  6000					      .byte	{1}MoveReturn
     71  6000					      .byte	{1}Handle_WHITE_PAWN	; 1
     72  6000					      .byte	{1}Handle_BLACK_PAWN	; 2
     73  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
     74  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
     75  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
     76  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
     77  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
     78  6000					      ENDM
     79  6000
     80  6000
     81  6000							;ALLOCATE Handlers, 32
     82  6000
     83  6000							;    .byte 0	  ; dummy to prevent page cross access on index 0
     84  6000
      0  6000				   HandlerVectorLO HANDLEVEC	<
      1  6000		       2b		      .byte.b	<MoveReturn
      2  6001		       2b		      .byte.b	<MoveReturn
      3  6002		       2b		      .byte.b	<MoveReturn
      4  6003		       4d		      .byte.b	<Handle_KNIGHT
      5  6004		       f5		      .byte.b	<Handle_BISHOP
      6  6005		       70		      .byte.b	<Handle_ROOK
      7  6006		       02		      .byte.b	<Handle_QUEEN
      8  6007		       eb		      .byte.b	<Handle_KING
      9  6008
     10  6008		       2b		      .byte.b	<MoveReturn
     11  6009		       32		      .byte.b	<Handle_WHITE_PAWN
     12  600a		       d4		      .byte.b	<Handle_BLACK_PAWN
     13  600b		       2b		      .byte.b	<MoveReturn
     14  600c		       2b		      .byte.b	<MoveReturn
     15  600d		       2b		      .byte.b	<MoveReturn
     16  600e		       2b		      .byte.b	<MoveReturn
     17  600f		       2b		      .byte.b	<MoveReturn
      0  6010				   HandlerVectorHI HANDLEVEC	>
      1  6010		       f9		      .byte.b	>MoveReturn
      2  6011		       f9		      .byte.b	>MoveReturn
      3  6012		       f9		      .byte.b	>MoveReturn
      4  6013		       fb		      .byte.b	>Handle_KNIGHT
      5  6014		       f1		      .byte.b	>Handle_BISHOP
      6  6015		       f2		      .byte.b	>Handle_ROOK
      7  6016		       f1		      .byte.b	>Handle_QUEEN
      8  6017		       f2		      .byte.b	>Handle_KING
      9  6018
     10  6018		       f9		      .byte.b	>MoveReturn
     11  6019		       fa		      .byte.b	>Handle_WHITE_PAWN
     12  601a		       fa		      .byte.b	>Handle_BLACK_PAWN
     13  601b		       f9		      .byte.b	>MoveReturn
     14  601c		       f9		      .byte.b	>MoveReturn
     15  601d		       f9		      .byte.b	>MoveReturn
     16  601e		       f9		      .byte.b	>MoveReturn
     17  601f		       f9		      .byte.b	>MoveReturn
     87  6020
     88  6020
     89  6020							; Note, we will never index INTO the above bytes - x will always be >= 22
     90  6020							; We just need to make sure that the actual indexing will not have an address before
     91  6020							; the index of outside the page.
     92  6020
      0  6020					      DEF	ValidSquare
      1  6020				   BANK_ValidSquare SET	_CURRENT_BANK
      2  6020				   ValidSquare
      3  6020				   TEMPORARY_VAR SET	Overlay
      4  6020				   TEMPORARY_OFFSET SET	0
      5  6020				   VAR_BOUNDARY_ValidSquare SET	TEMPORARY_OFFSET
      6  6020				   FUNCTION_NAME SET	ValidSquare
      7  6020					      SUBROUTINE
     94  6020
     95  6020
     96  6020							; Use this table to
     97  6020							;   a) Determine if a square is valid (-1 = NO)
     98  6020							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     99  6020							;	if a white pawn on square "x" can move "up" the board.
    100  6020
    101  6020		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    102  602a		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    103  6034		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
    104  603e		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
    105  6048		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
    106  6052		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
    107  605c		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
    108  6066		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
    109  6070		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
    110  607a		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
    111  6084
      0  6084					      DEF	Board
      1  6084				   BANK_Board SET	_CURRENT_BANK
      2  6084				   Board
      3  6084				   TEMPORARY_VAR SET	Overlay
      4  6084				   TEMPORARY_OFFSET SET	0
      5  6084				   VAR_BOUNDARY_Board SET	TEMPORARY_OFFSET
      6  6084				   FUNCTION_NAME SET	Board
      7  6084					      SUBROUTINE
    113  6084
    114  6084							; A 10X10... we should never write using invalid square
    115  6084							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
    116  6084							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
    117  6084
    118  6084		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
    119  608e		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
    120  6098
    121  6098					      REPEAT	8
    122  6098		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  6098					      REPEND
    122  60a2		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60a2					      REPEND
    122  60ac		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60ac					      REPEND
    122  60b6		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60b6					      REPEND
    122  60c0		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60c0					      REPEND
    122  60ca		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60ca					      REPEND
    122  60d4		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60d4					      REPEND
    122  60de		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    123  60e8					      REPEND
    124  60e8
    125  60e8							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
    126  60e8
    127  60e8
      0  60e8					      DEF	handleIt
      1  60e8				   BANK_handleIt SET	_CURRENT_BANK
      2  60e8				   handleIt
      3  60e8				   TEMPORARY_VAR SET	Overlay
      4  60e8				   TEMPORARY_OFFSET SET	0
      5  60e8				   VAR_BOUNDARY_handleIt SET	TEMPORARY_OFFSET
      6  60e8				   FUNCTION_NAME SET	handleIt
      7  60e8					      SUBROUTINE
    129  60e8					      SUBROUTINE
    130  60e8
    131  60e8
    132  60e8		       86 93		      stx	currentSquare
    133  60ea
    134  60ea		       45 97		      eor	sideToMove
    135  60ec		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    136  60ee		       85 92		      sta	currentPiece
    137  60f0		       29 0f		      and	#PIECE_MASK
    138  60f2		       05 b7		      ora	__pieceFilter
    139  60f4		       a8		      tay
    140  60f5
    141  60f5		       b9 10 f0 	      lda	HandlerVectorHI,y
    142  60f8		       85 b4		      sta	__vector+1
    143  60fa		       b9 00 f0 	      lda	HandlerVectorLO,y
    144  60fd		       85 b3		      sta	__vector
    145  60ff		       6c b3 00 	      jmp	(__vector)
    146  6102
    147  6102
    148  6102							;---------------------------------------------------------------------------------------------------
    149  6102
------- FILE Handler_QUEEN.asm LEVEL 3 PASS 5
      0  6102					      include	"Handler_QUEEN.asm"
      1  6102							; Copyright (C)2020 Andrew Davie
      2  6102
      3  6102							;---------------------------------------------------------------------------------------------------
      4  6102							; QUEEN
      5  6102							;---------------------------------------------------------------------------------------------------
      6  6102
      0  6102					      DEF	Handle_QUEEN
      1  6102				   BANK_Handle_QUEEN SET	_CURRENT_BANK
      2  6102				   Handle_QUEEN
      3  6102				   TEMPORARY_VAR SET	Overlay
      4  6102				   TEMPORARY_OFFSET SET	0
      5  6102				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      6  6102				   FUNCTION_NAME SET	Handle_QUEEN
      7  6102					      SUBROUTINE
      8  6102					      SUBROUTINE
      9  6102
      0  6102					      REFER	GenerateAllMoves
      1  6102					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6102				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6102					      ENDIF
      0  6102					      VEND	Handle_QUEEN
      1  6102				  -	      IFNCONST	Handle_QUEEN
      2  6102				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  6102				  -	      ERR
      4  6102					      ENDIF
      5  6102		       00 c9	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  6102
     13  6102							; Pass...
     14  6102							; x = currentSquare (square the piece is on)
     15  6102							; currentPiece (with flags/colour attached)
     16  6102
      0  6102					      MOVE_TOWARDS	_DOWN+_LEFT
      1  6102					      SUBROUTINE
      2  6102
      3  6102
      4  6102
      5  6102		       a9 00		      lda	#0
      6  6104		       85 9f		      sta	capture
      7  6106
      8  6106		       a6 93		      ldx	currentSquare
      9  6108		       d0 03		      bne	.project
     10  610a
     11  610a		       20 f6 fb    .empty     jsr	AddMove
     12  610d		       bc 15 f0    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6110		       30 0e		      bmi	.invalid
     14  6112		       b9 84 f0 	      lda	Board,y
     15  6115		       f0 f3		      beq	.empty
     16  6117		       85 9f		      sta	capture
     17  6119		       45 92		      eor	currentPiece
     18  611b		       10 03		      bpl	.invalid
     19  611d		       20 f6 fb 	      jsr	AddMove
     20  6120
     21  6120				   .invalid
      0  6120					      MOVE_TOWARDS	_DOWN
      1  6120					      SUBROUTINE
      2  6120
      3  6120
      4  6120
      5  6120		       a9 00		      lda	#0
      6  6122		       85 9f		      sta	capture
      7  6124
      8  6124		       a6 93		      ldx	currentSquare
      9  6126		       d0 03		      bne	.project
     10  6128
     11  6128		       20 f6 fb    .empty     jsr	AddMove
     12  612b		       bc 16 f0    .project   ldy	ValidSquare+_DOWN,x
     13  612e		       30 0e		      bmi	.invalid
     14  6130		       b9 84 f0 	      lda	Board,y
     15  6133		       f0 f3		      beq	.empty
     16  6135		       85 9f		      sta	capture
     17  6137		       45 92		      eor	currentPiece
     18  6139		       10 03		      bpl	.invalid
     19  613b		       20 f6 fb 	      jsr	AddMove
     20  613e
     21  613e				   .invalid
      0  613e					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  613e					      SUBROUTINE
      2  613e
      3  613e
      4  613e
      5  613e		       a9 00		      lda	#0
      6  6140		       85 9f		      sta	capture
      7  6142
      8  6142		       a6 93		      ldx	currentSquare
      9  6144		       d0 03		      bne	.project
     10  6146
     11  6146		       20 f6 fb    .empty     jsr	AddMove
     12  6149		       bc 17 f0    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  614c		       30 0e		      bmi	.invalid
     14  614e		       b9 84 f0 	      lda	Board,y
     15  6151		       f0 f3		      beq	.empty
     16  6153		       85 9f		      sta	capture
     17  6155		       45 92		      eor	currentPiece
     18  6157		       10 03		      bpl	.invalid
     19  6159		       20 f6 fb 	      jsr	AddMove
     20  615c
     21  615c				   .invalid
      0  615c					      MOVE_TOWARDS	_RIGHT
      1  615c					      SUBROUTINE
      2  615c
      3  615c
      4  615c
      5  615c		       a9 00		      lda	#0
      6  615e		       85 9f		      sta	capture
      7  6160
      8  6160		       a6 93		      ldx	currentSquare
      9  6162		       d0 03		      bne	.project
     10  6164
     11  6164		       20 f6 fb    .empty     jsr	AddMove
     12  6167		       bc 21 f0    .project   ldy	ValidSquare+_RIGHT,x
     13  616a		       30 0e		      bmi	.invalid
     14  616c		       b9 84 f0 	      lda	Board,y
     15  616f		       f0 f3		      beq	.empty
     16  6171		       85 9f		      sta	capture
     17  6173		       45 92		      eor	currentPiece
     18  6175		       10 03		      bpl	.invalid
     19  6177		       20 f6 fb 	      jsr	AddMove
     20  617a
     21  617a				   .invalid
      0  617a					      MOVE_TOWARDS	_UP+_RIGHT
      1  617a					      SUBROUTINE
      2  617a
      3  617a
      4  617a
      5  617a		       a9 00		      lda	#0
      6  617c		       85 9f		      sta	capture
      7  617e
      8  617e		       a6 93		      ldx	currentSquare
      9  6180		       d0 03		      bne	.project
     10  6182
     11  6182		       20 f6 fb    .empty     jsr	AddMove
     12  6185		       bc 2b f0    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6188		       30 0e		      bmi	.invalid
     14  618a		       b9 84 f0 	      lda	Board,y
     15  618d		       f0 f3		      beq	.empty
     16  618f		       85 9f		      sta	capture
     17  6191		       45 92		      eor	currentPiece
     18  6193		       10 03		      bpl	.invalid
     19  6195		       20 f6 fb 	      jsr	AddMove
     20  6198
     21  6198				   .invalid
      0  6198					      MOVE_TOWARDS	_UP
      1  6198					      SUBROUTINE
      2  6198
      3  6198
      4  6198
      5  6198		       a9 00		      lda	#0
      6  619a		       85 9f		      sta	capture
      7  619c
      8  619c		       a6 93		      ldx	currentSquare
      9  619e		       d0 03		      bne	.project
     10  61a0
     11  61a0		       20 f6 fb    .empty     jsr	AddMove
     12  61a3		       bc 2a f0    .project   ldy	ValidSquare+_UP,x
     13  61a6		       30 0e		      bmi	.invalid
     14  61a8		       b9 84 f0 	      lda	Board,y
     15  61ab		       f0 f3		      beq	.empty
     16  61ad		       85 9f		      sta	capture
     17  61af		       45 92		      eor	currentPiece
     18  61b1		       10 03		      bpl	.invalid
     19  61b3		       20 f6 fb 	      jsr	AddMove
     20  61b6
     21  61b6				   .invalid
      0  61b6					      MOVE_TOWARDS	_UP+_LEFT
      1  61b6					      SUBROUTINE
      2  61b6
      3  61b6
      4  61b6
      5  61b6		       a9 00		      lda	#0
      6  61b8		       85 9f		      sta	capture
      7  61ba
      8  61ba		       a6 93		      ldx	currentSquare
      9  61bc		       d0 03		      bne	.project
     10  61be
     11  61be		       20 f6 fb    .empty     jsr	AddMove
     12  61c1		       bc 29 f0    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  61c4		       30 0e		      bmi	.invalid
     14  61c6		       b9 84 f0 	      lda	Board,y
     15  61c9		       f0 f3		      beq	.empty
     16  61cb		       85 9f		      sta	capture
     17  61cd		       45 92		      eor	currentPiece
     18  61cf		       10 03		      bpl	.invalid
     19  61d1		       20 f6 fb 	      jsr	AddMove
     20  61d4
     21  61d4				   .invalid
      0  61d4					      MOVE_TOWARDS	_LEFT
      1  61d4					      SUBROUTINE
      2  61d4
      3  61d4
      4  61d4
      5  61d4		       a9 00		      lda	#0
      6  61d6		       85 9f		      sta	capture
      7  61d8
      8  61d8		       a6 93		      ldx	currentSquare
      9  61da		       d0 03		      bne	.project
     10  61dc
     11  61dc		       20 f6 fb    .empty     jsr	AddMove
     12  61df		       bc 1f f0    .project   ldy	ValidSquare+_LEFT,x
     13  61e2		       30 0e		      bmi	.invalid
     14  61e4		       b9 84 f0 	      lda	Board,y
     15  61e7		       f0 f3		      beq	.empty
     16  61e9		       85 9f		      sta	capture
     17  61eb		       45 92		      eor	currentPiece
     18  61ed		       10 03		      bpl	.invalid
     19  61ef		       20 f6 fb 	      jsr	AddMove
     20  61f2
     21  61f2				   .invalid
     25  61f2
     26  61f2		       4c 2b f9 	      jmp	MoveReturn
     27  61f5
     28  61f5							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_BISHOP.asm LEVEL 3 PASS 5
      0  61f5					      include	"Handler_BISHOP.asm"
      1  61f5							; Copyright (C)2020 Andrew Davie
      2  61f5
      3  61f5							;---------------------------------------------------------------------------------------------------
      4  61f5							; BISHOP
      5  61f5							;---------------------------------------------------------------------------------------------------
      6  61f5
      0  61f5					      DEF	Handle_BISHOP
      1  61f5				   BANK_Handle_BISHOP SET	_CURRENT_BANK
      2  61f5				   Handle_BISHOP
      3  61f5				   TEMPORARY_VAR SET	Overlay
      4  61f5				   TEMPORARY_OFFSET SET	0
      5  61f5				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      6  61f5				   FUNCTION_NAME SET	Handle_BISHOP
      7  61f5					      SUBROUTINE
      8  61f5					      SUBROUTINE
      9  61f5
      0  61f5					      REFER	GenerateAllMoves
      1  61f5					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  61f5				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  61f5					      ENDIF
      0  61f5					      VEND	Handle_BISHOP
      1  61f5				  -	      IFNCONST	Handle_BISHOP
      2  61f5				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  61f5				  -	      ERR
      4  61f5					      ENDIF
      5  61f5		       00 c9	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  61f5
     13  61f5							; x = currentSquare (square the piece is on)
     14  61f5							; currentPiece (with flags/colour attached)
     15  61f5
      0  61f5					      MOVE_TOWARDS	_DOWN+_LEFT
      1  61f5					      SUBROUTINE
      2  61f5
      3  61f5
      4  61f5
      5  61f5		       a9 00		      lda	#0
      6  61f7		       85 9f		      sta	capture
      7  61f9
      8  61f9		       a6 93		      ldx	currentSquare
      9  61fb		       d0 03		      bne	.project
     10  61fd
     11  61fd		       20 f6 fb    .empty     jsr	AddMove
     12  6200		       bc 15 f0    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6203		       30 0e		      bmi	.invalid
     14  6205		       b9 84 f0 	      lda	Board,y
     15  6208		       f0 f3		      beq	.empty
     16  620a		       85 9f		      sta	capture
     17  620c		       45 92		      eor	currentPiece
     18  620e		       10 03		      bpl	.invalid
     19  6210		       20 f6 fb 	      jsr	AddMove
     20  6213
     21  6213				   .invalid
      0  6213					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  6213					      SUBROUTINE
      2  6213
      3  6213
      4  6213
      5  6213		       a9 00		      lda	#0
      6  6215		       85 9f		      sta	capture
      7  6217
      8  6217		       a6 93		      ldx	currentSquare
      9  6219		       d0 03		      bne	.project
     10  621b
     11  621b		       20 f6 fb    .empty     jsr	AddMove
     12  621e		       bc 17 f0    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  6221		       30 0e		      bmi	.invalid
     14  6223		       b9 84 f0 	      lda	Board,y
     15  6226		       f0 f3		      beq	.empty
     16  6228		       85 9f		      sta	capture
     17  622a		       45 92		      eor	currentPiece
     18  622c		       10 03		      bpl	.invalid
     19  622e		       20 f6 fb 	      jsr	AddMove
     20  6231
     21  6231				   .invalid
      0  6231					      MOVE_TOWARDS	_UP+_LEFT
      1  6231					      SUBROUTINE
      2  6231
      3  6231
      4  6231
      5  6231		       a9 00		      lda	#0
      6  6233		       85 9f		      sta	capture
      7  6235
      8  6235		       a6 93		      ldx	currentSquare
      9  6237		       d0 03		      bne	.project
     10  6239
     11  6239		       20 f6 fb    .empty     jsr	AddMove
     12  623c		       bc 29 f0    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  623f		       30 0e		      bmi	.invalid
     14  6241		       b9 84 f0 	      lda	Board,y
     15  6244		       f0 f3		      beq	.empty
     16  6246		       85 9f		      sta	capture
     17  6248		       45 92		      eor	currentPiece
     18  624a		       10 03		      bpl	.invalid
     19  624c		       20 f6 fb 	      jsr	AddMove
     20  624f
     21  624f				   .invalid
      0  624f					      MOVE_TOWARDS	_UP+_RIGHT
      1  624f					      SUBROUTINE
      2  624f
      3  624f
      4  624f
      5  624f		       a9 00		      lda	#0
      6  6251		       85 9f		      sta	capture
      7  6253
      8  6253		       a6 93		      ldx	currentSquare
      9  6255		       d0 03		      bne	.project
     10  6257
     11  6257		       20 f6 fb    .empty     jsr	AddMove
     12  625a		       bc 2b f0    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  625d		       30 0e		      bmi	.invalid
     14  625f		       b9 84 f0 	      lda	Board,y
     15  6262		       f0 f3		      beq	.empty
     16  6264		       85 9f		      sta	capture
     17  6266		       45 92		      eor	currentPiece
     18  6268		       10 03		      bpl	.invalid
     19  626a		       20 f6 fb 	      jsr	AddMove
     20  626d
     21  626d				   .invalid
     20  626d
     21  626d		       4c 2b f9 	      jmp	MoveReturn
     22  6270
     23  6270							;---------------------------------------------------------------------------------------------------
     24  6270							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_ROOK.asm LEVEL 3 PASS 5
      0  6270					      include	"Handler_ROOK.asm"
      1  6270							; Copyright (C)2020 Andrew Davie
      2  6270							; Rook move handler
      3  6270
      4  6270							;---------------------------------------------------------------------------------------------------
      5  6270							; ROOK
      6  6270							;---------------------------------------------------------------------------------------------------
      7  6270
      0  6270					      DEF	Handle_ROOK
      1  6270				   BANK_Handle_ROOK SET	_CURRENT_BANK
      2  6270				   Handle_ROOK
      3  6270				   TEMPORARY_VAR SET	Overlay
      4  6270				   TEMPORARY_OFFSET SET	0
      5  6270				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      6  6270				   FUNCTION_NAME SET	Handle_ROOK
      7  6270					      SUBROUTINE
      9  6270					      SUBROUTINE
     10  6270
      0  6270					      REFER	GenerateAllMoves
      1  6270					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6270				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6270					      ENDIF
      0  6270					      VEND	Handle_ROOK
      1  6270				  -	      IFNCONST	Handle_ROOK
      2  6270				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  6270				  -	      ERR
      4  6270					      ENDIF
      5  6270		       00 c9	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  6270
     14  6270							; Pass...
     15  6270							; x = currentSquare (square the piece is on)
     16  6270							; currentPiece (with flags/colour attached)
     17  6270
      0  6270					      MOVE_TOWARDS	_DOWN
      1  6270					      SUBROUTINE
      2  6270
      3  6270
      4  6270
      5  6270		       a9 00		      lda	#0
      6  6272		       85 9f		      sta	capture
      7  6274
      8  6274		       a6 93		      ldx	currentSquare
      9  6276		       d0 03		      bne	.project
     10  6278
     11  6278		       20 f6 fb    .empty     jsr	AddMove
     12  627b		       bc 16 f0    .project   ldy	ValidSquare+_DOWN,x
     13  627e		       30 0e		      bmi	.invalid
     14  6280		       b9 84 f0 	      lda	Board,y
     15  6283		       f0 f3		      beq	.empty
     16  6285		       85 9f		      sta	capture
     17  6287		       45 92		      eor	currentPiece
     18  6289		       10 03		      bpl	.invalid
     19  628b		       20 f6 fb 	      jsr	AddMove
     20  628e
     21  628e				   .invalid
      0  628e					      MOVE_TOWARDS	_RIGHT
      1  628e					      SUBROUTINE
      2  628e
      3  628e
      4  628e
      5  628e		       a9 00		      lda	#0
      6  6290		       85 9f		      sta	capture
      7  6292
      8  6292		       a6 93		      ldx	currentSquare
      9  6294		       d0 03		      bne	.project
     10  6296
     11  6296		       20 f6 fb    .empty     jsr	AddMove
     12  6299		       bc 21 f0    .project   ldy	ValidSquare+_RIGHT,x
     13  629c		       30 0e		      bmi	.invalid
     14  629e		       b9 84 f0 	      lda	Board,y
     15  62a1		       f0 f3		      beq	.empty
     16  62a3		       85 9f		      sta	capture
     17  62a5		       45 92		      eor	currentPiece
     18  62a7		       10 03		      bpl	.invalid
     19  62a9		       20 f6 fb 	      jsr	AddMove
     20  62ac
     21  62ac				   .invalid
      0  62ac					      MOVE_TOWARDS	_UP
      1  62ac					      SUBROUTINE
      2  62ac
      3  62ac
      4  62ac
      5  62ac		       a9 00		      lda	#0
      6  62ae		       85 9f		      sta	capture
      7  62b0
      8  62b0		       a6 93		      ldx	currentSquare
      9  62b2		       d0 03		      bne	.project
     10  62b4
     11  62b4		       20 f6 fb    .empty     jsr	AddMove
     12  62b7		       bc 2a f0    .project   ldy	ValidSquare+_UP,x
     13  62ba		       30 0e		      bmi	.invalid
     14  62bc		       b9 84 f0 	      lda	Board,y
     15  62bf		       f0 f3		      beq	.empty
     16  62c1		       85 9f		      sta	capture
     17  62c3		       45 92		      eor	currentPiece
     18  62c5		       10 03		      bpl	.invalid
     19  62c7		       20 f6 fb 	      jsr	AddMove
     20  62ca
     21  62ca				   .invalid
      0  62ca					      MOVE_TOWARDS	_LEFT
      1  62ca					      SUBROUTINE
      2  62ca
      3  62ca
      4  62ca
      5  62ca		       a9 00		      lda	#0
      6  62cc		       85 9f		      sta	capture
      7  62ce
      8  62ce		       a6 93		      ldx	currentSquare
      9  62d0		       d0 03		      bne	.project
     10  62d2
     11  62d2		       20 f6 fb    .empty     jsr	AddMove
     12  62d5		       bc 1f f0    .project   ldy	ValidSquare+_LEFT,x
     13  62d8		       30 0e		      bmi	.invalid
     14  62da		       b9 84 f0 	      lda	Board,y
     15  62dd		       f0 f3		      beq	.empty
     16  62df		       85 9f		      sta	capture
     17  62e1		       45 92		      eor	currentPiece
     18  62e3		       10 03		      bpl	.invalid
     19  62e5		       20 f6 fb 	      jsr	AddMove
     20  62e8
     21  62e8				   .invalid
     22  62e8
     23  62e8		       4c 2b f9 	      jmp	MoveReturn
     24  62eb
     25  62eb							;---------------------------------------------------------------------------------------------------
     26  62eb							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_KING.asm LEVEL 3 PASS 5
      0  62eb					      include	"Handler_KING.asm"
      1  62eb							; Copyright (C)2020 Andrew Davie
      2  62eb
      3  62eb							;---------------------------------------------------------------------------------------------------
      4  62eb							; KING
      5  62eb							; This is the move handler for a KING
      6  62eb							; "Check" is detected in the next ply of the search.
      7  62eb
      8  62eb
      9  62eb							;---------------------------------------------------------------------------------------------------
     10  62eb
     11  62eb							; MACRO - Castling
     12  62eb
     13  62eb		       00 03	   KINGSIDE   =	3
     14  62eb		       ff ff ff fc QUEENSIDE  =	-4
     15  62eb
     16  62eb					      MAC	castle
     17  62eb							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  62eb
     19  62eb					      ldx	currentSquare
     20  62eb					      lda	Board+{1},x	; kingside/queenside R position
     21  62eb					      and	#PIECE_MASK|FLAG_MOVED
     22  62eb					      cmp	#ROOK
     23  62eb					      bne	.noCastle	; not a R that hasn't moved
     24  62eb
     25  62eb							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  62eb							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  62eb
     28  62eb					      IF	{1} = QUEENSIDE
     29  62eb					      lda	Board-3,x	; N pos
     30  62eb					      ora	Board-2,x	; B pos
     31  62eb					      ora	Board-1,x	; Q pos
     32  62eb					      bne	.noCastle	; not vacant?
     33  62eb
     34  62eb					      ENDIF
     35  62eb
     36  62eb					      IF	{1} = KINGSIDE
     37  62eb					      lda	Board+2,x	; N pos
     38  62eb					      ora	Board+1,x	; B pos
     39  62eb					      bne	.noCastle	; not vacant?
     40  62eb					      ENDIF
     41  62eb
     42  62eb							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  62eb
     44  62eb							; FINALLY -- king can castle
     45  62eb							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  62eb							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  62eb							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  62eb
     49  62eb					      lda	currentPiece
     50  62eb					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  62eb					      sta	currentPiece
     52  62eb
     53  62eb					      IF	{1} = KINGSIDE
     54  62eb					      ldy	ValidSquare+2,x
     55  62eb					      ENDIF
     56  62eb
     57  62eb					      IF	{1} = QUEENSIDE
     58  62eb					      ldy	ValidSquare-2,x
     59  62eb					      ENDIF
     60  62eb
     61  62eb					      jsr	AddMove	; 57
     62  62eb
     63  62eb				   .noCastle
     64  62eb					      ENDM
     65  62eb
     66  62eb
     67  62eb							;---------------------------------------------------------------------------------------------------
     68  62eb
      0  62eb					      DEF	Handle_KING
      1  62eb				   BANK_Handle_KING SET	_CURRENT_BANK
      2  62eb				   Handle_KING
      3  62eb				   TEMPORARY_VAR SET	Overlay
      4  62eb				   TEMPORARY_OFFSET SET	0
      5  62eb				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      6  62eb				   FUNCTION_NAME SET	Handle_KING
      7  62eb					      SUBROUTINE
     70  62eb					      SUBROUTINE
     71  62eb
      0  62eb					      REFER	GenerateAllMoves
      1  62eb					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  62eb				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  62eb					      ENDIF
      0  62eb					      VEND	Handle_KING
      1  62eb				  -	      IFNCONST	Handle_KING
      2  62eb				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  62eb				  -	      ERR
      4  62eb					      ENDIF
      5  62eb		       00 c9	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  62eb
     75  62eb							; x = currentSquare (square the KING is on)
     76  62eb							; currentPiece (KING of course, but with flags/colour attached)
     77  62eb
      0  62eb					      MOVE_TO	_DOWN+_LEFT
      1  62eb					      SUBROUTINE
      2  62eb		       bc 15 f0 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  62ee		       30 0e		      bmi	.invalid
      4  62f0		       b9 84 f0 	      lda	Board,y
      5  62f3		       85 9f		      sta	capture
      6  62f5		       f0 04		      beq	.squareEmpty
      7  62f7		       45 92		      eor	currentPiece
      8  62f9		       10 03		      bpl	.invalid
      9  62fb		       20 f6 fb    .squareEmpty jsr	AddMove
     10  62fe				   .invalid
      0  62fe					      MOVE_TO_X	_DOWN
      1  62fe		       a6 93		      ldx	currentSquare
      0  6300					      MOVE_TO	_DOWN
      1  6300					      SUBROUTINE
      2  6300		       bc 16 f0 	      ldy	ValidSquare+_DOWN,x
      3  6303		       30 0e		      bmi	.invalid
      4  6305		       b9 84 f0 	      lda	Board,y
      5  6308		       85 9f		      sta	capture
      6  630a		       f0 04		      beq	.squareEmpty
      7  630c		       45 92		      eor	currentPiece
      8  630e		       10 03		      bpl	.invalid
      9  6310		       20 f6 fb    .squareEmpty jsr	AddMove
     10  6313				   .invalid
      0  6313					      MOVE_TO_X	_DOWN+_RIGHT
      1  6313		       a6 93		      ldx	currentSquare
      0  6315					      MOVE_TO	_DOWN+_RIGHT
      1  6315					      SUBROUTINE
      2  6315		       bc 17 f0 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  6318		       30 0e		      bmi	.invalid
      4  631a		       b9 84 f0 	      lda	Board,y
      5  631d		       85 9f		      sta	capture
      6  631f		       f0 04		      beq	.squareEmpty
      7  6321		       45 92		      eor	currentPiece
      8  6323		       10 03		      bpl	.invalid
      9  6325		       20 f6 fb    .squareEmpty jsr	AddMove
     10  6328				   .invalid
      0  6328					      MOVE_TO_X	_RIGHT
      1  6328		       a6 93		      ldx	currentSquare
      0  632a					      MOVE_TO	_RIGHT
      1  632a					      SUBROUTINE
      2  632a		       bc 21 f0 	      ldy	ValidSquare+_RIGHT,x
      3  632d		       30 0e		      bmi	.invalid
      4  632f		       b9 84 f0 	      lda	Board,y
      5  6332		       85 9f		      sta	capture
      6  6334		       f0 04		      beq	.squareEmpty
      7  6336		       45 92		      eor	currentPiece
      8  6338		       10 03		      bpl	.invalid
      9  633a		       20 f6 fb    .squareEmpty jsr	AddMove
     10  633d				   .invalid
      0  633d					      MOVE_TO_X	_UP+_RIGHT
      1  633d		       a6 93		      ldx	currentSquare
      0  633f					      MOVE_TO	_UP+_RIGHT
      1  633f					      SUBROUTINE
      2  633f		       bc 2b f0 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  6342		       30 0e		      bmi	.invalid
      4  6344		       b9 84 f0 	      lda	Board,y
      5  6347		       85 9f		      sta	capture
      6  6349		       f0 04		      beq	.squareEmpty
      7  634b		       45 92		      eor	currentPiece
      8  634d		       10 03		      bpl	.invalid
      9  634f		       20 f6 fb    .squareEmpty jsr	AddMove
     10  6352				   .invalid
      0  6352					      MOVE_TO_X	_UP
      1  6352		       a6 93		      ldx	currentSquare
      0  6354					      MOVE_TO	_UP
      1  6354					      SUBROUTINE
      2  6354		       bc 2a f0 	      ldy	ValidSquare+_UP,x
      3  6357		       30 0e		      bmi	.invalid
      4  6359		       b9 84 f0 	      lda	Board,y
      5  635c		       85 9f		      sta	capture
      6  635e		       f0 04		      beq	.squareEmpty
      7  6360		       45 92		      eor	currentPiece
      8  6362		       10 03		      bpl	.invalid
      9  6364		       20 f6 fb    .squareEmpty jsr	AddMove
     10  6367				   .invalid
      0  6367					      MOVE_TO_X	_UP+_LEFT
      1  6367		       a6 93		      ldx	currentSquare
      0  6369					      MOVE_TO	_UP+_LEFT
      1  6369					      SUBROUTINE
      2  6369		       bc 29 f0 	      ldy	ValidSquare+_UP+_LEFT,x
      3  636c		       30 0e		      bmi	.invalid
      4  636e		       b9 84 f0 	      lda	Board,y
      5  6371		       85 9f		      sta	capture
      6  6373		       f0 04		      beq	.squareEmpty
      7  6375		       45 92		      eor	currentPiece
      8  6377		       10 03		      bpl	.invalid
      9  6379		       20 f6 fb    .squareEmpty jsr	AddMove
     10  637c				   .invalid
      0  637c					      MOVE_TO_X	_LEFT
      1  637c		       a6 93		      ldx	currentSquare
      0  637e					      MOVE_TO	_LEFT
      1  637e					      SUBROUTINE
      2  637e		       bc 1f f0 	      ldy	ValidSquare+_LEFT,x
      3  6381		       30 0e		      bmi	.invalid
      4  6383		       b9 84 f0 	      lda	Board,y
      5  6386		       85 9f		      sta	capture
      6  6388		       f0 04		      beq	.squareEmpty
      7  638a		       45 92		      eor	currentPiece
      8  638c		       10 03		      bpl	.invalid
      9  638e		       20 f6 fb    .squareEmpty jsr	AddMove
     10  6391				   .invalid
     86  6391
     87  6391							;IF CASTLING_ENABLED
     88  6391
     89  6391		       24 92		      bit	currentPiece
     90  6393		       70 41		      bvs	.exit	; king has moved, so no castling
     91  6395
      0  6395					      CASTLE	KINGSIDE
      1  6395
      2  6395
      3  6395		       a6 93		      ldx	currentSquare
      4  6397		       bd 87 f0 	      lda	Board+KINGSIDE,x
      5  639a		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  639c		       c9 05		      cmp	#ROOK
      7  639e		       d0 14		      bne	.noCastle
      8  63a0
      9  63a0
     10  63a0
     11  63a0
     12  63a0				  -	      IF	KINGSIDE = QUEENSIDE
     13  63a0				  -	      lda	Board-3,x
     14  63a0				  -	      ora	Board-2,x
     15  63a0				  -	      ora	Board-1,x
     16  63a0				  -	      bne	.noCastle
     17  63a0				  -
     18  63a0					      ENDIF
     19  63a0
     20  63a0					      IF	KINGSIDE = KINGSIDE
     21  63a0		       bd 86 f0 	      lda	Board+2,x
     22  63a3		       1d 85 f0 	      ora	Board+1,x
     23  63a6		       d0 0c		      bne	.noCastle
     24  63a8					      ENDIF
     25  63a8
     26  63a8
     27  63a8
     28  63a8
     29  63a8
     30  63a8
     31  63a8
     32  63a8
     33  63a8		       a5 92		      lda	currentPiece
     34  63aa		       09 10		      ora	#FLAG_CASTLE
     35  63ac		       85 92		      sta	currentPiece
     36  63ae
     37  63ae					      IF	KINGSIDE = KINGSIDE
     38  63ae		       bc 22 f0 	      ldy	ValidSquare+2,x
     39  63b1					      ENDIF
     40  63b1
     41  63b1				  -	      IF	KINGSIDE = QUEENSIDE
     42  63b1				  -	      ldy	ValidSquare-2,x
     43  63b1					      ENDIF
     44  63b1
     45  63b1		       20 f6 fb 	      jsr	AddMove
     46  63b4
     47  63b4				   .noCastle
      0  63b4					      CASTLE	QUEENSIDE
      1  63b4
      2  63b4
      3  63b4		       a6 93		      ldx	currentSquare
      4  63b6		       bd 80 f0 	      lda	Board+QUEENSIDE,x
      5  63b9		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  63bb		       c9 05		      cmp	#ROOK
      7  63bd		       d0 17		      bne	.noCastle
      8  63bf
      9  63bf
     10  63bf
     11  63bf
     12  63bf					      IF	QUEENSIDE = QUEENSIDE
     13  63bf		       bd 81 f0 	      lda	Board-3,x
     14  63c2		       1d 82 f0 	      ora	Board-2,x
     15  63c5		       1d 83 f0 	      ora	Board-1,x
     16  63c8		       d0 0c		      bne	.noCastle
     17  63ca
     18  63ca					      ENDIF
     19  63ca
     20  63ca				  -	      IF	QUEENSIDE = KINGSIDE
     21  63ca				  -	      lda	Board+2,x
     22  63ca				  -	      ora	Board+1,x
     23  63ca				  -	      bne	.noCastle
     24  63ca					      ENDIF
     25  63ca
     26  63ca
     27  63ca
     28  63ca
     29  63ca
     30  63ca
     31  63ca
     32  63ca
     33  63ca		       a5 92		      lda	currentPiece
     34  63cc		       09 10		      ora	#FLAG_CASTLE
     35  63ce		       85 92		      sta	currentPiece
     36  63d0
     37  63d0				  -	      IF	QUEENSIDE = KINGSIDE
     38  63d0				  -	      ldy	ValidSquare+2,x
     39  63d0					      ENDIF
     40  63d0
     41  63d0					      IF	QUEENSIDE = QUEENSIDE
     42  63d0		       bc 1e f0 	      ldy	ValidSquare-2,x
     43  63d3					      ENDIF
     44  63d3
     45  63d3		       20 f6 fb 	      jsr	AddMove
     46  63d6
     47  63d6				   .noCastle
     94  63d6
     95  63d6							;ENDIF
     96  63d6
     97  63d6		       4c 2b f9    .exit      jmp	MoveReturn
     98  63d9
     99  63d9							;---------------------------------------------------------------------------------------------------
    100  63d9							; EOF
------- FILE Handler_BANK1.asm
    154  63d9
    155  63d9							;---------------------------------------------------------------------------------------------------
    156  63d9
      0  63d9					      CHECK_HALF_BANK_SIZE	"HANDLER_BANK1 -- 1K"
      1  63d9
      2  63d9
      3  63d9		       03 d9	   .TEMP      =	* - BANK_START
 HANDLER_BANK1 -- 1K (1K) SIZE =  $3d9 , FREE= $27
      4  63d9					      ECHO	"HANDLER_BANK1 -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  63d9				  -	      IF	( .TEMP ) > ROM_BANK_SIZE/2
      6  63d9				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  63d9				  -	      ERR
      8  63d9					      ENDIF
    158  63d9
    159  63d9
    160  63d9							; There is space here (1K) for use as ROM
    161  63d9							; but NOT when the above bank is switched in as RAM, of course!
    162  63d9
    163  63d9
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  63d9					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  63d9					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  6400					      LIST	ON
      0  6400					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  6400				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  6400				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  6400				   TEMPORARY_VAR SET	Overlay
      4  6400				   TEMPORARY_OFFSET SET	0
      5  6400				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  6400				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      7  6400					      SUBROUTINE
      3  6400		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  6418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  6448					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  6448					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  6448					      LIST	ON
      0  6448					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  6448				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  6448				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  6448				   TEMPORARY_VAR SET	Overlay
      4  6448				   TEMPORARY_OFFSET SET	0
      5  6448				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  6448				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      7  6448					      SUBROUTINE
      3  6448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6460		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  6478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  6490					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  6490					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  6490					      LIST	ON
      0  6490					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  6490				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  6490				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  6490				   TEMPORARY_VAR SET	Overlay
      4  6490				   TEMPORARY_OFFSET SET	0
      5  6490				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  6490				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      7  6490					      SUBROUTINE
      3  6490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  64a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  64c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  64d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  64d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  6500					      LIST	ON
      0  6500					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  6500				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  6500				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  6500				   TEMPORARY_VAR SET	Overlay
      4  6500				   TEMPORARY_OFFSET SET	0
      5  6500				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  6500				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      7  6500					      SUBROUTINE
      3  6500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6530		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  6548					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  6548					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  6548					      LIST	ON
      0  6548					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  6548				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  6548				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  6548				   TEMPORARY_VAR SET	Overlay
      4  6548				   TEMPORARY_OFFSET SET	0
      5  6548				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  6548				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      7  6548					      SUBROUTINE
      3  6548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  6590					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  6590					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  6590					      LIST	ON
      0  6590					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  6590				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  6590				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  6590				   TEMPORARY_VAR SET	Overlay
      4  6590				   TEMPORARY_OFFSET SET	0
      5  6590				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  6590				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      7  6590					      SUBROUTINE
      3  6590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  65a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  65c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  65d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  65d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  6600					      LIST	ON
      0  6600					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  6600				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  6600				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  6600				   TEMPORARY_VAR SET	Overlay
      4  6600				   TEMPORARY_OFFSET SET	0
      5  6600				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  6600				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      7  6600					      SUBROUTINE
      3  6600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  6648					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  6648					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  6648					      LIST	ON
      0  6648					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  6648				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  6648				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  6648				   TEMPORARY_VAR SET	Overlay
      4  6648				   TEMPORARY_OFFSET SET	0
      5  6648				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  6648				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      7  6648					      SUBROUTINE
      3  6648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
    172  6690
    173  6690							;---------------------------------------------------------------------------------------------------
    174  6690
      0  6690					      CHECK_BANK_SIZE	"HANDLER_BANK_1 -- full 2K"
      1  6690		       06 90	   .TEMP      =	* - BANK_START
 HANDLER_BANK_1 -- full 2K (2K) SIZE =  $690 , FREE= $170
      2  6690					      ECHO	"HANDLER_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  6690				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  6690				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  6690				  -	      ERR
      6  6690					      ENDIF
      7  6690
    176  6690
    177  6690							;---------------------------------------------------------------------------------------------------
    178  6690							; EOF
------- FILE ./chess.asm
------- FILE BANK_PLY.asm LEVEL 2 PASS 5
      0  6690					      include	"BANK_PLY.asm"
      1  6690							; Copyright (C)2020 Andrew Davie
      2  6690							; andrew@taswegian.com
      3  6690
      4  6690
      5  6690							;---------------------------------------------------------------------------------------------------
      6  6690							; Define the RAM banks
      7  6690							; A "PLY" bank represents all the data required on any single ply of the search tree.
      8  6690							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
      9  6690							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     10  6690							; they act as independant switchable banks usable for data on each ply during the search.
     11  6690							; A ply will hold the move list for that position
     12  6690
     13  6690
      0  6690					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  6690
      2  6690
      3  6690
      4 U2800 ????				      SEG.U	PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	RAM_3E
      7 U2800				   BANK_START SET	*
      8 U2800				   RAMBANK_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U2800					      REPEAT	PLY_BANKS-1
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U4400 ????				      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	RAM_3E
      7 U2c00				   BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U2c00					      REPEND
      0 U2c00					      NEWRAMBANK	.DUMMY_PLY
      1 U2c00
      2 U2c00
      3 U2c00
      4 U2c00					      SEG.U	.DUMMY_PLY
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	RAM_3E
      7 U3000				   BANK_START SET	*
      8 U3000				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U3000					      REPEND
      0 U3000					      NEWRAMBANK	.DUMMY_PLY
      1 U3000
      2 U3000
      3 U3000
      4 U3000					      SEG.U	.DUMMY_PLY
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	RAM_3E
      7 U3400				   BANK_START SET	*
      8 U3400				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U3400					      REPEND
      0 U3400					      NEWRAMBANK	.DUMMY_PLY
      1 U3400
      2 U3400
      3 U3400
      4 U3400					      SEG.U	.DUMMY_PLY
      5 U3800					      ORG	ORIGIN_RAM
      6 U3800					      RORG	RAM_3E
      7 U3800				   BANK_START SET	*
      8 U3800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U3800					      REPEND
      0 U3800					      NEWRAMBANK	.DUMMY_PLY
      1 U3800
      2 U3800
      3 U3800
      4 U3800					      SEG.U	.DUMMY_PLY
      5 U3c00					      ORG	ORIGIN_RAM
      6 U3c00					      RORG	RAM_3E
      7 U3c00				   BANK_START SET	*
      8 U3c00				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U3c00					      REPEND
      0 U3c00					      NEWRAMBANK	.DUMMY_PLY
      1 U3c00
      2 U3c00
      3 U3c00
      4 U3c00					      SEG.U	.DUMMY_PLY
      5 U4000					      ORG	ORIGIN_RAM
      6 U4000					      RORG	RAM_3E
      7 U4000				   BANK_START SET	*
      8 U4000				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U4000					      REPEND
      0 U4000					      NEWRAMBANK	.DUMMY_PLY
      1 U4000
      2 U4000
      3 U4000
      4 U4000					      SEG.U	.DUMMY_PLY
      5 U4400					      ORG	ORIGIN_RAM
      6 U4400					      RORG	RAM_3E
      7 U4400				   BANK_START SET	*
      8 U4400				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U4400					      REPEND
     18 U4400
     19 U4400
     20 U4400							;---------------------------------------------------------------------------------------------------
     21 U4400							; and now the ROM shadow - this is copied to ALL of the RAM ply banks
     22 U4400
      0 U4400					      NEWBANK	BANK_PLY	; ROM SHADOW
      1  6bd8 ????				      SEG	BANK_PLY
      2  6800					      ORG	ORIGIN
      3  6800					      RORG	$F000
      4  6800				   BANK_START SET	*
      5  6800				   BANK_PLY   SET	ORIGIN / 2048
      6  6800				   ORIGIN     SET	ORIGIN + 2048
      7  6800				   _CURRENT_BANK SET	BANK_PLY
     24  6800
     25  6800							;---------------------------------------------------------------------------------------------------
     26  6800							; The piece-lists
     27  6800							; ONLY the very first bank piecelist is used - all other banks switch to the first for
     28  6800							; piecelist usage. Note that this initialisation (below) comes from the shadow ROM/RAM copy
     29  6800							; but this needs to be initialised programatically on new game.
     30  6800
     31  6800							; We have TWO piecelists, in different banks
     32  6800							; WHITE pieces in bank BANK_PLY
     33  6800							; BLACK pieces in bank BANK_PLY+1
     34  6800
      0  6800					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0  6800					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  6800					      LIST	ON
      2  6800		       00 00	   savedEvaluation ds	2
     36  6802
     37  6802							;---------------------------------------------------------------------------------------------------
     38  6802
     39  6802		       00 46	   MAX_MOVES  =	70
     40  6802
      0  6802					      VARIABLE	MoveFrom, MAX_MOVES
      0  6802					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  6802					      LIST	ON
      2  6802		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0  6848					      VARIABLE	MoveTo, MAX_MOVES
      0  6848					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  6848					      LIST	ON
      2  6848		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0  688e					      VARIABLE	MovePiece, MAX_MOVES
      0  688e					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  688e					      LIST	ON
      2  688e		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0  68d4					      VARIABLE	MoveCapture, MAX_MOVES
      0  68d4					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  6900					      LIST	ON
      2  6900		       00 00 00 00*MoveCapture ds	MAX_MOVES
     45  6946
      0  6946					      VARIABLE	kingSquare, 3	; traversing squares for castle/check
      0  6946					      OPTIONAL_PAGEBREAK	"Variable", 3
     12  6946					      LIST	ON
      2  6946		       00 00 00    kingSquare ds	3
     47  6949
     48  6949							;---------------------------------------------------------------------------------------------------
     49  6949
     50  6949							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     51  6949							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     52  6949
      0  6949					      VARIABLE	enPassantSquare, 1
      0  6949					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6949					      LIST	ON
      2  6949		       00	   enPassantSquare ds	1
      0  694a					      VARIABLE	capturedPiece, 1
      0  694a					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694a					      LIST	ON
      2  694a		       00	   capturedPiece ds	1
      0  694b					      VARIABLE	originalPiece, 1
      0  694b					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694b					      LIST	ON
      2  694b		       00	   originalPiece ds	1
      0  694c					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0  694c					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694c					      LIST	ON
      2  694c		       00	   secondaryPiece ds	1
      0  694d					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0  694d					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694d					      LIST	ON
      2  694d		       00	   secondarySquare ds	1
      0  694e					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0  694e					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694e					      LIST	ON
      2  694e		       00	   secondaryBlank ds	1
      0  694f					      VARIABLE	quiescentEnabled, 1	; all child nodes to quiesce
      0  694f					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694f					      LIST	ON
      2  694f		       00	   quiescentEnabled ds	1
      0  6950					      VARIABLE	captureMove, 1	; previous move was a capture
      0  6950					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6950					      LIST	ON
      2  6950		       00	   captureMove ds	1
     61  6951
     62  6951							;---------------------------------------------------------------------------------------------------
     63  6951							; Move tables hold piece moves for this current ply
     64  6951
      0  6951					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0  6951					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6951					      LIST	ON
      2  6951		       00	   moveIndex  ds	1
      0  6952					      VARIABLE	movePtr, 1
      0  6952					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6952					      LIST	ON
      2  6952		       00	   movePtr    ds	1
      0  6953					      VARIABLE	bestMove, 1
      0  6953					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6953					      LIST	ON
      2  6953		       00	   bestMove   ds	1
      0  6954					      VARIABLE	alpha, 2
      0  6954					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  6954					      LIST	ON
      2  6954		       00 00	   alpha      ds	2
      0  6956					      VARIABLE	beta, 2
      0  6956					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  6956					      LIST	ON
      2  6956		       00 00	   beta       ds	2
      0  6958					      VARIABLE	value, 2
      0  6958					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  6958					      LIST	ON
      2  6958		       00 00	   value      ds	2
      0  695a					      VARIABLE	depthLeft, 1
      0  695a					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  695a					      LIST	ON
      2  695a		       00	   depthLeft  ds	1
      0  695b					      VARIABLE	restorePiece, 1
      0  695b					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  695b					      LIST	ON
      2  695b		       00	   restorePiece ds	1
     73  695c
     74  695c							;---------------------------------------------------------------------------------------------------
     75  695c
      0  695c					      DEF	NewPlyInitialise
      1  695c				   BANK_NewPlyInitialise SET	_CURRENT_BANK
      2  695c				   NewPlyInitialise
      3  695c				   TEMPORARY_VAR SET	Overlay
      4  695c				   TEMPORARY_OFFSET SET	0
      5  695c				   VAR_BOUNDARY_NewPlyInitialise SET	TEMPORARY_OFFSET
      6  695c				   FUNCTION_NAME SET	NewPlyInitialise
      7  695c					      SUBROUTINE
     77  695c					      SUBROUTINE
     78  695c
      0  695c					      REFER	GenerateAllMoves
      1  695c					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  695c				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  695c					      ENDIF
      0  695c					      REFER	negaMax
      1  695c				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  695c				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  695c					      ENDIF
      0  695c					      VEND	NewPlyInitialise
      1  695c				  -	      IFNCONST	NewPlyInitialise
      2  695c				  -	      ECHO	"Incorrect VEND label", NewPlyInitialise
      3  695c				  -	      ERR
      4  695c					      ENDIF
      5  695c		       00 c9	   VAREND_NewPlyInitialise =	TEMPORARY_VAR
     82  695c
     83  695c							; This MUST be called at the start of a new ply
     84  695c							; It initialises the movelist to empty
     85  695c							; x must be preserved
     86  695c
     87  695c							; note that 'alpha' and 'beta' are set externally!!
     88  695c
     89  695c		       a9 ff		      lda	#-1
      0  695e					      sta@PLY	moveIndex	; no valid moves
      1  695e		       8d 51 f5 	      sta	[RAM]+moveIndex
      0  6961					      sta@PLY	bestMove
      1  6961		       8d 53 f5 	      sta	[RAM]+bestMove
     92  6964
     93  6964		       a5 94		      lda	enPassantPawn	; flag/square from last actual move made
      0  6966					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  6966		       8d 49 f5 	      sta	[RAM]+enPassantSquare
     95  6969
     96  6969
     97  6969							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
     98  6969							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
     99  6969							; start of each new ply.
    100  6969
    101  6969		       a5 90		      lda	Evaluation
      0  696b					      sta@PLY	savedEvaluation
      1  696b		       8d 00 f4 	      sta	[RAM]+savedEvaluation
    103  696e		       a5 91		      lda	Evaluation+1
      0  6970					      sta@PLY	savedEvaluation+1
      1  6970		       8d 01 f4 	      sta	[RAM]+savedEvaluation+1
    105  6973
    106  6973		       60		      rts
    107  6974
    108  6974
    109  6974							;---------------------------------------------------------------------------------------------------
    110  6974
      0  6974					      DEF	CheckMoveListFromSquare
      1  6974				   BANK_CheckMoveListFromSquare SET	_CURRENT_BANK
      2  6974				   CheckMoveListFromSquare
      3  6974				   TEMPORARY_VAR SET	Overlay
      4  6974				   TEMPORARY_OFFSET SET	0
      5  6974				   VAR_BOUNDARY_CheckMoveListFromSquare SET	TEMPORARY_OFFSET
      6  6974				   FUNCTION_NAME SET	CheckMoveListFromSquare
      7  6974					      SUBROUTINE
    112  6974					      SUBROUTINE
    113  6974
      0  6974					      REFER	IsValidP_MoveFromSquare
      1  6974				  -	      IF	VAREND_IsValidP_MoveFromSquare > TEMPORARY_VAR
      2  6974				  -TEMPORARY_VAR SET	VAREND_IsValidP_MoveFromSquare
      3  6974					      ENDIF
      0  6974					      VEND	CheckMoveListFromSquare
      1  6974				  -	      IFNCONST	CheckMoveListFromSquare
      2  6974				  -	      ECHO	"Incorrect VEND label", CheckMoveListFromSquare
      3  6974				  -	      ERR
      4  6974					      ENDIF
      5  6974		       00 a7	   VAREND_CheckMoveListFromSquare =	TEMPORARY_VAR
    116  6974
    117  6974							; X12 in A
    118  6974							; y = -1 on return if NOT FOUND
    119  6974
      0  6974					      ldy@RAM	moveIndex
      1  6974		       ac 51 f1 	      ldy	moveIndex
    121  6977		       30 08		      bmi	.exit
    122  6979
    123  6979		       d9 02 f0    .scan      cmp	MoveFrom,y
    124  697c		       f0 04		      beq	.scanned
    125  697e		       88		      dey
    126  697f		       10 f8		      bpl	.scan
    127  6981		       60	   .exit      rts
    128  6982
      0  6982				   .scanned   lda@PLY	MovePiece,y
      1  6982		       b9 8e f0 	      lda	MovePiece,y
    130  6985		       85 98		      sta	fromPiece
    131  6987		       60		      rts
    132  6988
    133  6988
    134  6988							;---------------------------------------------------------------------------------------------------
    135  6988
      0  6988					      DEF	GetPieceGivenFromToSquares
      1  6988				   BANK_GetPieceGivenFromToSquares SET	_CURRENT_BANK
      2  6988				   GetPieceGivenFromToSquares
      3  6988				   TEMPORARY_VAR SET	Overlay
      4  6988				   TEMPORARY_OFFSET SET	0
      5  6988				   VAR_BOUNDARY_GetPieceGivenFromToSquares SET	TEMPORARY_OFFSET
      6  6988				   FUNCTION_NAME SET	GetPieceGivenFromToSquares
      7  6988					      SUBROUTINE
    137  6988					      SUBROUTINE
    138  6988
      0  6988					      REFER	GetPiece
      1  6988				  -	      IF	VAREND_GetPiece > TEMPORARY_VAR
      2  6988				  -TEMPORARY_VAR SET	VAREND_GetPiece
      3  6988					      ENDIF
      0  6988					      VEND	GetPieceGivenFromToSquares
      1  6988				  -	      IFNCONST	GetPieceGivenFromToSquares
      2  6988				  -	      ECHO	"Incorrect VEND label", GetPieceGivenFromToSquares
      3  6988				  -	      ERR
      4  6988					      ENDIF
      5  6988		       00 a7	   VAREND_GetPieceGivenFromToSquares =	TEMPORARY_VAR
    141  6988
    142  6988							; returns piece in A+fromPiece
    143  6988							; or Y=-1 if not found
    144  6988
    145  6988							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
    146  6988							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
    147  6988							; This fixes the move with/without castle flag
    148  6988
    149  6988
      0  6988					      ldy@RAM	moveIndex
      1  6988		       ac 51 f1 	      ldy	moveIndex
    151  698b		       30 11		      bmi	.fail	; shouldn't happen
    152  698d		       a5 85	   .scan      lda	fromX12
    153  698f		       d9 02 f0 	      cmp	MoveFrom,y
    154  6992		       d0 07		      bne	.next
    155  6994		       a5 86		      lda	toX12
    156  6996		       d9 48 f0 	      cmp	MoveTo,y
    157  6999		       f0 04		      beq	.found
    158  699b		       88	   .next      dey
    159  699c		       10 ef		      bpl	.scan
    160  699e		       60	   .fail      rts
    161  699f
      0  699f				   .found     lda@PLY	MovePiece,y
      1  699f		       b9 8e f0 	      lda	MovePiece,y
    163  69a2		       85 98		      sta	fromPiece
    164  69a4		       60		      rts
    165  69a5
    166  69a5
    167  69a5
    168  69a5							;---------------------------------------------------------------------------------------------------
    169  69a5
      0  69a5					      DEF	selectmove
      1  69a5				   BANK_selectmove SET	_CURRENT_BANK
      2  69a5				   selectmove
      3  69a5				   TEMPORARY_VAR SET	Overlay
      4  69a5				   TEMPORARY_OFFSET SET	0
      5  69a5				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      6  69a5				   FUNCTION_NAME SET	selectmove
      7  69a5					      SUBROUTINE
    171  69a5					      SUBROUTINE
    172  69a5
      0  69a5					      COMMON_VARS_ALPHABETA
      1  69a5
      0  69a5					      VAR	__thinkbar, 1
      1  69a5		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  69a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  69a5
      4  69a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a5					      ENDIF
      8  69a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a5				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  69a5				  -	      ERR
     11  69a5					      ENDIF
     12  69a5					      LIST	ON
      0  69a5					      VAR	__toggle, 1
      1  69a5		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  69a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  69a5
      4  69a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a5					      ENDIF
      8  69a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a5				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  69a5				  -	      ERR
     11  69a5					      ENDIF
     12  69a5					      LIST	ON
      4  69a5
      0  69a5					      VAR	__bestMove, 1
      1  69a5		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  69a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  69a5
      4  69a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a5					      ENDIF
      8  69a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a5				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  69a5				  -	      ERR
     11  69a5					      ENDIF
     12  69a5					      LIST	ON
      0  69a5					      VAR	__alpha, 2
      1  69a5		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  69a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  69a5
      4  69a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a5					      ENDIF
      8  69a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a5				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  69a5				  -	      ERR
     11  69a5					      ENDIF
     12  69a5					      LIST	ON
      0  69a5					      VAR	__beta, 2
      1  69a5		       00 ac	   __beta     =	TEMPORARY_VAR
      2  69a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  69a5
      4  69a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a5					      ENDIF
      8  69a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a5				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  69a5				  -	      ERR
     11  69a5					      ENDIF
     12  69a5					      LIST	ON
      0  69a5					      VAR	__negaMax, 2
      1  69a5		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  69a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  69a5
      4  69a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a5					      ENDIF
      8  69a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a5				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  69a5				  -	      ERR
     11  69a5					      ENDIF
     12  69a5					      LIST	ON
      0  69a5					      VAR	__value, 2
      1  69a5		       00 b0	   __value    =	TEMPORARY_VAR
      2  69a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  69a5
      4  69a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a5					      ENDIF
      8  69a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a5				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  69a5				  -	      ERR
     11  69a5					      ENDIF
     12  69a5					      LIST	ON
     10  69a5
      0  69a5					      VAR	__quiesceCapOnly, 1
      1  69a5		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  69a5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  69a5
      4  69a5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a5					      ENDIF
      8  69a5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a5				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  69a5				  -	      ERR
     11  69a5					      ENDIF
     12  69a5					      LIST	ON
     12  69a5
      0  69a5					      REFER	aiComputerMove
      1  69a5				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  69a5				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  69a5					      ENDIF
      0  69a5					      VEND	selectmove
      1  69a5				  -	      IFNCONST	selectmove
      2  69a5				  -	      ECHO	"Incorrect VEND label", selectmove
      3  69a5				  -	      ERR
      4  69a5					      ENDIF
      5  69a5		       00 b3	   VAREND_selectmove =	TEMPORARY_VAR
    176  69a5
    177  69a5
    178  69a5
    179  69a5							; RAM bank already switched in!!!
    180  69a5							; returns with RAM bank switched
    181  69a5
    182  69a5
    183  69a5					      IF	DIAGNOSTICS
    184  69a5		       a9 00		      lda	#0
    185  69a7		       85 a1		      sta	positionCount
    186  69a9		       85 a2		      sta	positionCount+1
    187  69ab		       85 a3		      sta	positionCount+2
    188  69ad
    189  69ad							;		      sta maxPly
    190  69ad					      ENDIF
    191  69ad
    192  69ad
    193  69ad							;(* Initial call for Player A's root node *)
    194  69ad							;negaMax(rootNode, depth, −∞, +∞, 1)
    195  69ad
    196  69ad
    197  69ad		       a9 00		      lda	#<INFINITY
    198  69af		       85 ac		      sta	__beta
    199  69b1		       a9 70		      lda	#>INFINITY
    200  69b3		       85 ad		      sta	__beta+1
    201  69b5
    202  69b5		       a9 00		      lda	#<-INFINITY
    203  69b7		       85 aa		      sta	__alpha
    204  69b9		       a9 90		      lda	#>-INFINITY
    205  69bb		       85 ab		      sta	__alpha+1	; player tries to maximise
    206  69bd
    207  69bd		       a2 04		      ldx	#SEARCH_DEPTH
    208  69bf		       a9 00		      lda	#0	;no captured piece
    209  69c1		       85 b2		      sta	__quiesceCapOnly
    210  69c3
    211  69c3		       20 8e fe 	      jsr	negaMax
    212  69c6
    213  69c6							;NEGEVAL		 ;????
    214  69c6
    215  69c6							;lda #RAMBANK_PLY
    216  69c6							;sta SET_BANK_RAM
    217  69c6
      0  69c6					      ldx@PLY	bestMove
      1  69c6		       ae 53 f1 	      ldx	bestMove
    219  69c9		       30 28		      bmi	.nomove
    220  69cb
    221  69cb							; Generate player's moves in reply
    222  69cb							; Make the computer move, list player moves (PLY+1), unmake computer move
    223  69cb
    224  69cb
      0  69cb					      stx@PLY	movePtr
      1  69cb		       8e 52 f5 	      stx	[RAM]+movePtr
    226  69ce		       20 89 fd 	      jsr	MakeMove
    227  69d1
    228  69d1		       20 d2 f8 	      jsr	ListPlayerMoves
    229  69d4
    230  69d4		       a9 0a		      lda	#RAMBANK_PLY
    231  69d6		       85 3e		      sta	SET_BANK_RAM
    232  69d8
    233  69d8		       20 f0 fd 	      jsr	unmakeMove
    234  69db
    235  69db							; Grab the computer move details for the UI animation
    236  69db
    237  69db		       a9 0a		      lda	#RAMBANK_PLY
    238  69dd		       85 3e		      sta	SET_BANK_RAM
    239  69df
      0  69df					      ldx@PLY	bestMove
      1  69df		       ae 53 f1 	      ldx	bestMove
      0  69e2					      lda@PLY	MoveTo,x
      1  69e2		       bd 48 f0 	      lda	MoveTo,x
    242  69e5		       85 86		      sta	toX12
      0  69e7					      lda@PLY	MoveFrom,x
      1  69e7		       bd 02 f0 	      lda	MoveFrom,x
    244  69ea		       85 87		      sta	originX12
    245  69ec		       85 85		      sta	fromX12
      0  69ee					      lda@PLY	MovePiece,x
      1  69ee		       bd 8e f0 	      lda	MovePiece,x
    247  69f1		       85 98		      sta	fromPiece
    248  69f3
    249  69f3				   .nomove
    250  69f3		       60		      rts
    251  69f4
    252  69f4
    253  69f4							;---------------------------------------------------------------------------------------------------
    254  69f4
      0  69f4					      DEF	GenCastleMoveForRook
      1  69f4				   BANK_GenCastleMoveForRook SET	_CURRENT_BANK
      2  69f4				   GenCastleMoveForRook
      3  69f4				   TEMPORARY_VAR SET	Overlay
      4  69f4				   TEMPORARY_OFFSET SET	0
      5  69f4				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      6  69f4				   FUNCTION_NAME SET	GenCastleMoveForRook
      7  69f4					      SUBROUTINE
    256  69f4					      SUBROUTINE
    257  69f4
      0  69f4					      REFER	MakeMove
      1  69f4					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  69f4				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  69f4					      ENDIF
      0  69f4					      REFER	CastleFixupDraw
      1  69f4				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  69f4				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  69f4					      ENDIF
      0  69f4					      VEND	GenCastleMoveForRook
      1  69f4				  -	      IFNCONST	GenCastleMoveForRook
      2  69f4				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  69f4				  -	      ERR
      4  69f4					      ENDIF
      5  69f4		       00 b5	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    261  69f4
    262  69f4		       18		      clc
    263  69f5
    264  69f5		       a5 98		      lda	fromPiece
    265  69f7		       29 10		      and	#FLAG_CASTLE
    266  69f9		       f0 2b		      beq	.exit	; NOT involved in castle!
    267  69fb
    268  69fb		       a2 04		      ldx	#4
    269  69fd		       a5 85		      lda	fromX12	; *destination*
    270  69ff		       18	   .findCast  clc
    271  6a00		       ca		      dex
    272  6a01		       30 23		      bmi	.exit
    273  6a03		       dd 38 f2 	      cmp	KSquare,x
    274  6a06		       d0 f7		      bne	.findCast
    275  6a08
    276  6a08		       bd 40 f2 	      lda	RSquareEnd,x
    277  6a0b		       85 86		      sta	toX12
      0  6a0d					      sta@PLY	secondaryBlank
      1  6a0d		       8d 4e f5 	      sta	[RAM]+secondaryBlank
    279  6a10		       bc 3c f2 	      ldy	RSquareStart,x
    280  6a13		       84 85		      sty	fromX12
    281  6a15		       84 87		      sty	originX12
      0  6a17					      sty@PLY	secondarySquare
      1  6a17		       8c 4d f5 	      sty	[RAM]+secondarySquare
    283  6a1a
    284  6a1a		       a5 98		      lda	fromPiece
    285  6a1c		       29 80		      and	#128	; colour bit
    286  6a1e		       09 05		      ora	#ROOK	; preserve colour
    287  6a20		       85 98		      sta	fromPiece
      0  6a22					      sta@PLY	secondaryPiece
      1  6a22		       8d 4c f5 	      sta	[RAM]+secondaryPiece
    289  6a25
    290  6a25		       38		      sec
    291  6a26		       60	   .exit      rts
    292  6a27
    293  6a27
    294  6a27							;---------------------------------------------------------------------------------------------------
    295  6a27
      0  6a27					      DEF	CastleFixupDraw
      1  6a27				   BANK_CastleFixupDraw SET	_CURRENT_BANK
      2  6a27				   CastleFixupDraw
      3  6a27				   TEMPORARY_VAR SET	Overlay
      4  6a27				   TEMPORARY_OFFSET SET	0
      5  6a27				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      6  6a27				   FUNCTION_NAME SET	CastleFixupDraw
      7  6a27					      SUBROUTINE
    297  6a27					      SUBROUTINE
    298  6a27
      0  6a27					      REFER	aiSpecialMoveFixup
      1  6a27					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  6a27				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  6a27					      ENDIF
      0  6a27					      VEND	CastleFixupDraw
      1  6a27				  -	      IFNCONST	CastleFixupDraw
      2  6a27				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  6a27				  -	      ERR
      4  6a27					      ENDIF
      5  6a27		       00 b3	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    301  6a27
    302  6a27							; fixup any castling issues
    303  6a27							; at this point the king has finished his two-square march
    304  6a27							; based on the finish square, we determine which rook we're interacting with
    305  6a27							; and generate a 'move' for the rook to position on the other side of the king
    306  6a27
    307  6a27
    308  6a27					      IF	CASTLING_ENABLED
    309  6a27		       20 f4 f1 	      jsr	GenCastleMoveForRook
    310  6a2a		       b0 07		      bcs	.phase
    311  6a2c					      ENDIF
    312  6a2c
      0  6a2c					      SWAP
      1  6a2c		       a5 97		      lda	sideToMove
      2  6a2e		       49 81		      eor	#SWAP_SIDE
      3  6a30		       85 97		      sta	sideToMove
    314  6a32		       60		      rts
    315  6a33
    316  6a33				   .phase
    317  6a33
    318  6a33							; in this siutation (castle, rook moving) we do not change sides yet!
    319  6a33
      0  6a33					      PHASE	AI_MoveIsSelected
      1  6a33		       a9 14		      lda	#AI_MoveIsSelected
      2  6a35		       85 8c		      sta	aiState
    321  6a37		       60		      rts
    322  6a38
    323  6a38
    324  6a38
    325  6a38		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    326  6a3c		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    327  6a40		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    328  6a44
    329  6a44
    330  6a44							;---------------------------------------------------------------------------------------------------
    331  6a44
    332  6a44					      MAC	xchg
    333  6a44					      lda@PLY	{1},x
    334  6a44					      sta	__xchg
    335  6a44					      lda@PLY	{1},y
    336  6a44					      sta@PLY	{1},x
    337  6a44					      lda	__xchg
    338  6a44					      sta@PLY	{1},y
    339  6a44					      ENDM		;{name}
    340  6a44
    341  6a44
      0  6a44					      DEF	Sort
      1  6a44				   BANK_Sort  SET	_CURRENT_BANK
      2  6a44				   Sort
      3  6a44				   TEMPORARY_VAR SET	Overlay
      4  6a44				   TEMPORARY_OFFSET SET	0
      5  6a44				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      6  6a44				   FUNCTION_NAME SET	Sort
      7  6a44					      SUBROUTINE
    343  6a44					      SUBROUTINE
    344  6a44
      0  6a44					      REFER	GenerateAllMoves
      1  6a44					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6a44				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6a44					      ENDIF
      0  6a44					      VAR	__xchg, 1
      1  6a44		       00 c9	   __xchg     =	TEMPORARY_VAR
      2  6a44				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6a44
      4  6a44				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6a44				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6a44				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6a44					      ENDIF
      8  6a44				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6a44				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  6a44				  -	      ERR
     11  6a44					      ENDIF
     12  6a44					      LIST	ON
      0  6a44					      VEND	Sort
      1  6a44				  -	      IFNCONST	Sort
      2  6a44				  -	      ECHO	"Incorrect VEND label", Sort
      3  6a44				  -	      ERR
      4  6a44					      ENDIF
      5  6a44		       00 ca	   VAREND_Sort =	TEMPORARY_VAR
    348  6a44
    349  6a44							;lda currentPly
    350  6a44							;sta savedBank 	  ; ??
    351  6a44
    352  6a44		       a5 b2		      lda	__quiesceCapOnly
    353  6a46		       30 51		      bmi	.exit	; only caps present so already sorted!
    354  6a48
      0  6a48					      ldx@PLY	moveIndex
      1  6a48		       ae 51 f1 	      ldx	moveIndex
      0  6a4b					      ldy@PLY	moveIndex
      1  6a4b		       ac 51 f1 	      ldy	moveIndex
    357  6a4e		       88	   .next      dey
    358  6a4f		       30 48		      bmi	.exit
    359  6a51
    360  6a51				  -	      IF	0
    361  6a51				  -	      lda@PLY	MoveCapture,y
    362  6a51				  -	      bne	.swap
    363  6a51				  -	      lda@PLY	MovePiece,y
    364  6a51				  -	      and	#PIECE_MASK
    365  6a51				  -	      cmp	#3
    366  6a51				  -	      bcc	.next
    367  6a51				  -			;		      lda@PLY MovePiece,y
    368  6a51				  -			;		      and #PIECE_MASK
    369  6a51				  -			;		      cmp #3
    370  6a51				  -			;		      bcc .next
    371  6a51				  -
    372  6a51				  -.swap
    373  6a51					      ELSE
      0  6a51					      lda@PLY	MoveCapture,y
      1  6a51		       b9 00 f1 	      lda	MoveCapture,y
    375  6a54		       f0 f8		      beq	.next
    376  6a56
    377  6a56					      ENDIF
    378  6a56
      0  6a56					      XCHG	MoveFrom
      0  6a56					      lda@PLY	MoveFrom,x
      1  6a56		       bd 02 f0 	      lda	MoveFrom,x
      2  6a59		       85 c9		      sta	__xchg
      0  6a5b					      lda@PLY	MoveFrom,y
      1  6a5b		       b9 02 f0 	      lda	MoveFrom,y
      0  6a5e					      sta@PLY	MoveFrom,x
      1  6a5e		       9d 02 f4 	      sta	[RAM]+MoveFrom,x
      5  6a61		       a5 c9		      lda	__xchg
      0  6a63					      sta@PLY	MoveFrom,y
      1  6a63		       99 02 f4 	      sta	[RAM]+MoveFrom,y
      0  6a66					      XCHG	MoveTo
      0  6a66					      lda@PLY	MoveTo,x
      1  6a66		       bd 48 f0 	      lda	MoveTo,x
      2  6a69		       85 c9		      sta	__xchg
      0  6a6b					      lda@PLY	MoveTo,y
      1  6a6b		       b9 48 f0 	      lda	MoveTo,y
      0  6a6e					      sta@PLY	MoveTo,x
      1  6a6e		       9d 48 f4 	      sta	[RAM]+MoveTo,x
      5  6a71		       a5 c9		      lda	__xchg
      0  6a73					      sta@PLY	MoveTo,y
      1  6a73		       99 48 f4 	      sta	[RAM]+MoveTo,y
      0  6a76					      XCHG	MovePiece
      0  6a76					      lda@PLY	MovePiece,x
      1  6a76		       bd 8e f0 	      lda	MovePiece,x
      2  6a79		       85 c9		      sta	__xchg
      0  6a7b					      lda@PLY	MovePiece,y
      1  6a7b		       b9 8e f0 	      lda	MovePiece,y
      0  6a7e					      sta@PLY	MovePiece,x
      1  6a7e		       9d 8e f4 	      sta	[RAM]+MovePiece,x
      5  6a81		       a5 c9		      lda	__xchg
      0  6a83					      sta@PLY	MovePiece,y
      1  6a83		       99 8e f4 	      sta	[RAM]+MovePiece,y
      0  6a86					      XCHG	MoveCapture
      0  6a86					      lda@PLY	MoveCapture,x
      1  6a86		       bd 00 f1 	      lda	MoveCapture,x
      2  6a89		       85 c9		      sta	__xchg
      0  6a8b					      lda@PLY	MoveCapture,y
      1  6a8b		       b9 00 f1 	      lda	MoveCapture,y
      0  6a8e					      sta@PLY	MoveCapture,x
      1  6a8e		       9d 00 f5 	      sta	[RAM]+MoveCapture,x
      5  6a91		       a5 c9		      lda	__xchg
      0  6a93					      sta@PLY	MoveCapture,y
      1  6a93		       99 00 f5 	      sta	[RAM]+MoveCapture,y
    383  6a96
    384  6a96		       ca		      dex
    385  6a97		       10 b5		      bpl	.next
    386  6a99
    387  6a99				   .exit
    388  6a99
    389  6a99
    390  6a99
    391  6a99
    392  6a99							; Scan for capture of king
    393  6a99
      0  6a99					      ldx@PLY	moveIndex
      1  6a99		       ae 51 f1 	      ldx	moveIndex
    395  6a9c
      0  6a9c				   .scanCheck lda@PLY	MoveCapture,x
      1  6a9c		       bd 00 f1 	      lda	MoveCapture,x
    397  6a9f		       f0 0b		      beq	.check	; since they're sorted with captures "first" we can exit
    398  6aa1		       29 0f		      and	#PIECE_MASK
    399  6aa3		       c9 07		      cmp	#KING
    400  6aa5		       f0 05		      beq	.check
    401  6aa7		       ca		      dex
    402  6aa8		       10 f2		      bpl	.scanCheck
    403  6aaa
    404  6aaa		       a9 00		      lda	#0
    405  6aac		       85 a4	   .check     sta	flagCheck
    406  6aae		       60		      rts
    407  6aaf
    408  6aaf
    409  6aaf							;---------------------------------------------------------------------------------------------------
    410  6aaf							; QUIESCE!
    411  6aaf
    412  6aaf							;int Quiesce( int alpha, int beta ) {
    413  6aaf							;    int stand_pat = Evaluate();
    414  6aaf							;    if( stand_pat >= beta )
    415  6aaf							;	  return beta;
    416  6aaf							;    if( alpha < stand_pat )
    417  6aaf							;	  alpha = stand_pat;
    418  6aaf
    419  6aaf							;    until( every_capture_has_been_examined )	{
    420  6aaf							;	  MakeCapture();
    421  6aaf							;	  score = -Quiesce( -beta, -alpha );
    422  6aaf							;	  TakeBackMove();
    423  6aaf
    424  6aaf							;	  if( score >= beta )
    425  6aaf							;	      return beta;
    426  6aaf							;	  if( score > alpha )
    427  6aaf							;	     alpha = score;
    428  6aaf							;    }
    429  6aaf							;    return alpha;
    430  6aaf							;}
    431  6aaf
    432  6aaf
    433  6aaf		       ad 56 f1    .retBeta   lda	beta
    434  6ab2		       85 ae		      sta	__negaMax
    435  6ab4		       ad 57 f1 	      lda	beta+1
    436  6ab7		       85 af		      sta	__negaMax+1
    437  6ab9
    438  6ab9
    439  6ab9		       60		      rts
    440  6aba
    441  6aba
    442  6aba
      0  6aba					      DEF	quiesce
      1  6aba				   BANK_quiesce SET	_CURRENT_BANK
      2  6aba				   quiesce
      3  6aba				   TEMPORARY_VAR SET	Overlay
      4  6aba				   TEMPORARY_OFFSET SET	0
      5  6aba				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      6  6aba				   FUNCTION_NAME SET	quiesce
      7  6aba					      SUBROUTINE
    444  6aba					      SUBROUTINE
    445  6aba
    446  6aba							; pass...
    447  6aba							; x = depthleft
    448  6aba							; SET_BANK_RAM      --> current ply
    449  6aba							; __alpha[2] = param alpha
    450  6aba							; __beta[2] = param beta
    451  6aba
    452  6aba
      0  6aba					      COMMON_VARS_ALPHABETA
      1  6aba
      0  6aba					      VAR	__thinkbar, 1
      1  6aba		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  6aba				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6aba
      4  6aba				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aba				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aba				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aba					      ENDIF
      8  6aba				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aba				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  6aba				  -	      ERR
     11  6aba					      ENDIF
     12  6aba					      LIST	ON
      0  6aba					      VAR	__toggle, 1
      1  6aba		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  6aba				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6aba
      4  6aba				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aba				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aba				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aba					      ENDIF
      8  6aba				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aba				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  6aba				  -	      ERR
     11  6aba					      ENDIF
     12  6aba					      LIST	ON
      4  6aba
      0  6aba					      VAR	__bestMove, 1
      1  6aba		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  6aba				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6aba
      4  6aba				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aba				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aba				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aba					      ENDIF
      8  6aba				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aba				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  6aba				  -	      ERR
     11  6aba					      ENDIF
     12  6aba					      LIST	ON
      0  6aba					      VAR	__alpha, 2
      1  6aba		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  6aba				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6aba
      4  6aba				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aba				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aba				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aba					      ENDIF
      8  6aba				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aba				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  6aba				  -	      ERR
     11  6aba					      ENDIF
     12  6aba					      LIST	ON
      0  6aba					      VAR	__beta, 2
      1  6aba		       00 ac	   __beta     =	TEMPORARY_VAR
      2  6aba				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6aba
      4  6aba				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aba				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aba				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aba					      ENDIF
      8  6aba				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aba				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  6aba				  -	      ERR
     11  6aba					      ENDIF
     12  6aba					      LIST	ON
      0  6aba					      VAR	__negaMax, 2
      1  6aba		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  6aba				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6aba
      4  6aba				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aba				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aba				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aba					      ENDIF
      8  6aba				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aba				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  6aba				  -	      ERR
     11  6aba					      ENDIF
     12  6aba					      LIST	ON
      0  6aba					      VAR	__value, 2
      1  6aba		       00 b0	   __value    =	TEMPORARY_VAR
      2  6aba				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6aba
      4  6aba				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aba				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aba				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aba					      ENDIF
      8  6aba				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aba				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  6aba				  -	      ERR
     11  6aba					      ENDIF
     12  6aba					      LIST	ON
     10  6aba
      0  6aba					      VAR	__quiesceCapOnly, 1
      1  6aba		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  6aba				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6aba
      4  6aba				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aba				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aba				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aba					      ENDIF
      8  6aba				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aba				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  6aba				  -	      ERR
     11  6aba					      ENDIF
     12  6aba					      LIST	ON
     12  6aba
      0  6aba					      REFER	selectmove
      1  6aba				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  6aba				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  6aba					      ENDIF
      0  6aba					      REFER	negaMax
      1  6aba				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  6aba				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  6aba					      ENDIF
      0  6aba					      VEND	quiesce
      1  6aba				  -	      IFNCONST	quiesce
      2  6aba				  -	      ECHO	"Incorrect VEND label", quiesce
      3  6aba				  -	      ERR
      4  6aba					      ENDIF
      5  6aba		       00 b3	   VAREND_quiesce =	TEMPORARY_VAR
    457  6aba
    458  6aba		       a5 95		      lda	currentPly
    459  6abc		       c9 11		      cmp	#MAX_PLY_DEPTH_BANK -1
    460  6abe		       b0 6a		      bcs	.retBeta
    461  6ac0
    462  6ac0					      IF	DIAGNOSTICS
    463  6ac0							;lda currentPly
    464  6ac0							;cmp maxPly
    465  6ac0							;bcc .notmax
    466  6ac0							;sta maxPly
    467  6ac0				   .notmax
    468  6ac0
    469  6ac0
    470  6ac0					      ENDIF
    471  6ac0
    472  6ac0
    473  6ac0		       e6 a1		      inc	positionCount
    474  6ac2		       d0 06		      bne	.p1
    475  6ac4		       e6 a2		      inc	positionCount+1
    476  6ac6		       d0 02		      bne	.p1
    477  6ac8		       e6 a3		      inc	positionCount+2
    478  6aca				   .p1
    479  6aca
    480  6aca
    481  6aca		       a5 a1		      lda	positionCount
    482  6acc		       29 0f		      and	#15
    483  6ace		       a8		      tay
    484  6acf		       b9 7e fe 	      lda	spP1,y
    485  6ad2		       85 4f		      sta	PF2
    486  6ad4		       85 4e		      sta	PF1
    487  6ad6
    488  6ad6
    489  6ad6		       a5 ac		      lda	__beta
      0  6ad8					      sta@PLY	beta
      1  6ad8		       8d 56 f5 	      sta	[RAM]+beta
    491  6adb		       a5 ad		      lda	__beta+1
      0  6add					      sta@PLY	beta+1
      1  6add		       8d 57 f5 	      sta	[RAM]+beta+1
    493  6ae0
    494  6ae0		       a5 aa		      lda	__alpha
      0  6ae2					      sta@PLY	alpha
      1  6ae2		       8d 54 f5 	      sta	[RAM]+alpha
    496  6ae5		       a5 ab		      lda	__alpha+1
      0  6ae7					      sta@PLY	alpha+1
      1  6ae7		       8d 55 f5 	      sta	[RAM]+alpha+1
    498  6aea
    499  6aea
    500  6aea							;    int stand_pat = Evaluate();
    501  6aea							;    if( stand_pat >= beta )
    502  6aea							;	  return beta;
    503  6aea
    504  6aea		       38		      sec
    505  6aeb		       a5 90		      lda	Evaluation
      0  6aed					      sbc@PLY	beta
      1  6aed		       ed 56 f1 	      sbc	beta
    507  6af0		       a5 91		      lda	Evaluation+1
      0  6af2					      sbc@PLY	beta+1
      1  6af2		       ed 57 f1 	      sbc	beta+1
    509  6af5		       50 02		      bvc	.spat0
    510  6af7		       49 80		      eor	#$80
    511  6af9		       10 2f	   .spat0     bpl	.retBeta	; branch if stand_pat >= beta
    512  6afb
    513  6afb							;    if( alpha < stand_pat )
    514  6afb							;	  alpha = stand_pat;
    515  6afb
    516  6afb		       38		      sec
    517  6afc		       ad 54 f1 	      lda	alpha
    518  6aff		       e5 90		      sbc	Evaluation
    519  6b01		       ad 55 f1 	      lda	alpha+1
    520  6b04		       e5 91		      sbc	Evaluation+1
    521  6b06		       50 02		      bvc	.spat1
    522  6b08		       49 80		      eor	#$80
    523  6b0a		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    524  6b0c
    525  6b0c							; alpha < stand_pat
    526  6b0c
    527  6b0c		       a5 90		      lda	Evaluation
      0  6b0e					      sta@PLY	alpha
      1  6b0e		       8d 54 f5 	      sta	[RAM]+alpha
    529  6b11		       a5 91		      lda	Evaluation+1
      0  6b13					      sta@PLY	alpha+1
      1  6b13		       8d 55 f5 	      sta	[RAM]+alpha+1
    531  6b16
    532  6b16				   .alpha
    533  6b16		       20 07 f9 	      jsr	GenerateAllMoves
    534  6b19
    535  6b19							;lda flagCheck
    536  6b19							;bne .inCheck
    537  6b19
      0  6b19					      ldx@PLY	moveIndex
      1  6b19		       ae 51 f1 	      ldx	moveIndex
    539  6b1c		       10 17		      bpl	.forChild
    540  6b1e		       4c aa f3 	      jmp	.exit
    541  6b21							;bmi .exit
    542  6b21
    543  6b21		       a9 18	   .inCheck   lda	#<(INFINITY-1000)
    544  6b23		       85 ae		      sta	__negaMax
    545  6b25		       a9 6c		      lda	#>(INFINITY-1000)
    546  6b27		       85 ae		      sta	__negaMax
    547  6b29		       60		      rts
    548  6b2a
    549  6b2a
    550  6b2a		       ad 56 f1    .retBeta   lda	beta
    551  6b2d		       85 ae		      sta	__negaMax
    552  6b2f		       ad 57 f1 	      lda	beta+1
    553  6b32		       85 af		      sta	__negaMax+1
    554  6b34		       60		      rts
    555  6b35
    556  6b35
    557  6b35							;.inCheck	      ldx@PLY movePtr
    558  6b35							;		      lda #0
    559  6b35							;		      sta@PLY MoveFrom,x
    560  6b35							;		      beq .nextMove
    561  6b35
    562  6b35
    563  6b35
    564  6b35
      0  6b35				   .forChild  stx@PLY	movePtr
      1  6b35		       8e 52 f5 	      stx	[RAM]+movePtr
    566  6b38
    567  6b38							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    568  6b38
    569  6b38		       20 89 fd 	      jsr	MakeMove
    570  6b3b
    571  6b3b		       38		      sec
    572  6b3c		       a9 00		      lda	#0
      0  6b3e					      sbc@PLY	beta
      1  6b3e		       ed 56 f1 	      sbc	beta
    574  6b41		       85 aa		      sta	__alpha
    575  6b43		       a9 00		      lda	#0
      0  6b45					      sbc@PLY	beta+1
      1  6b45		       ed 57 f1 	      sbc	beta+1
    577  6b48		       85 ab		      sta	__alpha+1
    578  6b4a
    579  6b4a		       38		      sec
    580  6b4b		       a9 00		      lda	#0
      0  6b4d					      sbc@PLY	alpha
      1  6b4d		       ed 54 f1 	      sbc	alpha
    582  6b50		       85 ac		      sta	__beta
    583  6b52		       a9 00		      lda	#0
      0  6b54					      sbc@PLY	alpha+1
      1  6b54		       ed 55 f1 	      sbc	alpha+1
    585  6b57		       85 ad		      sta	__beta+1
    586  6b59
    587  6b59		       e6 95		      inc	currentPly
    588  6b5b		       a5 95		      lda	currentPly
    589  6b5d		       85 3e		      sta	SET_BANK_RAM	; self-switch
    590  6b5f
    591  6b5f		       20 ba f2 	      jsr	quiesce
    592  6b62
    593  6b62		       c6 95		      dec	currentPly
    594  6b64		       a5 95		      lda	currentPly
    595  6b66		       85 3e		      sta	SET_BANK_RAM
    596  6b68
    597  6b68		       20 f0 fd 	      jsr	unmakeMove
    598  6b6b
    599  6b6b
    600  6b6b		       38		      sec
    601  6b6c		       a9 00		      lda	#0
    602  6b6e		       e5 ae		      sbc	__negaMax
    603  6b70		       85 ae		      sta	__negaMax
    604  6b72		       a9 00		      lda	#0
    605  6b74		       e5 af		      sbc	__negaMax+1
    606  6b76		       85 af		      sta	__negaMax+1	; -negaMax(...)
    607  6b78
    608  6b78							;lda flagCheck 		  ; don't consider moves which leave us in check
    609  6b78							;bne .nextMove
    610  6b78
    611  6b78							;	  if( score >= beta )
    612  6b78							;	      return beta;
    613  6b78
    614  6b78
    615  6b78		       38		      sec
    616  6b79		       a5 ae		      lda	__negaMax
      0  6b7b					      sbc@PLY	beta
      1  6b7b		       ed 56 f1 	      sbc	beta
    618  6b7e		       a5 af		      lda	__negaMax+1
      0  6b80					      sbc@PLY	beta+1
      1  6b80		       ed 57 f1 	      sbc	beta+1
    620  6b83		       50 02		      bvc	.lab0
    621  6b85		       49 80		      eor	#$80
    622  6b87		       10 a1	   .lab0      bpl	.retBeta	; branch if score >= beta
    623  6b89
    624  6b89							;	  if( score > alpha )
    625  6b89							;	     alpha = score;
    626  6b89							;    }
    627  6b89
    628  6b89		       38		      sec
      0  6b8a					      lda@PLY	alpha
      1  6b8a		       ad 54 f1 	      lda	alpha
    630  6b8d		       e5 ae		      sbc	__negaMax
      0  6b8f					      lda@PLY	alpha+1
      1  6b8f		       ad 55 f1 	      lda	alpha+1
    632  6b92		       e5 af		      sbc	__negaMax+1
    633  6b94		       50 02		      bvc	.lab2
    634  6b96		       49 80		      eor	#$80
    635  6b98		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    636  6b9a
    637  6b9a							; score > alpha
    638  6b9a
    639  6b9a		       a5 ae		      lda	__negaMax
      0  6b9c					      sta@PLY	alpha
      1  6b9c		       8d 54 f5 	      sta	[RAM]+alpha
    641  6b9f		       a5 af		      lda	__negaMax+1
      0  6ba1					      sta@PLY	alpha+1
      1  6ba1		       8d 55 f5 	      sta	[RAM]+alpha+1
    643  6ba4
      0  6ba4				   .nextMove  ldx@PLY	movePtr
      1  6ba4		       ae 52 f1 	      ldx	movePtr
    645  6ba7		       ca		      dex
    646  6ba8		       10 8b		      bpl	.forChild
    647  6baa
    648  6baa				   .exit
    649  6baa
    650  6baa
    651  6baa							;    return alpha;
    652  6baa
      0  6baa					      lda@PLY	alpha
      1  6baa		       ad 54 f1 	      lda	alpha
    654  6bad		       85 ae		      sta	__negaMax
      0  6baf					      lda@PLY	alpha+1
      1  6baf		       ad 55 f1 	      lda	alpha+1
    656  6bb2		       85 af		      sta	__negaMax+1
    657  6bb4		       60		      rts
    658  6bb5
    659  6bb5		       a9 00	   .checker   lda	#0
    660  6bb7		       85 a4		      sta	flagCheck
    661  6bb9		       4c a4 f3 	      jmp	.nextMove
    662  6bbc
    663  6bbc
    664  6bbc							;---------------------------------------------------------------------------------------------------
    665  6bbc
      0  6bbc					      DEF	AddMovePly
      1  6bbc				   BANK_AddMovePly SET	_CURRENT_BANK
      2  6bbc				   AddMovePly
      3  6bbc				   TEMPORARY_VAR SET	Overlay
      4  6bbc				   TEMPORARY_OFFSET SET	0
      5  6bbc				   VAR_BOUNDARY_AddMovePly SET	TEMPORARY_OFFSET
      6  6bbc				   FUNCTION_NAME SET	AddMovePly
      7  6bbc					      SUBROUTINE
    667  6bbc					      SUBROUTINE
    668  6bbc
      0  6bbc					      REFER	AddMove
      1  6bbc				  -	      IF	VAREND_AddMove > TEMPORARY_VAR
      2  6bbc				  -TEMPORARY_VAR SET	VAREND_AddMove
      3  6bbc					      ENDIF
      0  6bbc					      VEND	AddMovePly
      1  6bbc				  -	      IFNCONST	AddMovePly
      2  6bbc				  -	      ECHO	"Incorrect VEND label", AddMovePly
      3  6bbc				  -	      ERR
      4  6bbc					      ENDIF
      5  6bbc		       00 a7	   VAREND_AddMovePly =	TEMPORARY_VAR
    671  6bbc
    672  6bbc		       98		      tya
    673  6bbd
      0  6bbd					      ldy@PLY	moveIndex
      1  6bbd		       ac 51 f1 	      ldy	moveIndex
    675  6bc0		       c8		      iny
      0  6bc1					      sty@PLY	moveIndex
      1  6bc1		       8c 51 f5 	      sty	[RAM]+moveIndex
    677  6bc4
      0  6bc4					      sta@PLY	MoveTo,y
      1  6bc4		       99 48 f4 	      sta	[RAM]+MoveTo,y
    679  6bc7		       aa		      tax		; used for continuation of sliding moves
    680  6bc8		       a5 93		      lda	currentSquare
      0  6bca					      sta@PLY	MoveFrom,y
      1  6bca		       99 02 f4 	      sta	[RAM]+MoveFrom,y
    682  6bcd		       a5 92		      lda	currentPiece
      0  6bcf					      sta@PLY	MovePiece,y
      1  6bcf		       99 8e f4 	      sta	[RAM]+MovePiece,y
    684  6bd2		       a5 9f		      lda	capture
      0  6bd4					      sta@PLY	MoveCapture,y
      1  6bd4		       99 00 f5 	      sta	[RAM]+MoveCapture,y
    686  6bd7
    687  6bd7		       60		      rts
    688  6bd8
    689  6bd8
    690  6bd8							;---------------------------------------------------------------------------------------------------
    691  6bd8
      0  6bd8					      CHECK_HALF_BANK_SIZE	"PLY -- 1K"
      1  6bd8
      2  6bd8
      3  6bd8		       03 d8	   .TEMP      =	* - BANK_START
 PLY -- 1K (1K) SIZE =  $3d8 , FREE= $28
      4  6bd8					      ECHO	"PLY -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  6bd8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE/2
      6  6bd8				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  6bd8				  -	      ERR
      8  6bd8					      ENDIF
    693  6bd8
    694  6bd8							;---------------------------------------------------------------------------------------------------
    695  6bd8
    696  6bd8							; There is space here (1K) for use as ROM
    697  6bd8							; but NOT when the above bank is switched in as RAM, of course!
    698  6bd8
    699  6bd8
    700  6bd8
    701  6bd8
    702  6bd8							;---------------------------------------------------------------------------------------------------
    703  6bd8							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 5
      0  6bd8					      include	"BANK_EVAL.asm"
      0  6bd8					      NEWRAMBANK	BANK_EVAL
      1  6bd8
      2  6bd8
      3  6bd8
      4 U4800 ????				      SEG.U	BANK_EVAL
      5 U4800					      ORG	ORIGIN_RAM
      6 U4800					      RORG	RAM_3E
      7 U4800				   BANK_START SET	*
      8 U4800				   RAMBANK_BANK_EVAL SET	ORIGIN_RAM / RAM_SIZE
      9 U4800				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U4800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U4800					      NEWBANK	EVAL
      1  7368 ????				      SEG	EVAL
      2  7000					      ORG	ORIGIN
      3  7000					      RORG	$F000
      4  7000				   BANK_START SET	*
      5  7000				   EVAL       SET	ORIGIN / 2048
      6  7000				   ORIGIN     SET	ORIGIN + 2048
      7  7000				   _CURRENT_BANK SET	EVAL
      3  7000
      4  7000
      5  7000							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
      6  7000
      7  7000
      8  7000
      9  7000					      MAC	vequ
     10  7000				   VALUE_{1}  =	{2}
     11  7000					      ENDM
     12  7000
     13  7000					      MAC	lobyte
     14  7000					      .byte	<{2}
     15  7000					      ENDM
     16  7000
     17  7000					      MAC	hibyte
     18  7000					      .byte	>{2}
     19  7000					      ENDM
     20  7000
     21  7000
     22  7000					      MAC	valuetable
     23  7000					      {1}	BLANK, 0
     24  7000					      {1}	PAWN, 100	; white
     25  7000					      {1}	PAWN, 100	; black
     26  7000					      {1}	KNIGHT, 320
     27  7000					      {1}	BISHOP, 375
     28  7000					      {1}	ROOK, 575
     29  7000					      {1}	QUEEN, 900
     30  7000					      {1}	KING, 10000
     31  7000					      ENDM
     32  7000
     33  7000
      0  7000					      VALUETABLE	VEQU
      0  7000					      VEQU	BLANK, 0
      1  7000		       00 00	   VALUE_BLANK =	0
      0  7000					      VEQU	PAWN, 100
      1  7000		       00 64	   VALUE_PAWN =	100
      0  7000					      VEQU	PAWN, 100
      1  7000		       00 64	   VALUE_PAWN =	100
      0  7000					      VEQU	KNIGHT, 320
      1  7000		       01 40	   VALUE_KNIGHT =	320
      0  7000					      VEQU	BISHOP, 375
      1  7000		       01 77	   VALUE_BISHOP =	375
      0  7000					      VEQU	ROOK, 575
      1  7000		       02 3f	   VALUE_ROOK =	575
      0  7000					      VEQU	QUEEN, 900
      1  7000		       03 84	   VALUE_QUEEN =	900
      0  7000					      VEQU	KING, 10000
      1  7000		       27 10	   VALUE_KING =	10000
     35  7000
      0  7000					      DEF	PieceValueLO
      1  7000				   BANK_PieceValueLO SET	_CURRENT_BANK
      2  7000				   PieceValueLO
      3  7000				   TEMPORARY_VAR SET	Overlay
      4  7000				   TEMPORARY_OFFSET SET	0
      5  7000				   VAR_BOUNDARY_PieceValueLO SET	TEMPORARY_OFFSET
      6  7000				   FUNCTION_NAME SET	PieceValueLO
      7  7000					      SUBROUTINE
      0  7000					      VALUETABLE	LOBYTE
      0  7000					      LOBYTE	BLANK, 0
      1  7000		       00		      .byte.b	<0
      0  7001					      LOBYTE	PAWN, 100
      1  7001		       64		      .byte.b	<100
      0  7002					      LOBYTE	PAWN, 100
      1  7002		       64		      .byte.b	<100
      0  7003					      LOBYTE	KNIGHT, 320
      1  7003		       40		      .byte.b	<320
      0  7004					      LOBYTE	BISHOP, 375
      1  7004		       77		      .byte.b	<375
      0  7005					      LOBYTE	ROOK, 575
      1  7005		       3f		      .byte.b	<575
      0  7006					      LOBYTE	QUEEN, 900
      1  7006		       84		      .byte.b	<900
      0  7007					      LOBYTE	KING, 10000
      1  7007		       10		      .byte.b	<10000
     38  7008
      0  7008					      DEF	PieceValueHI
      1  7008				   BANK_PieceValueHI SET	_CURRENT_BANK
      2  7008				   PieceValueHI
      3  7008				   TEMPORARY_VAR SET	Overlay
      4  7008				   TEMPORARY_OFFSET SET	0
      5  7008				   VAR_BOUNDARY_PieceValueHI SET	TEMPORARY_OFFSET
      6  7008				   FUNCTION_NAME SET	PieceValueHI
      7  7008					      SUBROUTINE
      0  7008					      VALUETABLE	HIBYTE
      0  7008					      HIBYTE	BLANK, 0
      1  7008		       00		      .byte.b	>0
      0  7009					      HIBYTE	PAWN, 100
      1  7009		       00		      .byte.b	>100
      0  700a					      HIBYTE	PAWN, 100
      1  700a		       00		      .byte.b	>100
      0  700b					      HIBYTE	KNIGHT, 320
      1  700b		       01		      .byte.b	>320
      0  700c					      HIBYTE	BISHOP, 375
      1  700c		       01		      .byte.b	>375
      0  700d					      HIBYTE	ROOK, 575
      1  700d		       02		      .byte.b	>575
      0  700e					      HIBYTE	QUEEN, 900
      1  700e		       03		      .byte.b	>900
      0  700f					      HIBYTE	KING, 10000
      1  700f		       27		      .byte.b	>10000
     41  7010
     42  7010							;---------------------------------------------------------------------------------------------------
     43  7010
      0  7010					      DEF	EnPassantRemovePiece
      1  7010				   BANK_EnPassantRemovePiece SET	_CURRENT_BANK
      2  7010				   EnPassantRemovePiece
      3  7010				   TEMPORARY_VAR SET	Overlay
      4  7010				   TEMPORARY_OFFSET SET	0
      5  7010				   VAR_BOUNDARY_EnPassantRemovePiece SET	TEMPORARY_OFFSET
      6  7010				   FUNCTION_NAME SET	EnPassantRemovePiece
      7  7010					      SUBROUTINE
     45  7010					      SUBROUTINE
     46  7010
      0  7010					      REFER	MakeMove
      1  7010					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  7010				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  7010					      ENDIF
     48  7010				  -	      IF	ENPASSANT_ENABLED
     49  7010				  -	      REFER	EnPassantCheck
     50  7010					      ENDIF
      0  7010					      VAR	__y, 1
      1  7010		       00 b5	   __y	      =	TEMPORARY_VAR
      2  7010				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7010
      4  7010				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7010				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7010				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7010					      ENDIF
      8  7010				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7010				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  7010				  -	      ERR
     11  7010					      ENDIF
     12  7010					      LIST	ON
      0  7010					      VAR	__col, 1
      1  7010		       00 b6	   __col      =	TEMPORARY_VAR
      2  7010				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7010
      4  7010				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7010				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7010				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7010					      ENDIF
      8  7010				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7010				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  7010				  -	      ERR
     11  7010					      ENDIF
     12  7010					      LIST	ON
      0  7010					      VEND	EnPassantRemovePiece
      1  7010				  -	      IFNCONST	EnPassantRemovePiece
      2  7010				  -	      ECHO	"Incorrect VEND label", EnPassantRemovePiece
      3  7010				  -	      ERR
      4  7010					      ENDIF
      5  7010		       00 b7	   VAREND_EnPassantRemovePiece =	TEMPORARY_VAR
     54  7010
     55  7010
     56  7010							; Based on piece square, adjust material and position value with piece deleted
     57  7010							; y = piece square
     58  7010
     59  7010		       84 b5		      sty	__y
     60  7012
     61  7012		       20 7d fc 	      jsr	GetBoard
     62  7015		       85 b6		      sta	__col
     63  7017		       20 28 f0 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
     64  701a
     65  701a		       a5 b6		      lda	__col
     66  701c		       a4 b5		      ldy	__y
     67  701e		       20 3b f0 	      jsr	AddPiecePositionValue	; adding for opponent = taking
     68  7021
     69  7021		       a5 97		      lda	sideToMove
     70  7023		       29 7f		      and	#127
     71  7025		       85 3e		      sta	SET_BANK_RAM
     72  7027
     73  7027		       60		      rts
     74  7028
     75  7028
     76  7028							;---------------------------------------------------------------------------------------------------
     77  7028
      0  7028					      DEF	AddPieceMaterialValue
      1  7028				   BANK_AddPieceMaterialValue SET	_CURRENT_BANK
      2  7028				   AddPieceMaterialValue
      3  7028				   TEMPORARY_VAR SET	Overlay
      4  7028				   TEMPORARY_OFFSET SET	0
      5  7028				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      6  7028				   FUNCTION_NAME SET	AddPieceMaterialValue
      7  7028					      SUBROUTINE
     79  7028					      SUBROUTINE
     80  7028
      0  7028					      REFER	AdjustMaterialPositionalValue
      1  7028					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  7028				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  7028					      ENDIF
      0  7028					      REFER	InitialisePieceSquares
      1  7028				  -	      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  7028				  -TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  7028					      ENDIF
      0  7028					      REFER	EnPassantRemovePiece
      1  7028				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  7028				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  7028					      ENDIF
      0  7028					      VEND	AddPieceMaterialValue
      1  7028				  -	      IFNCONST	AddPieceMaterialValue
      2  7028				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  7028				  -	      ERR
      4  7028					      ENDIF
      5  7028		       00 b7	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
     85  7028
     86  7028							; Adjust the material score based on the piece
     87  7028							; a = piece type + flags
     88  7028
     89  7028		       29 0f		      and	#PIECE_MASK
     90  702a		       a8		      tay
     91  702b
     92  702b		       18		      clc
     93  702c		       b9 00 f0 	      lda	PieceValueLO,y
     94  702f		       65 90		      adc	Evaluation
     95  7031		       85 90		      sta	Evaluation
     96  7033		       b9 08 f0 	      lda	PieceValueHI,y
     97  7036		       65 91		      adc	Evaluation+1
     98  7038		       85 91		      sta	Evaluation+1
     99  703a		       60		      rts
    100  703b
    101  703b
    102  703b							;---------------------------------------------------------------------------------------------------
    103  703b
      0  703b					      DEF	AddPiecePositionValue
      1  703b				   BANK_AddPiecePositionValue SET	_CURRENT_BANK
      2  703b				   AddPiecePositionValue
      3  703b				   TEMPORARY_VAR SET	Overlay
      4  703b				   TEMPORARY_OFFSET SET	0
      5  703b				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      6  703b				   FUNCTION_NAME SET	AddPiecePositionValue
      7  703b					      SUBROUTINE
    105  703b					      SUBROUTINE
    106  703b
      0  703b					      REFER	AdjustMaterialPositionalValue
      1  703b					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  703b				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  703b					      ENDIF
      0  703b					      REFER	negaMax
      1  703b				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  703b				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  703b					      ENDIF
      0  703b					      REFER	quiesce
      1  703b				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  703b				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  703b					      ENDIF
      0  703b					      VAR	__valPtr, 2
      1  703b		       00 b7	   __valPtr   =	TEMPORARY_VAR
      2  703b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  703b
      4  703b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  703b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  703b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  703b					      ENDIF
      8  703b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  703b				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  703b				  -	      ERR
     11  703b					      ENDIF
     12  703b					      LIST	ON
      0  703b					      VEND	AddPiecePositionValue
      1  703b				  -	      IFNCONST	AddPiecePositionValue
      2  703b				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  703b				  -	      ERR
      4  703b					      ENDIF
      5  703b		       00 b9	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    112  703b
    113  703b
    114  703b							; adds value of square piece is on to the evaluation
    115  703b							; note to do the subtraction as -( -x + val) == x - val
    116  703b
    117  703b							; y = square
    118  703b							; a = piece type (+flags)
    119  703b
    120  703b
    121  703b
    122  703b		       c9 80		      cmp	#128	; black = CS
    123  703d		       29 0f		      and	#PIECE_MASK
    124  703f		       aa		      tax
    125  7040
    126  7040							; black pieces flip rows so we can use the same eval tables
    127  7040
    128  7040		       98		      tya
    129  7041		       90 03		      bcc	.white
    130  7043		       b9 74 f0 	      lda	FlipSquareIndex,y
    131  7046							;clc
    132  7046				   .white
    133  7046		       7d d8 f0 	      adc	PosValVecLO,x
    134  7049		       85 b7		      sta	__valPtr
    135  704b		       bd e0 f0 	      lda	PosValVecHI,x
    136  704e		       69 00		      adc	#0
    137  7050		       85 b8		      sta	__valPtr+1
    138  7052
    139  7052		       a0 00		      ldy	#0
    140  7054		       b1 b7		      lda	(__valPtr),y
    141  7056
    142  7056							;clc
    143  7056		       65 90		      adc	Evaluation
    144  7058		       85 90		      sta	Evaluation
    145  705a		       90 02		      bcc	.noH
    146  705c		       e6 91		      inc	Evaluation+1
    147  705e		       60	   .noH       rts
    148  705f
    149  705f
    150  705f
      0  705f					      DEF	IncVal
      1  705f				   BANK_IncVal SET	_CURRENT_BANK
      2  705f				   IncVal
      3  705f				   TEMPORARY_VAR SET	Overlay
      4  705f				   TEMPORARY_OFFSET SET	0
      5  705f				   VAR_BOUNDARY_IncVal SET	TEMPORARY_OFFSET
      6  705f				   FUNCTION_NAME SET	IncVal
      7  705f					      SUBROUTINE
    152  705f					      SUBROUTINE
    153  705f
    154  705f		       a2 63		      ldx	#99
    155  7061		       18	   .higher    clc
      0  7062					      lda@RAM	PositionalValue_PAWN_BLACK,x
      1  7062		       bd 38 f1 	      lda	PositionalValue_PAWN_BLACK,x
    157  7065		       69 0a		      adc	#10
    158  7067		       c9 7f		      cmp	#$7F
    159  7069		       90 02		      bcc	.norm
    160  706b		       a9 7f		      lda	#$7f
      0  706d				   .norm      sta@RAM	PositionalValue_PAWN_BLACK,x
      1  706d		       9d 38 f5 	      sta	[RAM]+PositionalValue_PAWN_BLACK,x
    162  7070		       ca		      dex
    163  7071		       10 ee		      bpl	.higher
    164  7073		       60		      rts
    165  7074
    166  7074							;---------------------------------------------------------------------------------------------------
    167  7074
      0  7074					      ALLOCATE	FlipSquareIndex, 100
      0  7074					      OPTIONAL_PAGEBREAK	"Table", 100
     12  7074					      LIST	ON
      0  7074					      DEF	FlipSquareIndex
      1  7074				   BANK_FlipSquareIndex SET	_CURRENT_BANK
      2  7074				   FlipSquareIndex
      3  7074				   TEMPORARY_VAR SET	Overlay
      4  7074				   TEMPORARY_OFFSET SET	0
      5  7074				   VAR_BOUNDARY_FlipSquareIndex SET	TEMPORARY_OFFSET
      6  7074				   FUNCTION_NAME SET	FlipSquareIndex
      7  7074					      SUBROUTINE
    169  7074
    170  7074		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    171  707e		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    172  7088
    173  7088				   .SQBASE    SET	90-1
    174  7088					      REPEAT	8
    175  7088		       00 00		      .byte.b	0,0
    176  7088				   .SQX       SET	2
    177  708a					      REPEAT	8
    178  708a		       5b		      .byte.b	(.SQBASE+.SQX)
    179  708a				   .SQX       SET	.SQX + 1
    177  708a					      REPEND
    178  708b		       5c		      .byte.b	(.SQBASE+.SQX)
    179  708b				   .SQX       SET	.SQX + 1
    177  708b					      REPEND
    178  708c		       5d		      .byte.b	(.SQBASE+.SQX)
    179  708c				   .SQX       SET	.SQX + 1
    177  708c					      REPEND
    178  708d		       5e		      .byte.b	(.SQBASE+.SQX)
    179  708d				   .SQX       SET	.SQX + 1
    177  708d					      REPEND
    178  708e		       5f		      .byte.b	(.SQBASE+.SQX)
    179  708e				   .SQX       SET	.SQX + 1
    177  708e					      REPEND
    178  708f		       60		      .byte.b	(.SQBASE+.SQX)
    179  708f				   .SQX       SET	.SQX + 1
    177  708f					      REPEND
    178  7090		       61		      .byte.b	(.SQBASE+.SQX)
    179  7090				   .SQX       SET	.SQX + 1
    177  7090					      REPEND
    178  7091		       62		      .byte.b	(.SQBASE+.SQX)
    179  7091				   .SQX       SET	.SQX + 1
    180  7092					      REPEND
    181  7092				   .SQBASE    SET	.SQBASE - 10
    174  7092					      REPEND
    175  7092		       00 00		      .byte.b	0,0
    176  7092				   .SQX       SET	2
    177  7094					      REPEAT	8
    178  7094		       51		      .byte.b	(.SQBASE+.SQX)
    179  7094				   .SQX       SET	.SQX + 1
    177  7094					      REPEND
    178  7095		       52		      .byte.b	(.SQBASE+.SQX)
    179  7095				   .SQX       SET	.SQX + 1
    177  7095					      REPEND
    178  7096		       53		      .byte.b	(.SQBASE+.SQX)
    179  7096				   .SQX       SET	.SQX + 1
    177  7096					      REPEND
    178  7097		       54		      .byte.b	(.SQBASE+.SQX)
    179  7097				   .SQX       SET	.SQX + 1
    177  7097					      REPEND
    178  7098		       55		      .byte.b	(.SQBASE+.SQX)
    179  7098				   .SQX       SET	.SQX + 1
    177  7098					      REPEND
    178  7099		       56		      .byte.b	(.SQBASE+.SQX)
    179  7099				   .SQX       SET	.SQX + 1
    177  7099					      REPEND
    178  709a		       57		      .byte.b	(.SQBASE+.SQX)
    179  709a				   .SQX       SET	.SQX + 1
    177  709a					      REPEND
    178  709b		       58		      .byte.b	(.SQBASE+.SQX)
    179  709b				   .SQX       SET	.SQX + 1
    180  709c					      REPEND
    181  709c				   .SQBASE    SET	.SQBASE - 10
    174  709c					      REPEND
    175  709c		       00 00		      .byte.b	0,0
    176  709c				   .SQX       SET	2
    177  709e					      REPEAT	8
    178  709e		       47		      .byte.b	(.SQBASE+.SQX)
    179  709e				   .SQX       SET	.SQX + 1
    177  709e					      REPEND
    178  709f		       48		      .byte.b	(.SQBASE+.SQX)
    179  709f				   .SQX       SET	.SQX + 1
    177  709f					      REPEND
    178  70a0		       49		      .byte.b	(.SQBASE+.SQX)
    179  70a0				   .SQX       SET	.SQX + 1
    177  70a0					      REPEND
    178  70a1		       4a		      .byte.b	(.SQBASE+.SQX)
    179  70a1				   .SQX       SET	.SQX + 1
    177  70a1					      REPEND
    178  70a2		       4b		      .byte.b	(.SQBASE+.SQX)
    179  70a2				   .SQX       SET	.SQX + 1
    177  70a2					      REPEND
    178  70a3		       4c		      .byte.b	(.SQBASE+.SQX)
    179  70a3				   .SQX       SET	.SQX + 1
    177  70a3					      REPEND
    178  70a4		       4d		      .byte.b	(.SQBASE+.SQX)
    179  70a4				   .SQX       SET	.SQX + 1
    177  70a4					      REPEND
    178  70a5		       4e		      .byte.b	(.SQBASE+.SQX)
    179  70a5				   .SQX       SET	.SQX + 1
    180  70a6					      REPEND
    181  70a6				   .SQBASE    SET	.SQBASE - 10
    174  70a6					      REPEND
    175  70a6		       00 00		      .byte.b	0,0
    176  70a6				   .SQX       SET	2
    177  70a8					      REPEAT	8
    178  70a8		       3d		      .byte.b	(.SQBASE+.SQX)
    179  70a8				   .SQX       SET	.SQX + 1
    177  70a8					      REPEND
    178  70a9		       3e		      .byte.b	(.SQBASE+.SQX)
    179  70a9				   .SQX       SET	.SQX + 1
    177  70a9					      REPEND
    178  70aa		       3f		      .byte.b	(.SQBASE+.SQX)
    179  70aa				   .SQX       SET	.SQX + 1
    177  70aa					      REPEND
    178  70ab		       40		      .byte.b	(.SQBASE+.SQX)
    179  70ab				   .SQX       SET	.SQX + 1
    177  70ab					      REPEND
    178  70ac		       41		      .byte.b	(.SQBASE+.SQX)
    179  70ac				   .SQX       SET	.SQX + 1
    177  70ac					      REPEND
    178  70ad		       42		      .byte.b	(.SQBASE+.SQX)
    179  70ad				   .SQX       SET	.SQX + 1
    177  70ad					      REPEND
    178  70ae		       43		      .byte.b	(.SQBASE+.SQX)
    179  70ae				   .SQX       SET	.SQX + 1
    177  70ae					      REPEND
    178  70af		       44		      .byte.b	(.SQBASE+.SQX)
    179  70af				   .SQX       SET	.SQX + 1
    180  70b0					      REPEND
    181  70b0				   .SQBASE    SET	.SQBASE - 10
    174  70b0					      REPEND
    175  70b0		       00 00		      .byte.b	0,0
    176  70b0				   .SQX       SET	2
    177  70b2					      REPEAT	8
    178  70b2		       33		      .byte.b	(.SQBASE+.SQX)
    179  70b2				   .SQX       SET	.SQX + 1
    177  70b2					      REPEND
    178  70b3		       34		      .byte.b	(.SQBASE+.SQX)
    179  70b3				   .SQX       SET	.SQX + 1
    177  70b3					      REPEND
    178  70b4		       35		      .byte.b	(.SQBASE+.SQX)
    179  70b4				   .SQX       SET	.SQX + 1
    177  70b4					      REPEND
    178  70b5		       36		      .byte.b	(.SQBASE+.SQX)
    179  70b5				   .SQX       SET	.SQX + 1
    177  70b5					      REPEND
    178  70b6		       37		      .byte.b	(.SQBASE+.SQX)
    179  70b6				   .SQX       SET	.SQX + 1
    177  70b6					      REPEND
    178  70b7		       38		      .byte.b	(.SQBASE+.SQX)
    179  70b7				   .SQX       SET	.SQX + 1
    177  70b7					      REPEND
    178  70b8		       39		      .byte.b	(.SQBASE+.SQX)
    179  70b8				   .SQX       SET	.SQX + 1
    177  70b8					      REPEND
    178  70b9		       3a		      .byte.b	(.SQBASE+.SQX)
    179  70b9				   .SQX       SET	.SQX + 1
    180  70ba					      REPEND
    181  70ba				   .SQBASE    SET	.SQBASE - 10
    174  70ba					      REPEND
    175  70ba		       00 00		      .byte.b	0,0
    176  70ba				   .SQX       SET	2
    177  70bc					      REPEAT	8
    178  70bc		       29		      .byte.b	(.SQBASE+.SQX)
    179  70bc				   .SQX       SET	.SQX + 1
    177  70bc					      REPEND
    178  70bd		       2a		      .byte.b	(.SQBASE+.SQX)
    179  70bd				   .SQX       SET	.SQX + 1
    177  70bd					      REPEND
    178  70be		       2b		      .byte.b	(.SQBASE+.SQX)
    179  70be				   .SQX       SET	.SQX + 1
    177  70be					      REPEND
    178  70bf		       2c		      .byte.b	(.SQBASE+.SQX)
    179  70bf				   .SQX       SET	.SQX + 1
    177  70bf					      REPEND
    178  70c0		       2d		      .byte.b	(.SQBASE+.SQX)
    179  70c0				   .SQX       SET	.SQX + 1
    177  70c0					      REPEND
    178  70c1		       2e		      .byte.b	(.SQBASE+.SQX)
    179  70c1				   .SQX       SET	.SQX + 1
    177  70c1					      REPEND
    178  70c2		       2f		      .byte.b	(.SQBASE+.SQX)
    179  70c2				   .SQX       SET	.SQX + 1
    177  70c2					      REPEND
    178  70c3		       30		      .byte.b	(.SQBASE+.SQX)
    179  70c3				   .SQX       SET	.SQX + 1
    180  70c4					      REPEND
    181  70c4				   .SQBASE    SET	.SQBASE - 10
    174  70c4					      REPEND
    175  70c4		       00 00		      .byte.b	0,0
    176  70c4				   .SQX       SET	2
    177  70c6					      REPEAT	8
    178  70c6		       1f		      .byte.b	(.SQBASE+.SQX)
    179  70c6				   .SQX       SET	.SQX + 1
    177  70c6					      REPEND
    178  70c7		       20		      .byte.b	(.SQBASE+.SQX)
    179  70c7				   .SQX       SET	.SQX + 1
    177  70c7					      REPEND
    178  70c8		       21		      .byte.b	(.SQBASE+.SQX)
    179  70c8				   .SQX       SET	.SQX + 1
    177  70c8					      REPEND
    178  70c9		       22		      .byte.b	(.SQBASE+.SQX)
    179  70c9				   .SQX       SET	.SQX + 1
    177  70c9					      REPEND
    178  70ca		       23		      .byte.b	(.SQBASE+.SQX)
    179  70ca				   .SQX       SET	.SQX + 1
    177  70ca					      REPEND
    178  70cb		       24		      .byte.b	(.SQBASE+.SQX)
    179  70cb				   .SQX       SET	.SQX + 1
    177  70cb					      REPEND
    178  70cc		       25		      .byte.b	(.SQBASE+.SQX)
    179  70cc				   .SQX       SET	.SQX + 1
    177  70cc					      REPEND
    178  70cd		       26		      .byte.b	(.SQBASE+.SQX)
    179  70cd				   .SQX       SET	.SQX + 1
    180  70ce					      REPEND
    181  70ce				   .SQBASE    SET	.SQBASE - 10
    174  70ce					      REPEND
    175  70ce		       00 00		      .byte.b	0,0
    176  70ce				   .SQX       SET	2
    177  70d0					      REPEAT	8
    178  70d0		       15		      .byte.b	(.SQBASE+.SQX)
    179  70d0				   .SQX       SET	.SQX + 1
    177  70d0					      REPEND
    178  70d1		       16		      .byte.b	(.SQBASE+.SQX)
    179  70d1				   .SQX       SET	.SQX + 1
    177  70d1					      REPEND
    178  70d2		       17		      .byte.b	(.SQBASE+.SQX)
    179  70d2				   .SQX       SET	.SQX + 1
    177  70d2					      REPEND
    178  70d3		       18		      .byte.b	(.SQBASE+.SQX)
    179  70d3				   .SQX       SET	.SQX + 1
    177  70d3					      REPEND
    178  70d4		       19		      .byte.b	(.SQBASE+.SQX)
    179  70d4				   .SQX       SET	.SQX + 1
    177  70d4					      REPEND
    178  70d5		       1a		      .byte.b	(.SQBASE+.SQX)
    179  70d5				   .SQX       SET	.SQX + 1
    177  70d5					      REPEND
    178  70d6		       1b		      .byte.b	(.SQBASE+.SQX)
    179  70d6				   .SQX       SET	.SQX + 1
    177  70d6					      REPEND
    178  70d7		       1c		      .byte.b	(.SQBASE+.SQX)
    179  70d7				   .SQX       SET	.SQX + 1
    180  70d8					      REPEND
    181  70d8				   .SQBASE    SET	.SQBASE - 10
    182  70d8					      REPEND
    183  70d8
    184  70d8
    185  70d8							;---------------------------------------------------------------------------------------------------
    186  70d8							; Vectors to the position value tables for each piece
    187  70d8
    188  70d8					      MAC	posval
    189  70d8					      .byte	0
    190  70d8					      .byte	{1}(PositionalValue_PAWN - 22)
    191  70d8					      .byte	{1}(PositionalValue_PAWN - 22)
    192  70d8					      .byte	{1}(PositionalValue_KNIGHT - 22)
    193  70d8					      .byte	{1}(PositionalValue_BISHOP - 22)
    194  70d8					      .byte	{1}(PositionalValue_ROOK - 22)
    195  70d8					      .byte	{1}(PositionalValue_QUEEN - 22)
    196  70d8					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
    197  70d8					      ENDM
    198  70d8
      0  70d8					      ALLOCATE	PosValVecLO, 8
      0  70d8					      OPTIONAL_PAGEBREAK	"Table", 8
     12  70d8					      LIST	ON
      0  70d8					      DEF	PosValVecLO
      1  70d8				   BANK_PosValVecLO SET	_CURRENT_BANK
      2  70d8				   PosValVecLO
      3  70d8				   TEMPORARY_VAR SET	Overlay
      4  70d8				   TEMPORARY_OFFSET SET	0
      5  70d8				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      6  70d8				   FUNCTION_NAME SET	PosValVecLO
      7  70d8					      SUBROUTINE
      0  70d8					      POSVAL	<
      1  70d8		       00		      .byte.b	0
      2  70d9		       d2		      .byte.b	<(PositionalValue_PAWN - 22)
      3  70da		       d2		      .byte.b	<(PositionalValue_PAWN - 22)
      4  70db		       72		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  70dc		       c2		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  70dd		       12		      .byte.b	<(PositionalValue_ROOK - 22)
      7  70de		       62		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  70df		       b2		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  70e0					      ALLOCATE	PosValVecHI, 8
      0  70e0					      OPTIONAL_PAGEBREAK	"Table", 8
     12  70e0					      LIST	ON
      0  70e0					      DEF	PosValVecHI
      1  70e0				   BANK_PosValVecHI SET	_CURRENT_BANK
      2  70e0				   PosValVecHI
      3  70e0				   TEMPORARY_VAR SET	Overlay
      4  70e0				   TEMPORARY_OFFSET SET	0
      5  70e0				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      6  70e0				   FUNCTION_NAME SET	PosValVecHI
      7  70e0					      SUBROUTINE
      0  70e0					      POSVAL	>
      1  70e0		       00		      .byte.b	0
      2  70e1		       f0		      .byte.b	>(PositionalValue_PAWN - 22)
      3  70e2		       f0		      .byte.b	>(PositionalValue_PAWN - 22)
      4  70e3		       f1		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  70e4		       f1		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  70e5		       f2		      .byte.b	>(PositionalValue_ROOK - 22)
      7  70e6		       f2		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  70e7		       f2		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
    203  70e8
    204  70e8		       00 32	   BZ	      =	50
    205  70e8
    206  70e8					      MAC	pval
    207  70e8					      .byte	BZ + {1}
    208  70e8					      .byte	BZ + {2}
    209  70e8					      .byte	BZ + {3}
    210  70e8					      .byte	BZ + {4}
    211  70e8					      .byte	BZ + {5}
    212  70e8					      .byte	BZ + {6}
    213  70e8					      .byte	BZ + {7}
    214  70e8					      .byte	BZ + {8}
    215  70e8					      .byte	BZ
    216  70e8					      .byte	BZ
    217  70e8					      ENDM		;{ 10 entries }
    218  70e8
    219  70e8							;---------------------------------------------------------------------------------------------------
    220  70e8
    221  70e8				   PositionalValue_PAWN
    222  70e8
      0  70e8					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  70e8		       32		      .byte.b	BZ + 0
      2  70e9		       32		      .byte.b	BZ + 0
      3  70ea		       32		      .byte.b	BZ + 0
      4  70eb		       32		      .byte.b	BZ + 0
      5  70ec		       32		      .byte.b	BZ + 0
      6  70ed		       32		      .byte.b	BZ + 0
      7  70ee		       32		      .byte.b	BZ + 0
      8  70ef		       32		      .byte.b	BZ + 0
      9  70f0		       32		      .byte.b	BZ
     10  70f1		       32		      .byte.b	BZ
      0  70f2					      PVAL	15, 10, 0, -20, -20, 0, 10, 15
      1  70f2		       41		      .byte.b	BZ + 15
      2  70f3		       3c		      .byte.b	BZ + 10
      3  70f4		       32		      .byte.b	BZ + 0
      4  70f5		       1e		      .byte.b	BZ + -20
      5  70f6		       1e		      .byte.b	BZ + -20
      6  70f7		       32		      .byte.b	BZ + 0
      7  70f8		       3c		      .byte.b	BZ + 10
      8  70f9		       41		      .byte.b	BZ + 15
      9  70fa		       32		      .byte.b	BZ
     10  70fb		       32		      .byte.b	BZ
      0  70fc					      PVAL	5, -5, -10, 0, 0, -10, -5, 5
      1  70fc		       37		      .byte.b	BZ + 5
      2  70fd		       2d		      .byte.b	BZ + -5
      3  70fe		       28		      .byte.b	BZ + -10
      4  70ff		       32		      .byte.b	BZ + 0
      5  7100		       32		      .byte.b	BZ + 0
      6  7101		       28		      .byte.b	BZ + -10
      7  7102		       2d		      .byte.b	BZ + -5
      8  7103		       37		      .byte.b	BZ + 5
      9  7104		       32		      .byte.b	BZ
     10  7105		       32		      .byte.b	BZ
      0  7106					      PVAL	0, 0, 0, 10, 40, 0, 0, 0
      1  7106		       32		      .byte.b	BZ + 0
      2  7107		       32		      .byte.b	BZ + 0
      3  7108		       32		      .byte.b	BZ + 0
      4  7109		       3c		      .byte.b	BZ + 10
      5  710a		       5a		      .byte.b	BZ + 40
      6  710b		       32		      .byte.b	BZ + 0
      7  710c		       32		      .byte.b	BZ + 0
      8  710d		       32		      .byte.b	BZ + 0
      9  710e		       32		      .byte.b	BZ
     10  710f		       32		      .byte.b	BZ
      0  7110					      PVAL	15, 15, 20, 20, 50, 20, 15, 15
      1  7110		       41		      .byte.b	BZ + 15
      2  7111		       41		      .byte.b	BZ + 15
      3  7112		       46		      .byte.b	BZ + 20
      4  7113		       46		      .byte.b	BZ + 20
      5  7114		       64		      .byte.b	BZ + 50
      6  7115		       46		      .byte.b	BZ + 20
      7  7116		       41		      .byte.b	BZ + 15
      8  7117		       41		      .byte.b	BZ + 15
      9  7118		       32		      .byte.b	BZ
     10  7119		       32		      .byte.b	BZ
      0  711a					      PVAL	30, 30, 40, 50, 50, 40, 30, 30
      1  711a		       50		      .byte.b	BZ + 30
      2  711b		       50		      .byte.b	BZ + 30
      3  711c		       5a		      .byte.b	BZ + 40
      4  711d		       64		      .byte.b	BZ + 50
      5  711e		       64		      .byte.b	BZ + 50
      6  711f		       5a		      .byte.b	BZ + 40
      7  7120		       50		      .byte.b	BZ + 30
      8  7121		       50		      .byte.b	BZ + 30
      9  7122		       32		      .byte.b	BZ
     10  7123		       32		      .byte.b	BZ
      0  7124					      PVAL	40, 50, 60, 70, 70, 60, 50, 40
      1  7124		       5a		      .byte.b	BZ + 40
      2  7125		       64		      .byte.b	BZ + 50
      3  7126		       6e		      .byte.b	BZ + 60
      4  7127		       78		      .byte.b	BZ + 70
      5  7128		       78		      .byte.b	BZ + 70
      6  7129		       6e		      .byte.b	BZ + 60
      7  712a		       64		      .byte.b	BZ + 50
      8  712b		       5a		      .byte.b	BZ + 40
      9  712c		       32		      .byte.b	BZ
     10  712d		       32		      .byte.b	BZ
      0  712e					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  712e		       32		      .byte.b	BZ + 0
      2  712f		       32		      .byte.b	BZ + 0
      3  7130		       32		      .byte.b	BZ + 0
      4  7131		       32		      .byte.b	BZ + 0
      5  7132		       32		      .byte.b	BZ + 0
      6  7133		       32		      .byte.b	BZ + 0
      7  7134		       32		      .byte.b	BZ + 0
      8  7135		       32		      .byte.b	BZ + 0
      9  7136		       32		      .byte.b	BZ
     10  7137		       32		      .byte.b	BZ
    231  7138
    232  7138				   PositionalValue_PAWN_BLACK
    233  7138
      0  7138					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  7138		       32		      .byte.b	BZ + 0
      2  7139		       32		      .byte.b	BZ + 0
      3  713a		       32		      .byte.b	BZ + 0
      4  713b		       32		      .byte.b	BZ + 0
      5  713c		       32		      .byte.b	BZ + 0
      6  713d		       32		      .byte.b	BZ + 0
      7  713e		       32		      .byte.b	BZ + 0
      8  713f		       32		      .byte.b	BZ + 0
      9  7140		       32		      .byte.b	BZ
     10  7141		       32		      .byte.b	BZ
      0  7142					      PVAL	40, 50, 60, 70, 70, 60, 60, 40
      1  7142		       5a		      .byte.b	BZ + 40
      2  7143		       64		      .byte.b	BZ + 50
      3  7144		       6e		      .byte.b	BZ + 60
      4  7145		       78		      .byte.b	BZ + 70
      5  7146		       78		      .byte.b	BZ + 70
      6  7147		       6e		      .byte.b	BZ + 60
      7  7148		       6e		      .byte.b	BZ + 60
      8  7149		       5a		      .byte.b	BZ + 40
      9  714a		       32		      .byte.b	BZ
     10  714b		       32		      .byte.b	BZ
      0  714c					      PVAL	30, 30, 40, 50, 50, 40, 30, 30
      1  714c		       50		      .byte.b	BZ + 30
      2  714d		       50		      .byte.b	BZ + 30
      3  714e		       5a		      .byte.b	BZ + 40
      4  714f		       64		      .byte.b	BZ + 50
      5  7150		       64		      .byte.b	BZ + 50
      6  7151		       5a		      .byte.b	BZ + 40
      7  7152		       50		      .byte.b	BZ + 30
      8  7153		       50		      .byte.b	BZ + 30
      9  7154		       32		      .byte.b	BZ
     10  7155		       32		      .byte.b	BZ
      0  7156					      PVAL	15, 15, 10, 20, 20, 20, 15, 15
      1  7156		       41		      .byte.b	BZ + 15
      2  7157		       41		      .byte.b	BZ + 15
      3  7158		       3c		      .byte.b	BZ + 10
      4  7159		       46		      .byte.b	BZ + 20
      5  715a		       46		      .byte.b	BZ + 20
      6  715b		       46		      .byte.b	BZ + 20
      7  715c		       41		      .byte.b	BZ + 15
      8  715d		       41		      .byte.b	BZ + 15
      9  715e		       32		      .byte.b	BZ
     10  715f		       32		      .byte.b	BZ
      0  7160					      PVAL	0, 0, 0, 10, 10, 0, 0, 0
      1  7160		       32		      .byte.b	BZ + 0
      2  7161		       32		      .byte.b	BZ + 0
      3  7162		       32		      .byte.b	BZ + 0
      4  7163		       3c		      .byte.b	BZ + 10
      5  7164		       3c		      .byte.b	BZ + 10
      6  7165		       32		      .byte.b	BZ + 0
      7  7166		       32		      .byte.b	BZ + 0
      8  7167		       32		      .byte.b	BZ + 0
      9  7168		       32		      .byte.b	BZ
     10  7169		       32		      .byte.b	BZ
      0  716a					      PVAL	5, -5, -10, 0, 0, -10, -5, 5
      1  716a		       37		      .byte.b	BZ + 5
      2  716b		       2d		      .byte.b	BZ + -5
      3  716c		       28		      .byte.b	BZ + -10
      4  716d		       32		      .byte.b	BZ + 0
      5  716e		       32		      .byte.b	BZ + 0
      6  716f		       28		      .byte.b	BZ + -10
      7  7170		       2d		      .byte.b	BZ + -5
      8  7171		       37		      .byte.b	BZ + 5
      9  7172		       32		      .byte.b	BZ
     10  7173		       32		      .byte.b	BZ
      0  7174					      PVAL	15, 10, 0, -20, -20, 0, 10, 15
      1  7174		       41		      .byte.b	BZ + 15
      2  7175		       3c		      .byte.b	BZ + 10
      3  7176		       32		      .byte.b	BZ + 0
      4  7177		       1e		      .byte.b	BZ + -20
      5  7178		       1e		      .byte.b	BZ + -20
      6  7179		       32		      .byte.b	BZ + 0
      7  717a		       3c		      .byte.b	BZ + 10
      8  717b		       41		      .byte.b	BZ + 15
      9  717c		       32		      .byte.b	BZ
     10  717d		       32		      .byte.b	BZ
      0  717e					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  717e		       32		      .byte.b	BZ + 0
      2  717f		       32		      .byte.b	BZ + 0
      3  7180		       32		      .byte.b	BZ + 0
      4  7181		       32		      .byte.b	BZ + 0
      5  7182		       32		      .byte.b	BZ + 0
      6  7183		       32		      .byte.b	BZ + 0
      7  7184		       32		      .byte.b	BZ + 0
      8  7185		       32		      .byte.b	BZ + 0
      9  7186		       32		      .byte.b	BZ
     10  7187		       32		      .byte.b	BZ
    242  7188
    243  7188							;---------------------------------------------------------------------------------------------------
    244  7188
    245  7188				   PositionalValue_KNIGHT
    246  7188
      0  7188					      PVAL	-50, -40, -30, -30, -30, -30, -40, -50
      1  7188		       00		      .byte.b	BZ + -50
      2  7189		       0a		      .byte.b	BZ + -40
      3  718a		       14		      .byte.b	BZ + -30
      4  718b		       14		      .byte.b	BZ + -30
      5  718c		       14		      .byte.b	BZ + -30
      6  718d		       14		      .byte.b	BZ + -30
      7  718e		       0a		      .byte.b	BZ + -40
      8  718f		       00		      .byte.b	BZ + -50
      9  7190		       32		      .byte.b	BZ
     10  7191		       32		      .byte.b	BZ
      0  7192					      PVAL	-40, -20, 0, 5, 5, 0, -20, -40
      1  7192		       0a		      .byte.b	BZ + -40
      2  7193		       1e		      .byte.b	BZ + -20
      3  7194		       32		      .byte.b	BZ + 0
      4  7195		       37		      .byte.b	BZ + 5
      5  7196		       37		      .byte.b	BZ + 5
      6  7197		       32		      .byte.b	BZ + 0
      7  7198		       1e		      .byte.b	BZ + -20
      8  7199		       0a		      .byte.b	BZ + -40
      9  719a		       32		      .byte.b	BZ
     10  719b		       32		      .byte.b	BZ
      0  719c					      PVAL	-30, 0, 20, 15, 15, 20, 0, -30
      1  719c		       14		      .byte.b	BZ + -30
      2  719d		       32		      .byte.b	BZ + 0
      3  719e		       46		      .byte.b	BZ + 20
      4  719f		       41		      .byte.b	BZ + 15
      5  71a0		       41		      .byte.b	BZ + 15
      6  71a1		       46		      .byte.b	BZ + 20
      7  71a2		       32		      .byte.b	BZ + 0
      8  71a3		       14		      .byte.b	BZ + -30
      9  71a4		       32		      .byte.b	BZ
     10  71a5		       32		      .byte.b	BZ
      0  71a6					      PVAL	-30, 0, 15, 50, 50, 15, 0, -30
      1  71a6		       14		      .byte.b	BZ + -30
      2  71a7		       32		      .byte.b	BZ + 0
      3  71a8		       41		      .byte.b	BZ + 15
      4  71a9		       64		      .byte.b	BZ + 50
      5  71aa		       64		      .byte.b	BZ + 50
      6  71ab		       41		      .byte.b	BZ + 15
      7  71ac		       32		      .byte.b	BZ + 0
      8  71ad		       14		      .byte.b	BZ + -30
      9  71ae		       32		      .byte.b	BZ
     10  71af		       32		      .byte.b	BZ
      0  71b0					      PVAL	-30, 5, 15, 50, 50, 15, 5, -30
      1  71b0		       14		      .byte.b	BZ + -30
      2  71b1		       37		      .byte.b	BZ + 5
      3  71b2		       41		      .byte.b	BZ + 15
      4  71b3		       64		      .byte.b	BZ + 50
      5  71b4		       64		      .byte.b	BZ + 50
      6  71b5		       41		      .byte.b	BZ + 15
      7  71b6		       37		      .byte.b	BZ + 5
      8  71b7		       14		      .byte.b	BZ + -30
      9  71b8		       32		      .byte.b	BZ
     10  71b9		       32		      .byte.b	BZ
      0  71ba					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      1  71ba		       14		      .byte.b	BZ + -30
      2  71bb		       32		      .byte.b	BZ + 0
      3  71bc		       3c		      .byte.b	BZ + 10
      4  71bd		       41		      .byte.b	BZ + 15
      5  71be		       41		      .byte.b	BZ + 15
      6  71bf		       3c		      .byte.b	BZ + 10
      7  71c0		       32		      .byte.b	BZ + 0
      8  71c1		       14		      .byte.b	BZ + -30
      9  71c2		       32		      .byte.b	BZ
     10  71c3		       32		      .byte.b	BZ
      0  71c4					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      1  71c4		       0a		      .byte.b	BZ + -40
      2  71c5		       1e		      .byte.b	BZ + -20
      3  71c6		       50		      .byte.b	BZ + 30
      4  71c7		       32		      .byte.b	BZ + 0
      5  71c8		       32		      .byte.b	BZ + 0
      6  71c9		       50		      .byte.b	BZ + 30
      7  71ca		       1e		      .byte.b	BZ + -20
      8  71cb		       0a		      .byte.b	BZ + -40
      9  71cc		       32		      .byte.b	BZ
     10  71cd		       32		      .byte.b	BZ
      0  71ce					      PVAL	-50, -40, -30, -30, -30, -30, -40, -50
      1  71ce		       00		      .byte.b	BZ + -50
      2  71cf		       0a		      .byte.b	BZ + -40
      3  71d0		       14		      .byte.b	BZ + -30
      4  71d1		       14		      .byte.b	BZ + -30
      5  71d2		       14		      .byte.b	BZ + -30
      6  71d3		       14		      .byte.b	BZ + -30
      7  71d4		       0a		      .byte.b	BZ + -40
      8  71d5		       00		      .byte.b	BZ + -50
      9  71d6		       32		      .byte.b	BZ
     10  71d7		       32		      .byte.b	BZ
    255  71d8
    256  71d8
    257  71d8							;---------------------------------------------------------------------------------------------------
    258  71d8
    259  71d8				   PositionalValue_BISHOP
    260  71d8
      0  71d8					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      1  71d8		       1e		      .byte.b	BZ + -20
      2  71d9		       28		      .byte.b	BZ + -10
      3  71da		       00		      .byte.b	BZ + -50
      4  71db		       28		      .byte.b	BZ + -10
      5  71dc		       28		      .byte.b	BZ + -10
      6  71dd		       00		      .byte.b	BZ + -50
      7  71de		       28		      .byte.b	BZ + -10
      8  71df		       1e		      .byte.b	BZ + -20
      9  71e0		       32		      .byte.b	BZ
     10  71e1		       32		      .byte.b	BZ
      0  71e2					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      1  71e2		       28		      .byte.b	BZ + -10
      2  71e3		       37		      .byte.b	BZ + 5
      3  71e4		       32		      .byte.b	BZ + 0
      4  71e5		       32		      .byte.b	BZ + 0
      5  71e6		       32		      .byte.b	BZ + 0
      6  71e7		       32		      .byte.b	BZ + 0
      7  71e8		       37		      .byte.b	BZ + 5
      8  71e9		       28		      .byte.b	BZ + -10
      9  71ea		       32		      .byte.b	BZ
     10  71eb		       32		      .byte.b	BZ
      0  71ec					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      1  71ec		       28		      .byte.b	BZ + -10
      2  71ed		       3c		      .byte.b	BZ + 10
      3  71ee		       3c		      .byte.b	BZ + 10
      4  71ef		       3c		      .byte.b	BZ + 10
      5  71f0		       3c		      .byte.b	BZ + 10
      6  71f1		       3c		      .byte.b	BZ + 10
      7  71f2		       3c		      .byte.b	BZ + 10
      8  71f3		       28		      .byte.b	BZ + -10
      9  71f4		       32		      .byte.b	BZ
     10  71f5		       32		      .byte.b	BZ
      0  71f6					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      1  71f6		       28		      .byte.b	BZ + -10
      2  71f7		       32		      .byte.b	BZ + 0
      3  71f8		       3c		      .byte.b	BZ + 10
      4  71f9		       46		      .byte.b	BZ + 20
      5  71fa		       46		      .byte.b	BZ + 20
      6  71fb		       3c		      .byte.b	BZ + 10
      7  71fc		       32		      .byte.b	BZ + 0
      8  71fd		       28		      .byte.b	BZ + -10
      9  71fe		       32		      .byte.b	BZ
     10  71ff		       32		      .byte.b	BZ
      0  7200					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      1  7200		       28		      .byte.b	BZ + -10
      2  7201		       37		      .byte.b	BZ + 5
      3  7202		       37		      .byte.b	BZ + 5
      4  7203		       46		      .byte.b	BZ + 20
      5  7204		       46		      .byte.b	BZ + 20
      6  7205		       37		      .byte.b	BZ + 5
      7  7206		       37		      .byte.b	BZ + 5
      8  7207		       28		      .byte.b	BZ + -10
      9  7208		       32		      .byte.b	BZ
     10  7209		       32		      .byte.b	BZ
      0  720a					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      1  720a		       28		      .byte.b	BZ + -10
      2  720b		       32		      .byte.b	BZ + 0
      3  720c		       37		      .byte.b	BZ + 5
      4  720d		       3c		      .byte.b	BZ + 10
      5  720e		       3c		      .byte.b	BZ + 10
      6  720f		       37		      .byte.b	BZ + 5
      7  7210		       32		      .byte.b	BZ + 0
      8  7211		       28		      .byte.b	BZ + -10
      9  7212		       32		      .byte.b	BZ
     10  7213		       32		      .byte.b	BZ
      0  7214					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  7214		       28		      .byte.b	BZ + -10
      2  7215		       32		      .byte.b	BZ + 0
      3  7216		       32		      .byte.b	BZ + 0
      4  7217		       32		      .byte.b	BZ + 0
      5  7218		       32		      .byte.b	BZ + 0
      6  7219		       32		      .byte.b	BZ + 0
      7  721a		       32		      .byte.b	BZ + 0
      8  721b		       28		      .byte.b	BZ + -10
      9  721c		       32		      .byte.b	BZ
     10  721d		       32		      .byte.b	BZ
      0  721e					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      1  721e		       1e		      .byte.b	BZ + -20
      2  721f		       28		      .byte.b	BZ + -10
      3  7220		       28		      .byte.b	BZ + -10
      4  7221		       28		      .byte.b	BZ + -10
      5  7222		       28		      .byte.b	BZ + -10
      6  7223		       28		      .byte.b	BZ + -10
      7  7224		       28		      .byte.b	BZ + -10
      8  7225		       1e		      .byte.b	BZ + -20
      9  7226		       32		      .byte.b	BZ
     10  7227		       32		      .byte.b	BZ
    269  7228
    270  7228
    271  7228							;---------------------------------------------------------------------------------------------------
    272  7228
    273  7228				   PositionalValue_ROOK
    274  7228
      0  7228					      PVAL	-120, -10, 10, 25, 25, 10, -10, -200
      1  7228		       ba		      .byte.b	BZ + -120
      2  7229		       28		      .byte.b	BZ + -10
      3  722a		       3c		      .byte.b	BZ + 10
      4  722b		       4b		      .byte.b	BZ + 25
      5  722c		       4b		      .byte.b	BZ + 25
      6  722d		       3c		      .byte.b	BZ + 10
      7  722e		       28		      .byte.b	BZ + -10
      8  722f		       6a		      .byte.b	BZ + -200
      9  7230		       32		      .byte.b	BZ
     10  7231		       32		      .byte.b	BZ
      0  7232					      PVAL	-75, 0, 0, 0, 0, 0, 0, -200
      1  7232		       e7		      .byte.b	BZ + -75
      2  7233		       32		      .byte.b	BZ + 0
      3  7234		       32		      .byte.b	BZ + 0
      4  7235		       32		      .byte.b	BZ + 0
      5  7236		       32		      .byte.b	BZ + 0
      6  7237		       32		      .byte.b	BZ + 0
      7  7238		       32		      .byte.b	BZ + 0
      8  7239		       6a		      .byte.b	BZ + -200
      9  723a		       32		      .byte.b	BZ
     10  723b		       32		      .byte.b	BZ
      0  723c					      PVAL	-75, 0, 0, 0, 0, 0, 0, -150
      1  723c		       e7		      .byte.b	BZ + -75
      2  723d		       32		      .byte.b	BZ + 0
      3  723e		       32		      .byte.b	BZ + 0
      4  723f		       32		      .byte.b	BZ + 0
      5  7240		       32		      .byte.b	BZ + 0
      6  7241		       32		      .byte.b	BZ + 0
      7  7242		       32		      .byte.b	BZ + 0
      8  7243		       9c		      .byte.b	BZ + -150
      9  7244		       32		      .byte.b	BZ
     10  7245		       32		      .byte.b	BZ
      0  7246					      PVAL	-50, 0, 0, 0, 0, 0, 0, -100
      1  7246		       00		      .byte.b	BZ + -50
      2  7247		       32		      .byte.b	BZ + 0
      3  7248		       32		      .byte.b	BZ + 0
      4  7249		       32		      .byte.b	BZ + 0
      5  724a		       32		      .byte.b	BZ + 0
      6  724b		       32		      .byte.b	BZ + 0
      7  724c		       32		      .byte.b	BZ + 0
      8  724d		       ce		      .byte.b	BZ + -100
      9  724e		       32		      .byte.b	BZ
     10  724f		       32		      .byte.b	BZ
      0  7250					      PVAL	-5, 0, 0, 0, 0, 0, 0, -50
      1  7250		       2d		      .byte.b	BZ + -5
      2  7251		       32		      .byte.b	BZ + 0
      3  7252		       32		      .byte.b	BZ + 0
      4  7253		       32		      .byte.b	BZ + 0
      5  7254		       32		      .byte.b	BZ + 0
      6  7255		       32		      .byte.b	BZ + 0
      7  7256		       32		      .byte.b	BZ + 0
      8  7257		       00		      .byte.b	BZ + -50
      9  7258		       32		      .byte.b	BZ
     10  7259		       32		      .byte.b	BZ
      0  725a					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      1  725a		       2d		      .byte.b	BZ + -5
      2  725b		       32		      .byte.b	BZ + 0
      3  725c		       50		      .byte.b	BZ + 30
      4  725d		       50		      .byte.b	BZ + 30
      5  725e		       50		      .byte.b	BZ + 30
      6  725f		       50		      .byte.b	BZ + 30
      7  7260		       32		      .byte.b	BZ + 0
      8  7261		       2d		      .byte.b	BZ + -5
      9  7262		       32		      .byte.b	BZ
     10  7263		       32		      .byte.b	BZ
      0  7264					      PVAL	5, 10, 50, 50, 50, 50, 10, 5
      1  7264		       37		      .byte.b	BZ + 5
      2  7265		       3c		      .byte.b	BZ + 10
      3  7266		       64		      .byte.b	BZ + 50
      4  7267		       64		      .byte.b	BZ + 50
      5  7268		       64		      .byte.b	BZ + 50
      6  7269		       64		      .byte.b	BZ + 50
      7  726a		       3c		      .byte.b	BZ + 10
      8  726b		       37		      .byte.b	BZ + 5
      9  726c		       32		      .byte.b	BZ
     10  726d		       32		      .byte.b	BZ
      0  726e					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  726e		       32		      .byte.b	BZ + 0
      2  726f		       32		      .byte.b	BZ + 0
      3  7270		       32		      .byte.b	BZ + 0
      4  7271		       32		      .byte.b	BZ + 0
      5  7272		       32		      .byte.b	BZ + 0
      6  7273		       32		      .byte.b	BZ + 0
      7  7274		       32		      .byte.b	BZ + 0
      8  7275		       32		      .byte.b	BZ + 0
      9  7276		       32		      .byte.b	BZ
     10  7277		       32		      .byte.b	BZ
    283  7278
    284  7278
    285  7278							;---------------------------------------------------------------------------------------------------
    286  7278
    287  7278				   PositionalValue_QUEEN
    288  7278
      0  7278					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      1  7278		       1e		      .byte.b	BZ + -20
      2  7279		       28		      .byte.b	BZ + -10
      3  727a		       2d		      .byte.b	BZ + -5
      4  727b		       2d		      .byte.b	BZ + -5
      5  727c		       2d		      .byte.b	BZ + -5
      6  727d		       28		      .byte.b	BZ + -10
      7  727e		       28		      .byte.b	BZ + -10
      8  727f		       1e		      .byte.b	BZ + -20
      9  7280		       32		      .byte.b	BZ
     10  7281		       32		      .byte.b	BZ
      0  7282					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      1  7282		       28		      .byte.b	BZ + -10
      2  7283		       32		      .byte.b	BZ + 0
      3  7284		       37		      .byte.b	BZ + 5
      4  7285		       32		      .byte.b	BZ + 0
      5  7286		       32		      .byte.b	BZ + 0
      6  7287		       32		      .byte.b	BZ + 0
      7  7288		       32		      .byte.b	BZ + 0
      8  7289		       28		      .byte.b	BZ + -10
      9  728a		       32		      .byte.b	BZ
     10  728b		       32		      .byte.b	BZ
      0  728c					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      1  728c		       28		      .byte.b	BZ + -10
      2  728d		       37		      .byte.b	BZ + 5
      3  728e		       37		      .byte.b	BZ + 5
      4  728f		       37		      .byte.b	BZ + 5
      5  7290		       37		      .byte.b	BZ + 5
      6  7291		       4b		      .byte.b	BZ + 25
      7  7292		       32		      .byte.b	BZ + 0
      8  7293		       28		      .byte.b	BZ + -10
      9  7294		       32		      .byte.b	BZ
     10  7295		       32		      .byte.b	BZ
      0  7296					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      1  7296		       28		      .byte.b	BZ + -10
      2  7297		       32		      .byte.b	BZ + 0
      3  7298		       37		      .byte.b	BZ + 5
      4  7299		       4b		      .byte.b	BZ + 25
      5  729a		       4b		      .byte.b	BZ + 25
      6  729b		       4b		      .byte.b	BZ + 25
      7  729c		       32		      .byte.b	BZ + 0
      8  729d		       28		      .byte.b	BZ + -10
      9  729e		       32		      .byte.b	BZ
     10  729f		       32		      .byte.b	BZ
      0  72a0					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      1  72a0		       2d		      .byte.b	BZ + -5
      2  72a1		       32		      .byte.b	BZ + 0
      3  72a2		       41		      .byte.b	BZ + 15
      4  72a3		       69		      .byte.b	BZ + 55
      5  72a4		       69		      .byte.b	BZ + 55
      6  72a5		       69		      .byte.b	BZ + 55
      7  72a6		       32		      .byte.b	BZ + 0
      8  72a7		       2d		      .byte.b	BZ + -5
      9  72a8		       32		      .byte.b	BZ
     10  72a9		       32		      .byte.b	BZ
      0  72aa					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      1  72aa		       28		      .byte.b	BZ + -10
      2  72ab		       32		      .byte.b	BZ + 0
      3  72ac		       4b		      .byte.b	BZ + 25
      4  72ad		       7d		      .byte.b	BZ + 75
      5  72ae		       7d		      .byte.b	BZ + 75
      6  72af		       7d		      .byte.b	BZ + 75
      7  72b0		       32		      .byte.b	BZ + 0
      8  72b1		       28		      .byte.b	BZ + -10
      9  72b2		       32		      .byte.b	BZ
     10  72b3		       32		      .byte.b	BZ
      0  72b4					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  72b4		       28		      .byte.b	BZ + -10
      2  72b5		       32		      .byte.b	BZ + 0
      3  72b6		       32		      .byte.b	BZ + 0
      4  72b7		       32		      .byte.b	BZ + 0
      5  72b8		       32		      .byte.b	BZ + 0
      6  72b9		       32		      .byte.b	BZ + 0
      7  72ba		       32		      .byte.b	BZ + 0
      8  72bb		       28		      .byte.b	BZ + -10
      9  72bc		       32		      .byte.b	BZ
     10  72bd		       32		      .byte.b	BZ
      0  72be					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      1  72be		       1e		      .byte.b	BZ + -20
      2  72bf		       28		      .byte.b	BZ + -10
      3  72c0		       28		      .byte.b	BZ + -10
      4  72c1		       2d		      .byte.b	BZ + -5
      5  72c2		       2d		      .byte.b	BZ + -5
      6  72c3		       28		      .byte.b	BZ + -10
      7  72c4		       28		      .byte.b	BZ + -10
      8  72c5		       1e		      .byte.b	BZ + -20
      9  72c6		       32		      .byte.b	BZ
     10  72c7		       32		      .byte.b	BZ
    297  72c8
    298  72c8
    299  72c8							;---------------------------------------------------------------------------------------------------
    300  72c8
    301  72c8				   PositionalValue_KING_MIDGAME
    302  72c8
      0  72c8					      PVAL	0, 0, 30, -20, 0, 10, 40, 10
      1  72c8		       32		      .byte.b	BZ + 0
      2  72c9		       32		      .byte.b	BZ + 0
      3  72ca		       50		      .byte.b	BZ + 30
      4  72cb		       1e		      .byte.b	BZ + -20
      5  72cc		       32		      .byte.b	BZ + 0
      6  72cd		       3c		      .byte.b	BZ + 10
      7  72ce		       5a		      .byte.b	BZ + 40
      8  72cf		       3c		      .byte.b	BZ + 10
      9  72d0		       32		      .byte.b	BZ
     10  72d1		       32		      .byte.b	BZ
      0  72d2					      PVAL	20, 20, 0, -10, -10, 0, 20, 20
      1  72d2		       46		      .byte.b	BZ + 20
      2  72d3		       46		      .byte.b	BZ + 20
      3  72d4		       32		      .byte.b	BZ + 0
      4  72d5		       28		      .byte.b	BZ + -10
      5  72d6		       28		      .byte.b	BZ + -10
      6  72d7		       32		      .byte.b	BZ + 0
      7  72d8		       46		      .byte.b	BZ + 20
      8  72d9		       46		      .byte.b	BZ + 20
      9  72da		       32		      .byte.b	BZ
     10  72db		       32		      .byte.b	BZ
      0  72dc					      PVAL	-10, -20, -20, -20, -20, -20, -20, -10
      1  72dc		       28		      .byte.b	BZ + -10
      2  72dd		       1e		      .byte.b	BZ + -20
      3  72de		       1e		      .byte.b	BZ + -20
      4  72df		       1e		      .byte.b	BZ + -20
      5  72e0		       1e		      .byte.b	BZ + -20
      6  72e1		       1e		      .byte.b	BZ + -20
      7  72e2		       1e		      .byte.b	BZ + -20
      8  72e3		       28		      .byte.b	BZ + -10
      9  72e4		       32		      .byte.b	BZ
     10  72e5		       32		      .byte.b	BZ
      0  72e6					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      1  72e6		       1e		      .byte.b	BZ + -20
      2  72e7		       14		      .byte.b	BZ + -30
      3  72e8		       14		      .byte.b	BZ + -30
      4  72e9		       0a		      .byte.b	BZ + -40
      5  72ea		       0a		      .byte.b	BZ + -40
      6  72eb		       14		      .byte.b	BZ + -30
      7  72ec		       14		      .byte.b	BZ + -30
      8  72ed		       1e		      .byte.b	BZ + -20
      9  72ee		       32		      .byte.b	BZ
     10  72ef		       32		      .byte.b	BZ
      0  72f0					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  72f0		       14		      .byte.b	BZ + -30
      2  72f1		       0a		      .byte.b	BZ + -40
      3  72f2		       0a		      .byte.b	BZ + -40
      4  72f3		       00		      .byte.b	BZ + -50
      5  72f4		       00		      .byte.b	BZ + -50
      6  72f5		       0a		      .byte.b	BZ + -40
      7  72f6		       0a		      .byte.b	BZ + -40
      8  72f7		       14		      .byte.b	BZ + -30
      9  72f8		       32		      .byte.b	BZ
     10  72f9		       32		      .byte.b	BZ
      0  72fa					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  72fa		       14		      .byte.b	BZ + -30
      2  72fb		       0a		      .byte.b	BZ + -40
      3  72fc		       0a		      .byte.b	BZ + -40
      4  72fd		       00		      .byte.b	BZ + -50
      5  72fe		       00		      .byte.b	BZ + -50
      6  72ff		       0a		      .byte.b	BZ + -40
      7  7300		       0a		      .byte.b	BZ + -40
      8  7301		       14		      .byte.b	BZ + -30
      9  7302		       32		      .byte.b	BZ
     10  7303		       32		      .byte.b	BZ
      0  7304					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  7304		       14		      .byte.b	BZ + -30
      2  7305		       0a		      .byte.b	BZ + -40
      3  7306		       0a		      .byte.b	BZ + -40
      4  7307		       00		      .byte.b	BZ + -50
      5  7308		       00		      .byte.b	BZ + -50
      6  7309		       0a		      .byte.b	BZ + -40
      7  730a		       0a		      .byte.b	BZ + -40
      8  730b		       14		      .byte.b	BZ + -30
      9  730c		       32		      .byte.b	BZ
     10  730d		       32		      .byte.b	BZ
      0  730e					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  730e		       14		      .byte.b	BZ + -30
      2  730f		       0a		      .byte.b	BZ + -40
      3  7310		       0a		      .byte.b	BZ + -40
      4  7311		       00		      .byte.b	BZ + -50
      5  7312		       00		      .byte.b	BZ + -50
      6  7313		       0a		      .byte.b	BZ + -40
      7  7314		       0a		      .byte.b	BZ + -40
      8  7315		       14		      .byte.b	BZ + -30
      9  7316		       32		      .byte.b	BZ
     10  7317		       32		      .byte.b	BZ
    311  7318
    312  7318
    313  7318							;---------------------------------------------------------------------------------------------------
    314  7318
    315  7318				   PositionalValue_KING_ENDGAME
    316  7318
      0  7318					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      1  7318		       00		      .byte.b	BZ + -50
      2  7319		       14		      .byte.b	BZ + -30
      3  731a		       14		      .byte.b	BZ + -30
      4  731b		       14		      .byte.b	BZ + -30
      5  731c		       14		      .byte.b	BZ + -30
      6  731d		       14		      .byte.b	BZ + -30
      7  731e		       14		      .byte.b	BZ + -30
      8  731f		       00		      .byte.b	BZ + -50
      9  7320		       32		      .byte.b	BZ
     10  7321		       32		      .byte.b	BZ
      0  7322					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      1  7322		       14		      .byte.b	BZ + -30
      2  7323		       14		      .byte.b	BZ + -30
      3  7324		       32		      .byte.b	BZ + 0
      4  7325		       32		      .byte.b	BZ + 0
      5  7326		       32		      .byte.b	BZ + 0
      6  7327		       32		      .byte.b	BZ + 0
      7  7328		       14		      .byte.b	BZ + -30
      8  7329		       14		      .byte.b	BZ + -30
      9  732a		       32		      .byte.b	BZ
     10  732b		       32		      .byte.b	BZ
      0  732c					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  732c		       14		      .byte.b	BZ + -30
      2  732d		       28		      .byte.b	BZ + -10
      3  732e		       46		      .byte.b	BZ + 20
      4  732f		       50		      .byte.b	BZ + 30
      5  7330		       50		      .byte.b	BZ + 30
      6  7331		       46		      .byte.b	BZ + 20
      7  7332		       28		      .byte.b	BZ + -10
      8  7333		       14		      .byte.b	BZ + -30
      9  7334		       32		      .byte.b	BZ
     10  7335		       32		      .byte.b	BZ
      0  7336					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  7336		       14		      .byte.b	BZ + -30
      2  7337		       28		      .byte.b	BZ + -10
      3  7338		       50		      .byte.b	BZ + 30
      4  7339		       5a		      .byte.b	BZ + 40
      5  733a		       5a		      .byte.b	BZ + 40
      6  733b		       50		      .byte.b	BZ + 30
      7  733c		       28		      .byte.b	BZ + -10
      8  733d		       14		      .byte.b	BZ + -30
      9  733e		       32		      .byte.b	BZ
     10  733f		       32		      .byte.b	BZ
      0  7340					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  7340		       14		      .byte.b	BZ + -30
      2  7341		       28		      .byte.b	BZ + -10
      3  7342		       50		      .byte.b	BZ + 30
      4  7343		       5a		      .byte.b	BZ + 40
      5  7344		       5a		      .byte.b	BZ + 40
      6  7345		       50		      .byte.b	BZ + 30
      7  7346		       28		      .byte.b	BZ + -10
      8  7347		       14		      .byte.b	BZ + -30
      9  7348		       32		      .byte.b	BZ
     10  7349		       32		      .byte.b	BZ
      0  734a					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  734a		       14		      .byte.b	BZ + -30
      2  734b		       28		      .byte.b	BZ + -10
      3  734c		       46		      .byte.b	BZ + 20
      4  734d		       50		      .byte.b	BZ + 30
      5  734e		       50		      .byte.b	BZ + 30
      6  734f		       46		      .byte.b	BZ + 20
      7  7350		       28		      .byte.b	BZ + -10
      8  7351		       14		      .byte.b	BZ + -30
      9  7352		       32		      .byte.b	BZ
     10  7353		       32		      .byte.b	BZ
      0  7354					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      1  7354		       14		      .byte.b	BZ + -30
      2  7355		       1e		      .byte.b	BZ + -20
      3  7356		       28		      .byte.b	BZ + -10
      4  7357		       32		      .byte.b	BZ + 0
      5  7358		       32		      .byte.b	BZ + 0
      6  7359		       28		      .byte.b	BZ + -10
      7  735a		       1e		      .byte.b	BZ + -20
      8  735b		       14		      .byte.b	BZ + -30
      9  735c		       32		      .byte.b	BZ
     10  735d		       32		      .byte.b	BZ
      0  735e					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      1  735e		       00		      .byte.b	BZ + -50
      2  735f		       0a		      .byte.b	BZ + -40
      3  7360		       14		      .byte.b	BZ + -30
      4  7361		       1e		      .byte.b	BZ + -20
      5  7362		       1e		      .byte.b	BZ + - 20
      6  7363		       14		      .byte.b	BZ + -30
      7  7364		       0a		      .byte.b	BZ + -40
      8  7365		       00		      .byte.b	BZ + -50
      9  7366		       32		      .byte.b	BZ
     10  7367		       32		      .byte.b	BZ
    325  7368
    326  7368
      0  7368					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  7368		       03 68	   .TEMP      =	* - BANK_START
 BANK_EVAL (2K) SIZE =  $368 , FREE= $498
      2  7368					      ECHO	"BANK_EVAL", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  7368				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  7368				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  7368				  -	      ERR
      6  7368					      ENDIF
      7  7368
    328  7368
    329  7368							;---------------------------------------------------------------------------------------------------
    330  7368							; EOF
------- FILE ./chess.asm
------- FILE BANK_SPEAK.asm LEVEL 2 PASS 5
      0  7368					      include	"BANK_SPEAK.asm"
      0  7368					      NEWBANK	SPEAK
      1  7876 ????				      SEG	SPEAK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   SPEAK      SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	SPEAK
      2  7800
      3  7800							;
      4  7800							; speakjet.inc
      5  7800							;
      6  7800							;
      7  7800							; AtariVox Speech Synth Driver
      8  7800							;
      9  7800							; By Alex Herbert, 2004
     10  7800							;
     11  7800
     12  7800
     13  7800
     14  7800
     15  7800							; Constants
     16  7800
     17  7800
     18  7800		       00 01	   SERIAL_OUTMASK equ	$01
     19  7800		       00 02	   SERIAL_RDYMASK equ	$02
     20  7800
     21  7800
     22  7800
     23  7800							;---------------------------------------------------------------------------------------------------
     24  7800
     25  7800					      mac	speak
     26  7800
     27  7800					      lda	#<{1}
     28  7800					      sta	speech_addr
     29  7800					      lda	#>{1}
     30  7800					      sta	speech_addr+1
     31  7800
     32  7800					      endm
     33  7800
     34  7800
     35  7800							;---------------------------------------------------------------------------------------------------
     36  7800
      0  7800					      DEF	ShutYourMouth
      1  7800				   BANK_ShutYourMouth SET	_CURRENT_BANK
      2  7800				   ShutYourMouth
      3  7800				   TEMPORARY_VAR SET	Overlay
      4  7800				   TEMPORARY_OFFSET SET	0
      5  7800				   VAR_BOUNDARY_ShutYourMouth SET	TEMPORARY_OFFSET
      6  7800				   FUNCTION_NAME SET	ShutYourMouth
      7  7800					      SUBROUTINE
     38  7800					      SUBROUTINE
     39  7800
      0  7800					      REFER	Reset
      1  7800				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  7800				  -TEMPORARY_VAR SET	VAREND_Reset
      3  7800					      ENDIF
      0  7800					      VEND	ShutYourMouth
      1  7800				  -	      IFNCONST	ShutYourMouth
      2  7800				  -	      ECHO	"Incorrect VEND label", ShutYourMouth
      3  7800				  -	      ERR
      4  7800					      ENDIF
      5  7800		       00 a7	   VAREND_ShutYourMouth =	TEMPORARY_VAR
     42  7800
      0  7800					      SPEAK	silence_speech
      1  7800
      2  7800		       a9 74		      lda	#<silence_speech
      3  7802		       85 9c		      sta	speech_addr
      4  7804		       a9 f0		      lda	#>silence_speech
      5  7806		       85 9d		      sta	speech_addr+1
      6  7808
     44  7808		       60		      rts
     45  7809
     46  7809
     47  7809							;---------------------------------------------------------------------------------------------------
     48  7809
      0  7809					      DEF	GameSpeak
      1  7809				   BANK_GameSpeak SET	_CURRENT_BANK
      2  7809				   GameSpeak
      3  7809				   TEMPORARY_VAR SET	Overlay
      4  7809				   TEMPORARY_OFFSET SET	0
      5  7809				   VAR_BOUNDARY_GameSpeak SET	TEMPORARY_OFFSET
      6  7809				   FUNCTION_NAME SET	GameSpeak
      7  7809					      SUBROUTINE
     50  7809					      SUBROUTINE
     51  7809
      0  7809					      REFER	Reset
      1  7809				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  7809				  -TEMPORARY_VAR SET	VAREND_Reset
      3  7809					      ENDIF
      0  7809					      VAR	__speak_temp, 1
      1  7809		       00 a7	   __speak_temp =	TEMPORARY_VAR
      2  7809				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7809
      4  7809				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7809				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7809				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7809					      ENDIF
      8  7809				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7809				  -	      ECHO	"Temporary Variable", __speak_temp, "overflow!"
     10  7809				  -	      ERR
     11  7809					      ENDIF
     12  7809					      LIST	ON
      0  7809					      VEND	GameSpeak
      1  7809				  -	      IFNCONST	GameSpeak
      2  7809				  -	      ECHO	"Incorrect VEND label", GameSpeak
      3  7809				  -	      ERR
      4  7809					      ENDIF
      5  7809		       00 a8	   VAREND_GameSpeak =	TEMPORARY_VAR
     55  7809
     56  7809		       a0 00		      ldy	#0
     57  780b		       b1 9c		      lda	(speech_addr),y
     58  780d		       c9 ff		      cmp	#$ff
     59  780f		       d0 08		      bne	.talk
     60  7811
      0  7811					      SPEAK	left_speech
      1  7811
      2  7811		       a9 4a		      lda	#<left_speech
      3  7813		       85 9c		      sta	speech_addr
      4  7815		       a9 f0		      lda	#>left_speech
      5  7817		       85 9d		      sta	speech_addr+1
      6  7819
     62  7819
     63  7819
     64  7819				   .talk
     65  7819
     66  7819							; check buffer-full status
     67  7819
     68  7819		       ad 80 02 	      lda	SWCHA
     69  781c		       29 02		      and	#SERIAL_RDYMASK
     70  781e		       f0 29		      beq	.speech_done
     71  7820
     72  7820		       a0 00		      ldy	#0
     73  7822		       b1 9c		      lda	(speech_addr),y
     74  7824
     75  7824		       49 ff		      eor	#$ff
     76  7826		       f0 21		      beq	.speech_done
     77  7828		       85 a7		      sta	__speak_temp
     78  782a
     79  782a		       e6 9c		      inc	speech_addr
     80  782c		       d0 02		      bne	.incaddr_skip
     81  782e		       e6 9d		      inc	speech_addr+1
     82  7830				   .incaddr_skip
     83  7830
     84  7830		       38		      sec		; start bit
     85  7831				   .byteout_loop
     86  7831
     87  7831							; put carry flag into bit 0 of SWACNT, perserving other bits
     88  7831
     89  7831		       ad 81 02 	      lda	SWACNT	; 4
     90  7834		       29 fe		      and	#$fe	; 2 6
     91  7836		       69 00		      adc	#$00	; 2 8
     92  7838		       8d 81 02 	      sta	SWACNT	; 4 12
     93  783b
     94  783b							; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
     95  783b
     96  783b		       c0 09		      cpy	#$09	; 2 14
     97  783d		       f0 0a		      beq	.speech_done	; 2 16
     98  783f		       c8		      iny		; 2 18
     99  7840
    100  7840
    101  7840		       a2 07		      ldx	#$07	; 2 20
    102  7842		       ca	   .delay_loop dex		; { 2
    103  7843		       d0 fd		      bne	.delay_loop	;   3
    104  7845							; } = 7 * 5 - 1 = 34
    105  7845							; @54
    106  7845
    107  7845		       46 a7		      lsr	__speak_temp	; 5 59
    108  7847		       10 e8		      bpl	.byteout_loop	; 3 62 cycles for loop
    109  7849
    110  7849		       60	   .speech_done rts
    111  784a
    112  784a
    113  784a							;---------------------------------------------------------------------------------------------------
    114  784a
    115  784a							; Speech Data
    116  784a
    117  784a							;Dec. SpeakJet Use
    118  784a							;----- ------------------
    119  784a							;000 Pause 0
    120  784a							;001 Pause 1
    121  784a							;002 Pause 2
    122  784a							;003 Pause 3
    123  784a							;004 Pause 4
    124  784a							;005 Pause 5
    125  784a							;006 Pause 6
    126  784a							;007 Play Next Sound Fast
    127  784a							;008 Play Next Sound Slow
    128  784a							;014 Play Next Sound High Tone
    129  784a							;015 Play Next Sound Low Tone
    130  784a							;016 Wait
    131  784a							;020 Volume, X
    132  784a							;021 Speed, X
    133  784a							;022 Pitch, X
    134  784a							;023 Bend, X
    135  784a							;024 PortCtr, X
    136  784a							;025 Port, X
    137  784a							;026 Repeat, X
    138  784a							;028 Call Phrase, X
    139  784a							;029 Goto Phrase, X
    140  784a							;030 Delay, X
    141  784a							;031 Reset Defaults
    142  784a							;--------------------------------------------------------
    143  784a							;032 Reserved
    144  784a							;- to -
    145  784a							;127
    146  784a							;--------------------------------------------------------
    147  784a							;128 127 Sound codes
    148  784a							;- to -
    149  784a							;254
    150  784a							;--------------------------------------------------------
    151  784a							;255 End of Phrase.
    152  784a
    153  784a
    154  784a
    155  784a				   left_speech
    156  784a
    157  784a
    158  784a		       1f		      dc.b	31
    159  784b							;	  dc.b $ff
    160  784b
    161  784b
    162  784b
    163  784b
    164  784b
    165  784b
    166  784b
    167  784b		       15 74		      dc.b	21,116	; speed 116
    168  784d		       17 04		      dc.b	23,4	; bend, 4
    169  784f		       16 37		      dc.b	22,55	; pitch, 55
    170  7851		       b6		      dc.b	182	;CH
    171  7852		       81		      dc.b	129	;IH
    172  7853		       c2		      dc.b	194	;KE
    173  7854		       83		      dc.b	131	;EH
    174  7855		       8d		      dc.b	141	;NE
    175  7856		       02		      dc.b	2	; pause 2
    176  7857		       02		      dc.b	2	; pause 2
    177  7858
    178  7858
    179  7858		       08		      dc.b	8	; play next sound slow
    180  7859		       ba		      dc.b	186	;FF
    181  785a		       07		      dc.b	7	; play fast
    182  785b		       9b		      dc.b	155	;OHIY
    183  785c		       04		      dc.b	4	; pause 4
    184  785d		       bf		      dc.b	191	;TT
    185  785e		       06		      dc.b	6	; pause 6
    186  785f		       91		      dc.b	145	;LE
    187  7860		       07		      dc.b	7	; fast
    188  7861		       88		      dc.b	136	;AW
    189  7862		       07		      dc.b	7	; fast
    190  7863		       9b		      dc.b	155	;OHIY
    191  7864		       c4		      dc.b	196	;EK
    192  7865		       06		      dc.b	6	; pause 6
    193  7866		       9a		      dc.b	154	;EYIY
    194  7867		       80		      dc.b	128	;IY
    195  7868		       06		      dc.b	6	; pause 6
    196  7869		       94		      dc.b	148	;GR?
    197  786a		       07		      dc.b	7	; fast
    198  786b		       89		      dc.b	137	;OW
    199  786c		       07		      dc.b	7	; fast
    200  786d		       a4		      dc.b	164	;OWW
    201  786e		       12		      dc.b	18	;???
    202  786f		       ab		      dc.b	171	;BO
    203  7870		       88		      dc.b	136	;AW
    204  7871		       bf		      dc.b	191	;TT
    205  7872		       1f		      dc.b	31	; reset defaults
    206  7873		       ff		      dc.b	$ff
    207  7874
    208  7874
    209  7874				   silence_speech
    210  7874
    211  7874
    212  7874
    213  7874		       1f		      dc.b	31	;31
    214  7875
    215  7875
    216  7875		       ff		      dc.b	$ff
    217  7876
      0  7876					      CHECK_BANK_SIZE	"BANK_SPEAK"
      1  7876		       00 76	   .TEMP      =	* - BANK_START
 BANK_SPEAK (2K) SIZE =  $76 , FREE= $78a
      2  7876					      ECHO	"BANK_SPEAK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  7876				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  7876				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  7876				  -	      ERR
      6  7876					      ENDIF
      7  7876
    219  7876
    220  7876				  -	      IF	0
    221  7876				  -typedef    enum
    222  7876				  -	      182
    223  7876				  -	      183	Pause0 = 0, ///< Pause 0ms
    224  7876				  -	      184	Pause1 = 1, ///< Pause 100ms
    225  7876				  -	      185	Pause2 = 2, ///< Pause 200ms
    226  7876				  -	      186	Pause3 = 3, ///< Pause 700ms
    227  7876				  -	      187	Pause4 = 4, ///< Pause 30ms
    228  7876				  -	      188	Pause5 = 5, ///< Pause 60ms
    229  7876				  -	      189	Pause6 = 6, ///< Pause 90ms
    230  7876				  -	      190	Fast = 7, ///< Next phoneme at 0.5 speed
    231  7876				  -	      191	Slow = 8, ///< Next phoneme at 1.5 speed
    232  7876				  -	      192	Stress = 14, ///< Next phoneme with some stress
    233  7876				  -	      193	Relax = 15, ///< Next phoneme with relaxation
    234  7876				  -	      194	Wait = 16, ///< Stops and waits for a Start (see manual)
    235  7876				  -	      195	Soft = 18, ///< Stops and waits for a Start (see manual)
    236  7876				  -	      196	Volume = 20, ///< Next octet is volume 0 to 127. Default 96
    237  7876				  -	      197	Speed = 21, ///< Next octet is speed 0 to 127. Default 114
    238  7876				  -	      198	Pitch = 22, ///< Next octet is pitch in Hz = to 255
    239  7876				  -	      199	Bend = 23, ///< Next octet is frequency bend to 15. Default is 5
    240  7876				  -	      200	PortCtr = 24, ///< Next octet is port control value. See manual. Default is 7
    241  7876				  -	      201	Port = 25, ///< Next octet is Port Output Value. See manual. Default is 0
    242  7876				  -	      202	Repeat = 26, ///< Next octet is repeat count. 0 to 255
    243  7876				  -	      203	CallPhrase = 28, ///< Next octet is EEPROM phrase to play and return. See manual.
    244  7876				  -	      204	GotoPhrase = 29, ///< Next octet is EEPROM phgrase to go to. See manual.
    245  7876				  -	      205	Delay = 30, ///< Next octet is delay in multiples of 10ms. 0 to 255.
    246  7876				  -	      206	Reset = 31, ///< Reset Volume Speed, Pitch, Bend to defaults.
    247  7876				  -	      207
    248  7876				  -	      208	// 32 to 127 reserved
    249  7876				  -	      209
    250  7876				  -	      210	// 128 to 254 Sound codes
    251  7876				  -	      211	// Phonemes, standard names
    252  7876				  -	      212	Phoneme_IY = 128, ///< 70ms Voiced Long Vowel
    253  7876				  -	      213	Phoneme_IH = 129, ///< 70ms Voiced Long Vowel
    254  7876				  -	      214	Phoneme_EY = 130, ///< 70ms Voiced Long Vowel
    255  7876				  -	      215	Phoneme_EH = 131, ///< 70ms Voiced Long Vowel
    256  7876				  -	      216	Phoneme_AY = 132, ///< 70ms Voiced Long Vowel
    257  7876				  -	      217	Phoneme_AX = 133, ///< 70ms Voiced Long Vowel
    258  7876				  -	      218	Phoneme_UX = 134, ///< 70ms Voiced Long Vowel
    259  7876				  -	      219	Phoneme_OH = 135, ///< 70ms Voiced Long Vowel
    260  7876				  -	      220	Phoneme_AW = 136, ///< 70ms Voiced Long Vowel
    261  7876				  -	      221	Phoneme_OW = 137, ///< 70ms Voiced Long Vowel
    262  7876				  -	      222	Phoneme_UH = 138, ///< 70ms Voiced Long Vowel
    263  7876				  -	      223	Phoneme_UW = 139, ///< 70ms Voiced Long Vowel
    264  7876				  -	      224	Phoneme_MM = 140, ///< 70ms Voiced Nasal
    265  7876				  -	      225	Phoneme_NE = 141, ///< 70ms Voiced Nasal
    266  7876				  -	      226	Phoneme_NO = 142, ///< 70ms Voiced Nasal
    267  7876				  -	      227	Phoneme_NGE = 143, ///< 70ms Voiced Nasal
    268  7876				  -	      228	Phoneme_NGO = 144, ///< 70ms Voiced Nasal
    269  7876				  -	      229	Phoneme_LE = 145, ///< 70ms Voiced Resonate
    270  7876				  -	      230	Phoneme_LO = 146, ///< 70ms Voiced Resonate
    271  7876				  -	      231	Phoneme_WW = 147, ///< 70ms Voiced Resonate
    272  7876				  -	      232	Phoneme_RR = 149, //148? ///< 70ms Voiced Resonate
    273  7876				  -	      233	Phoneme_IYRR = 149, ///< 200ms Voiced R Color Vowel
    274  7876				  -	      234	Phoneme_EYRR = 150, ///< 200ms Voiced R Color Vowel
    275  7876				  -	      235	Phoneme_AXRR = 151, ///< 190ms Voiced R Color Vowel
    276  7876				  -	      236	Phoneme_AWRR = 152, ///< 200ms Voiced R Color Vowel
    277  7876				  -	      237	Phoneme_OWRR = 153, ///< 185ms Voiced R Color Vowel
    278  7876				  -	      238	Phoneme_EYIY = 154, ///< 165ms Voiced Diphthong
    279  7876				  -	      239	Phoneme_OHIY = 155, ///< 200ms Voiced Diphthong
    280  7876				  -	      240	Phoneme_OWIY = 156, ///< 225ms Voiced Diphthong
    281  7876				  -	      241	Phoneme_OHIH = 157, ///< 185ms Voiced Diphthong
    282  7876				  -	      242	Phoneme_IYEH = 158, ///< 170ms Voiced Diphthong
    283  7876				  -	      243	Phoneme_EHLE = 159, ///< 140ms Voiced Diphthong
    284  7876				  -	      244	Phoneme_IYUW = 160, ///< 180ms Voiced Diphthong
    285  7876				  -	      245	Phoneme_AXUW = 161, ///< 170ms Voiced Diphthong
    286  7876				  -	      246	Phoneme_IHWW = 162, ///< 170ms Voiced Diphthong
    287  7876				  -	      247	Phoneme_AYWW = 163, ///< 200ms Voiced Diphthong
    288  7876				  -	      248	Phoneme_OWWW = 164, ///< 131ms Voiced Diphthong
    289  7876				  -	      249	Phoneme_JH = 165, ///< 70ms Voiced Affricate
    290  7876				  -	      250	Phoneme_VV = 166, ///< 70ms Voiced Fricative
    291  7876				  -	      251	Phoneme_ZZ = 167, ///< 70ms Voiced Fricative
    292  7876				  -	      252	Phoneme_ZH = 168, ///< 70ms Voiced Fricative
    293  7876				  -	      253	Phoneme_DH = 169, ///< 70ms Voiced Fricative
    294  7876				  -	      254	Phoneme_BE = 170, ///< 45ms Voiced Stop
    295  7876				  -	      255	Phoneme_BO = 171, ///< 45ms Voiced Stop
    296  7876				  -	      256	Phoneme_EB = 172, ///< 10ms Voiced Stop
    297  7876				  -	      257	Phoneme_OB = 173, ///< 10ms Voiced Stop
    298  7876				  -	      258	Phoneme_DE = 174, ///< 45ms Voiced Stop
    299  7876				  -	      259	Phoneme_DO = 174, ///< 45ms Voiced Stop
    300  7876				  -	      260	Phoneme_ED = 176, ///< 10ms Voiced Stop
    301  7876				  -	      261	Phoneme_OD = 177, ///< 10ms Voiced Stop
    302  7876				  -	      262	Phoneme_GE = 178, ///< 55ms Voiced Stop
    303  7876				  -	      263	Phoneme_GO = 179, ///< 55ms Voiced Stop
    304  7876				  -	      264	Phoneme_EG = 180, ///< 55ms Voiced Stop
    305  7876				  -	      265	Phoneme_OG = 181, ///< 55ms Voiced Stop
    306  7876				  -	      266	Phoneme_CH = 182, ///< 70ms Voiceless Affricate
    307  7876				  -	      267	Phoneme_HE = 183, ///< 70ms Voiceless Fricative
    308  7876				  -	      268	Phoneme_HO = 184, ///< 70ms Voiceless Fricative
    309  7876				  -	      269	Phoneme_WH = 185, ///< 70ms Voiceless Fricative
    310  7876				  -	      270	Phoneme_FF = 186, ///< 70ms Voiceless Fricative
    311  7876				  -	      271	Phoneme_SE = 187, ///< 40ms Voiceless Fricative
    312  7876				  -	      272	Phoneme_SO = 188, ///< 40ms Voiceless Fricative
    313  7876				  -	      273	Phoneme_SH = 189, ///< 50ms Voiceless Fricative
    314  7876				  -	      274	Phoneme_TH = 190, ///< 40ms Voiceless Fricative
    315  7876				  -	      275	Phoneme_TT = 191, ///< 50ms Voiceless Stop
    316  7876				  -	      276	Phoneme_TU = 192, ///< 70ms Voiceless Stop
    317  7876				  -	      277	Phoneme_TS = 193, ///< 170ms Voiceless Stop
    318  7876				  -	      278	Phoneme_KE = 194, ///< 55ms Voiceless Stop
    319  7876				  -	      279	Phoneme_KO = 195, ///< 55ms Voiceless Stop
    320  7876				  -	      280	Phoneme_EK = 196, ///< 55ms Voiceless Stop
    321  7876				  -	      281	Phoneme_OK = 197, ///< 45ms Voiceless Stop
    322  7876				  -	      282	Phoneme_PE = 198, ///< 99ms Voiceless Stop
    323  7876				  -	      283	Phoneme_PO = 199, ///< 99ms Voiceless Stop
    324  7876				  -	      284	// Robot sound
    325  7876				  -	      285	Sound_R0 = 200, ///< 80ms Robot
    326  7876				  -	      286	Sound_R1 = 201, ///< 80ms Robot
    327  7876				  -	      287	Sound_R2 = 202, ///< 80ms Robot
    328  7876				  -	      288	Sound_R3 = 203, ///< 80ms Robot
    329  7876				  -	      289	Sound_R4 = 204, ///< 80ms Robot
    330  7876				  -	      290	Sound_R5 = 205, ///< 80ms Robot
    331  7876				  -	      291	Sound_R6 = 206, ///< 80ms Robot
    332  7876				  -	      292	Sound_R7 = 207, ///< 80ms Robot
    333  7876				  -	      293	Sound_R8 = 208, ///< 80ms Robot
    334  7876				  -	      294	Sound_R9 = 209, ///< 80ms Robot
    335  7876				  -	      295	// Alarm sound
    336  7876				  -	      296	Sound_A0 = 210, ///< 300ms Alarm
    337  7876				  -	      297	Sound_A1 = 211, ///< 101ms Alarm
    338  7876				  -	      298	Sound_A2 = 212, ///< 102ms Alarm
    339  7876				  -	      299	Sound_A3 = 213, ///< 540ms Alarm
    340  7876				  -	      300	Sound_A4 = 214, ///< 530ms Alarm
    341  7876				  -	      301	Sound_A5 = 215, ///< 500ms Alarm
    342  7876				  -	      302	Sound_A6 = 216, ///< 135ms Alarm
    343  7876				  -	      303	Sound_A7 = 217, ///< 600ms Alarm
    344  7876				  -	      304	Sound_A8 = 218, ///< 300ms Alarm
    345  7876				  -	      305	Sound_A9 = 219, ///< 250ms Alarm
    346  7876				  -	      306	// Beeps
    347  7876				  -	      307	Sound_B0 = 220, ///< 200ms Beep
    348  7876				  -	      308	Sound_B1 = 221, ///< 270ms Beep
    349  7876				  -	      309	Sound_B2 = 222, ///< 280ms Beep
    350  7876				  -	      310	Sound_B3 = 223, ///< 260ms Beep
    351  7876				  -	      311	Sound_B4 = 224, ///< 300ms Beep
    352  7876				  -	      312	Sound_B5 = 225, ///< 100ms Beep
    353  7876				  -	      313	Sound_B6 = 226, ///< 104ms Beep
    354  7876				  -	      314	Sound_B7 = 227, ///< 100ms Beep
    355  7876				  -	      315	Sound_B8 = 228, ///< 270ms Beep
    356  7876				  -	      316	Sound_B9 = 229, ///< 262ms Beep
    357  7876				  -	      317	// Biological
    358  7876				  -	      318	Sound_C0 = 230, ///< 160ms Biological
    359  7876				  -	      319	Sound_C1 = 231, ///< 300ms Biological
    360  7876				  -	      320	Sound_C2 = 232, ///< 182ms Biological
    361  7876				  -	      321	Sound_C3 = 233, ///< 120ms Biological
    362  7876				  -	      322	Sound_C4 = 234, ///< 175ms Biological
    363  7876				  -	      323	Sound_C5 = 235, ///< 350ms Biological
    364  7876				  -	      324	Sound_C6 = 236, ///< 160ms Biological
    365  7876				  -	      325	Sound_C7 = 237, ///< 260ms Biological
    366  7876				  -	      326	Sound_C8 = 238, ///< 95ms Biological
    367  7876				  -	      327	Sound_C9 = 239, ///< 75ms Biological
    368  7876				  -	      328	// DTMF
    369  7876				  -	      329	DTMF_0 = 240, ///< DTMF 0 95ms
    370  7876				  -	      330	DTMF_1 = 241, ///< DTMF 1 95ms
    371  7876				  -	      331	DTMF_2 = 242, ///< DTMF 2 95ms
    372  7876				  -	      332	DTMF_3 = 243, ///< DTMF 3 95ms
    373  7876				  -	      333	DTMF_4 = 244, ///< DTMF 4 95ms
    374  7876				  -	      334	DTMF_5 = 245, ///< DTMF 5 95ms
    375  7876				  -	      335	DTMF_6 = 246, ///< DTMF 6 95ms
    376  7876				  -	      336	DTMF_7 = 247, ///< DTMF 7 95ms
    377  7876				  -	      337	DTMF_8 = 248, ///< DTMF 8 95ms
    378  7876				  -	      338	DTMF_9 = 249, ///< DTMF 9 95ms
    379  7876				  -	      339	DTMF_STAR = 250, ///< DTMF * 95ms
    380  7876				  -	      340	DTMF_HASH = 251, ///< DTMF # 95ms
    381  7876				  -	      341	// Miscellaneous
    382  7876				  -	      342	Sound_M0 = 252, ///< Sonar ping 125ms
    383  7876				  -	      343	Sound_M1 = 253, ///< Pistol shot 250ms
    384  7876				  -	      344	Sound_M2 = 254, ///< WOW 530ms
    385  7876				  -	      345
    386  7876				  -	      346	EndOfPhrase = 255, ///< End of phrase marker. Required at end of code arrays
    387  7876				  -	      347
    388  7876				  -	      348	CommandCodes	;
    389  7876				  -	      349
    390  7876				  -
    391  7876				  -ENDIF
------- FILE ./chess.asm
    609  7876
    610  7876							; MUST BE LAST...
------- FILE BANK_FIXED.asm LEVEL 2 PASS 5
      0  7876					      include	"BANK_FIXED.asm"
      1  7876							; Chess
      2  7876							; Copyright (c) 2019-2020 Andrew Davie
      3  7876							; andrew@taswegian.com
      4  7876
      5  7876
      6  7876							;---------------------------------------------------------------------------------------------------
      7  7876							;#########################################  FIXED BANK  ############################################
      8  7876							;---------------------------------------------------------------------------------------------------
      9  7876
     10  7876				   ORIGIN     SET	FIXED_BANK
     11  7876
      0  7876					      NEWBANK	THE_FIXED_BANK
      1  ffb9 ????				      SEG	THE_FIXED_BANK
      2  f800					      ORG	ORIGIN
      3  f800					      RORG	$F000
      4  f800				   BANK_START SET	*
      5  f800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  f800				   ORIGIN     SET	ORIGIN + 2048
      7  f800				   _CURRENT_BANK SET	THE_FIXED_BANK
     13  f800					      RORG	$f800
     14  f800
     15  f800							;---------------------------------------------------------------------------------------------------
     16  f800
      0  f800					      DEF	Reset
      1  f800				   BANK_Reset SET	_CURRENT_BANK
      2  f800				   Reset
      3  f800				   TEMPORARY_VAR SET	Overlay
      4  f800				   TEMPORARY_OFFSET SET	0
      5  f800				   VAR_BOUNDARY_Reset SET	TEMPORARY_OFFSET
      6  f800				   FUNCTION_NAME SET	Reset
      7  f800					      SUBROUTINE
     18  f800					      SUBROUTINE
     19  f800
      0  f800					      VEND	Reset
      1  f800				  -	      IFNCONST	Reset
      2  f800				  -	      ECHO	"Incorrect VEND label", Reset
      3  f800				  -	      ERR
      4  f800					      ENDIF
      5  f800		       00 a7	   VAREND_Reset =	TEMPORARY_VAR
     21  f800
     22  f800		       a2 ff		      ldx	#$FF
     23  f802		       9a		      txs
     24  f803
      0  f803					      JSROM_SAFE	cartInit
      1  f803
      2  f803
      3  f803
      4  f803		       a9 00		      lda	#BANK_cartInit
      5  f805		       85 8b		      sta	savedBank
      6  f807		       85 3f		      sta	SET_BANK
      7  f809		       20 04 f0 	      jsr	cartInit
     26  f80c
     27  f80c							;JSROM TitleScreen
     28  f80c
     29  f80c							;JSROM ShutYourMouth
     30  f80c
     31  f80c							; Patch the final row's "loop" to a RTS
     32  f80c
     33  f80c		       a2 07		      ldx	#7
     34  f80e		       86 3e		      stx	SET_BANK_RAM
     35  f810		       a9 60		      lda	#$60	; "rts"
      0  f812					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  f812		       8d 00 f6 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     37  f815
     38  f815		       20 0d fc 	      jsr	InitialisePieceSquares
     39  f818
     40  f818
     41  f818							;RESYNC
     42  f818				   .StartFrame
     43  f818
     44  f818
     45  f818							; START OF FRAME
     46  f818
     47  f818		       a9 0e		      lda	#%1110	; VSYNC ON
     48  f81a		       85 42	   .loopVSync3 sta	WSYNC
     49  f81c		       85 40		      sta	VSYNC
     50  f81e		       4a		      lsr
     51  f81f		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     52  f821
     53  f821		       85 41		      sta	VBLANK
     54  f823
     55  f823		       a0 2e		      ldy	#TIME_PART_1
     56  f825		       8c 96 02 	      sty	TIM64T
     57  f828
     58  f828							; LOTS OF PROCESSING TIME - USE IT
     59  f828
     60  f828		       20 71 f8 	      jsr	AiStateMachine
     61  f82b
     62  f82b
     63  f82b							;xx2 lda INTIM
     64  f82b							; beq xx2
     65  f82b
     66  f82b
     67  f82b				  -	      IF	ASSERTS
     68  f82b				  -			; Catch timer expired already
     69  f82b				  -			;		      bit TIMINT
     70  f82b				  -			;.whoops	      bmi .whoops
     71  f82b					      ENDIF
     72  f82b
     73  f82b
     74  f82b		       2c 85 02    .wait      bit	TIMINT
     75  f82e		       10 fb		      bpl	.wait
     76  f830
     77  f830
     78  f830							; START OF VISIBLE SCANLINES
     79  f830
     80  f830
      0  f830					      JSROM	longD
      1  f830
      2  f830		       a9 00		      lda	#BANK_longD
      3  f832		       85 3f		      sta	SET_BANK
      4  f834		       20 71 f0 	      jsr	longD
     82  f837
     83  f837		       86 3e		      stx	SET_BANK_RAM
     84  f839		       20 03 f2 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     85  f83c
      0  f83c					      JSROM	tidySc
      1  f83c
      2  f83c		       a9 00		      lda	#BANK_tidySc
      3  f83e		       85 3f		      sta	SET_BANK
      4  f840		       20 5d f0 	      jsr	tidySc
     87  f843
     88  f843		       20 71 f8 	      jsr	AiStateMachine
     89  f846
     90  f846		       ad 84 02 	      lda	INTIM
     91  f849		       c9 14		      cmp	#20
     92  f84b		       90 1b		      bcc	.notnow
     93  f84d
      0  f84d					      JSROM	GameSpeak
      1  f84d
      2  f84d		       a9 0f		      lda	#BANK_GameSpeak
      3  f84f		       85 3f		      sta	SET_BANK
      4  f851		       20 09 f0 	      jsr	GameSpeak
      0  f854					      JSROM	PositionSprites
      1  f854
      2  f854		       a9 07		      lda	#BANK_PositionSprites
      3  f856		       85 3f		      sta	SET_BANK
      4  f858		       20 00 f4 	      jsr	PositionSprites
     96  f85b
     97  f85b
     98  f85b							; "draw" sprite shapes into row banks
     99  f85b
    100  f85b		       a2 07		      ldx	#7
    101  f85d		       86 3e	   zapem      stx	SET_BANK_RAM
    102  f85f		       20 a6 f2 	      jsr	WriteBlank
    103  f862		       ca		      dex
    104  f863		       10 f8		      bpl	zapem
    105  f865
    106  f865		       20 cf f2 	      jsr	WriteCursor
    107  f868				   .notnow
    108  f868
    109  f868							;    lda aiState
    110  f868							;    beq Waitforit
    111  f868							;    cmp #22
    112  f868							;    bcc Waitforit
    113  f868							;xx3 bit TIMINT
    114  f868							; bmi xx3
    115  f868
    116  f868		       2c 85 02    .waitTime  bit	TIMINT
    117  f86b		       10 fb		      bpl	.waitTime
    118  f86d
    119  f86d		       4c 18 f8 	      jmp	.StartFrame
    120  f870
    121  f870
    122  f870		       60	   _rts       rts
    123  f871
    124  f871
    125  f871							;---------------------------------------------------------------------------------------------------
    126  f871
      0  f871					      DEF	AiStateMachine
      1  f871				   BANK_AiStateMachine SET	_CURRENT_BANK
      2  f871				   AiStateMachine
      3  f871				   TEMPORARY_VAR SET	Overlay
      4  f871				   TEMPORARY_OFFSET SET	0
      5  f871				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      6  f871				   FUNCTION_NAME SET	AiStateMachine
      7  f871					      SUBROUTINE
    128  f871					      SUBROUTINE
    129  f871
      0  f871					      REFER	Reset
      1  f871				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  f871				  -TEMPORARY_VAR SET	VAREND_Reset
      3  f871					      ENDIF
      0  f871					      VEND	AiStateMachine
      1  f871				  -	      IFNCONST	AiStateMachine
      2  f871				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  f871				  -	      ERR
      4  f871					      ENDIF
      5  f871		       00 a7	   VAREND_AiStateMachine =	TEMPORARY_VAR
    132  f871
      0  f871					      JSROM	AiSetupVectors
      1  f871
      2  f871		       a9 07		      lda	#BANK_AiSetupVectors
      3  f873		       85 3f		      sta	SET_BANK
      4  f875		       20 75 f0 	      jsr	AiSetupVectors
    134  f878		       85 3f		      sta	SET_BANK
    135  f87a		       6c ef 00 	      jmp	(__ptr)	; TODO: OR branch back to squeeze cycles
    136  f87d
    137  f87d
    138  f87d							;---------------------------------------------------------------------------------------------------
    139  f87d
      0  f87d					      DEF	CallClear
      1  f87d				   BANK_CallClear SET	_CURRENT_BANK
      2  f87d				   CallClear
      3  f87d				   TEMPORARY_VAR SET	Overlay
      4  f87d				   TEMPORARY_OFFSET SET	0
      5  f87d				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      6  f87d				   FUNCTION_NAME SET	CallClear
      7  f87d					      SUBROUTINE
    141  f87d					      SUBROUTINE
    142  f87d
      0  f87d					      REFER	aiClearEachRow
      1  f87d				  -	      IF	VAREND_aiClearEachRow > TEMPORARY_VAR
      2  f87d				  -TEMPORARY_VAR SET	VAREND_aiClearEachRow
      3  f87d					      ENDIF
      0  f87d					      VEND	CallClear
      1  f87d				  -	      IFNCONST	CallClear
      2  f87d				  -	      ECHO	"Incorrect VEND label", CallClear
      3  f87d				  -	      ERR
      4  f87d					      ENDIF
      5  f87d		       00 a7	   VAREND_CallClear =	TEMPORARY_VAR
    145  f87d
    146  f87d							; No transient variable dependencies/calls
    147  f87d
    148  f87d		       84 3e		      sty	SET_BANK_RAM
    149  f87f		       20 90 f1 	      jsr	ClearRowBitmap
    150  f882		       60		      rts
    151  f883
    152  f883
    153  f883							;---------------------------------------------------------------------------------------------------
    154  f883
      0  f883					      DEF	aiDrawEntireBoard
      1  f883				   BANK_aiDrawEntireBoard SET	_CURRENT_BANK
      2  f883				   aiDrawEntireBoard
      3  f883				   TEMPORARY_VAR SET	Overlay
      4  f883				   TEMPORARY_OFFSET SET	0
      5  f883				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      6  f883				   FUNCTION_NAME SET	aiDrawEntireBoard
      7  f883					      SUBROUTINE
    156  f883					      SUBROUTINE
    157  f883
      0  f883					      REFER	AiStateMachine
      1  f883				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f883				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f883					      ENDIF
      0  f883					      VEND	aiDrawEntireBoard
      1  f883				  -	      IFNCONST	aiDrawEntireBoard
      2  f883				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  f883				  -	      ERR
      4  f883					      ENDIF
      5  f883		       00 a7	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    160  f883
    161  f883
    162  f883		       ad 84 02 	      lda	INTIM
    163  f886		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    164  f888		       90 2c		      bcc	.exit
    165  f88a
    166  f88a		       a9 09		      lda	#RAMBANK_BOARD
    167  f88c		       85 3e		      sta	SET_BANK_RAM
    168  f88e		       a4 80		      ldy	squareToDraw
    169  f890		       b9 20 f0 	      lda	ValidSquare,y
    170  f893		       30 1d		      bmi	.isablank2
    171  f895
    172  f895		       b9 84 f0 	      lda	Board,y
    173  f898		       f0 13		      beq	.isablank
    174  f89a		       48		      pha
    175  f89b		       a9 00		      lda	#BLANK
      0  f89d					      sta@RAM	Board,y
      1  f89d		       99 84 f4 	      sta	[RAM]+Board,y
    177  f8a0
    178  f8a0		       20 ed fc 	      jsr	CopySinglePiece
    179  f8a3
    180  f8a3		       a9 09		      lda	#RAMBANK_BOARD
    181  f8a5		       85 3e		      sta	SET_BANK_RAM
    182  f8a7
    183  f8a7		       a4 80		      ldy	squareToDraw
    184  f8a9		       68		      pla
      0  f8aa					      sta@RAM	Board,y
      1  f8aa		       99 84 f4 	      sta	[RAM]+Board,y
    186  f8ad
      0  f8ad				   .isablank  PHASE	AI_DrawPart2
      1  f8ad		       a9 10		      lda	#AI_DrawPart2
      2  f8af		       85 8c		      sta	aiState
    188  f8b1		       60		      rts
    189  f8b2
      0  f8b2				   .isablank2 PHASE	AI_DrawPart3
      1  f8b2		       a9 11		      lda	#AI_DrawPart3
      2  f8b4		       85 8c		      sta	aiState
    191  f8b6		       60	   .exit      rts
    192  f8b7
    193  f8b7
    194  f8b7							;---------------------------------------------------------------------------------------------------
    195  f8b7
      0  f8b7					      DEF	aiGenerateMoves
      1  f8b7				   BANK_aiGenerateMoves SET	_CURRENT_BANK
      2  f8b7				   aiGenerateMoves
      3  f8b7				   TEMPORARY_VAR SET	Overlay
      4  f8b7				   TEMPORARY_OFFSET SET	0
      5  f8b7				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      6  f8b7				   FUNCTION_NAME SET	aiGenerateMoves
      7  f8b7					      SUBROUTINE
    197  f8b7					      SUBROUTINE
    198  f8b7
      0  f8b7					      REFER	AiStateMachine
      1  f8b7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f8b7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f8b7					      ENDIF
      0  f8b7					      VEND	aiGenerateMoves
      1  f8b7				  -	      IFNCONST	aiGenerateMoves
      2  f8b7				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  f8b7				  -	      ERR
      4  f8b7					      ENDIF
      5  f8b7		       00 a7	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    201  f8b7
    202  f8b7							; Player comes here at the start of making a move
    203  f8b7							; This generates a valid movelist by calling 'negaMax' (removing illegal moves)
    204  f8b7
    205  f8b7		       a5 86		      lda	toX12
    206  f8b9		       85 80		      sta	squareToDraw	; for showing move (display square)
    207  f8bb
    208  f8bb		       a6 97		      ldx	sideToMove
    209  f8bd		       10 05		      bpl	.player
    210  f8bf
    211  f8bf
      0  f8bf				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  f8bf		       a9 13		      lda	#AI_ComputerMove
      2  f8c1		       85 8c		      sta	aiState
    213  f8c3		       60		      rts
    214  f8c4
    215  f8c4
      0  f8c4				   .player    PHASE	AI_StartMoveGen
      1  f8c4		       a9 0b		      lda	#AI_StartMoveGen
      2  f8c6		       85 8c		      sta	aiState
    217  f8c8		       60		      rts
    218  f8c9
    219  f8c9
    220  f8c9							;---------------------------------------------------------------------------------------------------
    221  f8c9
      0  f8c9					      DEF	aiStepMoveGen
      1  f8c9				   BANK_aiStepMoveGen SET	_CURRENT_BANK
      2  f8c9				   aiStepMoveGen
      3  f8c9				   TEMPORARY_VAR SET	Overlay
      4  f8c9				   TEMPORARY_OFFSET SET	0
      5  f8c9				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      6  f8c9				   FUNCTION_NAME SET	aiStepMoveGen
      7  f8c9					      SUBROUTINE
    223  f8c9					      SUBROUTINE
    224  f8c9
      0  f8c9					      REFER	AiStateMachine
      1  f8c9				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f8c9				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f8c9					      ENDIF
      0  f8c9					      VEND	aiStepMoveGen
      1  f8c9				  -	      IFNCONST	aiStepMoveGen
      2  f8c9				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  f8c9				  -	      ERR
      4  f8c9					      ENDIF
      5  f8c9		       00 a7	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    227  f8c9
    228  f8c9		       a5 87		      lda	originX12	; location of cursor (show move)
    229  f8cb		       85 88		      sta	cursorX12
      0  f8cd					      PHASE	AI_BeginSelectMovePhase
      1  f8cd		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  f8cf		       85 8c		      sta	aiState
    231  f8d1		       60		      rts
    232  f8d2
    233  f8d2
    234  f8d2							;---------------------------------------------------------------------------------------------------
    235  f8d2
      0  f8d2					      DEF	ListPlayerMoves
      1  f8d2				   BANK_ListPlayerMoves SET	_CURRENT_BANK
      2  f8d2				   ListPlayerMoves
      3  f8d2				   TEMPORARY_VAR SET	Overlay
      4  f8d2				   TEMPORARY_OFFSET SET	0
      5  f8d2				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      6  f8d2				   FUNCTION_NAME SET	ListPlayerMoves
      7  f8d2					      SUBROUTINE
    237  f8d2					      SUBROUTINE
    238  f8d2
    239  f8d2
    240  f8d2		       a9 00		      lda	#0
    241  f8d4		       85 b2		      sta	__quiesceCapOnly
    242  f8d6
    243  f8d6		       a9 0b		      lda	#RAMBANK_PLY+1
    244  f8d8		       85 95		      sta	currentPly
    245  f8da		       20 07 f9 	      jsr	GenerateAllMoves
    246  f8dd
      0  f8dd					      ldx@PLY	moveIndex
      1  f8dd		       ae 51 f1 	      ldx	moveIndex
      0  f8e0				   .scan      stx@PLY	movePtr
      1  f8e0		       8e 52 f5 	      stx	[RAM]+movePtr
    249  f8e3
    250  f8e3		       20 89 fd 	      jsr	MakeMove
    251  f8e6
    252  f8e6		       e6 95		      inc	currentPly
    253  f8e8		       20 07 f9 	      jsr	GenerateAllMoves
    254  f8eb
    255  f8eb		       c6 95		      dec	currentPly
    256  f8ed		       a5 95		      lda	currentPly
    257  f8ef		       85 3e		      sta	SET_BANK_RAM
    258  f8f1
    259  f8f1		       20 f0 fd 	      jsr	unmakeMove
    260  f8f4
    261  f8f4		       a5 a4		      lda	flagCheck
    262  f8f6		       f0 08		      beq	.next
    263  f8f8
      0  f8f8					      ldx@PLY	movePtr
      1  f8f8		       ae 52 f1 	      ldx	movePtr
    265  f8fb		       a9 00		      lda	#0
      0  f8fd					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  f8fd		       9d 02 f4 	      sta	[RAM]+MoveFrom,x
    267  f900
      0  f900				   .next      ldx@PLY	movePtr
      1  f900		       ae 52 f1 	      ldx	movePtr
    269  f903		       ca		      dex
    270  f904		       10 da		      bpl	.scan
    271  f906
    272  f906		       60	   elp	      rts
    273  f907
    274  f907
    275  f907							;---------------------------------------------------------------------------------------------------
    276  f907
      0  f907					      DEF	GenerateAllMoves
      1  f907				   BANK_GenerateAllMoves SET	_CURRENT_BANK
      2  f907				   GenerateAllMoves
      3  f907				   TEMPORARY_VAR SET	Overlay
      4  f907				   TEMPORARY_OFFSET SET	0
      5  f907				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      6  f907				   FUNCTION_NAME SET	GenerateAllMoves
      7  f907					      SUBROUTINE
    278  f907					      SUBROUTINE
    279  f907
      0  f907					      REFER	negaMax
      1  f907					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	VAREND_negaMax
      3  f907					      ENDIF
      0  f907					      REFER	quiesce
      1  f907				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  f907				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  f907					      ENDIF
      0  f907					      REFER	aiStepMoveGen
      1  f907				  -	      IF	VAREND_aiStepMoveGen > TEMPORARY_VAR
      2  f907				  -TEMPORARY_VAR SET	VAREND_aiStepMoveGen
      3  f907					      ENDIF
      0  f907					      REFER	aiGenerateMoves
      1  f907				  -	      IF	VAREND_aiGenerateMoves > TEMPORARY_VAR
      2  f907				  -TEMPORARY_VAR SET	VAREND_aiGenerateMoves
      3  f907					      ENDIF
      0  f907					      REFER	selectmove
      1  f907				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  f907				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  f907					      ENDIF
      0  f907					      VAR	__vector, 2
      1  f907		       00 b3	   __vector   =	TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f907
      4  f907				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f907				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f907				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f907					      ENDIF
      8  f907				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f907				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  f907				  -	      ERR
     11  f907					      ENDIF
     12  f907					      LIST	ON
      0  f907					      VAR	__masker, 2
      1  f907		       00 b5	   __masker   =	TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f907
      4  f907				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f907				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f907				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f907					      ENDIF
      8  f907				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f907				  -	      ECHO	"Temporary Variable", __masker, "overflow!"
     10  f907				  -	      ERR
     11  f907					      ENDIF
     12  f907					      LIST	ON
      0  f907					      VAR	__pieceFilter, 1
      1  f907		       00 b7	   __pieceFilter =	TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f907
      4  f907				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f907				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f907				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f907					      ENDIF
      8  f907				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f907				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  f907				  -	      ERR
     11  f907					      ENDIF
     12  f907					      LIST	ON
      0  f907					      VAR	__piecePointer, 16
      1  f907		       00 b8	   __piecePointer =	TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 16
      3  f907
      4  f907				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f907				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f907				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f907					      ENDIF
      8  f907				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f907				  -	      ECHO	"Temporary Variable", __piecePointer, "overflow!"
     10  f907				  -	      ERR
     11  f907					      ENDIF
     12  f907					      LIST	ON
      0  f907					      VAR	__ppIndex, 1
      1  f907		       00 c8	   __ppIndex  =	TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f907
      4  f907				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f907				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f907				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f907					      ENDIF
      8  f907				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f907				  -	      ECHO	"Temporary Variable", __ppIndex, "overflow!"
     10  f907				  -	      ERR
     11  f907					      ENDIF
     12  f907					      LIST	ON
      0  f907					      VEND	GenerateAllMoves
      1  f907				  -	      IFNCONST	GenerateAllMoves
      2  f907				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  f907				  -	      ERR
      4  f907					      ENDIF
      5  f907		       00 c9	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    291  f907
    292  f907							; Do the move generation in two passes - pawns then pieces
    293  f907							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    294  f907
    295  f907		       a5 95		      lda	currentPly
    296  f909		       85 3e		      sta	SET_BANK_RAM
    297  f90b		       20 5c f1 	      jsr	NewPlyInitialise
    298  f90e
    299  f90e				  -	      IF	0
    300  f90e				  -	      lda	#RAMBANK_BOARD
    301  f90e				  -	      sta	SET_BANK_RAM
    302  f90e				  -
    303  f90e				  -	      ldx	#0
    304  f90e				  -	      sta	_ppIndex
    305  f90e				  -
    306  f90e				  -	      ldx	#100
    307  f90e				  -.next      dex
    308  f90e				  -	      cpx	#22
    309  f90e				  -	      bcc	.exit
    310  f90e				  -
    311  f90e				  -	      lda	Board,x
    312  f90e				  -	      beq	.next
    313  f90e				  -	      cmp	#-1
    314  f90e				  -	      beq	.next
    315  f90e				  -
    316  f90e				  -	      and	#PIECE_MASK
    317  f90e				  -	      tay
    318  f90e					      ENDIF
    319  f90e
    320  f90e
    321  f90e
    322  f90e		       a9 08		      lda	#8	; pawns
    323  f910		       85 b7		      sta	__pieceFilter
    324  f912		       20 27 f9 	      jsr	MoveGenx
    325  f915		       a9 63		      lda	#99
    326  f917		       85 93		      sta	currentSquare
    327  f919		       a9 00		      lda	#0
    328  f91b		       85 b7		      sta	__pieceFilter
    329  f91d		       20 27 f9 	      jsr	MoveGenx
    330  f920
    331  f920
    332  f920
    333  f920
    334  f920		       a5 95		      lda	currentPly
    335  f922		       85 3e		      sta	SET_BANK_RAM
    336  f924		       4c 44 f2 	      jmp	Sort
    337  f927
    338  f927
    339  f927
    340  f927
    341  f927				   MoveGenx
    342  f927		       a2 64		      ldx	#100
    343  f929		       d0 02		      bne	.next2
    344  f92b
    345  f92b		       a6 93	   MoveReturn ldx	currentSquare
    346  f92d
    347  f92d		       a9 09	   .next2     lda	#RAMBANK_BOARD
    348  f92f		       85 3e		      sta	SET_BANK_RAM
    349  f931
    350  f931		       ca	   .next      dex
    351  f932		       e0 16		      cpx	#22
    352  f934		       90 10		      bcc	.exit
    353  f936
    354  f936		       bd 84 f0 	      lda	Board,x
    355  f939		       f0 f6		      beq	.next
    356  f93b		       c9 ff		      cmp	#-1
    357  f93d		       f0 f2		      beq	.next
    358  f93f		       45 97		      eor	sideToMove
    359  f941		       30 ee		      bmi	.next
    360  f943
    361  f943		       4c e8 f0 	      jmp	handleIt
    362  f946
    363  f946
    364  f946				   .exit
    365  f946		       60		      rts
    366  f947
    367  f947
    368  f947
    369  f947
    370  f947							;---------------------------------------------------------------------------------------------------
    371  f947
      0  f947					      DEF	aiComputerMove
      1  f947				   BANK_aiComputerMove SET	_CURRENT_BANK
      2  f947				   aiComputerMove
      3  f947				   TEMPORARY_VAR SET	Overlay
      4  f947				   TEMPORARY_OFFSET SET	0
      5  f947				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      6  f947				   FUNCTION_NAME SET	aiComputerMove
      7  f947					      SUBROUTINE
    373  f947					      SUBROUTINE
    374  f947
      0  f947					      REFER	AiStateMachine
      1  f947				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f947				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f947					      ENDIF
      0  f947					      VEND	aiComputerMove
      1  f947				  -	      IFNCONST	aiComputerMove
      2  f947				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  f947				  -	      ERR
      4  f947					      ENDIF
      5  f947		       00 a7	   VAREND_aiComputerMove =	TEMPORARY_VAR
    377  f947
    378  f947
    379  f947		       a9 0a		      lda	#RAMBANK_PLY
    380  f949		       85 95		      sta	currentPly
    381  f94b		       85 3e		      sta	SET_BANK_RAM	; switch in movelist
    382  f94d
    383  f94d		       a9 01		      lda	#1
    384  f94f		       85 4a		      sta	CTRLPF
    385  f951							;lda #$e0
    386  f951							;sta COLUPF
    387  f951
    388  f951		       20 a5 f1 	      jsr	selectmove
    389  f954
    390  f954		       a9 00		      lda	#0
    391  f956		       85 4a		      sta	CTRLPF
    392  f958		       85 4d		      sta	PF0
    393  f95a		       85 4e		      sta	PF1
    394  f95c		       85 4f		      sta	PF2
    395  f95e
      0  f95e					      lda@PLY	bestMove
      1  f95e		       ad 53 f1 	      lda	bestMove
    397  f961		       10 12		      bpl	.notComputer
    398  f963
    399  f963							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
    400  f963
    401  f963
    402  f963		       18		      clc
    403  f964		       20 07 f9 	      jsr	GenerateAllMoves
    404  f967		       a5 a4		      lda	flagCheck
    405  f969		       f0 05		      beq	.gameDrawn
    406  f96b
      0  f96b					      PHASE	AI_CheckMate
      1  f96b		       a9 23		      lda	#AI_CheckMate
      2  f96d		       85 8c		      sta	aiState
    408  f96f		       60		      rts
    409  f970
    410  f970
      0  f970				   .gameDrawn PHASE	AI_Draw
      1  f970		       a9 24		      lda	#AI_Draw
      2  f972		       85 8c		      sta	aiState
    412  f974		       60		      rts
    413  f975
    414  f975				   .notComputer
    415  f975
    416  f975
    417  f975		       a9 ff		      lda	#-1
    418  f977		       85 88		      sta	cursorX12
    419  f979
    420  f979		       a9 32		      lda	#50
    421  f97b		       85 8d		      sta	aiFlashDelay
      0  f97d					      PHASE	AI_DelayAfterMove
      1  f97d		       a9 25		      lda	#AI_DelayAfterMove
      2  f97f		       85 8c		      sta	aiState
    423  f981		       60	   .halted    rts
    424  f982
    425  f982
    426  f982
    427  f982							;---------------------------------------------------------------------------------------------------
    428  f982
      0  f982					      DEF	AdjustMaterialPositionalValue
      1  f982				   BANK_AdjustMaterialPositionalValue SET	_CURRENT_BANK
      2  f982				   AdjustMaterialPositionalValue
      3  f982				   TEMPORARY_VAR SET	Overlay
      4  f982				   TEMPORARY_OFFSET SET	0
      5  f982				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      6  f982				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
      7  f982					      SUBROUTINE
    430  f982					      SUBROUTINE
    431  f982
    432  f982							; A move is about to be made, so  adjust material and positional values based on from/to and
    433  f982							; capture.
    434  f982
    435  f982							; First, nominate referencing subroutines so that local variables can be adjusted properly
    436  f982
      0  f982					      REFER	negaMax
      1  f982					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  f982				   TEMPORARY_VAR SET	VAREND_negaMax
      3  f982					      ENDIF
      0  f982					      REFER	MakeMove
      1  f982					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  f982				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  f982					      ENDIF
      0  f982					      REFER	aiMoveIsSelected
      1  f982				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  f982				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  f982					      ENDIF
      0  f982					      VAR	__originalPiece, 1
      1  f982		       00 b5	   __originalPiece =	TEMPORARY_VAR
      2  f982				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f982
      4  f982				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f982				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f982				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f982					      ENDIF
      8  f982				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f982				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  f982				  -	      ERR
     11  f982					      ENDIF
     12  f982					      LIST	ON
      0  f982					      VAR	__capturedPiece, 1
      1  f982		       00 b6	   __capturedPiece =	TEMPORARY_VAR
      2  f982				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f982
      4  f982				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f982				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f982				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f982					      ENDIF
      8  f982				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f982				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  f982				  -	      ERR
     11  f982					      ENDIF
     12  f982					      LIST	ON
      0  f982					      VEND	AdjustMaterialPositionalValue
      1  f982				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  f982				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  f982				  -	      ERR
      4  f982					      ENDIF
      5  f982		       00 b7	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    443  f982
    444  f982							; fromPiece	 piece doing the move (promoted type)
    445  f982							; fromX12	 current square
    446  f982							; originX12	 starting square
    447  f982							; toX12	 ending square
    448  f982
    449  f982
    450  f982							; get the piece types from the board
    451  f982
    452  f982		       a9 09		      lda	#RAMBANK_BOARD
    453  f984		       85 3e		      sta	SET_BANK_RAM
    454  f986		       a4 87		      ldy	originX12
    455  f988		       b9 84 f0 	      lda	Board,y
    456  f98b		       85 b5		      sta	__originalPiece
    457  f98d		       a4 86		      ldy	toX12
    458  f98f		       b9 84 f0 	      lda	Board,y
    459  f992		       85 b6		      sta	__capturedPiece
    460  f994
    461  f994							; {
    462  f994							;   adjust the positional value  (originX12 --> fromX12)
    463  f994
    464  f994		       a9 12		      lda	#RAMBANK_BANK_EVAL	;BANK_AddPiecePositionValue
    465  f996		       85 3e		      sta	SET_BANK_RAM
    466  f998
    467  f998
    468  f998							;ldy toX12
    469  f998		       a5 98		      lda	fromPiece
    470  f99a		       20 3b f0 	      jsr	AddPiecePositionValue	; add pos value for new position
    471  f99d
    472  f99d
    473  f99d		       a5 b5		      lda	__originalPiece
    474  f99f		       45 98		      eor	fromPiece	; the new piece
    475  f9a1		       29 0f		      and	#PIECE_MASK
    476  f9a3		       f0 05		      beq	.same1	; unchanged, so skip
    477  f9a5
    478  f9a5		       a5 98		      lda	fromPiece	; new piece
    479  f9a7							;and #PIECE_MASK
    480  f9a7							;tay
    481  f9a7		       20 28 f0 	      jsr	AddPieceMaterialValue
    482  f9aa
    483  f9aa				   .same1
    484  f9aa
    485  f9aa							; and now the 'subtracts'
    486  f9aa
      0  f9aa					      NEGEVAL
      1  f9aa
      2  f9aa		       38		      sec
      3  f9ab		       a9 00		      lda	#0
      4  f9ad		       e5 90		      sbc	Evaluation
      5  f9af		       85 90		      sta	Evaluation
      6  f9b1		       a9 00		      lda	#0
      7  f9b3		       e5 91		      sbc	Evaluation+1
      8  f9b5		       85 91		      sta	Evaluation+1
    488  f9b7
    489  f9b7		       a4 87		      ldy	originX12
    490  f9b9		       a5 b5		      lda	__originalPiece
    491  f9bb		       20 3b f0 	      jsr	AddPiecePositionValue	; remove pos value for original position
    492  f9be
    493  f9be
    494  f9be		       a5 b5		      lda	__originalPiece
    495  f9c0		       45 98		      eor	fromPiece	; the new piece
    496  f9c2		       29 0f		      and	#PIECE_MASK
    497  f9c4		       f0 05		      beq	.same2	; unchanged, so skip
    498  f9c6
    499  f9c6		       a5 b5		      lda	__originalPiece
    500  f9c8							;and #PIECE_MASK
    501  f9c8							;tay
    502  f9c8		       20 28 f0 	      jsr	AddPieceMaterialValue	; remove material for original type
    503  f9cb				   .same2
    504  f9cb
      0  f9cb					      NEGEVAL
      1  f9cb
      2  f9cb		       38		      sec
      3  f9cc		       a9 00		      lda	#0
      4  f9ce		       e5 90		      sbc	Evaluation
      5  f9d0		       85 90		      sta	Evaluation
      6  f9d2		       a9 00		      lda	#0
      7  f9d4		       e5 91		      sbc	Evaluation+1
      8  f9d6		       85 91		      sta	Evaluation+1
    506  f9d8
    507  f9d8							; If there's a capture, we adjust the material value
    508  f9d8
    509  f9d8							;		      lda __capturedPiece
    510  f9d8							;		      eor __originalPiece
    511  f9d8							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    512  f9d8
    513  f9d8
    514  f9d8		       a5 b6		      lda	__capturedPiece
    515  f9da		       29 0f		      and	#PIECE_MASK
    516  f9dc		       f0 03		      beq	.noCapture
    517  f9de							;tay
    518  f9de		       20 28 f0 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    519  f9e1				   .noCapture
    520  f9e1
    521  f9e1							; }
    522  f9e1		       a5 8b		      lda	savedBank
    523  f9e3		       85 3f		      sta	SET_BANK
    524  f9e5		       60		      rts
    525  f9e6
    526  f9e6
    527  f9e6							;---------------------------------------------------------------------------------------------------
    528  f9e6
      0  f9e6					      DEF	debug
      1  f9e6				   BANK_debug SET	_CURRENT_BANK
      2  f9e6				   debug
      3  f9e6				   TEMPORARY_VAR SET	Overlay
      4  f9e6				   TEMPORARY_OFFSET SET	0
      5  f9e6				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      6  f9e6				   FUNCTION_NAME SET	debug
      7  f9e6					      SUBROUTINE
    530  f9e6					      SUBROUTINE
    531  f9e6
    532  f9e6							; Use this to trap breakpoints in "unknown" banks. Just "jsr debug" from wherever you want
    533  f9e6							; to catch the code, and put a breakpoint here instead. Then step, and you're at the place
    534  f9e6							; you wanted to see, without knowing the bank.
    535  f9e6
    536  f9e6		       60		      rts
    537  f9e7
    538  f9e7							;---------------------------------------------------------------------------------------------------
    539  f9e7
      0  f9e7					      DEF	aiSpecialMoveFixup
      1  f9e7				   BANK_aiSpecialMoveFixup SET	_CURRENT_BANK
      2  f9e7				   aiSpecialMoveFixup
      3  f9e7				   TEMPORARY_VAR SET	Overlay
      4  f9e7				   TEMPORARY_OFFSET SET	0
      5  f9e7				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      6  f9e7				   FUNCTION_NAME SET	aiSpecialMoveFixup
      7  f9e7					      SUBROUTINE
    541  f9e7					      SUBROUTINE
    542  f9e7
      0  f9e7					      COMMON_VARS_ALPHABETA
      1  f9e7
      0  f9e7					      VAR	__thinkbar, 1
      1  f9e7		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  f9e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f9e7
      4  f9e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e7					      ENDIF
      8  f9e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e7				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  f9e7				  -	      ERR
     11  f9e7					      ENDIF
     12  f9e7					      LIST	ON
      0  f9e7					      VAR	__toggle, 1
      1  f9e7		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  f9e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f9e7
      4  f9e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e7					      ENDIF
      8  f9e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e7				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  f9e7				  -	      ERR
     11  f9e7					      ENDIF
     12  f9e7					      LIST	ON
      4  f9e7
      0  f9e7					      VAR	__bestMove, 1
      1  f9e7		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  f9e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f9e7
      4  f9e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e7					      ENDIF
      8  f9e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e7				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  f9e7				  -	      ERR
     11  f9e7					      ENDIF
     12  f9e7					      LIST	ON
      0  f9e7					      VAR	__alpha, 2
      1  f9e7		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  f9e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f9e7
      4  f9e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e7					      ENDIF
      8  f9e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e7				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  f9e7				  -	      ERR
     11  f9e7					      ENDIF
     12  f9e7					      LIST	ON
      0  f9e7					      VAR	__beta, 2
      1  f9e7		       00 ac	   __beta     =	TEMPORARY_VAR
      2  f9e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f9e7
      4  f9e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e7					      ENDIF
      8  f9e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e7				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  f9e7				  -	      ERR
     11  f9e7					      ENDIF
     12  f9e7					      LIST	ON
      0  f9e7					      VAR	__negaMax, 2
      1  f9e7		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  f9e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f9e7
      4  f9e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e7					      ENDIF
      8  f9e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e7				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  f9e7				  -	      ERR
     11  f9e7					      ENDIF
     12  f9e7					      LIST	ON
      0  f9e7					      VAR	__value, 2
      1  f9e7		       00 b0	   __value    =	TEMPORARY_VAR
      2  f9e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f9e7
      4  f9e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e7					      ENDIF
      8  f9e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e7				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  f9e7				  -	      ERR
     11  f9e7					      ENDIF
     12  f9e7					      LIST	ON
     10  f9e7
      0  f9e7					      VAR	__quiesceCapOnly, 1
      1  f9e7		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  f9e7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f9e7
      4  f9e7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e7				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e7				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e7					      ENDIF
      8  f9e7				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e7				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  f9e7				  -	      ERR
     11  f9e7					      ENDIF
     12  f9e7					      LIST	ON
     12  f9e7
      0  f9e7					      REFER	AiStateMachine
      1  f9e7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f9e7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f9e7					      ENDIF
      0  f9e7					      VEND	aiSpecialMoveFixup
      1  f9e7				  -	      IFNCONST	aiSpecialMoveFixup
      2  f9e7				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  f9e7				  -	      ERR
      4  f9e7					      ENDIF
      5  f9e7		       00 b3	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    546  f9e7
    547  f9e7		       ad 84 02 	      lda	INTIM
    548  f9ea		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    549  f9ec		       b0 01		      bcs	.cont
    550  f9ee		       60		      rts
    551  f9ef
    552  f9ef
    553  f9ef				   .cont
    554  f9ef
    555  f9ef		       a2 01		      ldx	#1
    556  f9f1		       24 97		      bit	sideToMove
    557  f9f3		       30 02		      bmi	.setd
    558  f9f5		       a2 4b		      ldx	#75
    559  f9f7		       86 8d	   .setd      stx	aiFlashDelay
      0  f9f9					      PHASE	AI_DelayAfterPlaced
      1  f9f9		       a9 26		      lda	#AI_DelayAfterPlaced
      2  f9fb		       85 8c		      sta	aiState
    561  f9fd
    562  f9fd
    563  f9fd							; Special move fixup
    564  f9fd
    565  f9fd				  -	      IF	ENPASSANT_ENABLED
    566  f9fd				  -
    567  f9fd				  -			; Handle en-passant captures
    568  f9fd				  -			; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
    569  f9fd				  -			; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
    570  f9fd				  -			; need to do the appropriate things...
    571  f9fd				  -
    572  f9fd				  -	      lda	#BANK_EnPassantCheck
    573  f9fd				  -	      sta	SET_BANK
    574  f9fd				  -	      jsr	EnPassantCheck
    575  f9fd				  -
    576  f9fd					      ENDIF
    577  f9fd
    578  f9fd
    579  f9fd		       a5 95		      lda	currentPly
    580  f9ff		       85 3e		      sta	SET_BANK_RAM
    581  fa01		       20 27 f2 	      jsr	CastleFixupDraw
    582  fa04
    583  fa04		       a5 85		      lda	fromX12
    584  fa06		       85 80		      sta	squareToDraw
    585  fa08
    586  fa08		       60		      rts
    587  fa09
    588  fa09
    589  fa09							;---------------------------------------------------------------------------------------------------
    590  fa09
------- FILE Handler_PAWN.asm LEVEL 3 PASS 5
      0  fa09					      include	"Handler_PAWN.asm"
      1  fa09							; Copyright (C)2020 Andrew Davie
      2  fa09							; Pawn move handlers
      3  fa09
      4  fa09							;---------------------------------------------------------------------------------------------------
      5  fa09							; WHITE PAWN
      6  fa09							;---------------------------------------------------------------------------------------------------
      7  fa09
      8  fa09		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  fa09		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  fa09
     11  fa09							;---------------------------------------------------------------------------------------------------
     12  fa09
     13  fa09					      MAC	en_passant
     14  fa09					      SUBROUTINE
     15  fa09							; {1} = _LEFT or _RIGHT
     16  fa09
     17  fa09					      ldx	currentSquare
     18  fa09					      ldy	ValidSquare+{1},x
     19  fa09					      cpy	enPassantPawn
     20  fa09					      bne	.invalid
     21  fa09					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  fa09					      lda	Board,y
     23  fa09					      bne	.invalid
     24  fa09					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  fa09				   .invalid
     26  fa09					      ENDM
     27  fa09
     28  fa09							;---------------------------------------------------------------------------------------------------
     29  fa09
     30  fa09					      MAC	promote_pawn
     31  fa09							;SUBROUTINE
     32  fa09
     33  fa09							;{1} = BLACK or WHITE
     34  fa09
     35  fa09
     36  fa09					      sty	__temp
     37  fa09					      lda	#{1}|QUEEN
     38  fa09					      sta	currentPiece
     39  fa09					      jsr	AddMove
     40  fa09
     41  fa09					      lda	#{1}|ROOK
     42  fa09					      sta	currentPiece
     43  fa09					      ldy	__temp
     44  fa09					      jsr	AddMove
     45  fa09
     46  fa09					      lda	#{1}|BISHOP
     47  fa09					      sta	currentPiece
     48  fa09					      ldy	__temp
     49  fa09					      jsr	AddMove
     50  fa09
     51  fa09					      lda	#{1}|KNIGHT
     52  fa09					      sta	currentPiece
     53  fa09					      ldy	__temp
     54  fa09					      jsr	AddMove
     55  fa09
     56  fa09					      IF	{1} = WHITE
     57  fa09					      lda	#WHITE|WP
     58  fa09					      ENDIF
     59  fa09					      IF	{1} = BLACK
     60  fa09					      lda	#BLACK|BP
     61  fa09					      ENDIF
     62  fa09					      sta	currentPiece
     63  fa09					      ENDM
     64  fa09
     65  fa09							;---------------------------------------------------------------------------------------------------
     66  fa09
     67  fa09					      MAC	move_or_promote_pawn
     68  fa09							;SUBROUTINE
     69  fa09							; {1} = BLACK or WHITE
     70  fa09
     71  fa09					      IF	{1} = WHITE
     72  fa09					      cpy	#90	; last rank?
     73  fa09					      bcc	.standard
     74  fa09					      jsr	PromoteWhitePawn
     75  fa09					      jmp	.pMoved
     76  fa09					      ENDIF
     77  fa09
     78  fa09					      IF	{1} = BLACK
     79  fa09					      cpy	#30	; last rank?
     80  fa09					      bcs	.standard
     81  fa09					      jsr	PromoteBlackPawn
     82  fa09					      jmp	.pMoved
     83  fa09					      ENDIF
     84  fa09
     85  fa09				   .standard  jsr	AddMove	; add +1UP move
     86  fa09				   .pMoved
     87  fa09
     88  fa09					      ENDM
     89  fa09
     90  fa09							;---------------------------------------------------------------------------------------------------
     91  fa09
     92  fa09					      MAC	take
     93  fa09							;SUBROUTINE
     94  fa09							; {1} = capture square offset
     95  fa09
     96  fa09					      ldx	currentSquare
     97  fa09					      ldy	ValidSquare+{1},x
     98  fa09					      bmi	.invalid2
     99  fa09					      lda	Board,y
    100  fa09					      beq	.invalid2	; square empty
    101  fa09					      sta	capture
    102  fa09					      eor	currentPiece
    103  fa09					      bpl	.invalid	; same colour
    104  fa09
    105  fa09					      MOVE_OR_PROMOTE_PAWN	{2}
    106  fa09
    107  fa09					      jmp	.invalid2
    108  fa09				   .invalid   inc	protecting
    109  fa09				   .invalid2
    110  fa09					      ENDM
    111  fa09
    112  fa09							;---------------------------------------------------------------------------------------------------
    113  fa09
      0  fa09					      DEF	PromoteWhitePawn
      1  fa09				   BANK_PromoteWhitePawn SET	_CURRENT_BANK
      2  fa09				   PromoteWhitePawn
      3  fa09				   TEMPORARY_VAR SET	Overlay
      4  fa09				   TEMPORARY_OFFSET SET	0
      5  fa09				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      6  fa09				   FUNCTION_NAME SET	PromoteWhitePawn
      7  fa09					      SUBROUTINE
    115  fa09					      SUBROUTINE
    116  fa09
      0  fa09					      REFER	Handle_WHITE_PAWN
      1  fa09					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  fa09				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  fa09					      ENDIF
      0  fa09					      VAR	__temp, 1
      1  fa09		       00 c9	   __temp     =	TEMPORARY_VAR
      2  fa09				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fa09
      4  fa09				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fa09				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fa09				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fa09					      ENDIF
      8  fa09				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fa09				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  fa09				  -	      ERR
     11  fa09					      ENDIF
     12  fa09					      LIST	ON
      0  fa09					      VEND	PromoteWhitePawn
      1  fa09				  -	      IFNCONST	PromoteWhitePawn
      2  fa09				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  fa09				  -	      ERR
      4  fa09					      ENDIF
      5  fa09		       00 ca	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  fa09
      0  fa09					      PROMOTE_PAWN	WHITE
      1  fa09
      2  fa09
      3  fa09
      4  fa09
      5  fa09
      6  fa09		       84 c9		      sty	__temp
      7  fa0b		       a9 06		      lda	#WHITE|QUEEN
      8  fa0d		       85 92		      sta	currentPiece
      9  fa0f		       20 f6 fb 	      jsr	AddMove
     10  fa12
     11  fa12		       a9 05		      lda	#WHITE|ROOK
     12  fa14		       85 92		      sta	currentPiece
     13  fa16		       a4 c9		      ldy	__temp
     14  fa18		       20 f6 fb 	      jsr	AddMove
     15  fa1b
     16  fa1b		       a9 04		      lda	#WHITE|BISHOP
     17  fa1d		       85 92		      sta	currentPiece
     18  fa1f		       a4 c9		      ldy	__temp
     19  fa21		       20 f6 fb 	      jsr	AddMove
     20  fa24
     21  fa24		       a9 03		      lda	#WHITE|KNIGHT
     22  fa26		       85 92		      sta	currentPiece
     23  fa28		       a4 c9		      ldy	__temp
     24  fa2a		       20 f6 fb 	      jsr	AddMove
     25  fa2d
     26  fa2d					      IF	WHITE = WHITE
     27  fa2d		       a9 01		      lda	#WHITE|WP
     28  fa2f					      ENDIF
     29  fa2f				  -	      IF	WHITE = BLACK
     30  fa2f				  -	      lda	#BLACK|BP
     31  fa2f					      ENDIF
     32  fa2f		       85 92		      sta	currentPiece
    122  fa31		       60		      rts
    123  fa32
    124  fa32							;---------------------------------------------------------------------------------------------------
    125  fa32
      0  fa32					      DEF	Handle_WHITE_PAWN
      1  fa32				   BANK_Handle_WHITE_PAWN SET	_CURRENT_BANK
      2  fa32				   Handle_WHITE_PAWN
      3  fa32				   TEMPORARY_VAR SET	Overlay
      4  fa32				   TEMPORARY_OFFSET SET	0
      5  fa32				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      6  fa32				   FUNCTION_NAME SET	Handle_WHITE_PAWN
      7  fa32					      SUBROUTINE
    127  fa32					      SUBROUTINE
    128  fa32
      0  fa32					      REFER	GenerateAllMoves
      1  fa32					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  fa32				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  fa32					      ENDIF
      0  fa32					      VEND	Handle_WHITE_PAWN
      1  fa32				  -	      IFNCONST	Handle_WHITE_PAWN
      2  fa32				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  fa32				  -	      ERR
      4  fa32					      ENDIF
      5  fa32		       00 c9	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  fa32
    132  fa32		       bc 2a f0 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  fa35		       b9 84 f0 	      lda	Board,y
    134  fa38		       d0 26		      bne	.pMoved	; occupied
    135  fa3a		       85 9f		      sta	capture
    136  fa3c
    137  fa3c							; we may need to promote the pawn
    138  fa3c							; All possibilites (Q/R/B/N) are added as individual moves
    139  fa3c
      0  fa3c					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  fa3c
      2  fa3c
      3  fa3c
      4  fa3c					      IF	WHITE = WHITE
      5  fa3c		       c0 5a		      cpy	#90
      6  fa3e		       90 06		      bcc	.standard
      7  fa40		       20 09 fa 	      jsr	PromoteWhitePawn
      8  fa43		       4c 49 fa 	      jmp	.pMoved
      9  fa46					      ENDIF
     10  fa46
     11  fa46				  -	      IF	WHITE = BLACK
     12  fa46				  -	      cpy	#30
     13  fa46				  -	      bcs	.standard
     14  fa46				  -	      jsr	PromoteBlackPawn
     15  fa46				  -	      jmp	.pMoved
     16  fa46					      ENDIF
     17  fa46
     18  fa46		       20 f6 fb    .standard  jsr	AddMove
     19  fa49				   .pMoved
     20  fa49
    141  fa49
    142  fa49							; the +2 move off the home rank...
    143  fa49
    144  fa49		       a6 93		      ldx	currentSquare
    145  fa4b		       e0 28		      cpx	#WHITE_HOME_ROW
    146  fa4d		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  fa4f		       bc 34 f0 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  fa52		       b9 84 f0 	      lda	Board,y
    149  fa55		       d0 09		      bne	.pMoved	; destination square occupied
    150  fa57
    151  fa57		       a5 92		      lda	currentPiece
    152  fa59		       09 20		      ora	#FLAG_ENPASSANT
    153  fa5b		       85 92		      sta	currentPiece	; GENERATE en-passant opportunity
    154  fa5d
    155  fa5d		       20 f6 fb 	      jsr	AddMove	; add the +2UP move off home row
    156  fa60
    157  fa60				   .pMoved
    158  fa60
    159  fa60							; regular captures...
    160  fa60
      0  fa60					      TAKE	_UP+_LEFT, WHITE
      1  fa60
      2  fa60
      3  fa60
      4  fa60		       a6 93		      ldx	currentSquare
      5  fa62		       bc 29 f0 	      ldy	ValidSquare+_UP+_LEFT,x
      6  fa65		       30 1d		      bmi	.invalid2
      7  fa67		       b9 84 f0 	      lda	Board,y
      8  fa6a		       f0 18		      beq	.invalid2
      9  fa6c		       85 9f		      sta	capture
     10  fa6e		       45 92		      eor	currentPiece
     11  fa70		       10 10		      bpl	.invalid
     12  fa72
      0  fa72					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  fa72
      2  fa72
      3  fa72
      4  fa72					      IF	WHITE = WHITE
      5  fa72		       c0 5a		      cpy	#90
      6  fa74		       90 06		      bcc	.standard
      7  fa76		       20 09 fa 	      jsr	PromoteWhitePawn
      8  fa79		       4c 7f fa 	      jmp	.pMoved
      9  fa7c					      ENDIF
     10  fa7c
     11  fa7c				  -	      IF	WHITE = BLACK
     12  fa7c				  -	      cpy	#30
     13  fa7c				  -	      bcs	.standard
     14  fa7c				  -	      jsr	PromoteBlackPawn
     15  fa7c				  -	      jmp	.pMoved
     16  fa7c					      ENDIF
     17  fa7c
     18  fa7c		       20 f6 fb    .standard  jsr	AddMove
     19  fa7f				   .pMoved
     20  fa7f
     14  fa7f
     15  fa7f		       4c 84 fa 	      jmp	.invalid2
     16  fa82		       e6 a5	   .invalid   inc	protecting
     17  fa84				   .invalid2
      0  fa84					      TAKE	_UP+_RIGHT, WHITE
      1  fa84
      2  fa84
      3  fa84
      4  fa84		       a6 93		      ldx	currentSquare
      5  fa86		       bc 2b f0 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  fa89		       30 1d		      bmi	.invalid2
      7  fa8b		       b9 84 f0 	      lda	Board,y
      8  fa8e		       f0 18		      beq	.invalid2
      9  fa90		       85 9f		      sta	capture
     10  fa92		       45 92		      eor	currentPiece
     11  fa94		       10 10		      bpl	.invalid
     12  fa96
      0  fa96					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  fa96
      2  fa96
      3  fa96
      4  fa96					      IF	WHITE = WHITE
      5  fa96		       c0 5a		      cpy	#90
      6  fa98		       90 06		      bcc	.standard
      7  fa9a		       20 09 fa 	      jsr	PromoteWhitePawn
      8  fa9d		       4c a3 fa 	      jmp	.pMoved
      9  faa0					      ENDIF
     10  faa0
     11  faa0				  -	      IF	WHITE = BLACK
     12  faa0				  -	      cpy	#30
     13  faa0				  -	      bcs	.standard
     14  faa0				  -	      jsr	PromoteBlackPawn
     15  faa0				  -	      jmp	.pMoved
     16  faa0					      ENDIF
     17  faa0
     18  faa0		       20 f6 fb    .standard  jsr	AddMove
     19  faa3				   .pMoved
     20  faa3
     14  faa3
     15  faa3		       4c a8 fa 	      jmp	.invalid2
     16  faa6		       e6 a5	   .invalid   inc	protecting
     17  faa8				   .invalid2
    163  faa8
    164  faa8
    165  faa8				  -	      IF	ENPASSANT_ENABLED
    166  faa8				  -			; en-passant captures...
    167  faa8				  -
    168  faa8				  -	      lda	enPassantPawn
    169  faa8				  -	      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  faa8				  -
    171  faa8				  -	      lda	currentPiece
    172  faa8				  -	      ora	#FLAG_ENPASSANT
    173  faa8				  -	      sta	currentPiece	; CONSUME en-passant opportunity
    174  faa8				  -
    175  faa8				  -	      EN_PASSANT	_LEFT, _UP
    176  faa8				  -	      EN_PASSANT	_RIGHT, _UP
    177  faa8				  -
    178  faa8				  -.noEnPassant
    179  faa8					      ENDIF
    180  faa8
    181  faa8		       4c 2b f9 	      jmp	MoveReturn
    182  faab
    183  faab
    184  faab							;---------------------------------------------------------------------------------------------------
    185  faab							; BLACK PAWN
    186  faab							;---------------------------------------------------------------------------------------------------
    187  faab
      0  faab					      DEF	PromoteBlackPawn
      1  faab				   BANK_PromoteBlackPawn SET	_CURRENT_BANK
      2  faab				   PromoteBlackPawn
      3  faab				   TEMPORARY_VAR SET	Overlay
      4  faab				   TEMPORARY_OFFSET SET	0
      5  faab				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      6  faab				   FUNCTION_NAME SET	PromoteBlackPawn
      7  faab					      SUBROUTINE
    189  faab					      SUBROUTINE
    190  faab
      0  faab					      REFER	Handle_BLACK_PAWN
      1  faab					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  faab				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  faab					      ENDIF
      0  faab					      VAR	__temp, 1
      1  faab		       00 c9	   __temp     =	TEMPORARY_VAR
      2  faab				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  faab
      4  faab				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  faab				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  faab				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  faab					      ENDIF
      8  faab				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  faab				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  faab				  -	      ERR
     11  faab					      ENDIF
     12  faab					      LIST	ON
      0  faab					      VEND	PromoteBlackPawn
      1  faab				  -	      IFNCONST	PromoteBlackPawn
      2  faab				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  faab				  -	      ERR
      4  faab					      ENDIF
      5  faab		       00 ca	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  faab
      0  faab					      PROMOTE_PAWN	BLACK
      1  faab
      2  faab
      3  faab
      4  faab
      5  faab
      6  faab		       84 c9		      sty	__temp
      7  faad		       a9 86		      lda	#BLACK|QUEEN
      8  faaf		       85 92		      sta	currentPiece
      9  fab1		       20 f6 fb 	      jsr	AddMove
     10  fab4
     11  fab4		       a9 85		      lda	#BLACK|ROOK
     12  fab6		       85 92		      sta	currentPiece
     13  fab8		       a4 c9		      ldy	__temp
     14  faba		       20 f6 fb 	      jsr	AddMove
     15  fabd
     16  fabd		       a9 84		      lda	#BLACK|BISHOP
     17  fabf		       85 92		      sta	currentPiece
     18  fac1		       a4 c9		      ldy	__temp
     19  fac3		       20 f6 fb 	      jsr	AddMove
     20  fac6
     21  fac6		       a9 83		      lda	#BLACK|KNIGHT
     22  fac8		       85 92		      sta	currentPiece
     23  faca		       a4 c9		      ldy	__temp
     24  facc		       20 f6 fb 	      jsr	AddMove
     25  facf
     26  facf				  -	      IF	BLACK = WHITE
     27  facf				  -	      lda	#WHITE|WP
     28  facf					      ENDIF
     29  facf					      IF	BLACK = BLACK
     30  facf		       a9 82		      lda	#BLACK|BP
     31  fad1					      ENDIF
     32  fad1		       85 92		      sta	currentPiece
    196  fad3		       60		      rts
    197  fad4
      0  fad4					      DEF	Handle_BLACK_PAWN
      1  fad4				   BANK_Handle_BLACK_PAWN SET	_CURRENT_BANK
      2  fad4				   Handle_BLACK_PAWN
      3  fad4				   TEMPORARY_VAR SET	Overlay
      4  fad4				   TEMPORARY_OFFSET SET	0
      5  fad4				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      6  fad4				   FUNCTION_NAME SET	Handle_BLACK_PAWN
      7  fad4					      SUBROUTINE
    199  fad4					      SUBROUTINE
    200  fad4
      0  fad4					      REFER	GenerateAllMoves
      1  fad4					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  fad4				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  fad4					      ENDIF
      0  fad4					      VEND	Handle_BLACK_PAWN
      1  fad4				  -	      IFNCONST	Handle_BLACK_PAWN
      2  fad4				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  fad4				  -	      ERR
      4  fad4					      ENDIF
      5  fad4		       00 c9	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  fad4
    204  fad4		       bc 16 f0 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  fad7		       b9 84 f0 	      lda	Board,y
    206  fada		       d0 26		      bne	.pMoved	; occupied
    207  fadc		       85 9f		      sta	capture
    208  fade
    209  fade							; we may need to promote the pawn
    210  fade							; All possibilites (Q/R/B/N) are added as individual moves
    211  fade
      0  fade					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  fade
      2  fade
      3  fade
      4  fade				  -	      IF	BLACK = WHITE
      5  fade				  -	      cpy	#90
      6  fade				  -	      bcc	.standard
      7  fade				  -	      jsr	PromoteWhitePawn
      8  fade				  -	      jmp	.pMoved
      9  fade					      ENDIF
     10  fade
     11  fade					      IF	BLACK = BLACK
     12  fade		       c0 1e		      cpy	#30
     13  fae0		       b0 06		      bcs	.standard
     14  fae2		       20 ab fa 	      jsr	PromoteBlackPawn
     15  fae5		       4c eb fa 	      jmp	.pMoved
     16  fae8					      ENDIF
     17  fae8
     18  fae8		       20 f6 fb    .standard  jsr	AddMove
     19  faeb				   .pMoved
     20  faeb
    213  faeb
    214  faeb							; the +2 move off the home rank...
    215  faeb
    216  faeb		       a6 93		      ldx	currentSquare
    217  faed		       e0 52		      cpx	#BLACK_HOME_ROW
    218  faef		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  faf1
    220  faf1
    221  faf1		       bc 0c f0 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  faf4		       b9 84 f0 	      lda	Board,y
    223  faf7		       d0 09		      bne	.pMoved	; destination square occupied
    224  faf9
    225  faf9		       a5 92		      lda	currentPiece
    226  fafb		       09 20		      ora	#FLAG_ENPASSANT
    227  fafd		       85 92		      sta	currentPiece	; CAN en-passant
    228  faff
    229  faff		       20 f6 fb 	      jsr	AddMove	; add the +2DOWN move off home row
    230  fb02
    231  fb02				   .pMoved
    232  fb02
    233  fb02							; regular captures... (with promotion)
    234  fb02
      0  fb02					      TAKE	_DOWN+_LEFT, BLACK
      1  fb02
      2  fb02
      3  fb02
      4  fb02		       a6 93		      ldx	currentSquare
      5  fb04		       bc 15 f0 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  fb07		       30 1d		      bmi	.invalid2
      7  fb09		       b9 84 f0 	      lda	Board,y
      8  fb0c		       f0 18		      beq	.invalid2
      9  fb0e		       85 9f		      sta	capture
     10  fb10		       45 92		      eor	currentPiece
     11  fb12		       10 10		      bpl	.invalid
     12  fb14
      0  fb14					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  fb14
      2  fb14
      3  fb14
      4  fb14				  -	      IF	BLACK = WHITE
      5  fb14				  -	      cpy	#90
      6  fb14				  -	      bcc	.standard
      7  fb14				  -	      jsr	PromoteWhitePawn
      8  fb14				  -	      jmp	.pMoved
      9  fb14					      ENDIF
     10  fb14
     11  fb14					      IF	BLACK = BLACK
     12  fb14		       c0 1e		      cpy	#30
     13  fb16		       b0 06		      bcs	.standard
     14  fb18		       20 ab fa 	      jsr	PromoteBlackPawn
     15  fb1b		       4c 21 fb 	      jmp	.pMoved
     16  fb1e					      ENDIF
     17  fb1e
     18  fb1e		       20 f6 fb    .standard  jsr	AddMove
     19  fb21				   .pMoved
     20  fb21
     14  fb21
     15  fb21		       4c 26 fb 	      jmp	.invalid2
     16  fb24		       e6 a5	   .invalid   inc	protecting
     17  fb26				   .invalid2
      0  fb26					      TAKE	_DOWN+_RIGHT, BLACK
      1  fb26
      2  fb26
      3  fb26
      4  fb26		       a6 93		      ldx	currentSquare
      5  fb28		       bc 17 f0 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  fb2b		       30 1d		      bmi	.invalid2
      7  fb2d		       b9 84 f0 	      lda	Board,y
      8  fb30		       f0 18		      beq	.invalid2
      9  fb32		       85 9f		      sta	capture
     10  fb34		       45 92		      eor	currentPiece
     11  fb36		       10 10		      bpl	.invalid
     12  fb38
      0  fb38					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  fb38
      2  fb38
      3  fb38
      4  fb38				  -	      IF	BLACK = WHITE
      5  fb38				  -	      cpy	#90
      6  fb38				  -	      bcc	.standard
      7  fb38				  -	      jsr	PromoteWhitePawn
      8  fb38				  -	      jmp	.pMoved
      9  fb38					      ENDIF
     10  fb38
     11  fb38					      IF	BLACK = BLACK
     12  fb38		       c0 1e		      cpy	#30
     13  fb3a		       b0 06		      bcs	.standard
     14  fb3c		       20 ab fa 	      jsr	PromoteBlackPawn
     15  fb3f		       4c 45 fb 	      jmp	.pMoved
     16  fb42					      ENDIF
     17  fb42
     18  fb42		       20 f6 fb    .standard  jsr	AddMove
     19  fb45				   .pMoved
     20  fb45
     14  fb45
     15  fb45		       4c 4a fb 	      jmp	.invalid2
     16  fb48		       e6 a5	   .invalid   inc	protecting
     17  fb4a				   .invalid2
    237  fb4a
    238  fb4a
    239  fb4a				  -	      IF	ENPASSANT_ENABLED
    240  fb4a				  -			; en-passant captures...
    241  fb4a				  -
    242  fb4a				  -	      lda	enPassantPawn
    243  fb4a				  -	      beq	.noEnPassant	; was last move en-passantable?
    244  fb4a				  -
    245  fb4a				  -	      lda	currentPiece
    246  fb4a				  -	      ora	#FLAG_ENPASSANT
    247  fb4a				  -	      sta	currentPiece	; any en-passant move added will have flag set
    248  fb4a				  -
    249  fb4a				  -	      EN_PASSANT	_LEFT, _DOWN
    250  fb4a				  -	      EN_PASSANT	_RIGHT, _DOWN
    251  fb4a				  -
    252  fb4a				  -.noEnPassant
    253  fb4a					      ENDIF
    254  fb4a
    255  fb4a		       4c 2b f9 	      jmp	MoveReturn
    256  fb4d
    257  fb4d							; EOF
------- FILE BANK_FIXED.asm
------- FILE Handler_KNIGHT.asm LEVEL 3 PASS 5
      0  fb4d					      include	"Handler_KNIGHT.asm"
      1  fb4d							; Copyright (C)2020 Andrew Davie
      2  fb4d							; Knight move handler
      3  fb4d
      4  fb4d							;---------------------------------------------------------------------------------------------------
      5  fb4d							; KNIGHT
      6  fb4d							;---------------------------------------------------------------------------------------------------
      7  fb4d
      0  fb4d					      DEF	Handle_KNIGHT
      1  fb4d				   BANK_Handle_KNIGHT SET	_CURRENT_BANK
      2  fb4d				   Handle_KNIGHT
      3  fb4d				   TEMPORARY_VAR SET	Overlay
      4  fb4d				   TEMPORARY_OFFSET SET	0
      5  fb4d				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      6  fb4d				   FUNCTION_NAME SET	Handle_KNIGHT
      7  fb4d					      SUBROUTINE
      9  fb4d					      SUBROUTINE
     10  fb4d
      0  fb4d					      REFER	GenerateAllMoves
      1  fb4d					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  fb4d				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  fb4d					      ENDIF
      0  fb4d					      VEND	Handle_KNIGHT
      1  fb4d				  -	      IFNCONST	Handle_KNIGHT
      2  fb4d				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  fb4d				  -	      ERR
      4  fb4d					      ENDIF
      5  fb4d		       00 c9	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  fb4d
     14  fb4d							; x = currentSquare (square the piece is on)
     15  fb4d							; currentPiece (with flags/colour attached)
     16  fb4d
      0  fb4d					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  fb4d					      SUBROUTINE
      2  fb4d		       bc 0b f0 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  fb50		       30 0e		      bmi	.invalid
      4  fb52		       b9 84 f0 	      lda	Board,y
      5  fb55		       85 9f		      sta	capture
      6  fb57		       f0 04		      beq	.squareEmpty
      7  fb59		       45 92		      eor	currentPiece
      8  fb5b		       10 03		      bpl	.invalid
      9  fb5d		       20 f6 fb    .squareEmpty jsr	AddMove
     10  fb60				   .invalid
      0  fb60					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  fb60		       a6 93		      ldx	currentSquare
      0  fb62					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  fb62					      SUBROUTINE
      2  fb62		       bc 0d f0 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  fb65		       30 0e		      bmi	.invalid
      4  fb67		       b9 84 f0 	      lda	Board,y
      5  fb6a		       85 9f		      sta	capture
      6  fb6c		       f0 04		      beq	.squareEmpty
      7  fb6e		       45 92		      eor	currentPiece
      8  fb70		       10 03		      bpl	.invalid
      9  fb72		       20 f6 fb    .squareEmpty jsr	AddMove
     10  fb75				   .invalid
      0  fb75					      MOVE_TO_X	_UP+_UP+_LEFT
      1  fb75		       a6 93		      ldx	currentSquare
      0  fb77					      MOVE_TO	_UP+_UP+_LEFT
      1  fb77					      SUBROUTINE
      2  fb77		       bc 33 f0 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  fb7a		       30 0e		      bmi	.invalid
      4  fb7c		       b9 84 f0 	      lda	Board,y
      5  fb7f		       85 9f		      sta	capture
      6  fb81		       f0 04		      beq	.squareEmpty
      7  fb83		       45 92		      eor	currentPiece
      8  fb85		       10 03		      bpl	.invalid
      9  fb87		       20 f6 fb    .squareEmpty jsr	AddMove
     10  fb8a				   .invalid
      0  fb8a					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  fb8a		       a6 93		      ldx	currentSquare
      0  fb8c					      MOVE_TO	_UP+_UP+_RIGHT
      1  fb8c					      SUBROUTINE
      2  fb8c		       bc 35 f0 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  fb8f		       30 0e		      bmi	.invalid
      4  fb91		       b9 84 f0 	      lda	Board,y
      5  fb94		       85 9f		      sta	capture
      6  fb96		       f0 04		      beq	.squareEmpty
      7  fb98		       45 92		      eor	currentPiece
      8  fb9a		       10 03		      bpl	.invalid
      9  fb9c		       20 f6 fb    .squareEmpty jsr	AddMove
     10  fb9f				   .invalid
     21  fb9f
      0  fb9f					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  fb9f		       a6 93		      ldx	currentSquare
      0  fba1					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  fba1					      SUBROUTINE
      2  fba1		       bc 14 f0 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  fba4		       30 0e		      bmi	.invalid
      4  fba6		       b9 84 f0 	      lda	Board,y
      5  fba9		       85 9f		      sta	capture
      6  fbab		       f0 04		      beq	.squareEmpty
      7  fbad		       45 92		      eor	currentPiece
      8  fbaf		       10 03		      bpl	.invalid
      9  fbb1		       20 f6 fb    .squareEmpty jsr	AddMove
     10  fbb4				   .invalid
      0  fbb4					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  fbb4		       a6 93		      ldx	currentSquare
      0  fbb6					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  fbb6					      SUBROUTINE
      2  fbb6		       bc 18 f0 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  fbb9		       30 0e		      bmi	.invalid
      4  fbbb		       b9 84 f0 	      lda	Board,y
      5  fbbe		       85 9f		      sta	capture
      6  fbc0		       f0 04		      beq	.squareEmpty
      7  fbc2		       45 92		      eor	currentPiece
      8  fbc4		       10 03		      bpl	.invalid
      9  fbc6		       20 f6 fb    .squareEmpty jsr	AddMove
     10  fbc9				   .invalid
      0  fbc9					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  fbc9		       a6 93		      ldx	currentSquare
      0  fbcb					      MOVE_TO	_UP+_LEFT+_LEFT
      1  fbcb					      SUBROUTINE
      2  fbcb		       bc 28 f0 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  fbce		       30 0e		      bmi	.invalid
      4  fbd0		       b9 84 f0 	      lda	Board,y
      5  fbd3		       85 9f		      sta	capture
      6  fbd5		       f0 04		      beq	.squareEmpty
      7  fbd7		       45 92		      eor	currentPiece
      8  fbd9		       10 03		      bpl	.invalid
      9  fbdb		       20 f6 fb    .squareEmpty jsr	AddMove
     10  fbde				   .invalid
      0  fbde					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  fbde		       a6 93		      ldx	currentSquare
      0  fbe0					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  fbe0					      SUBROUTINE
      2  fbe0		       bc 2c f0 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  fbe3		       30 0e		      bmi	.invalid
      4  fbe5		       b9 84 f0 	      lda	Board,y
      5  fbe8		       85 9f		      sta	capture
      6  fbea		       f0 04		      beq	.squareEmpty
      7  fbec		       45 92		      eor	currentPiece
      8  fbee		       10 03		      bpl	.invalid
      9  fbf0		       20 f6 fb    .squareEmpty jsr	AddMove
     10  fbf3				   .invalid
     26  fbf3
     27  fbf3		       4c 2b f9 	      jmp	MoveReturn
     28  fbf6
     29  fbf6							; EOF
------- FILE BANK_FIXED.asm
    593  fbf6
    594  fbf6							;---------------------------------------------------------------------------------------------------
    595  fbf6
      0  fbf6					      DEF	AddMove
      1  fbf6				   BANK_AddMove SET	_CURRENT_BANK
      2  fbf6				   AddMove
      3  fbf6				   TEMPORARY_VAR SET	Overlay
      4  fbf6				   TEMPORARY_OFFSET SET	0
      5  fbf6				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      6  fbf6				   FUNCTION_NAME SET	AddMove
      7  fbf6					      SUBROUTINE
    597  fbf6					      SUBROUTINE
    598  fbf6
      0  fbf6					      VEND	AddMove
      1  fbf6				  -	      IFNCONST	AddMove
      2  fbf6				  -	      ECHO	"Incorrect VEND label", AddMove
      3  fbf6				  -	      ERR
      4  fbf6					      ENDIF
      5  fbf6		       00 a7	   VAREND_AddMove =	TEMPORARY_VAR
    600  fbf6
    601  fbf6							; =57 including call
    602  fbf6
    603  fbf6							; add square in y register to movelist as destination (X12 format)
    604  fbf6							; [y]		     to square (X12)
    605  fbf6							; currentSquare     from square (X12)
    606  fbf6							; currentPiece      piece.
    607  fbf6							;   ENPASSANT flag set if pawn double-moving off opening rank
    608  fbf6							; capture	     captured piece
    609  fbf6
    610  fbf6		       a5 9f		      lda	capture
    611  fbf8		       d0 04		      bne	.always
    612  fbfa		       a5 b2		      lda	__quiesceCapOnly
    613  fbfc		       d0 0c		      bne	.abort
    614  fbfe
    615  fbfe		       a5 95	   .always    lda	currentPly
    616  fc00		       85 3e		      sta	SET_BANK_RAM
    617  fc02		       20 bc f3 	      jsr	AddMovePly
    618  fc05		       a9 09		      lda	#RAMBANK_BOARD
    619  fc07		       85 3e		      sta	SET_BANK_RAM
    620  fc09		       60		      rts
    621  fc0a
    622  fc0a		       98	   .abort     tya
    623  fc0b		       aa		      tax
    624  fc0c		       60		      rts
    625  fc0d
    626  fc0d							;---------------------------------------------------------------------------------------------------
    627  fc0d
      0  fc0d					      DEF	InitialisePieceSquares
      1  fc0d				   BANK_InitialisePieceSquares SET	_CURRENT_BANK
      2  fc0d				   InitialisePieceSquares
      3  fc0d				   TEMPORARY_VAR SET	Overlay
      4  fc0d				   TEMPORARY_OFFSET SET	0
      5  fc0d				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      6  fc0d				   FUNCTION_NAME SET	InitialisePieceSquares
      7  fc0d					      SUBROUTINE
    629  fc0d					      SUBROUTINE
    630  fc0d
      0  fc0d					      REFER	Reset
      1  fc0d				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  fc0d				  -TEMPORARY_VAR SET	VAREND_Reset
      3  fc0d					      ENDIF
      0  fc0d					      VAR	__initPiece, 1
      1  fc0d		       00 a7	   __initPiece =	TEMPORARY_VAR
      2  fc0d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fc0d
      4  fc0d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fc0d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fc0d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fc0d					      ENDIF
      8  fc0d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fc0d				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  fc0d				  -	      ERR
     11  fc0d					      ENDIF
     12  fc0d					      LIST	ON
      0  fc0d					      VAR	__initSquare, 1
      1  fc0d		       00 a8	   __initSquare =	TEMPORARY_VAR
      2  fc0d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fc0d
      4  fc0d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fc0d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fc0d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fc0d					      ENDIF
      8  fc0d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fc0d				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  fc0d				  -	      ERR
     11  fc0d					      ENDIF
     12  fc0d					      LIST	ON
      0  fc0d					      VAR	__initListPtr, 1
      1  fc0d		       00 a9	   __initListPtr =	TEMPORARY_VAR
      2  fc0d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fc0d
      4  fc0d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fc0d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fc0d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fc0d					      ENDIF
      8  fc0d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fc0d				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  fc0d				  -	      ERR
     11  fc0d					      ENDIF
     12  fc0d					      LIST	ON
      0  fc0d					      VEND	InitialisePieceSquares
      1  fc0d				  -	      IFNCONST	InitialisePieceSquares
      2  fc0d				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  fc0d				  -	      ERR
      4  fc0d					      ENDIF
      5  fc0d		       00 aa	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    636  fc0d
      0  fc0d					      JSROM	InitPieceLists
      1  fc0d
      2  fc0d		       a9 00		      lda	#BANK_InitPieceLists
      3  fc0f		       85 3f		      sta	SET_BANK
      4  fc11		       20 3b f1 	      jsr	InitPieceLists
    638  fc14
    639  fc14		       a2 00		      ldx	#0
    640  fc16		       86 94		      stx	enPassantPawn	; no en-passant
    641  fc18							;stx maxPly
    642  fc18
    643  fc18							; Now setup the board/piecelists
    644  fc18
    645  fc18				   .fillPieceLists
    646  fc18		       a9 0b		      lda	#BANK_InitPieceList
    647  fc1a		       85 3f		      sta	SET_BANK
    648  fc1c
    649  fc1c		       bd 00 f0 	      lda	InitPieceList,x	; colour/-1
    650  fc1f		       f0 4c		      beq	.exit
    651  fc21		       85 b5		      sta	__originalPiece	; type
    652  fc23
    653  fc23		       bc 01 f0 	      ldy	InitPieceList+1,x	; square
    654  fc26		       84 a8		      sty	__initSquare
    655  fc28		       a9 09		      lda	#RAMBANK_BOARD
    656  fc2a		       85 3e		      sta	SET_BANK_RAM
    657  fc2c		       a5 b5		      lda	__originalPiece
      0  fc2e					      sta@RAM	Board,y
      1  fc2e		       99 84 f4 	      sta	[RAM]+Board,y
    659  fc31
    660  fc31		       10 0d		      bpl	.white
      0  fc33					      NEGEVAL
      1  fc33
      2  fc33		       38		      sec
      3  fc34		       a9 00		      lda	#0
      4  fc36		       e5 90		      sbc	Evaluation
      5  fc38		       85 90		      sta	Evaluation
      6  fc3a		       a9 00		      lda	#0
      7  fc3c		       e5 91		      sbc	Evaluation+1
      8  fc3e		       85 91		      sta	Evaluation+1
    662  fc40				   .white
    663  fc40
    664  fc40							; Add the material value of the piece to the evaluation
    665  fc40
    666  fc40		       a5 b5		      lda	__originalPiece
    667  fc42							;and #PIECE_MASK
    668  fc42							;tay
    669  fc42
    670  fc42							;		      ldy #BANK_AddPieceMaterialValue
    671  fc42							;		      sty SET_BANK
    672  fc42		       a9 12		      lda	#RAMBANK_BANK_EVAL	;BANK_AddPiecePositionValue
    673  fc44		       85 3e		      sta	SET_BANK_RAM
    674  fc46		       20 28 f0 	      jsr	AddPieceMaterialValue
    675  fc49
    676  fc49		       86 a9		      stx	__initListPtr
    677  fc4b
    678  fc4b							; add the positional value of the piece to the evaluation
    679  fc4b
    680  fc4b		       a4 a8		      ldy	__initSquare
    681  fc4d		       a5 b5		      lda	__originalPiece
    682  fc4f
    683  fc4f		       a2 0e		      ldx	#BANK_AddPiecePositionValue
    684  fc51		       86 3f		      stx	SET_BANK
    685  fc53		       20 3b f0 	      jsr	AddPiecePositionValue
    686  fc56
    687  fc56
    688  fc56
    689  fc56		       a5 b5		      lda	__originalPiece	; type/colour
    690  fc58		       10 0d		      bpl	.white2
      0  fc5a					      NEGEVAL
      1  fc5a
      2  fc5a		       38		      sec
      3  fc5b		       a9 00		      lda	#0
      4  fc5d		       e5 90		      sbc	Evaluation
      5  fc5f		       85 90		      sta	Evaluation
      6  fc61		       a9 00		      lda	#0
      7  fc63		       e5 91		      sbc	Evaluation+1
      8  fc65		       85 91		      sta	Evaluation+1
    692  fc67				   .white2
    693  fc67
    694  fc67		       a6 a9		      ldx	__initListPtr
    695  fc69		       e8		      inx
    696  fc6a		       e8		      inx
    697  fc6b		       10 ab		      bpl	.fillPieceLists
    698  fc6d
    699  fc6d				   .exit
    700  fc6d
    701  fc6d
    702  fc6d		       20 d2 f8 	      jsr	ListPlayerMoves
    703  fc70		       60		      rts
    704  fc71
    705  fc71
    706  fc71							;---------------------------------------------------------------------------------------------------
    707  fc71
      0  fc71					      DEF	GetValid
      1  fc71				   BANK_GetValid SET	_CURRENT_BANK
      2  fc71				   GetValid
      3  fc71				   TEMPORARY_VAR SET	Overlay
      4  fc71				   TEMPORARY_OFFSET SET	0
      5  fc71				   VAR_BOUNDARY_GetValid SET	TEMPORARY_OFFSET
      6  fc71				   FUNCTION_NAME SET	GetValid
      7  fc71					      SUBROUTINE
    709  fc71		       a9 09		      lda	#RAMBANK_BOARD
    710  fc73		       85 3e		      sta	SET_BANK_RAM
    711  fc75		       b9 20 f0 	      lda	ValidSquare,y
    712  fc78		       a4 8b		      ldy	savedBank
    713  fc7a		       84 3f		      sty	SET_BANK
    714  fc7c		       60		      rts
    715  fc7d
    716  fc7d
    717  fc7d							;---------------------------------------------------------------------------------------------------
    718  fc7d
      0  fc7d					      DEF	GetBoard
      1  fc7d				   BANK_GetBoard SET	_CURRENT_BANK
      2  fc7d				   GetBoard
      3  fc7d				   TEMPORARY_VAR SET	Overlay
      4  fc7d				   TEMPORARY_OFFSET SET	0
      5  fc7d				   VAR_BOUNDARY_GetBoard SET	TEMPORARY_OFFSET
      6  fc7d				   FUNCTION_NAME SET	GetBoard
      7  fc7d					      SUBROUTINE
    720  fc7d		       a9 09		      lda	#RAMBANK_BOARD
    721  fc7f		       85 3e		      sta	SET_BANK_RAM
    722  fc81		       b9 84 f0 	      lda	Board,y
    723  fc84		       a4 8b		      ldy	savedBank
    724  fc86		       84 3f		      sty	SET_BANK
    725  fc88		       60		      rts
    726  fc89
      0  fc89					      DEF	GetBoardRAM
      1  fc89				   BANK_GetBoardRAM SET	_CURRENT_BANK
      2  fc89				   GetBoardRAM
      3  fc89				   TEMPORARY_VAR SET	Overlay
      4  fc89				   TEMPORARY_OFFSET SET	0
      5  fc89				   VAR_BOUNDARY_GetBoardRAM SET	TEMPORARY_OFFSET
      6  fc89				   FUNCTION_NAME SET	GetBoardRAM
      7  fc89					      SUBROUTINE
    728  fc89		       a9 09		      lda	#RAMBANK_BOARD
    729  fc8b		       85 3e		      sta	SET_BANK_RAM
    730  fc8d		       b9 84 f0 	      lda	Board,y
    731  fc90		       a4 8b		      ldy	savedBank
    732  fc92		       84 3e		      sty	SET_BANK_RAM
    733  fc94		       60		      rts
    734  fc95
    735  fc95							;---------------------------------------------------------------------------------------------------
    736  fc95
      0  fc95					      DEF	PutBoard
      1  fc95				   BANK_PutBoard SET	_CURRENT_BANK
      2  fc95				   PutBoard
      3  fc95				   TEMPORARY_VAR SET	Overlay
      4  fc95				   TEMPORARY_OFFSET SET	0
      5  fc95				   VAR_BOUNDARY_PutBoard SET	TEMPORARY_OFFSET
      6  fc95				   FUNCTION_NAME SET	PutBoard
      7  fc95					      SUBROUTINE
    738  fc95		       a2 09		      ldx	#RAMBANK_BOARD
    739  fc97		       86 3e		      stx	SET_BANK_RAM
      0  fc99					      sta@RAM	Board,y	; and what's actually moving there
      1  fc99		       99 84 f4 	      sta	[RAM]+Board,y
    741  fc9c		       a6 8b		      ldx	savedBank
    742  fc9e		       86 3f		      stx	SET_BANK
    743  fca0		       60		      rts
    744  fca1
    745  fca1
    746  fca1							;---------------------------------------------------------------------------------------------------
    747  fca1
      0  fca1					      DEF	IsValidP_MoveFromSquare
      1  fca1				   BANK_IsValidP_MoveFromSquare SET	_CURRENT_BANK
      2  fca1				   IsValidP_MoveFromSquare
      3  fca1				   TEMPORARY_VAR SET	Overlay
      4  fca1				   TEMPORARY_OFFSET SET	0
      5  fca1				   VAR_BOUNDARY_IsValidP_MoveFromSquare SET	TEMPORARY_OFFSET
      6  fca1				   FUNCTION_NAME SET	IsValidP_MoveFromSquare
      7  fca1					      SUBROUTINE
    749  fca1					      SUBROUTINE
    750  fca1
      0  fca1					      REFER	aiSelectStartSquare
      1  fca1				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  fca1				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  fca1					      ENDIF
      0  fca1					      VEND	IsValidP_MoveFromSquare
      1  fca1				  -	      IFNCONST	IsValidP_MoveFromSquare
      2  fca1				  -	      ECHO	"Incorrect VEND label", IsValidP_MoveFromSquare
      3  fca1				  -	      ERR
      4  fca1					      ENDIF
      5  fca1		       00 a7	   VAREND_IsValidP_MoveFromSquare =	TEMPORARY_VAR
    753  fca1
    754  fca1							; Does the square exist in the movelist?
    755  fca1							; Return: y = -1 if NOT FOUND
    756  fca1
    757  fca1		       a5 88		      lda	cursorX12
    758  fca3		       85 85		      sta	fromX12
    759  fca5
    760  fca5		       a4 95		      ldy	currentPly
    761  fca7		       84 3e		      sty	SET_BANK_RAM
    762  fca9		       20 74 f1 	      jsr	CheckMoveListFromSquare
    763  fcac
    764  fcac		       a5 8b		      lda	savedBank
    765  fcae		       85 3f		      sta	SET_BANK
    766  fcb0		       60		      rts
    767  fcb1
    768  fcb1
    769  fcb1							;---------------------------------------------------------------------------------------------------
    770  fcb1
      0  fcb1					      DEF	GetPiece
      1  fcb1				   BANK_GetPiece SET	_CURRENT_BANK
      2  fcb1				   GetPiece
      3  fcb1				   TEMPORARY_VAR SET	Overlay
      4  fcb1				   TEMPORARY_OFFSET SET	0
      5  fcb1				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      6  fcb1				   FUNCTION_NAME SET	GetPiece
      7  fcb1					      SUBROUTINE
    772  fcb1					      SUBROUTINE
    773  fcb1
      0  fcb1					      REFER	aiSelectDestinationSquare
      1  fcb1				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  fcb1				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  fcb1					      ENDIF
      0  fcb1					      REFER	aiQuiescent
      1  fcb1				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  fcb1				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  fcb1					      ENDIF
      0  fcb1					      VEND	GetPiece
      1  fcb1				  -	      IFNCONST	GetPiece
      2  fcb1				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  fcb1				  -	      ERR
      4  fcb1					      ENDIF
      5  fcb1		       00 a7	   VAREND_GetPiece =	TEMPORARY_VAR
    777  fcb1
    778  fcb1							; Retrieve the piece+flags from the movelist, given from/to squares
    779  fcb1							; Required as moves have different flags but same origin squares (e.g., castling)
    780  fcb1
    781  fcb1		       a5 95		      lda	currentPly
    782  fcb3		       85 3e		      sta	SET_BANK_RAM
    783  fcb5
    784  fcb5		       20 88 f1 	      jsr	GetPieceGivenFromToSquares
    785  fcb8
    786  fcb8		       a5 8b		      lda	savedBank
    787  fcba		       85 3f		      sta	SET_BANK
    788  fcbc		       60		      rts
    789  fcbd
    790  fcbd
    791  fcbd							;---------------------------------------------------------------------------------------------------
    792  fcbd
    793  fcbd
      0  fcbd					      DEF	CopyShadowROMtoRAM
      1  fcbd				   BANK_CopyShadowROMtoRAM SET	_CURRENT_BANK
      2  fcbd				   CopyShadowROMtoRAM
      3  fcbd				   TEMPORARY_VAR SET	Overlay
      4  fcbd				   TEMPORARY_OFFSET SET	0
      5  fcbd				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      6  fcbd				   FUNCTION_NAME SET	CopyShadowROMtoRAM
      7  fcbd					      SUBROUTINE
    795  fcbd					      SUBROUTINE
    796  fcbd
      0  fcbd					      REFER	SetupBanks
      1  fcbd					      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  fcbd				   TEMPORARY_VAR SET	VAREND_SetupBanks
      3  fcbd					      ENDIF
      0  fcbd					      VAR	__destinationBank, 1
      1  fcbd		       00 a8	   __destinationBank =	TEMPORARY_VAR
      2  fcbd				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fcbd
      4  fcbd				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fcbd				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fcbd				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fcbd					      ENDIF
      8  fcbd				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fcbd				  -	      ECHO	"Temporary Variable", __destinationBank, "overflow!"
     10  fcbd				  -	      ERR
     11  fcbd					      ENDIF
     12  fcbd					      LIST	ON
      0  fcbd					      VAR	__sourceBank, 1
      1  fcbd		       00 a9	   __sourceBank =	TEMPORARY_VAR
      2  fcbd				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fcbd
      4  fcbd				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fcbd				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fcbd				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fcbd					      ENDIF
      8  fcbd				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fcbd				  -	      ECHO	"Temporary Variable", __sourceBank, "overflow!"
     10  fcbd				  -	      ERR
     11  fcbd					      ENDIF
     12  fcbd					      LIST	ON
      0  fcbd					      VEND	CopyShadowROMtoRAM
      1  fcbd				  -	      IFNCONST	CopyShadowROMtoRAM
      2  fcbd				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  fcbd				  -	      ERR
      4  fcbd					      ENDIF
      5  fcbd		       00 aa	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    801  fcbd
    802  fcbd							; Copy a whole 1K ROM SHADOW into a destination RAM 1K bank
    803  fcbd							; used to setup callable RAM code from ROM templates
    804  fcbd
    805  fcbd							; x = source ROM bank
    806  fcbd							; y = destination RAM bank (preserved)
    807  fcbd
    808  fcbd		       86 a9		      stx	__sourceBank
    809  fcbf
    810  fcbf		       a2 00		      ldx	#0
    811  fcc1		       a5 a9	   .copyPage  lda	__sourceBank
    812  fcc3		       85 3f		      sta	SET_BANK
    813  fcc5
    814  fcc5		       bd 00 f0 	      lda	$F000,x
    815  fcc8		       48		      pha
    816  fcc9		       bd 00 f1 	      lda	$F100,x
    817  fccc		       48		      pha
    818  fccd		       bd 00 f2 	      lda	$F200,x
    819  fcd0		       48		      pha
    820  fcd1		       bd 00 f3 	      lda	$F300,x
    821  fcd4
    822  fcd4		       84 3e		      sty	SET_BANK_RAM
    823  fcd6
      0  fcd6					      sta@RAM	$F300,x
      1  fcd6		       9d 00 f7 	      sta	[RAM]+$F300,x
    825  fcd9		       68		      pla
      0  fcda					      sta@RAM	$F200,x
      1  fcda		       9d 00 f6 	      sta	[RAM]+$F200,x
    827  fcdd		       68		      pla
      0  fcde					      sta@RAM	$F100,x
      1  fcde		       9d 00 f5 	      sta	[RAM]+$F100,x
    829  fce1		       68		      pla
      0  fce2					      sta@RAM	$F000,x
      1  fce2		       9d 00 f4 	      sta	[RAM]+$F000,x
    831  fce5
    832  fce5		       ca		      dex
    833  fce6		       d0 d9		      bne	.copyPage
    834  fce8
    835  fce8		       a5 8b		      lda	savedBank
    836  fcea		       85 3f		      sta	SET_BANK
    837  fcec		       60		      rts
    838  fced
    839  fced
    840  fced							;---------------------------------------------------------------------------------------------------
    841  fced
      0  fced					      DEF	CopySinglePiece
      1  fced				   BANK_CopySinglePiece SET	_CURRENT_BANK
      2  fced				   CopySinglePiece
      3  fced				   TEMPORARY_VAR SET	Overlay
      4  fced				   TEMPORARY_OFFSET SET	0
      5  fced				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      6  fced				   FUNCTION_NAME SET	CopySinglePiece
      7  fced					      SUBROUTINE
    843  fced					      SUBROUTINE
      0  fced					      TIMING	COPYSINGLEPIECE, (2600)
      1  fced		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    845  fced
      0  fced					      REFER	aiDrawEntireBoard
      1  fced				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  fced					      ENDIF
      0  fced					      REFER	aiSpecialMoveFixup
      1  fced					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  fced				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  fced					      ENDIF
      0  fced					      REFER	aiWriteStartPieceBlank
      1  fced				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  fced					      ENDIF
      0  fced					      REFER	aiDrawPart2
      1  fced				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  fced					      ENDIF
      0  fced					      REFER	aiMarchB
      1  fced				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  fced					      ENDIF
      0  fced					      REFER	aiFinalFlash
      1  fced				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  fced					      ENDIF
      0  fced					      REFER	UNSAFE_showMoveCaptures
      1  fced				  -	      IF	VAREND_UNSAFE_showMoveCaptures > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_UNSAFE_showMoveCaptures
      3  fced					      ENDIF
      0  fced					      REFER	aiMarchToTargetA
      1  fced				  -	      IF	VAREND_aiMarchToTargetA > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetA
      3  fced					      ENDIF
      0  fced					      REFER	aiMarchB2
      1  fced				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  fced					      ENDIF
      0  fced					      REFER	aiMarchToTargetB
      1  fced				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  fced					      ENDIF
      0  fced					      REFER	aiSelectDestinationSquare
      1  fced				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  fced					      ENDIF
      0  fced					      REFER	aiPromotePawnStart
      1  fced				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  fced					      ENDIF
      0  fced					      REFER	aiChoosePromotePiece
      1  fced				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  fced				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  fced					      ENDIF
      0  fced					      VEND	CopySinglePiece
      1  fced				  -	      IFNCONST	CopySinglePiece
      2  fced				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  fced				  -	      ERR
      4  fced					      ENDIF
      5  fced		       00 b3	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    860  fced
    861  fced							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    862  fced							; ALSO CAN'T USE IN THIS ROUTINE
    863  fced							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    864  fced							; @2150 max
    865  fced							; = 33 TIM64T
    866  fced
      0  fced					      JSROM	CopySetup
      1  fced
      2  fced		       a9 0b		      lda	#BANK_CopySetup
      3  fcef		       85 3f		      sta	SET_BANK
      4  fcf1		       20 75 f1 	      jsr	CopySetup
    868  fcf4
      0  fcf4					      DEF	InterceptMarkerCopy
      1  fcf4				   BANK_InterceptMarkerCopy SET	_CURRENT_BANK
      2  fcf4				   InterceptMarkerCopy
      3  fcf4				   TEMPORARY_VAR SET	Overlay
      4  fcf4				   TEMPORARY_OFFSET SET	0
      5  fcf4				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      6  fcf4				   FUNCTION_NAME SET	InterceptMarkerCopy
      7  fcf4					      SUBROUTINE
    870  fcf4					      SUBROUTINE
    871  fcf4
    872  fcf4
    873  fcf4							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    874  fcf4							; y = piece index
    875  fcf4
    876  fcf4		       a9 00		      lda	#BANK_PIECE_VECTOR_BANK
    877  fcf6		       85 3f		      sta	SET_BANK
    878  fcf8
    879  fcf8		       b9 54 f1 	      lda	PIECE_VECTOR_LO,y
    880  fcfb		       85 ef		      sta	__ptr
    881  fcfd		       b9 e4 f1 	      lda	PIECE_VECTOR_HI,y
    882  fd00		       85 f0		      sta	__ptr+1
    883  fd02		       b9 74 f2 	      lda	PIECE_VECTOR_BANK,y
    884  fd05		       85 3f		      sta	SET_BANK
    885  fd07
    886  fd07		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    887  fd09		       b1 ef	   .copy      lda	(__ptr),y
    888  fd0b		       99 a7 00 	      sta	__pieceShapeBuffer,y
    889  fd0e		       88		      dey
    890  fd0f		       10 f8		      bpl	.copy
    891  fd11
    892  fd11		       a5 80		      lda	squareToDraw
    893  fd13		       38		      sec
    894  fd14		       a2 0a		      ldx	#10
    895  fd16		       e9 0a	   .sub10     sbc	#10
    896  fd18		       ca		      dex
    897  fd19		       b0 fb		      bcs	.sub10
    898  fd1b
    899  fd1b		       86 3e		      stx	SET_BANK_RAM	; row
    900  fd1d
    901  fd1d		       69 08		      adc	#8
    902  fd1f		       c9 04		      cmp	#4	; CS = right side of screen
    903  fd21
    904  fd21		       20 9b f1 	      jsr	CopyPieceToRowBitmap
    905  fd24
    906  fd24		       a5 8b		      lda	savedBank
    907  fd26		       85 3f		      sta	SET_BANK
    908  fd28		       60		      rts
    909  fd29
    910  fd29
    911  fd29							;---------------------------------------------------------------------------------------------------
    912  fd29
      0  fd29					      DEF	SAFE_getMoveIndex
      1  fd29				   BANK_SAFE_getMoveIndex SET	_CURRENT_BANK
      2  fd29				   SAFE_getMoveIndex
      3  fd29				   TEMPORARY_VAR SET	Overlay
      4  fd29				   TEMPORARY_OFFSET SET	0
      5  fd29				   VAR_BOUNDARY_SAFE_getMoveIndex SET	TEMPORARY_OFFSET
      6  fd29				   FUNCTION_NAME SET	SAFE_getMoveIndex
      7  fd29					      SUBROUTINE
    914  fd29					      SUBROUTINE
    915  fd29
    916  fd29		       a9 0b		      lda	#RAMBANK_PLY+1
    917  fd2b		       85 3e		      sta	SET_BANK_RAM
      0  fd2d					      lda@PLY	moveIndex
      1  fd2d		       ad 51 f1 	      lda	moveIndex
    919  fd30		       a6 8b		      ldx	savedBank
    920  fd32		       86 3f		      stx	SET_BANK
    921  fd34		       60		      rts
    922  fd35
    923  fd35
    924  fd35							;---------------------------------------------------------------------------------------------------
    925  fd35
      0  fd35					      DEF	markerDraw
      1  fd35				   BANK_markerDraw SET	_CURRENT_BANK
      2  fd35				   markerDraw
      3  fd35				   TEMPORARY_VAR SET	Overlay
      4  fd35				   TEMPORARY_OFFSET SET	0
      5  fd35				   VAR_BOUNDARY_markerDraw SET	TEMPORARY_OFFSET
      6  fd35				   FUNCTION_NAME SET	markerDraw
      7  fd35					      SUBROUTINE
    927  fd35					      SUBROUTINE
    928  fd35
      0  fd35					      REFER	SAFE_showMoveOptions
      1  fd35					      IF	VAREND_SAFE_showMoveOptions > TEMPORARY_VAR
      2  fd35				   TEMPORARY_VAR SET	VAREND_SAFE_showMoveOptions
      3  fd35					      ENDIF
      0  fd35					      VEND	markerDraw
      1  fd35				  -	      IFNCONST	markerDraw
      2  fd35				  -	      ECHO	"Incorrect VEND label", markerDraw
      3  fd35				  -	      ERR
      4  fd35					      ENDIF
      5  fd35		       00 a9	   VAREND_markerDraw =	TEMPORARY_VAR
    931  fd35
    932  fd35		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
      0  fd37					      JSROM	CopySetupForMarker
      1  fd37
      2  fd37		       a9 0b		      lda	#BANK_CopySetupForMarker
      3  fd39		       85 3f		      sta	SET_BANK
      4  fd3b		       20 4a f1 	      jsr	CopySetupForMarker
    934  fd3e		       4c f4 fc 	      jmp	InterceptMarkerCopy
    935  fd41
    936  fd41
    937  fd41							;---------------------------------------------------------------------------------------------------
    938  fd41
      0  fd41					      DEF	showPromoteOptions
      1  fd41				   BANK_showPromoteOptions SET	_CURRENT_BANK
      2  fd41				   showPromoteOptions
      3  fd41				   TEMPORARY_VAR SET	Overlay
      4  fd41				   TEMPORARY_OFFSET SET	0
      5  fd41				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      6  fd41				   FUNCTION_NAME SET	showPromoteOptions
      7  fd41					      SUBROUTINE
    940  fd41					      SUBROUTINE
    941  fd41
      0  fd41					      REFER	aiRollPromotionPiece
      1  fd41				  -	      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  fd41				  -TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  fd41					      ENDIF
      0  fd41					      REFER	aiChoosePromotePiece
      1  fd41				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  fd41				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  fd41					      ENDIF
      0  fd41					      VEND	showPromoteOptions
      1  fd41				  -	      IFNCONST	showPromoteOptions
      2  fd41				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  fd41				  -	      ERR
      4  fd41					      ENDIF
      5  fd41		       00 a7	   VAREND_showPromoteOptions =	TEMPORARY_VAR
    945  fd41
    946  fd41							; X = character shape # (?/N/B/R/Q)
    947  fd41
    948  fd41		       a4 86		      ldy	toX12
    949  fd43		       84 80		      sty	squareToDraw
    950  fd45
      0  fd45					      JSROM	CopySetupForMarker
      1  fd45
      2  fd45		       a9 0b		      lda	#BANK_CopySetupForMarker
      3  fd47		       85 3f		      sta	SET_BANK
      4  fd49		       20 4a f1 	      jsr	CopySetupForMarker
    952  fd4c		       4c f4 fc 	      jmp	InterceptMarkerCopy
    953  fd4f
    954  fd4f
    955  fd4f							;---------------------------------------------------------------------------------------------------
    956  fd4f
      0  fd4f					      DEF	SAFE_BackupBitmaps
      1  fd4f				   BANK_SAFE_BackupBitmaps SET	_CURRENT_BANK
      2  fd4f				   SAFE_BackupBitmaps
      3  fd4f				   TEMPORARY_VAR SET	Overlay
      4  fd4f				   TEMPORARY_OFFSET SET	0
      5  fd4f				   VAR_BOUNDARY_SAFE_BackupBitmaps SET	TEMPORARY_OFFSET
      6  fd4f				   FUNCTION_NAME SET	SAFE_BackupBitmaps
      7  fd4f					      SUBROUTINE
    958  fd4f					      SUBROUTINE
    959  fd4f
      0  fd4f					      VEND	SAFE_BackupBitmaps
      1  fd4f				  -	      IFNCONST	SAFE_BackupBitmaps
      2  fd4f				  -	      ECHO	"Incorrect VEND label", SAFE_BackupBitmaps
      3  fd4f				  -	      ERR
      4  fd4f					      ENDIF
      5  fd4f		       00 a7	   VAREND_SAFE_BackupBitmaps =	TEMPORARY_VAR
    961  fd4f
    962  fd4f		       84 3e		      sty	SET_BANK_RAM
    963  fd51		       20 f4 f2 	      jsr	SaveBitmap
    964  fd54		       a5 8b		      lda	savedBank
    965  fd56		       85 3f		      sta	SET_BANK
    966  fd58		       60		      rts
    967  fd59
    968  fd59
    969  fd59							;---------------------------------------------------------------------------------------------------
    970  fd59
      0  fd59					      DEF	SAFE_showMoveCaptures
      1  fd59				   BANK_SAFE_showMoveCaptures SET	_CURRENT_BANK
      2  fd59				   SAFE_showMoveCaptures
      3  fd59				   TEMPORARY_VAR SET	Overlay
      4  fd59				   TEMPORARY_OFFSET SET	0
      5  fd59				   VAR_BOUNDARY_SAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      6  fd59				   FUNCTION_NAME SET	SAFE_showMoveCaptures
      7  fd59					      SUBROUTINE
    972  fd59					      SUBROUTINE
    973  fd59
      0  fd59					      VEND	SAFE_showMoveCaptures
      1  fd59				  -	      IFNCONST	SAFE_showMoveCaptures
      2  fd59				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveCaptures
      3  fd59				  -	      ERR
      4  fd59					      ENDIF
      5  fd59		       00 a7	   VAREND_SAFE_showMoveCaptures =	TEMPORARY_VAR
    975  fd59
      0  fd59					      JSROM	UNSAFE_showMoveCaptures
      1  fd59
      2  fd59		       a9 0b		      lda	#BANK_UNSAFE_showMoveCaptures
      3  fd5b		       85 3f		      sta	SET_BANK
      4  fd5d		       20 41 f0 	      jsr	UNSAFE_showMoveCaptures
    977  fd60		       a5 8b		      lda	savedBank
    978  fd62		       85 3f		      sta	SET_BANK
    979  fd64		       60		      rts
    980  fd65
    981  fd65
    982  fd65							;---------------------------------------------------------------------------------------------------
    983  fd65
      0  fd65					      DEF	GetP_MoveFrom
      1  fd65				   BANK_GetP_MoveFrom SET	_CURRENT_BANK
      2  fd65				   GetP_MoveFrom
      3  fd65				   TEMPORARY_VAR SET	Overlay
      4  fd65				   TEMPORARY_OFFSET SET	0
      5  fd65				   VAR_BOUNDARY_GetP_MoveFrom SET	TEMPORARY_OFFSET
      6  fd65				   FUNCTION_NAME SET	GetP_MoveFrom
      7  fd65					      SUBROUTINE
    985  fd65		       a9 0b		      lda	#RAMBANK_PLY+1
    986  fd67		       85 3e		      sta	SET_BANK_RAM
    987  fd69		       a4 8b		      ldy	savedBank
      0  fd6b					      lda@PLY	MoveFrom,x
      1  fd6b		       bd 02 f0 	      lda	MoveFrom,x
    989  fd6e		       84 3f		      sty	SET_BANK
    990  fd70		       60		      rts
    991  fd71
    992  fd71
    993  fd71							;---------------------------------------------------------------------------------------------------
    994  fd71
      0  fd71					      DEF	GetP_MoveTo
      1  fd71				   BANK_GetP_MoveTo SET	_CURRENT_BANK
      2  fd71				   GetP_MoveTo
      3  fd71				   TEMPORARY_VAR SET	Overlay
      4  fd71				   TEMPORARY_OFFSET SET	0
      5  fd71				   VAR_BOUNDARY_GetP_MoveTo SET	TEMPORARY_OFFSET
      6  fd71				   FUNCTION_NAME SET	GetP_MoveTo
      7  fd71					      SUBROUTINE
    996  fd71					      SUBROUTINE
    997  fd71
    998  fd71		       a9 0b		      lda	#RAMBANK_PLY+1
    999  fd73		       85 3e		      sta	SET_BANK_RAM
   1000  fd75		       a4 8b		      ldy	savedBank
      0  fd77					      lda@PLY	MoveTo,x
      1  fd77		       bd 48 f0 	      lda	MoveTo,x
   1002  fd7a		       84 3f		      sty	SET_BANK
   1003  fd7c		       60		      rts
   1004  fd7d
   1005  fd7d
   1006  fd7d							;---------------------------------------------------------------------------------------------------
   1007  fd7d
      0  fd7d					      DEF	GetP_MovePiece
      1  fd7d				   BANK_GetP_MovePiece SET	_CURRENT_BANK
      2  fd7d				   GetP_MovePiece
      3  fd7d				   TEMPORARY_VAR SET	Overlay
      4  fd7d				   TEMPORARY_OFFSET SET	0
      5  fd7d				   VAR_BOUNDARY_GetP_MovePiece SET	TEMPORARY_OFFSET
      6  fd7d				   FUNCTION_NAME SET	GetP_MovePiece
      7  fd7d					      SUBROUTINE
   1009  fd7d					      SUBROUTINE
   1010  fd7d
   1011  fd7d		       a9 0b		      lda	#RAMBANK_PLY+1
   1012  fd7f		       85 3e		      sta	SET_BANK_RAM
   1013  fd81		       a4 8b		      ldy	savedBank
      0  fd83					      lda@PLY	MovePiece,x
      1  fd83		       bd 8e f0 	      lda	MovePiece,x
   1015  fd86		       84 3f		      sty	SET_BANK
   1016  fd88		       60		      rts
   1017  fd89
   1018  fd89
   1019  fd89							;---------------------------------------------------------------------------------------------------
   1020  fd89
      0  fd89					      DEF	MakeMove
      1  fd89				   BANK_MakeMove SET	_CURRENT_BANK
      2  fd89				   MakeMove
      3  fd89				   TEMPORARY_VAR SET	Overlay
      4  fd89				   TEMPORARY_OFFSET SET	0
      5  fd89				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      6  fd89				   FUNCTION_NAME SET	MakeMove
      7  fd89					      SUBROUTINE
   1022  fd89					      SUBROUTINE
   1023  fd89
      0  fd89					      REFER	negaMax
      1  fd89					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  fd89				   TEMPORARY_VAR SET	VAREND_negaMax
      3  fd89					      ENDIF
      0  fd89					      VAR	__capture, 1
      1  fd89		       00 b3	   __capture  =	TEMPORARY_VAR
      2  fd89				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fd89
      4  fd89				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fd89				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fd89				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fd89					      ENDIF
      8  fd89				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fd89				  -	      ECHO	"Temporary Variable", __capture, "overflow!"
     10  fd89				  -	      ERR
     11  fd89					      ENDIF
     12  fd89					      LIST	ON
      0  fd89					      VAR	__restore, 1
      1  fd89		       00 b4	   __restore  =	TEMPORARY_VAR
      2  fd89				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fd89
      4  fd89				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fd89				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fd89				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fd89					      ENDIF
      8  fd89				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fd89				  -	      ECHO	"Temporary Variable", __restore, "overflow!"
     10  fd89				  -	      ERR
     11  fd89					      ENDIF
     12  fd89					      LIST	ON
      0  fd89					      VEND	MakeMove
      1  fd89				  -	      IFNCONST	MakeMove
      2  fd89				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  fd89				  -	      ERR
      4  fd89					      ENDIF
      5  fd89		       00 b5	   VAREND_MakeMove =	TEMPORARY_VAR
   1028  fd89
   1029  fd89							; Do a move without any GUI stuff
   1030  fd89							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
   1031  fd89							; and all relevant flags in original state. This is NOT used for the visible move on the
   1032  fd89							; screen.
   1033  fd89
   1034  fd89
   1035  fd89							; fromPiece	 piece doing the move
   1036  fd89							; fromX12	 current square X12
   1037  fd89							; originX12	 starting square X12
   1038  fd89							; toX12	 ending square X12
   1039  fd89
   1040  fd89
   1041  fd89							; There are potentially "two" moves, with the following
   1042  fd89							; a) Castling, moving both rook and king
   1043  fd89							; b) en-Passant, capturing pawn on "odd" square
   1044  fd89							; These both set "secondary" movers which are used for restoring during unmakeMove
   1045  fd89
   1046  fd89		       a9 00		      lda	#0
      0  fd8b					      sta@PLY	secondaryPiece
      1  fd8b		       8d 4c f5 	      sta	[RAM]+secondaryPiece
   1048  fd8e
      0  fd8e					      ldx@PLY	movePtr
      1  fd8e		       ae 52 f1 	      ldx	movePtr
      0  fd91					      lda@PLY	MoveFrom,x
      1  fd91		       bd 02 f0 	      lda	MoveFrom,x
   1051  fd94		       85 85		      sta	fromX12
   1052  fd96		       85 87		      sta	originX12
      0  fd98					      lda@PLY	MoveTo,x
      1  fd98		       bd 48 f0 	      lda	MoveTo,x
   1054  fd9b		       85 86		      sta	toX12
      0  fd9d					      lda@PLY	MovePiece,x
      1  fd9d		       bd 8e f0 	      lda	MovePiece,x
   1056  fda0		       85 98		      sta	fromPiece
   1057  fda2
   1058  fda2		       20 82 f9    .move      jsr	AdjustMaterialPositionalValue
   1059  fda5
   1060  fda5							; Modify the board
   1061  fda5
   1062  fda5		       a0 09		      ldy	#RAMBANK_BOARD
   1063  fda7		       84 3e		      sty	SET_BANK_RAM
   1064  fda9		       a4 87		      ldy	originX12
      0  fdab					      lda@RAM	Board,y
      1  fdab		       b9 84 f0 	      lda	Board,y
   1066  fdae		       85 b4		      sta	__restore
   1067  fdb0		       a9 00		      lda	#0
      0  fdb2					      sta@RAM	Board,y
      1  fdb2		       99 84 f4 	      sta	[RAM]+Board,y
   1069  fdb5		       a4 86		      ldy	toX12
      0  fdb7					      lda@RAM	Board,y
      1  fdb7		       b9 84 f0 	      lda	Board,y
   1071  fdba		       85 b3		      sta	__capture
   1072  fdbc		       a5 98		      lda	fromPiece
   1073  fdbe		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
   1074  fdc0		       09 40		      ora	#FLAG_MOVED
      0  fdc2					      sta@RAM	Board,y
      1  fdc2		       99 84 f4 	      sta	[RAM]+Board,y
   1076  fdc5
   1077  fdc5		       a5 95		      lda	currentPly
   1078  fdc7		       85 3e		      sta	SET_BANK_RAM
   1079  fdc9		       a5 b3		      lda	__capture
      0  fdcb					      sta@PLY	capturedPiece
      1  fdcb		       8d 4a f5 	      sta	[RAM]+capturedPiece
   1081  fdce		       a5 b4		      lda	__restore
      0  fdd0					      sta@PLY	restorePiece
      1  fdd0		       8d 5b f5 	      sta	[RAM]+restorePiece
   1083  fdd3
   1084  fdd3					      IF	CASTLING_ENABLED
   1085  fdd3
   1086  fdd3							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
   1087  fdd3							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
   1088  fdd3							; redo the moving code (for the rook, this time).
   1089  fdd3
   1090  fdd3		       20 f4 f1 	      jsr	GenCastleMoveForRook
   1091  fdd6		       b0 ca		      bcs	.move	; move the rook!
   1092  fdd8					      ENDIF
   1093  fdd8
   1094  fdd8
   1095  fdd8				  -	      IF	ENPASSANT_ENABLED
   1096  fdd8				  -	      JSROM	EnPassantCheck
   1097  fdd8				  -	      beq	.notEnPassant
   1098  fdd8				  -EPK	      jsr	EnPassantRemovePiece	; y = origin X12
   1099  fdd8				  -.notEnPassant
   1100  fdd8					      ENDIF
   1101  fdd8
   1102  fdd8							; Swap over sides
   1103  fdd8
      0  fdd8					      NEGEVAL
      1  fdd8
      2  fdd8		       38		      sec
      3  fdd9		       a9 00		      lda	#0
      4  fddb		       e5 90		      sbc	Evaluation
      5  fddd		       85 90		      sta	Evaluation
      6  fddf		       a9 00		      lda	#0
      7  fde1		       e5 91		      sbc	Evaluation+1
      8  fde3		       85 91		      sta	Evaluation+1
      0  fde5					      SWAP
      1  fde5		       a5 97		      lda	sideToMove
      2  fde7		       49 81		      eor	#SWAP_SIDE
      3  fde9		       85 97		      sta	sideToMove
   1106  fdeb
   1107  fdeb		       a5 95		      lda	currentPly
   1108  fded		       85 3e		      sta	SET_BANK_RAM
   1109  fdef		       60		      rts
   1110  fdf0
   1111  fdf0
   1112  fdf0							;---------------------------------------------------------------------------------------------------
   1113  fdf0
      0  fdf0					      DEF	unmakeMove
      1  fdf0				   BANK_unmakeMove SET	_CURRENT_BANK
      2  fdf0				   unmakeMove
      3  fdf0				   TEMPORARY_VAR SET	Overlay
      4  fdf0				   TEMPORARY_OFFSET SET	0
      5  fdf0				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      6  fdf0				   FUNCTION_NAME SET	unmakeMove
      7  fdf0					      SUBROUTINE
   1115  fdf0					      SUBROUTINE
   1116  fdf0
      0  fdf0					      REFER	negaMax
      1  fdf0					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  fdf0				   TEMPORARY_VAR SET	VAREND_negaMax
      3  fdf0					      ENDIF
      0  fdf0					      VAR	__unmake_capture, 1
      1  fdf0		       00 b3	   __unmake_capture =	TEMPORARY_VAR
      2  fdf0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fdf0
      4  fdf0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fdf0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fdf0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fdf0					      ENDIF
      8  fdf0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fdf0				  -	      ECHO	"Temporary Variable", __unmake_capture, "overflow!"
     10  fdf0				  -	      ERR
     11  fdf0					      ENDIF
     12  fdf0					      LIST	ON
      0  fdf0					      VAR	__secondaryBlank, 1
      1  fdf0		       00 b4	   __secondaryBlank =	TEMPORARY_VAR
      2  fdf0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fdf0
      4  fdf0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fdf0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fdf0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fdf0					      ENDIF
      8  fdf0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fdf0				  -	      ECHO	"Temporary Variable", __secondaryBlank, "overflow!"
     10  fdf0				  -	      ERR
     11  fdf0					      ENDIF
     12  fdf0					      LIST	ON
      0  fdf0					      VEND	unmakeMove
      1  fdf0				  -	      IFNCONST	unmakeMove
      2  fdf0				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  fdf0				  -	      ERR
      4  fdf0					      ENDIF
      5  fdf0		       00 b5	   VAREND_unmakeMove =	TEMPORARY_VAR
   1121  fdf0
   1122  fdf0							; restore the board evaluation to what it was at the start of this ply
   1123  fdf0							; TODO: note: moved flag seems wrong on restoration
   1124  fdf0
   1125  fdf0		       ad 00 f0 	      lda	savedEvaluation
   1126  fdf3		       85 90		      sta	Evaluation
   1127  fdf5		       ad 01 f0 	      lda	savedEvaluation+1
   1128  fdf8		       85 91		      sta	Evaluation+1
   1129  fdfa
   1130  fdfa		       ae 52 f1 	      ldx	movePtr
      0  fdfd					      lda@PLY	MoveFrom,x
      1  fdfd		       bd 02 f0 	      lda	MoveFrom,x
   1132  fe00		       85 85		      sta	fromX12
   1133  fe02		       bc 48 f0 	      ldy	MoveTo,x
   1134  fe05
   1135  fe05		       ad 5b f1 	      lda	restorePiece
   1136  fe08		       48		      pha
   1137  fe09		       ad 4a f1 	      lda	capturedPiece
   1138  fe0c
   1139  fe0c		       a2 09		      ldx	#RAMBANK_BOARD
   1140  fe0e		       86 3e		      stx	SET_BANK_RAM
      0  fe10					      sta@RAM	Board,y
      1  fe10		       99 84 f4 	      sta	[RAM]+Board,y
   1142  fe13		       a4 85		      ldy	fromX12
   1143  fe15		       68		      pla
      0  fe16					      sta@RAM	Board,y
      1  fe16		       99 84 f4 	      sta	[RAM]+Board,y
   1145  fe19
   1146  fe19
   1147  fe19		       a5 95		      lda	currentPly
   1148  fe1b		       85 3e		      sta	SET_BANK_RAM
   1149  fe1d
   1150  fe1d							; See if there are any 'secondary' pieces that moved
   1151  fe1d							; here we're dealing with reverting a castling or enPassant move
   1152  fe1d
      0  fe1d					      lda@PLY	secondaryPiece
      1  fe1d		       ad 4c f1 	      lda	secondaryPiece
   1154  fe20		       f0 1a		      beq	.noSecondary
      0  fe22					      ldy@PLY	secondaryBlank
      1  fe22		       ac 4e f1 	      ldy	secondaryBlank
   1156  fe25		       84 b4		      sty	__secondaryBlank
      0  fe27					      ldy@PLY	secondarySquare
      1  fe27		       ac 4d f1 	      ldy	secondarySquare
   1158  fe2a
   1159  fe2a
   1160  fe2a		       a2 09		      ldx	#RAMBANK_BOARD
   1161  fe2c		       86 3e		      stx	SET_BANK_RAM
      0  fe2e					      sta@RAM	Board,y	; put piece back
      1  fe2e		       99 84 f4 	      sta	[RAM]+Board,y
   1163  fe31
   1164  fe31		       a4 b4		      ldy	__secondaryBlank
   1165  fe33		       a9 00		      lda	#0
      0  fe35					      sta@RAM	Board,y	; blank piece origin
      1  fe35		       99 84 f4 	      sta	[RAM]+Board,y
   1167  fe38
   1168  fe38		       a5 95		      lda	currentPly
   1169  fe3a		       85 3e		      sta	SET_BANK_RAM
   1170  fe3c
   1171  fe3c
   1172  fe3c				   .noSecondary
      0  fe3c					      SWAP
      1  fe3c		       a5 97		      lda	sideToMove
      2  fe3e		       49 81		      eor	#SWAP_SIDE
      3  fe40		       85 97		      sta	sideToMove
   1174  fe42		       60		      rts
   1175  fe43
   1176  fe43
   1177  fe43							;---------------------------------------------------------------------------------------------------
   1178  fe43
   1179  fe43							;function negaMax(node, depth, α, β, color) is
   1180  fe43							;    if depth = 0 or node is a terminal node then
   1181  fe43							;	  return color × the heuristic value of node
   1182  fe43
   1183  fe43							;    childNodes := generateMoves(node)
   1184  fe43							;    childNodes := orderMoves(childNodes)
   1185  fe43							;    value := −∞
   1186  fe43							;    foreach child in childNodes do
   1187  fe43							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
   1188  fe43							;	  α := max(α, value)
   1189  fe43							;	  if α ≥ β then
   1190  fe43							;	      break (* cut-off *)
   1191  fe43							;    return value
   1192  fe43							;(* Initial call for Player A's root node *)
   1193  fe43							;negaMax(rootNode, depth, −∞, +∞, 1)
   1194  fe43
   1195  fe43
   1196  fe43					      SUBROUTINE
   1197  fe43
   1198  fe43				   .doQ
   1199  fe43
   1200  fe43							; PARAMS depth-1, -beta, -alpha
   1201  fe43							; pased through temporary variables (__alpha, __beta) and X reg
   1202  fe43
   1203  fe43		       a9 ff		      lda	#-1
   1204  fe45		       85 b2		      sta	__quiesceCapOnly
   1205  fe47		       20 ba f2 	      jsr	quiesce
   1206  fe4a		       e6 b2		      inc	__quiesceCapOnly
   1207  fe4c
   1208  fe4c		       4c 67 fe 	      jmp	.jiggle
   1209  fe4f
      0  fe4f				   .exit      lda@PLY	value
      1  fe4f		       ad 58 f1 	      lda	value
   1211  fe52		       85 ae		      sta	__negaMax
      0  fe54					      lda@PLY	value+1
      1  fe54		       ad 59 f1 	      lda	value+1
   1213  fe57		       85 af		      sta	__negaMax+1
   1214  fe59		       60		      rts
   1215  fe5a
   1216  fe5a				   .terminal
   1217  fe5a		       c9 00		      cmp	#0	; captured piece
   1218  fe5c		       d0 e5		      bne	.doQ	; last move was capture, so quiesce
   1219  fe5e
   1220  fe5e
   1221  fe5e
   1222  fe5e		       a5 90		      lda	Evaluation
   1223  fe60		       85 ae		      sta	__negaMax
   1224  fe62		       a5 91		      lda	Evaluation+1
   1225  fe64		       85 af		      sta	__negaMax+1
   1226  fe66
   1227  fe66
   1228  fe66
   1229  fe66
   1230  fe66		       60		      rts
   1231  fe67
   1232  fe67				   .jiggle
   1233  fe67
   1234  fe67		       38		      sec
   1235  fe68		       a5 ae		      lda	__negaMax
   1236  fe6a		       e9 00		      sbc	#0
   1237  fe6c		       85 ae		      sta	__negaMax
   1238  fe6e		       a5 af		      lda	__negaMax+1
   1239  fe70		       e9 00		      sbc	#0
   1240  fe72		       85 af		      sta	__negaMax+1
   1241  fe74		       60		      rts
   1242  fe75
   1243  fe75		       a9 18	   .inCheck2  lda	#<(INFINITY-1000)
   1244  fe77		       85 ae		      sta	__negaMax
   1245  fe79		       a9 18		      lda	#<(INFINITY-1000)
   1246  fe7b		       85 af		      sta	__negaMax+1
   1247  fe7d		       60		      rts
   1248  fe7e
   1249  fe7e
   1250  fe7e
   1251  fe7e				   spP1
   1252  fe7e		       c1		      .byte.b	%11000001
   1253  fe7f		       60		      .byte.b	%01100000
   1254  fe80		       30		      .byte.b	%00110000
   1255  fe81		       18		      .byte.b	%00011000
   1256  fe82		       0c		      .byte.b	%00001100
   1257  fe83		       06		      .byte.b	%00000110
   1258  fe84		       83		      .byte.b	%10000011
   1259  fe85		       c1		      .byte.b	%11000001
   1260  fe86
   1261  fe86		       83		      .byte.b	%10000011
   1262  fe87		       06		      .byte.b	%00000110
   1263  fe88		       0c		      .byte.b	%00001100
   1264  fe89		       18		      .byte.b	%00011000
   1265  fe8a		       30		      .byte.b	%00110000
   1266  fe8b		       60		      .byte.b	%01100000
   1267  fe8c		       c1		      .byte.b	%11000001
   1268  fe8d		       83		      .byte.b	%10000011
   1269  fe8e
   1270  fe8e
      0  fe8e					      DEF	negaMax
      1  fe8e				   BANK_negaMax SET	_CURRENT_BANK
      2  fe8e				   negaMax
      3  fe8e				   TEMPORARY_VAR SET	Overlay
      4  fe8e				   TEMPORARY_OFFSET SET	0
      5  fe8e				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      6  fe8e				   FUNCTION_NAME SET	negaMax
      7  fe8e					      SUBROUTINE
   1272  fe8e
   1273  fe8e							; pass...
   1274  fe8e							; x = depthleft
   1275  fe8e							; a = captured piece
   1276  fe8e							; SET_BANK_RAM      --> current ply
   1277  fe8e							; __alpha[2] = param alpha
   1278  fe8e							; __beta[2] = param beta
   1279  fe8e
   1280  fe8e
      0  fe8e					      COMMON_VARS_ALPHABETA
      1  fe8e
      0  fe8e					      VAR	__thinkbar, 1
      1  fe8e		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  fe8e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fe8e
      4  fe8e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe8e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe8e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe8e					      ENDIF
      8  fe8e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe8e				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  fe8e				  -	      ERR
     11  fe8e					      ENDIF
     12  fe8e					      LIST	ON
      0  fe8e					      VAR	__toggle, 1
      1  fe8e		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  fe8e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fe8e
      4  fe8e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe8e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe8e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe8e					      ENDIF
      8  fe8e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe8e				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  fe8e				  -	      ERR
     11  fe8e					      ENDIF
     12  fe8e					      LIST	ON
      4  fe8e
      0  fe8e					      VAR	__bestMove, 1
      1  fe8e		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  fe8e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fe8e
      4  fe8e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe8e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe8e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe8e					      ENDIF
      8  fe8e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe8e				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  fe8e				  -	      ERR
     11  fe8e					      ENDIF
     12  fe8e					      LIST	ON
      0  fe8e					      VAR	__alpha, 2
      1  fe8e		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  fe8e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  fe8e
      4  fe8e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe8e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe8e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe8e					      ENDIF
      8  fe8e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe8e				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  fe8e				  -	      ERR
     11  fe8e					      ENDIF
     12  fe8e					      LIST	ON
      0  fe8e					      VAR	__beta, 2
      1  fe8e		       00 ac	   __beta     =	TEMPORARY_VAR
      2  fe8e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  fe8e
      4  fe8e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe8e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe8e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe8e					      ENDIF
      8  fe8e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe8e				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  fe8e				  -	      ERR
     11  fe8e					      ENDIF
     12  fe8e					      LIST	ON
      0  fe8e					      VAR	__negaMax, 2
      1  fe8e		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  fe8e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  fe8e
      4  fe8e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe8e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe8e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe8e					      ENDIF
      8  fe8e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe8e				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  fe8e				  -	      ERR
     11  fe8e					      ENDIF
     12  fe8e					      LIST	ON
      0  fe8e					      VAR	__value, 2
      1  fe8e		       00 b0	   __value    =	TEMPORARY_VAR
      2  fe8e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  fe8e
      4  fe8e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe8e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe8e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe8e					      ENDIF
      8  fe8e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe8e				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  fe8e				  -	      ERR
     11  fe8e					      ENDIF
     12  fe8e					      LIST	ON
     10  fe8e
      0  fe8e					      VAR	__quiesceCapOnly, 1
      1  fe8e		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  fe8e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fe8e
      4  fe8e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe8e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe8e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe8e					      ENDIF
      8  fe8e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe8e				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  fe8e				  -	      ERR
     11  fe8e					      ENDIF
     12  fe8e					      LIST	ON
     12  fe8e
      0  fe8e					      REFER	selectmove
      1  fe8e				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  fe8e				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  fe8e					      ENDIF
      0  fe8e					      VEND	negaMax
      1  fe8e				  -	      IFNCONST	negaMax
      2  fe8e				  -	      ECHO	"Incorrect VEND label", negaMax
      3  fe8e				  -	      ERR
      4  fe8e					      ENDIF
      5  fe8e		       00 b3	   VAREND_negaMax =	TEMPORARY_VAR
   1284  fe8e
   1285  fe8e
   1286  fe8e
   1287  fe8e		       e6 a1		      inc	positionCount
   1288  fe90		       d0 06		      bne	.p1
   1289  fe92		       e6 a2		      inc	positionCount+1
   1290  fe94		       d0 02		      bne	.p1
   1291  fe96		       e6 a3		      inc	positionCount+2
   1292  fe98				   .p1
   1293  fe98
   1294  fe98							; The 'thinkbar' pattern...
   1295  fe98
   1296  fe98		       a5 a1		      lda	positionCount
   1297  fe9a		       29 0f		      and	#15
   1298  fe9c		       a8		      tay
   1299  fe9d		       b9 7e fe 	      lda	spP1,y
   1300  fea0		       85 4f		      sta	PF2
   1301  fea2		       85 4e		      sta	PF1
   1302  fea4		       85 4d		      sta	PF0
   1303  fea6
   1304  fea6
   1305  fea6		       a5 a2		      lda	positionCount+1
   1306  fea8		       0a		      asl
   1307  fea9		       0a		      asl
   1308  feaa		       0a		      asl
   1309  feab		       0a		      asl
   1310  feac		       09 02		      ora	#2
   1311  feae		       85 48		      sta	COLUPF
   1312  feb0
   1313  feb0							;^
   1314  feb0
   1315  feb0		       ca		      dex
   1316  feb1		       30 a7		      bmi	.terminal
      0  feb3					      stx@PLY	depthLeft
      1  feb3		       8e 5a f5 	      stx	[RAM]+depthLeft
   1318  feb6
   1319  feb6							; Allow the player to force computer to select a move. Press the SELECT switch
   1320  feb6							; This may have issues if no move has been selected yet. Still... if you wanna cheat....
   1321  feb6
   1322  feb6		       ad 82 02 	      lda	SWCHB
   1323  feb9		       29 02		      and	#2
   1324  febb		       f0 92		      beq	.exit	; SELECT abort
   1325  febd
   1326  febd
   1327  febd
   1328  febd					      IF	1
      0  febd					      NEXT_RANDOM		; for jiggle
      1  febd		       a5 81		      lda	rnd
      2  febf		       4a		      lsr
      3  fec0		       90 02		      bcc	.skipEOR
      4  fec2		       49 fe		      eor	#RND_EOR_VAL
      5  fec4		       85 81	   .skipEOR   sta	rnd
   1330  fec6		       29 0f		      and	#15
   1331  fec8		       65 90		      adc	Evaluation
   1332  feca		       85 90		      sta	Evaluation
   1333  fecc		       a5 91		      lda	Evaluation+1
   1334  fece		       69 00		      adc	#0
   1335  fed0		       85 91		      sta	Evaluation+1
   1336  fed2					      ENDIF
   1337  fed2
   1338  fed2
   1339  fed2		       a5 aa		      lda	__alpha
      0  fed4					      sta@PLY	alpha
      1  fed4		       8d 54 f5 	      sta	[RAM]+alpha
   1341  fed7		       a5 ab		      lda	__alpha+1
      0  fed9					      sta@PLY	alpha+1
      1  fed9		       8d 55 f5 	      sta	[RAM]+alpha+1
   1343  fedc
   1344  fedc		       a5 ac		      lda	__beta
      0  fede					      sta@PLY	beta
      1  fede		       8d 56 f5 	      sta	[RAM]+beta
   1346  fee1		       a5 ad		      lda	__beta+1
      0  fee3					      sta@PLY	beta+1
      1  fee3		       8d 57 f5 	      sta	[RAM]+beta+1
   1348  fee6
   1349  fee6		       20 07 f9 	      jsr	GenerateAllMoves
   1350  fee9							;lda flagCheck
   1351  fee9							;bne .inCheck2 			  ; OTHER guy in check
   1352  fee9
   1353  fee9
   1354  fee9					      IF	1
   1355  fee9							;clc
      0  fee9					      lda@PLY	moveIndex
      1  fee9		       ad 51 f1 	      lda	moveIndex
   1357  feec		       30 0e		      bmi	.none
      0  feee					      adc@PLY	savedEvaluation
      1  feee		       6d 00 f0 	      adc	savedEvaluation
      0  fef1					      sta@PLY	savedEvaluation
      1  fef1		       8d 00 f4 	      sta	[RAM]+savedEvaluation
      0  fef4					      lda@PLY	savedEvaluation+1
      1  fef4		       ad 01 f0 	      lda	savedEvaluation+1
   1361  fef7		       69 00		      adc	#0
      0  fef9					      sta@PLY	savedEvaluation+1	; + mobility (kind of odd/bad - happens every level)
      1  fef9		       8d 01 f4 	      sta	[RAM]+savedEvaluation+1
   1363  fefc				   .none
   1364  fefc					      ENDIF
   1365  fefc
   1366  fefc
   1367  fefc		       a9 00		      lda	#<-INFINITY
      0  fefe					      sta@PLY	value
      1  fefe		       8d 58 f5 	      sta	[RAM]+value
   1369  ff01		       a9 90		      lda	#>-INFINITY
      0  ff03					      sta@PLY	value+1
      1  ff03		       8d 59 f5 	      sta	[RAM]+value+1
   1371  ff06
      0  ff06					      ldx@PLY	moveIndex
      1  ff06		       ae 51 f1 	      ldx	moveIndex
   1373  ff09		       10 03		      bpl	.forChild
   1374  ff0b		       4c 4f fe 	      jmp	.exit
   1375  ff0e
      0  ff0e				   .forChild  stx@PLY	movePtr
      1  ff0e		       8e 52 f5 	      stx	[RAM]+movePtr
   1377  ff11
   1378  ff11		       20 89 fd 	      jsr	MakeMove
   1379  ff14
   1380  ff14
   1381  ff14
   1382  ff14							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
   1383  ff14
   1384  ff14							; PARAMS depth-1, -beta, -alpha
   1385  ff14							; pased through temporary variables (__alpha, __beta) and X reg
   1386  ff14
   1387  ff14		       38		      sec
   1388  ff15		       a9 00		      lda	#0
      0  ff17					      sbc@PLY	beta
      1  ff17		       ed 56 f1 	      sbc	beta
   1390  ff1a		       85 aa		      sta	__alpha
   1391  ff1c		       a9 00		      lda	#0
      0  ff1e					      sbc@PLY	beta+1
      1  ff1e		       ed 57 f1 	      sbc	beta+1
   1393  ff21		       85 ab		      sta	__alpha+1
   1394  ff23
   1395  ff23		       38		      sec
   1396  ff24		       a9 00		      lda	#0
      0  ff26					      sbc@PLY	alpha
      1  ff26		       ed 54 f1 	      sbc	alpha
   1398  ff29		       85 ac		      sta	__beta
   1399  ff2b		       a9 00		      lda	#0
      0  ff2d					      sbc@PLY	alpha+1
      1  ff2d		       ed 55 f1 	      sbc	alpha+1
   1401  ff30		       85 ad		      sta	__beta+1
   1402  ff32
   1403  ff32
      0  ff32					      ldx@PLY	depthLeft
      1  ff32		       ae 5a f1 	      ldx	depthLeft
      0  ff35					      lda@PLY	capturedPiece
      1  ff35		       ad 4a f1 	      lda	capturedPiece
   1406  ff38
   1407  ff38		       e6 95		      inc	currentPly
   1408  ff3a		       a4 95		      ldy	currentPly
   1409  ff3c		       84 3e		      sty	SET_BANK_RAM	; self-switch
   1410  ff3e
   1411  ff3e		       20 8e fe 	      jsr	negaMax
   1412  ff41
   1413  ff41		       c6 95		      dec	currentPly
   1414  ff43		       a5 95		      lda	currentPly
   1415  ff45		       85 3e		      sta	SET_BANK_RAM
   1416  ff47
   1417  ff47		       20 f0 fd 	      jsr	unmakeMove
   1418  ff4a
   1419  ff4a		       38		      sec
   1420  ff4b		       a9 00		      lda	#0
   1421  ff4d		       e5 ae		      sbc	__negaMax
   1422  ff4f		       85 ae		      sta	__negaMax
   1423  ff51		       a9 00		      lda	#0
   1424  ff53		       e5 af		      sbc	__negaMax+1
   1425  ff55		       85 af		      sta	__negaMax+1	; -negaMax(...)
   1426  ff57
   1427  ff57							;lda flagCheck
   1428  ff57							;bne .inCheckX
   1429  ff57
   1430  ff57		       38		      sec
      0  ff58					      lda@PLY	value
      1  ff58		       ad 58 f1 	      lda	value
   1432  ff5b		       e5 ae		      sbc	__negaMax
      0  ff5d					      lda@PLY	value+1
      1  ff5d		       ad 59 f1 	      lda	value+1
   1434  ff60		       e5 af		      sbc	__negaMax+1
   1435  ff62		       50 02		      bvc	.lab0
   1436  ff64		       49 80		      eor	#$80
   1437  ff66		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
   1438  ff68
   1439  ff68							; so, negaMax > value!
   1440  ff68
   1441  ff68		       a5 ae		      lda	__negaMax
      0  ff6a					      sta@PLY	value
      1  ff6a		       8d 58 f5 	      sta	[RAM]+value
   1443  ff6d		       a5 af		      lda	__negaMax+1
      0  ff6f					      sta@PLY	value+1	; max(value, -negaMax)
      1  ff6f		       8d 59 f5 	      sta	[RAM]+value+1
   1445  ff72
      0  ff72					      lda@PLY	movePtr
      1  ff72		       ad 52 f1 	      lda	movePtr
      0  ff75					      sta@PLY	bestMove
      1  ff75		       8d 53 f5 	      sta	[RAM]+bestMove
   1448  ff78				   .lt0
   1449  ff78
   1450  ff78							;	  α := max(α, value)
   1451  ff78
   1452  ff78		       38		      sec
      0  ff79					      lda@PLY	value
      1  ff79		       ad 58 f1 	      lda	value
      0  ff7c					      sbc@PLY	alpha
      1  ff7c		       ed 54 f1 	      sbc	alpha
      0  ff7f					      lda@PLY	value+1
      1  ff7f		       ad 59 f1 	      lda	value+1
      0  ff82					      sbc@PLY	alpha+1
      1  ff82		       ed 55 f1 	      sbc	alpha+1
   1457  ff85		       50 02		      bvc	.lab1
   1458  ff87		       49 80		      eor	#$80
   1459  ff89		       30 0c	   .lab1      bmi	.lt1	; value < alpha
   1460  ff8b
      0  ff8b					      lda@PLY	value
      1  ff8b		       ad 58 f1 	      lda	value
      0  ff8e					      sta@PLY	alpha
      1  ff8e		       8d 54 f5 	      sta	[RAM]+alpha
      0  ff91					      lda@PLY	value+1
      1  ff91		       ad 59 f1 	      lda	value+1
      0  ff94					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  ff94		       8d 55 f5 	      sta	[RAM]+alpha+1
   1465  ff97
   1466  ff97				   .lt1
   1467  ff97
   1468  ff97							;	  if α ≥ β then
   1469  ff97							;	      break (* cut-off *)
   1470  ff97
   1471  ff97		       38		      sec
      0  ff98					      lda@PLY	alpha
      1  ff98		       ad 54 f1 	      lda	alpha
      0  ff9b					      sbc@PLY	beta
      1  ff9b		       ed 56 f1 	      sbc	beta
      0  ff9e					      lda@PLY	alpha+1
      1  ff9e		       ad 55 f1 	      lda	alpha+1
      0  ffa1					      sbc@PLY	beta+1
      1  ffa1		       ed 57 f1 	      sbc	beta+1
   1476  ffa4		       50 02		      bvc	.lab2
   1477  ffa6		       49 80		      eor	#$80
   1478  ffa8		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
   1479  ffaa
   1480  ffaa
      0  ffaa				   .nextMove  ldx@PLY	movePtr
      1  ffaa		       ae 52 f1 	      ldx	movePtr
   1482  ffad		       ca	   .nextX     dex
   1483  ffae		       30 03		      bmi	.retrn
   1484  ffb0		       4c 0e ff 	      jmp	.forChild
   1485  ffb3
   1486  ffb3		       4c 4f fe    .retrn     jmp	.exit
   1487  ffb6
   1488  ffb6
   1489  ffb6				   .inCheckX
   1490  ffb6							; TODO - causes bad copypiece on move select for computer...!!
   1491  ffb6							;lda #0
   1492  ffb6							;sta@PLY MoveFrom,x		  ; technically not needed but useful for UI
   1493  ffb6							;sta flagCheck
   1494  ffb6		       4c aa ff 	      jmp	.nextMove
   1495  ffb9
   1496  ffb9							;---------------------------------------------------------------------------------------------------
   1497  ffb9
 FREE BYTES IN FIXED BANK =  $43
   1498  ffb9					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFC - *
   1499  ffb9
   1500  ffb9							;---------------------------------------------------------------------------------------------------
   1501  ffb9							; The reset vectors
   1502  ffb9							; these must live in the fixed bank (last 2K of any ROM image in "3E" scheme)
   1503  ffb9
   1504  10000 ????				       SEG	InterruptVectors
   1505  fffc					      ORG	FIXED_BANK + $7FC
   1506  fffc					      RORG	$7ffC
   1507  fffc
   1508  fffc		       00 f8		      .word.w	Reset	; RESET
   1509  fffe		       00 f8		      .word.w	Reset	; IRQ	      (not used)
   1510  10000
   1511  10000							;---------------------------------------------------------------------------------------------------
   1512  10000							; EOF
------- FILE ./chess.asm
    612  10000
    613  10000							;END
