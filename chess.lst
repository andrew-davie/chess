------- FILE ./chess.asm LEVEL 1 PASS 4
      1  6c00 ????						; Chess
      2  6c00 ????						; Atari 2600 Chess display system
      3  6c00 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  6c00 ????						; andrew@taswegian.com
      5  6c00 ????
      6  6c00 ????
      7  6c00 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  6c00 ????
      9  6c00 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  6c00 ????				      include	"vcs.h"
      1  6c00 ????						; VCS.H
      2  6c00 ????						; Version 1.05, 13/November/2003
      3  6c00 ????
      4  6c00 ????	       00 69	   VERSION_VCS =	105
      5  6c00 ????
      6  6c00 ????						; This file defines hardware registers and memory mapping for the
      7  6c00 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  6c00 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  6c00 ????						; available at at http://www.atari2600.org/dasm
     10  6c00 ????						;
     11  6c00 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  6c00 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  6c00 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  6c00 ????						; with your views.  Please contribute, if you think you can improve this
     15  6c00 ????						; file!
     16  6c00 ????						;
     17  6c00 ????						; Latest Revisions...
     18  6c00 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  6c00 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  6c00 ????						;			    This will allow conditional code to verify VCS.H being
     21  6c00 ????						;			    used for code assembly.
     22  6c00 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  6c00 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  6c00 ????						;			 mirrored reading/writing differences.	This is more a
     25  6c00 ????						;			 readability issue, and binary compatibility with disassembled
     26  6c00 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  6c00 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  6c00 ????						;			 which was broken by the use of segments in this file, as
     29  6c00 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  6c00 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  6c00 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  6c00 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  6c00 ????						;						   it is safe to leave it undefined, and the base address will
     34  6c00 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  6c00 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  6c00 ????						;			  - register definitions are now generated through assignment
     37  6c00 ????						;			    in uninitialised segments.	This allows a changeable base
     38  6c00 ????						;			    address architecture.
     39  6c00 ????						; 1.0	22/MAR/2003		Initial release
     40  6c00 ????
     41  6c00 ????
     42  6c00 ????						;-------------------------------------------------------------------------------
     43  6c00 ????
     44  6c00 ????						; TIA_BASE_ADDRESS
     45  6c00 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  6c00 ????						; Normally 0, the base address should (externally, before including this file)
     47  6c00 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  6c00 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  6c00 ????						; < $40 as a bankswitch.
     50  6c00 ????
     51  6c00 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  6c00 ????			  -TIA_BASE_ADDRESS =	0
     53  6c00 ????				      ENDIF
     54  6c00 ????
     55  6c00 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  6c00 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  6c00 ????						; *OR* by declaring the label before including this file, eg:
     58  6c00 ????						; TIA_BASE_ADDRESS = $40
     59  6c00 ????						;   include "vcs.h"
     60  6c00 ????
     61  6c00 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  6c00 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  6c00 ????						; for the mirrored ROM hardware registers.
     64  6c00 ????
     65  6c00 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  6c00 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  6c00 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  6c00 ????
     69  6c00 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  6c00 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  6c00 ????				      ENDIF
     72  6c00 ????
     73  6c00 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  6c00 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  6c00 ????				      ENDIF
     76  6c00 ????
     77  6c00 ????						;-------------------------------------------------------------------------------
     78  6c00 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
     19  0000 ????						;include "segtime.asm"
     20  0000 ????
     21  0000 ????
     22  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     23  0000 ????
     24  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     25  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     26  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     27  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????
     35  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     36  0000 ????
     37  0000 ????
     38  0000 ????						; assemble diagnostics. Remove for release.
     39  0000 ????
     40  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     41  0000 ????	       00 01	   DIAGNOSTICS =	1
     42  0000 ????	       00 01	   QUIESCENCE =	1
     43  0000 ????	       00 00	   ASSERTS    =	0
     44  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     45  0000 ????	       00 00	   ENPASSANT_ENABLED =	0
     46  0000 ????	       00 01	   CASTLING_ENABLED =	1
     47  0000 ????
     48  0000 ????						; NOTE: SEARCH_DEPTH cannot be < 3, because the player's moves are generated from PLY+1, and use
     49  0000 ????						; PLY+2 for computer response (thus, 3). The bank allocation gets stomped!
     50  0000 ????
     51  0000 ????
     52  0000 ????	       00 03	   SEARCH_DEPTH =	3
     53  0000 ????	       00 06	   QUIESCE_EXTRA_DEPTH =	6
     54  0000 ????
     55  0000 ????
     56  0000 ????			  -	      IF	SEARCH_DEPTH < 3
     57  0000 ????			  -	      ECHO	"ERROR: Search depth nust be >= 3"
     58  0000 ????			  -	      ERR
     59  0000 ????				      ENDIF
     60  0000 ????
     61  0000 ????
     62  0000 ????
     63  0000 ????	       00 09	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     64  0000 ????	       00 09	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     65  0000 ????
     66  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     67  0000 ????						;    ERR "Not enough RAM for PLY banks"
     68  0000 ????						;ENDIF
     69  0000 ????
     70  0000 ????
     71  0000 ????
     72  0000 ????
     73  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     74  0000 ????
     75  0000 ????
     76  0000 ????
     77  0000 ????						; DELAYS
     78  0000 ????
     79  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     80  0000 ????
     81  0000 ????						;===================================
     82  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     83  0000 ????						;===================================
     84  0000 ????
     85  0000 ????						;-------------------------------------------------------------------------------
     86  0000 ????						; The following are optional YES/NO depending on phase of the moon
     87  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     88  0000 ????						;-------------------------------------------------------------------------------
     89  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     90  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     91  0000 ????			  -	      IF	FINAL_VERSION = YES
     92  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     93  0000 ????				      ENDIF
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????
     97  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     98  0000 ????
     99  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    100  0000 ????
    101  0000 ????						;------------------------------------------------------------------------------
    102  0000 ????
    103  0000 ????	       00 01	   PLUSCART   =	YES
    104  0000 ????
    105  0000 ????						;------------------------------------------------------------------------------
    106  0000 ????
    107  0000 ????
    108  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
    109  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    110  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    111  0000 ????
    112  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    113  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    114  0000 ????
    115  0000 ????
    116  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    117  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    118  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    119  0000 ????
    120  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    121  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    122  0000 ????
    123  0000 ????
    124  0000 ????						; Platform constants:
    125  0000 ????	       00 02	   PAL	      =	%10
    126  0000 ????	       00 02	   PAL_50     =	PAL|0
    127  0000 ????	       00 03	   PAL_60     =	PAL|1
    128  0000 ????
    129  0000 ????
    130  0000 ????				      IF	L276
    131  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    132  0000 ????			  -	      ELSE
    133  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    134  0000 ????				      ENDIF
    135  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    136  0000 ????
    137  0000 ????				      IF	L276
    138  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    139  0000 ????			  -	      ELSE
    140  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    141  0000 ????				      ENDIF
    142  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    143  0000 ????
    144  0000 ????				      IF	L276
    145  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    146  0000 ????			  -	      ELSE
    147  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    148  0000 ????				      ENDIF
    149  0000 ????	       01 38	   SCANLINES_PAL =	312
    150  0000 ????
    151  0000 ????
    152  0000 ????	       00 2e	   TIME_PART_2 =	46
    153  0000 ????	       00 2e	   TIME_PART_1 =	46
    154  0000 ????
    155  0000 ????
    156  0000 ????	       00 00	   SLOT0      =	0
    157  0000 ????	       00 40	   SLOT1      =	64
    158  0000 ????	       00 80	   SLOT2      =	128
    159  0000 ????	       00 c0	   SLOT3      =	192
    160  0000 ????
    161  0000 ????						;------------------------------------------------------------------------------
    162  0000 ????						; MACRO definitions
    163  0000 ????
    164  0000 ????
    165  0000 ????
    166  0000 ????				      MAC	newbank
    167  0000 ????				      SEG	{1}
    168  0000 ????				      ORG	_ORIGIN
    169  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    170  0000 ????			   _BANK_START SET	*
    171  0000 ????			   {1}_START  SET	*
    172  0000 ????			   _CURRENT_BANK SET	_ORIGIN/1024
    173  0000 ????			   {1}	      SET	_BANK_SLOT + _CURRENT_BANK
    174  0000 ????			   _ORIGIN    SET	_ORIGIN + 1024
    175  0000 ????				      ENDM		; bank name
    176  0000 ????
    177  0000 ????						;	      MAC DEFINE_1K_SEGMENT ; {seg name}
    178  0000 ????						;		  ALIGN $400
    179  0000 ????						;SEGMENT_{1}	  SET *
    180  0000 ????						;BANK_{1}	  SET _CURRENT_BANK
    181  0000 ????						;	      ENDM
    182  0000 ????
    183  0000 ????				      MAC	check_bank_size
    184  0000 ????			   .TEMP      =	* - _BANK_START
    185  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    186  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    187  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    188  0000 ????				      ERR
    189  0000 ????				      ENDIF
    190  0000 ????				      ENDM		; name
    191  0000 ????
    192  0000 ????				      MAC	check_ram_bank_size
    193  0000 ????			   .TEMP      =	* - _BANK_START
    194  0000 ????				      ECHO	{1}, "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    195  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    196  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    197  0000 ????				      ERR
    198  0000 ????				      ENDIF
    199  0000 ????				      ENDM		; name
    200  0000 ????
    201  0000 ????						;---------------------------------------------------------------------------------------------------
    202  0000 ????
    203  0000 ????						; Macro inserts a page break if the object would overlap a page
    204  0000 ????
    205  0000 ????				      MAC	optional_pagebreak
    206  0000 ????				      LIST	OFF
    207  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    208  0000 ????			   EARLY_LOCATION SET	*
    209  0000 ????				      ALIGN	256
    210  0000 ????				      IF	VERBOSE=1
    211  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    212  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    213  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    214  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    215  0000 ????				      ENDIF
    216  0000 ????				      ENDIF
    217  0000 ????				      LIST	ON
    218  0000 ????				      ENDM		; { string, size }
    219  0000 ????
    220  0000 ????
    221  0000 ????				      MAC	check_page_crossing
    222  0000 ????				      LIST	OFF
    223  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    224  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    225  0000 ????				      ENDIF
    226  0000 ????				      LIST	ON
    227  0000 ????				      ENDM
    228  0000 ????
    229  0000 ????				      MAC	checkpage
    230  0000 ????				      LIST	OFF
    231  0000 ????				      IF	>. != >{1}
    232  0000 ????				      ECHO	""
    233  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    234  0000 ????				      ECHO	""
    235  0000 ????				      ERR
    236  0000 ????				      ENDIF
    237  0000 ????				      LIST	ON
    238  0000 ????				      ENDM
    239  0000 ????
    240  0000 ????				      MAC	checkpagex
    241  0000 ????				      LIST	OFF
    242  0000 ????				      IF	>. != >{1}
    243  0000 ????				      ECHO	""
    244  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    245  0000 ????				      ECHO	{2}
    246  0000 ????				      ECHO	""
    247  0000 ????				      ERR
    248  0000 ????				      ENDIF
    249  0000 ????				      LIST	ON
    250  0000 ????				      ENDM
    251  0000 ????
    252  0000 ????						;---------------------------------------------------------------------------------------------------
    253  0000 ????
    254  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    255  0000 ????				      MAC	variable
    256  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    257  0000 ????			   {1}	      ds	{2}
    258  0000 ????				      ENDM		; {name, size}
    259  0000 ????
    260  0000 ????
    261  0000 ????						;---------------------------------------------------------------------------------------------------
    262  0000 ????
    263  0000 ????				      MAC	def
    264  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
    265  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
    266  0000 ????			   {1}			; entry point
    267  0000 ????			   TEMPORARY_VAR SET	Overlay
    268  0000 ????			   TEMPORARY_OFFSET SET	0
    269  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    270  0000 ????			   FUNCTION_NAME SET	{1}
    271  0000 ????				      ENDM		; name of subroutine
    272  0000 ????
    273  0000 ????
    274  0000 ????						;---------------------------------------------------------------------------------------------------
    275  0000 ????
    276  0000 ????				      MAC	allocate
    277  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    278  0000 ????				      DEF	{1}
    279  0000 ????				      ENDM
    280  0000 ????
    281  0000 ????						;---------------------------------------------------------------------------------------------------
    282  0000 ????
    283  0000 ????				      MAC	slot
    284  0000 ????				      IF	({1} < 0) || ({1} > 3)
    285  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
    286  0000 ????				      ERR
    287  0000 ????				      ENDIF
    288  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
    289  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
    290  0000 ????				      ENDM		; {1}
    291  0000 ????
    292  0000 ????
    293  0000 ????						;---------------------------------------------------------------------------------------------------
    294  0000 ????
    295  0000 ????				      MAC	negeval
    296  0000 ????
    297  0000 ????				      sec
    298  0000 ????				      lda	#0
    299  0000 ????				      sbc	Evaluation
    300  0000 ????				      sta	Evaluation
    301  0000 ????				      lda	#0
    302  0000 ????				      sbc	Evaluation+1
    303  0000 ????				      sta	Evaluation+1
    304  0000 ????				      ENDM
    305  0000 ????
    306  0000 ????
    307  0000 ????				      MAC	swap
    308  0000 ????				      lda	sideToMove
    309  0000 ????				      eor	#SWAP_SIDE
    310  0000 ????				      sta	sideToMove
    311  0000 ????
    312  0000 ????						;NEGEVAL
    313  0000 ????				      ENDM
    314  0000 ????
    315  0000 ????
    316  0000 ????						;---------------------------------------------------------------------------------------------------
    317  0000 ????
    318  0000 ????			   TEMPORARY_OFFSET SET	0
    319  0000 ????
    320  0000 ????
    321  0000 ????				      MAC	vend
    322  0000 ????				      IFNCONST	{1}
    323  0000 ????				      ECHO	"Incorrect VEND label", {1}
    324  0000 ????				      ERR
    325  0000 ????				      ENDIF
    326  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    327  0000 ????				      ENDM		; {1}
    328  0000 ????
    329  0000 ????
    330  0000 ????				      MAC	refer
    331  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    332  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    333  0000 ????				      ENDIF
    334  0000 ????				      ENDM		; {1}
    335  0000 ????
    336  0000 ????
    337  0000 ????
    338  0000 ????						; Define a temporary variable for use in a subroutine
    339  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    340  0000 ????
    341  0000 ????				      MAC	var
    342  0000 ????			   {1}	      =	TEMPORARY_VAR
    343  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    344  0000 ????
    345  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    346  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    347  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    348  0000 ????				      ENDIF
    349  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    350  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    351  0000 ????				      ERR
    352  0000 ????				      ENDIF
    353  0000 ????				      LIST	ON
    354  0000 ????				      ENDM		; { name, size }
    355  0000 ????
    356  0000 ????
    357  0000 ????						;---------------------------------------------------------------------------------------------------
    358  0000 ????
    359  0000 ????				      MAC	tag
    360  0000 ????						; {0}
    361  0000 ????				      ENDM		; {ident/tag}
    362  0000 ????
    363  0000 ????						;---------------------------------------------------------------------------------------------------
    364  0000 ????
    365  0000 ????				      MAC	sta@ram
    366  0000 ????				      sta	[RAM]+{0}
    367  0000 ????				      ENDM		;{}
    368  0000 ????
    369  0000 ????				      MAC	stx@ram
    370  0000 ????				      stx	[RAM]+{0}
    371  0000 ????				      ENDM
    372  0000 ????
    373  0000 ????				      MAC	sty@ram
    374  0000 ????				      sty	[RAM]+{0}
    375  0000 ????				      ENDM
    376  0000 ????
    377  0000 ????				      MAC	sta@ply
    378  0000 ????				      sta	[RAM]+{0}
    379  0000 ????				      ENDM		;{}
    380  0000 ????
    381  0000 ????				      MAC	stx@ply
    382  0000 ????				      stx	[RAM]+{0}
    383  0000 ????				      ENDM
    384  0000 ????
    385  0000 ????				      MAC	sty@ply
    386  0000 ????				      sty	[RAM]+{0}
    387  0000 ????				      ENDM
    388  0000 ????
    389  0000 ????
    390  0000 ????				      MAC	lda@ram
    391  0000 ????				      lda	{0}
    392  0000 ????				      ENDM		;{}
    393  0000 ????
    394  0000 ????				      MAC	ldx@ram
    395  0000 ????				      ldx	{0}
    396  0000 ????				      ENDM		;{}
    397  0000 ????
    398  0000 ????				      MAC	ldy@ram
    399  0000 ????				      ldy	{0}
    400  0000 ????				      ENDM		;{}
    401  0000 ????
    402  0000 ????
    403  0000 ????				      MAC	lda@ply
    404  0000 ????				      lda	{0}
    405  0000 ????				      ENDM		;{}
    406  0000 ????
    407  0000 ????				      MAC	ldx@ply
    408  0000 ????				      ldx	{0}
    409  0000 ????				      ENDM		;{}
    410  0000 ????
    411  0000 ????				      MAC	ldy@ply
    412  0000 ????				      ldy	{0}
    413  0000 ????				      ENDM		;{}
    414  0000 ????
    415  0000 ????
    416  0000 ????				      MAC	adc@ply
    417  0000 ????				      adc	{0}
    418  0000 ????				      ENDM		;{}
    419  0000 ????
    420  0000 ????				      MAC	sbc@ply
    421  0000 ????				      sbc	{0}
    422  0000 ????				      ENDM		;{}
    423  0000 ????
    424  0000 ????				      MAC	cmp@ply
    425  0000 ????				      cmp	{0}
    426  0000 ????				      ENDM		;{}
    427  0000 ????
    428  0000 ????						;---------------------------------------------------------------------------------------------------
    429  0000 ????
    430  0000 ????				      MAC	newrambank
    431  0000 ????						; {1}	     bank name
    432  0000 ????						; {2}	     RAM bank number
    433  0000 ????
    434  0000 ????				      SEG.U	{1}
    435  0000 ????				      ORG	ORIGIN_RAM
    436  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    437  0000 ????			   _BANK_START SET	*
    438  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
    439  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    440  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    441  0000 ????				      ENDM		; bank name
    442  0000 ????
    443  0000 ????						;---------------------------------------------------------------------------------------------------
    444  0000 ????
    445  0000 ????				      MAC	resync
    446  0000 ????						; resync screen, X and Y == 0 afterwards
    447  0000 ????				      lda	#%10	; make sure VBLANK is ON
    448  0000 ????				      sta	VBLANK
    449  0000 ????
    450  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    451  0000 ????			   .loopResync
    452  0000 ????				      VERTICAL_SYNC
    453  0000 ????
    454  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    455  0000 ????				      lda	Platform
    456  0000 ????				      eor	#PAL_50	; PAL-50?
    457  0000 ????				      bne	.ntsc
    458  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    459  0000 ????			   .ntsc
    460  0000 ????			   .loopWait
    461  0000 ????				      sta	WSYNC
    462  0000 ????				      sta	WSYNC
    463  0000 ????				      dey
    464  0000 ????				      bne	.loopWait
    465  0000 ????				      dex
    466  0000 ????				      bne	.loopResync
    467  0000 ????				      ENDM
    468  0000 ????
    469  0000 ????				      MAC	set_platform
    470  0000 ????						; 00 = NTSC
    471  0000 ????						; 01 = NTSC
    472  0000 ????						; 10 = PAL-50
    473  0000 ????						; 11 = PAL-60
    474  0000 ????				      lda	SWCHB
    475  0000 ????				      rol
    476  0000 ????				      rol
    477  0000 ????				      rol
    478  0000 ????				      and	#%11
    479  0000 ????				      eor	#PAL
    480  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    481  0000 ????				      ENDM
    482  0000 ????
    483  0000 ????
    484  0000 ????						;---------------------------------------------------------------------------------------------------
    485  0000 ????
    486  0000 ????						;    MAC JSROM_SAFE ; {routine}
    487  0000 ????						;    ; Saves bank of routine to variable for later restore.
    488  0000 ????						;    ; Switches to the bank and does a JSR to the routine.
    489  0000 ????
    490  0000 ????						;		  lda #BANK_{1}
    491  0000 ????						;		  sta savedBank
    492  0000 ????						;		  sta SET_BANK
    493  0000 ????						;		  jsr {1}
    494  0000 ????						;    ENDM
    495  0000 ????
    496  0000 ????
    497  0000 ????						;    MAC JSROM ; {routine}
    498  0000 ????
    499  0000 ????						;		  lda #BANK_{1}
    500  0000 ????						;		  sta SET_BANK
    501  0000 ????						;		  jsr {1}
    502  0000 ????						;    ENDM
    503  0000 ????
    504  0000 ????
    505  0000 ????						;    MAC JSRAM
    506  0000 ????						;		  lda #BANK_{1}
    507  0000 ????						;		  sta SET_BANK_RAM
    508  0000 ????						;		  jsr {1}
    509  0000 ????						;    ENDM
    510  0000 ????
    511  0000 ????
    512  0000 ????
    513  0000 ????				      MAC	timecheck
    514  0000 ????				      lda	INTIM
    515  0000 ????				      cmp	#SPEEDOF_{1}
    516  0000 ????				      bcc	{2}
    517  0000 ????				      ENDM		; {ident}, {branch if out of time}
    518  0000 ????
    519  0000 ????
    520  0000 ????				      MAC	timing
    521  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    522  0000 ????				      ENDM		; {label}, {cycles}
    523  0000 ????
    524  0000 ????
    525  0000 ????						;---------------------------------------------------------------------------------------------------
    526  0000 ????
    527  0000 ????						; Failsafe call of function in another bank
    528  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    529  0000 ????
    530  0000 ????				      MAC	call
    531  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    532  0000 ????				      ECHO	"ERROR: Incompatible call to function requiring same slot..."
    533  0000 ????				      ECHO	"Cannot switch bank in use for", {0}
    534  0000 ????				      ERR
    535  0000 ????				      ENDIF
    536  0000 ????				      lda	#BANK_{1}
    537  0000 ????				      sta	SET_BANK
    538  0000 ????				      jsr	{1}
    539  0000 ????				      ENDM		; function name
    540  0000 ????
    541  0000 ????
    542  0000 ????
    543  0000 ????						;---------------------------------------------------------------------------------------------------
    544  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00fe ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   aiState    ds	1	; state
     24 U008c		       00	   aiFlashDelay ds	1
     25 U008d
     26 U008d		       00	   aiMoveIndex ds	1
     27 U008e
     28 U008e		       00	   aiFlashPhase ds	1
     29 U008f
     30 U008f		       00 00	   Evaluation ds	2	; tracks value of the board position
     31 U0091
     32 U0091		       00	   currentPiece ds	1
     33 U0092		       00	   currentSquare ds	1
     34 U0093		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     35 U0094		       00	   currentPly ds	1
     36 U0095
     37 U0095		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     38 U0096		       00	   fromPiece  ds	1
     39 U0097		       00	   lastPiece  ds	1
     40 U0098		       00	   previousPiece ds	1
     41 U0099
     42 U0099		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U009a		       00 00	   speech_addr ds	2
     44 U009c		       00	   bg	      ds	1
     45 U009d
     46 U009d		       00	   capture    ds	1
     47 U009e
     48 U009e					      IF	DIAGNOSTICS
     49 U009e		       00 00 00    positionCount ds	3
     50 U00a1					      ENDIF
     51 U00a1
     52 U00a1							;maxPly			  ds 1
     53 U00a1		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     54 U00a2		       00	   protecting ds	1
     55 U00a3		       00	   randomness ds	1
     56 U00a4		       00 00	   __psb      ds	2
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a6					      include	"overlays.asm"
      1 U00a6							; Chess
      2 U00a6							; Atari 2600 Chess display system
      3 U00a6							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a6							; andrew@taswegian.com
      5 U00a6
      6 U00a6							;---------------------------------------------------------------------------------------------------
      7 U00a6							; OVERLAYS!
      8 U00a6							; These variables are overlays, and should be managed with care
      9 U00a6							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a6							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a6							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a6							; overlay #2
     13 U00a6
     14 U00a6							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a6
     16 U00a6							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a6							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a6							;---------------------------------------------------------------------------------------------------
     19 U00a6
     20 U00a6					      MAC	overlay
     21 U00a6				   OVERLAY_NAME SET	{1}
     22 U00a6					      SEG.U	OVERLAY_{1}
     23 U00a6					      org	Overlay
     24 U00a6					      ENDM		; {name}
     25 U00a6
     26 U00a6							;---------------------------------------------------------------------------------------------------
     27 U00a6
     28 U00a6					      MAC	validate_overlay
     29 U00a6					      LIST	OFF
     30 U00a6				   OVERLAY_DELTA SET	* - Overlay
     31 U00a6					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a6				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a6					      ENDIF
     34 U00a6					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a6					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a6					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a6					      ERR
     38 U00a6					      ENDIF
     39 U00a6					      LIST	ON
     40 U00a6					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a6					      ENDM
     42 U00a6
     43 U00a6							;---------------------------------------------------------------------------------------------------
     44 U00a6
     45 U00a6				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a6				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a6
     48 U00a6
     49 U00a6							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a6							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a6							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a6							; (especially the latter ones) are only used in rare occasions.
     53 U00a6
     54 U00a6							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a6							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a6
      0 U00a6					      DEF	Overlay
      1 U00a6				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a6				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a6				   Overlay
      4 U00a6				   TEMPORARY_VAR SET	Overlay
      5 U00a6				   TEMPORARY_OFFSET SET	0
      6 U00a6				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a6				   FUNCTION_NAME SET	Overlay
     58 U00a6		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00f2				   END_OF_OVERLAY
     60 U00f2
     61 U00f2							;---------------------------------------------------------------------------------------------------
     62 U00f2							; And now... the overlays....
     63 U00f2
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00f2					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00f2
     66 U00f2							;---------------------------------------------------------------------------------------------------
     67 U00f2
     68 U00f2		       00 a6	   __pieceShapeBuffer =	Overlay	; size = PIECE_SHAPE_SIZE
     69 U00f2
     70 U00f2							;---------------------------------------------------------------------------------------------------
     71 U00f2
     72 U00f2
     73 U00f2					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     74 U00f2					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $0
     75 U00f2					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     76 U00f2
     77 U00f2							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00f2					      include	"stack.asm"
      1 U00f2							; Chess
      2 U00f2							; Atari 2600 Chess display system
      3 U00f2							; Copyright (c) 2019-2020 Andrew Davie
      4 U00f2							; andrew@taswegian.com
      5 U00f2
      6 U00f2
      7 U00f2		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00f2
      9 U00f2		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00fe
     11 U00fe							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00fe							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00fe							;  but since overlay is not generally stressed during alphabeta, we're good.
     14 U00fe
     15 U00fe							; Ensure there isn't any stomping of stack/overlay excess usage
     16 U00fe
 Overlay boundary:  $a6
     17 U00fe					      ECHO	"Overlay boundary: ", Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE
 Stack boundary:  $ed
     18 U00fe					      ECHO	"Stack boundary: ", $FF- PLY_BANKS*2
     19 U00fe
     20 U00fe				  -	      IF	($FF - PLY_BANKS*2) < (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     21 U00fe				  -	      ECHO	"ERROR: Not enough reserved space for stack with given #PLY"
     22 U00fe				  -	      ERR
     23 U00fe					      ENDIF
     24 U00fe
     25 U00fe
------- FILE ./chess.asm
    548 U00fe
 FREE BYTES IN ZERO PAGE =  $1
    549 U00fe					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    550 U00fe				  -	      IF	* > $FF
    551 U00fe				  -	      ERR	"Zero Page overflow!"
    552 U00fe					      ENDIF
    553 U00fe
    554 U00fe							;------------------------------------------------------------------------------
    555 U00fe							;##############################################################################
    556 U00fe							;------------------------------------------------------------------------------
    557 U00fe
    558 U00fe							; NOW THE VERY INTERESTING '3E' RAM BANKS
    559 U00fe							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    560 U00fe							; IN A 1K MEMORY SPACE
    561 U00fe
      0 U00fe					      SLOT	0
      1 U00fe				  -	      IF	(0 < 0) || (0 > 3)
      2 U00fe				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U00fe				  -	      ERR
      4 U00fe					      ENDIF
      5 U00fe				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U00fe				   _BANK_SLOT SET	0 * 64
      0 U00fe					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00fe
      2 U00fe
      3 U00fe
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0000				   _BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0400				   _BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0800				   _BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0c00				   _BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1000				   _BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1400				   _BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1800				   _BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1c00				   _BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    566 U1c00					      REPEND
    567 U1c00
    568 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    569 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    570 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    571 U1c00
    572 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    573 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    574 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    575 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    576 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    577 U1c00
    578 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    579 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    580 U1c00
    581 U1c00							;---------------------------------------------------------------------------------------------------
    582 U1c00
    583 U1c00
    584 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    585 U1c00
    586 U1c00					      MAC	next_random
    587 U1c00					      lda	rnd
    588 U1c00					      lsr
    589 U1c00					      bcc	.skipEOR
    590 U1c00					      eor	#RND_EOR_VAL
    591 U1c00				   .skipEOR   sta	rnd
    592 U1c00					      ENDM
    593 U1c00
    594 U1c00							;--------------------------------------------------------------------------------
    595 U1c00
    596 U1c00					      MAC	phase
    597 U1c00					      lda	#{1}
    598 U1c00					      sta	aiState
    599 U1c00					      ENDM		;#
    600 U1c00
    601 U1c00
    602 U1c00							;--------------------------------------------------------------------------------
    603 U1c00
    604 U1c00					      MAC	common_vars
    605 U1c00
    606 U1c00					      VAR	__thinkbar, 1
    607 U1c00					      VAR	__toggle, 1
    608 U1c00
    609 U1c00					      VAR	__bestMove, 1
    610 U1c00					      VAR	__alpha, 2
    611 U1c00					      VAR	__beta, 2
    612 U1c00					      VAR	__negaMax, 2
    613 U1c00					      VAR	__value, 2
    614 U1c00
    615 U1c00					      VAR	__quiesceCapOnly, 1
    616 U1c00
    617 U1c00					      VAR	__originalPiece, 1
    618 U1c00					      VAR	__capturedPiece, 1
    619 U1c00
    620 U1c00					      ENDM
    621 U1c00							;---------------------------------------------------------------------------------------------------
    622 U1c00
------- FILE BANK_FIRST@0.asm LEVEL 2 PASS 4
      0 U1c00					      include	"BANK_FIRST@0.asm"	; MUST be first in ROM - contains reset vectors
      1 U1c00							; Chess
      2 U1c00							; Copyright (c) 2019-2020 Andrew Davie
      3 U1c00							; andrew@taswegian.com
      4 U1c00
      5 U1c00
      6 U1c00							; SLOT0 - screen draw, state machine dispatcher
      7 U1c00							; SLOT1 - anything
      8 U1c00							; SLOT2 - moves/ply
      9 U1c00							; SLOT3 - board
     10 U1c00
     11 U1c00
     12 U1c00
     13 U1c00
     14 U1c00
     15 U1c00
      0 U1c00					      SLOT	0
      1 U1c00				  -	      IF	(0 < 0) || (0 > 3)
      2 U1c00				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U1c00				  -	      ERR
      4 U1c00					      ENDIF
      5 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U1c00				   _BANK_SLOT SET	0 * 64
     17 U1c00
     18 U1c00							;---------------------------------------------------------------------------------------------------
     19 U1c00							;#########################################  FIXED BANK  ############################################
     20 U1c00							;---------------------------------------------------------------------------------------------------
     21 U1c00
     22 U1c00				   _ORIGIN    SET	_FIRST_BANK
     23 U1c00
      0 U1c00					      NEWBANK	THE_FIRST_BANK
      1  037d ????				      SEG	THE_FIRST_BANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   THE_FIRST_BANK_START SET	*
      6  0000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0000				   THE_FIRST_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + 1024
     25  0000					      RORG	$f000
     26  0000
     27  0000							;---------------------------------------------------------------------------------------------------
     28  0000
      0  0000					      DEF	StartupBankReset
      1  0000				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0000				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0000				   StartupBankReset
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartupBankReset
     30  0000					      SUBROUTINE
     31  0000
      0  0000					      VEND	StartupBankReset
      1  0000				  -	      IFNCONST	StartupBankReset
      2  0000				  -	      ECHO	"Incorrect VEND label", StartupBankReset
      3  0000				  -	      ERR
      4  0000					      ENDIF
      5  0000		       00 a6	   VAREND_StartupBankReset =	TEMPORARY_VAR
     33  0000
     34  0000							; On startup, 3E+ switches banks 0 and 3 to the 1st ROM bank (1K), from which the reset
     35  0000							; vector is obtained from bank 0 (+$FFC). Chess3E+ (maybe) will leave this bank (3) alone
     36  0000							; so that a system reset will always have the reset vectors available at FFFC, where expected
     37  0000
     38  0000		       a2 ff		      ldx	#$FF
     39  0002		       9a		      txs
     40  0003
      0  0003					      CALL	CartInit
      1  0003				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0003				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0003				  -	      ECHO	"Cannot switch bank in use for", CartInit
      4  0003				  -	      ERR
      5  0003					      ENDIF
      6  0003		       a9 41		      lda	#BANK_CartInit
      7  0005		       85 3f		      sta	SET_BANK
      8  0007		       20 00 f4 	      jsr	CartInit
      0  000a					      CALL	SetupBanks
      1  000a				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  000a				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  000a				  -	      ECHO	"Cannot switch bank in use for", SetupBanks
      4  000a				  -	      ERR
      5  000a					      ENDIF
      6  000a		       a9 41		      lda	#BANK_SetupBanks
      7  000c		       85 3f		      sta	SET_BANK
      8  000e		       20 28 f4 	      jsr	SetupBanks
      0  0011					      CALL	InitialisePieceSquares
      1  0011				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  0011				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0011				  -	      ECHO	"Cannot switch bank in use for", InitialisePieceSquares
      4  0011				  -	      ERR
      5  0011					      ENDIF
      6  0011		       a9 41		      lda	#BANK_InitialisePieceSquares
      7  0013		       85 3f		      sta	SET_BANK
      8  0015		       20 88 f4 	      jsr	InitialisePieceSquares
     44  0018		       20 28 f2 	      jsr	ListPlayerMoves	;@0
     45  001b
     46  001b
     47  001b				   .StartFrame
     48  001b
     49  001b
     50  001b							; START OF FRAME
     51  001b
     52  001b		       a9 0e		      lda	#%1110	; VSYNC ON
     53  001d		       85 42	   .loopVSync3 sta	WSYNC
     54  001f		       85 40		      sta	VSYNC
     55  0021		       4a		      lsr
     56  0022		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     57  0024
     58  0024		       85 41		      sta	VBLANK
     59  0026
     60  0026		       a0 2e		      ldy	#TIME_PART_1
     61  0028		       8c 96 02 	      sty	TIM64T
     62  002b
     63  002b							; LOTS OF PROCESSING TIME - USE IT
     64  002b
     65  002b
     66  002b
     67  002b		       20 74 f1 	      jsr	AiStateMachine
     68  002e
     69  002e				  -	      IF	ASSERTS
     70  002e				  -			; Catch timer expired already
     71  002e				  -			;		      bit TIMINT
     72  002e				  -			;.whoops	      bmi .whoops
     73  002e					      ENDIF
     74  002e
     75  002e
     76  002e		       2c 85 02    .wait      bit	TIMINT
     77  0031		       10 fb		      bpl	.wait
     78  0033
     79  0033
     80  0033							; START OF VISIBLE SCANLINES
     81  0033
     82  0033
      0  0033					      CALL	longD
      1  0033				  -	      IF	SLOT_longD == _BANK_SLOT
      2  0033				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0033				  -	      ECHO	"Cannot switch bank in use for", longD
      4  0033				  -	      ERR
      5  0033					      ENDIF
      6  0033		       a9 91		      lda	#BANK_longD
      7  0035		       85 3f		      sta	SET_BANK
      8  0037		       20 18 f8 	      jsr	longD
     84  003a
     85  003a
     86  003a		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     87  003c		       86 3e		      stx	SET_BANK_RAM
     88  003e		       20 03 f9 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     89  0041
      0  0041					      CALL	tidySc
      1  0041				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  0041				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0041				  -	      ECHO	"Cannot switch bank in use for", tidySc
      4  0041				  -	      ERR
      5  0041					      ENDIF
      6  0041		       a9 91		      lda	#BANK_tidySc
      7  0043		       85 3f		      sta	SET_BANK
      8  0045		       20 04 f8 	      jsr	tidySc
     91  0048
     92  0048		       20 74 f1 	      jsr	AiStateMachine
     93  004b
     94  004b		       ad 84 02 	      lda	INTIM
     95  004e		       c9 14		      cmp	#20
     96  0050		       90 20		      bcc	.notnow
     97  0052
     98  0052							;CALL GameSpeak
      0  0052					      CALL	PositionSprites
      1  0052				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  0052				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0052				  -	      ECHO	"Cannot switch bank in use for", PositionSprites
      4  0052				  -	      ERR
      5  0052					      ENDIF
      6  0052		       a9 47		      lda	#BANK_PositionSprites
      7  0054		       85 3f		      sta	SET_BANK
      8  0056		       20 00 f6 	      jsr	PositionSprites
    100  0059
    101  0059
    102  0059					      IF	1
    103  0059							; "draw" sprite shapes into row banks
    104  0059
    105  0059		       a2 07		      ldx	#7
    106  005b		       8a	   zapem      txa
    107  005c		       18		      clc
    108  005d		       69 80		      adc	#SLOT_DrawRow
    109  005f		       85 3e		      sta	SET_BANK_RAM
      0  0061					      CALL	WriteBlank	;@3
      1  0061				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  0061				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0061				  -	      ECHO	"Cannot switch bank in use for", WriteBlank
      4  0061				  -	      ERR
      5  0061					      ENDIF
      6  0061		       a9 c3		      lda	#BANK_WriteBlank
      7  0063		       85 3f		      sta	SET_BANK
      8  0065		       20 0b fc 	      jsr	WriteBlank
    111  0068		       ca		      dex
    112  0069		       10 f0		      bpl	zapem
    113  006b
      0  006b					      CALL	WriteCursor	;@3
      1  006b				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  006b				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  006b				  -	      ECHO	"Cannot switch bank in use for", WriteCursor
      4  006b				  -	      ERR
      5  006b					      ENDIF
      6  006b		       a9 c3		      lda	#BANK_WriteCursor
      7  006d		       85 3f		      sta	SET_BANK
      8  006f		       20 34 fc 	      jsr	WriteCursor
    115  0072					      ENDIF
    116  0072
    117  0072				   .notnow
    118  0072
    119  0072		       2c 85 02    .waitTime  bit	TIMINT
    120  0075		       10 fb		      bpl	.waitTime
    121  0077
    122  0077		       4c 1b f0 	      jmp	.StartFrame
    123  007a
    124  007a
    125  007a							;---------------------------------------------------------------------------------------------------
    126  007a
      0  007a					      DEF	ThinkBar
      1  007a				   SLOT_ThinkBar SET	_BANK_SLOT
      2  007a				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  007a				   ThinkBar
      4  007a				   TEMPORARY_VAR SET	Overlay
      5  007a				   TEMPORARY_OFFSET SET	0
      6  007a				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  007a				   FUNCTION_NAME SET	ThinkBar
    128  007a					      SUBROUTINE
    129  007a
      0  007a					      COMMON_VARS
      1  007a
      0  007a					      VAR	__thinkbar, 1
      1  007a		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__toggle, 1
      1  007a		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      4  007a
      0  007a					      VAR	__bestMove, 1
      1  007a		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__alpha, 2
      1  007a		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__beta, 2
      1  007a		       00 ab	   __beta     =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__negaMax, 2
      1  007a		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__value, 2
      1  007a		       00 af	   __value    =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
     10  007a
      0  007a					      VAR	__quiesceCapOnly, 1
      1  007a		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
     12  007a
      0  007a					      VAR	__originalPiece, 1
      1  007a		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
      0  007a					      VAR	__capturedPiece, 1
      1  007a		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  007a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  007a
      4  007a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  007a					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  007a				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  007a					      ENDIF
      8  007a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  007a				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  007a				  -	      ERR
     11  007a					      ENDIF
     12  007a					      LIST	ON
     15  007a
      0  007a					      REFER	negaMax	;✅
      1  007a				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  007a				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  007a					      ENDIF
      0  007a					      REFER	quiesce	;✅
      1  007a				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  007a				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  007a					      ENDIF
      0  007a					      VEND	ThinkBar
      1  007a				  -	      IFNCONST	ThinkBar
      2  007a				  -	      ECHO	"Incorrect VEND label", ThinkBar
      3  007a				  -	      ERR
      4  007a					      ENDIF
      5  007a		       00 b4	   VAREND_ThinkBar =	TEMPORARY_VAR
    134  007a
    135  007a					      IF	DIAGNOSTICS
    136  007a
    137  007a		       e6 9e		      inc	positionCount
    138  007c		       d0 06		      bne	.p1
    139  007e		       e6 9f		      inc	positionCount+1
    140  0080		       d0 02		      bne	.p1
    141  0082		       e6 a0		      inc	positionCount+2
    142  0084				   .p1
    143  0084					      ENDIF
    144  0084
    145  0084							; The 'thinkbar' pattern...
    146  0084
    147  0084		       a9 00		      lda	#0
    148  0086		       a4 4c		      ldy	INPT4
    149  0088		       30 0f		      bmi	.doThink
    150  008a
    151  008a		       e6 a6		      inc	__thinkbar
    152  008c		       a5 a6		      lda	__thinkbar
    153  008e		       29 0f		      and	#15
    154  0090		       a8		      tay
    155  0091		       b9 9e f0 	      lda	TBcol,y
    156  0094		       85 48		      sta	COLUPF
    157  0096
    158  0096		       b9 ae f0 	      lda	SynapsePattern,y
    159  0099		       85 4f	   .doThink   sta	PF2
    160  009b		       85 4e		      sta	PF1
    161  009d		       60		      rts
    162  009e
    163  009e
    164  009e				   TBcol
    165  009e				   .TBC       SET	2
    166  009e					      REPEAT	16
    167  009e		       02		      .byte.b	.TBC
    168  009e				   .TBC       SET	.TBC + 16
    166  009e					      REPEND
    167  009f		       12		      .byte.b	.TBC
    168  009f				   .TBC       SET	.TBC + 16
    166  009f					      REPEND
    167  00a0		       22		      .byte.b	.TBC
    168  00a0				   .TBC       SET	.TBC + 16
    166  00a0					      REPEND
    167  00a1		       32		      .byte.b	.TBC
    168  00a1				   .TBC       SET	.TBC + 16
    166  00a1					      REPEND
    167  00a2		       42		      .byte.b	.TBC
    168  00a2				   .TBC       SET	.TBC + 16
    166  00a2					      REPEND
    167  00a3		       52		      .byte.b	.TBC
    168  00a3				   .TBC       SET	.TBC + 16
    166  00a3					      REPEND
    167  00a4		       62		      .byte.b	.TBC
    168  00a4				   .TBC       SET	.TBC + 16
    166  00a4					      REPEND
    167  00a5		       72		      .byte.b	.TBC
    168  00a5				   .TBC       SET	.TBC + 16
    166  00a5					      REPEND
    167  00a6		       82		      .byte.b	.TBC
    168  00a6				   .TBC       SET	.TBC + 16
    166  00a6					      REPEND
    167  00a7		       92		      .byte.b	.TBC
    168  00a7				   .TBC       SET	.TBC + 16
    166  00a7					      REPEND
    167  00a8		       a2		      .byte.b	.TBC
    168  00a8				   .TBC       SET	.TBC + 16
    166  00a8					      REPEND
    167  00a9		       b2		      .byte.b	.TBC
    168  00a9				   .TBC       SET	.TBC + 16
    166  00a9					      REPEND
    167  00aa		       c2		      .byte.b	.TBC
    168  00aa				   .TBC       SET	.TBC + 16
    166  00aa					      REPEND
    167  00ab		       d2		      .byte.b	.TBC
    168  00ab				   .TBC       SET	.TBC + 16
    166  00ab					      REPEND
    167  00ac		       e2		      .byte.b	.TBC
    168  00ac				   .TBC       SET	.TBC + 16
    166  00ac					      REPEND
    167  00ad		       f2		      .byte.b	.TBC
    168  00ad				   .TBC       SET	.TBC + 16
    169  00ae					      REPEND
    170  00ae
    171  00ae				   SynapsePattern
    172  00ae
    173  00ae		       c1		      .byte.b	%11000001
    174  00af		       60		      .byte.b	%01100000
    175  00b0		       30		      .byte.b	%00110000
    176  00b1		       18		      .byte.b	%00011000
    177  00b2		       0c		      .byte.b	%00001100
    178  00b3		       06		      .byte.b	%00000110
    179  00b4		       83		      .byte.b	%10000011
    180  00b5		       c1		      .byte.b	%11000001
    181  00b6
    182  00b6		       83		      .byte.b	%10000011
    183  00b7		       06		      .byte.b	%00000110
    184  00b8		       0c		      .byte.b	%00001100
    185  00b9		       18		      .byte.b	%00011000
    186  00ba		       30		      .byte.b	%00110000
    187  00bb		       60		      .byte.b	%01100000
    188  00bc		       c1		      .byte.b	%11000001
    189  00bd		       83		      .byte.b	%10000011
    190  00be
    191  00be
    192  00be							;---------------------------------------------------------------------------------------------------
    193  00be
      0  00be					      DEF	CopySinglePiece
      1  00be				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  00be				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  00be				   CopySinglePiece
      4  00be				   TEMPORARY_VAR SET	Overlay
      5  00be				   TEMPORARY_OFFSET SET	0
      6  00be				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  00be				   FUNCTION_NAME SET	CopySinglePiece
    195  00be					      SUBROUTINE
    196  00be
      0  00be					      TIMING	COPYSINGLEPIECE, (2600)
      1  00be		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    198  00be
      0  00be					      REFER	showMoveCaptures	;✅
      1  00be					      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  00be				   TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  00be					      ENDIF
      0  00be					      REFER	aiDrawEntireBoard	;✅
      1  00be				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  00be					      ENDIF
      0  00be					      REFER	aiDrawPart2	;✅
      1  00be				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  00be					      ENDIF
      0  00be					      REFER	aiMarchB	;✅
      1  00be				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  00be					      ENDIF
      0  00be					      REFER	aiFlashComputerMove	;✅
      1  00be				  -	      IF	VAREND_aiFlashComputerMove > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiFlashComputerMove
      3  00be					      ENDIF
      0  00be					      REFER	aiSelectDestinationSquare	;✅
      1  00be				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  00be					      ENDIF
      0  00be					      REFER	aiMarchA2	;✅
      1  00be				  -	      IF	VAREND_aiMarchA2 > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiMarchA2
      3  00be					      ENDIF
      0  00be					      REFER	aiMarchB2	;✅
      1  00be				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  00be					      ENDIF
      0  00be					      REFER	aiWriteStartPieceBlank	;✅
      1  00be				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  00be					      ENDIF
      0  00be					      REFER	aiChoosePromotePiece	;✅
      1  00be				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  00be					      ENDIF
      0  00be					      REFER	aiMarchToTargetB	;✅
      1  00be				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  00be					      ENDIF
      0  00be					      REFER	aiPromotePawnStart	;✅
      1  00be				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  00be					      ENDIF
      0  00be					      REFER	aiFinalFlash	;✅
      1  00be				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  00be				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  00be					      ENDIF
    212  00be
    213  00be				  -	      IF	ENPASSANT_ENABLED
    214  00be				  -	      REFER	EnPassantCheck	;✅
    215  00be					      ENDIF
    216  00be
      0  00be					      VEND	CopySinglePiece
      1  00be				  -	      IFNCONST	CopySinglePiece
      2  00be				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  00be				  -	      ERR
      4  00be					      ENDIF
      5  00be		       00 ab	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    218  00be
    219  00be							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    220  00be							; ALSO CAN'T USE IN THIS ROUTINE
    221  00be							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    222  00be							; @2150 max
    223  00be							; = 33 TIM64T
    224  00be
    225  00be							; Board is [SLOT3]
    226  00be
    227  00be
      0  00be					      CALL	CopySetup	;@2
      1  00be				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  00be				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  00be				  -	      ECHO	"Cannot switch bank in use for", CopySetup
      4  00be				  -	      ERR
      5  00be					      ENDIF
      6  00be		       a9 91		      lda	#BANK_CopySetup
      7  00c0		       85 3f		      sta	SET_BANK
      8  00c2		       20 6a f8 	      jsr	CopySetup
    229  00c5
    230  00c5
      0  00c5					      DEF	InterceptMarkerCopy
      1  00c5				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  00c5				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  00c5				   InterceptMarkerCopy
      4  00c5				   TEMPORARY_VAR SET	Overlay
      5  00c5				   TEMPORARY_OFFSET SET	0
      6  00c5				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  00c5				   FUNCTION_NAME SET	InterceptMarkerCopy
    232  00c5					      SUBROUTINE
    233  00c5
      0  00c5					      REFER	CopySinglePiece	;✅✅
      1  00c5					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  00c5				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  00c5					      ENDIF
      0  00c5					      REFER	showPromoteOptions	;✅
      1  00c5				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  00c5				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  00c5					      ENDIF
      0  00c5					      REFER	showMoveOptions	;✅
      1  00c5				  -	      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  00c5				  -TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  00c5					      ENDIF
      0  00c5					      VEND	InterceptMarkerCopy
      1  00c5				  -	      IFNCONST	InterceptMarkerCopy
      2  00c5				  -	      ECHO	"Incorrect VEND label", InterceptMarkerCopy
      3  00c5				  -	      ERR
      4  00c5					      ENDIF
      5  00c5		       00 ab	   VAREND_InterceptMarkerCopy =	TEMPORARY_VAR
    238  00c5
    239  00c5							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    240  00c5							; y = piece index
    241  00c5
    242  00c5		       a9 91		      lda	#BANK_PIECE_VECTOR_BANK
    243  00c7		       85 3f		      sta	SET_BANK	;@2
    244  00c9
    245  00c9		       b9 c5 f9 	      lda	PIECE_VECTOR_LO,y
    246  00cc		       85 a4		      sta	__psb
    247  00ce		       b9 55 fa 	      lda	PIECE_VECTOR_HI,y
    248  00d1		       85 a5		      sta	__psb+1
    249  00d3		       b9 e5 fa 	      lda	PIECE_VECTOR_BANK,y
    250  00d6		       85 3f		      sta	SET_BANK	;@2
    251  00d8
    252  00d8		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    253  00da		       b1 a4	   .copy      lda	(__psb),y
    254  00dc		       99 a6 00 	      sta	__pieceShapeBuffer,y
    255  00df		       88		      dey
    256  00e0		       10 f8		      bpl	.copy
    257  00e2
    258  00e2		       a5 80		      lda	squareToDraw
    259  00e4		       38		      sec
    260  00e5		       a2 0a		      ldx	#10
    261  00e7		       e9 0a	   .sub10     sbc	#10
    262  00e9		       ca		      dex
    263  00ea		       b0 fb		      bcs	.sub10
    264  00ec
    265  00ec		       69 08		      adc	#8
    266  00ee		       c9 04		      cmp	#4	; CS = right side of screen
    267  00f0
    268  00f0		       8a		      txa
    269  00f1		       09 80		      ora	#[SLOT2]
    270  00f3		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    271  00f5
    272  00f5		       20 19 f3 	      jsr	CopyPieceToRowBitmap	;@3
    273  00f8		       60		      rts
    274  00f9
    275  00f9
    276  00f9							;---------------------------------------------------------------------------------------------------
    277  00f9
    278  00f9				   P	      SET	0
    279  00f9					      MAC	ain
    280  00f9				   AI_{1}     SET	P
    281  00f9				   P	      SET	P+1
    282  00f9					      ENDM
    283  00f9
    284  00f9					      MAC	lo
    285  00f9					      .byte	<ai{1}
    286  00f9					      ENDM
    287  00f9
    288  00f9					      MAC	hi
    289  00f9					      .byte	>ai{1}
    290  00f9					      ENDM
    291  00f9
    292  00f9					      MAC	bk
    293  00f9					      .byte	BANK_ai{1}
    294  00f9					      ENDM
    295  00f9
    296  00f9
    297  00f9		       00 28	   ONCEPERFRAME =	40
    298  00f9
    299  00f9					      MAC	tabdef
    300  00f9
    301  00f9					      {1}	FlashComputerMove	; 0
    302  00f9					      {1}	BeginSelectMovePhase	; 1
    303  00f9					      {1}	SelectStartSquare	; 2
    304  00f9					      {1}	StartSquareSelected	; 3
    305  00f9					      {1}	DrawMoves	; 4
    306  00f9					      {1}	ShowMoveCaptures	; 5
    307  00f9					      {1}	SlowFlash	; 6
    308  00f9					      {1}	UnDrawTargetSquares	; 7
    309  00f9					      {1}	SelectDestinationSquare	; 8
    310  00f9					      {1}	Quiescent	; 9
    311  00f9					      {1}	ReselectDebounce	; 10
    312  00f9					      {1}	StartMoveGen	; 11
    313  00f9					      {1}	StepMoveGen	; 12
    314  00f9					      {1}	StartClearBoard	; 13
    315  00f9					      {1}	ClearEachRow	; 14
    316  00f9					      {1}	DrawEntireBoard	; 15
    317  00f9					      {1}	DrawPart2	; 16
    318  00f9					      {1}	DrawPart3	; 17
    319  00f9					      {1}	GenerateMoves	; 18
    320  00f9					      {1}	ComputerMove	; 19
    321  00f9					      {1}	MoveIsSelected	; 20
    322  00f9					      {1}	WriteStartPieceBlank	; 21
    323  00f9					      {1}	MarchToTargetA	; 22
    324  00f9					      {1}	MarchA2	; 23
    325  00f9					      {1}	MarchB	; 24
    326  00f9					      {1}	MarchToTargetB	; 25
    327  00f9					      {1}	MarchB2	; 26
    328  00f9					      {1}	FinalFlash	; 27
    329  00f9					      {1}	SpecialMoveFixup	; 28
    330  00f9					      {1}	InCheckBackup	; 29
    331  00f9					      {1}	InCheckDelay	; 30
    332  00f9					      {1}	PromotePawnStart	; 31
    333  00f9					      {1}	RollPromotionPiece	; 32
    334  00f9					      {1}	ChoosePromotePiece	; 33
    335  00f9					      {1}	ChooseDebounce	; 34
    336  00f9					      {1}	CheckMate	; 35
    337  00f9					      {1}	Draw	; 36
    338  00f9					      {1}	DelayAfterMove	; 37
    339  00f9					      {1}	DelayAfterMove2	; 38
    340  00f9					      {1}	DelayAfterPlaced	; 39
    341  00f9					      {1}	DelayAfterPlaced2	; 40
    342  00f9
    343  00f9					      ENDM		; {1} = macro to use
    344  00f9
      0  00f9					      TABDEF	AIN
      1  00f9
      0  00f9					      AIN	FlashComputerMove
      1  00f9				   AI_FlashComputerMove SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	BeginSelectMovePhase
      1  00f9				   AI_BeginSelectMovePhase SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	SelectStartSquare
      1  00f9				   AI_SelectStartSquare SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	StartSquareSelected
      1  00f9				   AI_StartSquareSelected SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DrawMoves
      1  00f9				   AI_DrawMoves SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ShowMoveCaptures
      1  00f9				   AI_ShowMoveCaptures SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	SlowFlash
      1  00f9				   AI_SlowFlash SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	UnDrawTargetSquares
      1  00f9				   AI_UnDrawTargetSquares SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	SelectDestinationSquare
      1  00f9				   AI_SelectDestinationSquare SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	Quiescent
      1  00f9				   AI_Quiescent SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ReselectDebounce
      1  00f9				   AI_ReselectDebounce SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	StartMoveGen
      1  00f9				   AI_StartMoveGen SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	StepMoveGen
      1  00f9				   AI_StepMoveGen SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	StartClearBoard
      1  00f9				   AI_StartClearBoard SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ClearEachRow
      1  00f9				   AI_ClearEachRow SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DrawEntireBoard
      1  00f9				   AI_DrawEntireBoard SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DrawPart2
      1  00f9				   AI_DrawPart2 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DrawPart3
      1  00f9				   AI_DrawPart3 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	GenerateMoves
      1  00f9				   AI_GenerateMoves SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ComputerMove
      1  00f9				   AI_ComputerMove SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MoveIsSelected
      1  00f9				   AI_MoveIsSelected SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	WriteStartPieceBlank
      1  00f9				   AI_WriteStartPieceBlank SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchToTargetA
      1  00f9				   AI_MarchToTargetA SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchA2
      1  00f9				   AI_MarchA2 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchB
      1  00f9				   AI_MarchB  SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchToTargetB
      1  00f9				   AI_MarchToTargetB SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	MarchB2
      1  00f9				   AI_MarchB2 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	FinalFlash
      1  00f9				   AI_FinalFlash SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	SpecialMoveFixup
      1  00f9				   AI_SpecialMoveFixup SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	InCheckBackup
      1  00f9				   AI_InCheckBackup SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	InCheckDelay
      1  00f9				   AI_InCheckDelay SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	PromotePawnStart
      1  00f9				   AI_PromotePawnStart SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	RollPromotionPiece
      1  00f9				   AI_RollPromotionPiece SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ChoosePromotePiece
      1  00f9				   AI_ChoosePromotePiece SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	ChooseDebounce
      1  00f9				   AI_ChooseDebounce SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	CheckMate
      1  00f9				   AI_CheckMate SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	Draw
      1  00f9				   AI_Draw    SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DelayAfterMove
      1  00f9				   AI_DelayAfterMove SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DelayAfterMove2
      1  00f9				   AI_DelayAfterMove2 SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DelayAfterPlaced
      1  00f9				   AI_DelayAfterPlaced SET	P
      2  00f9				   P	      SET	P+1
      0  00f9					      AIN	DelayAfterPlaced2
      1  00f9				   AI_DelayAfterPlaced2 SET	P
      2  00f9				   P	      SET	P+1
     43  00f9
    346  00f9
      0  00f9					      DEF	AiVectorLO
      1  00f9				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  00f9				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  00f9				   AiVectorLO
      4  00f9				   TEMPORARY_VAR SET	Overlay
      5  00f9				   TEMPORARY_OFFSET SET	0
      6  00f9				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  00f9				   FUNCTION_NAME SET	AiVectorLO
      0  00f9					      TABDEF	LO
      1  00f9
      0  00f9					      LO	FlashComputerMove
      1  00f9		       3c		      .byte.b	<aiFlashComputerMove
      0  00fa					      LO	BeginSelectMovePhase
      1  00fa		       1d		      .byte.b	<aiBeginSelectMovePhase
      0  00fb					      LO	SelectStartSquare
      1  00fb		       64		      .byte.b	<aiSelectStartSquare
      0  00fc					      LO	StartSquareSelected
      1  00fc		       e4		      .byte.b	<aiStartSquareSelected
      0  00fd					      LO	DrawMoves
      1  00fd		       ff		      .byte.b	<aiDrawMoves
      0  00fe					      LO	ShowMoveCaptures
      1  00fe		       e2		      .byte.b	<aiShowMoveCaptures
      0  00ff					      LO	SlowFlash
      1  00ff		       04		      .byte.b	<aiSlowFlash
      0  0100					      LO	UnDrawTargetSquares
      1  0100		       bc		      .byte.b	<aiUnDrawTargetSquares
      0  0101					      LO	SelectDestinationSquare
      1  0101		       5b		      .byte.b	<aiSelectDestinationSquare
      0  0102					      LO	Quiescent
      1  0102		       bd		      .byte.b	<aiQuiescent
      0  0103					      LO	ReselectDebounce
      1  0103		       b4		      .byte.b	<aiReselectDebounce
      0  0104					      LO	StartMoveGen
      1  0104		       00		      .byte.b	<aiStartMoveGen
      0  0105					      LO	StepMoveGen
      1  0105		       07		      .byte.b	<aiStepMoveGen
      0  0106					      LO	StartClearBoard
      1  0106		       2c		      .byte.b	<aiStartClearBoard
      0  0107					      LO	ClearEachRow
      1  0107		       39		      .byte.b	<aiClearEachRow
      0  0108					      LO	DrawEntireBoard
      1  0108		       9f		      .byte.b	<aiDrawEntireBoard
      0  0109					      LO	DrawPart2
      1  0109		       d3		      .byte.b	<aiDrawPart2
      0  010a					      LO	DrawPart3
      1  010a		       d6		      .byte.b	<aiDrawPart3
      0  010b					      LO	GenerateMoves
      1  010b		       f5		      .byte.b	<aiGenerateMoves
      0  010c					      LO	ComputerMove
      1  010c		       00		      .byte.b	<aiComputerMove
      0  010d					      LO	MoveIsSelected
      1  010d		       46		      .byte.b	<aiMoveIsSelected
      0  010e					      LO	WriteStartPieceBlank
      1  010e		       84		      .byte.b	<aiWriteStartPieceBlank
      0  010f					      LO	MarchToTargetA
      1  010f		       38		      .byte.b	<aiMarchToTargetA
      0  0110					      LO	MarchA2
      1  0110		       2b		      .byte.b	<aiMarchA2
      0  0111					      LO	MarchB
      1  0111		       f0		      .byte.b	<aiMarchB
      0  0112					      LO	MarchToTargetB
      1  0112		       af		      .byte.b	<aiMarchToTargetB
      0  0113					      LO	MarchB2
      1  0113		       58		      .byte.b	<aiMarchB2
      0  0114					      LO	FinalFlash
      1  0114		       92		      .byte.b	<aiFinalFlash
      0  0115					      LO	SpecialMoveFixup
      1  0115		       66		      .byte.b	<aiSpecialMoveFixup
      0  0116					      LO	InCheckBackup
      1  0116		       05		      .byte.b	<aiInCheckBackup
      0  0117					      LO	InCheckDelay
      1  0117		       10		      .byte.b	<aiInCheckDelay
      0  0118					      LO	PromotePawnStart
      1  0118		       d1		      .byte.b	<aiPromotePawnStart
      0  0119					      LO	RollPromotionPiece
      1  0119		       e5		      .byte.b	<aiRollPromotionPiece
      0  011a					      LO	ChoosePromotePiece
      1  011a		       00		      .byte.b	<aiChoosePromotePiece
      0  011b					      LO	ChooseDebounce
      1  011b		       73		      .byte.b	<aiChooseDebounce
      0  011c					      LO	CheckMate
      1  011c		       05		      .byte.b	<aiCheckMate
      0  011d					      LO	Draw
      1  011d		       00		      .byte.b	<aiDraw
      0  011e					      LO	DelayAfterMove
      1  011e		       85		      .byte.b	<aiDelayAfterMove
      0  011f					      LO	DelayAfterMove2
      1  011f		       8e		      .byte.b	<aiDelayAfterMove2
      0  0120					      LO	DelayAfterPlaced
      1  0120		       97		      .byte.b	<aiDelayAfterPlaced
      0  0121					      LO	DelayAfterPlaced2
      1  0121		       a6		      .byte.b	<aiDelayAfterPlaced2
     43  0122
    349  0122
      0  0122					      DEF	AiVectorHI
      1  0122				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  0122				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  0122				   AiVectorHI
      4  0122				   TEMPORARY_VAR SET	Overlay
      5  0122				   TEMPORARY_OFFSET SET	0
      6  0122				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  0122				   FUNCTION_NAME SET	AiVectorHI
      0  0122					      TABDEF	HI
      1  0122
      0  0122					      HI	FlashComputerMove
      1  0122		       f4		      .byte.b	>aiFlashComputerMove
      0  0123					      HI	BeginSelectMovePhase
      1  0123		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0124					      HI	SelectStartSquare
      1  0124		       f4		      .byte.b	>aiSelectStartSquare
      0  0125					      HI	StartSquareSelected
      1  0125		       f4		      .byte.b	>aiStartSquareSelected
      0  0126					      HI	DrawMoves
      1  0126		       f4		      .byte.b	>aiDrawMoves
      0  0127					      HI	ShowMoveCaptures
      1  0127		       f5		      .byte.b	>aiShowMoveCaptures
      0  0128					      HI	SlowFlash
      1  0128		       f6		      .byte.b	>aiSlowFlash
      0  0129					      HI	UnDrawTargetSquares
      1  0129		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  012a					      HI	SelectDestinationSquare
      1  012a		       f6		      .byte.b	>aiSelectDestinationSquare
      0  012b					      HI	Quiescent
      1  012b		       f6		      .byte.b	>aiQuiescent
      0  012c					      HI	ReselectDebounce
      1  012c		       f6		      .byte.b	>aiReselectDebounce
      0  012d					      HI	StartMoveGen
      1  012d		       f4		      .byte.b	>aiStartMoveGen
      0  012e					      HI	StepMoveGen
      1  012e		       f5		      .byte.b	>aiStepMoveGen
      0  012f					      HI	StartClearBoard
      1  012f		       f8		      .byte.b	>aiStartClearBoard
      0  0130					      HI	ClearEachRow
      1  0130		       f8		      .byte.b	>aiClearEachRow
      0  0131					      HI	DrawEntireBoard
      1  0131		       f5		      .byte.b	>aiDrawEntireBoard
      0  0132					      HI	DrawPart2
      1  0132		       f5		      .byte.b	>aiDrawPart2
      0  0133					      HI	DrawPart3
      1  0133		       f5		      .byte.b	>aiDrawPart3
      0  0134					      HI	GenerateMoves
      1  0134		       f4		      .byte.b	>aiGenerateMoves
      0  0135					      HI	ComputerMove
      1  0135		       f4		      .byte.b	>aiComputerMove
      0  0136					      HI	MoveIsSelected
      1  0136		       f8		      .byte.b	>aiMoveIsSelected
      0  0137					      HI	WriteStartPieceBlank
      1  0137		       f7		      .byte.b	>aiWriteStartPieceBlank
      0  0138					      HI	MarchToTargetA
      1  0138		       f6		      .byte.b	>aiMarchToTargetA
      0  0139					      HI	MarchA2
      1  0139		       f7		      .byte.b	>aiMarchA2
      0  013a					      HI	MarchB
      1  013a		       f5		      .byte.b	>aiMarchB
      0  013b					      HI	MarchToTargetB
      1  013b		       f4		      .byte.b	>aiMarchToTargetB
      0  013c					      HI	MarchB2
      1  013c		       f7		      .byte.b	>aiMarchB2
      0  013d					      HI	FinalFlash
      1  013d		       f6		      .byte.b	>aiFinalFlash
      0  013e					      HI	SpecialMoveFixup
      1  013e		       f5		      .byte.b	>aiSpecialMoveFixup
      0  013f					      HI	InCheckBackup
      1  013f		       f4		      .byte.b	>aiInCheckBackup
      0  0140					      HI	InCheckDelay
      1  0140		       f4		      .byte.b	>aiInCheckDelay
      0  0141					      HI	PromotePawnStart
      1  0141		       f4		      .byte.b	>aiPromotePawnStart
      0  0142					      HI	RollPromotionPiece
      1  0142		       f6		      .byte.b	>aiRollPromotionPiece
      0  0143					      HI	ChoosePromotePiece
      1  0143		       f4		      .byte.b	>aiChoosePromotePiece
      0  0144					      HI	ChooseDebounce
      1  0144		       f4		      .byte.b	>aiChooseDebounce
      0  0145					      HI	CheckMate
      1  0145		       f6		      .byte.b	>aiCheckMate
      0  0146					      HI	Draw
      1  0146		       f6		      .byte.b	>aiDraw
      0  0147					      HI	DelayAfterMove
      1  0147		       f4		      .byte.b	>aiDelayAfterMove
      0  0148					      HI	DelayAfterMove2
      1  0148		       f4		      .byte.b	>aiDelayAfterMove2
      0  0149					      HI	DelayAfterPlaced
      1  0149		       f4		      .byte.b	>aiDelayAfterPlaced
      0  014a					      HI	DelayAfterPlaced2
      1  014a		       f4		      .byte.b	>aiDelayAfterPlaced2
     43  014b
    352  014b
      0  014b					      DEF	AiVectorBANK
      1  014b				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  014b				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  014b				   AiVectorBANK
      4  014b				   TEMPORARY_VAR SET	Overlay
      5  014b				   TEMPORARY_OFFSET SET	0
      6  014b				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  014b				   FUNCTION_NAME SET	AiVectorBANK
      0  014b					      TABDEF	BK
      1  014b
      0  014b					      BK	FlashComputerMove
      1  014b		       46		      .byte.b	BANK_aiFlashComputerMove
      0  014c					      BK	BeginSelectMovePhase
      1  014c		       46		      .byte.b	BANK_aiBeginSelectMovePhase
      0  014d					      BK	SelectStartSquare
      1  014d		       46		      .byte.b	BANK_aiSelectStartSquare
      0  014e					      BK	StartSquareSelected
      1  014e		       46		      .byte.b	BANK_aiStartSquareSelected
      0  014f					      BK	DrawMoves
      1  014f		       46		      .byte.b	BANK_aiDrawMoves
      0  0150					      BK	ShowMoveCaptures
      1  0150		       46		      .byte.b	BANK_aiShowMoveCaptures
      0  0151					      BK	SlowFlash
      1  0151		       46		      .byte.b	BANK_aiSlowFlash
      0  0152					      BK	UnDrawTargetSquares
      1  0152		       46		      .byte.b	BANK_aiUnDrawTargetSquares
      0  0153					      BK	SelectDestinationSquare
      1  0153		       46		      .byte.b	BANK_aiSelectDestinationSquare
      0  0154					      BK	Quiescent
      1  0154		       46		      .byte.b	BANK_aiQuiescent
      0  0155					      BK	ReselectDebounce
      1  0155		       46		      .byte.b	BANK_aiReselectDebounce
      0  0156					      BK	StartMoveGen
      1  0156		       46		      .byte.b	BANK_aiStartMoveGen
      0  0157					      BK	StepMoveGen
      1  0157		       47		      .byte.b	BANK_aiStepMoveGen
      0  0158					      BK	StartClearBoard
      1  0158		       91		      .byte.b	BANK_aiStartClearBoard
      0  0159					      BK	ClearEachRow
      1  0159		       91		      .byte.b	BANK_aiClearEachRow
      0  015a					      BK	DrawEntireBoard
      1  015a		       41		      .byte.b	BANK_aiDrawEntireBoard
      0  015b					      BK	DrawPart2
      1  015b		       41		      .byte.b	BANK_aiDrawPart2
      0  015c					      BK	DrawPart3
      1  015c		       41		      .byte.b	BANK_aiDrawPart3
      0  015d					      BK	GenerateMoves
      1  015d		       47		      .byte.b	BANK_aiGenerateMoves
      0  015e					      BK	ComputerMove
      1  015e		       56		      .byte.b	BANK_aiComputerMove
      0  015f					      BK	MoveIsSelected
      1  015f		       91		      .byte.b	BANK_aiMoveIsSelected
      0  0160					      BK	WriteStartPieceBlank
      1  0160		       46		      .byte.b	BANK_aiWriteStartPieceBlank
      0  0161					      BK	MarchToTargetA
      1  0161		       47		      .byte.b	BANK_aiMarchToTargetA
      0  0162					      BK	MarchA2
      1  0162		       46		      .byte.b	BANK_aiMarchA2
      0  0163					      BK	MarchB
      1  0163		       41		      .byte.b	BANK_aiMarchB
      0  0164					      BK	MarchToTargetB
      1  0164		       47		      .byte.b	BANK_aiMarchToTargetB
      0  0165					      BK	MarchB2
      1  0165		       46		      .byte.b	BANK_aiMarchB2
      0  0166					      BK	FinalFlash
      1  0166		       47		      .byte.b	BANK_aiFinalFlash
      0  0167					      BK	SpecialMoveFixup
      1  0167		       41		      .byte.b	BANK_aiSpecialMoveFixup
      0  0168					      BK	InCheckBackup
      1  0168		       46		      .byte.b	BANK_aiInCheckBackup
      0  0169					      BK	InCheckDelay
      1  0169		       46		      .byte.b	BANK_aiInCheckDelay
      0  016a					      BK	PromotePawnStart
      1  016a		       47		      .byte.b	BANK_aiPromotePawnStart
      0  016b					      BK	RollPromotionPiece
      1  016b		       46		      .byte.b	BANK_aiRollPromotionPiece
      0  016c					      BK	ChoosePromotePiece
      1  016c		       47		      .byte.b	BANK_aiChoosePromotePiece
      0  016d					      BK	ChooseDebounce
      1  016d		       47		      .byte.b	BANK_aiChooseDebounce
      0  016e					      BK	CheckMate
      1  016e		       41		      .byte.b	BANK_aiCheckMate
      0  016f					      BK	Draw
      1  016f		       41		      .byte.b	BANK_aiDraw
      0  0170					      BK	DelayAfterMove
      1  0170		       47		      .byte.b	BANK_aiDelayAfterMove
      0  0171					      BK	DelayAfterMove2
      1  0171		       47		      .byte.b	BANK_aiDelayAfterMove2
      0  0172					      BK	DelayAfterPlaced
      1  0172		       47		      .byte.b	BANK_aiDelayAfterPlaced
      0  0173					      BK	DelayAfterPlaced2
      1  0173		       47		      .byte.b	BANK_aiDelayAfterPlaced2
     43  0174
    355  0174
    356  0174
    357  0174							;---------------------------------------------------------------------------------------------------
    358  0174
      0  0174					      DEF	AiStateMachine
      1  0174				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0174				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0174				   AiStateMachine
      4  0174				   TEMPORARY_VAR SET	Overlay
      5  0174				   TEMPORARY_OFFSET SET	0
      6  0174				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0174				   FUNCTION_NAME SET	AiStateMachine
    360  0174					      SUBROUTINE
    361  0174
      0  0174					      REFER	StartupBankReset	;✅
      1  0174				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0174				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0174					      ENDIF
      0  0174					      VAR	__aiVec, 2
      1  0174		       00 a6	   __aiVec    =	TEMPORARY_VAR
      2  0174				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0174
      4  0174				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0174				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0174				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0174					      ENDIF
      8  0174				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0174				  -	      ECHO	"Temporary Variable", __aiVec, "overflow!"
     10  0174				  -	      ERR
     11  0174					      ENDIF
     12  0174					      LIST	ON
      0  0174					      VEND	AiStateMachine
      1  0174				  -	      IFNCONST	AiStateMachine
      2  0174				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  0174				  -	      ERR
      4  0174					      ENDIF
      5  0174		       00 a8	   VAREND_AiStateMachine =	TEMPORARY_VAR
    365  0174
    366  0174
    367  0174							; State machine vector setup - points to current routine to execute
    368  0174
    369  0174		       a6 8b		      ldx	aiState
    370  0176		       bd f9 f0 	      lda	AiVectorLO,x
    371  0179		       85 a6		      sta	__aiVec
    372  017b		       bd 22 f1 	      lda	AiVectorHI,x
    373  017e		       85 a7		      sta	__aiVec+1
    374  0180
    375  0180		       bd 4b f1 	      lda	AiVectorBANK,x
    376  0183		       85 3f		      sta	SET_BANK
    377  0185		       6c a6 00 	      jmp	(__aiVec)	; NOTE: could branch back to squeeze cycles
    378  0188
    379  0188
    380  0188							;---------------------------------------------------------------------------------------------------
    381  0188
      0  0188					      DEF	GenerateAllMoves
      1  0188				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  0188				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  0188				   GenerateAllMoves
      4  0188				   TEMPORARY_VAR SET	Overlay
      5  0188				   TEMPORARY_OFFSET SET	0
      6  0188				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  0188				   FUNCTION_NAME SET	GenerateAllMoves
    383  0188					      SUBROUTINE
    384  0188
      0  0188					      REFER	ListPlayerMoves	;✅
      1  0188					      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0188				   TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0188					      ENDIF
      0  0188					      REFER	aiComputerMove	;✅
      1  0188				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  0188				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  0188					      ENDIF
      0  0188					      REFER	quiesce	;✅
      1  0188				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0188				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0188					      ENDIF
      0  0188					      REFER	negaMax	;✅
      1  0188				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0188				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0188					      ENDIF
    389  0188
      0  0188					      VAR	__vector, 2
      1  0188		       00 b4	   __vector   =	TEMPORARY_VAR
      2  0188				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0188
      4  0188				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0188					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0188				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0188					      ENDIF
      8  0188				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0188				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  0188				  -	      ERR
     11  0188					      ENDIF
     12  0188					      LIST	ON
      0  0188					      VAR	__pieceFilter, 1
      1  0188		       00 b6	   __pieceFilter =	TEMPORARY_VAR
      2  0188				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0188
      4  0188				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0188					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0188				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0188					      ENDIF
      8  0188				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0188				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  0188				  -	      ERR
     11  0188					      ENDIF
     12  0188					      LIST	ON
    392  0188
      0  0188					      VEND	GenerateAllMoves
      1  0188				  -	      IFNCONST	GenerateAllMoves
      2  0188				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  0188				  -	      ERR
      4  0188					      ENDIF
      5  0188		       00 b7	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    394  0188
    395  0188							; Do the move generation in two passes - pawns then pieces
    396  0188							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    397  0188
    398  0188							;...
    399  0188							; This MUST be called at the start of a new ply
    400  0188							; It initialises the movelist to empty
    401  0188							; x must be preserved
    402  0188
    403  0188		       a5 94		      lda	currentPly
    404  018a		       85 3e		      sta	SET_BANK_RAM	;@2
    405  018c
    406  018c							; note that 'alpha' and 'beta' are set externally!!
    407  018c
    408  018c		       a9 ff		      lda	#-1
      0  018e					      sta@PLY	moveIndex	; no valid moves
      1  018e		       8d cf fb 	      sta	[RAM]+moveIndex
      0  0191					      sta@PLY	bestMove
      1  0191		       8d d1 fb 	      sta	[RAM]+bestMove
    411  0194
    412  0194		       a5 93		      lda	enPassantPawn	; flag/square from last actual move made
      0  0196					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  0196		       8d ca fb 	      sta	[RAM]+enPassantSquare
    414  0199
    415  0199
    416  0199							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    417  0199							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    418  0199							; start of each new ply.
    419  0199
    420  0199		       a5 8f		      lda	Evaluation
      0  019b					      sta@PLY	savedEvaluation
      1  019b		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    422  019e		       a5 90		      lda	Evaluation+1
      0  01a0					      sta@PLY	savedEvaluation+1
      1  01a0		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    424  01a3							;^
    425  01a3
    426  01a3
    427  01a3
    428  01a3		       a9 08		      lda	#8	; pawns
    429  01a5		       85 b6		      sta	__pieceFilter
    430  01a7		       20 b8 f1 	      jsr	MoveGenX
    431  01aa							;lda #99
    432  01aa							;sta currentSquare
    433  01aa		       a9 00		      lda	#0
    434  01ac		       85 b6		      sta	__pieceFilter
    435  01ae		       20 b8 f1 	      jsr	MoveGenX
    436  01b1
    437  01b1		       a9 56		      lda	#BANK_Sort
    438  01b3		       85 3f		      sta	SET_BANK
    439  01b5		       4c 11 f6 	      jmp	Sort	;@1
    440  01b8
    441  01b8
    442  01b8
      0  01b8					      DEF	MoveGenX
      1  01b8				   SLOT_MoveGenX SET	_BANK_SLOT
      2  01b8				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  01b8				   MoveGenX
      4  01b8				   TEMPORARY_VAR SET	Overlay
      5  01b8				   TEMPORARY_OFFSET SET	0
      6  01b8				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  01b8				   FUNCTION_NAME SET	MoveGenX
    444  01b8					      SUBROUTINE
    445  01b8
    446  01b8		       a9 d1		      lda	#RAMBANK_BOARD
    447  01ba		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    448  01bc
    449  01bc		       a2 64		      ldx	#100
    450  01be		       d0 02		      bne	.next
    451  01c0
      0  01c0					      DEF	MoveReturn
      1  01c0				   SLOT_MoveReturn SET	_BANK_SLOT
      2  01c0				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  01c0				   MoveReturn
      4  01c0				   TEMPORARY_VAR SET	Overlay
      5  01c0				   TEMPORARY_OFFSET SET	0
      6  01c0				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  01c0				   FUNCTION_NAME SET	MoveReturn
    453  01c0
    454  01c0		       a6 92		      ldx	currentSquare
    455  01c2		       ca	   .next      dex
    456  01c3		       e0 16		      cpx	#22
    457  01c5		       90 2c		      bcc	.exit
    458  01c7
    459  01c7		       bd 79 fc 	      lda	Board,x
    460  01ca		       f0 f6		      beq	.next
    461  01cc		       c9 ff		      cmp	#-1
    462  01ce		       f0 f2		      beq	.next
    463  01d0		       45 95		      eor	sideToMove
    464  01d2		       30 ee		      bmi	.next
    465  01d4
    466  01d4		       86 92		      stx	currentSquare
    467  01d6
    468  01d6		       45 95		      eor	sideToMove
    469  01d8		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    470  01da		       85 91		      sta	currentPiece
    471  01dc		       29 0f		      and	#PIECE_MASK
    472  01de		       05 b6		      ora	__pieceFilter
    473  01e0		       a8		      tay
    474  01e1
    475  01e1		       b9 08 f2 	      lda	HandlerVectorHI,y
    476  01e4		       85 b5		      sta	__vector+1
    477  01e6		       b9 f8 f1 	      lda	HandlerVectorLO,y
    478  01e9		       85 b4		      sta	__vector
    479  01eb
    480  01eb		       b9 18 f2 	      lda	HandlerVectorBANK,y
    481  01ee		       85 3f		      sta	SET_BANK	;@1
    482  01f0
    483  01f0		       6c b4 00 	      jmp	(__vector)
    484  01f3
    485  01f3
    486  01f3		       a9 56	   .exit      lda	#BANK_negaMax
    487  01f5		       85 3f		      sta	SET_BANK
    488  01f7		       60		      rts
    489  01f8
    490  01f8					      MAC	handlevec
    491  01f8
    492  01f8					      .byte	{1}MoveReturn
    493  01f8					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
    494  01f8					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
    495  01f8					      .byte	{1}Handle_KNIGHT	; 3
    496  01f8					      .byte	{1}Handle_BISHOP	; 4
    497  01f8					      .byte	{1}Handle_ROOK	; 5
    498  01f8					      .byte	{1}Handle_QUEEN	; 6
    499  01f8					      .byte	{1}Handle_KING	; 7
    500  01f8
    501  01f8					      .byte	{1}MoveReturn
    502  01f8					      .byte	{1}Handle_WHITE_PAWN	; 1
    503  01f8					      .byte	{1}Handle_BLACK_PAWN	; 2
    504  01f8					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
    505  01f8					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
    506  01f8					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
    507  01f8					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
    508  01f8					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
    509  01f8					      ENDM
    510  01f8
    511  01f8
    512  01f8							;    .byte 0	  ; dummy to prevent page cross access on index 0
    513  01f8
      0  01f8					      DEF	HandlerVectorLO
      1  01f8				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  01f8				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  01f8				   HandlerVectorLO
      4  01f8				   TEMPORARY_VAR SET	Overlay
      5  01f8				   TEMPORARY_OFFSET SET	0
      6  01f8				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  01f8				   FUNCTION_NAME SET	HandlerVectorLO
      0  01f8					      HANDLEVEC	<
      1  01f8
      2  01f8		       c0		      .byte.b	<MoveReturn
      3  01f9		       c0		      .byte.b	<MoveReturn
      4  01fa		       c0		      .byte.b	<MoveReturn
      5  01fb		       44		      .byte.b	<Handle_KNIGHT
      6  01fc		       ed		      .byte.b	<Handle_BISHOP
      7  01fd		       00		      .byte.b	<Handle_ROOK
      8  01fe		       7b		      .byte.b	<Handle_QUEEN
      9  01ff		       6e		      .byte.b	<Handle_KING
     10  0200
     11  0200		       c0		      .byte.b	<MoveReturn
     12  0201		       29		      .byte.b	<Handle_WHITE_PAWN
     13  0202		       cb		      .byte.b	<Handle_BLACK_PAWN
     14  0203		       c0		      .byte.b	<MoveReturn
     15  0204		       c0		      .byte.b	<MoveReturn
     16  0205		       c0		      .byte.b	<MoveReturn
     17  0206		       c0		      .byte.b	<MoveReturn
     18  0207		       c0		      .byte.b	<MoveReturn
      0  0208					      DEF	HandlerVectorHI
      1  0208				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  0208				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  0208				   HandlerVectorHI
      4  0208				   TEMPORARY_VAR SET	Overlay
      5  0208				   TEMPORARY_OFFSET SET	0
      6  0208				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  0208				   FUNCTION_NAME SET	HandlerVectorHI
      0  0208					      HANDLEVEC	>
      1  0208
      2  0208		       f1		      .byte.b	>MoveReturn
      3  0209		       f1		      .byte.b	>MoveReturn
      4  020a		       f1		      .byte.b	>MoveReturn
      5  020b		       f5		      .byte.b	>Handle_KNIGHT
      6  020c		       f5		      .byte.b	>Handle_BISHOP
      7  020d		       f4		      .byte.b	>Handle_ROOK
      8  020e		       f4		      .byte.b	>Handle_QUEEN
      9  020f		       f5		      .byte.b	>Handle_KING
     10  0210
     11  0210		       f1		      .byte.b	>MoveReturn
     12  0211		       f4		      .byte.b	>Handle_WHITE_PAWN
     13  0212		       f4		      .byte.b	>Handle_BLACK_PAWN
     14  0213		       f1		      .byte.b	>MoveReturn
     15  0214		       f1		      .byte.b	>MoveReturn
     16  0215		       f1		      .byte.b	>MoveReturn
     17  0216		       f1		      .byte.b	>MoveReturn
     18  0217		       f1		      .byte.b	>MoveReturn
      0  0218					      DEF	HandlerVectorBANK
      1  0218				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  0218				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  0218				   HandlerVectorBANK
      4  0218				   TEMPORARY_VAR SET	Overlay
      5  0218				   TEMPORARY_OFFSET SET	0
      6  0218				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  0218				   FUNCTION_NAME SET	HandlerVectorBANK
      0  0218					      HANDLEVEC	BANK_
      1  0218
      2  0218		       00		      .byte.b	BANK_MoveReturn
      3  0219		       00		      .byte.b	BANK_MoveReturn
      4  021a		       00		      .byte.b	BANK_MoveReturn
      5  021b		       57		      .byte.b	BANK_Handle_KNIGHT
      6  021c		       57		      .byte.b	BANK_Handle_BISHOP
      7  021d		       58		      .byte.b	BANK_Handle_ROOK
      8  021e		       58		      .byte.b	BANK_Handle_QUEEN
      9  021f		       58		      .byte.b	BANK_Handle_KING
     10  0220
     11  0220		       00		      .byte.b	BANK_MoveReturn
     12  0221		       57		      .byte.b	BANK_Handle_WHITE_PAWN
     13  0222		       57		      .byte.b	BANK_Handle_BLACK_PAWN
     14  0223		       00		      .byte.b	BANK_MoveReturn
     15  0224		       00		      .byte.b	BANK_MoveReturn
     16  0225		       00		      .byte.b	BANK_MoveReturn
     17  0226		       00		      .byte.b	BANK_MoveReturn
     18  0227		       00		      .byte.b	BANK_MoveReturn
    520  0228
    521  0228
    522  0228							;---------------------------------------------------------------------------------------------------
    523  0228
      0  0228					      DEF	ListPlayerMoves
      1  0228				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  0228				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  0228				   ListPlayerMoves
      4  0228				   TEMPORARY_VAR SET	Overlay
      5  0228				   TEMPORARY_OFFSET SET	0
      6  0228				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  0228				   FUNCTION_NAME SET	ListPlayerMoves
    525  0228					      SUBROUTINE
    526  0228
    527  0228							; Build a list of (mostly) valid player moves. The list of all moves is generated, and then
    528  0228							; these are each verified by making the move and listing all opponent moves. If the opponent
    529  0228							; can capture the king, the move is invalidated by setting its "from" square to zero.
    530  0228
    531  0228							; The movelist is built in the second ply so as not to stomp on the movelist from the computer
    532  0228							; on the previous response. This allows the player movelist to be generated BEFORE the
    533  0228							; computer's move has been visually shown on the screen.
    534  0228
    535  0228							; This in turn requires the minimum memory for PLY banks to be 3 (computer, player, response)
    536  0228
      0  0228					      COMMON_VARS
      1  0228
      0  0228					      VAR	__thinkbar, 1
      1  0228		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
      0  0228					      VAR	__toggle, 1
      1  0228		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
      4  0228
      0  0228					      VAR	__bestMove, 1
      1  0228		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
      0  0228					      VAR	__alpha, 2
      1  0228		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
      0  0228					      VAR	__beta, 2
      1  0228		       00 ab	   __beta     =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
      0  0228					      VAR	__negaMax, 2
      1  0228		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
      0  0228					      VAR	__value, 2
      1  0228		       00 af	   __value    =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
     10  0228
      0  0228					      VAR	__quiesceCapOnly, 1
      1  0228		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
     12  0228
      0  0228					      VAR	__originalPiece, 1
      1  0228		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
      0  0228					      VAR	__capturedPiece, 1
      1  0228		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  0228				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0228
      4  0228				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0228				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0228				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0228					      ENDIF
      8  0228				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0228				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0228				  -	      ERR
     11  0228					      ENDIF
     12  0228					      LIST	ON
     15  0228
      0  0228					      REFER	selectmove	;✅
      1  0228				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0228				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0228					      ENDIF
      0  0228					      REFER	StartupBankReset	;✅
      1  0228				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0228				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0228					      ENDIF
    540  0228
      0  0228					      VEND	ListPlayerMoves
      1  0228				  -	      IFNCONST	ListPlayerMoves
      2  0228				  -	      ECHO	"Incorrect VEND label", ListPlayerMoves
      3  0228				  -	      ERR
      4  0228					      ENDIF
      5  0228		       00 b4	   VAREND_ListPlayerMoves =	TEMPORARY_VAR
    542  0228
    543  0228
    544  0228		       a9 00		      lda	#0
    545  022a		       85 b1		      sta	__quiesceCapOnly	; gen ALL moves
    546  022c
    547  022c		       a9 89		      lda	#RAMBANK_PLY+1
    548  022e		       85 94		      sta	currentPly
    549  0230
    550  0230		       20 88 f1 	      jsr	GenerateAllMoves	;@this
    551  0233
    552  0233		       e6 b1		      inc	__quiesceCapOnly	; only interested in captures now...
    553  0235
      0  0235					      ldx@PLY	moveIndex
      1  0235		       ae cf f9 	      ldx	moveIndex
      0  0238				   .scan      stx@PLY	movePtr
      1  0238		       8e d0 fb 	      stx	[RAM]+movePtr
    556  023b
      0  023b					      CALL	MakeMove	;@1
      1  023b				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  023b				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  023b				  -	      ECHO	"Cannot switch bank in use for", MakeMove
      4  023b				  -	      ERR
      5  023b					      ENDIF
      6  023b		       a9 56		      lda	#BANK_MakeMove
      7  023d		       85 3f		      sta	SET_BANK
      8  023f		       20 87 f4 	      jsr	MakeMove
    558  0242
    559  0242		       e6 94		      inc	currentPly
    560  0244		       20 88 f1 	      jsr	GenerateAllMoves	;@this
    561  0247
    562  0247		       c6 94		      dec	currentPly
    563  0249
    564  0249		       20 87 f2 	      jsr	unmakeMove	;@this
    565  024c
    566  024c		       a5 a1		      lda	flagCheck
    567  024e		       f0 08		      beq	.next
    568  0250
      0  0250					      ldx@PLY	movePtr
      1  0250		       ae d0 f9 	      ldx	movePtr
    570  0253		       a9 00		      lda	#0
      0  0255					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  0255		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    572  0258
      0  0258				   .next      ldx@PLY	movePtr
      1  0258		       ae d0 f9 	      ldx	movePtr
    574  025b		       ca		      dex
    575  025c		       10 da		      bpl	.scan
    576  025e
    577  025e		       60		      rts
    578  025f
    579  025f
    580  025f							;---------------------------------------------------------------------------------------------------
    581  025f
      0  025f					      DEF	AddMove
      1  025f				   SLOT_AddMove SET	_BANK_SLOT
      2  025f				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  025f				   AddMove
      4  025f				   TEMPORARY_VAR SET	Overlay
      5  025f				   TEMPORARY_OFFSET SET	0
      6  025f				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  025f				   FUNCTION_NAME SET	AddMove
    583  025f					      SUBROUTINE
    584  025f
      0  025f					      REFER	Handle_KING	;✅
      1  025f					      IF	VAREND_Handle_KING > TEMPORARY_VAR
      2  025f				   TEMPORARY_VAR SET	VAREND_Handle_KING
      3  025f					      ENDIF
      0  025f					      REFER	Handle_QUEEN	;✅
      1  025f				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  025f				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  025f					      ENDIF
      0  025f					      REFER	Handle_ROOK	;✅
      1  025f				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  025f				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  025f					      ENDIF
      0  025f					      REFER	Handle_BISHOP	;✅
      1  025f				  -	      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  025f				  -TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  025f					      ENDIF
      0  025f					      REFER	Handle_KNIGHT	;✅
      1  025f				  -	      IF	VAREND_Handle_KNIGHT > TEMPORARY_VAR
      2  025f				  -TEMPORARY_VAR SET	VAREND_Handle_KNIGHT
      3  025f					      ENDIF
      0  025f					      REFER	Handle_WHITE_PAWN	;✅
      1  025f				  -	      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  025f				  -TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  025f					      ENDIF
      0  025f					      REFER	Handle_BLACK_PAWN	;✅
      1  025f				  -	      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  025f				  -TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  025f					      ENDIF
    592  025f
      0  025f					      VEND	AddMove
      1  025f				  -	      IFNCONST	AddMove
      2  025f				  -	      ECHO	"Incorrect VEND label", AddMove
      3  025f				  -	      ERR
      4  025f					      ENDIF
      5  025f		       00 b7	   VAREND_AddMove =	TEMPORARY_VAR
    594  025f
    595  025f							; add square in y register to movelist as destination (X12 format)
    596  025f							; [y]		     to square (X12)
    597  025f							; currentSquare     from square (X12)
    598  025f							; currentPiece      piece.
    599  025f							;   ENPASSANT flag set if pawn double-moving off opening rank
    600  025f							; capture	     captured piece
    601  025f
    602  025f
    603  025f		       a5 9d		      lda	capture
    604  0261		       d0 04		      bne	.always
    605  0263		       a5 b1		      lda	__quiesceCapOnly
    606  0265		       d0 1c		      bne	.abort
    607  0267
    608  0267		       98	   .always    tya
    609  0268		       aa		      tax
    610  0269
      0  0269					      ldy@PLY	moveIndex
      1  0269		       ac cf f9 	      ldy	moveIndex
    612  026c		       c8		      iny
      0  026d					      sty@PLY	moveIndex
      1  026d		       8c cf fb 	      sty	[RAM]+moveIndex
    614  0270
      0  0270					      sta@PLY	MoveTo,y
      1  0270		       99 64 fa 	      sta	[RAM]+MoveTo,y
    616  0273		       a5 92		      lda	currentSquare
      0  0275					      sta@PLY	MoveFrom,y
      1  0275		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    618  0278		       a5 91		      lda	currentPiece
      0  027a					      sta@PLY	MovePiece,y
      1  027a		       99 00 fb 	      sta	[RAM]+MovePiece,y
    620  027d		       a5 9d		      lda	capture
      0  027f					      sta@PLY	MoveCapture,y
      1  027f		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    622  0282		       60		      rts
    623  0283
    624  0283		       98	   .abort     tya
    625  0284		       aa		      tax
    626  0285		       60		      rts
    627  0286
    628  0286
    629  0286
    630  0286							;---------------------------------------------------------------------------------------------------
    631  0286
      0  0286					      DEF	debug
      1  0286				   SLOT_debug SET	_BANK_SLOT
      2  0286				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  0286				   debug
      4  0286				   TEMPORARY_VAR SET	Overlay
      5  0286				   TEMPORARY_OFFSET SET	0
      6  0286				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  0286				   FUNCTION_NAME SET	debug
    633  0286					      SUBROUTINE
    634  0286		       60		      rts
    635  0287
    636  0287
    637  0287							;---------------------------------------------------------------------------------------------------
    638  0287
      0  0287					      DEF	unmakeMove
      1  0287				   SLOT_unmakeMove SET	_BANK_SLOT
      2  0287				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  0287				   unmakeMove
      4  0287				   TEMPORARY_VAR SET	Overlay
      5  0287				   TEMPORARY_OFFSET SET	0
      6  0287				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  0287				   FUNCTION_NAME SET	unmakeMove
    640  0287					      SUBROUTINE
    641  0287
      0  0287					      REFER	selectmove	;✅
      1  0287					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0287				   TEMPORARY_VAR SET	VAREND_selectmove
      3  0287					      ENDIF
      0  0287					      REFER	ListPlayerMoves	;✅
      1  0287				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0287				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0287					      ENDIF
      0  0287					      REFER	quiesce	;✅
      1  0287				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0287				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0287					      ENDIF
      0  0287					      REFER	negaMax	;✅
      1  0287				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0287				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0287					      ENDIF
      0  0287					      VEND	unmakeMove
      1  0287				  -	      IFNCONST	unmakeMove
      2  0287				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  0287				  -	      ERR
      4  0287					      ENDIF
      5  0287		       00 b4	   VAREND_unmakeMove =	TEMPORARY_VAR
    647  0287
    648  0287							; restore the board evaluation to what it was at the start of this ply
    649  0287							; TODO: note: moved flag seems wrong on restoration??
    650  0287
    651  0287		       a5 94		      lda	currentPly
    652  0289		       85 3e		      sta	SET_BANK_RAM	;@2
    653  028b		       a2 d1		      ldx	#RAMBANK_BOARD
    654  028d		       86 3e		      stx	SET_BANK_RAM	;@3
    655  028f
      0  028f					      lda@PLY	savedEvaluation
      1  028f		       ad c8 f9 	      lda	savedEvaluation
    657  0292		       85 8f		      sta	Evaluation
      0  0294					      lda@PLY	savedEvaluation+1
      1  0294		       ad c9 f9 	      lda	savedEvaluation+1
    659  0297		       85 90		      sta	Evaluation+1
    660  0299
      0  0299					      ldx@PLY	movePtr
      1  0299		       ae d0 f9 	      ldx	movePtr
      0  029c					      ldy@PLY	MoveFrom,x
      1  029c		       bc 00 f8 	      ldy	MoveFrom,x
      0  029f					      lda@PLY	restorePiece
      1  029f		       ad d9 f9 	      lda	restorePiece
      0  02a2					      sta@RAM	Board,y
      1  02a2		       99 79 fe 	      sta	[RAM]+Board,y
    665  02a5
      0  02a5					      ldy@PLY	MoveTo,x
      1  02a5		       bc 64 f8 	      ldy	MoveTo,x
      0  02a8					      lda@PLY	capturedPiece
      1  02a8		       ad cb f9 	      lda	capturedPiece
      0  02ab					      sta@RAM	Board,y
      1  02ab		       99 79 fe 	      sta	[RAM]+Board,y
    669  02ae
    670  02ae
    671  02ae							; See if there are any 'secondary' pieces that moved
    672  02ae							; here we're dealing with reverting a castling or enPassant move
    673  02ae
      0  02ae					      lda@PLY	secondaryPiece
      1  02ae		       ad cc f9 	      lda	secondaryPiece
    675  02b1		       f0 0e		      beq	.noSecondary
      0  02b3					      ldx@PLY	secondarySquare
      1  02b3		       ae cd f9 	      ldx	secondarySquare
      0  02b6					      sta@RAM	Board,x	; put piece back
      1  02b6		       9d 79 fe 	      sta	[RAM]+Board,x
      0  02b9					      ldy@PLY	secondaryBlank
      1  02b9		       ac ce f9 	      ldy	secondaryBlank
    679  02bc		       a9 00		      lda	#0
      0  02be					      sta@RAM	Board,y	; blank piece origin
      1  02be		       99 79 fe 	      sta	[RAM]+Board,y
    681  02c1
      0  02c1				   .noSecondary SWAP
      1  02c1		       a5 95		      lda	sideToMove
      2  02c3		       49 80		      eor	#SWAP_SIDE
      3  02c5		       85 95		      sta	sideToMove
      4  02c7
      5  02c7
    683  02c7		       60		      rts
    684  02c8
    685  02c8
    686  02c8							;---------------------------------------------------------------------------------------------------
    687  02c8
      0  02c8					      DEF	showMoveCaptures
      1  02c8				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  02c8				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  02c8				   showMoveCaptures
      4  02c8				   TEMPORARY_VAR SET	Overlay
      5  02c8				   TEMPORARY_OFFSET SET	0
      6  02c8				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  02c8				   FUNCTION_NAME SET	showMoveCaptures
    689  02c8					      SUBROUTINE
    690  02c8
      0  02c8					      REFER	aiShowMoveCaptures	;✅
      1  02c8					      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  02c8				   TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  02c8					      ENDIF
    692  02c8
      0  02c8					      VAR	__toSquareX12, 1
      1  02c8		       00 a8	   __toSquareX12 =	TEMPORARY_VAR
      2  02c8				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02c8
      4  02c8				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02c8				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02c8				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02c8					      ENDIF
      8  02c8				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02c8				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  02c8				  -	      ERR
     11  02c8					      ENDIF
     12  02c8					      LIST	ON
      0  02c8					      VAR	__fromPiece, 1
      1  02c8		       00 a9	   __fromPiece =	TEMPORARY_VAR
      2  02c8				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02c8
      4  02c8				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02c8				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02c8				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02c8					      ENDIF
      8  02c8				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02c8				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  02c8				  -	      ERR
     11  02c8					      ENDIF
     12  02c8					      LIST	ON
      0  02c8					      VAR	__aiMoveIndex, 1
      1  02c8		       00 aa	   __aiMoveIndex =	TEMPORARY_VAR
      2  02c8				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02c8
      4  02c8				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02c8				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02c8				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02c8					      ENDIF
      8  02c8				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02c8				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  02c8				  -	      ERR
     11  02c8					      ENDIF
     12  02c8					      LIST	ON
    696  02c8
      0  02c8					      VEND	showMoveCaptures
      1  02c8				  -	      IFNCONST	showMoveCaptures
      2  02c8				  -	      ECHO	"Incorrect VEND label", showMoveCaptures
      3  02c8				  -	      ERR
      4  02c8					      ENDIF
      5  02c8		       00 ab	   VAREND_showMoveCaptures =	TEMPORARY_VAR
    698  02c8
    699  02c8							; place a marker on the board for any square matching the piece
    700  02c8							; EXCEPT for squares which are occupied (we'll flash those later)
    701  02c8							; x = movelist item # being checked
    702  02c8
    703  02c8
    704  02c8		       a6 8d	   .next      ldx	aiMoveIndex
    705  02ca		       86 aa		      stx	__aiMoveIndex
    706  02cc		       30 4a		      bmi	.skip	; no moves in list
    707  02ce
    708  02ce		       ad 84 02 	      lda	INTIM
    709  02d1		       c9 14		      cmp	#20
    710  02d3		       90 43		      bcc	.skip
    711  02d5
    712  02d5		       c6 8d		      dec	aiMoveIndex
    713  02d7
    714  02d7		       a9 89		      lda	#RAMBANK_PLY+1
    715  02d9		       85 3e		      sta	SET_BANK_RAM
      0  02db					      lda@PLY	MoveFrom,x
      1  02db		       bd 00 f8 	      lda	MoveFrom,x
    717  02de		       c5 85		      cmp	fromX12
    718  02e0		       d0 e6		      bne	.next
    719  02e2
      0  02e2					      lda@PLY	MoveTo,x
      1  02e2		       bd 64 f8 	      lda	MoveTo,x
    721  02e5		       85 a8		      sta	__toSquareX12
    722  02e7		       a8		      tay
    723  02e8
    724  02e8		       a9 d1		      lda	#RAMBANK_BOARD
    725  02ea		       85 3e		      sta	SET_BANK_RAM	;@3
    726  02ec		       b9 79 fc 	      lda	Board,y
    727  02ef		       29 0f		      and	#PIECE_MASK
    728  02f1		       f0 d5		      beq	.next
    729  02f3
    730  02f3							; There's something on the board at destination, so it's a capture
    731  02f3							; Let's see if we are doing a pawn promote...
    732  02f3
    733  02f3		       a4 85		      ldy	fromX12
    734  02f5
    735  02f5		       a9 d1		      lda	#RAMBANK_BOARD
    736  02f7		       85 3e		      sta	SET_BANK_RAM	;@3
    737  02f9		       b9 79 fc 	      lda	Board,y
    738  02fc		       85 a9		      sta	__fromPiece
    739  02fe
    740  02fe		       a9 89		      lda	#RAMBANK_PLY+1
    741  0300		       85 3e		      sta	SET_BANK_RAM
      0  0302					      lda@PLY	MovePiece,x
      1  0302		       bd 00 f9 	      lda	MovePiece,x
    743  0305		       45 a9		      eor	__fromPiece
    744  0307		       29 0f		      and	#PIECE_MASK
    745  0309		       f0 06		      beq	.legit	; from == to, so not a promote
    746  030b
    747  030b							; Have detected a promotion duplicate - skip all 3 of them
    748  030b
    749  030b		       c6 8d		      dec	aiMoveIndex	; skip "KBRQ" promotes
    750  030d		       c6 8d		      dec	aiMoveIndex
    751  030f		       c6 8d		      dec	aiMoveIndex
    752  0311
    753  0311				   .legit
    754  0311
    755  0311							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
    756  0311
    757  0311		       a5 a8		      lda	__toSquareX12
    758  0313		       85 80		      sta	squareToDraw
    759  0315
    760  0315		       20 be f0 	      jsr	CopySinglePiece	;@0
    761  0318
    762  0318		       60	   .skip      rts
    763  0319
    764  0319
    765  0319							;---------------------------------------------------------------------------------------------------
    766  0319
      0  0319					      DEF	CopyPieceToRowBitmap
      1  0319				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  0319				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  0319				   CopyPieceToRowBitmap
      4  0319				   TEMPORARY_VAR SET	Overlay
      5  0319				   TEMPORARY_OFFSET SET	0
      6  0319				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  0319				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    768  0319					      SUBROUTINE
    769  0319
      0  0319					      REFER	InterceptMarkerCopy	;✅
      1  0319					      IF	VAREND_InterceptMarkerCopy > TEMPORARY_VAR
      2  0319				   TEMPORARY_VAR SET	VAREND_InterceptMarkerCopy
      3  0319					      ENDIF
    771  0319
      0  0319					      VEND	CopyPieceToRowBitmap
      1  0319				  -	      IFNCONST	CopyPieceToRowBitmap
      2  0319				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  0319				  -	      ERR
      4  0319					      ENDIF
      5  0319		       00 ab	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
    773  0319
    774  0319		       a0 11		      ldy	#17
    775  031b		       b0 30		      bcs	.rightSide
    776  031d
    777  031d		       b9 a6 00    .copyPiece lda	__pieceShapeBuffer,y
    778  0320		       f0 06		      beq	.blank1
    779  0322		       59 00 f8 	      eor	ChessBitmap,y
      0  0325					      sta@RAM	ChessBitmap,y
      1  0325		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    781  0328
    782  0328		       b9 b8 00    .blank1    lda	__pieceShapeBuffer+18,y
    783  032b		       f0 06		      beq	.blank2
    784  032d		       59 12 f8 	      eor	ChessBitmap+18,y
      0  0330					      sta@RAM	ChessBitmap+18,y
      1  0330		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    786  0333
    787  0333		       b9 ca 00    .blank2    lda	__pieceShapeBuffer+36,y
    788  0336		       f0 06		      beq	.blank3
    789  0338		       59 24 f8 	      eor	ChessBitmap+36,y
      0  033b					      sta@RAM	ChessBitmap+36,y
      1  033b		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    791  033e
    792  033e		       b9 dc 00    .blank3    lda	__pieceShapeBuffer+54,y
    793  0341		       f0 06		      beq	.blank4
    794  0343		       59 36 f8 	      eor	ChessBitmap+54,y
      0  0346					      sta@RAM	ChessBitmap+54,y
      1  0346		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    796  0349
    797  0349		       88	   .blank4    dey
    798  034a		       10 d1		      bpl	.copyPiece
    799  034c		       60		      rts
    800  034d
    801  034d				   .rightSide
    802  034d
    803  034d					      SUBROUTINE
    804  034d
    805  034d		       b9 a6 00    .copyPieceR lda	__pieceShapeBuffer,y
    806  0350		       f0 06		      beq	.blank1
    807  0352		       59 48 f8 	      eor	ChessBitmap+72,y
      0  0355					      sta@RAM	ChessBitmap+72,y
      1  0355		       99 48 fa 	      sta	[RAM]+ChessBitmap+72,y
    809  0358
    810  0358		       b9 b8 00    .blank1    lda	__pieceShapeBuffer+18,y
    811  035b		       f0 06		      beq	.blank2
    812  035d		       59 5a f8 	      eor	ChessBitmap+72+18,y
      0  0360					      sta@RAM	ChessBitmap+72+18,y
      1  0360		       99 5a fa 	      sta	[RAM]+ChessBitmap+72+18,y
    814  0363
    815  0363		       b9 ca 00    .blank2    lda	__pieceShapeBuffer+36,y
    816  0366		       f0 06		      beq	.blank3
    817  0368		       59 6c f8 	      eor	ChessBitmap+72+36,y
      0  036b					      sta@RAM	ChessBitmap+72+36,y
      1  036b		       99 6c fa 	      sta	[RAM]+ChessBitmap+72+36,y
    819  036e
    820  036e		       b9 dc 00    .blank3    lda	__pieceShapeBuffer+54,y
    821  0371		       f0 06		      beq	.blank4
    822  0373		       59 7e f8 	      eor	ChessBitmap+72+54,y
      0  0376					      sta@RAM	ChessBitmap+72+54,y
      1  0376		       99 7e fa 	      sta	[RAM]+ChessBitmap+72+54,y
    824  0379
    825  0379		       88	   .blank4    dey
    826  037a		       10 d1		      bpl	.copyPieceR
    827  037c		       60		      rts
    828  037d
    829  037d							;---------------------------------------------------------------------------------------------------
    830  037d
 FREE BYTES IN BANK_FIRST@0 BANK =  $7f
    831  037d					      ECHO	"FREE BYTES IN BANK_FIRST@0 BANK = ", $F3FC - *
    832  037d
    833  037d							;---------------------------------------------------------------------------------------------------
    834  037d							; The reset vectors
    835  037d							; these must live in the first 1K bank of the ROM
    836  037d
    837  0400 ????				      SEG	StartupInterruptVectors
    838  03fc					      ORG	_FIRST_BANK + $3FC
    839  03fc
    840  03fc		       00 f0		      .word.w	StartupBankReset	; RESET
    841  03fe		       00 f0		      .word.w	StartupBankReset	; IRQ	      (not used)
    842  0400
    843  0400							;---------------------------------------------------------------------------------------------------
    844  0400
    845  0400
    846  0400							; EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#1.asm LEVEL 2 PASS 4
      0  0400					      include	"BANK_GENERIC@1#1.asm"
      1  0400							; Chess
      2  0400							; Copyright (c) 2019-2020 Andrew Davie
      3  0400							; andrew@taswegian.com
      4  0400
      0  0400					      SLOT	1	; which bank this code switches to
      1  0400				  -	      IF	(1 < 0) || (1 > 3)
      2  0400				  -	      ECHO	"Illegal bank address/segment location", 1
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  0400				   _BANK_SLOT SET	1 * 64
      0  0400					      NEWBANK	ONE
      1  060a ????				      SEG	ONE
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   ONE_START  SET	*
      6  0400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0400				   ONE	      SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + 1024
      7  0400
      8  0400
      9  0400							;---------------------------------------------------------------------------------------------------
     10  0400							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     11  0400							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     12  0400							; bank finishes.  Just continue on from where it left off...
     13  0400							;---------------------------------------------------------------------------------------------------
     14  0400
      0  0400					      DEF	CartInit
      1  0400				   SLOT_CartInit SET	_BANK_SLOT
      2  0400				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0400				   CartInit
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	CartInit
     16  0400					      SUBROUTINE
     17  0400
      0  0400					      REFER	StartupBankReset	;✅
      1  0400				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0400				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0400					      ENDIF
     19  0400
      0  0400					      VEND	CartInit
      1  0400				  -	      IFNCONST	CartInit
      2  0400				  -	      ECHO	"Incorrect VEND label", CartInit
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400		       00 a6	   VAREND_CartInit =	TEMPORARY_VAR
     21  0400
     22  0400		       78		      sei
     23  0401		       d8		      cld
     24  0402							; See if we can come up with something 'random' for startup
     25  0402
     26  0402		       ac 84 02 	      ldy	INTIM
     27  0405		       d0 02		      bne	.toR
     28  0407		       a0 9a		      ldy	#$9A
     29  0409		       84 81	   .toR       sty	rnd
     30  040b
     31  040b		       a9 3f		      lda	#63
     32  040d		       85 a3		      sta	randomness
     33  040f
     34  040f		       a9 00		      lda	#0
     35  0411		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     36  0414		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     37  0417		       85 6b		      sta	HMCLR
     38  0419
     39  0419							; cleanup remains of title screen
     40  0419							;sta GRP0
     41  0419							;sta GRP1
     42  0419
     43  0419		       a9 07		      lda	#%111
     44  041b		       85 44		      sta	NUSIZ0
     45  041d		       85 45		      sta	NUSIZ1	; quad-width
     46  041f
     47  041f							;lda #%00000100
     48  041f							;sta CTRLPF
     49  041f		       a9 00		      lda	#BACKGCOL
     50  0421		       85 49		      sta	COLUBK
     51  0423
     52  0423
     53  0423		       a9 00		      lda	#WHITE	;tmp+RAMBANK_PLY
     54  0425		       85 95		      sta	sideToMove
     55  0427
     56  0427		       60		      rts
     57  0428
     58  0428
     59  0428							;---------------------------------------------------------------------------------------------------
     60  0428
      0  0428					      DEF	SetupBanks
      1  0428				   SLOT_SetupBanks SET	_BANK_SLOT
      2  0428				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  0428				   SetupBanks
      4  0428				   TEMPORARY_VAR SET	Overlay
      5  0428				   TEMPORARY_OFFSET SET	0
      6  0428				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  0428				   FUNCTION_NAME SET	SetupBanks
     62  0428					      SUBROUTINE
     63  0428
     64  0428							; Move a copy of the row bank template to the first 8 banks of RAM
     65  0428							; and then terminate the draw subroutine by substituting in a RTS on the last one
     66  0428
      0  0428					      REFER	StartupBankReset	;✅
      1  0428				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0428				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0428					      ENDIF
      0  0428					      VEND	SetupBanks
      1  0428				  -	      IFNCONST	SetupBanks
      2  0428				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  0428				  -	      ERR
      4  0428					      ENDIF
      5  0428		       00 a6	   VAREND_SetupBanks =	TEMPORARY_VAR
     69  0428
     70  0428							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     71  0428
     72  0428				   .ROWBANK   SET	0
     73  0428					      REPEAT	8
     74  0428		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  042a		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     76  042c		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  042c				   .ROWBANK   SET	.ROWBANK+1
     73  042c					      REPEND
     74  042f		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  0431		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     76  0433		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  0433				   .ROWBANK   SET	.ROWBANK+1
     73  0433					      REPEND
     74  0436		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  0438		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     76  043a		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  043a				   .ROWBANK   SET	.ROWBANK+1
     73  043a					      REPEND
     74  043d		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  043f		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     76  0441		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  0441				   .ROWBANK   SET	.ROWBANK+1
     73  0441					      REPEND
     74  0444		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  0446		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     76  0448		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  0448				   .ROWBANK   SET	.ROWBANK+1
     73  0448					      REPEND
     74  044b		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  044d		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     76  044f		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  044f				   .ROWBANK   SET	.ROWBANK+1
     73  044f					      REPEND
     74  0452		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  0454		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     76  0456		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  0456				   .ROWBANK   SET	.ROWBANK+1
     73  0456					      REPEND
     74  0459		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     75  045b		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     76  045d		       20 71 f4 	      jsr	CopyShadowROMtoRAM
     77  045d				   .ROWBANK   SET	.ROWBANK+1
     78  0460					      REPEND
     79  0460
     80  0460
     81  0460							; Patch the final row's "loop" to a RTS
     82  0460
     83  0460		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     84  0462		       86 3e		      stx	SET_BANK_RAM
     85  0464		       a9 60		      lda	#$60	; "rts"
      0  0466					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0466		       8d 00 fb 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     87  0469
     88  0469
     89  0469
     90  0469							; copy the BOARD/MOVES bank
     91  0469
     92  0469		       a2 84		      ldx	#SHADOW_BOARD
     93  046b		       a0 d1		      ldy	#RAMBANK_BOARD
     94  046d		       20 71 f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
     95  0470
     96  0470
     97  0470							; copy the PLY banks
     98  0470							; If there's no content (only variable decs) then we don't really need to do this.
     99  0470
    100  0470							;.PLY SET 0
    101  0470							;    REPEAT PLY_BANKS
    102  0470
    103  0470							;		      ldx #SHADOW_PLY
    104  0470							;		      ldy #RAMBANK_PLY + .PLY
    105  0470							;jsr CopyShadowROMtoRAM
    106  0470							;.PLY SET .PLY + 1
    107  0470							;    REPEND
    108  0470
    109  0470							; copy the evaluation code/tables
    110  0470							; 3E+ moved from RAM to ROM
    111  0470
    112  0470							;		      ldx #[SLOT2] + SHADOW_EVAL
    113  0470							;		      ldy #[SLOT3] + EVAL
    114  0470							;		      jsr CopyShadowROMtoRAM
    115  0470
    116  0470
    117  0470							;		      ldy #RAMBANK_RAM_PIECELIST
    118  0470							;		      ldx #ROM_PIECELIST
    119  0470							;		      jsr CopyShadowROMtoRAM
    120  0470
    121  0470		       60		      rts
    122  0471
    123  0471
    124  0471							;---------------------------------------------------------------------------------------------------
    125  0471
      0  0471					      DEF	CopyShadowROMtoRAM
      1  0471				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  0471				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  0471				   CopyShadowROMtoRAM
      4  0471				   TEMPORARY_VAR SET	Overlay
      5  0471				   TEMPORARY_OFFSET SET	0
      6  0471				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  0471				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    127  0471					      SUBROUTINE
    128  0471
      0  0471					      REFER	SetupBanks	;✅
      1  0471				  -	      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  0471				  -TEMPORARY_VAR SET	VAREND_SetupBanks
      3  0471					      ENDIF
    130  0471
      0  0471					      VEND	CopyShadowROMtoRAM
      1  0471				  -	      IFNCONST	CopyShadowROMtoRAM
      2  0471				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  0471				  -	      ERR
      4  0471					      ENDIF
      5  0471		       00 a6	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    132  0471
    133  0471							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    134  0471							; used to setup callable RAM code from ROM templates
    135  0471
    136  0471							; x = source ROM bank
    137  0471							; y = destination RAM bank (preserved)
    138  0471
    139  0471		       86 3f		      stx	SET_BANK
    140  0473		       84 3e		      sty	SET_BANK_RAM
    141  0475
    142  0475		       a2 00		      ldx	#0
    143  0477		       bd 00 f8    .copyPage  lda	$F800,x
      0  047a					      sta@RAM	$FC00,x
      1  047a		       9d 00 fe 	      sta	[RAM]+$FC00,x
    145  047d		       bd 00 f9 	      lda	$F900,x
      0  0480					      sta@RAM	$FD00,x
      1  0480		       9d 00 ff 	      sta	[RAM]+$FD00,x
    147  0483		       ca		      dex
    148  0484		       d0 f1		      bne	.copyPage
    149  0486		       60		      rts
    150  0487
    151  0487
    152  0487							;---------------------------------------------------------------------------------------------------
    153  0487
      0  0487					      DEF	CallClear
      1  0487				   SLOT_CallClear SET	_BANK_SLOT
      2  0487				   BANK_CallClear SET	SLOT_CallClear + _CURRENT_BANK
      3  0487				   CallClear
      4  0487				   TEMPORARY_VAR SET	Overlay
      5  0487				   TEMPORARY_OFFSET SET	0
      6  0487				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      7  0487				   FUNCTION_NAME SET	CallClear
    155  0487					      SUBROUTINE
    156  0487
    157  0487				  -	      IF	0
    158  0487				  -	      REFER	aiClearEachRow	;TODO
    159  0487					      ENDIF
    160  0487
      0  0487					      VEND	CallClear
      1  0487				  -	      IFNCONST	CallClear
      2  0487				  -	      ECHO	"Incorrect VEND label", CallClear
      3  0487				  -	      ERR
      4  0487					      ENDIF
      5  0487		       00 a6	   VAREND_CallClear =	TEMPORARY_VAR
    162  0487
    163  0487				  -	      IF	0
    164  0487				  -			; No transient variable dependencies/calls
    165  0487				  -
    166  0487				  -	      sty	SET_BANK_RAM
    167  0487				  -	      jsr	ClearRowBitmap
    168  0487					      ENDIF
    169  0487		       60		      rts
    170  0488
    171  0488
    172  0488							;---------------------------------------------------------------------------------------------------
    173  0488
      0  0488					      DEF	InitialisePieceSquares
      1  0488				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  0488				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  0488				   InitialisePieceSquares
      4  0488				   TEMPORARY_VAR SET	Overlay
      5  0488				   TEMPORARY_OFFSET SET	0
      6  0488				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  0488				   FUNCTION_NAME SET	InitialisePieceSquares
    175  0488					      SUBROUTINE
    176  0488
      0  0488					      COMMON_VARS
      1  0488
      0  0488					      VAR	__thinkbar, 1
      1  0488		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__toggle, 1
      1  0488		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      4  0488
      0  0488					      VAR	__bestMove, 1
      1  0488		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__alpha, 2
      1  0488		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__beta, 2
      1  0488		       00 ab	   __beta     =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__negaMax, 2
      1  0488		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__value, 2
      1  0488		       00 af	   __value    =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
     10  0488
      0  0488					      VAR	__quiesceCapOnly, 1
      1  0488		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
     12  0488
      0  0488					      VAR	__originalPiece, 1
      1  0488		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__capturedPiece, 1
      1  0488		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
     15  0488
      0  0488					      REFER	StartupBankReset	;✅
      1  0488				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0488				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0488					      ENDIF
    179  0488
      0  0488					      VAR	__initPiece, 1
      1  0488		       00 b4	   __initPiece =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__initSquare, 1
      1  0488		       00 b5	   __initSquare =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__initListPtr, 1
      1  0488		       00 b6	   __initListPtr =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
      0  0488					      VAR	__op, 1
      1  0488		       00 b7	   __op       =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0488				  -	      ECHO	"Temporary Variable", __op, "overflow!"
     10  0488				  -	      ERR
     11  0488					      ENDIF
     12  0488					      LIST	ON
    184  0488
      0  0488					      VEND	InitialisePieceSquares
      1  0488				  -	      IFNCONST	InitialisePieceSquares
      2  0488				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  0488				  -	      ERR
      4  0488					      ENDIF
      5  0488		       00 b8	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    186  0488
    187  0488		       a9 00		      lda	#0
    188  048a		       85 8f		      sta	Evaluation
    189  048c		       85 90		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    190  048e		       85 93		      sta	enPassantPawn	; no en-passant
    191  0490
    192  0490
      0  0490					      PHASE	AI_StartClearBoard
      1  0490		       a9 0d		      lda	#AI_StartClearBoard
      2  0492		       85 8b		      sta	aiState
    194  0494
    195  0494		       a2 00		      ldx	#0
    196  0496				   .fillPieceLists
    197  0496
    198  0496
    199  0496		       bd e8 f4 	      lda	InitPieceList,x	; colour/-1
    200  0499		       f0 4c		      beq	.exit
    201  049b		       85 b7		      sta	__op	; type
    202  049d		       bc e9 f4 	      ldy	InitPieceList+1,x	; square
    203  04a0		       84 b5		      sty	__initSquare
    204  04a2
    205  04a2		       a9 d1		      lda	#RAMBANK_BOARD
    206  04a4		       85 3e		      sta	SET_BANK_RAM
    207  04a6		       a5 b7		      lda	__op
      0  04a8					      sta@RAM	Board,y
      1  04a8		       99 79 fe 	      sta	[RAM]+Board,y
    209  04ab		       10 0d		      bpl	.white
    210  04ad
      0  04ad					      NEGEVAL
      1  04ad
      2  04ad		       38		      sec
      3  04ae		       a9 00		      lda	#0
      4  04b0		       e5 8f		      sbc	Evaluation
      5  04b2		       85 8f		      sta	Evaluation
      6  04b4		       a9 00		      lda	#0
      7  04b6		       e5 90		      sbc	Evaluation+1
      8  04b8		       85 90		      sta	Evaluation+1
    212  04ba				   .white
    213  04ba
    214  04ba		       86 b6		      stx	__initListPtr
    215  04bc
    216  04bc							; Add the material value of the piece to the evaluation
    217  04bc
    218  04bc		       a5 b7		      lda	__op
    219  04be		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    220  04c0		       86 3f		      stx	SET_BANK	;@2
    221  04c2		       20 11 f9 	      jsr	AddPieceMaterialValue
    222  04c5
    223  04c5
    224  04c5							; add the positional value of the piece to the evaluation
    225  04c5
    226  04c5		       a4 b5		      ldy	__initSquare
    227  04c7		       a5 b7		      lda	__op
    228  04c9		       a2 91		      ldx	#BANK_AddPiecePositionValue
    229  04cb		       86 3f		      stx	SET_BANK
    230  04cd		       20 34 f9 	      jsr	AddPiecePositionValue
    231  04d0
    232  04d0		       a5 b7		      lda	__op	; type/colour
    233  04d2		       10 0d		      bpl	.white2
      0  04d4					      NEGEVAL
      1  04d4
      2  04d4		       38		      sec
      3  04d5		       a9 00		      lda	#0
      4  04d7		       e5 8f		      sbc	Evaluation
      5  04d9		       85 8f		      sta	Evaluation
      6  04db		       a9 00		      lda	#0
      7  04dd		       e5 90		      sbc	Evaluation+1
      8  04df		       85 90		      sta	Evaluation+1
    235  04e1				   .white2
    236  04e1
    237  04e1		       a6 b6		      ldx	__initListPtr
    238  04e3		       e8		      inx
    239  04e4		       e8		      inx
    240  04e5		       10 af		      bpl	.fillPieceLists
    241  04e7
    242  04e7				   .exit
    243  04e7		       60		      rts
    244  04e8
    245  04e8
    246  04e8				   InitPieceList
    247  04e8
    248  04e8
    249  04e8					      IF	!TEST_POSITION
    250  04e8
    251  04e8		       06 19		      .byte.b	WHITE|Q, 25
    252  04ea		       04 18		      .byte.b	WHITE|B, 24
    253  04ec		       04 1b		      .byte.b	WHITE|B, 27
    254  04ee		       05 16		      .byte.b	WHITE|R, 22
    255  04f0		       05 1d		      .byte.b	WHITE|R, 29
    256  04f2		       03 17		      .byte.b	WHITE|N, 23
    257  04f4		       03 1c		      .byte.b	WHITE|N, 28
    258  04f6
    259  04f6		       01 23		      .byte.b	WHITE|WP, 35
    260  04f8		       01 24		      .byte.b	WHITE|WP, 36
    261  04fa		       01 22		      .byte.b	WHITE|WP, 34
    262  04fc		       01 25		      .byte.b	WHITE|WP, 37
    263  04fe		       01 21		      .byte.b	WHITE|WP, 33
    264  0500		       01 26		      .byte.b	WHITE|WP, 38
    265  0502		       01 20		      .byte.b	WHITE|WP, 32
    266  0504		       01 27		      .byte.b	WHITE|WP, 39
    267  0506
    268  0506		       07 1a		      .byte.b	WHITE|K, 26
    269  0508
    270  0508		       86 5f		      .byte.b	BLACK|Q, 95
    271  050a		       84 5e		      .byte.b	BLACK|B, 94
    272  050c		       84 61		      .byte.b	BLACK|B, 97
    273  050e		       85 5c		      .byte.b	BLACK|R, 92
    274  0510		       85 63		      .byte.b	BLACK|R, 99
    275  0512		       83 5d		      .byte.b	BLACK|N, 93
    276  0514		       83 62		      .byte.b	BLACK|N, 98
    277  0516
    278  0516		       82 55		      .byte.b	BLACK|BP, 85
    279  0518		       82 56		      .byte.b	BLACK|BP, 86
    280  051a		       82 54		      .byte.b	BLACK|BP, 84
    281  051c		       82 57		      .byte.b	BLACK|BP, 87
    282  051e		       82 53		      .byte.b	BLACK|BP, 83
    283  0520		       82 58		      .byte.b	BLACK|BP, 88
    284  0522		       82 52		      .byte.b	BLACK|BP, 82
    285  0524		       82 59		      .byte.b	BLACK|BP, 89
    286  0526
    287  0526		       87 60		      .byte.b	BLACK|K, 96
    288  0528
    289  0528		       00		      .byte.b	0	;end
    290  0529
    291  0529				  -	      ELSE		; test position...
    292  0529				  -
    293  0529				  -	      IF	1
    294  0529				  -
    295  0529				  -	      .byte	WHITE|N, 28
    296  0529				  -	      .byte	WHITE|K, 26
    297  0529				  -
    298  0529				  -	      .byte	BLACK|Q, 29
    299  0529				  -
    300  0529				  -	      .byte	0	;end
    301  0529				  -
    302  0529				  -	      ENDIF
    303  0529				  -
    304  0529				  -	      IF	0
    305  0529				  -
    306  0529				  -	      .byte	WHITE|K, 28
    307  0529				  -	      .byte	WHITE|WP, 37
    308  0529				  -	      .byte	WHITE|WP, 38
    309  0529				  -	      .byte	WHITE|WP, 53
    310  0529				  -	      .byte	WHITE|WP, 49
    311  0529				  -	      .byte	WHITE|WP, 32
    312  0529				  -	      .byte	WHITE|R, 27
    313  0529				  -	      .byte	WHITE|B, 46
    314  0529				  -	      .byte	WHITE|R, 54
    315  0529				  -
    316  0529				  -	      .byte	BLACK|BP, 56
    317  0529				  -	      .byte	BLACK|BP, 87
    318  0529				  -	      .byte	BLACK|BP, 88
    319  0529				  -	      .byte	BLACK|BP, 89
    320  0529				  -	      .byte	BLACK|BP, 84
    321  0529				  -	      .byte	BLACK|B, 66
    322  0529				  -	      .byte	BLACK|R, 69
    323  0529				  -	      .byte	BLACK|K, 98
    324  0529				  -
    325  0529				  -	      .byte	BLACK|R, 92
    326  0529				  -
    327  0529				  -
    328  0529				  -
    329  0529				  -	      ENDIF
    330  0529				  -
    331  0529				  -
    332  0529				  -	      IF	0
    333  0529				  -			; En passant test
    334  0529				  -
    335  0529				  -	      .byte	BLACK|BP, 88
    336  0529				  -	      .byte	BLACK|BP, 86
    337  0529				  -
    338  0529				  -	      .byte	WHITE|WP, 67
    339  0529				  -	      .byte	WHITE|K, 52
    340  0529				  -
    341  0529				  -
    342  0529				  -	      ENDIF
    343  0529				  -
    344  0529				  -
    345  0529				  -
    346  0529				  -
    347  0529				  -	      IF	0
    348  0529				  -
    349  0529				  -
    350  0529				  -			;.byte BLACK|R, 97
    351  0529				  -	      .byte	BLACK|K, 98
    352  0529				  -	      .byte	BLACK|BP, 87
    353  0529				  -	      .byte	BLACK|BP, 88
    354  0529				  -	      .byte	BLACK|BP, 89
    355  0529				  -			;    .byte BLACK|B, 76
    356  0529				  -
    357  0529				  -
    358  0529				  -	      .byte	WHITE|R,28
    359  0529				  -	      .byte	WHITE|Q,58
    360  0529				  -			;   .byte WHITE|N,65
    361  0529				  -	      ENDIF
    362  0529				  -
    363  0529				  -	      IF	0
    364  0529				  -			;.byte WHITE|WP, 56
    365  0529				  -
    366  0529				  -
    367  0529				  -	      .byte	BLACK|K, 98
    368  0529				  -
    369  0529				  -
    370  0529				  -	      .byte	WHITE|R,29
    371  0529				  -	      .byte	WHITE|Q,49
    372  0529				  -	      .byte	WHITE|N,65
    373  0529				  -	      ENDIF
    374  0529				  -	      .byte	0	;end
    375  0529				  -
    376  0529					      ENDIF
    377  0529
    378  0529
    379  0529							;---------------------------------------------------------------------------------------------------
    380  0529
      0  0529					      DEF	EnPassantRemovePiece
      1  0529				   SLOT_EnPassantRemovePiece SET	_BANK_SLOT
      2  0529				   BANK_EnPassantRemovePiece SET	SLOT_EnPassantRemovePiece + _CURRENT_BANK
      3  0529				   EnPassantRemovePiece
      4  0529				   TEMPORARY_VAR SET	Overlay
      5  0529				   TEMPORARY_OFFSET SET	0
      6  0529				   VAR_BOUNDARY_EnPassantRemovePiece SET	TEMPORARY_OFFSET
      7  0529				   FUNCTION_NAME SET	EnPassantRemovePiece
    382  0529					      SUBROUTINE
    383  0529
      0  0529					      REFER	MakeMove
      1  0529					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  0529				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  0529					      ENDIF
    385  0529
    386  0529				  -	      IF	ENPASSANT_ENABLED
    387  0529				  -	      REFER	EnPassantCheck	;✅
    388  0529					      ENDIF
    389  0529
      0  0529					      VAR	__y, 1
      1  0529		       00 b4	   __y	      =	TEMPORARY_VAR
      2  0529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0529
      4  0529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0529					      ENDIF
      8  0529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0529				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  0529				  -	      ERR
     11  0529					      ENDIF
     12  0529					      LIST	ON
      0  0529					      VAR	__col, 1
      1  0529		       00 b5	   __col      =	TEMPORARY_VAR
      2  0529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0529
      4  0529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0529					      ENDIF
      8  0529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0529				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  0529				  -	      ERR
     11  0529					      ENDIF
     12  0529					      LIST	ON
    392  0529
      0  0529					      VEND	EnPassantRemovePiece
      1  0529				  -	      IFNCONST	EnPassantRemovePiece
      2  0529				  -	      ECHO	"Incorrect VEND label", EnPassantRemovePiece
      3  0529				  -	      ERR
      4  0529					      ENDIF
      5  0529		       00 b6	   VAREND_EnPassantRemovePiece =	TEMPORARY_VAR
    394  0529
    395  0529
    396  0529							; Based on piece square, adjust material and position value with piece deleted
    397  0529							; y = piece square
    398  0529
    399  0529		       84 b4		      sty	__y
    400  052b
    401  052b		       a9 d1		      lda	#RAMBANK_BOARD
    402  052d		       85 3e		      sta	SET_BANK_RAM	;@3
    403  052f		       b9 79 fc 	      lda	Board,y
    404  0532		       85 b5		      sta	__col
    405  0534		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    406  0536		       86 3f		      stx	SET_BANK	;@2
    407  0538		       20 11 f9 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
    408  053b
    409  053b		       a5 b5		      lda	__col
    410  053d		       a4 b4		      ldy	__y
    411  053f		       20 34 f9 	      jsr	AddPiecePositionValue	; (same bank) adding for opponent = taking
    412  0542
    413  0542		       60		      rts
    414  0543
    415  0543
    416  0543							;---------------------------------------------------------------------------------------------------
    417  0543
    418  0543				  -	      IF	0
    419  0543				  -	      DEF	SAFE_BackupBitmaps
    420  0543				  -	      SUBROUTINE
    421  0543				  -
    422  0543				  -	      REFER	aiInCheckBackup
    423  0543				  -	      VEND	SAFE_BackupBitmaps
    424  0543				  -
    425  0543				  -	      sty	SET_BANK_RAM
    426  0543				  -	      jsr	SaveBitmap
    427  0543				  -	      rts
    428  0543					      ENDIF
    429  0543
    430  0543
    431  0543							;---------------------------------------------------------------------------------------------------
    432  0543
      0  0543					      DEF	AddMoveSimple
      1  0543				   SLOT_AddMoveSimple SET	_BANK_SLOT
      2  0543				   BANK_AddMoveSimple SET	SLOT_AddMoveSimple + _CURRENT_BANK
      3  0543				   AddMoveSimple
      4  0543				   TEMPORARY_VAR SET	Overlay
      5  0543				   TEMPORARY_OFFSET SET	0
      6  0543				   VAR_BOUNDARY_AddMoveSimple SET	TEMPORARY_OFFSET
      7  0543				   FUNCTION_NAME SET	AddMoveSimple
    434  0543					      SUBROUTINE
    435  0543
      0  0543					      VEND	AddMoveSimple
      1  0543				  -	      IFNCONST	AddMoveSimple
      2  0543				  -	      ECHO	"Incorrect VEND label", AddMoveSimple
      3  0543				  -	      ERR
      4  0543					      ENDIF
      5  0543		       00 a6	   VAREND_AddMoveSimple =	TEMPORARY_VAR
    437  0543
    438  0543							; add square in y register to movelist as destination (X12 format)
    439  0543							; [y]		     to square (X12)
    440  0543							; currentSquare     from square (X12)
    441  0543							; currentPiece      piece.
    442  0543							;   ENPASSANT flag set if pawn double-moving off opening rank
    443  0543							; capture	     captured piece
    444  0543
    445  0543		       a5 9d		      lda	capture
    446  0545		       d0 04		      bne	.always
    447  0547		       a5 b1		      lda	__quiesceCapOnly
    448  0549		       d0 1a		      bne	.abort
    449  054b
    450  054b		       98	   .always    tya
    451  054c
      0  054c					      ldy@PLY	moveIndex
      1  054c		       ac cf f9 	      ldy	moveIndex
    453  054f		       c8		      iny
      0  0550					      sty@PLY	moveIndex
      1  0550		       8c cf fb 	      sty	[RAM]+moveIndex
    455  0553
      0  0553					      sta@PLY	MoveTo,y
      1  0553		       99 64 fa 	      sta	[RAM]+MoveTo,y
    457  0556		       a5 92		      lda	currentSquare
      0  0558					      sta@PLY	MoveFrom,y
      1  0558		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    459  055b		       a5 91		      lda	currentPiece
      0  055d					      sta@PLY	MovePiece,y
      1  055d		       99 00 fb 	      sta	[RAM]+MovePiece,y
    461  0560		       a5 9d		      lda	capture
      0  0562					      sta@PLY	MoveCapture,y
      1  0562		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    463  0565
    464  0565		       60	   .abort     rts
    465  0566
    466  0566
    467  0566							;---------------------------------------------------------------------------------------------------
    468  0566
      0  0566					      DEF	aiSpecialMoveFixup
      1  0566				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  0566				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  0566				   aiSpecialMoveFixup
      4  0566				   TEMPORARY_VAR SET	Overlay
      5  0566				   TEMPORARY_OFFSET SET	0
      6  0566				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  0566				   FUNCTION_NAME SET	aiSpecialMoveFixup
    470  0566					      SUBROUTINE
    471  0566
      0  0566					      COMMON_VARS
      1  0566
      0  0566					      VAR	__thinkbar, 1
      1  0566		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
      0  0566					      VAR	__toggle, 1
      1  0566		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
      4  0566
      0  0566					      VAR	__bestMove, 1
      1  0566		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
      0  0566					      VAR	__alpha, 2
      1  0566		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
      0  0566					      VAR	__beta, 2
      1  0566		       00 ab	   __beta     =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
      0  0566					      VAR	__negaMax, 2
      1  0566		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
      0  0566					      VAR	__value, 2
      1  0566		       00 af	   __value    =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
     10  0566
      0  0566					      VAR	__quiesceCapOnly, 1
      1  0566		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
     12  0566
      0  0566					      VAR	__originalPiece, 1
      1  0566		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
      0  0566					      VAR	__capturedPiece, 1
      1  0566		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  0566				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0566
      4  0566				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0566				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0566				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0566					      ENDIF
      8  0566				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0566				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0566				  -	      ERR
     11  0566					      ENDIF
     12  0566					      LIST	ON
     15  0566
      0  0566					      REFER	AiStateMachine	;✅
      1  0566				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0566				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0566					      ENDIF
      0  0566					      VEND	aiSpecialMoveFixup
      1  0566				  -	      IFNCONST	aiSpecialMoveFixup
      2  0566				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  0566				  -	      ERR
      4  0566					      ENDIF
      5  0566		       00 b4	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    475  0566
    476  0566		       ad 84 02 	      lda	INTIM
    477  0569		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    478  056b		       b0 01		      bcs	.cont
    479  056d		       60		      rts
    480  056e
    481  056e
    482  056e				   .cont
    483  056e
      0  056e					      PHASE	AI_DelayAfterPlaced
      1  056e		       a9 27		      lda	#AI_DelayAfterPlaced
      2  0570		       85 8b		      sta	aiState
    485  0572
    486  0572
    487  0572							; Special move fixup
    488  0572
    489  0572				  -	      IF	ENPASSANT_ENABLED
    490  0572				  -
    491  0572				  -			; Handle en-passant captures
    492  0572				  -			; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
    493  0572				  -			; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
    494  0572				  -			; need to do the appropriate things...
    495  0572				  -
    496  0572				  -	      jsr	EnPassantCheck
    497  0572				  -
    498  0572					      ENDIF
    499  0572
    500  0572
    501  0572		       a5 94		      lda	currentPly
    502  0574		       85 3e		      sta	SET_BANK_RAM
    503  0576
    504  0576		       20 7e f5 	      jsr	CastleFixupDraw
    505  0579
    506  0579		       a5 85		      lda	fromX12
    507  057b		       85 80		      sta	squareToDraw
    508  057d
    509  057d		       60		      rts
    510  057e
    511  057e
    512  057e							;---------------------------------------------------------------------------------------------------
    513  057e
      0  057e					      DEF	CastleFixupDraw
      1  057e				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  057e				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  057e				   CastleFixupDraw
      4  057e				   TEMPORARY_VAR SET	Overlay
      5  057e				   TEMPORARY_OFFSET SET	0
      6  057e				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  057e				   FUNCTION_NAME SET	CastleFixupDraw
    515  057e					      SUBROUTINE
    516  057e
      0  057e					      REFER	aiSpecialMoveFixup	;✅
      1  057e					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  057e				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  057e					      ENDIF
    518  057e
      0  057e					      VEND	CastleFixupDraw
      1  057e				  -	      IFNCONST	CastleFixupDraw
      2  057e				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  057e				  -	      ERR
      4  057e					      ENDIF
      5  057e		       00 b4	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    520  057e
    521  057e							; fixup any castling issues
    522  057e							; at this point the king has finished his two-square march
    523  057e							; based on the finish square, we determine which rook we're interacting with
    524  057e							; and generate a 'move' for the rook to position on the other side of the king
    525  057e
    526  057e
    527  057e					      IF	CASTLING_ENABLED
      0  057e					      CALL	GenCastleMoveForRook	;@3
      1  057e				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  057e				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  057e				  -	      ECHO	"Cannot switch bank in use for", GenCastleMoveForRook
      4  057e				  -	      ERR
      5  057e					      ENDIF
      6  057e		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      7  0580		       85 3f		      sta	SET_BANK
      8  0582		       20 21 fc 	      jsr	GenCastleMoveForRook
    529  0585		       b0 07		      bcs	.phase
    530  0587					      ENDIF
    531  0587
      0  0587					      SWAP
      1  0587		       a5 95		      lda	sideToMove
      2  0589		       49 80		      eor	#SWAP_SIDE
      3  058b		       85 95		      sta	sideToMove
      4  058d
      5  058d
    533  058d		       60		      rts
    534  058e
    535  058e				   .phase
    536  058e
    537  058e							; in this siutation (castle, rook moving) we do not change sides yet!
    538  058e
      0  058e					      PHASE	AI_MoveIsSelected
      1  058e		       a9 14		      lda	#AI_MoveIsSelected
      2  0590		       85 8b		      sta	aiState
    540  0592		       60		      rts
    541  0593
    542  0593
    543  0593
    544  0593		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    545  0597		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    546  059b		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    547  059f
    548  059f
    549  059f							;---------------------------------------------------------------------------------------------------
    550  059f
      0  059f					      DEF	aiDrawEntireBoard
      1  059f				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  059f				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  059f				   aiDrawEntireBoard
      4  059f				   TEMPORARY_VAR SET	Overlay
      5  059f				   TEMPORARY_OFFSET SET	0
      6  059f				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  059f				   FUNCTION_NAME SET	aiDrawEntireBoard
    552  059f					      SUBROUTINE
    553  059f
      0  059f					      REFER	AiStateMachine	;✅
      1  059f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  059f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  059f					      ENDIF
    555  059f
      0  059f					      VEND	aiDrawEntireBoard
      1  059f				  -	      IFNCONST	aiDrawEntireBoard
      2  059f				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  059f				  -	      ERR
      4  059f					      ENDIF
      5  059f		       00 a8	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    557  059f
    558  059f
    559  059f		       ad 84 02 	      lda	INTIM
    560  05a2		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    561  05a4		       90 2c		      bcc	.exit
    562  05a6
    563  05a6							; We use [SLOT3] for accessing board
    564  05a6
    565  05a6		       a9 d1		      lda	#RAMBANK_BOARD
    566  05a8		       85 3e		      sta	SET_BANK_RAM
    567  05aa		       a4 80		      ldy	squareToDraw
    568  05ac		       b9 15 fc 	      lda	ValidSquare,y
    569  05af		       30 1d		      bmi	.isablank2
    570  05b1
    571  05b1		       b9 79 fc 	      lda	Board,y
    572  05b4		       f0 13		      beq	.isablank
    573  05b6		       48		      pha
    574  05b7		       a9 00		      lda	#BLANK
      0  05b9					      sta@RAM	Board,y
      1  05b9		       99 79 fe 	      sta	[RAM]+Board,y
    576  05bc
    577  05bc		       20 be f0 	      jsr	CopySinglePiece	;@0
    578  05bf
    579  05bf		       a9 d1		      lda	#RAMBANK_BOARD
    580  05c1		       85 3e		      sta	SET_BANK_RAM
    581  05c3
    582  05c3		       a4 80		      ldy	squareToDraw
    583  05c5		       68		      pla
      0  05c6					      sta@RAM	Board,y
      1  05c6		       99 79 fe 	      sta	[RAM]+Board,y
    585  05c9
      0  05c9				   .isablank  PHASE	AI_DrawPart2
      1  05c9		       a9 10		      lda	#AI_DrawPart2
      2  05cb		       85 8b		      sta	aiState
    587  05cd		       60		      rts
    588  05ce
      0  05ce				   .isablank2 PHASE	AI_DrawPart3
      1  05ce		       a9 11		      lda	#AI_DrawPart3
      2  05d0		       85 8b		      sta	aiState
    590  05d2		       60	   .exit      rts
    591  05d3
    592  05d3
    593  05d3							;---------------------------------------------------------------------------------------------------
    594  05d3
    595  05d3				  -	      IF	ENPASSANT_ENABLED
    596  05d3				  -
    597  05d3				  -	      DEF	EnPassantCheck
    598  05d3				  -	      SUBROUTINE
    599  05d3				  -
    600  05d3				  -	      REFER	MakeMove	;✅
    601  05d3				  -	      REFER	aiSpecialMoveFixup	;✅
    602  05d3				  -	      VEND	EnPassantCheck
    603  05d3				  -
    604  05d3				  -			; {
    605  05d3				  -			; With en-passant flag, it is essentially dual-use.
    606  05d3				  -			; First, it marks if the move is *involved* somehow in an en-passant
    607  05d3				  -			; if the piece has MOVED already, then it's an en-passant capture
    608  05d3				  -			; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    609  05d3				  -
    610  05d3				  -	      ldy	enPassantPawn	; save from previous side move
    611  05d3				  -
    612  05d3				  -	      ldx	#0	; (probably) NO en-passant this time
    613  05d3				  -	      lda	fromPiece
    614  05d3				  -	      and	#FLAG_ENPASSANT|FLAG_MOVED
    615  05d3				  -	      cmp	#FLAG_ENPASSANT
    616  05d3				  -	      bne	.noep	; HAS moved, or not en-passant
    617  05d3				  -
    618  05d3				  -	      eor	fromPiece	; clear FLAG_ENPASSANT
    619  05d3				  -	      sta	fromPiece
    620  05d3				  -
    621  05d3				  -	      ldx	fromX12	; this IS an en-passantable opening, so record the square
    622  05d3				  -.noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
    623  05d3				  -
    624  05d3				  -			; }
    625  05d3				  -
    626  05d3				  -
    627  05d3				  -			; Check to see if we are doing an actual en-passant capture...
    628  05d3				  -
    629  05d3				  -			; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
    630  05d3				  -			;  as the en-passant will fail if the taking piece does not have this flag set correctly
    631  05d3				  -
    632  05d3				  -	      lda	fromPiece
    633  05d3				  -	      and	#FLAG_ENPASSANT
    634  05d3				  -	      beq	.notEnPassant	; not an en-passant, or it's enpassant by a MOVED piece
    635  05d3				  -
    636  05d3				  -
    637  05d3				  -			; {
    638  05d3				  -
    639  05d3				  -			; Here we are the aggressor and we need to take the pawn 'en passant' fashion
    640  05d3				  -			; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
    641  05d3				  -
    642  05d3				  -			; Remove the pawn from the board and piecelist, and undraw
    643  05d3				  -
    644  05d3				  -	      sty	squareToDraw
    645  05d3				  -	      jsr	CopySinglePiece	;@0	      ; undraw captured pawn
    646  05d3				  -
    647  05d3				  -	      lda	#EVAL
    648  05d3				  -	      sta	SET_BANK	;@3
    649  05d3				  -
    650  05d3				  -	      ldy	originX12	; taken pawn's square
    651  05d3				  -	      jsr	EnPassantRemovePiece
    652  05d3				  -
    653  05d3				  -.notEnPassant
    654  05d3				  -			; }
    655  05d3				  -
    656  05d3				  -	      rts
    657  05d3				  -
    658  05d3					      ENDIF
    659  05d3
    660  05d3
    661  05d3							;---------------------------------------------------------------------------------------------------
    662  05d3
      0  05d3					      DEF	aiDrawPart2
      1  05d3				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  05d3				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  05d3				   aiDrawPart2
      4  05d3				   TEMPORARY_VAR SET	Overlay
      5  05d3				   TEMPORARY_OFFSET SET	0
      6  05d3				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  05d3				   FUNCTION_NAME SET	aiDrawPart2
    664  05d3					      SUBROUTINE
    665  05d3
      0  05d3					      REFER	AiStateMachine
      1  05d3					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  05d3				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  05d3					      ENDIF
      0  05d3					      VEND	aiDrawPart2
      1  05d3				  -	      IFNCONST	aiDrawPart2
      2  05d3				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  05d3				  -	      ERR
      4  05d3					      ENDIF
      5  05d3		       00 a8	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
    668  05d3
    669  05d3		       20 be f0 	      jsr	CopySinglePiece	;@0
    670  05d6
      0  05d6					      DEF	aiDrawPart3
      1  05d6				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  05d6				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  05d6				   aiDrawPart3
      4  05d6				   TEMPORARY_VAR SET	Overlay
      5  05d6				   TEMPORARY_OFFSET SET	0
      6  05d6				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  05d6				   FUNCTION_NAME SET	aiDrawPart3
    672  05d6					      SUBROUTINE
    673  05d6
    674  05d6		       c6 80		      dec	squareToDraw
    675  05d8		       a5 80		      lda	squareToDraw
    676  05da		       c9 16		      cmp	#22
    677  05dc		       90 05		      bcc	.comp
    678  05de
      0  05de					      PHASE	AI_DrawEntireBoard
      1  05de		       a9 0f		      lda	#AI_DrawEntireBoard
      2  05e0		       85 8b		      sta	aiState
    680  05e2		       60		      rts
    681  05e3
    682  05e3				   .comp
    683  05e3
    684  05e3		       a9 ff		      lda	#-1
    685  05e5		       85 86		      sta	toX12	; becomes startup flash square
    686  05e7		       a9 24		      lda	#36	; becomes cursor position
    687  05e9		       85 87		      sta	originX12
    688  05eb
    689  05eb
      0  05eb					      PHASE	AI_GenerateMoves
      1  05eb		       a9 12		      lda	#AI_GenerateMoves
      2  05ed		       85 8b		      sta	aiState
    691  05ef		       60		      rts
    692  05f0
    693  05f0
    694  05f0							;---------------------------------------------------------------------------------------------------
    695  05f0
      0  05f0					      DEF	aiMarchB
      1  05f0				   SLOT_aiMarchB SET	_BANK_SLOT
      2  05f0				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  05f0				   aiMarchB
      4  05f0				   TEMPORARY_VAR SET	Overlay
      5  05f0				   TEMPORARY_OFFSET SET	0
      6  05f0				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  05f0				   FUNCTION_NAME SET	aiMarchB
    697  05f0					      SUBROUTINE
    698  05f0
      0  05f0					      REFER	AiStateMachine
      1  05f0					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  05f0				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  05f0					      ENDIF
      0  05f0					      VEND	aiMarchB
      1  05f0				  -	      IFNCONST	aiMarchB
      2  05f0				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  05f0				  -	      ERR
      4  05f0					      ENDIF
      5  05f0		       00 a8	   VAREND_aiMarchB =	TEMPORARY_VAR
    701  05f0
    702  05f0							; Draw the piece in the new square
    703  05f0
    704  05f0		       a5 85		      lda	fromX12
    705  05f2		       85 80		      sta	squareToDraw
    706  05f4
    707  05f4		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
    708  05f7
    709  05f7		       a9 02		      lda	#2	; snail trail delay
    710  05f9		       85 82		      sta	drawDelay
    711  05fb
      0  05fb					      PHASE	AI_MarchToTargetB
      1  05fb		       a9 19		      lda	#AI_MarchToTargetB
      2  05fd		       85 8b		      sta	aiState
    713  05ff		       60		      rts
    714  0600
    715  0600
    716  0600							;---------------------------------------------------------------------------------------------------
    717  0600
      0  0600					      DEF	aiDraw
      1  0600				   SLOT_aiDraw SET	_BANK_SLOT
      2  0600				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  0600				   aiDraw
      4  0600				   TEMPORARY_VAR SET	Overlay
      5  0600				   TEMPORARY_OFFSET SET	0
      6  0600				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  0600				   FUNCTION_NAME SET	aiDraw
    719  0600					      SUBROUTINE
    720  0600		       a9 c0		      lda	#$C0
    721  0602		       85 49		      sta	COLUBK
    722  0604		       60		      rts
    723  0605
    724  0605
    725  0605							;---------------------------------------------------------------------------------------------------
    726  0605
      0  0605					      DEF	aiCheckMate
      1  0605				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  0605				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  0605				   aiCheckMate
      4  0605				   TEMPORARY_VAR SET	Overlay
      5  0605				   TEMPORARY_OFFSET SET	0
      6  0605				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  0605				   FUNCTION_NAME SET	aiCheckMate
    728  0605					      SUBROUTINE
    729  0605		       a9 44		      lda	#$44
    730  0607		       85 49		      sta	COLUBK
    731  0609		       60		      rts
    732  060a
    733  060a							;---------------------------------------------------------------------------------------------------
    734  060a
      0  060a					      CHECK_BANK_SIZE	"BANK_GENERIC@1#1"
      1  060a		       02 0a	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@1#1 (1K) SIZE =  $20a , FREE= $1f6
      2  060a					      ECHO	"BANK_GENERIC@1#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  060a				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  060a				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@1#1", " size=", * - ORIGIN
      5  060a				  -	      ERR
      6  060a					      ENDIF
    736  060a
    737  060a							;---------------------------------------------------------------------------------------------------
    738  060a							; EOF
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 4
      0  060a					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  060a
      0  060a					      SLOT	2
      1  060a				  -	      IF	(2 < 0) || (2 > 3)
      2  060a				  -	      ECHO	"Illegal bank address/segment location", 2
      3  060a				  -	      ERR
      4  060a					      ENDIF
      5  060a				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  060a				   _BANK_SLOT SET	2 * 64
      0  060a					      NEWBANK	BITMAP
      1  09a6 ????				      SEG	BITMAP
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   BITMAP_START SET	*
      6  0800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0800				   BITMAP     SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + 1024
      4  0800
      5  0800							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
      6  0800
      7  0800		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
      8  0800
      9  0800		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     10  0800		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     11  0800		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     12  0800		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     13  0800		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     14  0800		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     15  0800
     16  0800							; Template bank for a SINGLE ROW of the chessboard display.
     17  0800							; There are 8x of these.
     18  0800							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     19  0800							; The bank is copied from ROM into RAM at startup.
     20  0800							; The draw switches between consecutive row banks, with the last returning
     21  0800							; we effectively have 1K
     22  0800							;---------------------------------------------------------------------------------------------------
     23  0800
     24  0800		       00 84	   COLOUR_LINE_1 =	$84
     25  0800		       00 36	   COLOUR_LINE_2 =	$36
     26  0800		       00 28	   COLOUR_LINE_3 =	$28
     27  0800		       00 00	   BACKGCOL   =	$00
     28  0800
     29  0800
     30  0800		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     31  0800
     32  0800
      0  0800					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      0  0800					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0800					      LIST	ON
      0  0800					      DEF	SHADOW_ChessBitmap
      1  0800				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  0800				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  0800				   SHADOW_ChessBitmap
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	SHADOW_ChessBitmap
     34  0800		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     35  0818		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     36  0830		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     37  0848		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     38  0860		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     39  0878		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     40  0890
      0  0890					      ALLOCATE	BlankSprite, 8
      0  0890					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0890					      LIST	ON
      0  0890					      DEF	BlankSprite
      1  0890				   SLOT_BlankSprite SET	_BANK_SLOT
      2  0890				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  0890				   BlankSprite
      4  0890				   TEMPORARY_VAR SET	Overlay
      5  0890				   TEMPORARY_OFFSET SET	0
      6  0890				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  0890				   FUNCTION_NAME SET	BlankSprite
     42  0890		       00 00 00 00*	      ds	8, 0
     43  0898
      0  0898					      ALLOCATE	SpriteBuffer, 8
      0  0898					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0898					      LIST	ON
      0  0898					      DEF	SpriteBuffer
      1  0898				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  0898				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  0898				   SpriteBuffer
      4  0898				   TEMPORARY_VAR SET	Overlay
      5  0898				   TEMPORARY_OFFSET SET	0
      6  0898				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  0898				   FUNCTION_NAME SET	SpriteBuffer
     45  0898				   SpriteBuffer2
     46  0898		       f8		      .byte.b	%11111000
     47  0899		       f8		      .byte.b	%11111000
     48  089a		       f8		      .byte.b	%11111000
     49  089b		       f8		      .byte.b	%11111000
     50  089c		       f8		      .byte.b	%11111000
     51  089d		       f8		      .byte.b	%11111000
     52  089e		       f8		      .byte.b	%11111000
     53  089f		       f8		      .byte.b	%11111000
     54  08a0
     55  08a0				  -	      IF	0
     56  08a0				  -	      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
     57  08a0				  -	      ds	ROW_BITMAP_SIZE, 0
     58  08a0					      ENDIF
     59  08a0
     60  08a0							;---------------------------------------------------------------------------------------------------
     61  08a0
     62  0900		       00 00 00 00*	      ALIGN	256
     63  0900					      SUBROUTINE
     64  0900
      0  0900					      REFER	StartupBankReset
      1  0900				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0900				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0900					      ENDIF
     66  0900				   __dummy
      0  0900					      VEND	__dummy
      1  0900				  -	      IFNCONST	__dummy
      2  0900				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0900				  -	      ERR
      4  0900					      ENDIF
      5  0900		       00 a6	   VAREND___dummy =	TEMPORARY_VAR
     68  0900
     69  0900							; x = row # (and bank#)
     70  0900
     71  0900				   .endline
     72  0900
     73  0900							;@59
     74  0900
     75  0900							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
     76  0900							; Note that the other 7 row banks are unmodified (keeping the 'inx')
     77  0900				   SELFMOD_RTS_ON_LAST_ROW
     78  0900
     79  0900		       e8		      inx		; 2
     80  0901		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
     81  0903
      0  0903					      DEF	DrawRow
      1  0903				   SLOT_DrawRow SET	_BANK_SLOT
      2  0903				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  0903				   DrawRow
      4  0903				   TEMPORARY_VAR SET	Overlay
      5  0903				   TEMPORARY_OFFSET SET	0
      6  0903				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  0903				   FUNCTION_NAME SET	DrawRow
     83  0903
     84  0903							;@64
     85  0903		       a0 07		      ldy	#7	; 2
     86  0905		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
     87  0907
     88  0907							;@58...
     89  0907
     90  0907				   .l3
     91  0907
     92  0907		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
     93  090a		       85 5b		      sta	GRP0	; 3
     94  090c		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
     95  090f		       85 5c		      sta	GRP1	; 3
     96  0911
     97  0911							;@-4
     98  0911
     99  0911		       a9 84		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    100  0913		       85 48		      sta	COLUPF	; 3 @1
    101  0915
    102  0915		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    103  0918		       85 4d		      sta	PF0	; 3
    104  091a		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    105  091d		       85 4e		      sta	PF1	; 3
    106  091f		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    107  0922		       85 4f		      sta	PF2	; 3 @22
    108  0924
      0  0924					      SLEEP	6	; 6 @28
      1  0924				   .CYCLES    SET	6
      2  0924
      3  0924				  -	      IF	.CYCLES < 2
      4  0924				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0924				  -	      ERR
      6  0924					      ENDIF
      7  0924
      8  0924				  -	      IF	.CYCLES & 1
      9  0924				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0924				  -	      nop	0
     11  0924				  -	      ELSE
     12  0924				  -	      bit	VSYNC
     13  0924				  -	      ENDIF
     14  0924				  -.CYCLES    SET	.CYCLES - 3
     15  0924					      ENDIF
     16  0924
     17  0924					      REPEAT	.CYCLES / 2
     18  0924		       ea		      nop
     17  0924					      REPEND
     18  0925		       ea		      nop
     17  0925					      REPEND
     18  0926		       ea		      nop
     19  0927					      REPEND
    110  0927
    111  0927		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    112  092a		       85 4d		      sta	PF0	; 3
    113  092c		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    114  092f		       85 4e		      sta	PF1	; 3
    115  0931		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    116  0934		       8d 4f 00 	      sta.w	PF2	; 4 @50
    117  0937
      0  0937					      SLEEP	4	; 4
      1  0937				   .CYCLES    SET	4
      2  0937
      3  0937				  -	      IF	.CYCLES < 2
      4  0937				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0937				  -	      ERR
      6  0937					      ENDIF
      7  0937
      8  0937				  -	      IF	.CYCLES & 1
      9  0937				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0937				  -	      nop	0
     11  0937				  -	      ELSE
     12  0937				  -	      bit	VSYNC
     13  0937				  -	      ENDIF
     14  0937				  -.CYCLES    SET	.CYCLES - 3
     15  0937					      ENDIF
     16  0937
     17  0937					      REPEAT	.CYCLES / 2
     18  0937		       ea		      nop
     17  0937					      REPEND
     18  0938		       ea		      nop
     19  0939					      REPEND
    119  0939
    120  0939		       88		      dey		; 2
    121  093a		       30 c4		      bmi	.endline	; 2 (3)
    122  093c
    123  093c							;@57
    124  093c				   .drawLine
    125  093c
      0  093c					      SLEEP	11
      1  093c				   .CYCLES    SET	11
      2  093c
      3  093c				  -	      IF	.CYCLES < 2
      4  093c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  093c				  -	      ERR
      6  093c					      ENDIF
      7  093c
      8  093c					      IF	.CYCLES & 1
      9  093c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  093c		       04 00		      nop	0
     11  093e				  -	      ELSE
     12  093e				  -	      bit	VSYNC
     13  093e					      ENDIF
     14  093e				   .CYCLES    SET	.CYCLES - 3
     15  093e					      ENDIF
     16  093e
     17  093e					      REPEAT	.CYCLES / 2
     18  093e		       ea		      nop
     17  093e					      REPEND
     18  093f		       ea		      nop
     17  093f					      REPEND
     18  0940		       ea		      nop
     17  0940					      REPEND
     18  0941		       ea		      nop
     19  0942					      REPEND
    127  0942
    128  0942				   .dl2
    129  0942		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    130  0945		       85 5b		      sta	GRP0	; 3
    131  0947		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    132  094a		       85 5c		      sta	GRP1	; 3
    133  094c
    134  094c							;@7
    135  094c
    136  094c		       a9 36		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    137  094e		       85 48		      sta	COLUPF	; 3 @12
    138  0950
    139  0950		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    140  0953		       85 4d		      sta	PF0	; 3
    141  0955		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    142  0958		       85 4e		      sta	PF1	; 3
    143  095a		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    144  095d		       85 4f		      sta	PF2	; 3 @33
    145  095f
      0  095f					      SLEEP	3	; 3 @36
      1  095f				   .CYCLES    SET	3
      2  095f
      3  095f				  -	      IF	.CYCLES < 2
      4  095f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  095f				  -	      ERR
      6  095f					      ENDIF
      7  095f
      8  095f					      IF	.CYCLES & 1
      9  095f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  095f		       04 00		      nop	0
     11  0961				  -	      ELSE
     12  0961				  -	      bit	VSYNC
     13  0961					      ENDIF
     14  0961				   .CYCLES    SET	.CYCLES - 3
     15  0961					      ENDIF
     16  0961
     17  0961				  -	      REPEAT	.CYCLES / 2
     18  0961				  -	      nop
     19  0961					      REPEND
    147  0961
    148  0961		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    149  0964		       85 4d		      sta	PF0	; 3
    150  0966		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    151  0969		       85 4e		      sta	PF1	; 3
    152  096b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    153  096e		       85 4f		      sta	PF2	; 3 @57
    154  0970
      0  0970					      SLEEP	5
      1  0970				   .CYCLES    SET	5
      2  0970
      3  0970				  -	      IF	.CYCLES < 2
      4  0970				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0970				  -	      ERR
      6  0970					      ENDIF
      7  0970
      8  0970					      IF	.CYCLES & 1
      9  0970					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0970		       04 00		      nop	0
     11  0972				  -	      ELSE
     12  0972				  -	      bit	VSYNC
     13  0972					      ENDIF
     14  0972				   .CYCLES    SET	.CYCLES - 3
     15  0972					      ENDIF
     16  0972
     17  0972					      REPEAT	.CYCLES / 2
     18  0972		       ea		      nop
     19  0973					      REPEND
    156  0973
    157  0973		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    158  0976		       85 5b		      sta	GRP0	; 3
    159  0978		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    160  097b		       85 5c		      sta	GRP1	; 3
    161  097d
    162  097d							;@0
    163  097d		       a9 28		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    164  097f		       85 48		      sta	COLUPF	; 3 @5
    165  0981
    166  0981		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    167  0984		       85 4d		      sta	PF0	; 3
    168  0986		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    169  0989		       85 4e		      sta	PF1	; 3
    170  098b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    171  098e		       85 4f		      sta	PF2	; 3 @26
    172  0990
      0  0990					      SLEEP	8	; 6 @34
      1  0990				   .CYCLES    SET	8
      2  0990
      3  0990				  -	      IF	.CYCLES < 2
      4  0990				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0990				  -	      ERR
      6  0990					      ENDIF
      7  0990
      8  0990				  -	      IF	.CYCLES & 1
      9  0990				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0990				  -	      nop	0
     11  0990				  -	      ELSE
     12  0990				  -	      bit	VSYNC
     13  0990				  -	      ENDIF
     14  0990				  -.CYCLES    SET	.CYCLES - 3
     15  0990					      ENDIF
     16  0990
     17  0990					      REPEAT	.CYCLES / 2
     18  0990		       ea		      nop
     17  0990					      REPEND
     18  0991		       ea		      nop
     17  0991					      REPEND
     18  0992		       ea		      nop
     17  0992					      REPEND
     18  0993		       ea		      nop
     19  0994					      REPEND
    174  0994
    175  0994		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    176  0997		       85 4d		      sta	PF0	; 3
    177  0999		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    178  099c		       85 4e		      sta	PF1	; 3
    179  099e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    180  09a1		       85 4f		      sta	PF2	; 3 @55
    181  09a3
    182  09a3		       4c 07 f9 	      jmp	.l3	; 3 @58
    183  09a6
    184  09a6
    185  09a6
    186  09a6							;---------------------------------------------------------------------------------------------------
    187  09a6
      0  09a6					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  09a6		       01 a6	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $1a6 , FREE= $5a
      2  09a6					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  09a6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  09a6				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  09a6				  -	      ERR
      6  09a6					      ENDIF
    189  09a6
    190  09a6							;---------------------------------------------------------------------------------------------------
    191  09a6							;EOF
------- FILE ./chess.asm
------- FILE ROM_SCREEN@3.asm LEVEL 2 PASS 4
      0  09a6					      include	"ROM_SCREEN@3.asm"
      1  09a6
      0  09a6					      SLOT	3
      1  09a6				  -	      IF	(3 < 0) || (3 > 3)
      2  09a6				  -	      ECHO	"Illegal bank address/segment location", 3
      3  09a6				  -	      ERR
      4  09a6					      ENDIF
      5  09a6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  09a6				   _BANK_SLOT SET	3 * 64
      0  09a6					      NEWBANK	ROM_SCREEN
      1  0c5c ????				      SEG	ROM_SCREEN
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   ROM_SCREEN_START SET	*
      6  0c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0c00				   ROM_SCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  0c00
      5  0c00							;---------------------------------------------------------------------------------------------------
      6  0c00
      0  0c00					      DEF	ClearRowBitmap
      1  0c00				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  0c00				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  0c00				   ClearRowBitmap
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	ClearRowBitmap
      8  0c00					      SUBROUTINE
      9  0c00
      0  0c00					      REFER	CallClear	;✅
      1  0c00				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  0c00				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  0c00					      ENDIF
      0  0c00					      VEND	ClearRowBitmap
      1  0c00				  -	      IFNCONST	ClearRowBitmap
      2  0c00				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  0c00				  -	      ERR
      4  0c00					      ENDIF
      5  0c00		       00 a6	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     12  0c00
     13  0c00							; No transient variable dependencies/calls
     14  0c00
     15  0c00		       a9 00		      lda	#0
     16  0c02		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  0c04				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  0c04		       99 ff f9 	      sta	[RAM]+ChessBitmap-1,y
     18  0c07		       88		      dey
     19  0c08		       d0 fa		      bne	.clearRow
     20  0c0a		       60		      rts
     21  0c0b
     22  0c0b
     23  0c0b							;---------------------------------------------------------------------------------------------------
     24  0c0b
     25  0c0b					      IF	1
      0  0c0b					      DEF	WriteBlank
      1  0c0b				   SLOT_WriteBlank SET	_BANK_SLOT
      2  0c0b				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  0c0b				   WriteBlank
      4  0c0b				   TEMPORARY_VAR SET	Overlay
      5  0c0b				   TEMPORARY_OFFSET SET	0
      6  0c0b				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  0c0b				   FUNCTION_NAME SET	WriteBlank
     27  0c0b					      SUBROUTINE
     28  0c0b
      0  0c0b					      REFER	StartupBankReset	;✅
      1  0c0b				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c0b				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c0b					      ENDIF
      0  0c0b					      VEND	WriteBlank
      1  0c0b				  -	      IFNCONST	WriteBlank
      2  0c0b				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  0c0b				  -	      ERR
      4  0c0b					      ENDIF
      5  0c0b		       00 a6	   VAREND_WriteBlank =	TEMPORARY_VAR
     31  0c0b
     32  0c0b		       a9 90		      lda	#<BlankSprite
      0  0c0d					      sta@RAM	SMSPRITE0_0+1
      1  0c0d		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c10					      sta@RAM	SMSPRITE8_0+1
      1  0c10		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c13					      sta@RAM	SMSPRITE16_0+1
      1  0c13		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
      0  0c16					      sta@RAM	SMSPRITE0_1+1
      1  0c16		       8d 48 fb 	      sta	[RAM]+SMSPRITE0_1+1
      0  0c19					      sta@RAM	SMSPRITE8_1+1
      1  0c19		       8d 79 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  0c1c					      sta@RAM	SMSPRITE16_1+1
      1  0c1c		       8d 0d fb 	      sta	[RAM]+SMSPRITE16_1+1
     39  0c1f
     40  0c1f		       a9 f8		      lda	#>BlankSprite
      0  0c21					      sta@RAM	SMSPRITE0_0+2
      1  0c21		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c24					      sta@RAM	SMSPRITE8_0+2
      1  0c24		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c27					      sta@RAM	SMSPRITE16_0+2
      1  0c27		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
      0  0c2a					      sta@RAM	SMSPRITE0_1+2
      1  0c2a		       8d 49 fb 	      sta	[RAM]+SMSPRITE0_1+2
      0  0c2d					      sta@RAM	SMSPRITE8_1+2
      1  0c2d		       8d 7a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  0c30					      sta@RAM	SMSPRITE16_1+2
      1  0c30		       8d 0e fb 	      sta	[RAM]+SMSPRITE16_1+2
     47  0c33
     48  0c33		       60		      rts
     49  0c34					      ENDIF
     50  0c34
     51  0c34							;---------------------------------------------------------------------------------------------------
     52  0c34
     53  0c34					      IF	1
      0  0c34					      DEF	WriteCursor
      1  0c34				   SLOT_WriteCursor SET	_BANK_SLOT
      2  0c34				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  0c34				   WriteCursor
      4  0c34				   TEMPORARY_VAR SET	Overlay
      5  0c34				   TEMPORARY_OFFSET SET	0
      6  0c34				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  0c34				   FUNCTION_NAME SET	WriteCursor
     55  0c34					      SUBROUTINE
     56  0c34
      0  0c34					      REFER	StartupBankReset	;✅
      1  0c34				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c34				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c34					      ENDIF
      0  0c34					      VEND	WriteCursor
      1  0c34				  -	      IFNCONST	WriteCursor
      2  0c34				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  0c34				  -	      ERR
      4  0c34					      ENDIF
      5  0c34		       00 a6	   VAREND_WriteCursor =	TEMPORARY_VAR
     59  0c34
     60  0c34		       38		      sec
     61  0c35		       a5 88		      lda	cursorX12
     62  0c37		       30 22		      bmi	.exit
     63  0c39		       a2 0a		      ldx	#10
     64  0c3b		       e9 0a	   .sub10     sbc	#10
     65  0c3d		       ca		      dex
     66  0c3e		       b0 fb		      bcs	.sub10
     67  0c40
     68  0c40		       8a		      txa
     69  0c41		       69 80		      adc	#SLOT_DrawRow	;cc implied
     70  0c43		       85 3e		      sta	SET_BANK_RAM
     71  0c45
     72  0c45		       a9 98		      lda	#<SpriteBuffer
      0  0c47					      sta@RAM	SMSPRITE0_0+1
      1  0c47		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c4a					      sta@RAM	SMSPRITE8_0+1
      1  0c4a		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c4d					      sta@RAM	SMSPRITE16_0+1
      1  0c4d		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
     76  0c50		       a9 f8		      lda	#>SpriteBuffer
      0  0c52					      sta@RAM	SMSPRITE0_0+2
      1  0c52		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c55					      sta@RAM	SMSPRITE8_0+2
      1  0c55		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c58					      sta@RAM	SMSPRITE16_0+2
      1  0c58		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
     80  0c5b
     81  0c5b		       60	   .exit      rts
     82  0c5c					      ENDIF
     83  0c5c
     84  0c5c
     85  0c5c							;---------------------------------------------------------------------------------------------------
     86  0c5c
     87  0c5c				  -	      IF	0
     88  0c5c				  -	      DEF	SaveBitmap
     89  0c5c				  -	      SUBROUTINE
     90  0c5c				  -
     91  0c5c				  -	      REFER	SAFE_BackupBitmaps	;✅
     92  0c5c				  -	      VEND	SaveBitmap
     93  0c5c				  -
     94  0c5c				  -	      ldy	#71
     95  0c5c				  -.fromTo    lda	ChessBitmap,y
     96  0c5c				  -	      sta@RAM	BackupBitmap,y
     97  0c5c				  -	      lda	ChessBitmap+72,y
     98  0c5c				  -	      sta@RAM	BackupBitmap+72,y
     99  0c5c				  -	      dey
    100  0c5c				  -	      bpl	.fromTo
    101  0c5c				  -	      rts
    102  0c5c					      ENDIF
    103  0c5c
    104  0c5c							;---------------------------------------------------------------------------------------------------
    105  0c5c
    106  0c5c				  -	      IF	0
    107  0c5c				  -
    108  0c5c				  -	      DEF	RestoreBitmap
    109  0c5c				  -	      SUBROUTINE
    110  0c5c				  -
    111  0c5c				  -	      VEND	RestoreBitmap
    112  0c5c				  -
    113  0c5c				  -	      ldy	#71
    114  0c5c				  -.fromTo    lda	BackupBitmap,y
    115  0c5c				  -	      sta@RAM	ChessBitmap,y
    116  0c5c				  -	      lda	BackupBitmap+72,y
    117  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    118  0c5c				  -	      dey
    119  0c5c				  -	      bpl	.fromTo
    120  0c5c				  -	      rts
    121  0c5c					      ENDIF
    122  0c5c
    123  0c5c							;---------------------------------------------------------------------------------------------------
    124  0c5c
    125  0c5c				  -	      IF	0
    126  0c5c				  -
    127  0c5c				  -	      DEF	CopyTextToRowBitmap
    128  0c5c				  -	      SUBROUTINE
    129  0c5c				  -
    130  0c5c				  -	      VEND	CopyTextToRowBitmap
    131  0c5c				  -
    132  0c5c				  -			; An OR-draw, used for placing matricies/text onscreen
    133  0c5c				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    134  0c5c				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    135  0c5c				  -			; in original state once text disappears
    136  0c5c				  -
    137  0c5c				  -	      ldy	#71
    138  0c5c				  -	      bcs	.rightSide
    139  0c5c				  -
    140  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    141  0c5c				  -	      ora	ChessBitmap,y
    142  0c5c				  -	      sta@RAM	ChessBitmap,y
    143  0c5c				  -	      dey
    144  0c5c				  -	      bpl	.copy
    145  0c5c				  -
    146  0c5c				  -	      rts
    147  0c5c				  -
    148  0c5c				  -.rightSide
    149  0c5c				  -
    150  0c5c				  -	      SUBROUTINE
    151  0c5c				  -
    152  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    153  0c5c				  -	      ora	ChessBitmap+72,y
    154  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    155  0c5c				  -	      dey
    156  0c5c				  -	      bpl	.copy
    157  0c5c				  -
    158  0c5c				  -	      rts
    159  0c5c				  -
    160  0c5c					      ENDIF
    161  0c5c
    162  0c5c							;---------------------------------------------------------------------------------------------------
    163  0c5c
      0  0c5c					      CHECK_RAM_BANK_SIZE	"ROM_SCREEN@3"
      1  0c5c		       00 5c	   .TEMP      =	* - _BANK_START
 ROM_SCREEN@3 (512 byte) SIZE =  $5c , FREE= $1a4
      2  0c5c					      ECHO	"ROM_SCREEN@3", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  0c5c				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  0c5c				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SCREEN@3", " size=", * - ORIGIN
      5  0c5c				  -	      ERR
      6  0c5c					      ENDIF
    165  0c5c
    166  0c5c							;---------------------------------------------------------------------------------------------------
    167  0c5c							;EOF
------- FILE ./chess.asm
------- FILE SHADOW_PLY.asm LEVEL 2 PASS 4
      0  0c5c					      include	"SHADOW_PLY.asm"
      1  0c5c							; Chess
      2  0c5c							; Copyright (c) 2019-2020 Andrew Davie
      3  0c5c							; andrew@taswegian.com
      4  0c5c
      5  0c5c
      6  0c5c							;---------------------------------------------------------------------------------------------------
      7  0c5c							; Define the RAM banks
      8  0c5c							; A "PLY" bank represents all the data required on any single ply of the search tree.
      9  0c5c							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     10  0c5c							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     11  0c5c							; they act as independant switchable banks usable for data on each ply during the search.
     12  0c5c							; A ply will hold the move list for that position
     13  0c5c
     14  0c5c
      0  0c5c					      SLOT	2
      1  0c5c				  -	      IF	(2 < 0) || (2 > 3)
      2  0c5c				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0c5c				  -	      ERR
      4  0c5c					      ENDIF
      5  0c5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0c5c				   _BANK_SLOT SET	2 * 64
      0  0c5c					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  0c5c
      2  0c5c
      3  0c5c
      4 U21dd ????				      SEG.U	PLY
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2000				   _BANK_START SET	*
      8 U2000				   RAMBANK_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U2000
     18 U2000							;---------------------------------------------------------------------------------------------------
     19 U2000
     20 U2000		       00 64	   MAX_MOVES  =	100	; big is good
     21 U2000
      0 U2000					      VARIABLE	MoveFrom, MAX_MOVES
      0 U2000					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2000					      LIST	ON
      2 U2000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0 U2064					      VARIABLE	MoveTo, MAX_MOVES
      0 U2064					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2064					      LIST	ON
      2 U2064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0 U20c8					      VARIABLE	MovePiece, MAX_MOVES
      0 U20c8					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2100					      LIST	ON
      2 U2100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0 U2164					      VARIABLE	MoveCapture, MAX_MOVES
      0 U2164					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2164					      LIST	ON
      2 U2164		       00 00 00 00*MoveCapture ds	MAX_MOVES
     26 U21c8
     27 U21c8
     28 U21c8							;---------------------------------------------------------------------------------------------------
     29 U21c8
     30 U21c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     31 U21c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     32 U21c8
      0 U21c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0 U21c8					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21c8					      LIST	ON
      2 U21c8		       00 00	   savedEvaluation ds	2
      0 U21ca					      VARIABLE	enPassantSquare, 1
      0 U21ca					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ca					      LIST	ON
      2 U21ca		       00	   enPassantSquare ds	1
      0 U21cb					      VARIABLE	capturedPiece, 1
      0 U21cb					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cb					      LIST	ON
      2 U21cb		       00	   capturedPiece ds	1
     36 U21cc							;VARIABLE originalPiece, 1
      0 U21cc					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0 U21cc					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cc					      LIST	ON
      2 U21cc		       00	   secondaryPiece ds	1
      0 U21cd					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0 U21cd					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cd					      LIST	ON
      2 U21cd		       00	   secondarySquare ds	1
      0 U21ce					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0 U21ce					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ce					      LIST	ON
      2 U21ce		       00	   secondaryBlank ds	1
      0 U21cf					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0 U21cf					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cf					      LIST	ON
      2 U21cf		       00	   moveIndex  ds	1
      0 U21d0					      VARIABLE	movePtr, 1
      0 U21d0					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d0					      LIST	ON
      2 U21d0		       00	   movePtr    ds	1
      0 U21d1					      VARIABLE	bestMove, 1
      0 U21d1					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d1					      LIST	ON
      2 U21d1		       00	   bestMove   ds	1
      0 U21d2					      VARIABLE	alpha, 2
      0 U21d2					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d2					      LIST	ON
      2 U21d2		       00 00	   alpha      ds	2
      0 U21d4					      VARIABLE	beta, 2
      0 U21d4					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d4					      LIST	ON
      2 U21d4		       00 00	   beta       ds	2
      0 U21d6					      VARIABLE	value, 2
      0 U21d6					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d6					      LIST	ON
      2 U21d6		       00 00	   value      ds	2
      0 U21d8					      VARIABLE	depthLeft, 1
      0 U21d8					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d8					      LIST	ON
      2 U21d8		       00	   depthLeft  ds	1
      0 U21d9					      VARIABLE	restorePiece, 1
      0 U21d9					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d9					      LIST	ON
      2 U21d9		       00	   restorePiece ds	1
      0 U21da					      VARIABLE	kingSquare, 3	; traversing squares for castle/check
      0 U21da					      OPTIONAL_PAGEBREAK	"Variable", 3
     12 U21da					      LIST	ON
      2 U21da		       00 00 00    kingSquare ds	3
     49 U21dd
     50 U21dd
      0 U21dd					      CHECK_RAM_BANK_SIZE	"SHADOW_PLY"
      1 U21dd		       01 dd	   .TEMP      =	* - _BANK_START
 SHADOW_PLY (512 byte) SIZE =  $1dd , FREE= $23
      2 U21dd					      ECHO	"SHADOW_PLY", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3 U21dd				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U21dd				  -	      ECHO	"BANK OVERFLOW @ ", "SHADOW_PLY", " size=", * - ORIGIN
      5 U21dd				  -	      ERR
      6 U21dd					      ENDIF
     52 U21dd
     53 U21dd					      REPEAT	PLY_BANKS-1
      0 U21dd					      NEWRAMBANK	.DUMMY_PLY
      1 U21dd
      2 U21dd
      3 U21dd
      4 U4000 ????				      SEG.U	.DUMMY_PLY
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2400				   _BANK_START SET	*
      8 U2400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2400					      REPEND
      0 U2400					      NEWRAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400
      3 U2400
      4 U2400					      SEG.U	.DUMMY_PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2800				   _BANK_START SET	*
      8 U2800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2800					      REPEND
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U2800					      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2c00				   _BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2c00					      REPEND
      0 U2c00					      NEWRAMBANK	.DUMMY_PLY
      1 U2c00
      2 U2c00
      3 U2c00
      4 U2c00					      SEG.U	.DUMMY_PLY
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3000				   _BANK_START SET	*
      8 U3000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3000					      REPEND
      0 U3000					      NEWRAMBANK	.DUMMY_PLY
      1 U3000
      2 U3000
      3 U3000
      4 U3000					      SEG.U	.DUMMY_PLY
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3400				   _BANK_START SET	*
      8 U3400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3400					      REPEND
      0 U3400					      NEWRAMBANK	.DUMMY_PLY
      1 U3400
      2 U3400
      3 U3400
      4 U3400					      SEG.U	.DUMMY_PLY
      5 U3800					      ORG	ORIGIN_RAM
      6 U3800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3800				   _BANK_START SET	*
      8 U3800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3800					      REPEND
      0 U3800					      NEWRAMBANK	.DUMMY_PLY
      1 U3800
      2 U3800
      3 U3800
      4 U3800					      SEG.U	.DUMMY_PLY
      5 U3c00					      ORG	ORIGIN_RAM
      6 U3c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3c00				   _BANK_START SET	*
      8 U3c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U3c00					      REPEND
      0 U3c00					      NEWRAMBANK	.DUMMY_PLY
      1 U3c00
      2 U3c00
      3 U3c00
      4 U3c00					      SEG.U	.DUMMY_PLY
      5 U4000					      ORG	ORIGIN_RAM
      6 U4000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4000				   _BANK_START SET	*
      8 U4000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     55 U4000					      REPEND
     56 U4000
     57 U4000
     58 U4000							;---------------------------------------------------------------------------------------------------
     59 U4000							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0 U4000					      include	"SHADOW_BOARD.asm"
      1 U4000							; Copyright (C)2020 Andrew Davie
      2 U4000
      3 U4000
      4 U4000							;---------------------------------------------------------------------------------------------------
      0 U4000					      SLOT	3
      1 U4000				  -	      IF	(3 < 0) || (3 > 3)
      2 U4000				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U4000				  -	      ERR
      4 U4000					      ENDIF
      5 U4000				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U4000				   _BANK_SLOT SET	3 * 64
      0 U4000					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1 U4000
      2 U4000
      3 U4000
      4 U4400 ????				      SEG.U	BOARD
      5 U4400					      ORG	ORIGIN_RAM
      6 U4400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4400				   _BANK_START SET	*
      8 U4400				   RAMBANK_BOARD SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4400				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U4400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      7 U4400
      8 U4400		       fc 15	   ValidSquare =	ShadowValidSquare + $400
      9 U4400		       fc 79	   Board      =	ShadowBoard + $400
     10 U4400
      0 U4400					      SLOT	2
      1 U4400				  -	      IF	(2 < 0) || (2 > 3)
      2 U4400				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U4400				  -	      ERR
      4 U4400					      ENDIF
      5 U4400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U4400				   _BANK_SLOT SET	2 * 64
      0 U4400					      NEWBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  10dd ????				      SEG	SHADOW_BOARD
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   SHADOW_BOARD_START SET	*
      6  1000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1000				   SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + 1024
     13  1000
     14  1000							; Board is a 10 x 12 object which simplifies the generation of moves
     15  1000							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     16  1000							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     17  1000
     18  1000							;     X12 numbering
     19  1000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     20  1000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     21  1000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     22  1000							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     23  1000							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     24  1000							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     25  1000							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     26  1000							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     27  1000							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     28  1000							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     29  1000							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     30  1000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     31  1000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     32  1000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     33  1000							;	0   1	2   3	4   5	6   7	8   9
     34  1000							;		A   B	C   D	E   F	G   H
     35  1000
     36  1000							;     HEX X12
     37  1000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     38  1000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     39  1000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     40  1000							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     41  1000							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     42  1000							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     43  1000							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     44  1000							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     45  1000							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     46  1000							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     47  1000							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     48  1000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     49  1000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     50  1000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     51  1000							;	0   1	2   3	4   5	6   7	8   9
     52  1000							;		A   B	C   D	E   F	G   H
     53  1000
     54  1000
     55  1000							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     56  1000							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     57  1000							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     58  1000							; be re-used for something else - we just need to guarantee there are 21 of them there
     59  1000
      0  1000					      ALLOCATE	Valid, 120 + 80 + 21
      0  1000					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  1000					      LIST	ON
      0  1000					      DEF	Valid
      1  1000				   SLOT_Valid SET	_BANK_SLOT
      2  1000				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  1000				   Valid
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	Valid
     61  1000		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     62  1015							; Note, we will never index INTO the above bytes - x will always be >= 21
     63  1015							; We just need to make sure that the actual indexing will not have an address before
     64  1015							; the index of outside the page.
     65  1015
      0  1015					      DEF	ShadowValidSquare
      1  1015				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  1015				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  1015				   ShadowValidSquare
      4  1015				   TEMPORARY_VAR SET	Overlay
      5  1015				   TEMPORARY_OFFSET SET	0
      6  1015				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  1015				   FUNCTION_NAME SET	ShadowValidSquare
     67  1015
     68  1015
     69  1015							; Use this table to
     70  1015							;   a) Determine if a square is valid (-1 = NO)
     71  1015							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     72  1015							;	if a white pawn on square "x" can move "up" the board.
     73  1015
     74  1015		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     75  101f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     76  1029		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     77  1033		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     78  103d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     79  1047		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     80  1051		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     81  105b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     82  1065		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     83  106f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     84  1079
      0  1079					      DEF	ShadowBoard
      1  1079				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  1079				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  1079				   ShadowBoard
      4  1079				   TEMPORARY_VAR SET	Overlay
      5  1079				   TEMPORARY_OFFSET SET	0
      6  1079				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  1079				   FUNCTION_NAME SET	ShadowBoard
     86  1079
     87  1079							; A 10X10... we should never write using invalid square
     88  1079							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     89  1079							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     90  1079
     91  1079		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     92  1083		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     93  108d
     94  108d					      REPEAT	8
     95  108d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  108d					      REPEND
     95  1097		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  1097					      REPEND
     95  10a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10a1					      REPEND
     95  10ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10ab					      REPEND
     95  10b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10b5					      REPEND
     95  10bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10bf					      REPEND
     95  10c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10c9					      REPEND
     95  10d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     96  10dd					      REPEND
     97  10dd
     98  10dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     99  10dd
    100  10dd
    101  10dd							;---------------------------------------------------------------------------------------------------
    102  10dd							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 4
      0  10dd					      include	"BANK_EVAL.asm"
      1  10dd
      0  10dd					      SLOT	3
      1  10dd				  -	      IF	(3 < 0) || (3 > 3)
      2  10dd				  -	      ECHO	"Illegal bank address/segment location", 3
      3  10dd				  -	      ERR
      4  10dd					      ENDIF
      5  10dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  10dd				   _BANK_SLOT SET	3 * 64
      3  10dd
      4  10dd
      0  10dd					      NEWRAMBANK	BANK_EVAL
      1  10dd
      2  10dd
      3  10dd
      4 U4800 ????				      SEG.U	BANK_EVAL
      5 U4800					      ORG	ORIGIN_RAM
      6 U4800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U4800				   _BANK_START SET	*
      8 U4800				   RAMBANK_BANK_EVAL SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U4800				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U4800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U4800					      NEWBANK	EVAL
      1  1640 ????				      SEG	EVAL
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   EVAL_START SET	*
      6  1400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1400				   EVAL       SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + 1024
      7  1400
      8  1400
      9  1400							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     10  1400
     11  1400
     12  1400
     13  1400							;---------------------------------------------------------------------------------------------------
     14  1400							; Vectors to the position value tables for each piece
     15  1400
     16  1400							;---------------------------------------------------------------------------------------------------
     17  1400							; Vectors to the position value tables for each piece
     18  1400
     19  1400					      MAC	posval
     20  1400					      .byte	0
     21  1400					      .byte	{1}(PositionalValue_PAWN - 22)
     22  1400					      .byte	{1}(PositionalValue_PAWN - 22)
     23  1400					      .byte	{1}(PositionalValue_KNIGHT - 22)
     24  1400					      .byte	{1}(PositionalValue_BISHOP - 22)
     25  1400					      .byte	{1}(PositionalValue_ROOK - 22)
     26  1400					      .byte	{1}(PositionalValue_QUEEN - 22)
     27  1400					      .byte	{1}(PositionalValue_KING_ENDGAME - 22)
     28  1400					      ENDM
     29  1400
      0  1400					      ALLOCATE	PosValVecLO, 8
      0  1400					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1400					      LIST	ON
      0  1400					      DEF	PosValVecLO
      1  1400				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  1400				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  1400				   PosValVecLO
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	PosValVecLO
      0  1400					      POSVAL	<
      1  1400		       00		      .byte.b	0
      2  1401		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      3  1402		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      4  1403		       4a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  1404		       9a		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  1405		       ea		      .byte.b	<(PositionalValue_ROOK - 22)
      7  1406		       3a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  1407		       da		      .byte.b	<(PositionalValue_KING_ENDGAME - 22)
      0  1408					      ALLOCATE	PosValVecHI, 8
      0  1408					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1408					      LIST	ON
      0  1408					      DEF	PosValVecHI
      1  1408				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  1408				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  1408				   PosValVecHI
      4  1408				   TEMPORARY_VAR SET	Overlay
      5  1408				   TEMPORARY_OFFSET SET	0
      6  1408				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  1408				   FUNCTION_NAME SET	PosValVecHI
      0  1408					      POSVAL	>
      1  1408		       00		      .byte.b	0
      2  1409		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      3  140a		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      4  140b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  140c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  140d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  140e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  140f		       fd		      .byte.b	>(PositionalValue_KING_ENDGAME - 22)
     34  1410
     35  1410
     36  1410					      MAC	eval8
     37  1410					      IF	({1} > 127) || ({1} < -128)
     38  1410					      ECHO	"Erroneous position value", {1}
     39  1410					      ERR
     40  1410					      ENDIF
     41  1410					      .byte	{1}
     42  1410					      ENDM
     43  1410
     44  1410
     45  1410					      MAC	pval
     46  1410					      EVAL8	{1}
     47  1410					      EVAL8	{2}
     48  1410					      EVAL8	{3}
     49  1410					      EVAL8	{4}
     50  1410					      EVAL8	{5}
     51  1410					      EVAL8	{6}
     52  1410					      EVAL8	{7}
     53  1410					      EVAL8	{8}
     54  1410					      EVAL8	0
     55  1410					      EVAL8	0
     56  1410					      ENDM		;{ 10 entries }
     57  1410
     58  1410
     59  1410				  -	      IF	0
     69  1410				  -	      ENDM
     70  1410				  -
     71  1410				  -	      ALLOCATE	PosValVecLO, 8
     72  1410				  -	      POSVAL	<
     73  1410				  -	      ALLOCATE	PosValVecHI, 8
     74  1410				  -	      POSVAL	>
     75  1410				  -
     76  1410				  -BZ	      =	0
     77  1410				  -
     89  1410				  -	      ENDM		;{ 10 entries }
     90  1410					      ENDIF
     91  1410
     92  1410							;---------------------------------------------------------------------------------------------------
     93  1410
     94  1410				   PositionalValue_PAWN
     95  1410
      0  1410					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  1410					      EVAL8	0
      1  1410				  -	      IF	(0 > 127) || (0 < -128)
      2  1410				  -	      ECHO	"Erroneous position value", 0
      3  1410				  -	      ERR
      4  1410					      ENDIF
      5  1410		       00		      .byte.b	0
      0  1411					      EVAL8	0
      1  1411				  -	      IF	(0 > 127) || (0 < -128)
      2  1411				  -	      ECHO	"Erroneous position value", 0
      3  1411				  -	      ERR
      4  1411					      ENDIF
      5  1411		       00		      .byte.b	0
      0  1412					      EVAL8	0
      1  1412				  -	      IF	(0 > 127) || (0 < -128)
      2  1412				  -	      ECHO	"Erroneous position value", 0
      3  1412				  -	      ERR
      4  1412					      ENDIF
      5  1412		       00		      .byte.b	0
      0  1413					      EVAL8	0
      1  1413				  -	      IF	(0 > 127) || (0 < -128)
      2  1413				  -	      ECHO	"Erroneous position value", 0
      3  1413				  -	      ERR
      4  1413					      ENDIF
      5  1413		       00		      .byte.b	0
      0  1414					      EVAL8	0
      1  1414				  -	      IF	(0 > 127) || (0 < -128)
      2  1414				  -	      ECHO	"Erroneous position value", 0
      3  1414				  -	      ERR
      4  1414					      ENDIF
      5  1414		       00		      .byte.b	0
      0  1415					      EVAL8	0
      1  1415				  -	      IF	(0 > 127) || (0 < -128)
      2  1415				  -	      ECHO	"Erroneous position value", 0
      3  1415				  -	      ERR
      4  1415					      ENDIF
      5  1415		       00		      .byte.b	0
      0  1416					      EVAL8	0
      1  1416				  -	      IF	(0 > 127) || (0 < -128)
      2  1416				  -	      ECHO	"Erroneous position value", 0
      3  1416				  -	      ERR
      4  1416					      ENDIF
      5  1416		       00		      .byte.b	0
      0  1417					      EVAL8	0
      1  1417				  -	      IF	(0 > 127) || (0 < -128)
      2  1417				  -	      ECHO	"Erroneous position value", 0
      3  1417				  -	      ERR
      4  1417					      ENDIF
      5  1417		       00		      .byte.b	0
      0  1418					      EVAL8	0
      1  1418				  -	      IF	(0 > 127) || (0 < -128)
      2  1418				  -	      ECHO	"Erroneous position value", 0
      3  1418				  -	      ERR
      4  1418					      ENDIF
      5  1418		       00		      .byte.b	0
      0  1419					      EVAL8	0
      1  1419				  -	      IF	(0 > 127) || (0 < -128)
      2  1419				  -	      ECHO	"Erroneous position value", 0
      3  1419				  -	      ERR
      4  1419					      ENDIF
      5  1419		       00		      .byte.b	0
      0  141a					      PVAL	15, 20, 0, -10, -10, 0, 20, 15
      0  141a					      EVAL8	15
      1  141a				  -	      IF	(15 > 127) || (15 < -128)
      2  141a				  -	      ECHO	"Erroneous position value", 15
      3  141a				  -	      ERR
      4  141a					      ENDIF
      5  141a		       0f		      .byte.b	15
      0  141b					      EVAL8	20
      1  141b				  -	      IF	(20 > 127) || (20 < -128)
      2  141b				  -	      ECHO	"Erroneous position value", 20
      3  141b				  -	      ERR
      4  141b					      ENDIF
      5  141b		       14		      .byte.b	20
      0  141c					      EVAL8	0
      1  141c				  -	      IF	(0 > 127) || (0 < -128)
      2  141c				  -	      ECHO	"Erroneous position value", 0
      3  141c				  -	      ERR
      4  141c					      ENDIF
      5  141c		       00		      .byte.b	0
      0  141d					      EVAL8	-10
      1  141d				  -	      IF	(-10 > 127) || (-10 < -128)
      2  141d				  -	      ECHO	"Erroneous position value", -10
      3  141d				  -	      ERR
      4  141d					      ENDIF
      5  141d		       f6		      .byte.b	-10
      0  141e					      EVAL8	-10
      1  141e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  141e				  -	      ECHO	"Erroneous position value", -10
      3  141e				  -	      ERR
      4  141e					      ENDIF
      5  141e		       f6		      .byte.b	-10
      0  141f					      EVAL8	0
      1  141f				  -	      IF	(0 > 127) || (0 < -128)
      2  141f				  -	      ECHO	"Erroneous position value", 0
      3  141f				  -	      ERR
      4  141f					      ENDIF
      5  141f		       00		      .byte.b	0
      0  1420					      EVAL8	20
      1  1420				  -	      IF	(20 > 127) || (20 < -128)
      2  1420				  -	      ECHO	"Erroneous position value", 20
      3  1420				  -	      ERR
      4  1420					      ENDIF
      5  1420		       14		      .byte.b	20
      0  1421					      EVAL8	15
      1  1421				  -	      IF	(15 > 127) || (15 < -128)
      2  1421				  -	      ECHO	"Erroneous position value", 15
      3  1421				  -	      ERR
      4  1421					      ENDIF
      5  1421		       0f		      .byte.b	15
      0  1422					      EVAL8	0
      1  1422				  -	      IF	(0 > 127) || (0 < -128)
      2  1422				  -	      ECHO	"Erroneous position value", 0
      3  1422				  -	      ERR
      4  1422					      ENDIF
      5  1422		       00		      .byte.b	0
      0  1423					      EVAL8	0
      1  1423				  -	      IF	(0 > 127) || (0 < -128)
      2  1423				  -	      ECHO	"Erroneous position value", 0
      3  1423				  -	      ERR
      4  1423					      ENDIF
      5  1423		       00		      .byte.b	0
      0  1424					      PVAL	5, -5, 20, 0, 0, 20, -5, 5
      0  1424					      EVAL8	5
      1  1424				  -	      IF	(5 > 127) || (5 < -128)
      2  1424				  -	      ECHO	"Erroneous position value", 5
      3  1424				  -	      ERR
      4  1424					      ENDIF
      5  1424		       05		      .byte.b	5
      0  1425					      EVAL8	-5
      1  1425				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1425				  -	      ECHO	"Erroneous position value", -5
      3  1425				  -	      ERR
      4  1425					      ENDIF
      5  1425		       fb		      .byte.b	-5
      0  1426					      EVAL8	20
      1  1426				  -	      IF	(20 > 127) || (20 < -128)
      2  1426				  -	      ECHO	"Erroneous position value", 20
      3  1426				  -	      ERR
      4  1426					      ENDIF
      5  1426		       14		      .byte.b	20
      0  1427					      EVAL8	0
      1  1427				  -	      IF	(0 > 127) || (0 < -128)
      2  1427				  -	      ECHO	"Erroneous position value", 0
      3  1427				  -	      ERR
      4  1427					      ENDIF
      5  1427		       00		      .byte.b	0
      0  1428					      EVAL8	0
      1  1428				  -	      IF	(0 > 127) || (0 < -128)
      2  1428				  -	      ECHO	"Erroneous position value", 0
      3  1428				  -	      ERR
      4  1428					      ENDIF
      5  1428		       00		      .byte.b	0
      0  1429					      EVAL8	20
      1  1429				  -	      IF	(20 > 127) || (20 < -128)
      2  1429				  -	      ECHO	"Erroneous position value", 20
      3  1429				  -	      ERR
      4  1429					      ENDIF
      5  1429		       14		      .byte.b	20
      0  142a					      EVAL8	-5
      1  142a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  142a				  -	      ECHO	"Erroneous position value", -5
      3  142a				  -	      ERR
      4  142a					      ENDIF
      5  142a		       fb		      .byte.b	-5
      0  142b					      EVAL8	5
      1  142b				  -	      IF	(5 > 127) || (5 < -128)
      2  142b				  -	      ECHO	"Erroneous position value", 5
      3  142b				  -	      ERR
      4  142b					      ENDIF
      5  142b		       05		      .byte.b	5
      0  142c					      EVAL8	0
      1  142c				  -	      IF	(0 > 127) || (0 < -128)
      2  142c				  -	      ECHO	"Erroneous position value", 0
      3  142c				  -	      ERR
      4  142c					      ENDIF
      5  142c		       00		      .byte.b	0
      0  142d					      EVAL8	0
      1  142d				  -	      IF	(0 > 127) || (0 < -128)
      2  142d				  -	      ECHO	"Erroneous position value", 0
      3  142d				  -	      ERR
      4  142d					      ENDIF
      5  142d		       00		      .byte.b	0
      0  142e					      PVAL	5, 5, 10, 20, 40, 20, 5, 5
      0  142e					      EVAL8	5
      1  142e				  -	      IF	(5 > 127) || (5 < -128)
      2  142e				  -	      ECHO	"Erroneous position value", 5
      3  142e				  -	      ERR
      4  142e					      ENDIF
      5  142e		       05		      .byte.b	5
      0  142f					      EVAL8	5
      1  142f				  -	      IF	(5 > 127) || (5 < -128)
      2  142f				  -	      ECHO	"Erroneous position value", 5
      3  142f				  -	      ERR
      4  142f					      ENDIF
      5  142f		       05		      .byte.b	5
      0  1430					      EVAL8	10
      1  1430				  -	      IF	(10 > 127) || (10 < -128)
      2  1430				  -	      ECHO	"Erroneous position value", 10
      3  1430				  -	      ERR
      4  1430					      ENDIF
      5  1430		       0a		      .byte.b	10
      0  1431					      EVAL8	20
      1  1431				  -	      IF	(20 > 127) || (20 < -128)
      2  1431				  -	      ECHO	"Erroneous position value", 20
      3  1431				  -	      ERR
      4  1431					      ENDIF
      5  1431		       14		      .byte.b	20
      0  1432					      EVAL8	40
      1  1432				  -	      IF	(40 > 127) || (40 < -128)
      2  1432				  -	      ECHO	"Erroneous position value", 40
      3  1432				  -	      ERR
      4  1432					      ENDIF
      5  1432		       28		      .byte.b	40
      0  1433					      EVAL8	20
      1  1433				  -	      IF	(20 > 127) || (20 < -128)
      2  1433				  -	      ECHO	"Erroneous position value", 20
      3  1433				  -	      ERR
      4  1433					      ENDIF
      5  1433		       14		      .byte.b	20
      0  1434					      EVAL8	5
      1  1434				  -	      IF	(5 > 127) || (5 < -128)
      2  1434				  -	      ECHO	"Erroneous position value", 5
      3  1434				  -	      ERR
      4  1434					      ENDIF
      5  1434		       05		      .byte.b	5
      0  1435					      EVAL8	5
      1  1435				  -	      IF	(5 > 127) || (5 < -128)
      2  1435				  -	      ECHO	"Erroneous position value", 5
      3  1435				  -	      ERR
      4  1435					      ENDIF
      5  1435		       05		      .byte.b	5
      0  1436					      EVAL8	0
      1  1436				  -	      IF	(0 > 127) || (0 < -128)
      2  1436				  -	      ECHO	"Erroneous position value", 0
      3  1436				  -	      ERR
      4  1436					      ENDIF
      5  1436		       00		      .byte.b	0
      0  1437					      EVAL8	0
      1  1437				  -	      IF	(0 > 127) || (0 < -128)
      2  1437				  -	      ECHO	"Erroneous position value", 0
      3  1437				  -	      ERR
      4  1437					      ENDIF
      5  1437		       00		      .byte.b	0
      0  1438					      PVAL	15, 15, 20, 40, 50, 20, 15, 15
      0  1438					      EVAL8	15
      1  1438				  -	      IF	(15 > 127) || (15 < -128)
      2  1438				  -	      ECHO	"Erroneous position value", 15
      3  1438				  -	      ERR
      4  1438					      ENDIF
      5  1438		       0f		      .byte.b	15
      0  1439					      EVAL8	15
      1  1439				  -	      IF	(15 > 127) || (15 < -128)
      2  1439				  -	      ECHO	"Erroneous position value", 15
      3  1439				  -	      ERR
      4  1439					      ENDIF
      5  1439		       0f		      .byte.b	15
      0  143a					      EVAL8	20
      1  143a				  -	      IF	(20 > 127) || (20 < -128)
      2  143a				  -	      ECHO	"Erroneous position value", 20
      3  143a				  -	      ERR
      4  143a					      ENDIF
      5  143a		       14		      .byte.b	20
      0  143b					      EVAL8	40
      1  143b				  -	      IF	(40 > 127) || (40 < -128)
      2  143b				  -	      ECHO	"Erroneous position value", 40
      3  143b				  -	      ERR
      4  143b					      ENDIF
      5  143b		       28		      .byte.b	40
      0  143c					      EVAL8	50
      1  143c				  -	      IF	(50 > 127) || (50 < -128)
      2  143c				  -	      ECHO	"Erroneous position value", 50
      3  143c				  -	      ERR
      4  143c					      ENDIF
      5  143c		       32		      .byte.b	50
      0  143d					      EVAL8	20
      1  143d				  -	      IF	(20 > 127) || (20 < -128)
      2  143d				  -	      ECHO	"Erroneous position value", 20
      3  143d				  -	      ERR
      4  143d					      ENDIF
      5  143d		       14		      .byte.b	20
      0  143e					      EVAL8	15
      1  143e				  -	      IF	(15 > 127) || (15 < -128)
      2  143e				  -	      ECHO	"Erroneous position value", 15
      3  143e				  -	      ERR
      4  143e					      ENDIF
      5  143e		       0f		      .byte.b	15
      0  143f					      EVAL8	15
      1  143f				  -	      IF	(15 > 127) || (15 < -128)
      2  143f				  -	      ECHO	"Erroneous position value", 15
      3  143f				  -	      ERR
      4  143f					      ENDIF
      5  143f		       0f		      .byte.b	15
      0  1440					      EVAL8	0
      1  1440				  -	      IF	(0 > 127) || (0 < -128)
      2  1440				  -	      ECHO	"Erroneous position value", 0
      3  1440				  -	      ERR
      4  1440					      ENDIF
      5  1440		       00		      .byte.b	0
      0  1441					      EVAL8	0
      1  1441				  -	      IF	(0 > 127) || (0 < -128)
      2  1441				  -	      ECHO	"Erroneous position value", 0
      3  1441				  -	      ERR
      4  1441					      ENDIF
      5  1441		       00		      .byte.b	0
      0  1442					      PVAL	60, 60, 80, 80, 80, 80, 60, 60
      0  1442					      EVAL8	60
      1  1442				  -	      IF	(60 > 127) || (60 < -128)
      2  1442				  -	      ECHO	"Erroneous position value", 60
      3  1442				  -	      ERR
      4  1442					      ENDIF
      5  1442		       3c		      .byte.b	60
      0  1443					      EVAL8	60
      1  1443				  -	      IF	(60 > 127) || (60 < -128)
      2  1443				  -	      ECHO	"Erroneous position value", 60
      3  1443				  -	      ERR
      4  1443					      ENDIF
      5  1443		       3c		      .byte.b	60
      0  1444					      EVAL8	80
      1  1444				  -	      IF	(80 > 127) || (80 < -128)
      2  1444				  -	      ECHO	"Erroneous position value", 80
      3  1444				  -	      ERR
      4  1444					      ENDIF
      5  1444		       50		      .byte.b	80
      0  1445					      EVAL8	80
      1  1445				  -	      IF	(80 > 127) || (80 < -128)
      2  1445				  -	      ECHO	"Erroneous position value", 80
      3  1445				  -	      ERR
      4  1445					      ENDIF
      5  1445		       50		      .byte.b	80
      0  1446					      EVAL8	80
      1  1446				  -	      IF	(80 > 127) || (80 < -128)
      2  1446				  -	      ECHO	"Erroneous position value", 80
      3  1446				  -	      ERR
      4  1446					      ENDIF
      5  1446		       50		      .byte.b	80
      0  1447					      EVAL8	80
      1  1447				  -	      IF	(80 > 127) || (80 < -128)
      2  1447				  -	      ECHO	"Erroneous position value", 80
      3  1447				  -	      ERR
      4  1447					      ENDIF
      5  1447		       50		      .byte.b	80
      0  1448					      EVAL8	60
      1  1448				  -	      IF	(60 > 127) || (60 < -128)
      2  1448				  -	      ECHO	"Erroneous position value", 60
      3  1448				  -	      ERR
      4  1448					      ENDIF
      5  1448		       3c		      .byte.b	60
      0  1449					      EVAL8	60
      1  1449				  -	      IF	(60 > 127) || (60 < -128)
      2  1449				  -	      ECHO	"Erroneous position value", 60
      3  1449				  -	      ERR
      4  1449					      ENDIF
      5  1449		       3c		      .byte.b	60
      0  144a					      EVAL8	0
      1  144a				  -	      IF	(0 > 127) || (0 < -128)
      2  144a				  -	      ECHO	"Erroneous position value", 0
      3  144a				  -	      ERR
      4  144a					      ENDIF
      5  144a		       00		      .byte.b	0
      0  144b					      EVAL8	0
      1  144b				  -	      IF	(0 > 127) || (0 < -128)
      2  144b				  -	      ECHO	"Erroneous position value", 0
      3  144b				  -	      ERR
      4  144b					      ENDIF
      5  144b		       00		      .byte.b	0
      0  144c					      PVAL	100, 100, 120, 120, 120, 120, 100, 100
      0  144c					      EVAL8	100
      1  144c				  -	      IF	(100 > 127) || (100 < -128)
      2  144c				  -	      ECHO	"Erroneous position value", 100
      3  144c				  -	      ERR
      4  144c					      ENDIF
      5  144c		       64		      .byte.b	100
      0  144d					      EVAL8	100
      1  144d				  -	      IF	(100 > 127) || (100 < -128)
      2  144d				  -	      ECHO	"Erroneous position value", 100
      3  144d				  -	      ERR
      4  144d					      ENDIF
      5  144d		       64		      .byte.b	100
      0  144e					      EVAL8	120
      1  144e				  -	      IF	(120 > 127) || (120 < -128)
      2  144e				  -	      ECHO	"Erroneous position value", 120
      3  144e				  -	      ERR
      4  144e					      ENDIF
      5  144e		       78		      .byte.b	120
      0  144f					      EVAL8	120
      1  144f				  -	      IF	(120 > 127) || (120 < -128)
      2  144f				  -	      ECHO	"Erroneous position value", 120
      3  144f				  -	      ERR
      4  144f					      ENDIF
      5  144f		       78		      .byte.b	120
      0  1450					      EVAL8	120
      1  1450				  -	      IF	(120 > 127) || (120 < -128)
      2  1450				  -	      ECHO	"Erroneous position value", 120
      3  1450				  -	      ERR
      4  1450					      ENDIF
      5  1450		       78		      .byte.b	120
      0  1451					      EVAL8	120
      1  1451				  -	      IF	(120 > 127) || (120 < -128)
      2  1451				  -	      ECHO	"Erroneous position value", 120
      3  1451				  -	      ERR
      4  1451					      ENDIF
      5  1451		       78		      .byte.b	120
      0  1452					      EVAL8	100
      1  1452				  -	      IF	(100 > 127) || (100 < -128)
      2  1452				  -	      ECHO	"Erroneous position value", 100
      3  1452				  -	      ERR
      4  1452					      ENDIF
      5  1452		       64		      .byte.b	100
      0  1453					      EVAL8	100
      1  1453				  -	      IF	(100 > 127) || (100 < -128)
      2  1453				  -	      ECHO	"Erroneous position value", 100
      3  1453				  -	      ERR
      4  1453					      ENDIF
      5  1453		       64		      .byte.b	100
      0  1454					      EVAL8	0
      1  1454				  -	      IF	(0 > 127) || (0 < -128)
      2  1454				  -	      ECHO	"Erroneous position value", 0
      3  1454				  -	      ERR
      4  1454					      ENDIF
      5  1454		       00		      .byte.b	0
      0  1455					      EVAL8	0
      1  1455				  -	      IF	(0 > 127) || (0 < -128)
      2  1455				  -	      ECHO	"Erroneous position value", 0
      3  1455				  -	      ERR
      4  1455					      ENDIF
      5  1455		       00		      .byte.b	0
      0  1456					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  1456					      EVAL8	0
      1  1456				  -	      IF	(0 > 127) || (0 < -128)
      2  1456				  -	      ECHO	"Erroneous position value", 0
      3  1456				  -	      ERR
      4  1456					      ENDIF
      5  1456		       00		      .byte.b	0
      0  1457					      EVAL8	0
      1  1457				  -	      IF	(0 > 127) || (0 < -128)
      2  1457				  -	      ECHO	"Erroneous position value", 0
      3  1457				  -	      ERR
      4  1457					      ENDIF
      5  1457		       00		      .byte.b	0
      0  1458					      EVAL8	0
      1  1458				  -	      IF	(0 > 127) || (0 < -128)
      2  1458				  -	      ECHO	"Erroneous position value", 0
      3  1458				  -	      ERR
      4  1458					      ENDIF
      5  1458		       00		      .byte.b	0
      0  1459					      EVAL8	0
      1  1459				  -	      IF	(0 > 127) || (0 < -128)
      2  1459				  -	      ECHO	"Erroneous position value", 0
      3  1459				  -	      ERR
      4  1459					      ENDIF
      5  1459		       00		      .byte.b	0
      0  145a					      EVAL8	0
      1  145a				  -	      IF	(0 > 127) || (0 < -128)
      2  145a				  -	      ECHO	"Erroneous position value", 0
      3  145a				  -	      ERR
      4  145a					      ENDIF
      5  145a		       00		      .byte.b	0
      0  145b					      EVAL8	0
      1  145b				  -	      IF	(0 > 127) || (0 < -128)
      2  145b				  -	      ECHO	"Erroneous position value", 0
      3  145b				  -	      ERR
      4  145b					      ENDIF
      5  145b		       00		      .byte.b	0
      0  145c					      EVAL8	0
      1  145c				  -	      IF	(0 > 127) || (0 < -128)
      2  145c				  -	      ECHO	"Erroneous position value", 0
      3  145c				  -	      ERR
      4  145c					      ENDIF
      5  145c		       00		      .byte.b	0
      0  145d					      EVAL8	0
      1  145d				  -	      IF	(0 > 127) || (0 < -128)
      2  145d				  -	      ECHO	"Erroneous position value", 0
      3  145d				  -	      ERR
      4  145d					      ENDIF
      5  145d		       00		      .byte.b	0
      0  145e					      EVAL8	0
      1  145e				  -	      IF	(0 > 127) || (0 < -128)
      2  145e				  -	      ECHO	"Erroneous position value", 0
      3  145e				  -	      ERR
      4  145e					      ENDIF
      5  145e		       00		      .byte.b	0
      0  145f					      EVAL8	0
      1  145f				  -	      IF	(0 > 127) || (0 < -128)
      2  145f				  -	      ECHO	"Erroneous position value", 0
      3  145f				  -	      ERR
      4  145f					      ENDIF
      5  145f		       00		      .byte.b	0
    104  1460
    105  1460							;---------------------------------------------------------------------------------------------------
    106  1460
    107  1460				   PositionalValue_KNIGHT
    108  1460
      0  1460					      PVAL	-50, -30, -30, -30, -30, -30, -22, -50
      0  1460					      EVAL8	-50
      1  1460				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1460				  -	      ECHO	"Erroneous position value", -50
      3  1460				  -	      ERR
      4  1460					      ENDIF
      5  1460		       ce		      .byte.b	-50
      0  1461					      EVAL8	-30
      1  1461				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1461				  -	      ECHO	"Erroneous position value", -30
      3  1461				  -	      ERR
      4  1461					      ENDIF
      5  1461		       e2		      .byte.b	-30
      0  1462					      EVAL8	-30
      1  1462				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1462				  -	      ECHO	"Erroneous position value", -30
      3  1462				  -	      ERR
      4  1462					      ENDIF
      5  1462		       e2		      .byte.b	-30
      0  1463					      EVAL8	-30
      1  1463				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1463				  -	      ECHO	"Erroneous position value", -30
      3  1463				  -	      ERR
      4  1463					      ENDIF
      5  1463		       e2		      .byte.b	-30
      0  1464					      EVAL8	-30
      1  1464				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1464				  -	      ECHO	"Erroneous position value", -30
      3  1464				  -	      ERR
      4  1464					      ENDIF
      5  1464		       e2		      .byte.b	-30
      0  1465					      EVAL8	-30
      1  1465				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1465				  -	      ECHO	"Erroneous position value", -30
      3  1465				  -	      ERR
      4  1465					      ENDIF
      5  1465		       e2		      .byte.b	-30
      0  1466					      EVAL8	-22
      1  1466				  -	      IF	(-22 > 127) || (-22 < -128)
      2  1466				  -	      ECHO	"Erroneous position value", -22
      3  1466				  -	      ERR
      4  1466					      ENDIF
      5  1466		       ea		      .byte.b	-22
      0  1467					      EVAL8	-50
      1  1467				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1467				  -	      ECHO	"Erroneous position value", -50
      3  1467				  -	      ERR
      4  1467					      ENDIF
      5  1467		       ce		      .byte.b	-50
      0  1468					      EVAL8	0
      1  1468				  -	      IF	(0 > 127) || (0 < -128)
      2  1468				  -	      ECHO	"Erroneous position value", 0
      3  1468				  -	      ERR
      4  1468					      ENDIF
      5  1468		       00		      .byte.b	0
      0  1469					      EVAL8	0
      1  1469				  -	      IF	(0 > 127) || (0 < -128)
      2  1469				  -	      ECHO	"Erroneous position value", 0
      3  1469				  -	      ERR
      4  1469					      ENDIF
      5  1469		       00		      .byte.b	0
      0  146a					      PVAL	-40, -20, 0, -5, -25, 0, -20, -40
      0  146a					      EVAL8	-40
      1  146a				  -	      IF	(-40 > 127) || (-40 < -128)
      2  146a				  -	      ECHO	"Erroneous position value", -40
      3  146a				  -	      ERR
      4  146a					      ENDIF
      5  146a		       d8		      .byte.b	-40
      0  146b					      EVAL8	-20
      1  146b				  -	      IF	(-20 > 127) || (-20 < -128)
      2  146b				  -	      ECHO	"Erroneous position value", -20
      3  146b				  -	      ERR
      4  146b					      ENDIF
      5  146b		       ec		      .byte.b	-20
      0  146c					      EVAL8	0
      1  146c				  -	      IF	(0 > 127) || (0 < -128)
      2  146c				  -	      ECHO	"Erroneous position value", 0
      3  146c				  -	      ERR
      4  146c					      ENDIF
      5  146c		       00		      .byte.b	0
      0  146d					      EVAL8	-5
      1  146d				  -	      IF	(-5 > 127) || (-5 < -128)
      2  146d				  -	      ECHO	"Erroneous position value", -5
      3  146d				  -	      ERR
      4  146d					      ENDIF
      5  146d		       fb		      .byte.b	-5
      0  146e					      EVAL8	-25
      1  146e				  -	      IF	(-25 > 127) || (-25 < -128)
      2  146e				  -	      ECHO	"Erroneous position value", -25
      3  146e				  -	      ERR
      4  146e					      ENDIF
      5  146e		       e7		      .byte.b	-25
      0  146f					      EVAL8	0
      1  146f				  -	      IF	(0 > 127) || (0 < -128)
      2  146f				  -	      ECHO	"Erroneous position value", 0
      3  146f				  -	      ERR
      4  146f					      ENDIF
      5  146f		       00		      .byte.b	0
      0  1470					      EVAL8	-20
      1  1470				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1470				  -	      ECHO	"Erroneous position value", -20
      3  1470				  -	      ERR
      4  1470					      ENDIF
      5  1470		       ec		      .byte.b	-20
      0  1471					      EVAL8	-40
      1  1471				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1471				  -	      ECHO	"Erroneous position value", -40
      3  1471				  -	      ERR
      4  1471					      ENDIF
      5  1471		       d8		      .byte.b	-40
      0  1472					      EVAL8	0
      1  1472				  -	      IF	(0 > 127) || (0 < -128)
      2  1472				  -	      ECHO	"Erroneous position value", 0
      3  1472				  -	      ERR
      4  1472					      ENDIF
      5  1472		       00		      .byte.b	0
      0  1473					      EVAL8	0
      1  1473				  -	      IF	(0 > 127) || (0 < -128)
      2  1473				  -	      ECHO	"Erroneous position value", 0
      3  1473				  -	      ERR
      4  1473					      ENDIF
      5  1473		       00		      .byte.b	0
      0  1474					      PVAL	-30, 0, 18, 15, 15, 18, 0, -30
      0  1474					      EVAL8	-30
      1  1474				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1474				  -	      ECHO	"Erroneous position value", -30
      3  1474				  -	      ERR
      4  1474					      ENDIF
      5  1474		       e2		      .byte.b	-30
      0  1475					      EVAL8	0
      1  1475				  -	      IF	(0 > 127) || (0 < -128)
      2  1475				  -	      ECHO	"Erroneous position value", 0
      3  1475				  -	      ERR
      4  1475					      ENDIF
      5  1475		       00		      .byte.b	0
      0  1476					      EVAL8	18
      1  1476				  -	      IF	(18 > 127) || (18 < -128)
      2  1476				  -	      ECHO	"Erroneous position value", 18
      3  1476				  -	      ERR
      4  1476					      ENDIF
      5  1476		       12		      .byte.b	18
      0  1477					      EVAL8	15
      1  1477				  -	      IF	(15 > 127) || (15 < -128)
      2  1477				  -	      ECHO	"Erroneous position value", 15
      3  1477				  -	      ERR
      4  1477					      ENDIF
      5  1477		       0f		      .byte.b	15
      0  1478					      EVAL8	15
      1  1478				  -	      IF	(15 > 127) || (15 < -128)
      2  1478				  -	      ECHO	"Erroneous position value", 15
      3  1478				  -	      ERR
      4  1478					      ENDIF
      5  1478		       0f		      .byte.b	15
      0  1479					      EVAL8	18
      1  1479				  -	      IF	(18 > 127) || (18 < -128)
      2  1479				  -	      ECHO	"Erroneous position value", 18
      3  1479				  -	      ERR
      4  1479					      ENDIF
      5  1479		       12		      .byte.b	18
      0  147a					      EVAL8	0
      1  147a				  -	      IF	(0 > 127) || (0 < -128)
      2  147a				  -	      ECHO	"Erroneous position value", 0
      3  147a				  -	      ERR
      4  147a					      ENDIF
      5  147a		       00		      .byte.b	0
      0  147b					      EVAL8	-30
      1  147b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  147b				  -	      ECHO	"Erroneous position value", -30
      3  147b				  -	      ERR
      4  147b					      ENDIF
      5  147b		       e2		      .byte.b	-30
      0  147c					      EVAL8	0
      1  147c				  -	      IF	(0 > 127) || (0 < -128)
      2  147c				  -	      ECHO	"Erroneous position value", 0
      3  147c				  -	      ERR
      4  147c					      ENDIF
      5  147c		       00		      .byte.b	0
      0  147d					      EVAL8	0
      1  147d				  -	      IF	(0 > 127) || (0 < -128)
      2  147d				  -	      ECHO	"Erroneous position value", 0
      3  147d				  -	      ERR
      4  147d					      ENDIF
      5  147d		       00		      .byte.b	0
      0  147e					      PVAL	-40, 0, 15, 30, 30, 15, 0, -40
      0  147e					      EVAL8	-40
      1  147e				  -	      IF	(-40 > 127) || (-40 < -128)
      2  147e				  -	      ECHO	"Erroneous position value", -40
      3  147e				  -	      ERR
      4  147e					      ENDIF
      5  147e		       d8		      .byte.b	-40
      0  147f					      EVAL8	0
      1  147f				  -	      IF	(0 > 127) || (0 < -128)
      2  147f				  -	      ECHO	"Erroneous position value", 0
      3  147f				  -	      ERR
      4  147f					      ENDIF
      5  147f		       00		      .byte.b	0
      0  1480					      EVAL8	15
      1  1480				  -	      IF	(15 > 127) || (15 < -128)
      2  1480				  -	      ECHO	"Erroneous position value", 15
      3  1480				  -	      ERR
      4  1480					      ENDIF
      5  1480		       0f		      .byte.b	15
      0  1481					      EVAL8	30
      1  1481				  -	      IF	(30 > 127) || (30 < -128)
      2  1481				  -	      ECHO	"Erroneous position value", 30
      3  1481				  -	      ERR
      4  1481					      ENDIF
      5  1481		       1e		      .byte.b	30
      0  1482					      EVAL8	30
      1  1482				  -	      IF	(30 > 127) || (30 < -128)
      2  1482				  -	      ECHO	"Erroneous position value", 30
      3  1482				  -	      ERR
      4  1482					      ENDIF
      5  1482		       1e		      .byte.b	30
      0  1483					      EVAL8	15
      1  1483				  -	      IF	(15 > 127) || (15 < -128)
      2  1483				  -	      ECHO	"Erroneous position value", 15
      3  1483				  -	      ERR
      4  1483					      ENDIF
      5  1483		       0f		      .byte.b	15
      0  1484					      EVAL8	0
      1  1484				  -	      IF	(0 > 127) || (0 < -128)
      2  1484				  -	      ECHO	"Erroneous position value", 0
      3  1484				  -	      ERR
      4  1484					      ENDIF
      5  1484		       00		      .byte.b	0
      0  1485					      EVAL8	-40
      1  1485				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1485				  -	      ECHO	"Erroneous position value", -40
      3  1485				  -	      ERR
      4  1485					      ENDIF
      5  1485		       d8		      .byte.b	-40
      0  1486					      EVAL8	0
      1  1486				  -	      IF	(0 > 127) || (0 < -128)
      2  1486				  -	      ECHO	"Erroneous position value", 0
      3  1486				  -	      ERR
      4  1486					      ENDIF
      5  1486		       00		      .byte.b	0
      0  1487					      EVAL8	0
      1  1487				  -	      IF	(0 > 127) || (0 < -128)
      2  1487				  -	      ECHO	"Erroneous position value", 0
      3  1487				  -	      ERR
      4  1487					      ENDIF
      5  1487		       00		      .byte.b	0
      0  1488					      PVAL	-40, 5, 15, 30, 30, 15, 5, -40
      0  1488					      EVAL8	-40
      1  1488				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1488				  -	      ECHO	"Erroneous position value", -40
      3  1488				  -	      ERR
      4  1488					      ENDIF
      5  1488		       d8		      .byte.b	-40
      0  1489					      EVAL8	5
      1  1489				  -	      IF	(5 > 127) || (5 < -128)
      2  1489				  -	      ECHO	"Erroneous position value", 5
      3  1489				  -	      ERR
      4  1489					      ENDIF
      5  1489		       05		      .byte.b	5
      0  148a					      EVAL8	15
      1  148a				  -	      IF	(15 > 127) || (15 < -128)
      2  148a				  -	      ECHO	"Erroneous position value", 15
      3  148a				  -	      ERR
      4  148a					      ENDIF
      5  148a		       0f		      .byte.b	15
      0  148b					      EVAL8	30
      1  148b				  -	      IF	(30 > 127) || (30 < -128)
      2  148b				  -	      ECHO	"Erroneous position value", 30
      3  148b				  -	      ERR
      4  148b					      ENDIF
      5  148b		       1e		      .byte.b	30
      0  148c					      EVAL8	30
      1  148c				  -	      IF	(30 > 127) || (30 < -128)
      2  148c				  -	      ECHO	"Erroneous position value", 30
      3  148c				  -	      ERR
      4  148c					      ENDIF
      5  148c		       1e		      .byte.b	30
      0  148d					      EVAL8	15
      1  148d				  -	      IF	(15 > 127) || (15 < -128)
      2  148d				  -	      ECHO	"Erroneous position value", 15
      3  148d				  -	      ERR
      4  148d					      ENDIF
      5  148d		       0f		      .byte.b	15
      0  148e					      EVAL8	5
      1  148e				  -	      IF	(5 > 127) || (5 < -128)
      2  148e				  -	      ECHO	"Erroneous position value", 5
      3  148e				  -	      ERR
      4  148e					      ENDIF
      5  148e		       05		      .byte.b	5
      0  148f					      EVAL8	-40
      1  148f				  -	      IF	(-40 > 127) || (-40 < -128)
      2  148f				  -	      ECHO	"Erroneous position value", -40
      3  148f				  -	      ERR
      4  148f					      ENDIF
      5  148f		       d8		      .byte.b	-40
      0  1490					      EVAL8	0
      1  1490				  -	      IF	(0 > 127) || (0 < -128)
      2  1490				  -	      ECHO	"Erroneous position value", 0
      3  1490				  -	      ERR
      4  1490					      ENDIF
      5  1490		       00		      .byte.b	0
      0  1491					      EVAL8	0
      1  1491				  -	      IF	(0 > 127) || (0 < -128)
      2  1491				  -	      ECHO	"Erroneous position value", 0
      3  1491				  -	      ERR
      4  1491					      ENDIF
      5  1491		       00		      .byte.b	0
      0  1492					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      0  1492					      EVAL8	-30
      1  1492				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1492				  -	      ECHO	"Erroneous position value", -30
      3  1492				  -	      ERR
      4  1492					      ENDIF
      5  1492		       e2		      .byte.b	-30
      0  1493					      EVAL8	0
      1  1493				  -	      IF	(0 > 127) || (0 < -128)
      2  1493				  -	      ECHO	"Erroneous position value", 0
      3  1493				  -	      ERR
      4  1493					      ENDIF
      5  1493		       00		      .byte.b	0
      0  1494					      EVAL8	10
      1  1494				  -	      IF	(10 > 127) || (10 < -128)
      2  1494				  -	      ECHO	"Erroneous position value", 10
      3  1494				  -	      ERR
      4  1494					      ENDIF
      5  1494		       0a		      .byte.b	10
      0  1495					      EVAL8	15
      1  1495				  -	      IF	(15 > 127) || (15 < -128)
      2  1495				  -	      ECHO	"Erroneous position value", 15
      3  1495				  -	      ERR
      4  1495					      ENDIF
      5  1495		       0f		      .byte.b	15
      0  1496					      EVAL8	15
      1  1496				  -	      IF	(15 > 127) || (15 < -128)
      2  1496				  -	      ECHO	"Erroneous position value", 15
      3  1496				  -	      ERR
      4  1496					      ENDIF
      5  1496		       0f		      .byte.b	15
      0  1497					      EVAL8	10
      1  1497				  -	      IF	(10 > 127) || (10 < -128)
      2  1497				  -	      ECHO	"Erroneous position value", 10
      3  1497				  -	      ERR
      4  1497					      ENDIF
      5  1497		       0a		      .byte.b	10
      0  1498					      EVAL8	0
      1  1498				  -	      IF	(0 > 127) || (0 < -128)
      2  1498				  -	      ECHO	"Erroneous position value", 0
      3  1498				  -	      ERR
      4  1498					      ENDIF
      5  1498		       00		      .byte.b	0
      0  1499					      EVAL8	-30
      1  1499				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1499				  -	      ECHO	"Erroneous position value", -30
      3  1499				  -	      ERR
      4  1499					      ENDIF
      5  1499		       e2		      .byte.b	-30
      0  149a					      EVAL8	0
      1  149a				  -	      IF	(0 > 127) || (0 < -128)
      2  149a				  -	      ECHO	"Erroneous position value", 0
      3  149a				  -	      ERR
      4  149a					      ENDIF
      5  149a		       00		      .byte.b	0
      0  149b					      EVAL8	0
      1  149b				  -	      IF	(0 > 127) || (0 < -128)
      2  149b				  -	      ECHO	"Erroneous position value", 0
      3  149b				  -	      ERR
      4  149b					      ENDIF
      5  149b		       00		      .byte.b	0
      0  149c					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      0  149c					      EVAL8	-40
      1  149c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  149c				  -	      ECHO	"Erroneous position value", -40
      3  149c				  -	      ERR
      4  149c					      ENDIF
      5  149c		       d8		      .byte.b	-40
      0  149d					      EVAL8	-20
      1  149d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  149d				  -	      ECHO	"Erroneous position value", -20
      3  149d				  -	      ERR
      4  149d					      ENDIF
      5  149d		       ec		      .byte.b	-20
      0  149e					      EVAL8	30
      1  149e				  -	      IF	(30 > 127) || (30 < -128)
      2  149e				  -	      ECHO	"Erroneous position value", 30
      3  149e				  -	      ERR
      4  149e					      ENDIF
      5  149e		       1e		      .byte.b	30
      0  149f					      EVAL8	0
      1  149f				  -	      IF	(0 > 127) || (0 < -128)
      2  149f				  -	      ECHO	"Erroneous position value", 0
      3  149f				  -	      ERR
      4  149f					      ENDIF
      5  149f		       00		      .byte.b	0
      0  14a0					      EVAL8	0
      1  14a0				  -	      IF	(0 > 127) || (0 < -128)
      2  14a0				  -	      ECHO	"Erroneous position value", 0
      3  14a0				  -	      ERR
      4  14a0					      ENDIF
      5  14a0		       00		      .byte.b	0
      0  14a1					      EVAL8	30
      1  14a1				  -	      IF	(30 > 127) || (30 < -128)
      2  14a1				  -	      ECHO	"Erroneous position value", 30
      3  14a1				  -	      ERR
      4  14a1					      ENDIF
      5  14a1		       1e		      .byte.b	30
      0  14a2					      EVAL8	-20
      1  14a2				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14a2				  -	      ECHO	"Erroneous position value", -20
      3  14a2				  -	      ERR
      4  14a2					      ENDIF
      5  14a2		       ec		      .byte.b	-20
      0  14a3					      EVAL8	-40
      1  14a3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  14a3				  -	      ECHO	"Erroneous position value", -40
      3  14a3				  -	      ERR
      4  14a3					      ENDIF
      5  14a3		       d8		      .byte.b	-40
      0  14a4					      EVAL8	0
      1  14a4				  -	      IF	(0 > 127) || (0 < -128)
      2  14a4				  -	      ECHO	"Erroneous position value", 0
      3  14a4				  -	      ERR
      4  14a4					      ENDIF
      5  14a4		       00		      .byte.b	0
      0  14a5					      EVAL8	0
      1  14a5				  -	      IF	(0 > 127) || (0 < -128)
      2  14a5				  -	      ECHO	"Erroneous position value", 0
      3  14a5				  -	      ERR
      4  14a5					      ENDIF
      5  14a5		       00		      .byte.b	0
      0  14a6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      0  14a6					      EVAL8	-50
      1  14a6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  14a6				  -	      ECHO	"Erroneous position value", -50
      3  14a6				  -	      ERR
      4  14a6					      ENDIF
      5  14a6		       ce		      .byte.b	-50
      0  14a7					      EVAL8	-20
      1  14a7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14a7				  -	      ECHO	"Erroneous position value", -20
      3  14a7				  -	      ERR
      4  14a7					      ENDIF
      5  14a7		       ec		      .byte.b	-20
      0  14a8					      EVAL8	-30
      1  14a8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  14a8				  -	      ECHO	"Erroneous position value", -30
      3  14a8				  -	      ERR
      4  14a8					      ENDIF
      5  14a8		       e2		      .byte.b	-30
      0  14a9					      EVAL8	-30
      1  14a9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  14a9				  -	      ECHO	"Erroneous position value", -30
      3  14a9				  -	      ERR
      4  14a9					      ENDIF
      5  14a9		       e2		      .byte.b	-30
      0  14aa					      EVAL8	-30
      1  14aa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  14aa				  -	      ECHO	"Erroneous position value", -30
      3  14aa				  -	      ERR
      4  14aa					      ENDIF
      5  14aa		       e2		      .byte.b	-30
      0  14ab					      EVAL8	-30
      1  14ab				  -	      IF	(-30 > 127) || (-30 < -128)
      2  14ab				  -	      ECHO	"Erroneous position value", -30
      3  14ab				  -	      ERR
      4  14ab					      ENDIF
      5  14ab		       e2		      .byte.b	-30
      0  14ac					      EVAL8	-20
      1  14ac				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14ac				  -	      ECHO	"Erroneous position value", -20
      3  14ac				  -	      ERR
      4  14ac					      ENDIF
      5  14ac		       ec		      .byte.b	-20
      0  14ad					      EVAL8	-50
      1  14ad				  -	      IF	(-50 > 127) || (-50 < -128)
      2  14ad				  -	      ECHO	"Erroneous position value", -50
      3  14ad				  -	      ERR
      4  14ad					      ENDIF
      5  14ad		       ce		      .byte.b	-50
      0  14ae					      EVAL8	0
      1  14ae				  -	      IF	(0 > 127) || (0 < -128)
      2  14ae				  -	      ECHO	"Erroneous position value", 0
      3  14ae				  -	      ERR
      4  14ae					      ENDIF
      5  14ae		       00		      .byte.b	0
      0  14af					      EVAL8	0
      1  14af				  -	      IF	(0 > 127) || (0 < -128)
      2  14af				  -	      ECHO	"Erroneous position value", 0
      3  14af				  -	      ERR
      4  14af					      ENDIF
      5  14af		       00		      .byte.b	0
    117  14b0
    118  14b0
    119  14b0							;---------------------------------------------------------------------------------------------------
    120  14b0
    121  14b0				   PositionalValue_BISHOP
    122  14b0
      0  14b0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      0  14b0					      EVAL8	-20
      1  14b0				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14b0				  -	      ECHO	"Erroneous position value", -20
      3  14b0				  -	      ERR
      4  14b0					      ENDIF
      5  14b0		       ec		      .byte.b	-20
      0  14b1					      EVAL8	-10
      1  14b1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14b1				  -	      ECHO	"Erroneous position value", -10
      3  14b1				  -	      ERR
      4  14b1					      ENDIF
      5  14b1		       f6		      .byte.b	-10
      0  14b2					      EVAL8	-50
      1  14b2				  -	      IF	(-50 > 127) || (-50 < -128)
      2  14b2				  -	      ECHO	"Erroneous position value", -50
      3  14b2				  -	      ERR
      4  14b2					      ENDIF
      5  14b2		       ce		      .byte.b	-50
      0  14b3					      EVAL8	-10
      1  14b3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14b3				  -	      ECHO	"Erroneous position value", -10
      3  14b3				  -	      ERR
      4  14b3					      ENDIF
      5  14b3		       f6		      .byte.b	-10
      0  14b4					      EVAL8	-10
      1  14b4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14b4				  -	      ECHO	"Erroneous position value", -10
      3  14b4				  -	      ERR
      4  14b4					      ENDIF
      5  14b4		       f6		      .byte.b	-10
      0  14b5					      EVAL8	-50
      1  14b5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  14b5				  -	      ECHO	"Erroneous position value", -50
      3  14b5				  -	      ERR
      4  14b5					      ENDIF
      5  14b5		       ce		      .byte.b	-50
      0  14b6					      EVAL8	-10
      1  14b6				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14b6				  -	      ECHO	"Erroneous position value", -10
      3  14b6				  -	      ERR
      4  14b6					      ENDIF
      5  14b6		       f6		      .byte.b	-10
      0  14b7					      EVAL8	-20
      1  14b7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14b7				  -	      ECHO	"Erroneous position value", -20
      3  14b7				  -	      ERR
      4  14b7					      ENDIF
      5  14b7		       ec		      .byte.b	-20
      0  14b8					      EVAL8	0
      1  14b8				  -	      IF	(0 > 127) || (0 < -128)
      2  14b8				  -	      ECHO	"Erroneous position value", 0
      3  14b8				  -	      ERR
      4  14b8					      ENDIF
      5  14b8		       00		      .byte.b	0
      0  14b9					      EVAL8	0
      1  14b9				  -	      IF	(0 > 127) || (0 < -128)
      2  14b9				  -	      ECHO	"Erroneous position value", 0
      3  14b9				  -	      ERR
      4  14b9					      ENDIF
      5  14b9		       00		      .byte.b	0
      0  14ba					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      0  14ba					      EVAL8	-10
      1  14ba				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14ba				  -	      ECHO	"Erroneous position value", -10
      3  14ba				  -	      ERR
      4  14ba					      ENDIF
      5  14ba		       f6		      .byte.b	-10
      0  14bb					      EVAL8	5
      1  14bb				  -	      IF	(5 > 127) || (5 < -128)
      2  14bb				  -	      ECHO	"Erroneous position value", 5
      3  14bb				  -	      ERR
      4  14bb					      ENDIF
      5  14bb		       05		      .byte.b	5
      0  14bc					      EVAL8	0
      1  14bc				  -	      IF	(0 > 127) || (0 < -128)
      2  14bc				  -	      ECHO	"Erroneous position value", 0
      3  14bc				  -	      ERR
      4  14bc					      ENDIF
      5  14bc		       00		      .byte.b	0
      0  14bd					      EVAL8	0
      1  14bd				  -	      IF	(0 > 127) || (0 < -128)
      2  14bd				  -	      ECHO	"Erroneous position value", 0
      3  14bd				  -	      ERR
      4  14bd					      ENDIF
      5  14bd		       00		      .byte.b	0
      0  14be					      EVAL8	0
      1  14be				  -	      IF	(0 > 127) || (0 < -128)
      2  14be				  -	      ECHO	"Erroneous position value", 0
      3  14be				  -	      ERR
      4  14be					      ENDIF
      5  14be		       00		      .byte.b	0
      0  14bf					      EVAL8	0
      1  14bf				  -	      IF	(0 > 127) || (0 < -128)
      2  14bf				  -	      ECHO	"Erroneous position value", 0
      3  14bf				  -	      ERR
      4  14bf					      ENDIF
      5  14bf		       00		      .byte.b	0
      0  14c0					      EVAL8	5
      1  14c0				  -	      IF	(5 > 127) || (5 < -128)
      2  14c0				  -	      ECHO	"Erroneous position value", 5
      3  14c0				  -	      ERR
      4  14c0					      ENDIF
      5  14c0		       05		      .byte.b	5
      0  14c1					      EVAL8	-10
      1  14c1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14c1				  -	      ECHO	"Erroneous position value", -10
      3  14c1				  -	      ERR
      4  14c1					      ENDIF
      5  14c1		       f6		      .byte.b	-10
      0  14c2					      EVAL8	0
      1  14c2				  -	      IF	(0 > 127) || (0 < -128)
      2  14c2				  -	      ECHO	"Erroneous position value", 0
      3  14c2				  -	      ERR
      4  14c2					      ENDIF
      5  14c2		       00		      .byte.b	0
      0  14c3					      EVAL8	0
      1  14c3				  -	      IF	(0 > 127) || (0 < -128)
      2  14c3				  -	      ECHO	"Erroneous position value", 0
      3  14c3				  -	      ERR
      4  14c3					      ENDIF
      5  14c3		       00		      .byte.b	0
      0  14c4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      0  14c4					      EVAL8	-10
      1  14c4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14c4				  -	      ECHO	"Erroneous position value", -10
      3  14c4				  -	      ERR
      4  14c4					      ENDIF
      5  14c4		       f6		      .byte.b	-10
      0  14c5					      EVAL8	10
      1  14c5				  -	      IF	(10 > 127) || (10 < -128)
      2  14c5				  -	      ECHO	"Erroneous position value", 10
      3  14c5				  -	      ERR
      4  14c5					      ENDIF
      5  14c5		       0a		      .byte.b	10
      0  14c6					      EVAL8	10
      1  14c6				  -	      IF	(10 > 127) || (10 < -128)
      2  14c6				  -	      ECHO	"Erroneous position value", 10
      3  14c6				  -	      ERR
      4  14c6					      ENDIF
      5  14c6		       0a		      .byte.b	10
      0  14c7					      EVAL8	10
      1  14c7				  -	      IF	(10 > 127) || (10 < -128)
      2  14c7				  -	      ECHO	"Erroneous position value", 10
      3  14c7				  -	      ERR
      4  14c7					      ENDIF
      5  14c7		       0a		      .byte.b	10
      0  14c8					      EVAL8	10
      1  14c8				  -	      IF	(10 > 127) || (10 < -128)
      2  14c8				  -	      ECHO	"Erroneous position value", 10
      3  14c8				  -	      ERR
      4  14c8					      ENDIF
      5  14c8		       0a		      .byte.b	10
      0  14c9					      EVAL8	10
      1  14c9				  -	      IF	(10 > 127) || (10 < -128)
      2  14c9				  -	      ECHO	"Erroneous position value", 10
      3  14c9				  -	      ERR
      4  14c9					      ENDIF
      5  14c9		       0a		      .byte.b	10
      0  14ca					      EVAL8	10
      1  14ca				  -	      IF	(10 > 127) || (10 < -128)
      2  14ca				  -	      ECHO	"Erroneous position value", 10
      3  14ca				  -	      ERR
      4  14ca					      ENDIF
      5  14ca		       0a		      .byte.b	10
      0  14cb					      EVAL8	-10
      1  14cb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14cb				  -	      ECHO	"Erroneous position value", -10
      3  14cb				  -	      ERR
      4  14cb					      ENDIF
      5  14cb		       f6		      .byte.b	-10
      0  14cc					      EVAL8	0
      1  14cc				  -	      IF	(0 > 127) || (0 < -128)
      2  14cc				  -	      ECHO	"Erroneous position value", 0
      3  14cc				  -	      ERR
      4  14cc					      ENDIF
      5  14cc		       00		      .byte.b	0
      0  14cd					      EVAL8	0
      1  14cd				  -	      IF	(0 > 127) || (0 < -128)
      2  14cd				  -	      ECHO	"Erroneous position value", 0
      3  14cd				  -	      ERR
      4  14cd					      ENDIF
      5  14cd		       00		      .byte.b	0
      0  14ce					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      0  14ce					      EVAL8	-10
      1  14ce				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14ce				  -	      ECHO	"Erroneous position value", -10
      3  14ce				  -	      ERR
      4  14ce					      ENDIF
      5  14ce		       f6		      .byte.b	-10
      0  14cf					      EVAL8	0
      1  14cf				  -	      IF	(0 > 127) || (0 < -128)
      2  14cf				  -	      ECHO	"Erroneous position value", 0
      3  14cf				  -	      ERR
      4  14cf					      ENDIF
      5  14cf		       00		      .byte.b	0
      0  14d0					      EVAL8	10
      1  14d0				  -	      IF	(10 > 127) || (10 < -128)
      2  14d0				  -	      ECHO	"Erroneous position value", 10
      3  14d0				  -	      ERR
      4  14d0					      ENDIF
      5  14d0		       0a		      .byte.b	10
      0  14d1					      EVAL8	20
      1  14d1				  -	      IF	(20 > 127) || (20 < -128)
      2  14d1				  -	      ECHO	"Erroneous position value", 20
      3  14d1				  -	      ERR
      4  14d1					      ENDIF
      5  14d1		       14		      .byte.b	20
      0  14d2					      EVAL8	20
      1  14d2				  -	      IF	(20 > 127) || (20 < -128)
      2  14d2				  -	      ECHO	"Erroneous position value", 20
      3  14d2				  -	      ERR
      4  14d2					      ENDIF
      5  14d2		       14		      .byte.b	20
      0  14d3					      EVAL8	10
      1  14d3				  -	      IF	(10 > 127) || (10 < -128)
      2  14d3				  -	      ECHO	"Erroneous position value", 10
      3  14d3				  -	      ERR
      4  14d3					      ENDIF
      5  14d3		       0a		      .byte.b	10
      0  14d4					      EVAL8	0
      1  14d4				  -	      IF	(0 > 127) || (0 < -128)
      2  14d4				  -	      ECHO	"Erroneous position value", 0
      3  14d4				  -	      ERR
      4  14d4					      ENDIF
      5  14d4		       00		      .byte.b	0
      0  14d5					      EVAL8	-10
      1  14d5				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14d5				  -	      ECHO	"Erroneous position value", -10
      3  14d5				  -	      ERR
      4  14d5					      ENDIF
      5  14d5		       f6		      .byte.b	-10
      0  14d6					      EVAL8	0
      1  14d6				  -	      IF	(0 > 127) || (0 < -128)
      2  14d6				  -	      ECHO	"Erroneous position value", 0
      3  14d6				  -	      ERR
      4  14d6					      ENDIF
      5  14d6		       00		      .byte.b	0
      0  14d7					      EVAL8	0
      1  14d7				  -	      IF	(0 > 127) || (0 < -128)
      2  14d7				  -	      ECHO	"Erroneous position value", 0
      3  14d7				  -	      ERR
      4  14d7					      ENDIF
      5  14d7		       00		      .byte.b	0
      0  14d8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      0  14d8					      EVAL8	-10
      1  14d8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14d8				  -	      ECHO	"Erroneous position value", -10
      3  14d8				  -	      ERR
      4  14d8					      ENDIF
      5  14d8		       f6		      .byte.b	-10
      0  14d9					      EVAL8	5
      1  14d9				  -	      IF	(5 > 127) || (5 < -128)
      2  14d9				  -	      ECHO	"Erroneous position value", 5
      3  14d9				  -	      ERR
      4  14d9					      ENDIF
      5  14d9		       05		      .byte.b	5
      0  14da					      EVAL8	5
      1  14da				  -	      IF	(5 > 127) || (5 < -128)
      2  14da				  -	      ECHO	"Erroneous position value", 5
      3  14da				  -	      ERR
      4  14da					      ENDIF
      5  14da		       05		      .byte.b	5
      0  14db					      EVAL8	20
      1  14db				  -	      IF	(20 > 127) || (20 < -128)
      2  14db				  -	      ECHO	"Erroneous position value", 20
      3  14db				  -	      ERR
      4  14db					      ENDIF
      5  14db		       14		      .byte.b	20
      0  14dc					      EVAL8	20
      1  14dc				  -	      IF	(20 > 127) || (20 < -128)
      2  14dc				  -	      ECHO	"Erroneous position value", 20
      3  14dc				  -	      ERR
      4  14dc					      ENDIF
      5  14dc		       14		      .byte.b	20
      0  14dd					      EVAL8	5
      1  14dd				  -	      IF	(5 > 127) || (5 < -128)
      2  14dd				  -	      ECHO	"Erroneous position value", 5
      3  14dd				  -	      ERR
      4  14dd					      ENDIF
      5  14dd		       05		      .byte.b	5
      0  14de					      EVAL8	5
      1  14de				  -	      IF	(5 > 127) || (5 < -128)
      2  14de				  -	      ECHO	"Erroneous position value", 5
      3  14de				  -	      ERR
      4  14de					      ENDIF
      5  14de		       05		      .byte.b	5
      0  14df					      EVAL8	-10
      1  14df				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14df				  -	      ECHO	"Erroneous position value", -10
      3  14df				  -	      ERR
      4  14df					      ENDIF
      5  14df		       f6		      .byte.b	-10
      0  14e0					      EVAL8	0
      1  14e0				  -	      IF	(0 > 127) || (0 < -128)
      2  14e0				  -	      ECHO	"Erroneous position value", 0
      3  14e0				  -	      ERR
      4  14e0					      ENDIF
      5  14e0		       00		      .byte.b	0
      0  14e1					      EVAL8	0
      1  14e1				  -	      IF	(0 > 127) || (0 < -128)
      2  14e1				  -	      ECHO	"Erroneous position value", 0
      3  14e1				  -	      ERR
      4  14e1					      ENDIF
      5  14e1		       00		      .byte.b	0
      0  14e2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      0  14e2					      EVAL8	-10
      1  14e2				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14e2				  -	      ECHO	"Erroneous position value", -10
      3  14e2				  -	      ERR
      4  14e2					      ENDIF
      5  14e2		       f6		      .byte.b	-10
      0  14e3					      EVAL8	0
      1  14e3				  -	      IF	(0 > 127) || (0 < -128)
      2  14e3				  -	      ECHO	"Erroneous position value", 0
      3  14e3				  -	      ERR
      4  14e3					      ENDIF
      5  14e3		       00		      .byte.b	0
      0  14e4					      EVAL8	5
      1  14e4				  -	      IF	(5 > 127) || (5 < -128)
      2  14e4				  -	      ECHO	"Erroneous position value", 5
      3  14e4				  -	      ERR
      4  14e4					      ENDIF
      5  14e4		       05		      .byte.b	5
      0  14e5					      EVAL8	10
      1  14e5				  -	      IF	(10 > 127) || (10 < -128)
      2  14e5				  -	      ECHO	"Erroneous position value", 10
      3  14e5				  -	      ERR
      4  14e5					      ENDIF
      5  14e5		       0a		      .byte.b	10
      0  14e6					      EVAL8	10
      1  14e6				  -	      IF	(10 > 127) || (10 < -128)
      2  14e6				  -	      ECHO	"Erroneous position value", 10
      3  14e6				  -	      ERR
      4  14e6					      ENDIF
      5  14e6		       0a		      .byte.b	10
      0  14e7					      EVAL8	5
      1  14e7				  -	      IF	(5 > 127) || (5 < -128)
      2  14e7				  -	      ECHO	"Erroneous position value", 5
      3  14e7				  -	      ERR
      4  14e7					      ENDIF
      5  14e7		       05		      .byte.b	5
      0  14e8					      EVAL8	0
      1  14e8				  -	      IF	(0 > 127) || (0 < -128)
      2  14e8				  -	      ECHO	"Erroneous position value", 0
      3  14e8				  -	      ERR
      4  14e8					      ENDIF
      5  14e8		       00		      .byte.b	0
      0  14e9					      EVAL8	-10
      1  14e9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14e9				  -	      ECHO	"Erroneous position value", -10
      3  14e9				  -	      ERR
      4  14e9					      ENDIF
      5  14e9		       f6		      .byte.b	-10
      0  14ea					      EVAL8	0
      1  14ea				  -	      IF	(0 > 127) || (0 < -128)
      2  14ea				  -	      ECHO	"Erroneous position value", 0
      3  14ea				  -	      ERR
      4  14ea					      ENDIF
      5  14ea		       00		      .byte.b	0
      0  14eb					      EVAL8	0
      1  14eb				  -	      IF	(0 > 127) || (0 < -128)
      2  14eb				  -	      ECHO	"Erroneous position value", 0
      3  14eb				  -	      ERR
      4  14eb					      ENDIF
      5  14eb		       00		      .byte.b	0
      0  14ec					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  14ec					      EVAL8	-10
      1  14ec				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14ec				  -	      ECHO	"Erroneous position value", -10
      3  14ec				  -	      ERR
      4  14ec					      ENDIF
      5  14ec		       f6		      .byte.b	-10
      0  14ed					      EVAL8	0
      1  14ed				  -	      IF	(0 > 127) || (0 < -128)
      2  14ed				  -	      ECHO	"Erroneous position value", 0
      3  14ed				  -	      ERR
      4  14ed					      ENDIF
      5  14ed		       00		      .byte.b	0
      0  14ee					      EVAL8	0
      1  14ee				  -	      IF	(0 > 127) || (0 < -128)
      2  14ee				  -	      ECHO	"Erroneous position value", 0
      3  14ee				  -	      ERR
      4  14ee					      ENDIF
      5  14ee		       00		      .byte.b	0
      0  14ef					      EVAL8	0
      1  14ef				  -	      IF	(0 > 127) || (0 < -128)
      2  14ef				  -	      ECHO	"Erroneous position value", 0
      3  14ef				  -	      ERR
      4  14ef					      ENDIF
      5  14ef		       00		      .byte.b	0
      0  14f0					      EVAL8	0
      1  14f0				  -	      IF	(0 > 127) || (0 < -128)
      2  14f0				  -	      ECHO	"Erroneous position value", 0
      3  14f0				  -	      ERR
      4  14f0					      ENDIF
      5  14f0		       00		      .byte.b	0
      0  14f1					      EVAL8	0
      1  14f1				  -	      IF	(0 > 127) || (0 < -128)
      2  14f1				  -	      ECHO	"Erroneous position value", 0
      3  14f1				  -	      ERR
      4  14f1					      ENDIF
      5  14f1		       00		      .byte.b	0
      0  14f2					      EVAL8	0
      1  14f2				  -	      IF	(0 > 127) || (0 < -128)
      2  14f2				  -	      ECHO	"Erroneous position value", 0
      3  14f2				  -	      ERR
      4  14f2					      ENDIF
      5  14f2		       00		      .byte.b	0
      0  14f3					      EVAL8	-10
      1  14f3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14f3				  -	      ECHO	"Erroneous position value", -10
      3  14f3				  -	      ERR
      4  14f3					      ENDIF
      5  14f3		       f6		      .byte.b	-10
      0  14f4					      EVAL8	0
      1  14f4				  -	      IF	(0 > 127) || (0 < -128)
      2  14f4				  -	      ECHO	"Erroneous position value", 0
      3  14f4				  -	      ERR
      4  14f4					      ENDIF
      5  14f4		       00		      .byte.b	0
      0  14f5					      EVAL8	0
      1  14f5				  -	      IF	(0 > 127) || (0 < -128)
      2  14f5				  -	      ECHO	"Erroneous position value", 0
      3  14f5				  -	      ERR
      4  14f5					      ENDIF
      5  14f5		       00		      .byte.b	0
      0  14f6					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      0  14f6					      EVAL8	-20
      1  14f6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14f6				  -	      ECHO	"Erroneous position value", -20
      3  14f6				  -	      ERR
      4  14f6					      ENDIF
      5  14f6		       ec		      .byte.b	-20
      0  14f7					      EVAL8	-10
      1  14f7				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14f7				  -	      ECHO	"Erroneous position value", -10
      3  14f7				  -	      ERR
      4  14f7					      ENDIF
      5  14f7		       f6		      .byte.b	-10
      0  14f8					      EVAL8	-10
      1  14f8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14f8				  -	      ECHO	"Erroneous position value", -10
      3  14f8				  -	      ERR
      4  14f8					      ENDIF
      5  14f8		       f6		      .byte.b	-10
      0  14f9					      EVAL8	-10
      1  14f9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14f9				  -	      ECHO	"Erroneous position value", -10
      3  14f9				  -	      ERR
      4  14f9					      ENDIF
      5  14f9		       f6		      .byte.b	-10
      0  14fa					      EVAL8	-10
      1  14fa				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14fa				  -	      ECHO	"Erroneous position value", -10
      3  14fa				  -	      ERR
      4  14fa					      ENDIF
      5  14fa		       f6		      .byte.b	-10
      0  14fb					      EVAL8	-10
      1  14fb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14fb				  -	      ECHO	"Erroneous position value", -10
      3  14fb				  -	      ERR
      4  14fb					      ENDIF
      5  14fb		       f6		      .byte.b	-10
      0  14fc					      EVAL8	-10
      1  14fc				  -	      IF	(-10 > 127) || (-10 < -128)
      2  14fc				  -	      ECHO	"Erroneous position value", -10
      3  14fc				  -	      ERR
      4  14fc					      ENDIF
      5  14fc		       f6		      .byte.b	-10
      0  14fd					      EVAL8	-20
      1  14fd				  -	      IF	(-20 > 127) || (-20 < -128)
      2  14fd				  -	      ECHO	"Erroneous position value", -20
      3  14fd				  -	      ERR
      4  14fd					      ENDIF
      5  14fd		       ec		      .byte.b	-20
      0  14fe					      EVAL8	0
      1  14fe				  -	      IF	(0 > 127) || (0 < -128)
      2  14fe				  -	      ECHO	"Erroneous position value", 0
      3  14fe				  -	      ERR
      4  14fe					      ENDIF
      5  14fe		       00		      .byte.b	0
      0  14ff					      EVAL8	0
      1  14ff				  -	      IF	(0 > 127) || (0 < -128)
      2  14ff				  -	      ECHO	"Erroneous position value", 0
      3  14ff				  -	      ERR
      4  14ff					      ENDIF
      5  14ff		       00		      .byte.b	0
    131  1500
    132  1500
    133  1500							;---------------------------------------------------------------------------------------------------
    134  1500
    135  1500				   PositionalValue_ROOK
    136  1500
      0  1500					      PVAL	-25, -20, 10, 55, 55, 50, -20, -25
      0  1500					      EVAL8	-25
      1  1500				  -	      IF	(-25 > 127) || (-25 < -128)
      2  1500				  -	      ECHO	"Erroneous position value", -25
      3  1500				  -	      ERR
      4  1500					      ENDIF
      5  1500		       e7		      .byte.b	-25
      0  1501					      EVAL8	-20
      1  1501				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1501				  -	      ECHO	"Erroneous position value", -20
      3  1501				  -	      ERR
      4  1501					      ENDIF
      5  1501		       ec		      .byte.b	-20
      0  1502					      EVAL8	10
      1  1502				  -	      IF	(10 > 127) || (10 < -128)
      2  1502				  -	      ECHO	"Erroneous position value", 10
      3  1502				  -	      ERR
      4  1502					      ENDIF
      5  1502		       0a		      .byte.b	10
      0  1503					      EVAL8	55
      1  1503				  -	      IF	(55 > 127) || (55 < -128)
      2  1503				  -	      ECHO	"Erroneous position value", 55
      3  1503				  -	      ERR
      4  1503					      ENDIF
      5  1503		       37		      .byte.b	55
      0  1504					      EVAL8	55
      1  1504				  -	      IF	(55 > 127) || (55 < -128)
      2  1504				  -	      ECHO	"Erroneous position value", 55
      3  1504				  -	      ERR
      4  1504					      ENDIF
      5  1504		       37		      .byte.b	55
      0  1505					      EVAL8	50
      1  1505				  -	      IF	(50 > 127) || (50 < -128)
      2  1505				  -	      ECHO	"Erroneous position value", 50
      3  1505				  -	      ERR
      4  1505					      ENDIF
      5  1505		       32		      .byte.b	50
      0  1506					      EVAL8	-20
      1  1506				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1506				  -	      ECHO	"Erroneous position value", -20
      3  1506				  -	      ERR
      4  1506					      ENDIF
      5  1506		       ec		      .byte.b	-20
      0  1507					      EVAL8	-25
      1  1507				  -	      IF	(-25 > 127) || (-25 < -128)
      2  1507				  -	      ECHO	"Erroneous position value", -25
      3  1507				  -	      ERR
      4  1507					      ENDIF
      5  1507		       e7		      .byte.b	-25
      0  1508					      EVAL8	0
      1  1508				  -	      IF	(0 > 127) || (0 < -128)
      2  1508				  -	      ECHO	"Erroneous position value", 0
      3  1508				  -	      ERR
      4  1508					      ENDIF
      5  1508		       00		      .byte.b	0
      0  1509					      EVAL8	0
      1  1509				  -	      IF	(0 > 127) || (0 < -128)
      2  1509				  -	      ECHO	"Erroneous position value", 0
      3  1509				  -	      ERR
      4  1509					      ENDIF
      5  1509		       00		      .byte.b	0
      0  150a					      PVAL	-120, 0, 0, 0, 0, 0, 0, -128
      0  150a					      EVAL8	-120
      1  150a				  -	      IF	(-120 > 127) || (-120 < -128)
      2  150a				  -	      ECHO	"Erroneous position value", -120
      3  150a				  -	      ERR
      4  150a					      ENDIF
      5  150a		       88		      .byte.b	-120
      0  150b					      EVAL8	0
      1  150b				  -	      IF	(0 > 127) || (0 < -128)
      2  150b				  -	      ECHO	"Erroneous position value", 0
      3  150b				  -	      ERR
      4  150b					      ENDIF
      5  150b		       00		      .byte.b	0
      0  150c					      EVAL8	0
      1  150c				  -	      IF	(0 > 127) || (0 < -128)
      2  150c				  -	      ECHO	"Erroneous position value", 0
      3  150c				  -	      ERR
      4  150c					      ENDIF
      5  150c		       00		      .byte.b	0
      0  150d					      EVAL8	0
      1  150d				  -	      IF	(0 > 127) || (0 < -128)
      2  150d				  -	      ECHO	"Erroneous position value", 0
      3  150d				  -	      ERR
      4  150d					      ENDIF
      5  150d		       00		      .byte.b	0
      0  150e					      EVAL8	0
      1  150e				  -	      IF	(0 > 127) || (0 < -128)
      2  150e				  -	      ECHO	"Erroneous position value", 0
      3  150e				  -	      ERR
      4  150e					      ENDIF
      5  150e		       00		      .byte.b	0
      0  150f					      EVAL8	0
      1  150f				  -	      IF	(0 > 127) || (0 < -128)
      2  150f				  -	      ECHO	"Erroneous position value", 0
      3  150f				  -	      ERR
      4  150f					      ENDIF
      5  150f		       00		      .byte.b	0
      0  1510					      EVAL8	0
      1  1510				  -	      IF	(0 > 127) || (0 < -128)
      2  1510				  -	      ECHO	"Erroneous position value", 0
      3  1510				  -	      ERR
      4  1510					      ENDIF
      5  1510		       00		      .byte.b	0
      0  1511					      EVAL8	-128
      1  1511				  -	      IF	(-128 > 127) || (-128 < -128)
      2  1511				  -	      ECHO	"Erroneous position value", -128
      3  1511				  -	      ERR
      4  1511					      ENDIF
      5  1511		       80		      .byte.b	-128
      0  1512					      EVAL8	0
      1  1512				  -	      IF	(0 > 127) || (0 < -128)
      2  1512				  -	      ECHO	"Erroneous position value", 0
      3  1512				  -	      ERR
      4  1512					      ENDIF
      5  1512		       00		      .byte.b	0
      0  1513					      EVAL8	0
      1  1513				  -	      IF	(0 > 127) || (0 < -128)
      2  1513				  -	      ECHO	"Erroneous position value", 0
      3  1513				  -	      ERR
      4  1513					      ENDIF
      5  1513		       00		      .byte.b	0
      0  1514					      PVAL	-128, 0, 0, 0, 0, 0, 0, -100
      0  1514					      EVAL8	-128
      1  1514				  -	      IF	(-128 > 127) || (-128 < -128)
      2  1514				  -	      ECHO	"Erroneous position value", -128
      3  1514				  -	      ERR
      4  1514					      ENDIF
      5  1514		       80		      .byte.b	-128
      0  1515					      EVAL8	0
      1  1515				  -	      IF	(0 > 127) || (0 < -128)
      2  1515				  -	      ECHO	"Erroneous position value", 0
      3  1515				  -	      ERR
      4  1515					      ENDIF
      5  1515		       00		      .byte.b	0
      0  1516					      EVAL8	0
      1  1516				  -	      IF	(0 > 127) || (0 < -128)
      2  1516				  -	      ECHO	"Erroneous position value", 0
      3  1516				  -	      ERR
      4  1516					      ENDIF
      5  1516		       00		      .byte.b	0
      0  1517					      EVAL8	0
      1  1517				  -	      IF	(0 > 127) || (0 < -128)
      2  1517				  -	      ECHO	"Erroneous position value", 0
      3  1517				  -	      ERR
      4  1517					      ENDIF
      5  1517		       00		      .byte.b	0
      0  1518					      EVAL8	0
      1  1518				  -	      IF	(0 > 127) || (0 < -128)
      2  1518				  -	      ECHO	"Erroneous position value", 0
      3  1518				  -	      ERR
      4  1518					      ENDIF
      5  1518		       00		      .byte.b	0
      0  1519					      EVAL8	0
      1  1519				  -	      IF	(0 > 127) || (0 < -128)
      2  1519				  -	      ECHO	"Erroneous position value", 0
      3  1519				  -	      ERR
      4  1519					      ENDIF
      5  1519		       00		      .byte.b	0
      0  151a					      EVAL8	0
      1  151a				  -	      IF	(0 > 127) || (0 < -128)
      2  151a				  -	      ECHO	"Erroneous position value", 0
      3  151a				  -	      ERR
      4  151a					      ENDIF
      5  151a		       00		      .byte.b	0
      0  151b					      EVAL8	-100
      1  151b				  -	      IF	(-100 > 127) || (-100 < -128)
      2  151b				  -	      ECHO	"Erroneous position value", -100
      3  151b				  -	      ERR
      4  151b					      ENDIF
      5  151b		       9c		      .byte.b	-100
      0  151c					      EVAL8	0
      1  151c				  -	      IF	(0 > 127) || (0 < -128)
      2  151c				  -	      ECHO	"Erroneous position value", 0
      3  151c				  -	      ERR
      4  151c					      ENDIF
      5  151c		       00		      .byte.b	0
      0  151d					      EVAL8	0
      1  151d				  -	      IF	(0 > 127) || (0 < -128)
      2  151d				  -	      ECHO	"Erroneous position value", 0
      3  151d				  -	      ERR
      4  151d					      ENDIF
      5  151d		       00		      .byte.b	0
      0  151e					      PVAL	-100, 0, 0, 0, 0, 0, 0, -100
      0  151e					      EVAL8	-100
      1  151e				  -	      IF	(-100 > 127) || (-100 < -128)
      2  151e				  -	      ECHO	"Erroneous position value", -100
      3  151e				  -	      ERR
      4  151e					      ENDIF
      5  151e		       9c		      .byte.b	-100
      0  151f					      EVAL8	0
      1  151f				  -	      IF	(0 > 127) || (0 < -128)
      2  151f				  -	      ECHO	"Erroneous position value", 0
      3  151f				  -	      ERR
      4  151f					      ENDIF
      5  151f		       00		      .byte.b	0
      0  1520					      EVAL8	0
      1  1520				  -	      IF	(0 > 127) || (0 < -128)
      2  1520				  -	      ECHO	"Erroneous position value", 0
      3  1520				  -	      ERR
      4  1520					      ENDIF
      5  1520		       00		      .byte.b	0
      0  1521					      EVAL8	0
      1  1521				  -	      IF	(0 > 127) || (0 < -128)
      2  1521				  -	      ECHO	"Erroneous position value", 0
      3  1521				  -	      ERR
      4  1521					      ENDIF
      5  1521		       00		      .byte.b	0
      0  1522					      EVAL8	0
      1  1522				  -	      IF	(0 > 127) || (0 < -128)
      2  1522				  -	      ECHO	"Erroneous position value", 0
      3  1522				  -	      ERR
      4  1522					      ENDIF
      5  1522		       00		      .byte.b	0
      0  1523					      EVAL8	0
      1  1523				  -	      IF	(0 > 127) || (0 < -128)
      2  1523				  -	      ECHO	"Erroneous position value", 0
      3  1523				  -	      ERR
      4  1523					      ENDIF
      5  1523		       00		      .byte.b	0
      0  1524					      EVAL8	0
      1  1524				  -	      IF	(0 > 127) || (0 < -128)
      2  1524				  -	      ECHO	"Erroneous position value", 0
      3  1524				  -	      ERR
      4  1524					      ENDIF
      5  1524		       00		      .byte.b	0
      0  1525					      EVAL8	-100
      1  1525				  -	      IF	(-100 > 127) || (-100 < -128)
      2  1525				  -	      ECHO	"Erroneous position value", -100
      3  1525				  -	      ERR
      4  1525					      ENDIF
      5  1525		       9c		      .byte.b	-100
      0  1526					      EVAL8	0
      1  1526				  -	      IF	(0 > 127) || (0 < -128)
      2  1526				  -	      ECHO	"Erroneous position value", 0
      3  1526				  -	      ERR
      4  1526					      ENDIF
      5  1526		       00		      .byte.b	0
      0  1527					      EVAL8	0
      1  1527				  -	      IF	(0 > 127) || (0 < -128)
      2  1527				  -	      ECHO	"Erroneous position value", 0
      3  1527				  -	      ERR
      4  1527					      ENDIF
      5  1527		       00		      .byte.b	0
      0  1528					      PVAL	-50, 0, 0, 0, 0, 0, 0, -50
      0  1528					      EVAL8	-50
      1  1528				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1528				  -	      ECHO	"Erroneous position value", -50
      3  1528				  -	      ERR
      4  1528					      ENDIF
      5  1528		       ce		      .byte.b	-50
      0  1529					      EVAL8	0
      1  1529				  -	      IF	(0 > 127) || (0 < -128)
      2  1529				  -	      ECHO	"Erroneous position value", 0
      3  1529				  -	      ERR
      4  1529					      ENDIF
      5  1529		       00		      .byte.b	0
      0  152a					      EVAL8	0
      1  152a				  -	      IF	(0 > 127) || (0 < -128)
      2  152a				  -	      ECHO	"Erroneous position value", 0
      3  152a				  -	      ERR
      4  152a					      ENDIF
      5  152a		       00		      .byte.b	0
      0  152b					      EVAL8	0
      1  152b				  -	      IF	(0 > 127) || (0 < -128)
      2  152b				  -	      ECHO	"Erroneous position value", 0
      3  152b				  -	      ERR
      4  152b					      ENDIF
      5  152b		       00		      .byte.b	0
      0  152c					      EVAL8	0
      1  152c				  -	      IF	(0 > 127) || (0 < -128)
      2  152c				  -	      ECHO	"Erroneous position value", 0
      3  152c				  -	      ERR
      4  152c					      ENDIF
      5  152c		       00		      .byte.b	0
      0  152d					      EVAL8	0
      1  152d				  -	      IF	(0 > 127) || (0 < -128)
      2  152d				  -	      ECHO	"Erroneous position value", 0
      3  152d				  -	      ERR
      4  152d					      ENDIF
      5  152d		       00		      .byte.b	0
      0  152e					      EVAL8	0
      1  152e				  -	      IF	(0 > 127) || (0 < -128)
      2  152e				  -	      ECHO	"Erroneous position value", 0
      3  152e				  -	      ERR
      4  152e					      ENDIF
      5  152e		       00		      .byte.b	0
      0  152f					      EVAL8	-50
      1  152f				  -	      IF	(-50 > 127) || (-50 < -128)
      2  152f				  -	      ECHO	"Erroneous position value", -50
      3  152f				  -	      ERR
      4  152f					      ENDIF
      5  152f		       ce		      .byte.b	-50
      0  1530					      EVAL8	0
      1  1530				  -	      IF	(0 > 127) || (0 < -128)
      2  1530				  -	      ECHO	"Erroneous position value", 0
      3  1530				  -	      ERR
      4  1530					      ENDIF
      5  1530		       00		      .byte.b	0
      0  1531					      EVAL8	0
      1  1531				  -	      IF	(0 > 127) || (0 < -128)
      2  1531				  -	      ECHO	"Erroneous position value", 0
      3  1531				  -	      ERR
      4  1531					      ENDIF
      5  1531		       00		      .byte.b	0
      0  1532					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      0  1532					      EVAL8	-5
      1  1532				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1532				  -	      ECHO	"Erroneous position value", -5
      3  1532				  -	      ERR
      4  1532					      ENDIF
      5  1532		       fb		      .byte.b	-5
      0  1533					      EVAL8	0
      1  1533				  -	      IF	(0 > 127) || (0 < -128)
      2  1533				  -	      ECHO	"Erroneous position value", 0
      3  1533				  -	      ERR
      4  1533					      ENDIF
      5  1533		       00		      .byte.b	0
      0  1534					      EVAL8	30
      1  1534				  -	      IF	(30 > 127) || (30 < -128)
      2  1534				  -	      ECHO	"Erroneous position value", 30
      3  1534				  -	      ERR
      4  1534					      ENDIF
      5  1534		       1e		      .byte.b	30
      0  1535					      EVAL8	30
      1  1535				  -	      IF	(30 > 127) || (30 < -128)
      2  1535				  -	      ECHO	"Erroneous position value", 30
      3  1535				  -	      ERR
      4  1535					      ENDIF
      5  1535		       1e		      .byte.b	30
      0  1536					      EVAL8	30
      1  1536				  -	      IF	(30 > 127) || (30 < -128)
      2  1536				  -	      ECHO	"Erroneous position value", 30
      3  1536				  -	      ERR
      4  1536					      ENDIF
      5  1536		       1e		      .byte.b	30
      0  1537					      EVAL8	30
      1  1537				  -	      IF	(30 > 127) || (30 < -128)
      2  1537				  -	      ECHO	"Erroneous position value", 30
      3  1537				  -	      ERR
      4  1537					      ENDIF
      5  1537		       1e		      .byte.b	30
      0  1538					      EVAL8	0
      1  1538				  -	      IF	(0 > 127) || (0 < -128)
      2  1538				  -	      ECHO	"Erroneous position value", 0
      3  1538				  -	      ERR
      4  1538					      ENDIF
      5  1538		       00		      .byte.b	0
      0  1539					      EVAL8	-5
      1  1539				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1539				  -	      ECHO	"Erroneous position value", -5
      3  1539				  -	      ERR
      4  1539					      ENDIF
      5  1539		       fb		      .byte.b	-5
      0  153a					      EVAL8	0
      1  153a				  -	      IF	(0 > 127) || (0 < -128)
      2  153a				  -	      ECHO	"Erroneous position value", 0
      3  153a				  -	      ERR
      4  153a					      ENDIF
      5  153a		       00		      .byte.b	0
      0  153b					      EVAL8	0
      1  153b				  -	      IF	(0 > 127) || (0 < -128)
      2  153b				  -	      ECHO	"Erroneous position value", 0
      3  153b				  -	      ERR
      4  153b					      ENDIF
      5  153b		       00		      .byte.b	0
      0  153c					      PVAL	55, 80, 90, 90, 90, 90, 80, 55
      0  153c					      EVAL8	55
      1  153c				  -	      IF	(55 > 127) || (55 < -128)
      2  153c				  -	      ECHO	"Erroneous position value", 55
      3  153c				  -	      ERR
      4  153c					      ENDIF
      5  153c		       37		      .byte.b	55
      0  153d					      EVAL8	80
      1  153d				  -	      IF	(80 > 127) || (80 < -128)
      2  153d				  -	      ECHO	"Erroneous position value", 80
      3  153d				  -	      ERR
      4  153d					      ENDIF
      5  153d		       50		      .byte.b	80
      0  153e					      EVAL8	90
      1  153e				  -	      IF	(90 > 127) || (90 < -128)
      2  153e				  -	      ECHO	"Erroneous position value", 90
      3  153e				  -	      ERR
      4  153e					      ENDIF
      5  153e		       5a		      .byte.b	90
      0  153f					      EVAL8	90
      1  153f				  -	      IF	(90 > 127) || (90 < -128)
      2  153f				  -	      ECHO	"Erroneous position value", 90
      3  153f				  -	      ERR
      4  153f					      ENDIF
      5  153f		       5a		      .byte.b	90
      0  1540					      EVAL8	90
      1  1540				  -	      IF	(90 > 127) || (90 < -128)
      2  1540				  -	      ECHO	"Erroneous position value", 90
      3  1540				  -	      ERR
      4  1540					      ENDIF
      5  1540		       5a		      .byte.b	90
      0  1541					      EVAL8	90
      1  1541				  -	      IF	(90 > 127) || (90 < -128)
      2  1541				  -	      ECHO	"Erroneous position value", 90
      3  1541				  -	      ERR
      4  1541					      ENDIF
      5  1541		       5a		      .byte.b	90
      0  1542					      EVAL8	80
      1  1542				  -	      IF	(80 > 127) || (80 < -128)
      2  1542				  -	      ECHO	"Erroneous position value", 80
      3  1542				  -	      ERR
      4  1542					      ENDIF
      5  1542		       50		      .byte.b	80
      0  1543					      EVAL8	55
      1  1543				  -	      IF	(55 > 127) || (55 < -128)
      2  1543				  -	      ECHO	"Erroneous position value", 55
      3  1543				  -	      ERR
      4  1543					      ENDIF
      5  1543		       37		      .byte.b	55
      0  1544					      EVAL8	0
      1  1544				  -	      IF	(0 > 127) || (0 < -128)
      2  1544				  -	      ECHO	"Erroneous position value", 0
      3  1544				  -	      ERR
      4  1544					      ENDIF
      5  1544		       00		      .byte.b	0
      0  1545					      EVAL8	0
      1  1545				  -	      IF	(0 > 127) || (0 < -128)
      2  1545				  -	      ECHO	"Erroneous position value", 0
      3  1545				  -	      ERR
      4  1545					      ENDIF
      5  1545		       00		      .byte.b	0
      0  1546					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  1546					      EVAL8	0
      1  1546				  -	      IF	(0 > 127) || (0 < -128)
      2  1546				  -	      ECHO	"Erroneous position value", 0
      3  1546				  -	      ERR
      4  1546					      ENDIF
      5  1546		       00		      .byte.b	0
      0  1547					      EVAL8	0
      1  1547				  -	      IF	(0 > 127) || (0 < -128)
      2  1547				  -	      ECHO	"Erroneous position value", 0
      3  1547				  -	      ERR
      4  1547					      ENDIF
      5  1547		       00		      .byte.b	0
      0  1548					      EVAL8	0
      1  1548				  -	      IF	(0 > 127) || (0 < -128)
      2  1548				  -	      ECHO	"Erroneous position value", 0
      3  1548				  -	      ERR
      4  1548					      ENDIF
      5  1548		       00		      .byte.b	0
      0  1549					      EVAL8	0
      1  1549				  -	      IF	(0 > 127) || (0 < -128)
      2  1549				  -	      ECHO	"Erroneous position value", 0
      3  1549				  -	      ERR
      4  1549					      ENDIF
      5  1549		       00		      .byte.b	0
      0  154a					      EVAL8	0
      1  154a				  -	      IF	(0 > 127) || (0 < -128)
      2  154a				  -	      ECHO	"Erroneous position value", 0
      3  154a				  -	      ERR
      4  154a					      ENDIF
      5  154a		       00		      .byte.b	0
      0  154b					      EVAL8	0
      1  154b				  -	      IF	(0 > 127) || (0 < -128)
      2  154b				  -	      ECHO	"Erroneous position value", 0
      3  154b				  -	      ERR
      4  154b					      ENDIF
      5  154b		       00		      .byte.b	0
      0  154c					      EVAL8	0
      1  154c				  -	      IF	(0 > 127) || (0 < -128)
      2  154c				  -	      ECHO	"Erroneous position value", 0
      3  154c				  -	      ERR
      4  154c					      ENDIF
      5  154c		       00		      .byte.b	0
      0  154d					      EVAL8	0
      1  154d				  -	      IF	(0 > 127) || (0 < -128)
      2  154d				  -	      ECHO	"Erroneous position value", 0
      3  154d				  -	      ERR
      4  154d					      ENDIF
      5  154d		       00		      .byte.b	0
      0  154e					      EVAL8	0
      1  154e				  -	      IF	(0 > 127) || (0 < -128)
      2  154e				  -	      ECHO	"Erroneous position value", 0
      3  154e				  -	      ERR
      4  154e					      ENDIF
      5  154e		       00		      .byte.b	0
      0  154f					      EVAL8	0
      1  154f				  -	      IF	(0 > 127) || (0 < -128)
      2  154f				  -	      ECHO	"Erroneous position value", 0
      3  154f				  -	      ERR
      4  154f					      ENDIF
      5  154f		       00		      .byte.b	0
    145  1550
    146  1550
    147  1550							;---------------------------------------------------------------------------------------------------
    148  1550
    149  1550				   PositionalValue_QUEEN
    150  1550
      0  1550					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      0  1550					      EVAL8	-20
      1  1550				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1550				  -	      ECHO	"Erroneous position value", -20
      3  1550				  -	      ERR
      4  1550					      ENDIF
      5  1550		       ec		      .byte.b	-20
      0  1551					      EVAL8	-10
      1  1551				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1551				  -	      ECHO	"Erroneous position value", -10
      3  1551				  -	      ERR
      4  1551					      ENDIF
      5  1551		       f6		      .byte.b	-10
      0  1552					      EVAL8	-5
      1  1552				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1552				  -	      ECHO	"Erroneous position value", -5
      3  1552				  -	      ERR
      4  1552					      ENDIF
      5  1552		       fb		      .byte.b	-5
      0  1553					      EVAL8	-5
      1  1553				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1553				  -	      ECHO	"Erroneous position value", -5
      3  1553				  -	      ERR
      4  1553					      ENDIF
      5  1553		       fb		      .byte.b	-5
      0  1554					      EVAL8	-5
      1  1554				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1554				  -	      ECHO	"Erroneous position value", -5
      3  1554				  -	      ERR
      4  1554					      ENDIF
      5  1554		       fb		      .byte.b	-5
      0  1555					      EVAL8	-10
      1  1555				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1555				  -	      ECHO	"Erroneous position value", -10
      3  1555				  -	      ERR
      4  1555					      ENDIF
      5  1555		       f6		      .byte.b	-10
      0  1556					      EVAL8	-10
      1  1556				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1556				  -	      ECHO	"Erroneous position value", -10
      3  1556				  -	      ERR
      4  1556					      ENDIF
      5  1556		       f6		      .byte.b	-10
      0  1557					      EVAL8	-20
      1  1557				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1557				  -	      ECHO	"Erroneous position value", -20
      3  1557				  -	      ERR
      4  1557					      ENDIF
      5  1557		       ec		      .byte.b	-20
      0  1558					      EVAL8	0
      1  1558				  -	      IF	(0 > 127) || (0 < -128)
      2  1558				  -	      ECHO	"Erroneous position value", 0
      3  1558				  -	      ERR
      4  1558					      ENDIF
      5  1558		       00		      .byte.b	0
      0  1559					      EVAL8	0
      1  1559				  -	      IF	(0 > 127) || (0 < -128)
      2  1559				  -	      ECHO	"Erroneous position value", 0
      3  1559				  -	      ERR
      4  1559					      ENDIF
      5  1559		       00		      .byte.b	0
      0  155a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      0  155a					      EVAL8	-10
      1  155a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  155a				  -	      ECHO	"Erroneous position value", -10
      3  155a				  -	      ERR
      4  155a					      ENDIF
      5  155a		       f6		      .byte.b	-10
      0  155b					      EVAL8	0
      1  155b				  -	      IF	(0 > 127) || (0 < -128)
      2  155b				  -	      ECHO	"Erroneous position value", 0
      3  155b				  -	      ERR
      4  155b					      ENDIF
      5  155b		       00		      .byte.b	0
      0  155c					      EVAL8	5
      1  155c				  -	      IF	(5 > 127) || (5 < -128)
      2  155c				  -	      ECHO	"Erroneous position value", 5
      3  155c				  -	      ERR
      4  155c					      ENDIF
      5  155c		       05		      .byte.b	5
      0  155d					      EVAL8	0
      1  155d				  -	      IF	(0 > 127) || (0 < -128)
      2  155d				  -	      ECHO	"Erroneous position value", 0
      3  155d				  -	      ERR
      4  155d					      ENDIF
      5  155d		       00		      .byte.b	0
      0  155e					      EVAL8	0
      1  155e				  -	      IF	(0 > 127) || (0 < -128)
      2  155e				  -	      ECHO	"Erroneous position value", 0
      3  155e				  -	      ERR
      4  155e					      ENDIF
      5  155e		       00		      .byte.b	0
      0  155f					      EVAL8	0
      1  155f				  -	      IF	(0 > 127) || (0 < -128)
      2  155f				  -	      ECHO	"Erroneous position value", 0
      3  155f				  -	      ERR
      4  155f					      ENDIF
      5  155f		       00		      .byte.b	0
      0  1560					      EVAL8	0
      1  1560				  -	      IF	(0 > 127) || (0 < -128)
      2  1560				  -	      ECHO	"Erroneous position value", 0
      3  1560				  -	      ERR
      4  1560					      ENDIF
      5  1560		       00		      .byte.b	0
      0  1561					      EVAL8	-10
      1  1561				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1561				  -	      ECHO	"Erroneous position value", -10
      3  1561				  -	      ERR
      4  1561					      ENDIF
      5  1561		       f6		      .byte.b	-10
      0  1562					      EVAL8	0
      1  1562				  -	      IF	(0 > 127) || (0 < -128)
      2  1562				  -	      ECHO	"Erroneous position value", 0
      3  1562				  -	      ERR
      4  1562					      ENDIF
      5  1562		       00		      .byte.b	0
      0  1563					      EVAL8	0
      1  1563				  -	      IF	(0 > 127) || (0 < -128)
      2  1563				  -	      ECHO	"Erroneous position value", 0
      3  1563				  -	      ERR
      4  1563					      ENDIF
      5  1563		       00		      .byte.b	0
      0  1564					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      0  1564					      EVAL8	-10
      1  1564				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1564				  -	      ECHO	"Erroneous position value", -10
      3  1564				  -	      ERR
      4  1564					      ENDIF
      5  1564		       f6		      .byte.b	-10
      0  1565					      EVAL8	5
      1  1565				  -	      IF	(5 > 127) || (5 < -128)
      2  1565				  -	      ECHO	"Erroneous position value", 5
      3  1565				  -	      ERR
      4  1565					      ENDIF
      5  1565		       05		      .byte.b	5
      0  1566					      EVAL8	5
      1  1566				  -	      IF	(5 > 127) || (5 < -128)
      2  1566				  -	      ECHO	"Erroneous position value", 5
      3  1566				  -	      ERR
      4  1566					      ENDIF
      5  1566		       05		      .byte.b	5
      0  1567					      EVAL8	5
      1  1567				  -	      IF	(5 > 127) || (5 < -128)
      2  1567				  -	      ECHO	"Erroneous position value", 5
      3  1567				  -	      ERR
      4  1567					      ENDIF
      5  1567		       05		      .byte.b	5
      0  1568					      EVAL8	5
      1  1568				  -	      IF	(5 > 127) || (5 < -128)
      2  1568				  -	      ECHO	"Erroneous position value", 5
      3  1568				  -	      ERR
      4  1568					      ENDIF
      5  1568		       05		      .byte.b	5
      0  1569					      EVAL8	25
      1  1569				  -	      IF	(25 > 127) || (25 < -128)
      2  1569				  -	      ECHO	"Erroneous position value", 25
      3  1569				  -	      ERR
      4  1569					      ENDIF
      5  1569		       19		      .byte.b	25
      0  156a					      EVAL8	0
      1  156a				  -	      IF	(0 > 127) || (0 < -128)
      2  156a				  -	      ECHO	"Erroneous position value", 0
      3  156a				  -	      ERR
      4  156a					      ENDIF
      5  156a		       00		      .byte.b	0
      0  156b					      EVAL8	-10
      1  156b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  156b				  -	      ECHO	"Erroneous position value", -10
      3  156b				  -	      ERR
      4  156b					      ENDIF
      5  156b		       f6		      .byte.b	-10
      0  156c					      EVAL8	0
      1  156c				  -	      IF	(0 > 127) || (0 < -128)
      2  156c				  -	      ECHO	"Erroneous position value", 0
      3  156c				  -	      ERR
      4  156c					      ENDIF
      5  156c		       00		      .byte.b	0
      0  156d					      EVAL8	0
      1  156d				  -	      IF	(0 > 127) || (0 < -128)
      2  156d				  -	      ECHO	"Erroneous position value", 0
      3  156d				  -	      ERR
      4  156d					      ENDIF
      5  156d		       00		      .byte.b	0
      0  156e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      0  156e					      EVAL8	-10
      1  156e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  156e				  -	      ECHO	"Erroneous position value", -10
      3  156e				  -	      ERR
      4  156e					      ENDIF
      5  156e		       f6		      .byte.b	-10
      0  156f					      EVAL8	0
      1  156f				  -	      IF	(0 > 127) || (0 < -128)
      2  156f				  -	      ECHO	"Erroneous position value", 0
      3  156f				  -	      ERR
      4  156f					      ENDIF
      5  156f		       00		      .byte.b	0
      0  1570					      EVAL8	5
      1  1570				  -	      IF	(5 > 127) || (5 < -128)
      2  1570				  -	      ECHO	"Erroneous position value", 5
      3  1570				  -	      ERR
      4  1570					      ENDIF
      5  1570		       05		      .byte.b	5
      0  1571					      EVAL8	25
      1  1571				  -	      IF	(25 > 127) || (25 < -128)
      2  1571				  -	      ECHO	"Erroneous position value", 25
      3  1571				  -	      ERR
      4  1571					      ENDIF
      5  1571		       19		      .byte.b	25
      0  1572					      EVAL8	25
      1  1572				  -	      IF	(25 > 127) || (25 < -128)
      2  1572				  -	      ECHO	"Erroneous position value", 25
      3  1572				  -	      ERR
      4  1572					      ENDIF
      5  1572		       19		      .byte.b	25
      0  1573					      EVAL8	25
      1  1573				  -	      IF	(25 > 127) || (25 < -128)
      2  1573				  -	      ECHO	"Erroneous position value", 25
      3  1573				  -	      ERR
      4  1573					      ENDIF
      5  1573		       19		      .byte.b	25
      0  1574					      EVAL8	0
      1  1574				  -	      IF	(0 > 127) || (0 < -128)
      2  1574				  -	      ECHO	"Erroneous position value", 0
      3  1574				  -	      ERR
      4  1574					      ENDIF
      5  1574		       00		      .byte.b	0
      0  1575					      EVAL8	-10
      1  1575				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1575				  -	      ECHO	"Erroneous position value", -10
      3  1575				  -	      ERR
      4  1575					      ENDIF
      5  1575		       f6		      .byte.b	-10
      0  1576					      EVAL8	0
      1  1576				  -	      IF	(0 > 127) || (0 < -128)
      2  1576				  -	      ECHO	"Erroneous position value", 0
      3  1576				  -	      ERR
      4  1576					      ENDIF
      5  1576		       00		      .byte.b	0
      0  1577					      EVAL8	0
      1  1577				  -	      IF	(0 > 127) || (0 < -128)
      2  1577				  -	      ECHO	"Erroneous position value", 0
      3  1577				  -	      ERR
      4  1577					      ENDIF
      5  1577		       00		      .byte.b	0
      0  1578					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      0  1578					      EVAL8	-5
      1  1578				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1578				  -	      ECHO	"Erroneous position value", -5
      3  1578				  -	      ERR
      4  1578					      ENDIF
      5  1578		       fb		      .byte.b	-5
      0  1579					      EVAL8	0
      1  1579				  -	      IF	(0 > 127) || (0 < -128)
      2  1579				  -	      ECHO	"Erroneous position value", 0
      3  1579				  -	      ERR
      4  1579					      ENDIF
      5  1579		       00		      .byte.b	0
      0  157a					      EVAL8	15
      1  157a				  -	      IF	(15 > 127) || (15 < -128)
      2  157a				  -	      ECHO	"Erroneous position value", 15
      3  157a				  -	      ERR
      4  157a					      ENDIF
      5  157a		       0f		      .byte.b	15
      0  157b					      EVAL8	55
      1  157b				  -	      IF	(55 > 127) || (55 < -128)
      2  157b				  -	      ECHO	"Erroneous position value", 55
      3  157b				  -	      ERR
      4  157b					      ENDIF
      5  157b		       37		      .byte.b	55
      0  157c					      EVAL8	55
      1  157c				  -	      IF	(55 > 127) || (55 < -128)
      2  157c				  -	      ECHO	"Erroneous position value", 55
      3  157c				  -	      ERR
      4  157c					      ENDIF
      5  157c		       37		      .byte.b	55
      0  157d					      EVAL8	55
      1  157d				  -	      IF	(55 > 127) || (55 < -128)
      2  157d				  -	      ECHO	"Erroneous position value", 55
      3  157d				  -	      ERR
      4  157d					      ENDIF
      5  157d		       37		      .byte.b	55
      0  157e					      EVAL8	0
      1  157e				  -	      IF	(0 > 127) || (0 < -128)
      2  157e				  -	      ECHO	"Erroneous position value", 0
      3  157e				  -	      ERR
      4  157e					      ENDIF
      5  157e		       00		      .byte.b	0
      0  157f					      EVAL8	-5
      1  157f				  -	      IF	(-5 > 127) || (-5 < -128)
      2  157f				  -	      ECHO	"Erroneous position value", -5
      3  157f				  -	      ERR
      4  157f					      ENDIF
      5  157f		       fb		      .byte.b	-5
      0  1580					      EVAL8	0
      1  1580				  -	      IF	(0 > 127) || (0 < -128)
      2  1580				  -	      ECHO	"Erroneous position value", 0
      3  1580				  -	      ERR
      4  1580					      ENDIF
      5  1580		       00		      .byte.b	0
      0  1581					      EVAL8	0
      1  1581				  -	      IF	(0 > 127) || (0 < -128)
      2  1581				  -	      ECHO	"Erroneous position value", 0
      3  1581				  -	      ERR
      4  1581					      ENDIF
      5  1581		       00		      .byte.b	0
      0  1582					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      0  1582					      EVAL8	-10
      1  1582				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1582				  -	      ECHO	"Erroneous position value", -10
      3  1582				  -	      ERR
      4  1582					      ENDIF
      5  1582		       f6		      .byte.b	-10
      0  1583					      EVAL8	0
      1  1583				  -	      IF	(0 > 127) || (0 < -128)
      2  1583				  -	      ECHO	"Erroneous position value", 0
      3  1583				  -	      ERR
      4  1583					      ENDIF
      5  1583		       00		      .byte.b	0
      0  1584					      EVAL8	25
      1  1584				  -	      IF	(25 > 127) || (25 < -128)
      2  1584				  -	      ECHO	"Erroneous position value", 25
      3  1584				  -	      ERR
      4  1584					      ENDIF
      5  1584		       19		      .byte.b	25
      0  1585					      EVAL8	75
      1  1585				  -	      IF	(75 > 127) || (75 < -128)
      2  1585				  -	      ECHO	"Erroneous position value", 75
      3  1585				  -	      ERR
      4  1585					      ENDIF
      5  1585		       4b		      .byte.b	75
      0  1586					      EVAL8	75
      1  1586				  -	      IF	(75 > 127) || (75 < -128)
      2  1586				  -	      ECHO	"Erroneous position value", 75
      3  1586				  -	      ERR
      4  1586					      ENDIF
      5  1586		       4b		      .byte.b	75
      0  1587					      EVAL8	75
      1  1587				  -	      IF	(75 > 127) || (75 < -128)
      2  1587				  -	      ECHO	"Erroneous position value", 75
      3  1587				  -	      ERR
      4  1587					      ENDIF
      5  1587		       4b		      .byte.b	75
      0  1588					      EVAL8	0
      1  1588				  -	      IF	(0 > 127) || (0 < -128)
      2  1588				  -	      ECHO	"Erroneous position value", 0
      3  1588				  -	      ERR
      4  1588					      ENDIF
      5  1588		       00		      .byte.b	0
      0  1589					      EVAL8	-10
      1  1589				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1589				  -	      ECHO	"Erroneous position value", -10
      3  1589				  -	      ERR
      4  1589					      ENDIF
      5  1589		       f6		      .byte.b	-10
      0  158a					      EVAL8	0
      1  158a				  -	      IF	(0 > 127) || (0 < -128)
      2  158a				  -	      ECHO	"Erroneous position value", 0
      3  158a				  -	      ERR
      4  158a					      ENDIF
      5  158a		       00		      .byte.b	0
      0  158b					      EVAL8	0
      1  158b				  -	      IF	(0 > 127) || (0 < -128)
      2  158b				  -	      ECHO	"Erroneous position value", 0
      3  158b				  -	      ERR
      4  158b					      ENDIF
      5  158b		       00		      .byte.b	0
      0  158c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  158c					      EVAL8	-10
      1  158c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  158c				  -	      ECHO	"Erroneous position value", -10
      3  158c				  -	      ERR
      4  158c					      ENDIF
      5  158c		       f6		      .byte.b	-10
      0  158d					      EVAL8	0
      1  158d				  -	      IF	(0 > 127) || (0 < -128)
      2  158d				  -	      ECHO	"Erroneous position value", 0
      3  158d				  -	      ERR
      4  158d					      ENDIF
      5  158d		       00		      .byte.b	0
      0  158e					      EVAL8	0
      1  158e				  -	      IF	(0 > 127) || (0 < -128)
      2  158e				  -	      ECHO	"Erroneous position value", 0
      3  158e				  -	      ERR
      4  158e					      ENDIF
      5  158e		       00		      .byte.b	0
      0  158f					      EVAL8	0
      1  158f				  -	      IF	(0 > 127) || (0 < -128)
      2  158f				  -	      ECHO	"Erroneous position value", 0
      3  158f				  -	      ERR
      4  158f					      ENDIF
      5  158f		       00		      .byte.b	0
      0  1590					      EVAL8	0
      1  1590				  -	      IF	(0 > 127) || (0 < -128)
      2  1590				  -	      ECHO	"Erroneous position value", 0
      3  1590				  -	      ERR
      4  1590					      ENDIF
      5  1590		       00		      .byte.b	0
      0  1591					      EVAL8	0
      1  1591				  -	      IF	(0 > 127) || (0 < -128)
      2  1591				  -	      ECHO	"Erroneous position value", 0
      3  1591				  -	      ERR
      4  1591					      ENDIF
      5  1591		       00		      .byte.b	0
      0  1592					      EVAL8	0
      1  1592				  -	      IF	(0 > 127) || (0 < -128)
      2  1592				  -	      ECHO	"Erroneous position value", 0
      3  1592				  -	      ERR
      4  1592					      ENDIF
      5  1592		       00		      .byte.b	0
      0  1593					      EVAL8	-10
      1  1593				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1593				  -	      ECHO	"Erroneous position value", -10
      3  1593				  -	      ERR
      4  1593					      ENDIF
      5  1593		       f6		      .byte.b	-10
      0  1594					      EVAL8	0
      1  1594				  -	      IF	(0 > 127) || (0 < -128)
      2  1594				  -	      ECHO	"Erroneous position value", 0
      3  1594				  -	      ERR
      4  1594					      ENDIF
      5  1594		       00		      .byte.b	0
      0  1595					      EVAL8	0
      1  1595				  -	      IF	(0 > 127) || (0 < -128)
      2  1595				  -	      ECHO	"Erroneous position value", 0
      3  1595				  -	      ERR
      4  1595					      ENDIF
      5  1595		       00		      .byte.b	0
      0  1596					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      0  1596					      EVAL8	-20
      1  1596				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1596				  -	      ECHO	"Erroneous position value", -20
      3  1596				  -	      ERR
      4  1596					      ENDIF
      5  1596		       ec		      .byte.b	-20
      0  1597					      EVAL8	-10
      1  1597				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1597				  -	      ECHO	"Erroneous position value", -10
      3  1597				  -	      ERR
      4  1597					      ENDIF
      5  1597		       f6		      .byte.b	-10
      0  1598					      EVAL8	-10
      1  1598				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1598				  -	      ECHO	"Erroneous position value", -10
      3  1598				  -	      ERR
      4  1598					      ENDIF
      5  1598		       f6		      .byte.b	-10
      0  1599					      EVAL8	-5
      1  1599				  -	      IF	(-5 > 127) || (-5 < -128)
      2  1599				  -	      ECHO	"Erroneous position value", -5
      3  1599				  -	      ERR
      4  1599					      ENDIF
      5  1599		       fb		      .byte.b	-5
      0  159a					      EVAL8	-5
      1  159a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  159a				  -	      ECHO	"Erroneous position value", -5
      3  159a				  -	      ERR
      4  159a					      ENDIF
      5  159a		       fb		      .byte.b	-5
      0  159b					      EVAL8	-10
      1  159b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  159b				  -	      ECHO	"Erroneous position value", -10
      3  159b				  -	      ERR
      4  159b					      ENDIF
      5  159b		       f6		      .byte.b	-10
      0  159c					      EVAL8	-10
      1  159c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  159c				  -	      ECHO	"Erroneous position value", -10
      3  159c				  -	      ERR
      4  159c					      ENDIF
      5  159c		       f6		      .byte.b	-10
      0  159d					      EVAL8	-20
      1  159d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  159d				  -	      ECHO	"Erroneous position value", -20
      3  159d				  -	      ERR
      4  159d					      ENDIF
      5  159d		       ec		      .byte.b	-20
      0  159e					      EVAL8	0
      1  159e				  -	      IF	(0 > 127) || (0 < -128)
      2  159e				  -	      ECHO	"Erroneous position value", 0
      3  159e				  -	      ERR
      4  159e					      ENDIF
      5  159e		       00		      .byte.b	0
      0  159f					      EVAL8	0
      1  159f				  -	      IF	(0 > 127) || (0 < -128)
      2  159f				  -	      ECHO	"Erroneous position value", 0
      3  159f				  -	      ERR
      4  159f					      ENDIF
      5  159f		       00		      .byte.b	0
    159  15a0
    160  15a0
    161  15a0							;---------------------------------------------------------------------------------------------------
    162  15a0
    163  15a0				   PositionalValue_KING_MIDGAME
    164  15a0
      0  15a0					      PVAL	0, 0, 40, -60, -30, 0, 50, 0
      0  15a0					      EVAL8	0
      1  15a0				  -	      IF	(0 > 127) || (0 < -128)
      2  15a0				  -	      ECHO	"Erroneous position value", 0
      3  15a0				  -	      ERR
      4  15a0					      ENDIF
      5  15a0		       00		      .byte.b	0
      0  15a1					      EVAL8	0
      1  15a1				  -	      IF	(0 > 127) || (0 < -128)
      2  15a1				  -	      ECHO	"Erroneous position value", 0
      3  15a1				  -	      ERR
      4  15a1					      ENDIF
      5  15a1		       00		      .byte.b	0
      0  15a2					      EVAL8	40
      1  15a2				  -	      IF	(40 > 127) || (40 < -128)
      2  15a2				  -	      ECHO	"Erroneous position value", 40
      3  15a2				  -	      ERR
      4  15a2					      ENDIF
      5  15a2		       28		      .byte.b	40
      0  15a3					      EVAL8	-60
      1  15a3				  -	      IF	(-60 > 127) || (-60 < -128)
      2  15a3				  -	      ECHO	"Erroneous position value", -60
      3  15a3				  -	      ERR
      4  15a3					      ENDIF
      5  15a3		       c4		      .byte.b	-60
      0  15a4					      EVAL8	-30
      1  15a4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15a4				  -	      ECHO	"Erroneous position value", -30
      3  15a4				  -	      ERR
      4  15a4					      ENDIF
      5  15a4		       e2		      .byte.b	-30
      0  15a5					      EVAL8	0
      1  15a5				  -	      IF	(0 > 127) || (0 < -128)
      2  15a5				  -	      ECHO	"Erroneous position value", 0
      3  15a5				  -	      ERR
      4  15a5					      ENDIF
      5  15a5		       00		      .byte.b	0
      0  15a6					      EVAL8	50
      1  15a6				  -	      IF	(50 > 127) || (50 < -128)
      2  15a6				  -	      ECHO	"Erroneous position value", 50
      3  15a6				  -	      ERR
      4  15a6					      ENDIF
      5  15a6		       32		      .byte.b	50
      0  15a7					      EVAL8	0
      1  15a7				  -	      IF	(0 > 127) || (0 < -128)
      2  15a7				  -	      ECHO	"Erroneous position value", 0
      3  15a7				  -	      ERR
      4  15a7					      ENDIF
      5  15a7		       00		      .byte.b	0
      0  15a8					      EVAL8	0
      1  15a8				  -	      IF	(0 > 127) || (0 < -128)
      2  15a8				  -	      ECHO	"Erroneous position value", 0
      3  15a8				  -	      ERR
      4  15a8					      ENDIF
      5  15a8		       00		      .byte.b	0
      0  15a9					      EVAL8	0
      1  15a9				  -	      IF	(0 > 127) || (0 < -128)
      2  15a9				  -	      ECHO	"Erroneous position value", 0
      3  15a9				  -	      ERR
      4  15a9					      ENDIF
      5  15a9		       00		      .byte.b	0
      0  15aa					      PVAL	0, 0, -80, -80, -70, -70, 0, 0
      0  15aa					      EVAL8	0
      1  15aa				  -	      IF	(0 > 127) || (0 < -128)
      2  15aa				  -	      ECHO	"Erroneous position value", 0
      3  15aa				  -	      ERR
      4  15aa					      ENDIF
      5  15aa		       00		      .byte.b	0
      0  15ab					      EVAL8	0
      1  15ab				  -	      IF	(0 > 127) || (0 < -128)
      2  15ab				  -	      ECHO	"Erroneous position value", 0
      3  15ab				  -	      ERR
      4  15ab					      ENDIF
      5  15ab		       00		      .byte.b	0
      0  15ac					      EVAL8	-80
      1  15ac				  -	      IF	(-80 > 127) || (-80 < -128)
      2  15ac				  -	      ECHO	"Erroneous position value", -80
      3  15ac				  -	      ERR
      4  15ac					      ENDIF
      5  15ac		       b0		      .byte.b	-80
      0  15ad					      EVAL8	-80
      1  15ad				  -	      IF	(-80 > 127) || (-80 < -128)
      2  15ad				  -	      ECHO	"Erroneous position value", -80
      3  15ad				  -	      ERR
      4  15ad					      ENDIF
      5  15ad		       b0		      .byte.b	-80
      0  15ae					      EVAL8	-70
      1  15ae				  -	      IF	(-70 > 127) || (-70 < -128)
      2  15ae				  -	      ECHO	"Erroneous position value", -70
      3  15ae				  -	      ERR
      4  15ae					      ENDIF
      5  15ae		       ba		      .byte.b	-70
      0  15af					      EVAL8	-70
      1  15af				  -	      IF	(-70 > 127) || (-70 < -128)
      2  15af				  -	      ECHO	"Erroneous position value", -70
      3  15af				  -	      ERR
      4  15af					      ENDIF
      5  15af		       ba		      .byte.b	-70
      0  15b0					      EVAL8	0
      1  15b0				  -	      IF	(0 > 127) || (0 < -128)
      2  15b0				  -	      ECHO	"Erroneous position value", 0
      3  15b0				  -	      ERR
      4  15b0					      ENDIF
      5  15b0		       00		      .byte.b	0
      0  15b1					      EVAL8	0
      1  15b1				  -	      IF	(0 > 127) || (0 < -128)
      2  15b1				  -	      ECHO	"Erroneous position value", 0
      3  15b1				  -	      ERR
      4  15b1					      ENDIF
      5  15b1		       00		      .byte.b	0
      0  15b2					      EVAL8	0
      1  15b2				  -	      IF	(0 > 127) || (0 < -128)
      2  15b2				  -	      ECHO	"Erroneous position value", 0
      3  15b2				  -	      ERR
      4  15b2					      ENDIF
      5  15b2		       00		      .byte.b	0
      0  15b3					      EVAL8	0
      1  15b3				  -	      IF	(0 > 127) || (0 < -128)
      2  15b3				  -	      ECHO	"Erroneous position value", 0
      3  15b3				  -	      ERR
      4  15b3					      ENDIF
      5  15b3		       00		      .byte.b	0
      0  15b4					      PVAL	-10, -20, -20, -20, -30, -20, -20, -10
      0  15b4					      EVAL8	-10
      1  15b4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  15b4				  -	      ECHO	"Erroneous position value", -10
      3  15b4				  -	      ERR
      4  15b4					      ENDIF
      5  15b4		       f6		      .byte.b	-10
      0  15b5					      EVAL8	-20
      1  15b5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15b5				  -	      ECHO	"Erroneous position value", -20
      3  15b5				  -	      ERR
      4  15b5					      ENDIF
      5  15b5		       ec		      .byte.b	-20
      0  15b6					      EVAL8	-20
      1  15b6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15b6				  -	      ECHO	"Erroneous position value", -20
      3  15b6				  -	      ERR
      4  15b6					      ENDIF
      5  15b6		       ec		      .byte.b	-20
      0  15b7					      EVAL8	-20
      1  15b7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15b7				  -	      ECHO	"Erroneous position value", -20
      3  15b7				  -	      ERR
      4  15b7					      ENDIF
      5  15b7		       ec		      .byte.b	-20
      0  15b8					      EVAL8	-30
      1  15b8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15b8				  -	      ECHO	"Erroneous position value", -30
      3  15b8				  -	      ERR
      4  15b8					      ENDIF
      5  15b8		       e2		      .byte.b	-30
      0  15b9					      EVAL8	-20
      1  15b9				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15b9				  -	      ECHO	"Erroneous position value", -20
      3  15b9				  -	      ERR
      4  15b9					      ENDIF
      5  15b9		       ec		      .byte.b	-20
      0  15ba					      EVAL8	-20
      1  15ba				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15ba				  -	      ECHO	"Erroneous position value", -20
      3  15ba				  -	      ERR
      4  15ba					      ENDIF
      5  15ba		       ec		      .byte.b	-20
      0  15bb					      EVAL8	-10
      1  15bb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  15bb				  -	      ECHO	"Erroneous position value", -10
      3  15bb				  -	      ERR
      4  15bb					      ENDIF
      5  15bb		       f6		      .byte.b	-10
      0  15bc					      EVAL8	0
      1  15bc				  -	      IF	(0 > 127) || (0 < -128)
      2  15bc				  -	      ECHO	"Erroneous position value", 0
      3  15bc				  -	      ERR
      4  15bc					      ENDIF
      5  15bc		       00		      .byte.b	0
      0  15bd					      EVAL8	0
      1  15bd				  -	      IF	(0 > 127) || (0 < -128)
      2  15bd				  -	      ECHO	"Erroneous position value", 0
      3  15bd				  -	      ERR
      4  15bd					      ENDIF
      5  15bd		       00		      .byte.b	0
      0  15be					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      0  15be					      EVAL8	-20
      1  15be				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15be				  -	      ECHO	"Erroneous position value", -20
      3  15be				  -	      ERR
      4  15be					      ENDIF
      5  15be		       ec		      .byte.b	-20
      0  15bf					      EVAL8	-30
      1  15bf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15bf				  -	      ECHO	"Erroneous position value", -30
      3  15bf				  -	      ERR
      4  15bf					      ENDIF
      5  15bf		       e2		      .byte.b	-30
      0  15c0					      EVAL8	-30
      1  15c0				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15c0				  -	      ECHO	"Erroneous position value", -30
      3  15c0				  -	      ERR
      4  15c0					      ENDIF
      5  15c0		       e2		      .byte.b	-30
      0  15c1					      EVAL8	-40
      1  15c1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15c1				  -	      ECHO	"Erroneous position value", -40
      3  15c1				  -	      ERR
      4  15c1					      ENDIF
      5  15c1		       d8		      .byte.b	-40
      0  15c2					      EVAL8	-40
      1  15c2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15c2				  -	      ECHO	"Erroneous position value", -40
      3  15c2				  -	      ERR
      4  15c2					      ENDIF
      5  15c2		       d8		      .byte.b	-40
      0  15c3					      EVAL8	-30
      1  15c3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15c3				  -	      ECHO	"Erroneous position value", -30
      3  15c3				  -	      ERR
      4  15c3					      ENDIF
      5  15c3		       e2		      .byte.b	-30
      0  15c4					      EVAL8	-30
      1  15c4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15c4				  -	      ECHO	"Erroneous position value", -30
      3  15c4				  -	      ERR
      4  15c4					      ENDIF
      5  15c4		       e2		      .byte.b	-30
      0  15c5					      EVAL8	-20
      1  15c5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  15c5				  -	      ECHO	"Erroneous position value", -20
      3  15c5				  -	      ERR
      4  15c5					      ENDIF
      5  15c5		       ec		      .byte.b	-20
      0  15c6					      EVAL8	0
      1  15c6				  -	      IF	(0 > 127) || (0 < -128)
      2  15c6				  -	      ECHO	"Erroneous position value", 0
      3  15c6				  -	      ERR
      4  15c6					      ENDIF
      5  15c6		       00		      .byte.b	0
      0  15c7					      EVAL8	0
      1  15c7				  -	      IF	(0 > 127) || (0 < -128)
      2  15c7				  -	      ECHO	"Erroneous position value", 0
      3  15c7				  -	      ERR
      4  15c7					      ENDIF
      5  15c7		       00		      .byte.b	0
      0  15c8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  15c8					      EVAL8	-30
      1  15c8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15c8				  -	      ECHO	"Erroneous position value", -30
      3  15c8				  -	      ERR
      4  15c8					      ENDIF
      5  15c8		       e2		      .byte.b	-30
      0  15c9					      EVAL8	-40
      1  15c9				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15c9				  -	      ECHO	"Erroneous position value", -40
      3  15c9				  -	      ERR
      4  15c9					      ENDIF
      5  15c9		       d8		      .byte.b	-40
      0  15ca					      EVAL8	-40
      1  15ca				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15ca				  -	      ECHO	"Erroneous position value", -40
      3  15ca				  -	      ERR
      4  15ca					      ENDIF
      5  15ca		       d8		      .byte.b	-40
      0  15cb					      EVAL8	-50
      1  15cb				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15cb				  -	      ECHO	"Erroneous position value", -50
      3  15cb				  -	      ERR
      4  15cb					      ENDIF
      5  15cb		       ce		      .byte.b	-50
      0  15cc					      EVAL8	-50
      1  15cc				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15cc				  -	      ECHO	"Erroneous position value", -50
      3  15cc				  -	      ERR
      4  15cc					      ENDIF
      5  15cc		       ce		      .byte.b	-50
      0  15cd					      EVAL8	-40
      1  15cd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15cd				  -	      ECHO	"Erroneous position value", -40
      3  15cd				  -	      ERR
      4  15cd					      ENDIF
      5  15cd		       d8		      .byte.b	-40
      0  15ce					      EVAL8	-40
      1  15ce				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15ce				  -	      ECHO	"Erroneous position value", -40
      3  15ce				  -	      ERR
      4  15ce					      ENDIF
      5  15ce		       d8		      .byte.b	-40
      0  15cf					      EVAL8	-30
      1  15cf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15cf				  -	      ECHO	"Erroneous position value", -30
      3  15cf				  -	      ERR
      4  15cf					      ENDIF
      5  15cf		       e2		      .byte.b	-30
      0  15d0					      EVAL8	0
      1  15d0				  -	      IF	(0 > 127) || (0 < -128)
      2  15d0				  -	      ECHO	"Erroneous position value", 0
      3  15d0				  -	      ERR
      4  15d0					      ENDIF
      5  15d0		       00		      .byte.b	0
      0  15d1					      EVAL8	0
      1  15d1				  -	      IF	(0 > 127) || (0 < -128)
      2  15d1				  -	      ECHO	"Erroneous position value", 0
      3  15d1				  -	      ERR
      4  15d1					      ENDIF
      5  15d1		       00		      .byte.b	0
      0  15d2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  15d2					      EVAL8	-30
      1  15d2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15d2				  -	      ECHO	"Erroneous position value", -30
      3  15d2				  -	      ERR
      4  15d2					      ENDIF
      5  15d2		       e2		      .byte.b	-30
      0  15d3					      EVAL8	-40
      1  15d3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15d3				  -	      ECHO	"Erroneous position value", -40
      3  15d3				  -	      ERR
      4  15d3					      ENDIF
      5  15d3		       d8		      .byte.b	-40
      0  15d4					      EVAL8	-40
      1  15d4				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15d4				  -	      ECHO	"Erroneous position value", -40
      3  15d4				  -	      ERR
      4  15d4					      ENDIF
      5  15d4		       d8		      .byte.b	-40
      0  15d5					      EVAL8	-50
      1  15d5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15d5				  -	      ECHO	"Erroneous position value", -50
      3  15d5				  -	      ERR
      4  15d5					      ENDIF
      5  15d5		       ce		      .byte.b	-50
      0  15d6					      EVAL8	-50
      1  15d6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15d6				  -	      ECHO	"Erroneous position value", -50
      3  15d6				  -	      ERR
      4  15d6					      ENDIF
      5  15d6		       ce		      .byte.b	-50
      0  15d7					      EVAL8	-40
      1  15d7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15d7				  -	      ECHO	"Erroneous position value", -40
      3  15d7				  -	      ERR
      4  15d7					      ENDIF
      5  15d7		       d8		      .byte.b	-40
      0  15d8					      EVAL8	-40
      1  15d8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15d8				  -	      ECHO	"Erroneous position value", -40
      3  15d8				  -	      ERR
      4  15d8					      ENDIF
      5  15d8		       d8		      .byte.b	-40
      0  15d9					      EVAL8	-30
      1  15d9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15d9				  -	      ECHO	"Erroneous position value", -30
      3  15d9				  -	      ERR
      4  15d9					      ENDIF
      5  15d9		       e2		      .byte.b	-30
      0  15da					      EVAL8	0
      1  15da				  -	      IF	(0 > 127) || (0 < -128)
      2  15da				  -	      ECHO	"Erroneous position value", 0
      3  15da				  -	      ERR
      4  15da					      ENDIF
      5  15da		       00		      .byte.b	0
      0  15db					      EVAL8	0
      1  15db				  -	      IF	(0 > 127) || (0 < -128)
      2  15db				  -	      ECHO	"Erroneous position value", 0
      3  15db				  -	      ERR
      4  15db					      ENDIF
      5  15db		       00		      .byte.b	0
      0  15dc					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  15dc					      EVAL8	-30
      1  15dc				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15dc				  -	      ECHO	"Erroneous position value", -30
      3  15dc				  -	      ERR
      4  15dc					      ENDIF
      5  15dc		       e2		      .byte.b	-30
      0  15dd					      EVAL8	-40
      1  15dd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15dd				  -	      ECHO	"Erroneous position value", -40
      3  15dd				  -	      ERR
      4  15dd					      ENDIF
      5  15dd		       d8		      .byte.b	-40
      0  15de					      EVAL8	-40
      1  15de				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15de				  -	      ECHO	"Erroneous position value", -40
      3  15de				  -	      ERR
      4  15de					      ENDIF
      5  15de		       d8		      .byte.b	-40
      0  15df					      EVAL8	-50
      1  15df				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15df				  -	      ECHO	"Erroneous position value", -50
      3  15df				  -	      ERR
      4  15df					      ENDIF
      5  15df		       ce		      .byte.b	-50
      0  15e0					      EVAL8	-50
      1  15e0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15e0				  -	      ECHO	"Erroneous position value", -50
      3  15e0				  -	      ERR
      4  15e0					      ENDIF
      5  15e0		       ce		      .byte.b	-50
      0  15e1					      EVAL8	-40
      1  15e1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15e1				  -	      ECHO	"Erroneous position value", -40
      3  15e1				  -	      ERR
      4  15e1					      ENDIF
      5  15e1		       d8		      .byte.b	-40
      0  15e2					      EVAL8	-40
      1  15e2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15e2				  -	      ECHO	"Erroneous position value", -40
      3  15e2				  -	      ERR
      4  15e2					      ENDIF
      5  15e2		       d8		      .byte.b	-40
      0  15e3					      EVAL8	-30
      1  15e3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15e3				  -	      ECHO	"Erroneous position value", -30
      3  15e3				  -	      ERR
      4  15e3					      ENDIF
      5  15e3		       e2		      .byte.b	-30
      0  15e4					      EVAL8	0
      1  15e4				  -	      IF	(0 > 127) || (0 < -128)
      2  15e4				  -	      ECHO	"Erroneous position value", 0
      3  15e4				  -	      ERR
      4  15e4					      ENDIF
      5  15e4		       00		      .byte.b	0
      0  15e5					      EVAL8	0
      1  15e5				  -	      IF	(0 > 127) || (0 < -128)
      2  15e5				  -	      ECHO	"Erroneous position value", 0
      3  15e5				  -	      ERR
      4  15e5					      ENDIF
      5  15e5		       00		      .byte.b	0
      0  15e6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  15e6					      EVAL8	-30
      1  15e6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15e6				  -	      ECHO	"Erroneous position value", -30
      3  15e6				  -	      ERR
      4  15e6					      ENDIF
      5  15e6		       e2		      .byte.b	-30
      0  15e7					      EVAL8	-40
      1  15e7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15e7				  -	      ECHO	"Erroneous position value", -40
      3  15e7				  -	      ERR
      4  15e7					      ENDIF
      5  15e7		       d8		      .byte.b	-40
      0  15e8					      EVAL8	-40
      1  15e8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15e8				  -	      ECHO	"Erroneous position value", -40
      3  15e8				  -	      ERR
      4  15e8					      ENDIF
      5  15e8		       d8		      .byte.b	-40
      0  15e9					      EVAL8	-50
      1  15e9				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15e9				  -	      ECHO	"Erroneous position value", -50
      3  15e9				  -	      ERR
      4  15e9					      ENDIF
      5  15e9		       ce		      .byte.b	-50
      0  15ea					      EVAL8	-50
      1  15ea				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15ea				  -	      ECHO	"Erroneous position value", -50
      3  15ea				  -	      ERR
      4  15ea					      ENDIF
      5  15ea		       ce		      .byte.b	-50
      0  15eb					      EVAL8	-40
      1  15eb				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15eb				  -	      ECHO	"Erroneous position value", -40
      3  15eb				  -	      ERR
      4  15eb					      ENDIF
      5  15eb		       d8		      .byte.b	-40
      0  15ec					      EVAL8	-40
      1  15ec				  -	      IF	(-40 > 127) || (-40 < -128)
      2  15ec				  -	      ECHO	"Erroneous position value", -40
      3  15ec				  -	      ERR
      4  15ec					      ENDIF
      5  15ec		       d8		      .byte.b	-40
      0  15ed					      EVAL8	-30
      1  15ed				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15ed				  -	      ECHO	"Erroneous position value", -30
      3  15ed				  -	      ERR
      4  15ed					      ENDIF
      5  15ed		       e2		      .byte.b	-30
      0  15ee					      EVAL8	0
      1  15ee				  -	      IF	(0 > 127) || (0 < -128)
      2  15ee				  -	      ECHO	"Erroneous position value", 0
      3  15ee				  -	      ERR
      4  15ee					      ENDIF
      5  15ee		       00		      .byte.b	0
      0  15ef					      EVAL8	0
      1  15ef				  -	      IF	(0 > 127) || (0 < -128)
      2  15ef				  -	      ECHO	"Erroneous position value", 0
      3  15ef				  -	      ERR
      4  15ef					      ENDIF
      5  15ef		       00		      .byte.b	0
    173  15f0
    174  15f0
    175  15f0							;---------------------------------------------------------------------------------------------------
    176  15f0
    177  15f0				   PositionalValue_KING_ENDGAME
    178  15f0
      0  15f0					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      0  15f0					      EVAL8	-50
      1  15f0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15f0				  -	      ECHO	"Erroneous position value", -50
      3  15f0				  -	      ERR
      4  15f0					      ENDIF
      5  15f0		       ce		      .byte.b	-50
      0  15f1					      EVAL8	-30
      1  15f1				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f1				  -	      ECHO	"Erroneous position value", -30
      3  15f1				  -	      ERR
      4  15f1					      ENDIF
      5  15f1		       e2		      .byte.b	-30
      0  15f2					      EVAL8	-30
      1  15f2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f2				  -	      ECHO	"Erroneous position value", -30
      3  15f2				  -	      ERR
      4  15f2					      ENDIF
      5  15f2		       e2		      .byte.b	-30
      0  15f3					      EVAL8	-30
      1  15f3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f3				  -	      ECHO	"Erroneous position value", -30
      3  15f3				  -	      ERR
      4  15f3					      ENDIF
      5  15f3		       e2		      .byte.b	-30
      0  15f4					      EVAL8	-30
      1  15f4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f4				  -	      ECHO	"Erroneous position value", -30
      3  15f4				  -	      ERR
      4  15f4					      ENDIF
      5  15f4		       e2		      .byte.b	-30
      0  15f5					      EVAL8	-30
      1  15f5				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f5				  -	      ECHO	"Erroneous position value", -30
      3  15f5				  -	      ERR
      4  15f5					      ENDIF
      5  15f5		       e2		      .byte.b	-30
      0  15f6					      EVAL8	-30
      1  15f6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15f6				  -	      ECHO	"Erroneous position value", -30
      3  15f6				  -	      ERR
      4  15f6					      ENDIF
      5  15f6		       e2		      .byte.b	-30
      0  15f7					      EVAL8	-50
      1  15f7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  15f7				  -	      ECHO	"Erroneous position value", -50
      3  15f7				  -	      ERR
      4  15f7					      ENDIF
      5  15f7		       ce		      .byte.b	-50
      0  15f8					      EVAL8	0
      1  15f8				  -	      IF	(0 > 127) || (0 < -128)
      2  15f8				  -	      ECHO	"Erroneous position value", 0
      3  15f8				  -	      ERR
      4  15f8					      ENDIF
      5  15f8		       00		      .byte.b	0
      0  15f9					      EVAL8	0
      1  15f9				  -	      IF	(0 > 127) || (0 < -128)
      2  15f9				  -	      ECHO	"Erroneous position value", 0
      3  15f9				  -	      ERR
      4  15f9					      ENDIF
      5  15f9		       00		      .byte.b	0
      0  15fa					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      0  15fa					      EVAL8	-30
      1  15fa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15fa				  -	      ECHO	"Erroneous position value", -30
      3  15fa				  -	      ERR
      4  15fa					      ENDIF
      5  15fa		       e2		      .byte.b	-30
      0  15fb					      EVAL8	-30
      1  15fb				  -	      IF	(-30 > 127) || (-30 < -128)
      2  15fb				  -	      ECHO	"Erroneous position value", -30
      3  15fb				  -	      ERR
      4  15fb					      ENDIF
      5  15fb		       e2		      .byte.b	-30
      0  15fc					      EVAL8	0
      1  15fc				  -	      IF	(0 > 127) || (0 < -128)
      2  15fc				  -	      ECHO	"Erroneous position value", 0
      3  15fc				  -	      ERR
      4  15fc					      ENDIF
      5  15fc		       00		      .byte.b	0
      0  15fd					      EVAL8	0
      1  15fd				  -	      IF	(0 > 127) || (0 < -128)
      2  15fd				  -	      ECHO	"Erroneous position value", 0
      3  15fd				  -	      ERR
      4  15fd					      ENDIF
      5  15fd		       00		      .byte.b	0
      0  15fe					      EVAL8	0
      1  15fe				  -	      IF	(0 > 127) || (0 < -128)
      2  15fe				  -	      ECHO	"Erroneous position value", 0
      3  15fe				  -	      ERR
      4  15fe					      ENDIF
      5  15fe		       00		      .byte.b	0
      0  15ff					      EVAL8	0
      1  15ff				  -	      IF	(0 > 127) || (0 < -128)
      2  15ff				  -	      ECHO	"Erroneous position value", 0
      3  15ff				  -	      ERR
      4  15ff					      ENDIF
      5  15ff		       00		      .byte.b	0
      0  1600					      EVAL8	-30
      1  1600				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1600				  -	      ECHO	"Erroneous position value", -30
      3  1600				  -	      ERR
      4  1600					      ENDIF
      5  1600		       e2		      .byte.b	-30
      0  1601					      EVAL8	-30
      1  1601				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1601				  -	      ECHO	"Erroneous position value", -30
      3  1601				  -	      ERR
      4  1601					      ENDIF
      5  1601		       e2		      .byte.b	-30
      0  1602					      EVAL8	0
      1  1602				  -	      IF	(0 > 127) || (0 < -128)
      2  1602				  -	      ECHO	"Erroneous position value", 0
      3  1602				  -	      ERR
      4  1602					      ENDIF
      5  1602		       00		      .byte.b	0
      0  1603					      EVAL8	0
      1  1603				  -	      IF	(0 > 127) || (0 < -128)
      2  1603				  -	      ECHO	"Erroneous position value", 0
      3  1603				  -	      ERR
      4  1603					      ENDIF
      5  1603		       00		      .byte.b	0
      0  1604					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  1604					      EVAL8	-30
      1  1604				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1604				  -	      ECHO	"Erroneous position value", -30
      3  1604				  -	      ERR
      4  1604					      ENDIF
      5  1604		       e2		      .byte.b	-30
      0  1605					      EVAL8	-10
      1  1605				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1605				  -	      ECHO	"Erroneous position value", -10
      3  1605				  -	      ERR
      4  1605					      ENDIF
      5  1605		       f6		      .byte.b	-10
      0  1606					      EVAL8	20
      1  1606				  -	      IF	(20 > 127) || (20 < -128)
      2  1606				  -	      ECHO	"Erroneous position value", 20
      3  1606				  -	      ERR
      4  1606					      ENDIF
      5  1606		       14		      .byte.b	20
      0  1607					      EVAL8	30
      1  1607				  -	      IF	(30 > 127) || (30 < -128)
      2  1607				  -	      ECHO	"Erroneous position value", 30
      3  1607				  -	      ERR
      4  1607					      ENDIF
      5  1607		       1e		      .byte.b	30
      0  1608					      EVAL8	30
      1  1608				  -	      IF	(30 > 127) || (30 < -128)
      2  1608				  -	      ECHO	"Erroneous position value", 30
      3  1608				  -	      ERR
      4  1608					      ENDIF
      5  1608		       1e		      .byte.b	30
      0  1609					      EVAL8	20
      1  1609				  -	      IF	(20 > 127) || (20 < -128)
      2  1609				  -	      ECHO	"Erroneous position value", 20
      3  1609				  -	      ERR
      4  1609					      ENDIF
      5  1609		       14		      .byte.b	20
      0  160a					      EVAL8	-10
      1  160a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  160a				  -	      ECHO	"Erroneous position value", -10
      3  160a				  -	      ERR
      4  160a					      ENDIF
      5  160a		       f6		      .byte.b	-10
      0  160b					      EVAL8	-30
      1  160b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  160b				  -	      ECHO	"Erroneous position value", -30
      3  160b				  -	      ERR
      4  160b					      ENDIF
      5  160b		       e2		      .byte.b	-30
      0  160c					      EVAL8	0
      1  160c				  -	      IF	(0 > 127) || (0 < -128)
      2  160c				  -	      ECHO	"Erroneous position value", 0
      3  160c				  -	      ERR
      4  160c					      ENDIF
      5  160c		       00		      .byte.b	0
      0  160d					      EVAL8	0
      1  160d				  -	      IF	(0 > 127) || (0 < -128)
      2  160d				  -	      ECHO	"Erroneous position value", 0
      3  160d				  -	      ERR
      4  160d					      ENDIF
      5  160d		       00		      .byte.b	0
      0  160e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  160e					      EVAL8	-30
      1  160e				  -	      IF	(-30 > 127) || (-30 < -128)
      2  160e				  -	      ECHO	"Erroneous position value", -30
      3  160e				  -	      ERR
      4  160e					      ENDIF
      5  160e		       e2		      .byte.b	-30
      0  160f					      EVAL8	-10
      1  160f				  -	      IF	(-10 > 127) || (-10 < -128)
      2  160f				  -	      ECHO	"Erroneous position value", -10
      3  160f				  -	      ERR
      4  160f					      ENDIF
      5  160f		       f6		      .byte.b	-10
      0  1610					      EVAL8	30
      1  1610				  -	      IF	(30 > 127) || (30 < -128)
      2  1610				  -	      ECHO	"Erroneous position value", 30
      3  1610				  -	      ERR
      4  1610					      ENDIF
      5  1610		       1e		      .byte.b	30
      0  1611					      EVAL8	40
      1  1611				  -	      IF	(40 > 127) || (40 < -128)
      2  1611				  -	      ECHO	"Erroneous position value", 40
      3  1611				  -	      ERR
      4  1611					      ENDIF
      5  1611		       28		      .byte.b	40
      0  1612					      EVAL8	40
      1  1612				  -	      IF	(40 > 127) || (40 < -128)
      2  1612				  -	      ECHO	"Erroneous position value", 40
      3  1612				  -	      ERR
      4  1612					      ENDIF
      5  1612		       28		      .byte.b	40
      0  1613					      EVAL8	30
      1  1613				  -	      IF	(30 > 127) || (30 < -128)
      2  1613				  -	      ECHO	"Erroneous position value", 30
      3  1613				  -	      ERR
      4  1613					      ENDIF
      5  1613		       1e		      .byte.b	30
      0  1614					      EVAL8	-10
      1  1614				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1614				  -	      ECHO	"Erroneous position value", -10
      3  1614				  -	      ERR
      4  1614					      ENDIF
      5  1614		       f6		      .byte.b	-10
      0  1615					      EVAL8	-30
      1  1615				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1615				  -	      ECHO	"Erroneous position value", -30
      3  1615				  -	      ERR
      4  1615					      ENDIF
      5  1615		       e2		      .byte.b	-30
      0  1616					      EVAL8	0
      1  1616				  -	      IF	(0 > 127) || (0 < -128)
      2  1616				  -	      ECHO	"Erroneous position value", 0
      3  1616				  -	      ERR
      4  1616					      ENDIF
      5  1616		       00		      .byte.b	0
      0  1617					      EVAL8	0
      1  1617				  -	      IF	(0 > 127) || (0 < -128)
      2  1617				  -	      ECHO	"Erroneous position value", 0
      3  1617				  -	      ERR
      4  1617					      ENDIF
      5  1617		       00		      .byte.b	0
      0  1618					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  1618					      EVAL8	-30
      1  1618				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1618				  -	      ECHO	"Erroneous position value", -30
      3  1618				  -	      ERR
      4  1618					      ENDIF
      5  1618		       e2		      .byte.b	-30
      0  1619					      EVAL8	-10
      1  1619				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1619				  -	      ECHO	"Erroneous position value", -10
      3  1619				  -	      ERR
      4  1619					      ENDIF
      5  1619		       f6		      .byte.b	-10
      0  161a					      EVAL8	30
      1  161a				  -	      IF	(30 > 127) || (30 < -128)
      2  161a				  -	      ECHO	"Erroneous position value", 30
      3  161a				  -	      ERR
      4  161a					      ENDIF
      5  161a		       1e		      .byte.b	30
      0  161b					      EVAL8	40
      1  161b				  -	      IF	(40 > 127) || (40 < -128)
      2  161b				  -	      ECHO	"Erroneous position value", 40
      3  161b				  -	      ERR
      4  161b					      ENDIF
      5  161b		       28		      .byte.b	40
      0  161c					      EVAL8	40
      1  161c				  -	      IF	(40 > 127) || (40 < -128)
      2  161c				  -	      ECHO	"Erroneous position value", 40
      3  161c				  -	      ERR
      4  161c					      ENDIF
      5  161c		       28		      .byte.b	40
      0  161d					      EVAL8	30
      1  161d				  -	      IF	(30 > 127) || (30 < -128)
      2  161d				  -	      ECHO	"Erroneous position value", 30
      3  161d				  -	      ERR
      4  161d					      ENDIF
      5  161d		       1e		      .byte.b	30
      0  161e					      EVAL8	-10
      1  161e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  161e				  -	      ECHO	"Erroneous position value", -10
      3  161e				  -	      ERR
      4  161e					      ENDIF
      5  161e		       f6		      .byte.b	-10
      0  161f					      EVAL8	-30
      1  161f				  -	      IF	(-30 > 127) || (-30 < -128)
      2  161f				  -	      ECHO	"Erroneous position value", -30
      3  161f				  -	      ERR
      4  161f					      ENDIF
      5  161f		       e2		      .byte.b	-30
      0  1620					      EVAL8	0
      1  1620				  -	      IF	(0 > 127) || (0 < -128)
      2  1620				  -	      ECHO	"Erroneous position value", 0
      3  1620				  -	      ERR
      4  1620					      ENDIF
      5  1620		       00		      .byte.b	0
      0  1621					      EVAL8	0
      1  1621				  -	      IF	(0 > 127) || (0 < -128)
      2  1621				  -	      ECHO	"Erroneous position value", 0
      3  1621				  -	      ERR
      4  1621					      ENDIF
      5  1621		       00		      .byte.b	0
      0  1622					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  1622					      EVAL8	-30
      1  1622				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1622				  -	      ECHO	"Erroneous position value", -30
      3  1622				  -	      ERR
      4  1622					      ENDIF
      5  1622		       e2		      .byte.b	-30
      0  1623					      EVAL8	-10
      1  1623				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1623				  -	      ECHO	"Erroneous position value", -10
      3  1623				  -	      ERR
      4  1623					      ENDIF
      5  1623		       f6		      .byte.b	-10
      0  1624					      EVAL8	20
      1  1624				  -	      IF	(20 > 127) || (20 < -128)
      2  1624				  -	      ECHO	"Erroneous position value", 20
      3  1624				  -	      ERR
      4  1624					      ENDIF
      5  1624		       14		      .byte.b	20
      0  1625					      EVAL8	30
      1  1625				  -	      IF	(30 > 127) || (30 < -128)
      2  1625				  -	      ECHO	"Erroneous position value", 30
      3  1625				  -	      ERR
      4  1625					      ENDIF
      5  1625		       1e		      .byte.b	30
      0  1626					      EVAL8	30
      1  1626				  -	      IF	(30 > 127) || (30 < -128)
      2  1626				  -	      ECHO	"Erroneous position value", 30
      3  1626				  -	      ERR
      4  1626					      ENDIF
      5  1626		       1e		      .byte.b	30
      0  1627					      EVAL8	20
      1  1627				  -	      IF	(20 > 127) || (20 < -128)
      2  1627				  -	      ECHO	"Erroneous position value", 20
      3  1627				  -	      ERR
      4  1627					      ENDIF
      5  1627		       14		      .byte.b	20
      0  1628					      EVAL8	-10
      1  1628				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1628				  -	      ECHO	"Erroneous position value", -10
      3  1628				  -	      ERR
      4  1628					      ENDIF
      5  1628		       f6		      .byte.b	-10
      0  1629					      EVAL8	-30
      1  1629				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1629				  -	      ECHO	"Erroneous position value", -30
      3  1629				  -	      ERR
      4  1629					      ENDIF
      5  1629		       e2		      .byte.b	-30
      0  162a					      EVAL8	0
      1  162a				  -	      IF	(0 > 127) || (0 < -128)
      2  162a				  -	      ECHO	"Erroneous position value", 0
      3  162a				  -	      ERR
      4  162a					      ENDIF
      5  162a		       00		      .byte.b	0
      0  162b					      EVAL8	0
      1  162b				  -	      IF	(0 > 127) || (0 < -128)
      2  162b				  -	      ECHO	"Erroneous position value", 0
      3  162b				  -	      ERR
      4  162b					      ENDIF
      5  162b		       00		      .byte.b	0
      0  162c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      0  162c					      EVAL8	-30
      1  162c				  -	      IF	(-30 > 127) || (-30 < -128)
      2  162c				  -	      ECHO	"Erroneous position value", -30
      3  162c				  -	      ERR
      4  162c					      ENDIF
      5  162c		       e2		      .byte.b	-30
      0  162d					      EVAL8	-20
      1  162d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  162d				  -	      ECHO	"Erroneous position value", -20
      3  162d				  -	      ERR
      4  162d					      ENDIF
      5  162d		       ec		      .byte.b	-20
      0  162e					      EVAL8	-10
      1  162e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  162e				  -	      ECHO	"Erroneous position value", -10
      3  162e				  -	      ERR
      4  162e					      ENDIF
      5  162e		       f6		      .byte.b	-10
      0  162f					      EVAL8	0
      1  162f				  -	      IF	(0 > 127) || (0 < -128)
      2  162f				  -	      ECHO	"Erroneous position value", 0
      3  162f				  -	      ERR
      4  162f					      ENDIF
      5  162f		       00		      .byte.b	0
      0  1630					      EVAL8	0
      1  1630				  -	      IF	(0 > 127) || (0 < -128)
      2  1630				  -	      ECHO	"Erroneous position value", 0
      3  1630				  -	      ERR
      4  1630					      ENDIF
      5  1630		       00		      .byte.b	0
      0  1631					      EVAL8	-10
      1  1631				  -	      IF	(-10 > 127) || (-10 < -128)
      2  1631				  -	      ECHO	"Erroneous position value", -10
      3  1631				  -	      ERR
      4  1631					      ENDIF
      5  1631		       f6		      .byte.b	-10
      0  1632					      EVAL8	-20
      1  1632				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1632				  -	      ECHO	"Erroneous position value", -20
      3  1632				  -	      ERR
      4  1632					      ENDIF
      5  1632		       ec		      .byte.b	-20
      0  1633					      EVAL8	-30
      1  1633				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1633				  -	      ECHO	"Erroneous position value", -30
      3  1633				  -	      ERR
      4  1633					      ENDIF
      5  1633		       e2		      .byte.b	-30
      0  1634					      EVAL8	0
      1  1634				  -	      IF	(0 > 127) || (0 < -128)
      2  1634				  -	      ECHO	"Erroneous position value", 0
      3  1634				  -	      ERR
      4  1634					      ENDIF
      5  1634		       00		      .byte.b	0
      0  1635					      EVAL8	0
      1  1635				  -	      IF	(0 > 127) || (0 < -128)
      2  1635				  -	      ECHO	"Erroneous position value", 0
      3  1635				  -	      ERR
      4  1635					      ENDIF
      5  1635		       00		      .byte.b	0
      0  1636					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      0  1636					      EVAL8	-50
      1  1636				  -	      IF	(-50 > 127) || (-50 < -128)
      2  1636				  -	      ECHO	"Erroneous position value", -50
      3  1636				  -	      ERR
      4  1636					      ENDIF
      5  1636		       ce		      .byte.b	-50
      0  1637					      EVAL8	-40
      1  1637				  -	      IF	(-40 > 127) || (-40 < -128)
      2  1637				  -	      ECHO	"Erroneous position value", -40
      3  1637				  -	      ERR
      4  1637					      ENDIF
      5  1637		       d8		      .byte.b	-40
      0  1638					      EVAL8	-30
      1  1638				  -	      IF	(-30 > 127) || (-30 < -128)
      2  1638				  -	      ECHO	"Erroneous position value", -30
      3  1638				  -	      ERR
      4  1638					      ENDIF
      5  1638		       e2		      .byte.b	-30
      0  1639					      EVAL8	-20
      1  1639				  -	      IF	(-20 > 127) || (-20 < -128)
      2  1639				  -	      ECHO	"Erroneous position value", -20
      3  1639				  -	      ERR
      4  1639					      ENDIF
      5  1639		       ec		      .byte.b	-20
      0  163a					      EVAL8	- 20
      1  163a				  -	      IF	(- 20 > 127) || (- 20 < -128)
      2  163a				  -	      ECHO	"Erroneous position value", - 20
      3  163a				  -	      ERR
      4  163a					      ENDIF
      5  163a		       ec		      .byte.b	- 20
      0  163b					      EVAL8	-30
      1  163b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  163b				  -	      ECHO	"Erroneous position value", -30
      3  163b				  -	      ERR
      4  163b					      ENDIF
      5  163b		       e2		      .byte.b	-30
      0  163c					      EVAL8	-40
      1  163c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  163c				  -	      ECHO	"Erroneous position value", -40
      3  163c				  -	      ERR
      4  163c					      ENDIF
      5  163c		       d8		      .byte.b	-40
      0  163d					      EVAL8	-50
      1  163d				  -	      IF	(-50 > 127) || (-50 < -128)
      2  163d				  -	      ECHO	"Erroneous position value", -50
      3  163d				  -	      ERR
      4  163d					      ENDIF
      5  163d		       ce		      .byte.b	-50
      0  163e					      EVAL8	0
      1  163e				  -	      IF	(0 > 127) || (0 < -128)
      2  163e				  -	      ECHO	"Erroneous position value", 0
      3  163e				  -	      ERR
      4  163e					      ENDIF
      5  163e		       00		      .byte.b	0
      0  163f					      EVAL8	0
      1  163f				  -	      IF	(0 > 127) || (0 < -128)
      2  163f				  -	      ECHO	"Erroneous position value", 0
      3  163f				  -	      ERR
      4  163f					      ENDIF
      5  163f		       00		      .byte.b	0
    187  1640
    188  1640
    189  1640
      0  1640					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  1640		       02 40	   .TEMP      =	* - _BANK_START
 BANK_EVAL (1K) SIZE =  $240 , FREE= $1c0
      2  1640					      ECHO	"BANK_EVAL", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1640				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1640				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_EVAL", " size=", * - ORIGIN
      5  1640				  -	      ERR
      6  1640					      ENDIF
    191  1640
    192  1640							;---------------------------------------------------------------------------------------------------
    193  1640							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#1.asm LEVEL 2 PASS 4
      0  1640					      include	"BANK_StateMachine@1#1.asm"
      0  1640					      SLOT	1
      1  1640				  -	      IF	(1 < 0) || (1 > 3)
      2  1640				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1640				  -	      ERR
      4  1640					      ENDIF
      5  1640				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1640				   _BANK_SLOT SET	1 * 64
      0  1640					      NEWBANK	STATEMACHINE
      1  1ba9 ????				      SEG	STATEMACHINE
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   STATEMACHINE_START SET	*
      6  1800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1800				   STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + 1024
      3  1800
      4  1800
      5  1800							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      6  1800
      7  1800
      8  1800		       00 10	   CURSOR_MOVE_SPEED =	16
      9  1800		       00 14	   CAP_SPEED  =	20
     10  1800		       00 28	   HOLD_DELAY =	40
     11  1800
     12  1800
     13  1800							;---------------------------------------------------------------------------------------------------
     14  1800
     15  1800
     16  1800							;---------------------------------------------------------------------------------------------------
     17  1800
      0  1800					      DEF	aiStartMoveGen
      1  1800				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  1800				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  1800				   aiStartMoveGen
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	aiStartMoveGen
     19  1800					      SUBROUTINE
     20  1800
      0  1800					      REFER	AiStateMachine
      1  1800					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1800				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1800					      ENDIF
      0  1800					      VEND	aiStartMoveGen
      1  1800				  -	      IFNCONST	aiStartMoveGen
      2  1800				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  1800				  -	      ERR
      4  1800					      ENDIF
      5  1800		       00 a8	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
     23  1800
     24  1800							; To assist with castling, generate the moves for the opponent, giving us effectively
     25  1800							; a list of squares that are being attacked. The castling can't happen if the king is
     26  1800							; in check or if the squares it would have to move over are in check
     27  1800
     28  1800							; we don't need to worry about this if K has moved, or relevant R has moved or if
     29  1800							; the squares between are occupied. We can tell THAT by examining the movelist to see
     30  1800							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     31  1800
     32  1800							;inc currentPly
     33  1800							;jsr InitialiseMoveGeneration
     34  1800
      0  1800					      PHASE	AI_StepMoveGen
      1  1800		       a9 0c		      lda	#AI_StepMoveGen
      2  1802		       85 8b		      sta	aiState
     36  1804		       60		      rts
     37  1805
     38  1805
     39  1805							;---------------------------------------------------------------------------------------------------
     40  1805
      0  1805					      DEF	aiInCheckBackup
      1  1805				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  1805				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  1805				   aiInCheckBackup
      4  1805				   TEMPORARY_VAR SET	Overlay
      5  1805				   TEMPORARY_OFFSET SET	0
      6  1805				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  1805				   FUNCTION_NAME SET	aiInCheckBackup
     42  1805					      SUBROUTINE
     43  1805
      0  1805					      REFER	AiStateMachine
      1  1805					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1805				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1805					      ENDIF
      0  1805					      VEND	aiInCheckBackup
      1  1805				  -	      IFNCONST	aiInCheckBackup
      2  1805				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  1805				  -	      ERR
      4  1805					      ENDIF
      5  1805		       00 a8	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
     46  1805
     47  1805							; We're about to draw some large text on the screen
     48  1805							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     49  1805
     50  1805		       c6 84		      dec	drawCount
     51  1807		       30 02		      bmi	.exit	; done all rows
     52  1809		       a4 84		      ldy	drawCount
     53  180b				  -	      IF	0
     54  180b				  -	      jmp	SAFE_BackupBitmaps
     55  180b					      ENDIF
     56  180b
      0  180b				   .exit      PHASE	AI_InCheckDelay
      1  180b		       a9 1e		      lda	#AI_InCheckDelay
      2  180d		       85 8b		      sta	aiState
     58  180f		       60		      rts
     59  1810
     60  1810
     61  1810							;---------------------------------------------------------------------------------------------------
     62  1810
      0  1810					      DEF	aiInCheckDelay
      1  1810				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  1810				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  1810				   aiInCheckDelay
      4  1810				   TEMPORARY_VAR SET	Overlay
      5  1810				   TEMPORARY_OFFSET SET	0
      6  1810				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  1810				   FUNCTION_NAME SET	aiInCheckDelay
     64  1810					      SUBROUTINE
     65  1810
      0  1810					      REFER	AiStateMachine
      1  1810					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1810				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1810					      ENDIF
      0  1810					      VEND	aiInCheckDelay
      1  1810				  -	      IFNCONST	aiInCheckDelay
      2  1810				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  1810				  -	      ERR
      4  1810					      ENDIF
      5  1810		       00 a8	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
     68  1810
     69  1810		       c6 89		      dec	mdelay
     70  1812		       d0 08		      bne	.exit
     71  1814
     72  1814		       a9 00		      lda	#0
     73  1816		       85 49		      sta	COLUBK
     74  1818
      0  1818					      PHASE	AI_BeginSelectMovePhase
      1  1818		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  181a		       85 8b		      sta	aiState
     76  181c		       60	   .exit      rts
     77  181d
     78  181d
     79  181d							;---------------------------------------------------------------------------------------------------
     80  181d
      0  181d					      DEF	aiBeginSelectMovePhase
      1  181d				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  181d				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  181d				   aiBeginSelectMovePhase
      4  181d				   TEMPORARY_VAR SET	Overlay
      5  181d				   TEMPORARY_OFFSET SET	0
      6  181d				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  181d				   FUNCTION_NAME SET	aiBeginSelectMovePhase
     82  181d					      SUBROUTINE
     83  181d
      0  181d					      REFER	AiStateMachine
      1  181d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  181d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  181d					      ENDIF
      0  181d					      VEND	aiBeginSelectMovePhase
      1  181d				  -	      IFNCONST	aiBeginSelectMovePhase
      2  181d				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  181d				  -	      ERR
      4  181d					      ENDIF
      5  181d		       00 a8	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
     86  181d
     87  181d
     88  181d		       a9 02		      lda	#$2
     89  181f		       85 46		      sta	COLUP0
     90  1821		       a2 04		      ldx	#%100
     91  1823		       86 4a		      stx	CTRLPF	; under
     92  1825
     93  1825		       a9 00		      lda	#0
     94  1827		       85 89		      sta	mdelay	;?
     95  1829		       85 8e		      sta	aiFlashPhase	; odd/even for flashing pieces
     96  182b
     97  182b		       a9 28		      lda	#CAP_SPEED*2
     98  182d		       85 8c		      sta	aiFlashDelay
     99  182f
    100  182f		       a9 ff		      lda	#-1
    101  1831		       85 85		      sta	fromX12
    102  1833		       85 86		      sta	toX12
    103  1835
    104  1835		       46 a3		      lsr	randomness
    105  1837
    106  1837
      0  1837					      PHASE	AI_FlashComputerMove
      1  1837		       a9 00		      lda	#AI_FlashComputerMove
      2  1839		       85 8b		      sta	aiState
    108  183b		       60		      rts
    109  183c
    110  183c							;---------------------------------------------------------------------------------------------------
    111  183c
      0  183c					      DEF	aiFlashComputerMove
      1  183c				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  183c				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  183c				   aiFlashComputerMove
      4  183c				   TEMPORARY_VAR SET	Overlay
      5  183c				   TEMPORARY_OFFSET SET	0
      6  183c				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  183c				   FUNCTION_NAME SET	aiFlashComputerMove
    113  183c					      SUBROUTINE
    114  183c
      0  183c					      REFER	AiStateMachine
      1  183c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  183c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  183c					      ENDIF
      0  183c					      VEND	aiFlashComputerMove
      1  183c				  -	      IFNCONST	aiFlashComputerMove
      2  183c				  -	      ECHO	"Incorrect VEND label", aiFlashComputerMove
      3  183c				  -	      ERR
      4  183c					      ENDIF
      5  183c		       00 a8	   VAREND_aiFlashComputerMove =	TEMPORARY_VAR
    117  183c
    118  183c		       a5 80		      lda	squareToDraw
    119  183e		       30 1f		      bmi	.initial2	; startup - no computer move to show
    120  1840
    121  1840							; "squareToDraw" is the piece that should flash while human waits
    122  1840
    123  1840		       ad 80 02 	      lda	SWCHA
    124  1843		       29 f0		      and	#$F0
    125  1845		       c9 f0		      cmp	#$F0
    126  1847		       f0 08		      beq	.nodir
    127  1849
    128  1849		       a9 01		      lda	#1
    129  184b		       85 8c		      sta	aiFlashDelay
    130  184d		       25 8e		      and	aiFlashPhase
    131  184f		       f0 0e		      beq	.initial
    132  1851
    133  1851		       c6 8c	   .nodir     dec	aiFlashDelay
    134  1853		       d0 0e		      bne	.exit	; don't flash
    135  1855		       a9 28		      lda	#CAP_SPEED*2
    136  1857		       85 8c		      sta	aiFlashDelay
    137  1859
    138  1859		       e6 8e		      inc	aiFlashPhase
    139  185b
    140  185b		       20 be f0 	      jsr	CopySinglePiece	;@0
    141  185e		       60		      rts
    142  185f
    143  185f				   .initial
    144  185f
    145  185f							;SWAP
      0  185f				   .initial2  PHASE	AI_SelectStartSquare
      1  185f		       a9 02		      lda	#AI_SelectStartSquare
      2  1861		       85 8b		      sta	aiState
    147  1863
    148  1863		       60	   .exit      rts
    149  1864
    150  1864
    151  1864							;---------------------------------------------------------------------------------------------------
    152  1864
      0  1864					      DEF	aiSelectStartSquare
      1  1864				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  1864				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  1864				   aiSelectStartSquare
      4  1864				   TEMPORARY_VAR SET	Overlay
      5  1864				   TEMPORARY_OFFSET SET	0
      6  1864				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  1864				   FUNCTION_NAME SET	aiSelectStartSquare
    154  1864					      SUBROUTINE
    155  1864
      0  1864					      REFER	AiStateMachine
      1  1864					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1864				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1864					      ENDIF
      0  1864					      VEND	aiSelectStartSquare
      1  1864				  -	      IFNCONST	aiSelectStartSquare
      2  1864				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  1864				  -	      ERR
      4  1864					      ENDIF
      5  1864		       00 a8	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    158  1864
      0  1864					      NEXT_RANDOM
      1  1864		       a5 81		      lda	rnd
      2  1866		       4a		      lsr
      3  1867		       90 02		      bcc	.skipEOR
      4  1869		       49 fe		      eor	#RND_EOR_VAL
      5  186b		       85 81	   .skipEOR   sta	rnd
    160  186d
    161  186d		       20 29 f6 	      jsr	moveCursor
    162  1870
    163  1870							; Search the player's movelist for the square, so we can set cursor colour
    164  1870
    165  1870		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
    166  1872		       85 3e		      sta	SET_BANK_RAM	;@2
    167  1874
    168  1874		       a5 88		      lda	cursorX12
    169  1876		       85 85		      sta	fromX12
    170  1878
      0  1878					      ldy@PLY	moveIndex
      1  1878		       ac cf f9 	      ldy	moveIndex
    172  187b		       30 0d		      bmi	.done
    173  187d
    174  187d		       d9 00 f8    .scan      cmp	MoveFrom,y
    175  1880		       f0 03		      beq	.scanned
    176  1882		       88		      dey
    177  1883		       10 f8		      bpl	.scan
    178  1885
      0  1885				   .scanned   lda@PLY	MovePiece,y
      1  1885		       b9 00 f9 	      lda	MovePiece,y
    180  1888		       85 96		      sta	fromPiece
    181  188a
    182  188a		       c6 8a	   .done      dec	ccur	; pulse colour for valid squares
    183  188c		       20 b1 f4 	      jsr	setCursorColours
    184  188f
    185  188f		       98		      tya
    186  1890		       05 4c		      ora	INPT4
    187  1892		       30 04		      bmi	.exit	; illegal square or no button press
    188  1894
      0  1894					      PHASE	AI_StartSquareSelected
      1  1894		       a9 03		      lda	#AI_StartSquareSelected
      2  1896		       85 8b		      sta	aiState
    190  1898
    191  1898		       60	   .exit      rts
    192  1899
    193  1899							;---------------------------------------------------------------------------------------------------
    194  1899
      0  1899					      DEF	setCursorPriority
      1  1899				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  1899				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  1899				   setCursorPriority
      4  1899				   TEMPORARY_VAR SET	Overlay
      5  1899				   TEMPORARY_OFFSET SET	0
      6  1899				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  1899				   FUNCTION_NAME SET	setCursorPriority
    196  1899					      SUBROUTINE
    197  1899
      0  1899					      REFER	moveCursor
      1  1899					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  1899				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  1899					      ENDIF
      0  1899					      VEND	setCursorPriority
      1  1899				  -	      IFNCONST	setCursorPriority
      2  1899				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  1899				  -	      ERR
      4  1899					      ENDIF
      5  1899		       00 a9	   VAREND_setCursorPriority =	TEMPORARY_VAR
    200  1899
    201  1899		       98		      tya
    202  189a		       48		      pha
    203  189b
    204  189b		       a2 04		      ldx	#%100
    205  189d
    206  189d		       a4 88		      ldy	cursorX12
    207  189f		       30 0b		      bmi	.under
    208  18a1
    209  18a1		       a9 d1		      lda	#RAMBANK_BOARD
    210  18a3		       85 3e		      sta	SET_BANK_RAM	;@3
    211  18a5		       b9 79 fc 	      lda	Board,y
    212  18a8		       d0 02		      bne	.under
    213  18aa		       a2 00		      ldx	#0
    214  18ac		       86 4a	   .under     stx	CTRLPF	; UNDER
    215  18ae
    216  18ae		       68		      pla
    217  18af		       a8		      tay
    218  18b0		       60		      rts
    219  18b1
    220  18b1							;---------------------------------------------------------------------------------------------------
    221  18b1
      0  18b1					      DEF	setCursorColours
      1  18b1				   SLOT_setCursorColours SET	_BANK_SLOT
      2  18b1				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  18b1				   setCursorColours
      4  18b1				   TEMPORARY_VAR SET	Overlay
      5  18b1				   TEMPORARY_OFFSET SET	0
      6  18b1				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  18b1				   FUNCTION_NAME SET	setCursorColours
    223  18b1					      SUBROUTINE
    224  18b1
      0  18b1					      REFER	aiSelectStartSquare
      1  18b1					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  18b1				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  18b1					      ENDIF
      0  18b1					      REFER	aiDrawMoves
      1  18b1				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  18b1					      ENDIF
      0  18b1					      REFER	aiUnDrawTargetSquares
      1  18b1				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  18b1					      ENDIF
      0  18b1					      REFER	aiShowMoveCaptures
      1  18b1				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  18b1					      ENDIF
      0  18b1					      REFER	aiSlowFlash
      1  18b1				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  18b1					      ENDIF
      0  18b1					      REFER	aiSelectDestinationSquare
      1  18b1				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  18b1					      ENDIF
      0  18b1					      VEND	setCursorColours
      1  18b1				  -	      IFNCONST	setCursorColours
      2  18b1				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  18b1				  -	      ERR
      4  18b1					      ENDIF
      5  18b1		       00 a8	   VAREND_setCursorColours =	TEMPORARY_VAR
    232  18b1
    233  18b1							; pass y=-1 if move is NOT in the movelist
    234  18b1							; preserve y
    235  18b1
    236  18b1		       a9 40		      lda	#$40
    237  18b3
    238  18b3		       c0 ff		      cpy	#-1
    239  18b5		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    240  18b7
    241  18b7		       a5 8a		      lda	ccur
    242  18b9		       4a		      lsr
    243  18ba		       4a		      lsr
    244  18bb		       4a		      lsr
    245  18bc		       29 03		      and	#3
    246  18be		       18		      clc
    247  18bf		       69 d0		      adc	#$D0	;COLOUR_LINE_1
    248  18c1
    249  18c1		       85 46	   .writeCursorCol sta	COLUP0
    250  18c3		       60		      rts
    251  18c4
    252  18c4
    253  18c4							;---------------------------------------------------------------------------------------------------
    254  18c4
    255  18c4							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    256  18c4							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    257  18c4
      0  18c4					      ALLOCATE	JoyCombined, 16
      0  18c4					      OPTIONAL_PAGEBREAK	"Table", 16
     12  18c4					      LIST	ON
      0  18c4					      DEF	JoyCombined
      1  18c4				   SLOT_JoyCombined SET	_BANK_SLOT
      2  18c4				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  18c4				   JoyCombined
      4  18c4				   TEMPORARY_VAR SET	Overlay
      5  18c4				   TEMPORARY_OFFSET SET	0
      6  18c4				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  18c4				   FUNCTION_NAME SET	JoyCombined
    259  18c4		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    260  18d4
      0  18d4					      ALLOCATE	JoyMoveCursor, 16
      0  18d4					      OPTIONAL_PAGEBREAK	"Table", 16
     12  18d4					      LIST	ON
      0  18d4					      DEF	JoyMoveCursor
      1  18d4				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  18d4				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  18d4				   JoyMoveCursor
      4  18d4				   TEMPORARY_VAR SET	Overlay
      5  18d4				   TEMPORARY_OFFSET SET	0
      6  18d4				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  18d4				   FUNCTION_NAME SET	JoyMoveCursor
    262  18d4		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    263  18e4
    264  18e4
    265  18e4							;---------------------------------------------------------------------------------------------------
    266  18e4
      0  18e4					      DEF	aiStartSquareSelected
      1  18e4				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  18e4				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  18e4				   aiStartSquareSelected
      4  18e4				   TEMPORARY_VAR SET	Overlay
      5  18e4				   TEMPORARY_OFFSET SET	0
      6  18e4				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  18e4				   FUNCTION_NAME SET	aiStartSquareSelected
    268  18e4					      SUBROUTINE
    269  18e4
      0  18e4					      REFER	AiStateMachine
      1  18e4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  18e4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  18e4					      ENDIF
      0  18e4					      VEND	aiStartSquareSelected
      1  18e4				  -	      IFNCONST	aiStartSquareSelected
      2  18e4				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  18e4				  -	      ERR
      4  18e4					      ENDIF
      5  18e4		       00 a8	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    272  18e4
    273  18e4
    274  18e4							; Mark all the valid moves for the selected piece on the board
    275  18e4							; and then start pulsing the piece
    276  18e4							; AND start choosing for selection of TO square
    277  18e4
    278  18e4							; Iterate the movelist and for all from squares which = drawPieceNumber
    279  18e4							; then draw a BLANK at that square
    280  18e4							; do 1 by one, when none found then increment state
    281  18e4
    282  18e4		       a5 88		      lda	cursorX12
    283  18e6		       85 80		      sta	squareToDraw
    284  18e8
    285  18e8		       a9 0a		      lda	#10
    286  18ea		       85 8c		      sta	aiFlashDelay
    287  18ec
    288  18ec		       a9 00		      lda	#0
    289  18ee		       85 86		      sta	toX12	;aiToSquareX12
    290  18f0		       85 8e		      sta	aiFlashPhase	; for debounce exit timing
    291  18f2
    292  18f2		       a9 ff		      lda	#-1
    293  18f4		       85 8d		      sta	aiMoveIndex
    294  18f6
    295  18f6		       a9 28		      lda	#HOLD_DELAY
    296  18f8		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    297  18fa
      0  18fa					      PHASE	AI_DrawMoves
      1  18fa		       a9 04		      lda	#AI_DrawMoves
      2  18fc		       85 8b		      sta	aiState
    299  18fe		       60		      rts
    300  18ff
    301  18ff
    302  18ff							;---------------------------------------------------------------------------------------------------
    303  18ff
      0  18ff					      DEF	aiDrawMoves
      1  18ff				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  18ff				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  18ff				   aiDrawMoves
      4  18ff				   TEMPORARY_VAR SET	Overlay
      5  18ff				   TEMPORARY_OFFSET SET	0
      6  18ff				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  18ff				   FUNCTION_NAME SET	aiDrawMoves
    305  18ff					      SUBROUTINE
    306  18ff
      0  18ff					      REFER	AiStateMachine
      1  18ff					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  18ff				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  18ff					      ENDIF
      0  18ff					      VEND	aiDrawMoves
      1  18ff				  -	      IFNCONST	aiDrawMoves
      2  18ff				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  18ff				  -	      ERR
      4  18ff					      ENDIF
      5  18ff		       00 a8	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    309  18ff
    310  18ff		       c6 8a		      dec	ccur
    311  1901		       20 b1 f4 	      jsr	setCursorColours
    312  1904
    313  1904		       c6 89		      dec	mdelay
    314  1906		       d0 25		      bne	.exit
    315  1908		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    316  190a		       85 89		      sta	mdelay	; once triggered, runs always
    317  190c
    318  190c		       a5 8d		      lda	aiMoveIndex
    319  190e		       10 09		      bpl	.valid
    320  1910
    321  1910		       a9 89		      lda	#RAMBANK_PLY+1
    322  1912		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1914					      lda@PLY	moveIndex
      1  1914		       ad cf f9 	      lda	moveIndex
    324  1917		       85 8d		      sta	aiMoveIndex
    325  1919				   .valid
    326  1919
    327  1919		       20 3a f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    328  191c		       a5 8d		      lda	aiMoveIndex
    329  191e		       10 19		      bpl	.unsure	; still drawing in this phase
    330  1920
    331  1920		       a9 14		      lda	#CAP_SPEED
    332  1922		       85 89		      sta	mdelay
    333  1924
    334  1924		       a9 00		      lda	#0
    335  1926		       85 8e		      sta	aiFlashPhase	; controls odd/even exit of flashing
    336  1928
      0  1928					      PHASE	AI_ShowMoveCaptures
      1  1928		       a9 05		      lda	#AI_ShowMoveCaptures
      2  192a		       85 8b		      sta	aiState
    338  192c		       60		      rts
    339  192d
    340  192d				   .exit
    341  192d
    342  192d							; Initial piece selection has happened, but the button hasn't been released yet
    343  192d							; AND we're still in the waiting phase to see if the button was held long enough for move show
    344  192d
    345  192d		       a5 4c		      lda	INPT4
    346  192f		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    347  1931
    348  1931							; Aha! Button released, so we know the selected piece and can start flashing it
    349  1931							; and allowing movement of the selector to a destination square...
    350  1931
    351  1931		       a9 18		      lda	#6*4
    352  1933		       85 8a		      sta	ccur	; bright green square for selection
    353  1935
      0  1935					      PHASE	AI_SelectDestinationSquare
      1  1935		       a9 08		      lda	#AI_SelectDestinationSquare
      2  1937		       85 8b		      sta	aiState
    355  1939
    356  1939		       60	   .unsure    rts
    357  193a
    358  193a
    359  193a							;---------------------------------------------------------------------------------------------------
    360  193a
      0  193a					      DEF	showMoveOptions
      1  193a				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  193a				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  193a				   showMoveOptions
      4  193a				   TEMPORARY_VAR SET	Overlay
      5  193a				   TEMPORARY_OFFSET SET	0
      6  193a				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  193a				   FUNCTION_NAME SET	showMoveOptions
    362  193a					      SUBROUTINE
    363  193a
      0  193a					      REFER	aiDrawMoves
      1  193a					      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  193a				   TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  193a					      ENDIF
      0  193a					      REFER	aiUnDrawTargetSquares
      1  193a				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  193a				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  193a					      ENDIF
    366  193a
      0  193a					      VAR	__saveIdx, 1
      1  193a		       00 a8	   __saveIdx  =	TEMPORARY_VAR
      2  193a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  193a
      4  193a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  193a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  193a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  193a					      ENDIF
      8  193a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  193a				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  193a				  -	      ERR
     11  193a					      ENDIF
     12  193a					      LIST	ON
      0  193a					      VAR	__piece, 1
      1  193a		       00 a9	   __piece    =	TEMPORARY_VAR
      2  193a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  193a
      4  193a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  193a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  193a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  193a					      ENDIF
      8  193a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  193a				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  193a				  -	      ERR
     11  193a					      ENDIF
     12  193a					      LIST	ON
    369  193a
      0  193a					      VEND	showMoveOptions
      1  193a				  -	      IFNCONST	showMoveOptions
      2  193a				  -	      ECHO	"Incorrect VEND label", showMoveOptions
      3  193a				  -	      ERR
      4  193a					      ENDIF
      5  193a		       00 aa	   VAREND_showMoveOptions =	TEMPORARY_VAR
    371  193a
    372  193a							; place a marker on the board for any square matching the piece
    373  193a							; EXCEPT for squares which are occupied (we'll flash those later)
    374  193a
    375  193a		       a6 8d	   .next      ldx	aiMoveIndex
    376  193c		       86 a8		      stx	__saveIdx
    377  193e		       30 4c		      bmi	.skip
    378  1940
    379  1940		       ad 84 02 	      lda	INTIM
    380  1943		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    381  1945		       90 45		      bcc	.skip
    382  1947
    383  1947		       c6 8d		      dec	aiMoveIndex
    384  1949
    385  1949		       a9 89		      lda	#RAMBANK_PLY+1
    386  194b		       85 3e		      sta	SET_BANK_RAM	;@2
    387  194d
      0  194d					      lda@PLY	MoveFrom,x
      1  194d		       bd 00 f8 	      lda	MoveFrom,x
    389  1950		       c5 85		      cmp	fromX12
    390  1952		       d0 e6		      bne	.next
    391  1954
      0  1954					      lda@PLY	MoveTo,x
      1  1954		       bd 64 f8 	      lda	MoveTo,x
    393  1957		       85 80		      sta	squareToDraw
    394  1959
      0  1959					      lda@PLY	MovePiece,x
      1  1959		       bd 00 f9 	      lda	MovePiece,x
    396  195c		       85 a9		      sta	__piece
    397  195e
    398  195e							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    399  195e							; TODO this could/will fail on sorted lists. MMh.
    400  195e
    401  195e		       ca		      dex
    402  195f		       30 16		      bmi	.prom
    403  1961
      0  1961					      lda@PLY	MoveTo,x
      1  1961		       bd 64 f8 	      lda	MoveTo,x
    405  1964		       c5 80		      cmp	squareToDraw
    406  1966		       d0 0f		      bne	.prom
    407  1968
      0  1968					      lda@PLY	MovePiece,x
      1  1968		       bd 00 f9 	      lda	MovePiece,x
    409  196b		       45 a9		      eor	__piece
    410  196d		       29 0f		      and	#PIECE_MASK
    411  196f		       f0 06		      beq	.prom	; same piece type so not a promote
    412  1971
    413  1971		       c6 8d		      dec	aiMoveIndex
    414  1973		       c6 8d		      dec	aiMoveIndex
    415  1975		       c6 8d		      dec	aiMoveIndex
    416  1977				   .prom
    417  1977
    418  1977		       a4 80		      ldy	squareToDraw
    419  1979
    420  1979		       a9 d1		      lda	#RAMBANK_BOARD
    421  197b		       85 3e		      sta	SET_BANK_RAM	;@3
    422  197d		       b9 79 fc 	      lda	Board,y
    423  1980		       29 0f		      and	#PIECE_MASK
    424  1982		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    425  1984
    426  1984
    427  1984							;lda INTIM
    428  1984							;cmp #SPEEDOF_COPYSINGLEPIECE
    429  1984							;bcc .skip
    430  1984
    431  1984							;lda aiMoveIndex
    432  1984							;sta __saveIdx
    433  1984
    434  1984							; Draw the marker...?
    435  1984
    436  1984		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    437  1986		       20 91 f5 	      jsr	CopySetupForMarker	;@1
    438  1989		       4c c5 f0 	      jmp	InterceptMarkerCopy	;@0
    439  198c
    440  198c
    441  198c
    442  198c		       a5 a8	   .skip      lda	__saveIdx
    443  198e		       85 8d		      sta	aiMoveIndex
    444  1990		       60		      rts
    445  1991
    446  1991
    447  1991							;---------------------------------------------------------------------------------------------------
    448  1991
      0  1991					      DEF	CopySetupForMarker
      1  1991				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  1991				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  1991				   CopySetupForMarker
      4  1991				   TEMPORARY_VAR SET	Overlay
      5  1991				   TEMPORARY_OFFSET SET	0
      6  1991				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  1991				   FUNCTION_NAME SET	CopySetupForMarker
    450  1991					      SUBROUTINE
    451  1991
      0  1991					      REFER	showMoveOptions
      1  1991					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  1991					      ENDIF
      0  1991					      REFER	showPromoteOptions
      1  1991				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  1991				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  1991					      ENDIF
    454  1991
      0  1991					      VAR	__pieceColour, 1
      1  1991		       00 aa	   __pieceColour =	TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1991
      4  1991				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1991				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1991				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1991					      ENDIF
      8  1991				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1991				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  1991				  -	      ERR
     11  1991					      ENDIF
     12  1991					      LIST	ON
      0  1991					      VAR	__oddeven, 1
      1  1991		       00 ab	   __oddeven  =	TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1991
      4  1991				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1991				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1991				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1991					      ENDIF
      8  1991				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1991				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  1991				  -	      ERR
     11  1991					      ENDIF
     12  1991					      LIST	ON
      0  1991					      VAR	__pmcol, 1
      1  1991		       00 ac	   __pmcol    =	TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1991
      4  1991				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1991				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1991				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1991					      ENDIF
      8  1991				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1991				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  1991				  -	      ERR
     11  1991					      ENDIF
     12  1991					      LIST	ON
    458  1991
      0  1991					      VEND	CopySetupForMarker
      1  1991				  -	      IFNCONST	CopySetupForMarker
      2  1991				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  1991				  -	      ERR
      4  1991					      ENDIF
      5  1991		       00 ad	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    460  1991
    461  1991		       a5 80		      lda	squareToDraw
    462  1993		       38		      sec
    463  1994		       a0 0a		      ldy	#10
    464  1996		       e9 0a	   .sub10     sbc	#10
    465  1998		       88		      dey
    466  1999		       b0 fb		      bcs	.sub10
    467  199b		       84 ab		      sty	__oddeven
    468  199d		       69 08		      adc	#8
    469  199f		       85 ac		      sta	__pmcol
    470  19a1		       65 ab		      adc	__oddeven
    471  19a3
    472  19a3		       29 01		      and	#1
    473  19a5		       49 01		      eor	#1
    474  19a7		       f0 02		      beq	.white
    475  19a9		       a9 24		      lda	#36
    476  19ab				   .white
    477  19ab		       85 aa		      sta	__pieceColour	; actually SQUARE black/white
    478  19ad
    479  19ad		       8a		      txa
    480  19ae		       18		      clc
    481  19af		       65 aa		      adc	__pieceColour
    482  19b1		       85 aa		      sta	__pieceColour
    483  19b3
    484  19b3		       a5 ac		      lda	__pmcol
    485  19b5		       29 03		      and	#3
    486  19b7
    487  19b7		       18		      clc
    488  19b8		       65 aa		      adc	__pieceColour
    489  19ba		       a8		      tay
    490  19bb		       60		      rts
    491  19bc
    492  19bc
    493  19bc							;---------------------------------------------------------------------------------------------------
    494  19bc
      0  19bc					      DEF	aiUnDrawTargetSquares
      1  19bc				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  19bc				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  19bc				   aiUnDrawTargetSquares
      4  19bc				   TEMPORARY_VAR SET	Overlay
      5  19bc				   TEMPORARY_OFFSET SET	0
      6  19bc				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  19bc				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    496  19bc					      SUBROUTINE
    497  19bc
      0  19bc					      REFER	AiStateMachine
      1  19bc					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  19bc				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  19bc					      ENDIF
      0  19bc					      VEND	aiUnDrawTargetSquares
      1  19bc				  -	      IFNCONST	aiUnDrawTargetSquares
      2  19bc				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  19bc				  -	      ERR
      4  19bc					      ENDIF
      5  19bc		       00 a8	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    500  19bc
    501  19bc
    502  19bc		       c6 8a		      dec	ccur
    503  19be		       20 b1 f4 	      jsr	setCursorColours
    504  19c1
    505  19c1		       c6 89		      dec	mdelay
    506  19c3		       d0 1c		      bne	.exit
    507  19c5		       a9 01		      lda	#1
    508  19c7		       85 89		      sta	mdelay	; once triggered, runs always
    509  19c9
    510  19c9		       a5 8d		      lda	aiMoveIndex
    511  19cb		       10 09		      bpl	.valid
    512  19cd
    513  19cd		       a9 89		      lda	#RAMBANK_PLY+1
    514  19cf		       85 3e		      sta	SET_BANK_RAM	;@2
      0  19d1					      lda@PLY	moveIndex
      1  19d1		       ad cf f9 	      lda	moveIndex
    516  19d4		       85 8d		      sta	aiMoveIndex
    517  19d6				   .valid
    518  19d6
    519  19d6		       20 3a f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    520  19d9		       a5 8d		      lda	aiMoveIndex
    521  19db		       10 04		      bpl	.exit	; still drawing in this phase
    522  19dd
      0  19dd					      PHASE	AI_SelectStartSquare
      1  19dd		       a9 02		      lda	#AI_SelectStartSquare
      2  19df		       85 8b		      sta	aiState
    524  19e1
    525  19e1		       60	   .exit      rts
    526  19e2
    527  19e2
    528  19e2							;---------------------------------------------------------------------------------------------------
    529  19e2
    530  19e2
      0  19e2					      DEF	aiShowMoveCaptures
      1  19e2				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  19e2				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  19e2				   aiShowMoveCaptures
      4  19e2				   TEMPORARY_VAR SET	Overlay
      5  19e2				   TEMPORARY_OFFSET SET	0
      6  19e2				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  19e2				   FUNCTION_NAME SET	aiShowMoveCaptures
    532  19e2					      SUBROUTINE
    533  19e2
      0  19e2					      REFER	AiStateMachine
      1  19e2					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  19e2				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  19e2					      ENDIF
      0  19e2					      VEND	aiShowMoveCaptures
      1  19e2				  -	      IFNCONST	aiShowMoveCaptures
      2  19e2				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  19e2				  -	      ERR
      4  19e2					      ENDIF
      5  19e2		       00 a8	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    536  19e2
    537  19e2							; draw/undraw ALL captured pieces
    538  19e2							; we should do this an even number of times so that pieces don't disappEOR
    539  19e2
    540  19e2		       c6 8a		      dec	ccur
    541  19e4		       20 b1 f4 	      jsr	setCursorColours
    542  19e7
    543  19e7		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    544  19e9
    545  19e9		       a5 8d		      lda	aiMoveIndex
    546  19eb		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    547  19ed		       a9 89		      lda	#RAMBANK_PLY+1
    548  19ef		       85 3e		      sta	SET_BANK_RAM	;@2
      0  19f1					      lda@PLY	moveIndex
      1  19f1		       ad cf f9 	      lda	moveIndex
    550  19f4		       85 8d		      sta	aiMoveIndex
    551  19f6				   .valid
    552  19f6
    553  19f6							;lda #BANK_showMoveCaptures
    554  19f6							;sta SET_BANK;@0
    555  19f6
    556  19f6		       20 c8 f2 	      jsr	showMoveCaptures	;@0
    557  19f9		       a5 8d		      lda	aiMoveIndex
    558  19fb		       10 06		      bpl	.exit
    559  19fd
    560  19fd		       e6 8e		      inc	aiFlashPhase
    561  19ff
      0  19ff					      PHASE	AI_SlowFlash
      1  19ff		       a9 06		      lda	#AI_SlowFlash
      2  1a01		       85 8b		      sta	aiState
    563  1a03
    564  1a03		       60	   .exit      rts
    565  1a04
    566  1a04
    567  1a04							;---------------------------------------------------------------------------------------------------
    568  1a04
      0  1a04					      DEF	aiSlowFlash
      1  1a04				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  1a04				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  1a04				   aiSlowFlash
      4  1a04				   TEMPORARY_VAR SET	Overlay
      5  1a04				   TEMPORARY_OFFSET SET	0
      6  1a04				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  1a04				   FUNCTION_NAME SET	aiSlowFlash
    570  1a04					      SUBROUTINE
    571  1a04
      0  1a04					      REFER	AiStateMachine
      1  1a04					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1a04				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1a04					      ENDIF
      0  1a04					      VEND	aiSlowFlash
      1  1a04				  -	      IFNCONST	aiSlowFlash
      2  1a04				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  1a04				  -	      ERR
      4  1a04					      ENDIF
      5  1a04		       00 a8	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    574  1a04
    575  1a04							; Joystick button is held down, so we're displaying the available moves
    576  1a04							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    577  1a04
    578  1a04		       c6 8a		      dec	ccur
    579  1a06		       20 b1 f4 	      jsr	setCursorColours
    580  1a09
    581  1a09		       a5 8e		      lda	aiFlashPhase
    582  1a0b		       29 01		      and	#1
    583  1a0d		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    584  1a0f
    585  1a0f		       a5 4c		      lda	INPT4
    586  1a11		       30 0d		      bmi	.butpress	; exit on button release
    587  1a13
    588  1a13				   .notEven
    589  1a13
    590  1a13							; Wait for delay to expire then back and flash 'em again
    591  1a13
    592  1a13		       c6 89		      dec	mdelay
    593  1a15		       10 08		      bpl	.slowWait
    594  1a17
    595  1a17		       a9 14		      lda	#CAP_SPEED
    596  1a19		       85 89		      sta	mdelay
    597  1a1b
      0  1a1b					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  1a1b		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1a1d		       85 8b		      sta	aiState
    599  1a1f
    600  1a1f		       60	   .slowWait  rts
    601  1a20
    602  1a20
    603  1a20		       a9 01	   .butpress  lda	#1
    604  1a22		       85 89		      sta	mdelay
    605  1a24
      0  1a24					      PHASE	AI_UnDrawTargetSquares
      1  1a24		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  1a26		       85 8b		      sta	aiState
    607  1a28		       60		      rts
    608  1a29
    609  1a29
    610  1a29							;---------------------------------------------------------------------------------------------------
    611  1a29
      0  1a29					      DEF	moveCursor
      1  1a29				   SLOT_moveCursor SET	_BANK_SLOT
      2  1a29				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  1a29				   moveCursor
      4  1a29				   TEMPORARY_VAR SET	Overlay
      5  1a29				   TEMPORARY_OFFSET SET	0
      6  1a29				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  1a29				   FUNCTION_NAME SET	moveCursor
    613  1a29					      SUBROUTINE
    614  1a29
      0  1a29					      REFER	aiSelectStartSquare
      1  1a29					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  1a29				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  1a29					      ENDIF
      0  1a29					      REFER	aiSelectDestinationSquare
      1  1a29				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  1a29				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  1a29					      ENDIF
    617  1a29
      0  1a29					      VAR	__newCursor, 1
      1  1a29		       00 a8	   __newCursor =	TEMPORARY_VAR
      2  1a29				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1a29
      4  1a29				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1a29				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1a29				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1a29					      ENDIF
      8  1a29				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1a29				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  1a29				  -	      ERR
     11  1a29					      ENDIF
     12  1a29					      LIST	ON
    619  1a29
      0  1a29					      VEND	moveCursor
      1  1a29				  -	      IFNCONST	moveCursor
      2  1a29				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  1a29				  -	      ERR
      4  1a29					      ENDIF
      5  1a29		       00 a9	   VAREND_moveCursor =	TEMPORARY_VAR
    621  1a29
    622  1a29							; Part (a) move cursor around the board waiting for joystick press
    623  1a29
    624  1a29		       a2 00		      ldx	#0	; delay
    625  1a2b
    626  1a2b		       ad 80 02 	      lda	SWCHA
    627  1a2e		       4a		      lsr
    628  1a2f		       4a		      lsr
    629  1a30		       4a		      lsr
    630  1a31		       4a		      lsr
    631  1a32		       a8		      tay
    632  1a33
    633  1a33		       c9 0f		      cmp	#15
    634  1a35		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
    635  1a37
    636  1a37		       c6 89		      dec	mdelay
    637  1a39		       10 1f		      bpl	.delaym
    638  1a3b
    639  1a3b		       18		      clc
    640  1a3c		       a5 88		      lda	cursorX12
    641  1a3e		       79 d4 f4 	      adc	JoyMoveCursor,y
    642  1a41		       85 a8		      sta	__newCursor
    643  1a43		       a8		      tay
    644  1a44
    645  1a44		       a9 d1		      lda	#RAMBANK_BOARD
    646  1a46		       85 3e		      sta	SET_BANK_RAM	;@3
    647  1a48		       b9 15 fc 	      lda	ValidSquare,y
    648  1a4b		       c9 ff		      cmp	#-1
    649  1a4d		       f0 04		      beq	.invalid
    650  1a4f		       a5 a8		      lda	__newCursor
    651  1a51		       85 88		      sta	cursorX12
    652  1a53				   .invalid
    653  1a53
    654  1a53		       a2 10		      ldx	#CURSOR_MOVE_SPEED
    655  1a55		       86 89	   .cursor    stx	mdelay
    656  1a57		       20 99 f4 	      jsr	setCursorPriority
    657  1a5a		       60	   .delaym    rts
    658  1a5b
    659  1a5b
    660  1a5b							;---------------------------------------------------------------------------------------------------
    661  1a5b
      0  1a5b					      DEF	aiSelectDestinationSquare
      1  1a5b				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  1a5b				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  1a5b				   aiSelectDestinationSquare
      4  1a5b				   TEMPORARY_VAR SET	Overlay
      5  1a5b				   TEMPORARY_OFFSET SET	0
      6  1a5b				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  1a5b				   FUNCTION_NAME SET	aiSelectDestinationSquare
    663  1a5b					      SUBROUTINE
    664  1a5b
      0  1a5b					      REFER	AiStateMachine
      1  1a5b					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1a5b				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1a5b					      ENDIF
      0  1a5b					      VEND	aiSelectDestinationSquare
      1  1a5b				  -	      IFNCONST	aiSelectDestinationSquare
      2  1a5b				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  1a5b				  -	      ERR
      4  1a5b					      ENDIF
      5  1a5b		       00 a8	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    667  1a5b
    668  1a5b							; Piece is selected and now we're looking for a button press on a destination square
    669  1a5b							; we flash the piece on-and-off while we're doing that
    670  1a5b							; Flash the selected piece
    671  1a5b
    672  1a5b		       ad 84 02 	      lda	INTIM
    673  1a5e		       c9 28		      cmp	#ONCEPERFRAME
    674  1a60		       90 0e		      bcc	.exit
    675  1a62
    676  1a62
    677  1a62		       c6 8c		      dec	aiFlashDelay
    678  1a64		       d0 0a		      bne	.exit	; don't flash
    679  1a66		       a9 14		      lda	#CAP_SPEED
    680  1a68		       85 8c		      sta	aiFlashDelay
    681  1a6a
    682  1a6a		       e6 8e		      inc	aiFlashPhase
    683  1a6c
    684  1a6c		       20 be f0 	      jsr	CopySinglePiece	;@0
    685  1a6f		       60		      rts
    686  1a70
    687  1a70				   .exit
    688  1a70		       20 29 f6 	      jsr	moveCursor
    689  1a73
    690  1a73		       ad 84 02 	      lda	INTIM
    691  1a76		       c9 14		      cmp	#20
    692  1a78		       90 39		      bcc	.noButton
    693  1a7a
    694  1a7a
    695  1a7a		       a4 88		      ldy	cursorX12
    696  1a7c		       84 86		      sty	toX12
    697  1a7e
      0  1a7e					      CALL	GetPiece	;@3
      1  1a7e				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1a7e				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1a7e				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1a7e				  -	      ERR
      5  1a7e					      ENDIF
      6  1a7e		       a9 d9		      lda	#BANK_GetPiece
      7  1a80		       85 3f		      sta	SET_BANK
      8  1a82		       20 00 fc 	      jsr	GetPiece
    699  1a85		       20 b1 f4 	      jsr	setCursorColours
    700  1a88
    701  1a88
    702  1a88							; y = valid square
    703  1a88
    704  1a88		       a5 4c		      lda	INPT4
    705  1a8a		       30 27		      bmi	.noButton
    706  1a8c
    707  1a8c		       a5 86		      lda	toX12
    708  1a8e		       c5 85		      cmp	fromX12
    709  1a90		       f0 0d		      beq	.cancel
    710  1a92
    711  1a92		       c0 ff		      cpy	#-1
    712  1a94		       f0 1d		      beq	.noButton	; not a valid square
    713  1a96
    714  1a96		       a5 8e		      lda	aiFlashPhase
    715  1a98		       29 01		      and	#1
    716  1a9a		       f0 13		      beq	.done
    717  1a9c		       85 8c		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    718  1a9e		       60		      rts
    719  1a9f
    720  1a9f				   .cancel
    721  1a9f
    722  1a9f		       a5 8e		      lda	aiFlashPhase
    723  1aa1		       29 01		      and	#1
    724  1aa3		       f0 05		      beq	.doCancel
    725  1aa5
    726  1aa5							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    727  1aa5
    728  1aa5		       a9 01		      lda	#1
    729  1aa7		       85 8c		      sta	aiFlashDelay
    730  1aa9		       60		      rts
    731  1aaa
    732  1aaa
      0  1aaa				   .doCancel  PHASE	AI_ReselectDebounce
      1  1aaa		       a9 0a		      lda	#AI_ReselectDebounce
      2  1aac		       85 8b		      sta	aiState
    734  1aae		       60		      rts
    735  1aaf
      0  1aaf				   .done      PHASE	AI_Quiescent	; destination selected!
      1  1aaf		       a9 09		      lda	#AI_Quiescent
      2  1ab1		       85 8b		      sta	aiState
    737  1ab3		       60	   .noButton  rts
    738  1ab4
    739  1ab4
    740  1ab4
    741  1ab4
    742  1ab4							;---------------------------------------------------------------------------------------------------
    743  1ab4
      0  1ab4					      DEF	aiReselectDebounce
      1  1ab4				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  1ab4				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  1ab4				   aiReselectDebounce
      4  1ab4				   TEMPORARY_VAR SET	Overlay
      5  1ab4				   TEMPORARY_OFFSET SET	0
      6  1ab4				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  1ab4				   FUNCTION_NAME SET	aiReselectDebounce
    745  1ab4					      SUBROUTINE
    746  1ab4
      0  1ab4					      REFER	AiStateMachine
      1  1ab4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ab4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ab4					      ENDIF
      0  1ab4					      VEND	aiReselectDebounce
      1  1ab4				  -	      IFNCONST	aiReselectDebounce
      2  1ab4				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  1ab4				  -	      ERR
      4  1ab4					      ENDIF
      5  1ab4		       00 a8	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    749  1ab4
    750  1ab4							; We've just cancelled the move. Wait for the button to be released
    751  1ab4							; and then go back to selecting a piece to move
    752  1ab4
    753  1ab4		       a5 4c		      lda	INPT4
    754  1ab6		       10 04		      bpl	.exit	; button still pressed, so wait
    755  1ab8
      0  1ab8					      PHASE	AI_SelectStartSquare
      1  1ab8		       a9 02		      lda	#AI_SelectStartSquare
      2  1aba		       85 8b		      sta	aiState
    757  1abc		       60	   .exit      rts
    758  1abd
    759  1abd
    760  1abd							;---------------------------------------------------------------------------------------------------
    761  1abd
      0  1abd					      DEF	aiQuiescent
      1  1abd				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  1abd				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  1abd				   aiQuiescent
      4  1abd				   TEMPORARY_VAR SET	Overlay
      5  1abd				   TEMPORARY_OFFSET SET	0
      6  1abd				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  1abd				   FUNCTION_NAME SET	aiQuiescent
    763  1abd					      SUBROUTINE
    764  1abd
      0  1abd					      REFER	AiStateMachine
      1  1abd					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1abd				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1abd					      ENDIF
      0  1abd					      VEND	aiQuiescent
      1  1abd				  -	      IFNCONST	aiQuiescent
      2  1abd				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  1abd				  -	      ERR
      4  1abd					      ENDIF
      5  1abd		       00 a8	   VAREND_aiQuiescent =	TEMPORARY_VAR
    767  1abd
    768  1abd							; Move has been selected
    769  1abd
    770  1abd		       a9 ff		      lda	#-1
    771  1abf		       85 88		      sta	cursorX12
    772  1ac1
    773  1ac1		       a5 85		      lda	fromX12
    774  1ac3		       85 87		      sta	originX12
      0  1ac5					      CALL	GetPiece	;@3		    ; from the movelist
      1  1ac5				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1ac5				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1ac5				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1ac5				  -	      ERR
      5  1ac5					      ENDIF
      6  1ac5		       a9 d9		      lda	#BANK_GetPiece
      7  1ac7		       85 3f		      sta	SET_BANK
      8  1ac9		       20 00 fc 	      jsr	GetPiece
    776  1acc
    777  1acc		       a4 85		      ldy	fromX12
    778  1ace		       a9 d1		      lda	#RAMBANK_BOARD
    779  1ad0		       85 3e		      sta	SET_BANK_RAM	;@3
    780  1ad2		       b9 79 fc 	      lda	Board,y
    781  1ad5		       45 96		      eor	fromPiece
    782  1ad7		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    783  1ad9		       d0 05		      bne	.promote	; promote a pawn
    784  1adb
      0  1adb					      PHASE	AI_MoveIsSelected
      1  1adb		       a9 14		      lda	#AI_MoveIsSelected
      2  1add		       85 8b		      sta	aiState
    786  1adf		       60		      rts
    787  1ae0
      0  1ae0				   .promote   PHASE	AI_PromotePawnStart
      1  1ae0		       a9 1f		      lda	#AI_PromotePawnStart
      2  1ae2		       85 8b		      sta	aiState
    789  1ae4		       60		      rts
    790  1ae5
    791  1ae5
    792  1ae5							;---------------------------------------------------------------------------------------------------
    793  1ae5
      0  1ae5					      DEF	aiRollPromotionPiece
      1  1ae5				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  1ae5				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  1ae5				   aiRollPromotionPiece
      4  1ae5				   TEMPORARY_VAR SET	Overlay
      5  1ae5				   TEMPORARY_OFFSET SET	0
      6  1ae5				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  1ae5				   FUNCTION_NAME SET	aiRollPromotionPiece
    795  1ae5					      SUBROUTINE
    796  1ae5
      0  1ae5					      REFER	AiStateMachine
      1  1ae5					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ae5				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ae5					      ENDIF
      0  1ae5					      VEND	aiRollPromotionPiece
      1  1ae5				  -	      IFNCONST	aiRollPromotionPiece
      2  1ae5				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  1ae5				  -	      ERR
      4  1ae5					      ENDIF
      5  1ae5		       00 a8	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    799  1ae5
    800  1ae5							; Flash the '?' and wait for an UDLR move
    801  1ae5
    802  1ae5		       ad 84 02 	      lda	INTIM
    803  1ae8		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    804  1aea		       90 28		      bcc	.exit
    805  1aec
    806  1aec		       ad 80 02 	      lda	SWCHA
    807  1aef		       29 f0		      and	#$F0
    808  1af1		       c9 f0		      cmp	#$F0
    809  1af3		       f0 0a		      beq	.nojoy
    810  1af5
    811  1af5		       a9 00		      lda	#0
    812  1af7		       85 8c		      sta	aiFlashDelay
    813  1af9
    814  1af9		       a5 8e		      lda	aiFlashPhase
    815  1afb		       29 01		      and	#1
    816  1afd		       f0 16		      beq	.even
    817  1aff
    818  1aff		       c6 8c	   .nojoy     dec	aiFlashDelay
    819  1b01		       10 11		      bpl	.exit
    820  1b03
    821  1b03		       a9 0a		      lda	#10
    822  1b05		       85 8c		      sta	aiFlashDelay
    823  1b07
    824  1b07		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    825  1b09		       a5 95		      lda	sideToMove
    826  1b0b		       10 02		      bpl	.wtm
    827  1b0d		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    828  1b0f				   .wtm
    829  1b0f		       20 54 fc 	      jsr	showPromoteOptions
    830  1b12
    831  1b12		       e6 8e		      inc	aiFlashPhase
    832  1b14
    833  1b14		       60	   .exit      rts
    834  1b15
    835  1b15
    836  1b15		       a9 03	   .even      lda	#3	; QUEEN
    837  1b17		       85 96		      sta	fromPiece	; cycles as index to NBRQ
    838  1b19
    839  1b19		       e6 8e		      inc	aiFlashPhase
    840  1b1b
    841  1b1b
    842  1b1b		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    843  1b1d		       a5 95		      lda	sideToMove
    844  1b1f		       10 02		      bpl	.whiteToMove
    845  1b21		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    846  1b23				   .whiteToMove
    847  1b23
    848  1b23		       20 54 fc 	      jsr	showPromoteOptions
    849  1b26
      0  1b26					      PHASE	AI_ChooseDebounce
      1  1b26		       a9 22		      lda	#AI_ChooseDebounce
      2  1b28		       85 8b		      sta	aiState
    851  1b2a		       60		      rts
    852  1b2b
    853  1b2b
    854  1b2b
    855  1b2b							;---------------------------------------------------------------------------------------------------
    856  1b2b
      0  1b2b					      DEF	aiMarchA2
      1  1b2b				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  1b2b				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  1b2b				   aiMarchA2
      4  1b2b				   TEMPORARY_VAR SET	Overlay
      5  1b2b				   TEMPORARY_OFFSET SET	0
      6  1b2b				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  1b2b				   FUNCTION_NAME SET	aiMarchA2
    858  1b2b					      SUBROUTINE
    859  1b2b
      0  1b2b					      REFER	AiStateMachine
      1  1b2b					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b2b				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b2b					      ENDIF
    861  1b2b
      0  1b2b					      VEND	aiMarchA2
      1  1b2b				  -	      IFNCONST	aiMarchA2
      2  1b2b				  -	      ECHO	"Incorrect VEND label", aiMarchA2
      3  1b2b				  -	      ERR
      4  1b2b					      ENDIF
      5  1b2b		       00 a8	   VAREND_aiMarchA2 =	TEMPORARY_VAR
    863  1b2b
    864  1b2b							; erase object in new sqare --> blank
    865  1b2b
    866  1b2b		       a4 85		      ldy	fromX12
    867  1b2d		       84 80		      sty	squareToDraw
    868  1b2f
    869  1b2f		       a9 d1		      lda	#RAMBANK_BOARD
    870  1b31		       85 3e		      sta	SET_BANK_RAM	;@3
    871  1b33		       b9 79 fc 	      lda	Board,y
    872  1b36		       f0 03		      beq	.skipbl
    873  1b38		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    874  1b3b
    875  1b3b				   .skipbl
    876  1b3b		       a4 85		      ldy	fromX12
    877  1b3d		       84 a9		      sty	__boardIndex
    878  1b3f
    879  1b3f		       a9 d1		      lda	#RAMBANK_BOARD
    880  1b41		       85 3e		      sta	SET_BANK_RAM	;@3
    881  1b43		       b9 79 fc 	      lda	Board,y
    882  1b46		       85 97		      sta	lastPiece	; what we are overwriting
    883  1b48		       a5 96		      lda	fromPiece
    884  1b4a		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    885  1b4c		       29 df		      and	#~FLAG_ENPASSANT
    886  1b4e		       a4 a9		      ldy	__boardIndex
      0  1b50					      sta@RAM	Board,y	; and what's actually moving there
      1  1b50		       99 79 fe 	      sta	[RAM]+Board,y
    888  1b53
    889  1b53
      0  1b53					      PHASE	AI_MarchB
      1  1b53		       a9 18		      lda	#AI_MarchB
      2  1b55		       85 8b		      sta	aiState
    891  1b57		       60		      rts
    892  1b58
    893  1b58
    894  1b58							;---------------------------------------------------------------------------------------------------
    895  1b58
      0  1b58					      DEF	aiMarchB2
      1  1b58				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  1b58				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  1b58				   aiMarchB2
      4  1b58				   TEMPORARY_VAR SET	Overlay
      5  1b58				   TEMPORARY_OFFSET SET	0
      6  1b58				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  1b58				   FUNCTION_NAME SET	aiMarchB2
    897  1b58					      SUBROUTINE
    898  1b58
      0  1b58					      REFER	AiStateMachine
      1  1b58					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b58				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b58					      ENDIF
      0  1b58					      VEND	aiMarchB2
      1  1b58				  -	      IFNCONST	aiMarchB2
      2  1b58				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  1b58				  -	      ERR
      4  1b58					      ENDIF
      5  1b58		       00 a8	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    901  1b58
    902  1b58		       a4 83		      ldy	lastSquareX12
    903  1b5a		       84 80		      sty	squareToDraw
    904  1b5c
    905  1b5c		       a9 d1		      lda	#RAMBANK_BOARD
    906  1b5e		       85 3e		      sta	SET_BANK_RAM	;@3
    907  1b60		       b9 79 fc 	      lda	Board,y
    908  1b63		       f0 03		      beq	.skipbl2
    909  1b65
    910  1b65		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    911  1b68				   .skipbl2
    912  1b68
    913  1b68		       a5 85		      lda	fromX12
    914  1b6a		       c5 86		      cmp	toX12
    915  1b6c		       f0 09		      beq	xhalt
    916  1b6e
    917  1b6e		       a9 02		      lda	#2	;??? inter-move segment speed (can be 0)
    918  1b70		       85 82		      sta	drawDelay
      0  1b72					      PHASE	AI_MarchToTargetA
      1  1b72		       a9 16		      lda	#AI_MarchToTargetA
      2  1b74		       85 8b		      sta	aiState
    920  1b76
    921  1b76		       60		      rts
    922  1b77
    923  1b77				   xhalt
    924  1b77
    925  1b77							;??? jsr FinaliseMove
    926  1b77
    927  1b77		       a9 04		      lda	#4	; on/off count
    928  1b79		       85 84		      sta	drawCount	; flashing for piece about to move
    929  1b7b		       a9 00		      lda	#0
    930  1b7d		       85 82		      sta	drawDelay
    931  1b7f
      0  1b7f					      PHASE	AI_FinalFlash
      1  1b7f		       a9 1b		      lda	#AI_FinalFlash
      2  1b81		       85 8b		      sta	aiState
    933  1b83		       60		      rts
    934  1b84
    935  1b84
    936  1b84							;---------------------------------------------------------------------------------------------------
    937  1b84
    938  1b84
      0  1b84					      DEF	aiWriteStartPieceBlank
      1  1b84				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  1b84				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  1b84				   aiWriteStartPieceBlank
      4  1b84				   TEMPORARY_VAR SET	Overlay
      5  1b84				   TEMPORARY_OFFSET SET	0
      6  1b84				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  1b84				   FUNCTION_NAME SET	aiWriteStartPieceBlank
    940  1b84					      SUBROUTINE
    941  1b84
      0  1b84					      REFER	AiStateMachine
      1  1b84					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b84				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b84					      ENDIF
      0  1b84					      VEND	aiWriteStartPieceBlank
      1  1b84				  -	      IFNCONST	aiWriteStartPieceBlank
      2  1b84				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  1b84				  -	      ERR
      4  1b84					      ENDIF
      5  1b84		       00 a8	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    944  1b84
    945  1b84							; Flash the piece in-place preparatory to moving it.
    946  1b84							; drawDelay = flash speed
    947  1b84							; drawCount = # of flashes
    948  1b84
    949  1b84
    950  1b84		       a9 04		      lda	#%100
    951  1b86		       85 4a		      sta	CTRLPF
    952  1b88		       a9 02		      lda	#2
    953  1b8a		       85 46		      sta	COLUP0
    954  1b8c
    955  1b8c
    956  1b8c		       a5 82		      lda	drawDelay
    957  1b8e		       f0 03		      beq	deCount
    958  1b90		       c6 82		      dec	drawDelay
    959  1b92		       60		      rts
    960  1b93				   deCount
    961  1b93
    962  1b93		       a5 84		      lda	drawCount
    963  1b95		       f0 0d		      beq	flashDone
    964  1b97		       c6 84		      dec	drawCount
    965  1b99
    966  1b99		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    967  1b9b		       85 82		      sta	drawDelay	; "getting ready to move" flash
    968  1b9d
    969  1b9d		       a5 85		      lda	fromX12
    970  1b9f		       85 80		      sta	squareToDraw
    971  1ba1
    972  1ba1		       4c be f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
    973  1ba4
    974  1ba4				   flashDone
    975  1ba4
    976  1ba4							;lda #2
    977  1ba4							;sta drawDelay
      0  1ba4					      PHASE	AI_MarchToTargetA
      1  1ba4		       a9 16		      lda	#AI_MarchToTargetA
      2  1ba6		       85 8b		      sta	aiState
    979  1ba8		       60		      rts
    980  1ba9
    981  1ba9
    982  1ba9							;---------------------------------------------------------------------------------------------------
    983  1ba9
      0  1ba9					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  1ba9		       03 a9	   .TEMP      =	* - _BANK_START
 BANK_StateMachine (1K) SIZE =  $3a9 , FREE= $57
      2  1ba9					      ECHO	"BANK_StateMachine", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1ba9				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1ba9				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine", " size=", * - ORIGIN
      5  1ba9				  -	      ERR
      6  1ba9					      ENDIF
    985  1ba9
    986  1ba9
    987  1ba9							;---------------------------------------------------------------------------------------------------
    988  1ba9
    989  1ba9							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#2.asm LEVEL 2 PASS 4
      0  1ba9					      include	"BANK_StateMachine@1#2.asm"
      0  1ba9					      SLOT	1
      1  1ba9				  -	      IF	(1 < 0) || (1 > 3)
      2  1ba9				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1ba9				  -	      ERR
      4  1ba9					      ENDIF
      5  1ba9				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1ba9				   _BANK_SLOT SET	1 * 64
      0  1ba9					      NEWBANK	STATEMACHINE2
      1  1eb4 ????				      SEG	STATEMACHINE2
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   STATEMACHINE2_START SET	*
      6  1c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1c00				   STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  1c00
      4  1c00							;---------------------------------------------------------------------------------------------------
      5  1c00
      0  1c00					      DEF	aiChoosePromotePiece
      1  1c00				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  1c00				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  1c00				   aiChoosePromotePiece
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  1c00					      SUBROUTINE
      8  1c00
      0  1c00					      REFER	AiStateMachine
      1  1c00					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c00				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c00					      ENDIF
      0  1c00					      VEND	aiChoosePromotePiece
      1  1c00				  -	      IFNCONST	aiChoosePromotePiece
      2  1c00				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  1c00				  -	      ERR
      4  1c00					      ENDIF
      5  1c00		       00 a8	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
     11  1c00
     12  1c00							; Question-mark phase has exited via joystick direction
     13  1c00							; Now we cycle through the selectable pieces
     14  1c00
     15  1c00		       ad 84 02 	      lda	INTIM
     16  1c03		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
     17  1c05		       90 44		      bcc	.exit
     18  1c07
     19  1c07		       a5 4c		      lda	INPT4
     20  1c09		       30 0a		      bmi	.nobut	; no press
     21  1c0b
     22  1c0b							; button pressed but make sure phase is correct for exit
     23  1c0b
     24  1c0b		       a9 00		      lda	#0
     25  1c0d		       85 8c		      sta	aiFlashDelay
     26  1c0f
     27  1c0f		       a5 8e		      lda	aiFlashPhase
     28  1c11		       29 01		      and	#1
     29  1c13		       f0 37		      beq	.chosen	; button pressed --> selection made
     30  1c15
     31  1c15				   .nobut
     32  1c15		       ad 80 02 	      lda	SWCHA
     33  1c18		       29 f0		      and	#$F0
     34  1c1a		       c9 f0		      cmp	#$F0
     35  1c1c		       f0 17		      beq	.odd	; no direction pressed
     36  1c1e
     37  1c1e		       4a		      lsr
     38  1c1f		       4a		      lsr
     39  1c20		       4a		      lsr
     40  1c21		       4a		      lsr
     41  1c22		       a8		      tay
     42  1c23
     43  1c23							; joystick but make sure phase is correct
     44  1c23
     45  1c23		       a5 8e		      lda	aiFlashPhase
     46  1c25		       4a		      lsr
     47  1c26		       b0 0d		      bcs	.odd	; must wait until piece undrawn
     48  1c28
     49  1c28							; cycle to the next promotable piece (N/B/R/Q)
     50  1c28							; TODO; use joy table for mod instead of just incrementing all the time
     51  1c28
     52  1c28							;clc
     53  1c28		       a5 96		      lda	fromPiece
     54  1c2a		       79 c4 f4 	      adc	JoyCombined,y
     55  1c2d		       29 03		      and	#3
     56  1c2f		       85 96		      sta	fromPiece
     57  1c31
      0  1c31					      PHASE	AI_ChooseDebounce	; wait for release
      1  1c31		       a9 22		      lda	#AI_ChooseDebounce
      2  1c33		       85 8b		      sta	aiState
     59  1c35
     60  1c35		       c6 8c	   .odd       dec	aiFlashDelay
     61  1c37		       10 12		      bpl	.exit
     62  1c39
     63  1c39		       a9 0a	   .force     lda	#10
     64  1c3b		       85 8c		      sta	aiFlashDelay
     65  1c3d
     66  1c3d		       e6 8e		      inc	aiFlashPhase
     67  1c3f
     68  1c3f		       a4 96		      ldy	fromPiece
     69  1c41		       be 6b f4 	      ldx	promotePiece,y
      0  1c44					      CALL	showPromoteOptions	;@3
      1  1c44				  -	      IF	SLOT_showPromoteOptions == _BANK_SLOT
      2  1c44				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1c44				  -	      ECHO	"Cannot switch bank in use for", showPromoteOptions
      4  1c44				  -	      ERR
      5  1c44					      ENDIF
      6  1c44		       a9 d9		      lda	#BANK_showPromoteOptions
      7  1c46		       85 3f		      sta	SET_BANK
      8  1c48		       20 54 fc 	      jsr	showPromoteOptions
     71  1c4b
     72  1c4b		       60	   .exit      rts
     73  1c4c
     74  1c4c
     75  1c4c				   .chosen
     76  1c4c		       a5 96		      lda	fromPiece
     77  1c4e		       29 0f		      and	#PIECE_MASK
     78  1c50		       aa		      tax
     79  1c51
     80  1c51		       bd 6f f4 	      lda	promoteType,x
     81  1c54		       85 96		      sta	fromPiece
     82  1c56
     83  1c56		       a4 86		      ldy	toX12
     84  1c58		       a9 d1		      lda	#RAMBANK_BOARD
     85  1c5a		       85 3e		      sta	SET_BANK_RAM	;@3
     86  1c5c		       b9 79 fc 	      lda	Board,y
     87  1c5f		       29 0f		      and	#PIECE_MASK
     88  1c61		       f0 03		      beq	.nothing
     89  1c63
     90  1c63		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
     91  1c66
      0  1c66				   .nothing   PHASE	AI_MoveIsSelected
      1  1c66		       a9 14		      lda	#AI_MoveIsSelected
      2  1c68		       85 8b		      sta	aiState
     93  1c6a		       60		      rts
     94  1c6b
      0  1c6b					      ALLOCATE	promotePiece, 4
      0  1c6b					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1c6b					      LIST	ON
      0  1c6b					      DEF	promotePiece
      1  1c6b				   SLOT_promotePiece SET	_BANK_SLOT
      2  1c6b				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  1c6b				   promotePiece
      4  1c6b				   TEMPORARY_VAR SET	Overlay
      5  1c6b				   TEMPORARY_OFFSET SET	0
      6  1c6b				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  1c6b				   FUNCTION_NAME SET	promotePiece
     96  1c6b		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
     97  1c6c		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
     98  1c6d		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
     99  1c6e		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    100  1c6f
      0  1c6f					      ALLOCATE	promoteType,4
      0  1c6f					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1c6f					      LIST	ON
      0  1c6f					      DEF	promoteType
      1  1c6f				   SLOT_promoteType SET	_BANK_SLOT
      2  1c6f				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  1c6f				   promoteType
      4  1c6f				   TEMPORARY_VAR SET	Overlay
      5  1c6f				   TEMPORARY_OFFSET SET	0
      6  1c6f				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  1c6f				   FUNCTION_NAME SET	promoteType
    102  1c6f		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    103  1c73
    104  1c73
    105  1c73							;---------------------------------------------------------------------------------------------------
    106  1c73
      0  1c73					      DEF	aiChooseDebounce
      1  1c73				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  1c73				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  1c73				   aiChooseDebounce
      4  1c73				   TEMPORARY_VAR SET	Overlay
      5  1c73				   TEMPORARY_OFFSET SET	0
      6  1c73				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  1c73				   FUNCTION_NAME SET	aiChooseDebounce
    108  1c73					      SUBROUTINE
    109  1c73
      0  1c73					      REFER	AiStateMachine
      1  1c73					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c73				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c73					      ENDIF
      0  1c73					      VEND	aiChooseDebounce
      1  1c73				  -	      IFNCONST	aiChooseDebounce
      2  1c73				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  1c73				  -	      ERR
      4  1c73					      ENDIF
      5  1c73		       00 a8	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    112  1c73
    113  1c73							; We've changed promotion piece, but wait for joystick to be released
    114  1c73
    115  1c73		       ad 80 02 	      lda	SWCHA
    116  1c76		       29 f0		      and	#$F0
    117  1c78		       c9 f0		      cmp	#$F0
    118  1c7a		       d0 08		      bne	.exit	; wait while joystick still pressed
    119  1c7c
    120  1c7c		       a9 01		      lda	#1
    121  1c7e		       85 8c		      sta	aiFlashDelay
    122  1c80
      0  1c80					      PHASE	AI_ChoosePromotePiece
      1  1c80		       a9 21		      lda	#AI_ChoosePromotePiece
      2  1c82		       85 8b		      sta	aiState
    124  1c84		       60	   .exit      rts
    125  1c85
    126  1c85
    127  1c85							;---------------------------------------------------------------------------------------------------
    128  1c85
      0  1c85					      DEF	aiDelayAfterMove
      1  1c85				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  1c85				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  1c85				   aiDelayAfterMove
      4  1c85				   TEMPORARY_VAR SET	Overlay
      5  1c85				   TEMPORARY_OFFSET SET	0
      6  1c85				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  1c85				   FUNCTION_NAME SET	aiDelayAfterMove
    130  1c85					      SUBROUTINE
    131  1c85
      0  1c85					      REFER	AiStateMachine
      1  1c85					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c85				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c85					      ENDIF
      0  1c85					      VEND	aiDelayAfterMove
      1  1c85				  -	      IFNCONST	aiDelayAfterMove
      2  1c85				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  1c85				  -	      ERR
      4  1c85					      ENDIF
      5  1c85		       00 a8	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    134  1c85
    135  1c85		       a9 32		      lda	#50
    136  1c87		       85 8c		      sta	aiFlashDelay
      0  1c89					      PHASE	AI_DelayAfterMove2
      1  1c89		       a9 26		      lda	#AI_DelayAfterMove2
      2  1c8b		       85 8b		      sta	aiState
    138  1c8d		       60	   .exit      rts
    139  1c8e
    140  1c8e
    141  1c8e							;---------------------------------------------------------------------------------------------------
    142  1c8e
      0  1c8e					      DEF	aiDelayAfterMove2
      1  1c8e				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  1c8e				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  1c8e				   aiDelayAfterMove2
      4  1c8e				   TEMPORARY_VAR SET	Overlay
      5  1c8e				   TEMPORARY_OFFSET SET	0
      6  1c8e				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  1c8e				   FUNCTION_NAME SET	aiDelayAfterMove2
    144  1c8e					      SUBROUTINE
    145  1c8e
      0  1c8e					      REFER	AiStateMachine
      1  1c8e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c8e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c8e					      ENDIF
      0  1c8e					      VEND	aiDelayAfterMove
      1  1c8e				  -	      IFNCONST	aiDelayAfterMove
      2  1c8e				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  1c8e				  -	      ERR
      4  1c8e					      ENDIF
      5  1c8e		       00 a8	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    148  1c8e
    149  1c8e		       c6 8c		      dec	aiFlashDelay
    150  1c90		       d0 04		      bne	.exit
      0  1c92					      PHASE	AI_MoveIsSelected
      1  1c92		       a9 14		      lda	#AI_MoveIsSelected
      2  1c94		       85 8b		      sta	aiState
    152  1c96		       60	   .exit      rts
    153  1c97
    154  1c97
    155  1c97							;---------------------------------------------------------------------------------------------------
    156  1c97
      0  1c97					      DEF	aiDelayAfterPlaced
      1  1c97				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  1c97				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  1c97				   aiDelayAfterPlaced
      4  1c97				   TEMPORARY_VAR SET	Overlay
      5  1c97				   TEMPORARY_OFFSET SET	0
      6  1c97				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  1c97				   FUNCTION_NAME SET	aiDelayAfterPlaced
    158  1c97					      SUBROUTINE
    159  1c97
      0  1c97					      REFER	AiStateMachine
      1  1c97					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c97				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c97					      ENDIF
      0  1c97					      VEND	aiDelayAfterPlaced
      1  1c97				  -	      IFNCONST	aiDelayAfterPlaced
      2  1c97				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  1c97				  -	      ERR
      4  1c97					      ENDIF
      5  1c97		       00 a8	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
    162  1c97
    163  1c97		       a2 4b		      ldx	#75	; delay after human move
    164  1c99		       a5 95		      lda	sideToMove
    165  1c9b		       30 02		      bmi	.computer
    166  1c9d		       a2 01		      ldx	#1	; delay after computer move
    167  1c9f		       86 8c	   .computer  stx	aiFlashDelay
    168  1ca1
      0  1ca1					      PHASE	AI_DelayAfterPlaced2
      1  1ca1		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  1ca3		       85 8b		      sta	aiState
    170  1ca5		       60		      rts
    171  1ca6
    172  1ca6
    173  1ca6							;---------------------------------------------------------------------------------------------------
    174  1ca6
      0  1ca6					      DEF	aiDelayAfterPlaced2
      1  1ca6				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  1ca6				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  1ca6				   aiDelayAfterPlaced2
      4  1ca6				   TEMPORARY_VAR SET	Overlay
      5  1ca6				   TEMPORARY_OFFSET SET	0
      6  1ca6				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  1ca6				   FUNCTION_NAME SET	aiDelayAfterPlaced2
    176  1ca6					      SUBROUTINE
    177  1ca6
      0  1ca6					      REFER	AiStateMachine
      1  1ca6					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ca6				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ca6					      ENDIF
      0  1ca6					      VEND	aiDelayAfterPlaced2
      1  1ca6				  -	      IFNCONST	aiDelayAfterPlaced2
      2  1ca6				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced2
      3  1ca6				  -	      ERR
      4  1ca6					      ENDIF
      5  1ca6		       00 a8	   VAREND_aiDelayAfterPlaced2 =	TEMPORARY_VAR
    180  1ca6
    181  1ca6		       c6 8c		      dec	aiFlashDelay
    182  1ca8		       d0 04		      bne	.exit
    183  1caa
    184  1caa							;SWAP
    185  1caa
      0  1caa					      PHASE	AI_GenerateMoves
      1  1caa		       a9 12		      lda	#AI_GenerateMoves
      2  1cac		       85 8b		      sta	aiState
    187  1cae		       60	   .exit      rts
    188  1caf
    189  1caf
    190  1caf							;---------------------------------------------------------------------------------------------------
    191  1caf
      0  1caf					      DEF	aiMarchToTargetB
      1  1caf				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  1caf				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  1caf				   aiMarchToTargetB
      4  1caf				   TEMPORARY_VAR SET	Overlay
      5  1caf				   TEMPORARY_OFFSET SET	0
      6  1caf				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  1caf				   FUNCTION_NAME SET	aiMarchToTargetB
    193  1caf					      SUBROUTINE
    194  1caf
      0  1caf					      REFER	AiStateMachine
      1  1caf					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1caf				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1caf					      ENDIF
      0  1caf					      VEND	aiMarchToTargetB
      1  1caf				  -	      IFNCONST	aiMarchToTargetB
      2  1caf				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  1caf				  -	      ERR
      4  1caf					      ENDIF
      5  1caf		       00 a8	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    197  1caf
    198  1caf							; now we want to undraw the piece in the old square
    199  1caf
    200  1caf		       a5 82		      lda	drawDelay
    201  1cb1		       f0 03		      beq	.stepOne
    202  1cb3		       c6 82		      dec	drawDelay
    203  1cb5		       60		      rts
    204  1cb6
    205  1cb6				   .stepOne
    206  1cb6		       a5 83		      lda	lastSquareX12
    207  1cb8		       85 80		      sta	squareToDraw
    208  1cba
    209  1cba		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    210  1cbd
    211  1cbd		       a4 83		      ldy	lastSquareX12
    212  1cbf		       a5 98		      lda	previousPiece
    213  1cc1
    214  1cc1		       a2 d1		      ldx	#RAMBANK_BOARD
    215  1cc3		       86 3e		      stx	SET_BANK_RAM	;@3
      0  1cc5					      sta@RAM	Board,y	; and what's actually moving there
      1  1cc5		       99 79 fe 	      sta	[RAM]+Board,y
    217  1cc8
    218  1cc8		       a5 97		      lda	lastPiece
    219  1cca		       85 98		      sta	previousPiece
    220  1ccc
      0  1ccc					      PHASE	AI_MarchB2
      1  1ccc		       a9 1a		      lda	#AI_MarchB2
      2  1cce		       85 8b		      sta	aiState
    222  1cd0		       60		      rts
    223  1cd1
    224  1cd1
    225  1cd1							;---------------------------------------------------------------------------------------------------
    226  1cd1
      0  1cd1					      DEF	aiPromotePawnStart
      1  1cd1				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  1cd1				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  1cd1				   aiPromotePawnStart
      4  1cd1				   TEMPORARY_VAR SET	Overlay
      5  1cd1				   TEMPORARY_OFFSET SET	0
      6  1cd1				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  1cd1				   FUNCTION_NAME SET	aiPromotePawnStart
    228  1cd1					      SUBROUTINE
    229  1cd1
      0  1cd1					      REFER	AiStateMachine
      1  1cd1					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cd1				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cd1					      ENDIF
      0  1cd1					      VEND	aiPromotePawnStart
      1  1cd1				  -	      IFNCONST	aiPromotePawnStart
      2  1cd1				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  1cd1				  -	      ERR
      4  1cd1					      ENDIF
      5  1cd1		       00 a8	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    232  1cd1
    233  1cd1
    234  1cd1		       ad 84 02 	      lda	INTIM
    235  1cd4		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    236  1cd6		       90 1c		      bcc	.exit
    237  1cd8
    238  1cd8		       a9 00		      lda	#0
    239  1cda		       85 8e		      sta	aiFlashPhase
    240  1cdc		       85 8c		      sta	aiFlashDelay
    241  1cde
    242  1cde		       a4 86		      ldy	toX12
    243  1ce0		       84 80		      sty	squareToDraw
    244  1ce2
    245  1ce2		       a9 d1		      lda	#RAMBANK_BOARD
    246  1ce4		       85 3e		      sta	SET_BANK_RAM	;@3
    247  1ce6		       b9 79 fc 	      lda	Board,y
    248  1ce9		       29 0f		      and	#PIECE_MASK
    249  1ceb		       f0 03		      beq	.empty
    250  1ced
    251  1ced		       20 be f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    252  1cf0
      0  1cf0				   .empty     PHASE	AI_RollPromotionPiece
      1  1cf0		       a9 20		      lda	#AI_RollPromotionPiece
      2  1cf2		       85 8b		      sta	aiState
    254  1cf4		       60	   .exit      rts
    255  1cf5
    256  1cf5
    257  1cf5							;---------------------------------------------------------------------------------------------------
    258  1cf5
      0  1cf5					      DEF	aiGenerateMoves
      1  1cf5				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  1cf5				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  1cf5				   aiGenerateMoves
      4  1cf5				   TEMPORARY_VAR SET	Overlay
      5  1cf5				   TEMPORARY_OFFSET SET	0
      6  1cf5				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  1cf5				   FUNCTION_NAME SET	aiGenerateMoves
    260  1cf5					      SUBROUTINE
    261  1cf5
      0  1cf5					      REFER	AiStateMachine
      1  1cf5					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cf5				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cf5					      ENDIF
      0  1cf5					      VEND	aiGenerateMoves
      1  1cf5				  -	      IFNCONST	aiGenerateMoves
      2  1cf5				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  1cf5				  -	      ERR
      4  1cf5					      ENDIF
      5  1cf5		       00 a8	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    264  1cf5
    265  1cf5		       a5 86		      lda	toX12
    266  1cf7		       85 80		      sta	squareToDraw	; for showing move (display square)
    267  1cf9
    268  1cf9		       a6 95		      ldx	sideToMove
    269  1cfb		       10 05		      bpl	.player
    270  1cfd
    271  1cfd
      0  1cfd				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  1cfd		       a9 13		      lda	#AI_ComputerMove
      2  1cff		       85 8b		      sta	aiState
    273  1d01		       60		      rts
    274  1d02
    275  1d02
      0  1d02				   .player    PHASE	AI_StartMoveGen
      1  1d02		       a9 0b		      lda	#AI_StartMoveGen
      2  1d04		       85 8b		      sta	aiState
    277  1d06		       60		      rts
    278  1d07
    279  1d07
    280  1d07							;---------------------------------------------------------------------------------------------------
    281  1d07
      0  1d07					      DEF	aiStepMoveGen
      1  1d07				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  1d07				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  1d07				   aiStepMoveGen
      4  1d07				   TEMPORARY_VAR SET	Overlay
      5  1d07				   TEMPORARY_OFFSET SET	0
      6  1d07				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  1d07				   FUNCTION_NAME SET	aiStepMoveGen
    283  1d07					      SUBROUTINE
    284  1d07
      0  1d07					      REFER	AiStateMachine
      1  1d07					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1d07				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1d07					      ENDIF
      0  1d07					      VEND	aiStepMoveGen
      1  1d07				  -	      IFNCONST	aiStepMoveGen
      2  1d07				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  1d07				  -	      ERR
      4  1d07					      ENDIF
      5  1d07		       00 a8	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    287  1d07
    288  1d07		       a5 87		      lda	originX12	; location of cursor (show move)
    289  1d09		       85 88		      sta	cursorX12
      0  1d0b					      PHASE	AI_BeginSelectMovePhase
      1  1d0b		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  1d0d		       85 8b		      sta	aiState
    291  1d0f		       60		      rts
    292  1d10
    293  1d10
    294  1d10							;---------------------------------------------------------------------------------------------------
    295  1d10
    296  1e00		       00 00 00 00*	      align	256	; TODO?
      0  1e00					      DEF	PositionSprites
      1  1e00				   SLOT_PositionSprites SET	_BANK_SLOT
      2  1e00				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  1e00				   PositionSprites
      4  1e00				   TEMPORARY_VAR SET	Overlay
      5  1e00				   TEMPORARY_OFFSET SET	0
      6  1e00				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  1e00				   FUNCTION_NAME SET	PositionSprites
    298  1e00					      SUBROUTINE
    299  1e00
      0  1e00					      REFER	StartupBankReset
      1  1e00				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1e00				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1e00					      ENDIF
      0  1e00					      VEND	PositionSprites
      1  1e00				  -	      IFNCONST	PositionSprites
      2  1e00				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  1e00				  -	      ERR
      4  1e00					      ENDIF
      5  1e00		       00 a6	   VAREND_PositionSprites =	TEMPORARY_VAR
    302  1e00
    303  1e00
    304  1e00		       a5 88		      lda	cursorX12
    305  1e02		       38		      sec
    306  1e03		       e9 0a	   .sub10     sbc	#10
    307  1e05		       b0 fc		      bcs	.sub10
    308  1e07		       69 08		      adc	#8
    309  1e09		       a8		      tay
    310  1e0a
    311  1e0a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    312  1e0c
    313  1e0c		       b9 30 f6 	      lda	colToPixel,y
    314  1e0f
    315  1e0f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    316  1e10		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    317  1e12		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    318  1e14
    319  1e14		       a8		      tay
    320  1e15		       b9 30 f5 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    321  1e18		       85 60		      sta	HMP0
    322  1e1a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    323  1e1c
    324  1e1c		       85 42		      sta	WSYNC
    325  1e1e		       85 6a		      sta	HMOVE
    326  1e20
    327  1e20		       60		      rts
    328  1e21
    329  1e21							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    330  1e21							; fine adjustment value. This table is on a page boundary to guarantee the processor
    331  1e21							; will cross a page boundary and waste a cycle in order to be at the precise position
    332  1e21							; for a RESP0,x write
    333  1e21
    334  1e21				   fineAdjustBegin
    335  1e21
    336  1e21		       70		      DC.B	%01110000	; Left 7
    337  1e22		       60		      DC.B	%01100000	; Left 6
    338  1e23		       50		      DC.B	%01010000	; Left 5
    339  1e24		       40		      DC.B	%01000000	; Left 4
    340  1e25		       30		      DC.B	%00110000	; Left 3
    341  1e26		       20		      DC.B	%00100000	; Left 2
    342  1e27		       10		      DC.B	%00010000	; Left 1
    343  1e28		       00		      DC.B	%00000000	; No movement.
    344  1e29		       f0		      DC.B	%11110000	; Right 1
    345  1e2a		       e0		      DC.B	%11100000	; Right 2
    346  1e2b		       d0		      DC.B	%11010000	; Right 3
    347  1e2c		       c0		      DC.B	%11000000	; Right 4
    348  1e2d		       b0		      DC.B	%10110000	; Right 5
    349  1e2e		       a0		      DC.B	%10100000	; Right 6
    350  1e2f		       90		      DC.B	%10010000	; Right 7
    351  1e30
    352  1e30		       f5 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    353  1e30
    354  1e30
      0  1e30					      ALLOCATE	colToPixel, 8
      0  1e30					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1e30					      LIST	ON
      0  1e30					      DEF	colToPixel
      1  1e30				   SLOT_colToPixel SET	_BANK_SLOT
      2  1e30				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  1e30				   colToPixel
      4  1e30				   TEMPORARY_VAR SET	Overlay
      5  1e30				   TEMPORARY_OFFSET SET	0
      6  1e30				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  1e30				   FUNCTION_NAME SET	colToPixel
    356  1e30		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    357  1e38
    358  1e38
    359  1e38							;---------------------------------------------------------------------------------------------------
    360  1e38
      0  1e38					      DEF	aiMarchToTargetA
      1  1e38				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  1e38				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  1e38				   aiMarchToTargetA
      4  1e38				   TEMPORARY_VAR SET	Overlay
      5  1e38				   TEMPORARY_OFFSET SET	0
      6  1e38				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  1e38				   FUNCTION_NAME SET	aiMarchToTargetA
    362  1e38					      SUBROUTINE
    363  1e38
      0  1e38					      REFER	AiStateMachine
      1  1e38					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e38					      ENDIF
    365  1e38
      0  1e38					      VAR	__fromRow, 1
      1  1e38		       00 a8	   __fromRow  =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
      0  1e38					      VAR	__boardIndex, 1
      1  1e38		       00 a9	   __boardIndex =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
      0  1e38					      VAR	__fromCol, 1
      1  1e38		       00 aa	   __fromCol  =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
      0  1e38					      VAR	__toCol, 1
      1  1e38		       00 ab	   __toCol    =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
    370  1e38
      0  1e38					      VEND	aiMarchToTargetA
      1  1e38				  -	      IFNCONST	aiMarchToTargetA
      2  1e38				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  1e38				  -	      ERR
      4  1e38					      ENDIF
      5  1e38		       00 ac	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    372  1e38
    373  1e38
    374  1e38		       a5 82		      lda	drawDelay
    375  1e3a		       f0 03		      beq	.nodelay
    376  1e3c		       c6 82		      dec	drawDelay
    377  1e3e		       60		      rts
    378  1e3f				   .nodelay
    379  1e3f
    380  1e3f							; Now we calculate move to new square
    381  1e3f
    382  1e3f		       a5 85		      lda	fromX12
    383  1e41		       c5 86		      cmp	toX12
    384  1e43		       f0 44		      beq	.unmovedx
    385  1e45		       85 83		      sta	lastSquareX12
    386  1e47
    387  1e47		       38		      sec
    388  1e48		       a2 fd		      ldx	#-3
    389  1e4a		       e9 0a	   .sub10     sbc	#10
    390  1e4c		       e8		      inx
    391  1e4d		       b0 fb		      bcs	.sub10
    392  1e4f		       69 08		      adc	#8
    393  1e51		       85 aa		      sta	__fromCol
    394  1e53		       86 a8		      stx	__fromRow
    395  1e55
    396  1e55		       a5 86		      lda	toX12
    397  1e57		       38		      sec
    398  1e58		       a2 fd		      ldx	#-3
    399  1e5a		       e9 0a	   .sub10b    sbc	#10
    400  1e5c		       e8		      inx
    401  1e5d		       b0 fb		      bcs	.sub10b
    402  1e5f		       69 08		      adc	#8
    403  1e61		       85 ab		      sta	__toCol
    404  1e63
    405  1e63
    406  1e63		       e4 a8		      cpx	__fromRow
    407  1e65		       f0 13		      beq	.rowDone
    408  1e67
    409  1e67		       b0 0a		      bcs	.incRow
    410  1e69
    411  1e69		       38		      sec
    412  1e6a		       a5 85		      lda	fromX12
    413  1e6c		       e9 0a		      sbc	#10
    414  1e6e		       85 85		      sta	fromX12
    415  1e70		       4c 7a f6 	      jmp	.rowDone
    416  1e73
    417  1e73		       18	   .incRow    clc
    418  1e74		       a5 85		      lda	fromX12
    419  1e76		       69 0a		      adc	#10
    420  1e78		       85 85		      sta	fromX12
    421  1e7a
    422  1e7a				   .rowDone
    423  1e7a
    424  1e7a		       a5 ab		      lda	__toCol
    425  1e7c		       c5 aa		      cmp	__fromCol
    426  1e7e		       f0 09		      beq	.colDone
    427  1e80
    428  1e80		       b0 05		      bcs	.incCol
    429  1e82
    430  1e82		       c6 85		      dec	fromX12
    431  1e84		       4c 89 f6 	      jmp	.colDone
    432  1e87
    433  1e87		       e6 85	   .incCol    inc	fromX12
    434  1e89				   .colDone
    435  1e89				   .unmovedx
    436  1e89
    437  1e89		       a5 87		      lda	originX12
    438  1e8b		       85 88		      sta	cursorX12
    439  1e8d
      0  1e8d					      PHASE	AI_MarchA2
      1  1e8d		       a9 17		      lda	#AI_MarchA2
      2  1e8f		       85 8b		      sta	aiState
    441  1e91		       60		      rts
    442  1e92
    443  1e92
    444  1e92							;---------------------------------------------------------------------------------------------------
    445  1e92
      0  1e92					      DEF	aiFinalFlash
      1  1e92				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  1e92				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  1e92				   aiFinalFlash
      4  1e92				   TEMPORARY_VAR SET	Overlay
      5  1e92				   TEMPORARY_OFFSET SET	0
      6  1e92				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  1e92				   FUNCTION_NAME SET	aiFinalFlash
    447  1e92					      SUBROUTINE
    448  1e92
      0  1e92					      REFER	AiStateMachine
      1  1e92					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e92				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e92					      ENDIF
      0  1e92					      VEND	aiFinalFlash
      1  1e92				  -	      IFNCONST	aiFinalFlash
      2  1e92				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  1e92				  -	      ERR
      4  1e92					      ENDIF
      5  1e92		       00 a8	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    451  1e92
    452  1e92							; Piece has finished the animated move and is now in destination square.
    453  1e92							; Flash the piece
    454  1e92
    455  1e92		       a5 82		      lda	drawDelay
    456  1e94		       f0 03		      beq	.deCount
    457  1e96		       c6 82		      dec	drawDelay
    458  1e98		       60		      rts
    459  1e99
    460  1e99		       a5 84	   .deCount   lda	drawCount
    461  1e9b		       f0 0e		      beq	.flashDone2
    462  1e9d		       c6 84		      dec	drawCount
    463  1e9f
    464  1e9f		       a9 0a		      lda	#10
    465  1ea1		       85 82		      sta	drawDelay	; "getting ready to move" flash
    466  1ea3
    467  1ea3		       a5 85		      lda	fromX12
    468  1ea5		       85 80		      sta	squareToDraw
    469  1ea7
    470  1ea7		       20 be f0 	      jsr	CopySinglePiece	;@0
    471  1eaa		       60		      rts
    472  1eab
    473  1eab				   .flashDone2
    474  1eab
    475  1eab		       a9 64		      lda	#100
    476  1ead		       85 8c		      sta	aiFlashDelay
    477  1eaf
      0  1eaf					      PHASE	AI_SpecialMoveFixup
      1  1eaf		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  1eb1		       85 8b		      sta	aiState
    479  1eb3		       60		      rts
    480  1eb4
    481  1eb4
    482  1eb4							;---------------------------------------------------------------------------------------------------
    483  1eb4
    484  1eb4
      0  1eb4					      CHECK_BANK_SIZE	"BANK_StateMachine2"
      1  1eb4		       02 b4	   .TEMP      =	* - _BANK_START
 BANK_StateMachine2 (1K) SIZE =  $2b4 , FREE= $14c
      2  1eb4					      ECHO	"BANK_StateMachine2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1eb4				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1eb4				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine2", " size=", * - ORIGIN
      5  1eb4				  -	      ERR
      6  1eb4					      ENDIF
    486  1eb4
    487  1eb4
    488  1eb4							;---------------------------------------------------------------------------------------------------
    489  1eb4
    490  1eb4							; EOF
------- FILE ./chess.asm
------- FILE piece_graphics.asm LEVEL 2 PASS 4
      0  1eb4					      include	"piece_graphics.asm"
      1  1eb4							; Import the graphics definitions generated by ConvertChessPieces.py
      2  1eb4
      0  1eb4					      SLOT	2
      1  1eb4				  -	      IF	(2 < 0) || (2 > 3)
      2  1eb4				  -	      ECHO	"Illegal bank address/segment location", 2
      3  1eb4				  -	      ERR
      4  1eb4					      ENDIF
      5  1eb4				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  1eb4				   _BANK_SLOT SET	2 * 64
      0  1eb4					      NEWBANK	PIECES_0
      1  23d8 ????				      SEG	PIECES_0
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   PIECES_0_START SET	*
      6  2000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2000				   PIECES_0   SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + 1024
      5  2000
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2000					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  2000					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  2000					      LIST	ON
      0  2000					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  2000				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2000				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2000				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  2000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  2018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  2030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2048					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  2048					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  2048					      LIST	ON
      0  2048					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  2048				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2048				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2048				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  2048				   TEMPORARY_VAR SET	Overlay
      5  2048				   TEMPORARY_OFFSET SET	0
      6  2048				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2048				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  2048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2090					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  2090					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  2090					      LIST	ON
      0  2090					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  2090				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2090				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2090				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  2090				   TEMPORARY_VAR SET	Overlay
      5  2090				   TEMPORARY_OFFSET SET	0
      6  2090				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2090				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  2090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  20a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  20c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  20d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  20d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  2100					      LIST	ON
      0  2100					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  2100				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2100				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2100				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  2100				   TEMPORARY_VAR SET	Overlay
      5  2100				   TEMPORARY_OFFSET SET	0
      6  2100				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2100				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  2100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2148					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  2148					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  2148					      LIST	ON
      0  2148					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  2148				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2148				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2148				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  2148				   TEMPORARY_VAR SET	Overlay
      5  2148				   TEMPORARY_OFFSET SET	0
      6  2148				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2148				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  2148		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2190					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  2190					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  2190					      LIST	ON
      0  2190					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  2190				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2190				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2190				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  2190				   TEMPORARY_VAR SET	Overlay
      5  2190				   TEMPORARY_OFFSET SET	0
      6  2190				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2190				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  2190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  21a8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  21c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  21d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  21d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  2200					      LIST	ON
      0  2200					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  2200				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2200				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2200				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  2200				   TEMPORARY_VAR SET	Overlay
      5  2200				   TEMPORARY_OFFSET SET	0
      6  2200				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2200				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  2200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2218		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2230		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2248					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  2248					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  2248					      LIST	ON
      0  2248					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  2248				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2248				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2248				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  2248				   TEMPORARY_VAR SET	Overlay
      5  2248				   TEMPORARY_OFFSET SET	0
      6  2248				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2248				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  2248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2278		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2290					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2290					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2290					      LIST	ON
      0  2290					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  2290				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2290				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2290				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  2290				   TEMPORARY_VAR SET	Overlay
      5  2290				   TEMPORARY_OFFSET SET	0
      6  2290				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2290				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  2290		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  22a8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  22c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  22d8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  22d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2300					      LIST	ON
      0  2300					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  2300				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2300				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2300				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  2300				   TEMPORARY_VAR SET	Overlay
      5  2300				   TEMPORARY_OFFSET SET	0
      6  2300				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2300				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  2300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2318		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2348					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2348					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2348					      LIST	ON
      0  2348					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  2348				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2348				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2348				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  2348				   TEMPORARY_VAR SET	Overlay
      5  2348				   TEMPORARY_OFFSET SET	0
      6  2348				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2348				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  2348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2360		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2378		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2390					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2390					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2390					      LIST	ON
      0  2390					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  2390				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2390				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2390				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  2390				   TEMPORARY_VAR SET	Overlay
      5  2390				   TEMPORARY_OFFSET SET	0
      6  2390				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2390				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  2390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  23a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  23c0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  23d8					      CHECK_BANK_SIZE	"PIECES_0 (1K)"
      1  23d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_0 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  23d8					      ECHO	"PIECES_0 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  23d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  23d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_0 (1K)", " size=", * - ORIGIN
      5  23d8				  -	      ERR
      6  23d8					      ENDIF
     19  23d8
      0  23d8					      SLOT	2
      1  23d8				  -	      IF	(2 < 0) || (2 > 3)
      2  23d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  23d8				  -	      ERR
      4  23d8					      ENDIF
      5  23d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  23d8				   _BANK_SLOT SET	2 * 64
      0  23d8					      NEWBANK	PIECES_1
      1  27d8 ????				      SEG	PIECES_1
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   PIECES_1_START SET	*
      6  2400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2400				   PIECES_1   SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2400					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2400					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  2400					      LIST	ON
      0  2400					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  2400				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2400				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2400				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  2400				   TEMPORARY_VAR SET	Overlay
      5  2400				   TEMPORARY_OFFSET SET	0
      6  2400				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2400				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  2400		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  2418		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2448					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  2448					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  2448					      LIST	ON
      0  2448					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  2448				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2448				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2448				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  2448				   TEMPORARY_VAR SET	Overlay
      5  2448				   TEMPORARY_OFFSET SET	0
      6  2448				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2448				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  2448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2460		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  2478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2490					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2490					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  2490					      LIST	ON
      0  2490					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  2490				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2490				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2490				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  2490				   TEMPORARY_VAR SET	Overlay
      5  2490				   TEMPORARY_OFFSET SET	0
      6  2490				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2490				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  2490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  24a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  24c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  24d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  24d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  2500					      LIST	ON
      0  2500					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  2500				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2500				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2500				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  2500				   TEMPORARY_VAR SET	Overlay
      5  2500				   TEMPORARY_OFFSET SET	0
      6  2500				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2500				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  2500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2530		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2548					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  2548					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  2548					      LIST	ON
      0  2548					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  2548				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2548				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2548				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  2548				   TEMPORARY_VAR SET	Overlay
      5  2548				   TEMPORARY_OFFSET SET	0
      6  2548				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2548				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  2548		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2560		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2590					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  2590					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  2590					      LIST	ON
      0  2590					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  2590				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2590				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2590				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  2590				   TEMPORARY_VAR SET	Overlay
      5  2590				   TEMPORARY_OFFSET SET	0
      6  2590				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2590				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  2590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  25a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  25c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  25d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  25d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  2600					      LIST	ON
      0  2600					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  2600				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2600				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2600				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  2600				   TEMPORARY_VAR SET	Overlay
      5  2600				   TEMPORARY_OFFSET SET	0
      6  2600				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2600				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  2600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2618		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2630		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2648					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  2648					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  2648					      LIST	ON
      0  2648					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  2648				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2648				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2648				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  2648				   TEMPORARY_VAR SET	Overlay
      5  2648				   TEMPORARY_OFFSET SET	0
      6  2648				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2648				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  2648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2678		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2690					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  2690					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  2690					      LIST	ON
      0  2690					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  2690				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2690				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2690				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  2690				   TEMPORARY_VAR SET	Overlay
      5  2690				   TEMPORARY_OFFSET SET	0
      6  2690				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2690				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  2690		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  26a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  26c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  26d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  26d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  2700					      LIST	ON
      0  2700					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  2700				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2700				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2700				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  2700				   TEMPORARY_VAR SET	Overlay
      5  2700				   TEMPORARY_OFFSET SET	0
      6  2700				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2700				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  2700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2718		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2748					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  2748					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  2748					      LIST	ON
      0  2748					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  2748				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2748				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2748				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  2748				   TEMPORARY_VAR SET	Overlay
      5  2748				   TEMPORARY_OFFSET SET	0
      6  2748				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2748				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  2748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2760		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2778		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2790					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  2790					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  2790					      LIST	ON
      0  2790					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  2790				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2790				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2790				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  2790				   TEMPORARY_VAR SET	Overlay
      5  2790				   TEMPORARY_OFFSET SET	0
      6  2790				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2790				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  2790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  27a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  27c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  27d8					      CHECK_BANK_SIZE	"PIECES_1 (1K)"
      1  27d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_1 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  27d8					      ECHO	"PIECES_1 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  27d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  27d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_1 (1K)", " size=", * - ORIGIN
      5  27d8				  -	      ERR
      6  27d8					      ENDIF
      0  27d8					      SLOT	2
      1  27d8				  -	      IF	(2 < 0) || (2 > 3)
      2  27d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  27d8				  -	      ERR
      4  27d8					      ENDIF
      5  27d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  27d8				   _BANK_SLOT SET	2 * 64
      0  27d8					      NEWBANK	PIECES_2
      1  2bd8 ????				      SEG	PIECES_2
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   PIECES_2_START SET	*
      6  2800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2800				   PIECES_2   SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2800					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  2800				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2800				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2800				   WHITE_KING_on_WHITE_SQUARE_0
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  2800		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  2818		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2848					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  2848				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2848				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2848				   WHITE_KING_on_WHITE_SQUARE_1
      4  2848				   TEMPORARY_VAR SET	Overlay
      5  2848				   TEMPORARY_OFFSET SET	0
      6  2848				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2848				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2890					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  2890				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2890				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2890				   WHITE_KING_on_WHITE_SQUARE_2
      4  2890				   TEMPORARY_VAR SET	Overlay
      5  2890				   TEMPORARY_OFFSET SET	0
      6  2890				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2890				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  28c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  28d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  2900				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2900				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2900				   WHITE_KING_on_WHITE_SQUARE_3
      4  2900				   TEMPORARY_VAR SET	Overlay
      5  2900				   TEMPORARY_OFFSET SET	0
      6  2900				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2900				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2948					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  2948				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2948				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2948				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  2948				   TEMPORARY_VAR SET	Overlay
      5  2948				   TEMPORARY_OFFSET SET	0
      6  2948				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2948				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  2948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2990					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  2990				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2990				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2990				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  2990				   TEMPORARY_VAR SET	Overlay
      5  2990				   TEMPORARY_OFFSET SET	0
      6  2990				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2990				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  29d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  2a00				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2a00				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2a00				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  2a00				   TEMPORARY_VAR SET	Overlay
      5  2a00				   TEMPORARY_OFFSET SET	0
      6  2a00				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2a00				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2a48					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  2a48				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2a48				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2a48				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  2a48				   TEMPORARY_VAR SET	Overlay
      5  2a48				   TEMPORARY_OFFSET SET	0
      6  2a48				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2a48				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2a90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  2a90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2a90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2a90				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  2a90				   TEMPORARY_VAR SET	Overlay
      5  2a90				   TEMPORARY_OFFSET SET	0
      6  2a90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2a90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  2a90		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  2aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ad8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  2b00				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2b00				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2b00				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  2b00				   TEMPORARY_VAR SET	Overlay
      5  2b00				   TEMPORARY_OFFSET SET	0
      6  2b00				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2b00				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2b48					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  2b48				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2b48				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2b48				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  2b48				   TEMPORARY_VAR SET	Overlay
      5  2b48				   TEMPORARY_OFFSET SET	0
      6  2b48				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2b48				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  2b78		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2b90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  2b90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2b90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2b90				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  2b90				   TEMPORARY_VAR SET	Overlay
      5  2b90				   TEMPORARY_OFFSET SET	0
      6  2b90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2b90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
      0  2bd8					      CHECK_BANK_SIZE	"PIECES_2 (1K)"
      1  2bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_2 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2bd8					      ECHO	"PIECES_2 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_2 (1K)", " size=", * - ORIGIN
      5  2bd8				  -	      ERR
      6  2bd8					      ENDIF
      0  2bd8					      SLOT	2
      1  2bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2bd8				  -	      ERR
      4  2bd8					      ENDIF
      5  2bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2bd8				   _BANK_SLOT SET	2 * 64
      0  2bd8					      NEWBANK	PIECES_3
      1  2fd8 ????				      SEG	PIECES_3
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   PIECES_3_START SET	*
      6  2c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2c00				   PIECES_3   SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  2c00				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2c00				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  2c00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  2c18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  2c48				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2c48				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  2c90				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2c90				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  2cc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  2d00				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2d00				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  2d48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2d48				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  2d48		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  2d60		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  2d90				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2d90				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  2e00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2e00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  2e30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  2e48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2e48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  2e90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  2e90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  2ea8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  2f00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  2f48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  2f78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  2f90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECES_3 (1K)"
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_3 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2fd8					      ECHO	"PIECES_3 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_3 (1K)", " size=", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      0  2fd8					      SLOT	2
      1  2fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2fd8				  -	      ERR
      4  2fd8					      ENDIF
      5  2fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2fd8				   _BANK_SLOT SET	2 * 64
      0  2fd8					      NEWBANK	PIECE_4
      1  33d8 ????				      SEG	PIECE_4
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   PIECE_4_START SET	*
      6  3000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3000				   PIECE_4    SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  3000				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  3000		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  3048				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  3090				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  30c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  3100				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3100				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3100				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  3148				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3148				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3148				   WHITE_KING_on_BLACK_SQUARE_0
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  3148		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  3160		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  3190				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3190				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3190				   WHITE_KING_on_BLACK_SQUARE_1
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  3200				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3200				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3200				   WHITE_KING_on_BLACK_SQUARE_2
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3230		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  3248				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3248				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3248				   WHITE_KING_on_BLACK_SQUARE_3
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  3290				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3290				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3290				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  3290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  32a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  3300				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3300				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3300				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  3348				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3348				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3348				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3378		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  3390				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3390				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3390				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
      0  33d8					      CHECK_BANK_SIZE	"PIECES_4 (1K)"
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_4 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  33d8					      ECHO	"PIECES_4 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_4 (1K)", " size=", * - ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      0  33d8					      SLOT	2
      1  33d8				  -	      IF	(2 < 0) || (2 > 3)
      2  33d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  33d8				  -	      ERR
      4  33d8					      ENDIF
      5  33d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  33d8				   _BANK_SLOT SET	2 * 64
      0  33d8					      NEWBANK	PIECE_5
      1  37d8 ????				      SEG	PIECE_5
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   PIECE_5_START SET	*
      6  3400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3400				   PIECE_5    SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  3400				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3400				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3400				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  3400		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  3418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  3448				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3448				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3448				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  3490				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3490				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3490				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  34c0		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  3500				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3500				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3500				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  3548				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3548				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3548				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  3548		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  3560		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  3590				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3590				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3590				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  3600				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3600				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3600				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  3630		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  3648				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3648				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  3690				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3690				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  3690		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  36a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  3700				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3700				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  3748				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3748				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  3778		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  3790				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3790				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECES_5 (1K)"
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_5 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  37d8					      ECHO	"PIECES_5 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_5 (1K)", " size=", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      0  37d8					      SLOT	2
      1  37d8				  -	      IF	(2 < 0) || (2 > 3)
      2  37d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  37d8				  -	      ERR
      4  37d8					      ENDIF
      5  37d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  37d8				   _BANK_SLOT SET	2 * 64
      0  37d8					      NEWBANK	PIECE_6
      1  3b90 ????				      SEG	PIECE_6
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   PIECE_6_START SET	*
      6  3800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3800				   PIECE_6    SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  3800					      LIST	ON
      0  3800					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  3800				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3800				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  3800		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  3818		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  3848					      LIST	ON
      0  3848					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  3848				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3848				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  3890					      LIST	ON
      0  3890					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  3890				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3890				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  38c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  3900					      LIST	ON
      0  3900					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  3900				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3900				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  3948					      LIST	ON
      0  3948					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  3948				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3948				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  3948		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  3990					      LIST	ON
      0  3990					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  3990				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3990				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  3a00					      LIST	ON
      0  3a00					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  3a00				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3a00				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  3a30		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  3a48					      LIST	ON
      0  3a48					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  3a48				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3a48				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  3a90					      LIST	ON
      0  3a90					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  3a90				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3a90				   BLACK_KING_on_WHITE_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  3a90		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  3aa8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  3b00					      LIST	ON
      0  3b00					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  3b00				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3b00				   BLACK_KING_on_WHITE_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  3b48					      LIST	ON
      0  3b48					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  3b48				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3b48				   BLACK_KING_on_WHITE_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3b78		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
      0  3b90					      CHECK_BANK_SIZE	"PIECES_6 (1K)"
      1  3b90		       03 90	   .TEMP      =	* - _BANK_START
 PIECES_6 (1K) (1K) SIZE =  $390 , FREE= $70
      2  3b90					      ECHO	"PIECES_6 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3b90				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3b90				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_6 (1K)", " size=", * - ORIGIN
      5  3b90				  -	      ERR
      6  3b90					      ENDIF
      0  3b90					      SLOT	2
      1  3b90				  -	      IF	(2 < 0) || (2 > 3)
      2  3b90				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3b90				  -	      ERR
      4  3b90					      ENDIF
      5  3b90				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3b90				   _BANK_SLOT SET	2 * 64
      0  3b90					      NEWBANK	PIECE_7
      1  3fd8 ????				      SEG	PIECE_7
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECE_7_START SET	*
      6  3c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3c00				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  3c00					      LIST	ON
      0  3c00					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  3c00				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3c00				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3c00				   BLACK_KING_on_WHITE_SQUARE_3
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  3c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  3c48					      LIST	ON
      0  3c48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  3c48				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3c48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3c48				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  3c90					      LIST	ON
      0  3c90					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  3c90				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3c90				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3c90				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  3d00				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3d00				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3d00				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  3d48				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3d48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3d48				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  3d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  3d90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3d90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3d90				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  3d90		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  3e00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3e00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3e00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  3e48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3e48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3e48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  3e90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3e90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3e90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  3e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  3f00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3f00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3f00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  3f00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  3f18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  3f48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3f48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3f48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  3f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3f90					      LIST	ON
      0  3f90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  3f90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3f90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3f90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  3fd8					      CHECK_BANK_SIZE	"PIECE_7 (1K)"
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_7 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3fd8					      ECHO	"PIECE_7 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_7 (1K)", " size=", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      0  3fd8					      SLOT	2
      1  3fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3fd8				  -	      ERR
      4  3fd8					      ENDIF
      5  3fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3fd8				   _BANK_SLOT SET	2 * 64
      0  3fd8					      NEWBANK	PIECE_8
      1  4048 ????				      SEG	PIECE_8
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECE_8_START SET	*
      6  4000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4000				   PIECE_8    SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  4000					      LIST	ON
      0  4000					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  4000				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4000				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4000				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  4000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
    127  4048
      0  4048					      CHECK_BANK_SIZE	"PIECES_8 (1K)"
      1  4048		       00 48	   .TEMP      =	* - _BANK_START
 PIECES_8 (1K) (1K) SIZE =  $48 , FREE= $3b8
      2  4048					      ECHO	"PIECES_8 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4048				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4048				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_8 (1K)", " size=", * - ORIGIN
      5  4048				  -	      ERR
      6  4048					      ENDIF
    129  4048
    130  4048							;    NEWBANK PIECES_5
    131  4048
    132  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    133  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    134  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    135  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    136  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    137  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    138  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    139  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    140  4048
    141  4048
    142  4048				  -	      IF	0
    143  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    144  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    145  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    146  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    147  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    148  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    149  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    150  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    151  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    152  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    153  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    154  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    155  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    156  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    157  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    158  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    159  4048					      ENDIF
    160  4048
    161  4048							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    162  4048
    163  4048				  -	      IF	0
    164  4048				  -	      NEWBANK	PIECES_6
    165  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    166  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    167  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    168  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    169  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    170  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    171  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    172  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    173  4048				  -
    174  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    175  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    176  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    177  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    178  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    179  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    180  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    181  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    182  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    183  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    184  4048				  -
    185  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    186  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    187  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    188  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    189  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    190  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    191  4048				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    192  4048				  -
    193  4048				  -
    194  4048				  -	      NEWBANK	PIECES_7
    195  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    196  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    197  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    198  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    199  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    200  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    201  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    202  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    203  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    204  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    205  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    206  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    207  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    208  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    209  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    210  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    211  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    212  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    213  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    214  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    215  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    216  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    217  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    218  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    219  4048				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    220  4048				  -
    221  4048				  -
    222  4048				  -	      NEWBANK	PIECES_8
    223  4048				  -
    224  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    225  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    226  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    227  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    228  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    229  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    230  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    231  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    232  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    233  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    234  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    235  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    236  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    237  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    238  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    239  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    240  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    241  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    242  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    243  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    244  4048				  -
    245  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    246  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    247  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    248  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    249  4048				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    250  4048				  -
    251  4048					      ENDIF
    252  4048
    253  4048							;    NEWBANK PIECES_9
    254  4048
    255  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    256  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    257  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    258  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    259  4048							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    260  4048
    261  4048				  -	      IF	0
    262  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    263  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    264  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    265  4048					      ENDIF
    266  4048
    267  4048							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    268  4048
    269  4048				  -	      IF	0
    270  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    271  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    272  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    273  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    274  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    275  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    276  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    277  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    278  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    279  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    280  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    281  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    282  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    283  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    284  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    285  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    286  4048					      ENDIF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2.asm LEVEL 2 PASS 4
      0  4048					      include	"BANK_GENERIC@2.asm"
      1  4048
      0  4048					      SLOT	2
      1  4048				  -	      IF	(2 < 0) || (2 > 3)
      2  4048				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4048				  -	      ERR
      4  4048					      ENDIF
      5  4048				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4048				   _BANK_SLOT SET	2 * 64
      0  4048					      NEWBANK	GENERIC_BANK@2
      1  4775 ????				      SEG	GENERIC_BANK@2
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   GENERIC_BANK@2_START SET	*
      6  4400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4400				   GENERIC_BANK@2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + 1024
      4  4400
      5  4400							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
      6  4400
      7  4400				  -	      IF	0
      8  4400				  -	      IF	PLUSCART = YES
      9  4400				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     10  4400				  -	      .byte	"pluscart.firmaplus.de", #0
     11  4400				  -	      ENDIF
     12  4400					      ENDIF
     13  4400
     14  4400		       54 4a 33 45 STELLA_AUTODETECT dc	"TJ3E"	; 3E+ autodetect
     15  4404
     16  4404
     17  4404							;---------------------------------------------------------------------------------------------------
     18  4404
      0  4404					      DEF	tidySc
      1  4404				   SLOT_tidySc SET	_BANK_SLOT
      2  4404				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  4404				   tidySc
      4  4404				   TEMPORARY_VAR SET	Overlay
      5  4404				   TEMPORARY_OFFSET SET	0
      6  4404				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  4404				   FUNCTION_NAME SET	tidySc
     20  4404					      SUBROUTINE
     21  4404
      0  4404					      REFER	StartupBankReset	;✅
      1  4404				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  4404				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  4404					      ENDIF
      0  4404					      VEND	tidySc
      1  4404				  -	      IFNCONST	tidySc
      2  4404				  -	      ECHO	"Incorrect VEND label", tidySc
      3  4404				  -	      ERR
      4  4404					      ENDIF
      5  4404		       00 a6	   VAREND_tidySc =	TEMPORARY_VAR
     24  4404
     25  4404		       a9 00		      lda	#0
     26  4406		       85 4d		      sta	PF0
     27  4408		       85 4e		      sta	PF1
     28  440a		       85 4f		      sta	PF2
     29  440c		       85 5b		      sta	GRP0
     30  440e		       85 5c		      sta	GRP1
     31  4410
     32  4410		       a9 42		      lda	#%01000010	; bit6 is not required
     33  4412							;sta VBLANK			  ; end of screen - enter blanking
     34  4412
     35  4412
     36  4412							; END OF VISIBLE SCREEN
     37  4412							; HERE'S SOME TIME TO DO STUFF
     38  4412
     39  4412		       a9 2e		      lda	#TIME_PART_2
     40  4414		       8d 96 02 	      sta	TIM64T
     41  4417		       60		      rts
     42  4418
     43  4418
     44  4418							;---------------------------------------------------------------------------------------------------
     45  4418
      0  4418					      DEF	longD
      1  4418				   SLOT_longD SET	_BANK_SLOT
      2  4418				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  4418				   longD
      4  4418				   TEMPORARY_VAR SET	Overlay
      5  4418				   TEMPORARY_OFFSET SET	0
      6  4418				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  4418				   FUNCTION_NAME SET	longD
     47  4418					      SUBROUTINE
     48  4418
      0  4418					      REFER	StartupBankReset	;✅
      1  4418				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  4418				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  4418					      ENDIF
      0  4418					      VEND	longD
      1  4418				  -	      IFNCONST	longD
      2  4418				  -	      ECHO	"Incorrect VEND label", longD
      3  4418				  -	      ERR
      4  4418					      ENDIF
      5  4418		       00 a6	   VAREND_longD =	TEMPORARY_VAR
     51  4418
     52  4418		       85 42		      sta	WSYNC
     53  441a
     54  441a		       20 2b f8 	      jsr	_rts
     55  441d		       20 2b f8 	      jsr	_rts
     56  4420		       20 2b f8 	      jsr	_rts
      0  4423					      SLEEP	7
      1  4423				   .CYCLES    SET	7
      2  4423
      3  4423				  -	      IF	.CYCLES < 2
      4  4423				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4423				  -	      ERR
      6  4423					      ENDIF
      7  4423
      8  4423					      IF	.CYCLES & 1
      9  4423					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4423		       04 00		      nop	0
     11  4425				  -	      ELSE
     12  4425				  -	      bit	VSYNC
     13  4425					      ENDIF
     14  4425				   .CYCLES    SET	.CYCLES - 3
     15  4425					      ENDIF
     16  4425
     17  4425					      REPEAT	.CYCLES / 2
     18  4425		       ea		      nop
     17  4425					      REPEND
     18  4426		       ea		      nop
     19  4427					      REPEND
     58  4427
     59  4427		       a2 00		      ldx	#0
     60  4429		       86 41		      stx	VBLANK
     61  442b		       60	   _rts       rts
     62  442c
     63  442c
     64  442c							;---------------------------------------------------------------------------------------------------
     65  442c
      0  442c					      DEF	aiStartClearBoard
      1  442c				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  442c				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  442c				   aiStartClearBoard
      4  442c				   TEMPORARY_VAR SET	Overlay
      5  442c				   TEMPORARY_OFFSET SET	0
      6  442c				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  442c				   FUNCTION_NAME SET	aiStartClearBoard
     67  442c					      SUBROUTINE
     68  442c
      0  442c					      REFER	AiStateMachine	;✅
      1  442c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  442c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  442c					      ENDIF
      0  442c					      VEND	aiStartClearBoard
      1  442c				  -	      IFNCONST	aiStartClearBoard
      2  442c				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  442c				  -	      ERR
      4  442c					      ENDIF
      5  442c		       00 a8	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     71  442c
     72  442c		       a2 08		      ldx	#8
     73  442e		       86 84		      stx	drawCount	; = bank
     74  4430
     75  4430		       a9 ff		      lda	#-1
     76  4432		       85 88		      sta	cursorX12
     77  4434
      0  4434					      PHASE	AI_ClearEachRow
      1  4434		       a9 0e		      lda	#AI_ClearEachRow
      2  4436		       85 8b		      sta	aiState
     79  4438		       60		      rts
     80  4439
     81  4439
     82  4439							;---------------------------------------------------------------------------------------------------
     83  4439
      0  4439					      DEF	aiClearEachRow
      1  4439				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  4439				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  4439				   aiClearEachRow
      4  4439				   TEMPORARY_VAR SET	Overlay
      5  4439				   TEMPORARY_OFFSET SET	0
      6  4439				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  4439				   FUNCTION_NAME SET	aiClearEachRow
     85  4439					      SUBROUTINE
     86  4439
      0  4439					      REFER	AiStateMachine	;✅
      1  4439					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4439				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4439					      ENDIF
      0  4439					      VEND	aiClearEachRow
      1  4439				  -	      IFNCONST	aiClearEachRow
      2  4439				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  4439				  -	      ERR
      4  4439					      ENDIF
      5  4439		       00 a8	   VAREND_aiClearEachRow =	TEMPORARY_VAR
     89  4439
     90  4439		       c6 84		      dec	drawCount
     91  443b		       30 00		      bmi	.bitmapCleared
     92  443d							;TODOldy drawCount
     93  443d							;TODO jmp CallClear
     94  443d
     95  443d				   .bitmapCleared
     96  443d
     97  443d		       a9 63		      lda	#99
     98  443f		       85 80		      sta	squareToDraw
     99  4441
      0  4441					      PHASE	AI_DrawEntireBoard
      1  4441		       a9 0f		      lda	#AI_DrawEntireBoard
      2  4443		       85 8b		      sta	aiState
    101  4445		       60		      rts
    102  4446
    103  4446
    104  4446							;---------------------------------------------------------------------------------------------------
    105  4446
      0  4446					      DEF	aiMoveIsSelected
      1  4446				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  4446				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  4446				   aiMoveIsSelected
      4  4446				   TEMPORARY_VAR SET	Overlay
      5  4446				   TEMPORARY_OFFSET SET	0
      6  4446				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  4446				   FUNCTION_NAME SET	aiMoveIsSelected
    107  4446					      SUBROUTINE
    108  4446
      0  4446					      COMMON_VARS
      1  4446
      0  4446					      VAR	__thinkbar, 1
      1  4446		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__toggle, 1
      1  4446		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      4  4446
      0  4446					      VAR	__bestMove, 1
      1  4446		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__alpha, 2
      1  4446		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__beta, 2
      1  4446		       00 ab	   __beta     =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__negaMax, 2
      1  4446		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__value, 2
      1  4446		       00 af	   __value    =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
     10  4446
      0  4446					      VAR	__quiesceCapOnly, 1
      1  4446		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
     12  4446
      0  4446					      VAR	__originalPiece, 1
      1  4446		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
      0  4446					      VAR	__capturedPiece, 1
      1  4446		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  4446				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4446
      4  4446				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4446				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4446				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4446					      ENDIF
      8  4446				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4446				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  4446				  -	      ERR
     11  4446					      ENDIF
     12  4446					      LIST	ON
     15  4446
      0  4446					      REFER	AiStateMachine	;✅
      1  4446				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4446				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4446					      ENDIF
      0  4446					      VEND	aiMoveIsSelected
      1  4446				  -	      IFNCONST	aiMoveIsSelected
      2  4446				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  4446				  -	      ERR
      4  4446					      ENDIF
      5  4446		       00 b4	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    112  4446
    113  4446							; Both computer and human have now seleted a move, and converge here
    114  4446
    115  4446
    116  4446							; fromPiece	 piece doing the move
    117  4446							; fromX12	 current square X12
    118  4446							; originX12	 starting square X12
    119  4446							; toX12	 ending square X12
    120  4446
    121  4446							; get the piece types from the board
    122  4446
    123  4446		       a9 d1		      lda	#RAMBANK_BOARD
    124  4448		       85 3e		      sta	SET_BANK_RAM	;@3
    125  444a		       a4 87		      ldy	originX12
    126  444c		       b9 79 fc 	      lda	Board,y
    127  444f		       85 b2		      sta	__originalPiece
    128  4451		       a4 86		      ldy	toX12
    129  4453		       b9 79 fc 	      lda	Board,y
    130  4456		       85 b3		      sta	__capturedPiece
    131  4458
    132  4458
    133  4458		       20 c5 f8 	      jsr	AdjustMaterialPositionalValue	;@this
    134  445b
    135  445b		       a9 00		      lda	#0
    136  445d		       85 98		      sta	previousPiece
    137  445f		       85 82		      sta	drawDelay
    138  4461
    139  4461		       a9 0a		      lda	#10	; on/off count
    140  4463		       85 84		      sta	drawCount	; flashing for piece about to move
    141  4465
      0  4465					      PHASE	AI_WriteStartPieceBlank
      1  4465		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  4467		       85 8b		      sta	aiState
    143  4469		       60	   .idleErase rts
    144  446a
    145  446a
    146  446a							;---------------------------------------------------------------------------------------------------
    147  446a
      0  446a					      DEF	CopySetup
      1  446a				   SLOT_CopySetup SET	_BANK_SLOT
      2  446a				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  446a				   CopySetup
      4  446a				   TEMPORARY_VAR SET	Overlay
      5  446a				   TEMPORARY_OFFSET SET	0
      6  446a				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  446a				   FUNCTION_NAME SET	CopySetup
    149  446a					      SUBROUTINE
    150  446a
      0  446a					      REFER	CopySinglePiece	;✅
      1  446a					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  446a				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  446a					      ENDIF
    152  446a
      0  446a					      VAR	__tmp, 1
      1  446a		       00 ab	   __tmp      =	TEMPORARY_VAR
      2  446a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  446a
      4  446a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  446a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  446a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  446a					      ENDIF
      8  446a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  446a				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  446a				  -	      ERR
     11  446a					      ENDIF
     12  446a					      LIST	ON
      0  446a					      VAR	__shiftx, 1
      1  446a		       00 ac	   __shiftx   =	TEMPORARY_VAR
      2  446a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  446a
      4  446a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  446a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  446a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  446a					      ENDIF
      8  446a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  446a				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  446a				  -	      ERR
     11  446a					      ENDIF
     12  446a					      LIST	ON
      0  446a					      VAR	__pieceColour2, 1
      1  446a		       00 ad	   __pieceColour2 =	TEMPORARY_VAR
      2  446a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  446a
      4  446a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  446a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  446a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  446a					      ENDIF
      8  446a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  446a				  -	      ECHO	"Temporary Variable", __pieceColour2, "overflow!"
     10  446a				  -	      ERR
     11  446a					      ENDIF
     12  446a					      LIST	ON
    156  446a
      0  446a					      VEND	CopySetup
      1  446a				  -	      IFNCONST	CopySetup
      2  446a				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  446a				  -	      ERR
      4  446a					      ENDIF
      5  446a		       00 ae	   VAREND_CopySetup =	TEMPORARY_VAR
    158  446a
    159  446a							; figure colouration of square
    160  446a
    161  446a		       a5 80		      lda	squareToDraw
    162  446c
    163  446c					      IF	DIAGNOSTICS
    164  446c							; Catch out-of-range piece square
    165  446c							; will not catch off left/right edge
    166  446c
    167  446c		       c9 64	   .fail      cmp	#100
    168  446e		       b0 fc		      bcs	.fail
    169  4470		       c9 16		      cmp	#22
    170  4472		       90 f8		      bcc	.fail
    171  4474					      ENDIF
    172  4474
    173  4474
    174  4474		       a2 0a		      ldx	#10
    175  4476		       38		      sec
    176  4477		       e9 0a	   .sub10     sbc	#10
    177  4479		       ca		      dex
    178  447a		       b0 fb		      bcs	.sub10
    179  447c		       69 08		      adc	#8
    180  447e		       85 ac		      sta	__shiftx
    181  4480					      IF	DIAGNOSTICS
    182  4480		       c9 08	   .fail2     cmp	#8
    183  4482		       b0 fc		      bcs	.fail2
    184  4484		       e0 08		      cpx	#8
    185  4486		       b0 f8		      bcs	.fail2
    186  4488					      ENDIF
    187  4488		       86 ab		      stx	__tmp
    188  448a		       65 ab		      adc	__tmp
    189  448c
    190  448c
    191  448c		       29 01		      and	#1
    192  448e		       49 01		      eor	#1
    193  4490		       f0 02		      beq	.white
    194  4492		       a9 24		      lda	#36
    195  4494				   .white
    196  4494		       85 ad		      sta	__pieceColour2	; actually SQUARE black/white
    197  4496
    198  4496							; PieceColour = 0 for white square, 36 for black square
    199  4496
    200  4496		       a9 d1		      lda	#RAMBANK_BOARD
    201  4498		       85 3e		      sta	SET_BANK_RAM	;@3
    202  449a
    203  449a		       a4 80		      ldy	squareToDraw
    204  449c		       b9 79 fc 	      lda	Board,y
    205  449f							;and #$87
    206  449f		       0a		      asl
    207  44a0		       90 02		      bcc	.blackAdjust
    208  44a2		       09 10		      ora	#16	; switch white pieces
    209  44a4		       4a	   .blackAdjust lsr
    210  44a5		       29 0f		      and	#%1111
    211  44a7		       aa		      tax
    212  44a8
    213  44a8		       a5 ac		      lda	__shiftx
    214  44aa		       29 03		      and	#3	; shift position in P
    215  44ac
    216  44ac		       18		      clc
    217  44ad		       7d b5 f8 	      adc	PieceToShape,x
    218  44b0		       18		      clc
    219  44b1		       65 ad		      adc	__pieceColour2
    220  44b3		       a8		      tay
    221  44b4		       60		      rts
    222  44b5
    223  44b5				   PieceToShape
    224  44b5
    225  44b5		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    226  44b6		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    227  44b7		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    228  44b8		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    229  44b9		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    230  44ba		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    231  44bb		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    232  44bc		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    233  44bd
    234  44bd		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    235  44be		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    236  44bf		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    237  44c0		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    238  44c1		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    239  44c2		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    240  44c3		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    241  44c4		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    242  44c5
    243  44c5
    244  44c5							;---------------------------------------------------------------------------------------------------
    245  44c5
      0  44c5					      DEF	AdjustMaterialPositionalValue
      1  44c5				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  44c5				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  44c5				   AdjustMaterialPositionalValue
      4  44c5				   TEMPORARY_VAR SET	Overlay
      5  44c5				   TEMPORARY_OFFSET SET	0
      6  44c5				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  44c5				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    247  44c5					      SUBROUTINE
    248  44c5
    249  44c5							; A move is about to be made, so  adjust material and positional values based on from/to and
    250  44c5							; capture.
    251  44c5
    252  44c5							; First, nominate referencing subroutines so that local variables can be adjusted properly
    253  44c5
      0  44c5					      COMMON_VARS
      1  44c5
      0  44c5					      VAR	__thinkbar, 1
      1  44c5		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__toggle, 1
      1  44c5		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      4  44c5
      0  44c5					      VAR	__bestMove, 1
      1  44c5		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__alpha, 2
      1  44c5		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__beta, 2
      1  44c5		       00 ab	   __beta     =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__negaMax, 2
      1  44c5		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__value, 2
      1  44c5		       00 af	   __value    =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
     10  44c5
      0  44c5					      VAR	__quiesceCapOnly, 1
      1  44c5		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
     12  44c5
      0  44c5					      VAR	__originalPiece, 1
      1  44c5		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
      0  44c5					      VAR	__capturedPiece, 1
      1  44c5		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  44c5				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44c5
      4  44c5				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44c5				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44c5				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44c5					      ENDIF
      8  44c5				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44c5				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  44c5				  -	      ERR
     11  44c5					      ENDIF
     12  44c5					      LIST	ON
     15  44c5
      0  44c5					      REFER	MakeMove	;✅
      1  44c5				  -	      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  44c5				  -TEMPORARY_VAR SET	VAREND_MakeMove
      3  44c5					      ENDIF
      0  44c5					      REFER	aiMoveIsSelected	;✅
      1  44c5				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  44c5				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  44c5					      ENDIF
      0  44c5					      VEND	AdjustMaterialPositionalValue
      1  44c5				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  44c5				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  44c5				  -	      ERR
      4  44c5					      ENDIF
      5  44c5		       00 b4	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    258  44c5
    259  44c5							; fromPiece	 piece doing the move (promoted type)
    260  44c5							; fromX12	 current square
    261  44c5							; originX12	 starting square
    262  44c5							; toX12	 ending square
    263  44c5
    264  44c5
    265  44c5							; {
    266  44c5							;   adjust the positional value  (originX12 --> fromX12)
    267  44c5
    268  44c5		       a4 86		      ldy	toX12	; already loaded
    269  44c7		       a5 96		      lda	fromPiece
    270  44c9		       20 34 f9 	      jsr	AddPiecePositionValue	; add pos value for new position
    271  44cc
    272  44cc
    273  44cc		       a5 b2		      lda	__originalPiece
    274  44ce		       45 96		      eor	fromPiece	; the new piece
    275  44d0		       29 0f		      and	#PIECE_MASK
    276  44d2		       f0 05		      beq	.same1	; unchanged, so skip
    277  44d4
    278  44d4		       a5 96		      lda	fromPiece	; new piece
    279  44d6		       20 11 f9 	      jsr	AddPieceMaterialValue
    280  44d9
    281  44d9				   .same1
    282  44d9
    283  44d9							; and now the 'subtracts'
    284  44d9
      0  44d9					      NEGEVAL
      1  44d9
      2  44d9		       38		      sec
      3  44da		       a9 00		      lda	#0
      4  44dc		       e5 8f		      sbc	Evaluation
      5  44de		       85 8f		      sta	Evaluation
      6  44e0		       a9 00		      lda	#0
      7  44e2		       e5 90		      sbc	Evaluation+1
      8  44e4		       85 90		      sta	Evaluation+1
    286  44e6
    287  44e6		       a4 87		      ldy	originX12
    288  44e8		       a5 b2		      lda	__originalPiece
    289  44ea		       20 34 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    290  44ed
    291  44ed
    292  44ed		       a5 b2		      lda	__originalPiece
    293  44ef		       45 96		      eor	fromPiece	; the new piece
    294  44f1		       29 0f		      and	#PIECE_MASK
    295  44f3		       f0 05		      beq	.same2	; unchanged, so skip
    296  44f5
    297  44f5		       a5 b2		      lda	__originalPiece
    298  44f7		       20 11 f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    299  44fa				   .same2
    300  44fa
      0  44fa					      NEGEVAL
      1  44fa
      2  44fa		       38		      sec
      3  44fb		       a9 00		      lda	#0
      4  44fd		       e5 8f		      sbc	Evaluation
      5  44ff		       85 8f		      sta	Evaluation
      6  4501		       a9 00		      lda	#0
      7  4503		       e5 90		      sbc	Evaluation+1
      8  4505		       85 90		      sta	Evaluation+1
    302  4507
    303  4507							; If there's a capture, we adjust the material value
    304  4507
    305  4507							;		      lda __capturedPiece
    306  4507							;		      eor __originalPiece
    307  4507							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    308  4507
    309  4507
    310  4507		       a5 b3		      lda	__capturedPiece
    311  4509		       29 0f		      and	#PIECE_MASK
    312  450b		       f0 03		      beq	.noCapture
    313  450d		       20 11 f9 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    314  4510				   .noCapture
    315  4510
    316  4510							; }
    317  4510		       60		      rts
    318  4511
    319  4511
    320  4511							;---------------------------------------------------------------------------------------------------
    321  4511
      0  4511					      DEF	AddPieceMaterialValue
      1  4511				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  4511				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  4511				   AddPieceMaterialValue
      4  4511				   TEMPORARY_VAR SET	Overlay
      5  4511				   TEMPORARY_OFFSET SET	0
      6  4511				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  4511				   FUNCTION_NAME SET	AddPieceMaterialValue
    323  4511					      SUBROUTINE
    324  4511
      0  4511					      COMMON_VARS
      1  4511
      0  4511					      VAR	__thinkbar, 1
      1  4511		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__toggle, 1
      1  4511		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      4  4511
      0  4511					      VAR	__bestMove, 1
      1  4511		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__alpha, 2
      1  4511		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__beta, 2
      1  4511		       00 ab	   __beta     =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__negaMax, 2
      1  4511		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__value, 2
      1  4511		       00 af	   __value    =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
     10  4511
      0  4511					      VAR	__quiesceCapOnly, 1
      1  4511		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
     12  4511
      0  4511					      VAR	__originalPiece, 1
      1  4511		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
      0  4511					      VAR	__capturedPiece, 1
      1  4511		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4511
      4  4511				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4511				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4511				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4511					      ENDIF
      8  4511				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4511				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  4511				  -	      ERR
     11  4511					      ENDIF
     12  4511					      LIST	ON
     15  4511
      0  4511					      REFER	InitialisePieceSquares	;✅
      1  4511					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  4511				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  4511					      ENDIF
      0  4511					      REFER	AdjustMaterialPositionalValue	;✅
      1  4511				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  4511				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  4511					      ENDIF
      0  4511					      REFER	EnPassantRemovePiece	;✅
      1  4511				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  4511				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  4511					      ENDIF
      0  4511					      VEND	AddPieceMaterialValue
      1  4511				  -	      IFNCONST	AddPieceMaterialValue
      2  4511				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  4511				  -	      ERR
      4  4511					      ENDIF
      5  4511		       00 b8	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
    330  4511
    331  4511							; Adjust the material score based on the piece
    332  4511							; a = piece type + flags
    333  4511
    334  4511		       29 0f		      and	#PIECE_MASK
    335  4513		       a8		      tay
    336  4514
    337  4514		       18		      clc
    338  4515		       b9 24 f9 	      lda	PieceValueLO,y
    339  4518		       65 8f		      adc	Evaluation
    340  451a		       85 8f		      sta	Evaluation
    341  451c		       b9 2c f9 	      lda	PieceValueHI,y
    342  451f		       65 90		      adc	Evaluation+1
    343  4521		       85 90		      sta	Evaluation+1
    344  4523		       60		      rts
    345  4524
    346  4524
    347  4524					      MAC	valuetable
    348  4524					      .byte	{1}0	; blank
    349  4524					      .byte	{1}100	; white P
    350  4524					      .byte	{1}100	; black P
    351  4524					      .byte	{1}320	; N
    352  4524					      .byte	{1}375	; B
    353  4524					      .byte	{1}575	; R
    354  4524					      .byte	{1}900	; Q
    355  4524					      .byte	{1}10000	; K
    356  4524					      ENDM
    357  4524
    358  4524				   PieceValueLO
      0  4524					      VALUETABLE	<
      1  4524		       00		      .byte.b	<0
      2  4525		       64		      .byte.b	<100
      3  4526		       64		      .byte.b	<100
      4  4527		       40		      .byte.b	<320
      5  4528		       77		      .byte.b	<375
      6  4529		       3f		      .byte.b	<575
      7  452a		       84		      .byte.b	<900
      8  452b		       10		      .byte.b	<10000
    360  452c
    361  452c				   PieceValueHI
      0  452c					      VALUETABLE	>
      1  452c		       00		      .byte.b	>0
      2  452d		       00		      .byte.b	>100
      3  452e		       00		      .byte.b	>100
      4  452f		       01		      .byte.b	>320
      5  4530		       01		      .byte.b	>375
      6  4531		       02		      .byte.b	>575
      7  4532		       03		      .byte.b	>900
      8  4533		       27		      .byte.b	>10000
    363  4534
    364  4534
    365  4534							;---------------------------------------------------------------------------------------------------
    366  4534
      0  4534					      DEF	AddPiecePositionValue
      1  4534				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  4534				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  4534				   AddPiecePositionValue
      4  4534				   TEMPORARY_VAR SET	Overlay
      5  4534				   TEMPORARY_OFFSET SET	0
      6  4534				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  4534				   FUNCTION_NAME SET	AddPiecePositionValue
    368  4534					      SUBROUTINE
    369  4534
      0  4534					      REFER	InitialisePieceSquares	;✅
      1  4534					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  4534				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  4534					      ENDIF
      0  4534					      REFER	AdjustMaterialPositionalValue	;✅
      1  4534				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  4534				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  4534					      ENDIF
      0  4534					      REFER	EnPassantRemovePiece	;✅
      1  4534				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  4534				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  4534					      ENDIF
      0  4534					      VAR	__valPtr, 2
      1  4534		       00 b8	   __valPtr   =	TEMPORARY_VAR
      2  4534				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4534
      4  4534				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4534					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4534				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4534					      ENDIF
      8  4534				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4534				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  4534				  -	      ERR
     11  4534					      ENDIF
     12  4534					      LIST	ON
      0  4534					      VEND	AddPiecePositionValue
      1  4534				  -	      IFNCONST	AddPiecePositionValue
      2  4534				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  4534				  -	      ERR
      4  4534					      ENDIF
      5  4534		       00 ba	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    375  4534
    376  4534
    377  4534							; adds value of square piece is on to the evaluation
    378  4534							; note to do the subtraction as -( -x + val) == x - val
    379  4534
    380  4534							; y = square
    381  4534							; a = piece type (+flags)
    382  4534
    383  4534
    384  4534
    385  4534		       c9 80		      cmp	#128	; black = CS
    386  4536		       29 0f		      and	#PIECE_MASK
    387  4538		       aa		      tax
    388  4539
    389  4539		       a9 c5		      lda	#EVAL
    390  453b		       85 3f		      sta	SET_BANK	;@3
    391  453d
    392  453d							; black pieces flip rows so we can use the same eval tables
    393  453d
    394  453d		       98		      tya
    395  453e		       90 03		      bcc	.white
    396  4540		       b9 61 f9 	      lda	FlipSquareIndex,y
    397  4543							;clc
    398  4543				   .white
    399  4543		       7d 00 fc 	      adc	PosValVecLO,x
    400  4546		       85 b8		      sta	__valPtr
    401  4548		       bd 08 fc 	      lda	PosValVecHI,x
    402  454b		       69 00		      adc	#0
    403  454d		       85 b9		      sta	__valPtr+1
    404  454f
    405  454f		       a0 00		      ldy	#0
    406  4551		       b1 b8		      lda	(__valPtr),y
    407  4553		       10 01		      bpl	.sum
    408  4555		       88		      dey
    409  4556
    410  4556		       18	   .sum       clc
    411  4557		       65 8f		      adc	Evaluation
    412  4559		       85 8f		      sta	Evaluation
    413  455b		       98		      tya
    414  455c		       65 90		      adc	Evaluation+1
    415  455e		       85 90		      sta	Evaluation+1
    416  4560		       60		      rts
    417  4561
    418  4561
    419  4561				   FlipSquareIndex
    420  4561
    421  4561		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    422  456b		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    423  4575
    424  4575				   .SQBASE    SET	90-1
    425  4575					      REPEAT	8
    426  4575		       00 00		      .byte.b	0,0
    427  4575				   .SQX       SET	2
    428  4577					      REPEAT	8
    429  4577		       5b		      .byte.b	(.SQBASE+.SQX)
    430  4577				   .SQX       SET	.SQX + 1
    428  4577					      REPEND
    429  4578		       5c		      .byte.b	(.SQBASE+.SQX)
    430  4578				   .SQX       SET	.SQX + 1
    428  4578					      REPEND
    429  4579		       5d		      .byte.b	(.SQBASE+.SQX)
    430  4579				   .SQX       SET	.SQX + 1
    428  4579					      REPEND
    429  457a		       5e		      .byte.b	(.SQBASE+.SQX)
    430  457a				   .SQX       SET	.SQX + 1
    428  457a					      REPEND
    429  457b		       5f		      .byte.b	(.SQBASE+.SQX)
    430  457b				   .SQX       SET	.SQX + 1
    428  457b					      REPEND
    429  457c		       60		      .byte.b	(.SQBASE+.SQX)
    430  457c				   .SQX       SET	.SQX + 1
    428  457c					      REPEND
    429  457d		       61		      .byte.b	(.SQBASE+.SQX)
    430  457d				   .SQX       SET	.SQX + 1
    428  457d					      REPEND
    429  457e		       62		      .byte.b	(.SQBASE+.SQX)
    430  457e				   .SQX       SET	.SQX + 1
    431  457f					      REPEND
    432  457f				   .SQBASE    SET	.SQBASE - 10
    425  457f					      REPEND
    426  457f		       00 00		      .byte.b	0,0
    427  457f				   .SQX       SET	2
    428  4581					      REPEAT	8
    429  4581		       51		      .byte.b	(.SQBASE+.SQX)
    430  4581				   .SQX       SET	.SQX + 1
    428  4581					      REPEND
    429  4582		       52		      .byte.b	(.SQBASE+.SQX)
    430  4582				   .SQX       SET	.SQX + 1
    428  4582					      REPEND
    429  4583		       53		      .byte.b	(.SQBASE+.SQX)
    430  4583				   .SQX       SET	.SQX + 1
    428  4583					      REPEND
    429  4584		       54		      .byte.b	(.SQBASE+.SQX)
    430  4584				   .SQX       SET	.SQX + 1
    428  4584					      REPEND
    429  4585		       55		      .byte.b	(.SQBASE+.SQX)
    430  4585				   .SQX       SET	.SQX + 1
    428  4585					      REPEND
    429  4586		       56		      .byte.b	(.SQBASE+.SQX)
    430  4586				   .SQX       SET	.SQX + 1
    428  4586					      REPEND
    429  4587		       57		      .byte.b	(.SQBASE+.SQX)
    430  4587				   .SQX       SET	.SQX + 1
    428  4587					      REPEND
    429  4588		       58		      .byte.b	(.SQBASE+.SQX)
    430  4588				   .SQX       SET	.SQX + 1
    431  4589					      REPEND
    432  4589				   .SQBASE    SET	.SQBASE - 10
    425  4589					      REPEND
    426  4589		       00 00		      .byte.b	0,0
    427  4589				   .SQX       SET	2
    428  458b					      REPEAT	8
    429  458b		       47		      .byte.b	(.SQBASE+.SQX)
    430  458b				   .SQX       SET	.SQX + 1
    428  458b					      REPEND
    429  458c		       48		      .byte.b	(.SQBASE+.SQX)
    430  458c				   .SQX       SET	.SQX + 1
    428  458c					      REPEND
    429  458d		       49		      .byte.b	(.SQBASE+.SQX)
    430  458d				   .SQX       SET	.SQX + 1
    428  458d					      REPEND
    429  458e		       4a		      .byte.b	(.SQBASE+.SQX)
    430  458e				   .SQX       SET	.SQX + 1
    428  458e					      REPEND
    429  458f		       4b		      .byte.b	(.SQBASE+.SQX)
    430  458f				   .SQX       SET	.SQX + 1
    428  458f					      REPEND
    429  4590		       4c		      .byte.b	(.SQBASE+.SQX)
    430  4590				   .SQX       SET	.SQX + 1
    428  4590					      REPEND
    429  4591		       4d		      .byte.b	(.SQBASE+.SQX)
    430  4591				   .SQX       SET	.SQX + 1
    428  4591					      REPEND
    429  4592		       4e		      .byte.b	(.SQBASE+.SQX)
    430  4592				   .SQX       SET	.SQX + 1
    431  4593					      REPEND
    432  4593				   .SQBASE    SET	.SQBASE - 10
    425  4593					      REPEND
    426  4593		       00 00		      .byte.b	0,0
    427  4593				   .SQX       SET	2
    428  4595					      REPEAT	8
    429  4595		       3d		      .byte.b	(.SQBASE+.SQX)
    430  4595				   .SQX       SET	.SQX + 1
    428  4595					      REPEND
    429  4596		       3e		      .byte.b	(.SQBASE+.SQX)
    430  4596				   .SQX       SET	.SQX + 1
    428  4596					      REPEND
    429  4597		       3f		      .byte.b	(.SQBASE+.SQX)
    430  4597				   .SQX       SET	.SQX + 1
    428  4597					      REPEND
    429  4598		       40		      .byte.b	(.SQBASE+.SQX)
    430  4598				   .SQX       SET	.SQX + 1
    428  4598					      REPEND
    429  4599		       41		      .byte.b	(.SQBASE+.SQX)
    430  4599				   .SQX       SET	.SQX + 1
    428  4599					      REPEND
    429  459a		       42		      .byte.b	(.SQBASE+.SQX)
    430  459a				   .SQX       SET	.SQX + 1
    428  459a					      REPEND
    429  459b		       43		      .byte.b	(.SQBASE+.SQX)
    430  459b				   .SQX       SET	.SQX + 1
    428  459b					      REPEND
    429  459c		       44		      .byte.b	(.SQBASE+.SQX)
    430  459c				   .SQX       SET	.SQX + 1
    431  459d					      REPEND
    432  459d				   .SQBASE    SET	.SQBASE - 10
    425  459d					      REPEND
    426  459d		       00 00		      .byte.b	0,0
    427  459d				   .SQX       SET	2
    428  459f					      REPEAT	8
    429  459f		       33		      .byte.b	(.SQBASE+.SQX)
    430  459f				   .SQX       SET	.SQX + 1
    428  459f					      REPEND
    429  45a0		       34		      .byte.b	(.SQBASE+.SQX)
    430  45a0				   .SQX       SET	.SQX + 1
    428  45a0					      REPEND
    429  45a1		       35		      .byte.b	(.SQBASE+.SQX)
    430  45a1				   .SQX       SET	.SQX + 1
    428  45a1					      REPEND
    429  45a2		       36		      .byte.b	(.SQBASE+.SQX)
    430  45a2				   .SQX       SET	.SQX + 1
    428  45a2					      REPEND
    429  45a3		       37		      .byte.b	(.SQBASE+.SQX)
    430  45a3				   .SQX       SET	.SQX + 1
    428  45a3					      REPEND
    429  45a4		       38		      .byte.b	(.SQBASE+.SQX)
    430  45a4				   .SQX       SET	.SQX + 1
    428  45a4					      REPEND
    429  45a5		       39		      .byte.b	(.SQBASE+.SQX)
    430  45a5				   .SQX       SET	.SQX + 1
    428  45a5					      REPEND
    429  45a6		       3a		      .byte.b	(.SQBASE+.SQX)
    430  45a6				   .SQX       SET	.SQX + 1
    431  45a7					      REPEND
    432  45a7				   .SQBASE    SET	.SQBASE - 10
    425  45a7					      REPEND
    426  45a7		       00 00		      .byte.b	0,0
    427  45a7				   .SQX       SET	2
    428  45a9					      REPEAT	8
    429  45a9		       29		      .byte.b	(.SQBASE+.SQX)
    430  45a9				   .SQX       SET	.SQX + 1
    428  45a9					      REPEND
    429  45aa		       2a		      .byte.b	(.SQBASE+.SQX)
    430  45aa				   .SQX       SET	.SQX + 1
    428  45aa					      REPEND
    429  45ab		       2b		      .byte.b	(.SQBASE+.SQX)
    430  45ab				   .SQX       SET	.SQX + 1
    428  45ab					      REPEND
    429  45ac		       2c		      .byte.b	(.SQBASE+.SQX)
    430  45ac				   .SQX       SET	.SQX + 1
    428  45ac					      REPEND
    429  45ad		       2d		      .byte.b	(.SQBASE+.SQX)
    430  45ad				   .SQX       SET	.SQX + 1
    428  45ad					      REPEND
    429  45ae		       2e		      .byte.b	(.SQBASE+.SQX)
    430  45ae				   .SQX       SET	.SQX + 1
    428  45ae					      REPEND
    429  45af		       2f		      .byte.b	(.SQBASE+.SQX)
    430  45af				   .SQX       SET	.SQX + 1
    428  45af					      REPEND
    429  45b0		       30		      .byte.b	(.SQBASE+.SQX)
    430  45b0				   .SQX       SET	.SQX + 1
    431  45b1					      REPEND
    432  45b1				   .SQBASE    SET	.SQBASE - 10
    425  45b1					      REPEND
    426  45b1		       00 00		      .byte.b	0,0
    427  45b1				   .SQX       SET	2
    428  45b3					      REPEAT	8
    429  45b3		       1f		      .byte.b	(.SQBASE+.SQX)
    430  45b3				   .SQX       SET	.SQX + 1
    428  45b3					      REPEND
    429  45b4		       20		      .byte.b	(.SQBASE+.SQX)
    430  45b4				   .SQX       SET	.SQX + 1
    428  45b4					      REPEND
    429  45b5		       21		      .byte.b	(.SQBASE+.SQX)
    430  45b5				   .SQX       SET	.SQX + 1
    428  45b5					      REPEND
    429  45b6		       22		      .byte.b	(.SQBASE+.SQX)
    430  45b6				   .SQX       SET	.SQX + 1
    428  45b6					      REPEND
    429  45b7		       23		      .byte.b	(.SQBASE+.SQX)
    430  45b7				   .SQX       SET	.SQX + 1
    428  45b7					      REPEND
    429  45b8		       24		      .byte.b	(.SQBASE+.SQX)
    430  45b8				   .SQX       SET	.SQX + 1
    428  45b8					      REPEND
    429  45b9		       25		      .byte.b	(.SQBASE+.SQX)
    430  45b9				   .SQX       SET	.SQX + 1
    428  45b9					      REPEND
    429  45ba		       26		      .byte.b	(.SQBASE+.SQX)
    430  45ba				   .SQX       SET	.SQX + 1
    431  45bb					      REPEND
    432  45bb				   .SQBASE    SET	.SQBASE - 10
    425  45bb					      REPEND
    426  45bb		       00 00		      .byte.b	0,0
    427  45bb				   .SQX       SET	2
    428  45bd					      REPEAT	8
    429  45bd		       15		      .byte.b	(.SQBASE+.SQX)
    430  45bd				   .SQX       SET	.SQX + 1
    428  45bd					      REPEND
    429  45be		       16		      .byte.b	(.SQBASE+.SQX)
    430  45be				   .SQX       SET	.SQX + 1
    428  45be					      REPEND
    429  45bf		       17		      .byte.b	(.SQBASE+.SQX)
    430  45bf				   .SQX       SET	.SQX + 1
    428  45bf					      REPEND
    429  45c0		       18		      .byte.b	(.SQBASE+.SQX)
    430  45c0				   .SQX       SET	.SQX + 1
    428  45c0					      REPEND
    429  45c1		       19		      .byte.b	(.SQBASE+.SQX)
    430  45c1				   .SQX       SET	.SQX + 1
    428  45c1					      REPEND
    429  45c2		       1a		      .byte.b	(.SQBASE+.SQX)
    430  45c2				   .SQX       SET	.SQX + 1
    428  45c2					      REPEND
    429  45c3		       1b		      .byte.b	(.SQBASE+.SQX)
    430  45c3				   .SQX       SET	.SQX + 1
    428  45c3					      REPEND
    429  45c4		       1c		      .byte.b	(.SQBASE+.SQX)
    430  45c4				   .SQX       SET	.SQX + 1
    431  45c5					      REPEND
    432  45c5				   .SQBASE    SET	.SQBASE - 10
    433  45c5					      REPEND
    434  45c5
    435  45c5							;---------------------------------------------------------------------------------------------------
    436  45c5
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  45c5					      include	"piece_vectors.asm"
      1  45c5							; Created by ConvertChessPieces.py
      0  45c5					      DEF	PIECE_VECTOR_LO
      1  45c5				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  45c5				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  45c5				   PIECE_VECTOR_LO
      4  45c5				   TEMPORARY_VAR SET	Overlay
      5  45c5				   TEMPORARY_OFFSET SET	0
      6  45c5				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  45c5				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  45c5		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  45c6		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  45c7		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  45c8		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  45c9		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  45ca		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  45cb		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  45cc		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  45cd		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  45ce		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  45cf		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  45d0		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  45d1		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  45d2		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  45d3		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  45d4		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  45d5		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  45d6		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  45d7		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  45d8		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  45d9		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  45da		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  45db		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  45dc		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  45dd		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  45de		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  45df		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  45e0		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  45e1		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  45e2		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  45e3		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  45e4		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  45e5		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  45e6		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  45e7		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  45e8		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  45e9		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  45ea		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  45eb		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  45ec		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  45ed		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  45ee		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  45ef		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  45f0		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  45f1		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  45f2		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  45f3		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  45f4		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  45f5		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  45f6		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  45f7		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  45f8		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  45f9		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  45fa		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  45fb		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  45fc		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  45fd		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  45fe		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  45ff		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  4600		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  4601		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  4602		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  4603		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  4604		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  4605		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  4606		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  4607		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  4608		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  4609		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  460a		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  460b		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  460c		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  460d		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  460e		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  460f		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  4610		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  4611		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  4612		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  4613		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  4614		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  4615		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  4616		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  4617		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  4618		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  4619		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  461a		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  461b		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  461c		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  461d		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  461e		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  461f		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  4620		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  4621		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  4622		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  4623		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  4624		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  4625		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  4626		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  4627		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  4628		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  4629		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  462a		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  462b		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  462c		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  462d		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  462e		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  462f		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  4630		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  4631		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  4632		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  4633		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  4634		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  4635		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  4636		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  4637		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  4638		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  4639		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  463a		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  463b		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  463c		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  463d		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  463e		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  463f		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  4640		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  4641		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  4642		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  4643		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  4644		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  4645		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  4646		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  4647		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  4648		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  4649		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  464a		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  464b		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  464c		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  464d		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  464e		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  464f		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  4650		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  4651		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  4652		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  4653		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  4654		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  4655					      DEF	PIECE_VECTOR_HI
      1  4655				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  4655				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  4655				   PIECE_VECTOR_HI
      4  4655				   TEMPORARY_VAR SET	Overlay
      5  4655				   TEMPORARY_OFFSET SET	0
      6  4655				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  4655				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  4655		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  4656		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  4657		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  4658		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  4659		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  465a		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  465b		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  465c		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  465d		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  465e		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  465f		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  4660		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  4661		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  4662		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  4663		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  4664		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  4665		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  4666		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  4667		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  4668		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  4669		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  466a		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  466b		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  466c		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  466d		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  466e		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  466f		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  4670		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  4671		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  4672		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  4673		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  4674		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  4675		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  4676		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  4677		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  4678		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  4679		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  467a		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  467b		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  467c		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  467d		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  467e		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  467f		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  4680		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  4681		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  4682		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  4683		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  4684		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  4685		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  4686		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  4687		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  4688		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  4689		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  468a		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  468b		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  468c		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  468d		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  468e		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  468f		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  4690		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  4691		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  4692		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  4693		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  4694		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  4695		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  4696		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  4697		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  4698		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  4699		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  469a		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  469b		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  469c		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  469d		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  469e		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  469f		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  46a0		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  46a1		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  46a2		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  46a3		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  46a4		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  46a5		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  46a6		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  46a7		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  46a8		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  46a9		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  46aa		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  46ab		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  46ac		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  46ad		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  46ae		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  46af		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  46b0		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  46b1		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  46b2		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  46b3		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  46b4		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  46b5		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  46b6		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  46b7		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  46b8		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  46b9		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  46ba		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  46bb		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  46bc		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  46bd		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  46be		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  46bf		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  46c0		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  46c1		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  46c2		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  46c3		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  46c4		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  46c5		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  46c6		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  46c7		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  46c8		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  46c9		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  46ca		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  46cb		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  46cc		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  46cd		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  46ce		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  46cf		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  46d0		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  46d1		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  46d2		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  46d3		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  46d4		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  46d5		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  46d6		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  46d7		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  46d8		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  46d9		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  46da		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  46db		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  46dc		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  46dd		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  46de		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  46df		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  46e0		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  46e1		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  46e2		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  46e3		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  46e4		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  46e5					      DEF	PIECE_VECTOR_BANK
      1  46e5				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  46e5				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  46e5				   PIECE_VECTOR_BANK
      4  46e5				   TEMPORARY_VAR SET	Overlay
      5  46e5				   TEMPORARY_OFFSET SET	0
      6  46e5				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  46e5				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  46e5		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  46e6		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  46e7		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  46e8		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  46e9		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  46ea		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  46eb		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  46ec		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  46ed		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  46ee		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  46ef		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  46f0		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  46f1		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  46f2		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  46f3		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  46f4		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  46f5		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  46f6		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  46f7		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  46f8		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  46f9		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  46fa		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  46fb		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  46fc		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  46fd		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  46fe		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  46ff		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  4700		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  4701		       93		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  4702		       93		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  4703		       93		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  4704		       94		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  4705		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  4706		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  4707		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  4708		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  4709		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  470a		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  470b		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  470c		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  470d		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  470e		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  470f		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  4710		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  4711		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  4712		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  4713		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  4714		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  4715		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  4716		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  4717		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  4718		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  4719		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  471a		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  471b		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  471c		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  471d		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  471e		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  471f		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  4720		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  4721		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  4722		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  4723		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  4724		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  4725		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  4726		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  4727		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  4728		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  4729		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  472a		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  472b		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  472c		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  472d		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  472e		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  472f		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  4730		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  4731		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  4732		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  4733		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  4734		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  4735		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  4736		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  4737		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  4738		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  4739		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  473a		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  473b		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  473c		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  473d		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  473e		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  473f		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  4740		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  4741		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  4742		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  4743		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  4744		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  4745		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  4746		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  4747		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  4748		       8f		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  4749		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  474a		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  474b		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  474c		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  474d		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  474e		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  474f		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  4750		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  4751		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  4752		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  4753		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  4754		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  4755		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  4756		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  4757		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  4758		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  4759		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  475a		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  475b		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  475c		       90		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  475d		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  475e		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  475f		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  4760		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  4761		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  4762		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  4763		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  4764		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  4765		       93		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  4766		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  4767		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  4768		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  4769		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  476a		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  476b		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  476c		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  476d		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  476e		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  476f		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  4770		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  4771		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  4772		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  4773		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  4774		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  4775
    438  4775							; piece index equates...
    439  4775		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  4775		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  4775		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  4775		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  4775		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  4775		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  4775		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  4775		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  4775		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  4775		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  4775		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  4775		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  4775		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  4775		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  4775		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  4775		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  4775		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  4775		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  4775		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  4775		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  4775		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  4775		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  4775		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  4775		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  4775		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  4775		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  4775		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  4775		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  4775		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  4775		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  4775		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  4775		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  4775		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  4775		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  4775		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  4775		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  4775		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  4775		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  4775		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  4775		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  4775		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  4775		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  4775		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  4775		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  4775		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  4775		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  4775		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  4775		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  4775		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  4775		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  4775		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  4775		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  4775		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  4775		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  4775		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  4775		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  4775		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  4775		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  4775		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  4775		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  4775		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  4775		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  4775		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  4775		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  4775		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  4775		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  4775		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  4775		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  4775		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  4775		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  4775		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  4775		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  4775		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  4775		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  4775		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  4775		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  4775		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  4775		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  4775		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  4775		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  4775		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  4775		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  4775		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  4775		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  4775		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  4775		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  4775		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  4775		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  4775		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  4775		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  4775		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  4775		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  4775		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  4775		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  4775		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  4775		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  4775		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  4775		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  4775		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  4775		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  4775		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  4775		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  4775		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  4775		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  4775		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  4775		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  4775		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  4775		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  4775		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  4775		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  4775		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  4775		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  4775		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  4775		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  4775		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  4775		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  4775		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  4775		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  4775		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  4775		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  4775		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  4775		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  4775		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  4775		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  4775		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  4775		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  4775		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  4775		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  4775		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  4775		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  4775		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  4775		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  4775		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  4775		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  4775		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  4775		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  4775		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  4775		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  4775		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  4775		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  4775		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  4775		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  4775		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  4775		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC@2.asm
    438  4775
    439  4775							;---------------------------------------------------------------------------------------------------
    440  4775
      0  4775					      CHECK_BANK_SIZE	"BANK_GENERIC@2"
      1  4775		       03 75	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2 (1K) SIZE =  $375 , FREE= $8b
      2  4775					      ECHO	"BANK_GENERIC@2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4775				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4775				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2", " size=", * - ORIGIN
      5  4775				  -	      ERR
      6  4775					      ENDIF
    442  4775
    443  4775							;---------------------------------------------------------------------------------------------------
    444  4775							;EOF
------- FILE ./chess.asm
------- FILE GFX1.asm LEVEL 2 PASS 4
      0  4775					      include	"GFX1.asm"
      0  4775					      SLOT	2
      1  4775				  -	      IF	(2 < 0) || (2 > 3)
      2  4775				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4775				  -	      ERR
      4  4775					      ENDIF
      5  4775				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4775				   _BANK_SLOT SET	2 * 64
      0  4775					      NEWBANK	GFX1
      1  4bd8 ????				      SEG	GFX1
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   GFX1_START SET	*
      6  4800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4800				   GFX1       SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + 1024
      3  4800
      4  4800
      5  4800							;---------------------------------------------------------------------------------------------------
      6  4800
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  4800					      LIST	ON
      0  4800					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  4800				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4800				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4800				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  4800		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4848					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  4848					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  4848					      LIST	ON
      0  4848					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  4848				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4848				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4848				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  4848				   TEMPORARY_VAR SET	Overlay
      5  4848				   TEMPORARY_OFFSET SET	0
      6  4848				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4848				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  4848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4860		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4890					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  4890					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  4890					      LIST	ON
      0  4890					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  4890				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4890				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4890				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  4890				   TEMPORARY_VAR SET	Overlay
      5  4890				   TEMPORARY_OFFSET SET	0
      6  4890				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4890				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  4890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  48a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  48c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  48d8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  48d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  4900					      LIST	ON
      0  4900					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  4900				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4900				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4900				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  4900				   TEMPORARY_VAR SET	Overlay
      5  4900				   TEMPORARY_OFFSET SET	0
      6  4900				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4900				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  4900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4930		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4948					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  4948					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  4948					      LIST	ON
      0  4948					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  4948				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4948				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4948				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  4948				   TEMPORARY_VAR SET	Overlay
      5  4948				   TEMPORARY_OFFSET SET	0
      6  4948				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4948				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  4948		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  4960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4990					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  4990					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  4990					      LIST	ON
      0  4990					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  4990				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4990				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4990				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  4990				   TEMPORARY_VAR SET	Overlay
      5  4990				   TEMPORARY_OFFSET SET	0
      6  4990				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4990				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  4990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  49a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$14,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  49c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  49d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  49d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  4a00					      LIST	ON
      0  4a00					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  4a00				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4a00				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4a00				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  4a00				   TEMPORARY_VAR SET	Overlay
      5  4a00				   TEMPORARY_OFFSET SET	0
      6  4a00				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4a00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  4a30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$05,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4a48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  4a48					      LIST	ON
      0  4a48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  4a48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4a48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4a48				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  4a48				   TEMPORARY_VAR SET	Overlay
      5  4a48				   TEMPORARY_OFFSET SET	0
      6  4a48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4a48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$a0,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX1.asm
     15  4a90
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4a90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  4a90					      LIST	ON
      0  4a90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  4a90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4a90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4a90				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  4a90				   TEMPORARY_VAR SET	Overlay
      5  4a90				   TEMPORARY_OFFSET SET	0
      6  4a90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4a90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  4a90		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ad8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  4b00					      LIST	ON
      0  4b00					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  4b00				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4b00				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4b00				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  4b00				   TEMPORARY_VAR SET	Overlay
      5  4b00				   TEMPORARY_OFFSET SET	0
      6  4b00				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4b00				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  4b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b18		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4b48					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  4b48					      LIST	ON
      0  4b48					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  4b48				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4b48				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4b48				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  4b48				   TEMPORARY_VAR SET	Overlay
      5  4b48				   TEMPORARY_OFFSET SET	0
      6  4b48				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4b48				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4b78		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4b90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  4b90					      LIST	ON
      0  4b90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  4b90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4b90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4b90				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  4b90				   TEMPORARY_VAR SET	Overlay
      5  4b90				   TEMPORARY_OFFSET SET	0
      6  4b90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4b90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4bc0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
     20  4bd8
     21  4bd8
     22  4bd8							;---------------------------------------------------------------------------------------------------
     23  4bd8
      0  4bd8					      CHECK_BANK_SIZE	"BANK_GFX1"
      1  4bd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX1 (1K) SIZE =  $3d8 , FREE= $28
      2  4bd8					      ECHO	"BANK_GFX1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4bd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX1", " size=", * - ORIGIN
      5  4bd8				  -	      ERR
      6  4bd8					      ENDIF
     25  4bd8
     26  4bd8							;---------------------------------------------------------------------------------------------------
     27  4bd8							;EOF
------- FILE ./chess.asm
------- FILE GFX2.asm LEVEL 2 PASS 4
      0  4bd8					      include	"GFX2.asm"
      0  4bd8					      SLOT	2
      1  4bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4bd8				  -	      ERR
      4  4bd8					      ENDIF
      5  4bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4bd8				   _BANK_SLOT SET	2 * 64
      0  4bd8					      NEWBANK	GFX2
      1  4fd8 ????				      SEG	GFX2
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   GFX2_START SET	*
      6  4c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4c00				   GFX2       SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  4c00
      4  4c00							;---------------------------------------------------------------------------------------------------
      5  4c00
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  4c00					      LIST	ON
      0  4c00					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  4c00				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4c00				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4c00				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  4c00		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  4c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4c48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  4c48					      LIST	ON
      0  4c48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  4c48				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4c48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4c48				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  4c48				   TEMPORARY_VAR SET	Overlay
      5  4c48				   TEMPORARY_OFFSET SET	0
      6  4c48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4c48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  4c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4c90					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  4c90					      LIST	ON
      0  4c90					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  4c90				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4c90				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4c90				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  4c90				   TEMPORARY_VAR SET	Overlay
      5  4c90				   TEMPORARY_OFFSET SET	0
      6  4c90				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4c90				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4cc0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE GFX2.asm
      9  4cd8
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4cd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  4d00					      LIST	ON
      0  4d00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  4d00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4d00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4d00				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  4d00				   TEMPORARY_VAR SET	Overlay
      5  4d00				   TEMPORARY_OFFSET SET	0
      6  4d00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4d00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  4d00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  4d18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4d48					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  4d48					      LIST	ON
      0  4d48					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  4d48				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4d48				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4d48				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  4d48				   TEMPORARY_VAR SET	Overlay
      5  4d48				   TEMPORARY_OFFSET SET	0
      6  4d48				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4d48				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  4d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  4d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4d90					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  4d90					      LIST	ON
      0  4d90					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  4d90				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4d90				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4d90				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  4d90				   TEMPORARY_VAR SET	Overlay
      5  4d90				   TEMPORARY_OFFSET SET	0
      6  4d90				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4d90				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  4d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4da8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4dc0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4dd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  4e00					      LIST	ON
      0  4e00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  4e00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4e00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4e00				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  4e00				   TEMPORARY_VAR SET	Overlay
      5  4e00				   TEMPORARY_OFFSET SET	0
      6  4e00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4e00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4e48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  4e48					      LIST	ON
      0  4e48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  4e48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4e48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4e48				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  4e48				   TEMPORARY_VAR SET	Overlay
      5  4e48				   TEMPORARY_OFFSET SET	0
      6  4e48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4e48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  4e48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  4e60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4e90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  4e90					      LIST	ON
      0  4e90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  4e90				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4e90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4e90				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  4e90				   TEMPORARY_VAR SET	Overlay
      5  4e90				   TEMPORARY_OFFSET SET	0
      6  4e90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4e90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ea8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  4ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4ed8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  4f00					      LIST	ON
      0  4f00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  4f00				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4f00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4f00				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  4f00				   TEMPORARY_VAR SET	Overlay
      5  4f00				   TEMPORARY_OFFSET SET	0
      6  4f00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4f00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  4f30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4f48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  4f48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  4f48					      LIST	ON
      0  4f48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  4f48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4f48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4f48				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  4f48				   TEMPORARY_VAR SET	Overlay
      5  4f48				   TEMPORARY_OFFSET SET	0
      6  4f48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4f48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  4f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4f78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE GFX2.asm
     18  4f90
     19  4f90
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4f90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  4f90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  4f90					      LIST	ON
      0  4f90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  4f90				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4f90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4f90				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  4f90				   TEMPORARY_VAR SET	Overlay
      5  4f90				   TEMPORARY_OFFSET SET	0
      6  4f90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4f90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  4f90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4fa8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
     21  4fd8
     22  4fd8
     23  4fd8							;---------------------------------------------------------------------------------------------------
     24  4fd8
      0  4fd8					      CHECK_BANK_SIZE	"BANK_GFX2"
      1  4fd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX2 (1K) SIZE =  $3d8 , FREE= $28
      2  4fd8					      ECHO	"BANK_GFX2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4fd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX2", " size=", * - ORIGIN
      5  4fd8				  -	      ERR
      6  4fd8					      ENDIF
     26  4fd8
     27  4fd8							;---------------------------------------------------------------------------------------------------
     28  4fd8							;EOF
------- FILE ./chess.asm
------- FILE GFX3.asm LEVEL 2 PASS 4
      0  4fd8					      include	"GFX3.asm"
      0  4fd8					      SLOT	2
      1  4fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4fd8				  -	      ERR
      4  4fd8					      ENDIF
      5  4fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4fd8				   _BANK_SLOT SET	2 * 64
      0  4fd8					      NEWBANK	GFX3
      1  53d8 ????				      SEG	GFX3
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   GFX3_START SET	*
      6  5000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5000				   GFX3       SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + 1024
      3  5000
      4  5000							;---------------------------------------------------------------------------------------------------
      5  5000
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5000					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  5000					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  5000					      LIST	ON
      0  5000					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  5000				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5000				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5000				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  5000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5018		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
      7  5048
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5048					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  5048					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  5048					      LIST	ON
      0  5048					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  5048				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5048				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5048				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  5048				   TEMPORARY_VAR SET	Overlay
      5  5048				   TEMPORARY_OFFSET SET	0
      6  5048				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5048				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  5048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5060		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5078		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5090					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  5090					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  5090					      LIST	ON
      0  5090					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  5090				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5090				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5090				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  5090				   TEMPORARY_VAR SET	Overlay
      5  5090				   TEMPORARY_OFFSET SET	0
      6  5090				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5090				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  5090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  50a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  50c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     10  50d8
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  50d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  50d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  5100					      LIST	ON
      0  5100					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  5100				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5100				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5100				   BLACK_KING_on_BLACK_SQUARE_0
      4  5100				   TEMPORARY_VAR SET	Overlay
      5  5100				   TEMPORARY_OFFSET SET	0
      6  5100				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5100				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  5100		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5118		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5148					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  5148					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  5148					      LIST	ON
      0  5148					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  5148				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5148				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5148				   BLACK_KING_on_BLACK_SQUARE_1
      4  5148				   TEMPORARY_VAR SET	Overlay
      5  5148				   TEMPORARY_OFFSET SET	0
      6  5148				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5148				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  5148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5160		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5190					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  5190					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  5190					      LIST	ON
      0  5190					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  5190				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5190				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5190				   BLACK_KING_on_BLACK_SQUARE_2
      4  5190				   TEMPORARY_VAR SET	Overlay
      5  5190				   TEMPORARY_OFFSET SET	0
      6  5190				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5190				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  5190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  51a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  51c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  51d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  51d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  5200					      LIST	ON
      0  5200					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  5200				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5200				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5200				   BLACK_KING_on_BLACK_SQUARE_3
      4  5200				   TEMPORARY_VAR SET	Overlay
      5  5200				   TEMPORARY_OFFSET SET	0
      6  5200				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5200				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  5200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5230		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     15  5248
     16  5248
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5248					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  5248					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  5248					      LIST	ON
      0  5248					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  5248				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5248				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5248				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  5248				   TEMPORARY_VAR SET	Overlay
      5  5248				   TEMPORARY_OFFSET SET	0
      6  5248				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5248				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  5248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5278		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE GFX3.asm
     18  5290
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5290					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  5290					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  5290					      LIST	ON
      0  5290					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  5290				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5290				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5290				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  5290				   TEMPORARY_VAR SET	Overlay
      5  5290				   TEMPORARY_OFFSET SET	0
      6  5290				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5290				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  5290		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  52a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  52c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  52d8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  52d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  5300					      LIST	ON
      0  5300					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  5300				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5300				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5300				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  5300				   TEMPORARY_VAR SET	Overlay
      5  5300				   TEMPORARY_OFFSET SET	0
      6  5300				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5300				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  5300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5318		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5348					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  5348					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  5348					      LIST	ON
      0  5348					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  5348				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5348				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5348				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  5348				   TEMPORARY_VAR SET	Overlay
      5  5348				   TEMPORARY_OFFSET SET	0
      6  5348				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5348				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  5348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5378		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5390					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  5390					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  5390					      LIST	ON
      0  5390					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  5390				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5390				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5390				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  5390				   TEMPORARY_VAR SET	Overlay
      5  5390				   TEMPORARY_OFFSET SET	0
      6  5390				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5390				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  5390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  53a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     23  53d8
     24  53d8							;---------------------------------------------------------------------------------------------------
     25  53d8
      0  53d8					      CHECK_BANK_SIZE	"BANK_GFX3"
      1  53d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX3 (1K) SIZE =  $3d8 , FREE= $28
      2  53d8					      ECHO	"BANK_GFX3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  53d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  53d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX3", " size=", * - ORIGIN
      5  53d8				  -	      ERR
      6  53d8					      ENDIF
     27  53d8
     28  53d8							;---------------------------------------------------------------------------------------------------
     29  53d8							;EOF
------- FILE ./chess.asm
------- FILE GFX4.asm LEVEL 2 PASS 4
      0  53d8					      include	"GFX4.asm"
      0  53d8					      SLOT	2
      1  53d8				  -	      IF	(2 < 0) || (2 > 3)
      2  53d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  53d8				  -	      ERR
      4  53d8					      ENDIF
      5  53d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  53d8				   _BANK_SLOT SET	2 * 64
      0  53d8					      NEWBANK	GFX4
      1  57d8 ????				      SEG	GFX4
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   GFX4_START SET	*
      6  5400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5400				   GFX4       SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + 1024
      3  5400
      4  5400							;---------------------------------------------------------------------------------------------------
      5  5400
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  5400					      LIST	ON
      0  5400					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  5400				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5400				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5400				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  5400		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  5418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  5448					      LIST	ON
      0  5448					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  5448				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5448				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5448				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  5490					      LIST	ON
      0  5490					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  5490				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5490				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5490				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  54c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  5500					      LIST	ON
      0  5500					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  5500				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5500				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  5500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE GFX4.asm
     10  5548
     11  5548
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5548					      LIST	ON
      0  5548					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  5548				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5548				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5548				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  5548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  5560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5590					      LIST	ON
      0  5590					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  5590				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5590				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5590				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  55c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5600					      LIST	ON
      0  5600					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  5600				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5600				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5600				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  5630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5648					      LIST	ON
      0  5648					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  5648				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5648				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5648				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5690					      LIST	ON
      0  5690					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  5690				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5690				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5690				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  5690		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  56a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5700					      LIST	ON
      0  5700					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  5700				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5700				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5700				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$04,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5748					      LIST	ON
      0  5748					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  5748				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5748				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5748				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5778		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5790					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5790					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5790					      LIST	ON
      0  5790					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  5790				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5790				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5790				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  5790				   TEMPORARY_VAR SET	Overlay
      5  5790				   TEMPORARY_OFFSET SET	0
      6  5790				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5790				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  5790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  57a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  57c0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$80,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
     20  57d8
     21  57d8
     22  57d8							;---------------------------------------------------------------------------------------------------
     23  57d8
      0  57d8					      CHECK_BANK_SIZE	"BANK_GFX4"
      1  57d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX4 (1K) SIZE =  $3d8 , FREE= $28
      2  57d8					      ECHO	"BANK_GFX4", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  57d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  57d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX4", " size=", * - ORIGIN
      5  57d8				  -	      ERR
      6  57d8					      ENDIF
     25  57d8
     26  57d8							;---------------------------------------------------------------------------------------------------
     27  57d8							;EOF
------- FILE ./chess.asm
------- FILE NEGAMAX@1.asm LEVEL 2 PASS 4
      0  57d8					      include	"NEGAMAX@1.asm"
      1  57d8							; Chess
      2  57d8							; Copyright (c) 2019-2020 Andrew Davie
      3  57d8							; andrew@taswegian.com
      4  57d8
      0  57d8					      SLOT	1
      1  57d8				  -	      IF	(1 < 0) || (1 > 3)
      2  57d8				  -	      ECHO	"Illegal bank address/segment location", 1
      3  57d8				  -	      ERR
      4  57d8					      ENDIF
      5  57d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  57d8				   _BANK_SLOT SET	1 * 64
      0  57d8					      NEWBANK	NEGAMAX
      1  5b5e ????				      SEG	NEGAMAX
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   NEGAMAX_START SET	*
      6  5800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5800				   NEGAMAX    SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + 1024
      7  5800
      8  5800							;---------------------------------------------------------------------------------------------------
      9  5800
      0  5800					      DEF	aiComputerMove
      1  5800				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  5800				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  5800				   aiComputerMove
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	aiComputerMove
     11  5800					      SUBROUTINE
     12  5800
      0  5800					      REFER	AiStateMachine	;✅
      1  5800					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5800				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5800					      ENDIF
      0  5800					      VEND	aiComputerMove
      1  5800				  -	      IFNCONST	aiComputerMove
      2  5800				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  5800				  -	      ERR
      4  5800					      ENDIF
      5  5800		       00 a8	   VAREND_aiComputerMove =	TEMPORARY_VAR
     15  5800
     16  5800
     17  5800		       a9 88		      lda	#RAMBANK_PLY
     18  5802		       85 94		      sta	currentPly
     19  5804		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     20  5806
     21  5806		       a9 01		      lda	#1
     22  5808		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
     23  580a
     24  580a
     25  580a		       20 3a f4 	      jsr	selectmove	;@this
     26  580d
     27  580d
     28  580d		       a9 00		      lda	#0
     29  580f		       85 4a		      sta	CTRLPF	; clear mirroring
     30  5811		       85 4e		      sta	PF1
     31  5813		       85 4f		      sta	PF2
     32  5815
     33  5815							; correct ply is already switched
     34  5815
      0  5815					      lda@PLY	bestMove
      1  5815		       ad d1 f9 	      lda	bestMove
     36  5818		       10 17		      bpl	.notComputer
     37  581a
     38  581a							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     39  581a
      0  581a					      SWAP
      1  581a		       a5 95		      lda	sideToMove
      2  581c		       49 80		      eor	#SWAP_SIDE
      3  581e		       85 95		      sta	sideToMove
      4  5820
      5  5820
     41  5820		       20 88 f1 	      jsr	GenerateAllMoves	;@0
     42  5823		       a5 a1		      lda	flagCheck
     43  5825		       f0 05		      beq	.gameDrawn
     44  5827
      0  5827					      PHASE	AI_CheckMate
      1  5827		       a9 23		      lda	#AI_CheckMate
      2  5829		       85 8b		      sta	aiState
     46  582b		       60		      rts
     47  582c
     48  582c
      0  582c				   .gameDrawn PHASE	AI_Draw
      1  582c		       a9 24		      lda	#AI_Draw
      2  582e		       85 8b		      sta	aiState
     50  5830		       60		      rts
     51  5831
     52  5831				   .notComputer
     53  5831
     54  5831
     55  5831		       a9 ff		      lda	#-1
     56  5833		       85 88		      sta	cursorX12
     57  5835
      0  5835					      PHASE	AI_DelayAfterMove
      1  5835		       a9 25		      lda	#AI_DelayAfterMove
      2  5837		       85 8b		      sta	aiState
     59  5839		       60	   .halted    rts
     60  583a
     61  583a
     62  583a							;---------------------------------------------------------------------------------------------------
     63  583a
      0  583a					      DEF	selectmove
      1  583a				   SLOT_selectmove SET	_BANK_SLOT
      2  583a				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  583a				   selectmove
      4  583a				   TEMPORARY_VAR SET	Overlay
      5  583a				   TEMPORARY_OFFSET SET	0
      6  583a				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  583a				   FUNCTION_NAME SET	selectmove
     65  583a					      SUBROUTINE
     66  583a
      0  583a					      COMMON_VARS
      1  583a
      0  583a					      VAR	__thinkbar, 1
      1  583a		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__toggle, 1
      1  583a		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      4  583a
      0  583a					      VAR	__bestMove, 1
      1  583a		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__alpha, 2
      1  583a		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__beta, 2
      1  583a		       00 ab	   __beta     =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__negaMax, 2
      1  583a		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__value, 2
      1  583a		       00 af	   __value    =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
     10  583a
      0  583a					      VAR	__quiesceCapOnly, 1
      1  583a		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
     12  583a
      0  583a					      VAR	__originalPiece, 1
      1  583a		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__capturedPiece, 1
      1  583a		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
     15  583a
      0  583a					      REFER	aiComputerMove	;✅
      1  583a				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  583a				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  583a					      ENDIF
      0  583a					      VEND	selectmove
      1  583a				  -	      IFNCONST	selectmove
      2  583a				  -	      ECHO	"Incorrect VEND label", selectmove
      3  583a				  -	      ERR
      4  583a					      ENDIF
      5  583a		       00 b4	   VAREND_selectmove =	TEMPORARY_VAR
     70  583a
     71  583a
     72  583a							; RAM bank already switched in!!!
     73  583a							; returns with RAM bank switched
     74  583a
     75  583a
     76  583a					      IF	DIAGNOSTICS
     77  583a
     78  583a		       a9 00		      lda	#0
     79  583c		       85 9e		      sta	positionCount
     80  583e		       85 9f		      sta	positionCount+1
     81  5840		       85 a0		      sta	positionCount+2
     82  5842							;sta maxPly
     83  5842					      ENDIF
     84  5842
     85  5842
     86  5842		       a9 00		      lda	#<INFINITY
     87  5844		       85 ab		      sta	__beta
     88  5846		       a9 70		      lda	#>INFINITY
     89  5848		       85 ac		      sta	__beta+1
     90  584a
     91  584a		       a9 00		      lda	#<-INFINITY
     92  584c		       85 a9		      sta	__alpha
     93  584e		       a9 90		      lda	#>-INFINITY
     94  5850		       85 aa		      sta	__alpha+1	; player tries to maximise
     95  5852
     96  5852		       a2 03		      ldx	#SEARCH_DEPTH
     97  5854		       a9 00		      lda	#0	; no captured piece
     98  5856		       85 b1		      sta	__quiesceCapOnly	; ALL moves to be generated
     99  5858
    100  5858		       20 08 f5 	      jsr	negaMax
    101  585b
    102  585b							;lda currentPly
    103  585b							;sta SET_BANK_RAM ;tmp?
    104  585b
      0  585b					      ldx@PLY	bestMove
      1  585b		       ae d1 f9 	      ldx	bestMove
    106  585e		       30 26		      bmi	.nomove
    107  5860
    108  5860							; Generate player's moves in reply
    109  5860							; Make the computer move, list player moves (PLY+1), unmake computer move
    110  5860
      0  5860					      stx@PLY	movePtr
      1  5860		       8e d0 fb 	      stx	[RAM]+movePtr
    112  5863		       20 87 f4 	      jsr	MakeMove	;@this
    113  5866		       20 28 f2 	      jsr	ListPlayerMoves	;@0
    114  5869
    115  5869		       c6 94		      dec	currentPly
    116  586b		       20 87 f2 	      jsr	unmakeMove	;@0
    117  586e
    118  586e							; Grab the computer move details for the UI animation
    119  586e
    120  586e		       a9 88		      lda	#RAMBANK_PLY
    121  5870		       85 3e		      sta	SET_BANK_RAM
    122  5872
      0  5872					      ldx@PLY	bestMove
      1  5872		       ae d1 f9 	      ldx	bestMove
      0  5875					      lda@PLY	MoveTo,x
      1  5875		       bd 64 f8 	      lda	MoveTo,x
    125  5878		       85 86		      sta	toX12
      0  587a					      lda@PLY	MoveFrom,x
      1  587a		       bd 00 f8 	      lda	MoveFrom,x
    127  587d		       85 87		      sta	originX12
    128  587f		       85 85		      sta	fromX12
      0  5881					      lda@PLY	MovePiece,x
      1  5881		       bd 00 f9 	      lda	MovePiece,x
    130  5884		       85 96		      sta	fromPiece
    131  5886
    132  5886				   .nomove
    133  5886		       60		      rts
    134  5887
    135  5887
    136  5887							;---------------------------------------------------------------------------------------------------
    137  5887
      0  5887					      DEF	MakeMove
      1  5887				   SLOT_MakeMove SET	_BANK_SLOT
      2  5887				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  5887				   MakeMove
      4  5887				   TEMPORARY_VAR SET	Overlay
      5  5887				   TEMPORARY_OFFSET SET	0
      6  5887				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  5887				   FUNCTION_NAME SET	MakeMove
    139  5887					      SUBROUTINE
    140  5887
      0  5887					      COMMON_VARS
      1  5887
      0  5887					      VAR	__thinkbar, 1
      1  5887		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__toggle, 1
      1  5887		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      4  5887
      0  5887					      VAR	__bestMove, 1
      1  5887		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__alpha, 2
      1  5887		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__beta, 2
      1  5887		       00 ab	   __beta     =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__negaMax, 2
      1  5887		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__value, 2
      1  5887		       00 af	   __value    =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
     10  5887
      0  5887					      VAR	__quiesceCapOnly, 1
      1  5887		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
     12  5887
      0  5887					      VAR	__originalPiece, 1
      1  5887		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__capturedPiece, 1
      1  5887		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
     15  5887
      0  5887					      REFER	selectmove	;✅
      1  5887				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  5887					      ENDIF
      0  5887					      REFER	ListPlayerMoves	;✅
      1  5887				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  5887					      ENDIF
      0  5887					      REFER	quiesce	;✅
      1  5887				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  5887					      ENDIF
      0  5887					      REFER	negaMax	;✅
      1  5887				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  5887					      ENDIF
      0  5887					      VEND	MakeMove
      1  5887				  -	      IFNCONST	MakeMove
      2  5887				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  5887				  -	      ERR
      4  5887					      ENDIF
      5  5887		       00 b4	   VAREND_MakeMove =	TEMPORARY_VAR
    147  5887
    148  5887							; Do a move without any GUI stuff
    149  5887							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    150  5887							; and all relevant flags in original state. This is NOT used for the visible move on the
    151  5887							; screen.
    152  5887
    153  5887
    154  5887							; fromPiece	 piece doing the move
    155  5887							; fromX12	 current square X12
    156  5887							; originX12	 starting square X12
    157  5887							; toX12	 ending square X12
    158  5887
    159  5887							; BANK:SLOT2 = currentPly
    160  5887
    161  5887
    162  5887							; There are potentially "two" moves, with the following
    163  5887							; a) Castling, moving both rook and king
    164  5887							; b) en-Passant, capturing pawn on "odd" square
    165  5887							; These both set "secondary" movers which are used for restoring during unmakeMove
    166  5887
    167  5887		       a0 d1		      ldy	#RAMBANK_BOARD
    168  5889		       84 3e		      sty	SET_BANK_RAM	;@3
    169  588b
      0  588b					      ldx@PLY	movePtr
      1  588b		       ae d0 f9 	      ldx	movePtr
      0  588e					      ldy@PLY	MoveFrom,x
      1  588e		       bc 00 f8 	      ldy	MoveFrom,x
    172  5891		       84 85		      sty	fromX12
    173  5893		       84 87		      sty	originX12
    174  5895
      0  5895					      lda@RAM	Board,y
      1  5895		       b9 79 fc 	      lda	Board,y
    176  5898		       85 b2		      sta	__originalPiece
      0  589a					      sta@PLY	restorePiece
      1  589a		       8d d9 fb 	      sta	[RAM]+restorePiece
    178  589d
    179  589d		       a9 00		      lda	#0
      0  589f					      sta@RAM	Board,y
      1  589f		       99 79 fe 	      sta	[RAM]+Board,y
      0  58a2					      sta@PLY	secondaryPiece
      1  58a2		       8d cc fb 	      sta	[RAM]+secondaryPiece
    182  58a5
      0  58a5					      ldy@PLY	MoveTo,x
      1  58a5		       bc 64 f8 	      ldy	MoveTo,x
    184  58a8		       84 86		      sty	toX12
    185  58aa
      0  58aa					      lda@RAM	Board,y
      1  58aa		       b9 79 fc 	      lda	Board,y
    187  58ad		       85 b3		      sta	__capturedPiece
      0  58af					      sta@PLY	capturedPiece
      1  58af		       8d cb fb 	      sta	[RAM]+capturedPiece
    189  58b2
      0  58b2					      lda@PLY	MovePiece,x
      1  58b2		       bd 00 f9 	      lda	MovePiece,x
    191  58b5		       85 96		      sta	fromPiece
    192  58b7
    193  58b7		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
    194  58b9		       09 40		      ora	#FLAG_MOVED
      0  58bb					      sta@RAM	Board,y
      1  58bb		       99 79 fe 	      sta	[RAM]+Board,y
    196  58be
    197  58be
      0  58be				   .move      CALL	AdjustMaterialPositionalValue	;@2
      1  58be				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  58be				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  58be				  -	      ECHO	"Cannot switch bank in use for", AdjustMaterialPositionalValue
      4  58be				  -	      ERR
      5  58be					      ENDIF
      6  58be		       a9 91		      lda	#BANK_AdjustMaterialPositionalValue
      7  58c0		       85 3f		      sta	SET_BANK
      8  58c2		       20 c5 f8 	      jsr	AdjustMaterialPositionalValue
    199  58c5
    200  58c5
    201  58c5					      IF	CASTLING_ENABLED
    202  58c5
    203  58c5							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    204  58c5							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    205  58c5							; redo the moving code (for the rook, this time).
    206  58c5
      0  58c5					      CALL	GenCastleMoveForRook	;@3
      1  58c5				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  58c5				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  58c5				  -	      ECHO	"Cannot switch bank in use for", GenCastleMoveForRook
      4  58c5				  -	      ERR
      5  58c5					      ENDIF
      6  58c5		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      7  58c7		       85 3f		      sta	SET_BANK
      8  58c9		       20 21 fc 	      jsr	GenCastleMoveForRook
    208  58cc		       b0 f0		      bcs	.move	; move the rook!
    209  58ce					      ENDIF
    210  58ce
    211  58ce
    212  58ce				  -	      IF	ENPASSANT_ENABLED
    213  58ce				  -	      jsr	EnPassantCheck
    214  58ce				  -	      beq	.notEnPassant
    215  58ce				  -	      jsr	EnPassantRemovePiece	; TODO will crash wrong bank!!!  y = origin X12
    216  58ce				  -.notEnPassant
    217  58ce					      ENDIF
    218  58ce
    219  58ce							; Swap over sides
    220  58ce
      0  58ce					      NEGEVAL
      1  58ce
      2  58ce		       38		      sec
      3  58cf		       a9 00		      lda	#0
      4  58d1		       e5 8f		      sbc	Evaluation
      5  58d3		       85 8f		      sta	Evaluation
      6  58d5		       a9 00		      lda	#0
      7  58d7		       e5 90		      sbc	Evaluation+1
      8  58d9		       85 90		      sta	Evaluation+1
      0  58db					      SWAP
      1  58db		       a5 95		      lda	sideToMove
      2  58dd		       49 80		      eor	#SWAP_SIDE
      3  58df		       85 95		      sta	sideToMove
      4  58e1
      5  58e1
    223  58e1
    224  58e1		       a5 94		      lda	currentPly
    225  58e3		       85 3e		      sta	SET_BANK_RAM
    226  58e5		       60		      rts
    227  58e6
    228  58e6
    229  58e6							;---------------------------------------------------------------------------------------------------
    230  58e6
    231  58e6							;function negaMax(node, depth, α, β, color) is
    232  58e6							;    if depth = 0 or node is a terminal node then
    233  58e6							;	  return color × the heuristic value of node
    234  58e6
    235  58e6							;    childNodes := generateMoves(node)
    236  58e6							;    childNodes := orderMoves(childNodes)
    237  58e6							;    value := −∞
    238  58e6							;    foreach child in childNodes do
    239  58e6							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    240  58e6							;	  α := max(α, value)
    241  58e6							;	  if α ≥ β then
    242  58e6							;	      break (* cut-off *)
    243  58e6							;    return value
    244  58e6							;(* Initial call for Player A's root node *)
    245  58e6							;negaMax(rootNode, depth, −∞, +∞, 1)
    246  58e6
    247  58e6
    248  58e6					      SUBROUTINE
    249  58e6
    250  58e6		       a9 ff	   .doQ       lda	#-1
    251  58e8		       85 b1		      sta	__quiesceCapOnly
    252  58ea		       20 77 f6 	      jsr	quiesce
    253  58ed		       e6 b1		      inc	__quiesceCapOnly
    254  58ef		       60		      rts
    255  58f0
    256  58f0
      0  58f0				   .exit      lda@PLY	value
      1  58f0		       ad d6 f9 	      lda	value
    258  58f3		       85 ad		      sta	__negaMax
      0  58f5					      lda@PLY	value+1
      1  58f5		       ad d7 f9 	      lda	value+1
    260  58f8		       85 ae		      sta	__negaMax+1
    261  58fa		       60		      rts
    262  58fb
    263  58fb
    264  58fb				   .terminal
    265  58fb
    266  58fb					      IF	QUIESCE_EXTRA_DEPTH > 0
    267  58fb		       c9 00		      cmp	#0	; captured piece
    268  58fd		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
    269  58ff					      ENDIF
    270  58ff
    271  58ff
    272  58ff		       a5 8f		      lda	Evaluation
    273  5901		       85 ad		      sta	__negaMax
    274  5903		       a5 90		      lda	Evaluation+1
    275  5905		       85 ae		      sta	__negaMax+1
    276  5907
    277  5907		       60	   .inCheck2  rts
    278  5908
    279  5908
    280  5908
      0  5908					      DEF	negaMax
      1  5908				   SLOT_negaMax SET	_BANK_SLOT
      2  5908				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  5908				   negaMax
      4  5908				   TEMPORARY_VAR SET	Overlay
      5  5908				   TEMPORARY_OFFSET SET	0
      6  5908				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  5908				   FUNCTION_NAME SET	negaMax
    282  5908
    283  5908							; PARAMS depth-1, -beta, -alpha
    284  5908							; pased through temporary variables (__alpha, __beta) and X reg
    285  5908
    286  5908							; pass...
    287  5908							; x = depthleft
    288  5908							; a = captured piece
    289  5908							; SET_BANK_RAM      --> current ply
    290  5908							; __alpha[2] = param alpha
    291  5908							; __beta[2] = param beta
    292  5908
    293  5908
      0  5908					      COMMON_VARS
      1  5908
      0  5908					      VAR	__thinkbar, 1
      1  5908		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
      0  5908					      VAR	__toggle, 1
      1  5908		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
      4  5908
      0  5908					      VAR	__bestMove, 1
      1  5908		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
      0  5908					      VAR	__alpha, 2
      1  5908		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
      0  5908					      VAR	__beta, 2
      1  5908		       00 ab	   __beta     =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
      0  5908					      VAR	__negaMax, 2
      1  5908		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
      0  5908					      VAR	__value, 2
      1  5908		       00 af	   __value    =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
     10  5908
      0  5908					      VAR	__quiesceCapOnly, 1
      1  5908		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
     12  5908
      0  5908					      VAR	__originalPiece, 1
      1  5908		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
      0  5908					      VAR	__capturedPiece, 1
      1  5908		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  5908				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5908
      4  5908				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5908				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5908				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5908					      ENDIF
      8  5908				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5908				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  5908				  -	      ERR
     11  5908					      ENDIF
     12  5908					      LIST	ON
     15  5908
      0  5908					      REFER	selectmove	;✅
      1  5908				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  5908				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  5908					      ENDIF
      0  5908					      VEND	negaMax
      1  5908				  -	      IFNCONST	negaMax
      2  5908				  -	      ECHO	"Incorrect VEND label", negaMax
      3  5908				  -	      ERR
      4  5908					      ENDIF
      5  5908		       00 b4	   VAREND_negaMax =	TEMPORARY_VAR
    297  5908
    298  5908		       48		      pha
    299  5909
    300  5909		       20 7a f0 	      jsr	ThinkBar	;@0
    301  590c
    302  590c		       a5 94		      lda	currentPly
    303  590e		       85 3e		      sta	SET_BANK_RAM	;@2
    304  5910
    305  5910		       68		      pla
    306  5911		       ca		      dex
    307  5912		       30 e7		      bmi	.terminal
      0  5914					      stx@PLY	depthLeft
      1  5914		       8e d8 fb 	      stx	[RAM]+depthLeft
    309  5917
    310  5917
    311  5917							; Allow the player to force computer to select a move. Press the SELECT switch
    312  5917
      0  5917					      lda@PLY	bestMove
      1  5917		       ad d1 f9 	      lda	bestMove
    314  591a		       30 07		      bmi	.noCheat	; can't force if no move chosen!
    315  591c		       ad 82 02 	      lda	SWCHB
    316  591f		       29 02		      and	#2
    317  5921		       f0 cd		      beq	.exit	; SELECT abort
    318  5923				   .noCheat
    319  5923
    320  5923
      0  5923					      NEXT_RANDOM
      1  5923		       a5 81		      lda	rnd
      2  5925		       4a		      lsr
      3  5926		       90 02		      bcc	.skipEOR
      4  5928		       49 fe		      eor	#RND_EOR_VAL
      5  592a		       85 81	   .skipEOR   sta	rnd
    322  592c		       25 a3		      and	randomness
    323  592e		       65 8f		      adc	Evaluation
    324  5930		       85 8f		      sta	Evaluation	; since it's random we don't care about HI
    325  5932							;bcc .evOK
    326  5932							;inc Evaluation+1
    327  5932				   .evOK
    328  5932
    329  5932
    330  5932
    331  5932							;lda #2
    332  5932							;sta COLUPF			  ; grey thinkbars
    333  5932
    334  5932		       a5 a9		      lda	__alpha
      0  5934					      sta@PLY	alpha
      1  5934		       8d d2 fb 	      sta	[RAM]+alpha
    336  5937		       a5 aa		      lda	__alpha+1
      0  5939					      sta@PLY	alpha+1
      1  5939		       8d d3 fb 	      sta	[RAM]+alpha+1
    338  593c
    339  593c		       a5 ab		      lda	__beta
      0  593e					      sta@PLY	beta
      1  593e		       8d d4 fb 	      sta	[RAM]+beta
    341  5941		       a5 ac		      lda	__beta+1
      0  5943					      sta@PLY	beta+1
      1  5943		       8d d5 fb 	      sta	[RAM]+beta+1
    343  5946
    344  5946
    345  5946		       20 88 f1 	      jsr	GenerateAllMoves	;@0
    346  5949
    347  5949		       a5 a1		      lda	flagCheck
    348  594b		       d0 ba		      bne	.inCheck2	; OTHER guy in check
    349  594d
    350  594d		       a9 00		      lda	#<-INFINITY
      0  594f					      sta@PLY	value
      1  594f		       8d d6 fb 	      sta	[RAM]+value
    352  5952		       a9 90		      lda	#>-INFINITY
      0  5954					      sta@PLY	value+1
      1  5954		       8d d7 fb 	      sta	[RAM]+value+1
    354  5957
      0  5957					      ldx@PLY	moveIndex
      1  5957		       ae cf f9 	      ldx	moveIndex
    356  595a		       10 03		      bpl	.forChild
    357  595c		       4c f0 f4 	      jmp	.exit
    358  595f
      0  595f				   .forChild  stx@PLY	movePtr
      1  595f		       8e d0 fb 	      stx	[RAM]+movePtr
    360  5962
    361  5962		       20 87 f4 	      jsr	MakeMove	;@this
    362  5965
    363  5965
    364  5965							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    365  5965
    366  5965							; PARAMS depth-1, -beta, -alpha
    367  5965							; pased through temporary variables (__alpha, __beta) and X reg
    368  5965
    369  5965		       38		      sec
    370  5966		       a9 00		      lda	#0
      0  5968					      sbc@PLY	beta
      1  5968		       ed d4 f9 	      sbc	beta
    372  596b		       85 a9		      sta	__alpha
    373  596d		       a9 00		      lda	#0
      0  596f					      sbc@PLY	beta+1
      1  596f		       ed d5 f9 	      sbc	beta+1
    375  5972		       85 aa		      sta	__alpha+1
    376  5974
    377  5974		       38		      sec
    378  5975		       a9 00		      lda	#0
      0  5977					      sbc@PLY	alpha
      1  5977		       ed d2 f9 	      sbc	alpha
    380  597a		       85 ab		      sta	__beta
    381  597c		       a9 00		      lda	#0
      0  597e					      sbc@PLY	alpha+1
      1  597e		       ed d3 f9 	      sbc	alpha+1
    383  5981		       85 ac		      sta	__beta+1
    384  5983
    385  5983
      0  5983					      ldx@PLY	depthLeft
      1  5983		       ae d8 f9 	      ldx	depthLeft
      0  5986					      lda@PLY	capturedPiece
      1  5986		       ad cb f9 	      lda	capturedPiece
    388  5989
    389  5989		       e6 94		      inc	currentPly
    390  598b		       a4 94		      ldy	currentPly
    391  598d		       84 3e		      sty	SET_BANK_RAM	; self-switch
    392  598f
    393  598f		       20 08 f5 	      jsr	negaMax	;@this
    394  5992
    395  5992		       c6 94		      dec	currentPly
    396  5994		       a5 94		      lda	currentPly
    397  5996		       85 3e		      sta	SET_BANK_RAM
    398  5998
    399  5998		       20 87 f2 	      jsr	unmakeMove	;@0
    400  599b
    401  599b		       38		      sec
    402  599c		       a9 00		      lda	#0
    403  599e		       e5 ad		      sbc	__negaMax
    404  59a0		       85 ad		      sta	__negaMax
    405  59a2		       a9 00		      lda	#0
    406  59a4		       e5 ae		      sbc	__negaMax+1
    407  59a6		       85 ae		      sta	__negaMax+1	; -negaMax(...)
    408  59a8
    409  59a8					      IF	1
    410  59a8		       a5 a1		      lda	flagCheck
    411  59aa		       f0 06		      beq	.notCheck
    412  59ac
    413  59ac							; at this point we've determined that the move was illegal, because the next ply detected
    414  59ac							; a king capture. So, the move should be totally discounted
    415  59ac
    416  59ac		       a9 00		      lda	#0
    417  59ae		       85 a1		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    418  59b0		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    419  59b2					      ENDIF
    420  59b2
    421  59b2		       38	   .notCheck  sec
      0  59b3					      lda@PLY	value
      1  59b3		       ad d6 f9 	      lda	value
    423  59b6		       e5 ad		      sbc	__negaMax
      0  59b8					      lda@PLY	value+1
      1  59b8		       ad d7 f9 	      lda	value+1
    425  59bb		       e5 ae		      sbc	__negaMax+1
    426  59bd		       50 02		      bvc	.lab0
    427  59bf		       49 80		      eor	#$80
    428  59c1		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    429  59c3
    430  59c3							; so, negaMax > value!
    431  59c3
    432  59c3		       a5 ad		      lda	__negaMax
      0  59c5					      sta@PLY	value
      1  59c5		       8d d6 fb 	      sta	[RAM]+value
    434  59c8		       a5 ae		      lda	__negaMax+1
      0  59ca					      sta@PLY	value+1	; max(value, -negaMax)
      1  59ca		       8d d7 fb 	      sta	[RAM]+value+1
    436  59cd
      0  59cd					      lda@PLY	movePtr
      1  59cd		       ad d0 f9 	      lda	movePtr
      0  59d0					      sta@PLY	bestMove
      1  59d0		       8d d1 fb 	      sta	[RAM]+bestMove
    439  59d3				   .lt0
    440  59d3
    441  59d3							;	  α := max(α, value)
    442  59d3
    443  59d3		       38		      sec
      0  59d4					      lda@PLY	value
      1  59d4		       ad d6 f9 	      lda	value
      0  59d7					      sbc@PLY	alpha
      1  59d7		       ed d2 f9 	      sbc	alpha
      0  59da					      lda@PLY	value+1
      1  59da		       ad d7 f9 	      lda	value+1
      0  59dd					      sbc@PLY	alpha+1
      1  59dd		       ed d3 f9 	      sbc	alpha+1
    448  59e0		       50 02		      bvc	.lab1
    449  59e2		       49 80		      eor	#$80
    450  59e4		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    451  59e6
      0  59e6					      lda@PLY	value
      1  59e6		       ad d6 f9 	      lda	value
      0  59e9					      sta@PLY	alpha
      1  59e9		       8d d2 fb 	      sta	[RAM]+alpha
      0  59ec					      lda@PLY	value+1
      1  59ec		       ad d7 f9 	      lda	value+1
      0  59ef					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  59ef		       8d d3 fb 	      sta	[RAM]+alpha+1
    456  59f2
    457  59f2				   .lt1
    458  59f2
    459  59f2							;	  if α ≥ β then
    460  59f2							;	      break (* cut-off *)
    461  59f2
    462  59f2		       38		      sec
      0  59f3					      lda@PLY	alpha
      1  59f3		       ad d2 f9 	      lda	alpha
      0  59f6					      sbc@PLY	beta
      1  59f6		       ed d4 f9 	      sbc	beta
      0  59f9					      lda@PLY	alpha+1
      1  59f9		       ad d3 f9 	      lda	alpha+1
      0  59fc					      sbc@PLY	beta+1
      1  59fc		       ed d5 f9 	      sbc	beta+1
    467  59ff		       50 02		      bvc	.lab2
    468  5a01		       49 80		      eor	#$80
    469  5a03		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    470  5a05
    471  5a05
      0  5a05				   .nextMove  ldx@PLY	movePtr
      1  5a05		       ae d0 f9 	      ldx	movePtr
    473  5a08		       ca	   .nextX     dex
    474  5a09		       30 03		      bmi	.retrn
    475  5a0b		       4c 5f f5 	      jmp	.forChild
    476  5a0e
    477  5a0e		       4c f0 f4    .retrn     jmp	.exit
    478  5a11
    479  5a11							;---------------------------------------------------------------------------------------------------
    480  5a11
    481  5a11					      MAC	xchg
    482  5a11					      lda@PLY	{1},x
    483  5a11					      pha		;sta __xchg
    484  5a11					      lda@PLY	{1},y
    485  5a11					      sta@PLY	{1},x
    486  5a11					      pla		;lda __xchg
    487  5a11					      sta@PLY	{1},y
    488  5a11					      ENDM		;{name}
    489  5a11
    490  5a11
      0  5a11					      DEF	Sort
      1  5a11				   SLOT_Sort  SET	_BANK_SLOT
      2  5a11				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  5a11				   Sort
      4  5a11				   TEMPORARY_VAR SET	Overlay
      5  5a11				   TEMPORARY_OFFSET SET	0
      6  5a11				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  5a11				   FUNCTION_NAME SET	Sort
    492  5a11					      SUBROUTINE
    493  5a11
      0  5a11					      REFER	GenerateAllMoves
      1  5a11					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5a11				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5a11					      ENDIF
      0  5a11					      VAR	__xchg, 1
      1  5a11		       00 b7	   __xchg     =	TEMPORARY_VAR
      2  5a11				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a11
      4  5a11				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a11				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a11				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a11					      ENDIF
      8  5a11				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a11				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  5a11				  -	      ERR
     11  5a11					      ENDIF
     12  5a11					      LIST	ON
      0  5a11					      VEND	Sort
      1  5a11				  -	      IFNCONST	Sort
      2  5a11				  -	      ECHO	"Incorrect VEND label", Sort
      3  5a11				  -	      ERR
      4  5a11					      ENDIF
      5  5a11		       00 b8	   VAREND_Sort =	TEMPORARY_VAR
    497  5a11
    498  5a11		       a5 b1		      lda	__quiesceCapOnly
    499  5a13		       d0 4a		      bne	.exit	; only caps present so already sorted!
    500  5a15
      0  5a15					      ldx@PLY	moveIndex
      1  5a15		       ae cf f9 	      ldx	moveIndex
      0  5a18					      ldy@PLY	moveIndex
      1  5a18		       ac cf f9 	      ldy	moveIndex
    503  5a1b		       c8		      iny		; this is OK - swaps "1st" with itself if it's a capture
    504  5a1c
    505  5a1c		       88	   .next      dey
    506  5a1d		       30 40		      bmi	.exit
    507  5a1f
      0  5a1f					      lda@PLY	MoveCapture,y
      1  5a1f		       b9 64 f9 	      lda	MoveCapture,y
    509  5a22		       f0 f8		      beq	.next
    510  5a24
      0  5a24					      XCHG	MoveFrom
      0  5a24					      lda@PLY	MoveFrom,x
      1  5a24		       bd 00 f8 	      lda	MoveFrom,x
      2  5a27		       48		      pha
      0  5a28					      lda@PLY	MoveFrom,y
      1  5a28		       b9 00 f8 	      lda	MoveFrom,y
      0  5a2b					      sta@PLY	MoveFrom,x
      1  5a2b		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  5a2e		       68		      pla
      0  5a2f					      sta@PLY	MoveFrom,y
      1  5a2f		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  5a32					      XCHG	MoveTo
      0  5a32					      lda@PLY	MoveTo,x
      1  5a32		       bd 64 f8 	      lda	MoveTo,x
      2  5a35		       48		      pha
      0  5a36					      lda@PLY	MoveTo,y
      1  5a36		       b9 64 f8 	      lda	MoveTo,y
      0  5a39					      sta@PLY	MoveTo,x
      1  5a39		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  5a3c		       68		      pla
      0  5a3d					      sta@PLY	MoveTo,y
      1  5a3d		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  5a40					      XCHG	MovePiece
      0  5a40					      lda@PLY	MovePiece,x
      1  5a40		       bd 00 f9 	      lda	MovePiece,x
      2  5a43		       48		      pha
      0  5a44					      lda@PLY	MovePiece,y
      1  5a44		       b9 00 f9 	      lda	MovePiece,y
      0  5a47					      sta@PLY	MovePiece,x
      1  5a47		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  5a4a		       68		      pla
      0  5a4b					      sta@PLY	MovePiece,y
      1  5a4b		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  5a4e					      XCHG	MoveCapture
      0  5a4e					      lda@PLY	MoveCapture,x
      1  5a4e		       bd 64 f9 	      lda	MoveCapture,x
      2  5a51		       48		      pha
      0  5a52					      lda@PLY	MoveCapture,y
      1  5a52		       b9 64 f9 	      lda	MoveCapture,y
      0  5a55					      sta@PLY	MoveCapture,x
      1  5a55		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  5a58		       68		      pla
      0  5a59					      sta@PLY	MoveCapture,y
      1  5a59		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    515  5a5c
    516  5a5c		       ca		      dex
    517  5a5d		       10 bd		      bpl	.next
    518  5a5f
    519  5a5f				   .exit
    520  5a5f
    521  5a5f
    522  5a5f
    523  5a5f
    524  5a5f							; Scan for capture of king
    525  5a5f
      0  5a5f					      ldx@PLY	moveIndex
      1  5a5f		       ae cf f9 	      ldx	moveIndex
    527  5a62		       30 0e		      bmi	.notCheck	; OK if no captures in quiesce!
    528  5a64
      0  5a64				   .scanCheck lda@PLY	MoveCapture,x
      1  5a64		       bd 64 f9 	      lda	MoveCapture,x
    530  5a67		       f0 0b		      beq	.check	; since they're sorted with captures "first" we can exit
    531  5a69		       29 0f		      and	#PIECE_MASK
    532  5a6b		       c9 07		      cmp	#KING
    533  5a6d		       f0 05		      beq	.check
    534  5a6f		       ca		      dex
    535  5a70		       10 f2		      bpl	.scanCheck
    536  5a72
    537  5a72		       a9 00	   .notCheck  lda	#0
    538  5a74		       85 a1	   .check     sta	flagCheck
    539  5a76		       60		      rts
    540  5a77
    541  5a77
    542  5a77							;---------------------------------------------------------------------------------------------------
    543  5a77							; QUIESCE!
    544  5a77
    545  5a77							;int Quiesce( int alpha, int beta ) {
    546  5a77							;    int stand_pat = Evaluate();
    547  5a77							;    if( stand_pat >= beta )
    548  5a77							;	  return beta;
    549  5a77							;    if( alpha < stand_pat )
    550  5a77							;	  alpha = stand_pat;
    551  5a77
    552  5a77							;    until( every_capture_has_been_examined )	{
    553  5a77							;	  MakeCapture();
    554  5a77							;	  score = -Quiesce( -beta, -alpha );
    555  5a77							;	  TakeBackMove();
    556  5a77
    557  5a77							;	  if( score >= beta )
    558  5a77							;	      return beta;
    559  5a77							;	  if( score > alpha )
    560  5a77							;	     alpha = score;
    561  5a77							;    }
    562  5a77							;    return alpha;
    563  5a77							;}
    564  5a77
    565  5a77
    566  5a77							;---------------------------------------------------------------------------------------------------
    567  5a77
      0  5a77					      DEF	quiesce
      1  5a77				   SLOT_quiesce SET	_BANK_SLOT
      2  5a77				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  5a77				   quiesce
      4  5a77				   TEMPORARY_VAR SET	Overlay
      5  5a77				   TEMPORARY_OFFSET SET	0
      6  5a77				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  5a77				   FUNCTION_NAME SET	quiesce
    569  5a77					      SUBROUTINE
    570  5a77
    571  5a77							; pass...
    572  5a77							; x = depthleft
    573  5a77							; SET_BANK_RAM      --> current ply
    574  5a77							; __alpha[2] = param alpha
    575  5a77							; __beta[2] = param beta
    576  5a77
    577  5a77
      0  5a77					      COMMON_VARS
      1  5a77
      0  5a77					      VAR	__thinkbar, 1
      1  5a77		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
      0  5a77					      VAR	__toggle, 1
      1  5a77		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
      4  5a77
      0  5a77					      VAR	__bestMove, 1
      1  5a77		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
      0  5a77					      VAR	__alpha, 2
      1  5a77		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
      0  5a77					      VAR	__beta, 2
      1  5a77		       00 ab	   __beta     =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
      0  5a77					      VAR	__negaMax, 2
      1  5a77		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
      0  5a77					      VAR	__value, 2
      1  5a77		       00 af	   __value    =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
     10  5a77
      0  5a77					      VAR	__quiesceCapOnly, 1
      1  5a77		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
     12  5a77
      0  5a77					      VAR	__originalPiece, 1
      1  5a77		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
      0  5a77					      VAR	__capturedPiece, 1
      1  5a77		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  5a77				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a77
      4  5a77				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a77				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a77				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a77					      ENDIF
      8  5a77				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a77				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  5a77				  -	      ERR
     11  5a77					      ENDIF
     12  5a77					      LIST	ON
     15  5a77
      0  5a77					      REFER	negaMax
      1  5a77				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  5a77				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  5a77					      ENDIF
      0  5a77					      VEND	quiesce
      1  5a77				  -	      IFNCONST	quiesce
      2  5a77				  -	      ECHO	"Incorrect VEND label", quiesce
      3  5a77				  -	      ERR
      4  5a77					      ENDIF
      5  5a77		       00 b4	   VAREND_quiesce =	TEMPORARY_VAR
    581  5a77
    582  5a77		       a5 94		      lda	currentPly
    583  5a79		       c9 90		      cmp	#RAMBANK_PLY + PLY_BANKS -1
    584  5a7b		       b0 28		      bcs	.retBeta
    585  5a7d							;sta SET_BANK_RAM ;tmp
    586  5a7d
    587  5a7d
    588  5a7d		       20 7a f0 	      jsr	ThinkBar	;@0
    589  5a80
    590  5a80		       a5 ab		      lda	__beta
      0  5a82					      sta@PLY	beta
      1  5a82		       8d d4 fb 	      sta	[RAM]+beta
    592  5a85		       a5 ac		      lda	__beta+1
      0  5a87					      sta@PLY	beta+1
      1  5a87		       8d d5 fb 	      sta	[RAM]+beta+1
    594  5a8a
    595  5a8a		       a5 a9		      lda	__alpha
      0  5a8c					      sta@PLY	alpha
      1  5a8c		       8d d2 fb 	      sta	[RAM]+alpha
    597  5a8f		       a5 aa		      lda	__alpha+1
      0  5a91					      sta@PLY	alpha+1
      1  5a91		       8d d3 fb 	      sta	[RAM]+alpha+1
    599  5a94
    600  5a94
    601  5a94							;    int stand_pat = Evaluate();
    602  5a94							;    if( stand_pat >= beta )
    603  5a94							;	  return beta;
    604  5a94
    605  5a94		       38		      sec
    606  5a95		       a5 8f		      lda	Evaluation
      0  5a97					      sbc@PLY	beta
      1  5a97		       ed d4 f9 	      sbc	beta
    608  5a9a		       a5 90		      lda	Evaluation+1
      0  5a9c					      sbc@PLY	beta+1
      1  5a9c		       ed d5 f9 	      sbc	beta+1
    610  5a9f		       50 02		      bvc	.spat0
    611  5aa1		       49 80		      eor	#$80
    612  5aa3		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    613  5aa5
    614  5aa5		       ad d4 f9    .retBeta   lda	beta
    615  5aa8		       85 ad		      sta	__negaMax
    616  5aaa		       ad d5 f9 	      lda	beta+1
    617  5aad		       85 ae		      sta	__negaMax+1
    618  5aaf
    619  5aaf		       60	   .abort     rts
    620  5ab0
    621  5ab0				   .norb
    622  5ab0
    623  5ab0
    624  5ab0							;    if( alpha < stand_pat )
    625  5ab0							;	  alpha = stand_pat;
    626  5ab0
    627  5ab0		       38		      sec
    628  5ab1		       ad d2 f9 	      lda	alpha
    629  5ab4		       e5 8f		      sbc	Evaluation
    630  5ab6		       ad d3 f9 	      lda	alpha+1
    631  5ab9		       e5 90		      sbc	Evaluation+1
    632  5abb		       50 02		      bvc	.spat1
    633  5abd		       49 80		      eor	#$80
    634  5abf		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    635  5ac1
    636  5ac1							; alpha < stand_pat
    637  5ac1
    638  5ac1		       a5 8f		      lda	Evaluation
      0  5ac3					      sta@PLY	alpha
      1  5ac3		       8d d2 fb 	      sta	[RAM]+alpha
    640  5ac6		       a5 90		      lda	Evaluation+1
      0  5ac8					      sta@PLY	alpha+1
      1  5ac8		       8d d3 fb 	      sta	[RAM]+alpha+1
    642  5acb
    643  5acb				   .alpha
    644  5acb		       20 88 f1 	      jsr	GenerateAllMoves
    645  5ace		       a5 a1		      lda	flagCheck
    646  5ad0		       d0 dd		      bne	.abort	; pure abort
    647  5ad2
      0  5ad2					      ldx@PLY	moveIndex
      1  5ad2		       ae cf f9 	      ldx	moveIndex
    649  5ad5		       30 76		      bmi	.exit
    650  5ad7
      0  5ad7				   .forChild  stx@PLY	movePtr
      1  5ad7		       8e d0 fb 	      stx	[RAM]+movePtr
    652  5ada
    653  5ada							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    654  5ada
    655  5ada		       20 87 f4 	      jsr	MakeMove	;@this
    656  5add
    657  5add		       38		      sec
    658  5ade		       a9 00		      lda	#0
      0  5ae0					      sbc@PLY	beta
      1  5ae0		       ed d4 f9 	      sbc	beta
    660  5ae3		       85 a9		      sta	__alpha
    661  5ae5		       a9 00		      lda	#0
      0  5ae7					      sbc@PLY	beta+1
      1  5ae7		       ed d5 f9 	      sbc	beta+1
    663  5aea		       85 aa		      sta	__alpha+1
    664  5aec
    665  5aec		       38		      sec
    666  5aed		       a9 00		      lda	#0
      0  5aef					      sbc@PLY	alpha
      1  5aef		       ed d2 f9 	      sbc	alpha
    668  5af2		       85 ab		      sta	__beta
    669  5af4		       a9 00		      lda	#0
      0  5af6					      sbc@PLY	alpha+1
      1  5af6		       ed d3 f9 	      sbc	alpha+1
    671  5af9		       85 ac		      sta	__beta+1
    672  5afb
    673  5afb		       e6 94		      inc	currentPly
    674  5afd		       a5 94		      lda	currentPly
    675  5aff		       85 3e		      sta	SET_BANK_RAM	; self-switch
    676  5b01
    677  5b01		       20 77 f6 	      jsr	quiesce	;@this
    678  5b04
    679  5b04		       c6 94		      dec	currentPly
    680  5b06
    681  5b06		       20 87 f2 	      jsr	unmakeMove	;@0
    682  5b09
    683  5b09		       a5 a1		      lda	flagCheck	; don't consider moves which leave us in check
    684  5b0b		       d0 4b		      bne	.inCheck
    685  5b0d
    686  5b0d		       38		      sec
    687  5b0e							;lda #0			 ; already 0
    688  5b0e		       e5 ad		      sbc	__negaMax
    689  5b10		       85 ad		      sta	__negaMax
    690  5b12		       a9 00		      lda	#0
    691  5b14		       e5 ae		      sbc	__negaMax+1
    692  5b16		       85 ae		      sta	__negaMax+1	; -negaMax(...)
    693  5b18
    694  5b18
    695  5b18
    696  5b18							;	  if( score >= beta )
    697  5b18							;	      return beta;
    698  5b18
    699  5b18
    700  5b18		       38		      sec
    701  5b19		       a5 ad		      lda	__negaMax
      0  5b1b					      sbc@PLY	beta
      1  5b1b		       ed d4 f9 	      sbc	beta
    703  5b1e		       a5 ae		      lda	__negaMax+1
      0  5b20					      sbc@PLY	beta+1
      1  5b20		       ed d5 f9 	      sbc	beta+1
    705  5b23		       50 02		      bvc	.lab0
    706  5b25		       49 80		      eor	#$80
    707  5b27		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    708  5b29		       4c a5 f6 	      jmp	.retBeta
    709  5b2c				   .nrb2
    710  5b2c
    711  5b2c							;	  if( score > alpha )
    712  5b2c							;	     alpha = score;
    713  5b2c							;    }
    714  5b2c
    715  5b2c		       38		      sec
      0  5b2d					      lda@PLY	alpha
      1  5b2d		       ad d2 f9 	      lda	alpha
    717  5b30		       e5 ad		      sbc	__negaMax
      0  5b32					      lda@PLY	alpha+1
      1  5b32		       ad d3 f9 	      lda	alpha+1
    719  5b35		       e5 ae		      sbc	__negaMax+1
    720  5b37		       50 02		      bvc	.lab2
    721  5b39		       49 80		      eor	#$80
    722  5b3b		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    723  5b3d
    724  5b3d							; score > alpha
    725  5b3d
    726  5b3d		       a5 ad		      lda	__negaMax
      0  5b3f					      sta@PLY	alpha
      1  5b3f		       8d d2 fb 	      sta	[RAM]+alpha
    728  5b42		       a5 ae		      lda	__negaMax+1
      0  5b44					      sta@PLY	alpha+1
      1  5b44		       8d d3 fb 	      sta	[RAM]+alpha+1
    730  5b47
      0  5b47				   .nextMove  ldx@PLY	movePtr
      1  5b47		       ae d0 f9 	      ldx	movePtr
    732  5b4a		       ca		      dex
    733  5b4b		       10 8a		      bpl	.forChild
    734  5b4d
    735  5b4d							;    return alpha;
    736  5b4d
    737  5b4d				   .exit
      0  5b4d					      lda@PLY	alpha
      1  5b4d		       ad d2 f9 	      lda	alpha
    739  5b50		       85 ad		      sta	__negaMax
      0  5b52					      lda@PLY	alpha+1
      1  5b52		       ad d3 f9 	      lda	alpha+1
    741  5b55		       85 ae		      sta	__negaMax+1
    742  5b57		       60		      rts
    743  5b58
    744  5b58		       a9 00	   .inCheck   lda	#0
    745  5b5a		       85 a1		      sta	flagCheck
    746  5b5c		       f0 e9		      beq	.nextMove
    747  5b5e
    748  5b5e
    749  5b5e							;---------------------------------------------------------------------------------------------------
    750  5b5e
      0  5b5e					      CHECK_BANK_SIZE	"NEGAMAX"
      1  5b5e		       03 5e	   .TEMP      =	* - _BANK_START
 NEGAMAX (1K) SIZE =  $35e , FREE= $a2
      2  5b5e					      ECHO	"NEGAMAX", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5b5e				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5b5e				  -	      ECHO	"BANK OVERFLOW @ ", "NEGAMAX", " size=", * - ORIGIN
      5  5b5e				  -	      ERR
      6  5b5e					      ENDIF
    752  5b5e
    753  5b5e							;---------------------------------------------------------------------------------------------------
    754  5b5e							; EOF
------- FILE ./chess.asm
    639  5b5e
------- FILE PIECE_MACROS.asm LEVEL 2 PASS 4
      0  5b5e					      include	"PIECE_MACROS.asm"
      1  5b5e							; Copyright (C)2020 Andrew Davie
      2  5b5e							; Common macros for piece move handlers
      3  5b5e
      4  5b5e							;---------------------------------------------------------------------------------------------------
      5  5b5e							; Looks at a square offset {1} to see if piece can move to it
      6  5b5e							; Adds the square to the movelist if it can
      7  5b5e							; Keeps moving in the same direction until it's blocked/off=board
      8  5b5e
      9  5b5e					      MAC	move_towards
     10  5b5e					      SUBROUTINE
     11  5b5e
     12  5b5e							; = 76 for single square (empty/take)
     13  5b5e
     14  5b5e					      lda	#0
     15  5b5e					      sta	capture
     16  5b5e
     17  5b5e					      ldx	currentSquare	; 3
     18  5b5e					      bne	.project	; 3   unconditional
     19  5b5e
     20  5b5e				   .empty     jsr	AddMove	; 57
     21  5b5e				   .project   ldy	ValidSquare+{1},x	; 4
     22  5b5e					      bmi	.invalid	; 2/3 off board!
     23  5b5e					      lda	Board,y	; 4   piece @ destination
     24  5b5e					      beq	.empty	; 2/3
     25  5b5e					      sta	capture
     26  5b5e					      eor	currentPiece	; 3
     27  5b5e					      bpl	.invalid	; 2/3 same colour
     28  5b5e					      jsr	AddMove	; 57  and exit
     29  5b5e
     30  5b5e				   .invalid
     31  5b5e					      ENDM
     32  5b5e
     33  5b5e
     34  5b5e							;---------------------------------------------------------------------------------------------------
     35  5b5e
     36  5b5e					      MAC	move_to
     37  5b5e					      SUBROUTINE
     38  5b5e					      ldy	ValidSquare+{1},x
     39  5b5e					      bmi	.invalid	; off board!
     40  5b5e					      lda	Board,y	; piece @ destination
     41  5b5e					      sta	capture
     42  5b5e					      beq	.squareEmpty
     43  5b5e					      eor	currentPiece
     44  5b5e					      bpl	.invalid	; same colour
     45  5b5e				   .squareEmpty jsr	AddMove
     46  5b5e				   .invalid
     47  5b5e					      ENDM
     48  5b5e
     49  5b5e
     50  5b5e							;---------------------------------------------------------------------------------------------------
     51  5b5e
     52  5b5e					      MAC	move_to_x
     53  5b5e					      ldx	currentSquare
     54  5b5e					      MOVE_TO	{1}
     55  5b5e					      ENDM
     56  5b5e
     57  5b5e
     58  5b5e							;---------------------------------------------------------------------------------------------------
     59  5b5e							; EOF
------- FILE ./chess.asm
    641  5b5e
------- FILE PIECE_HANDLER@1#1.asm LEVEL 2 PASS 4
      0  5b5e					      include	"PIECE_HANDLER@1#1.asm"
      0  5b5e					      SLOT	1
      1  5b5e				  -	      IF	(1 < 0) || (1 > 3)
      2  5b5e				  -	      ECHO	"Illegal bank address/segment location", 1
      3  5b5e				  -	      ERR
      4  5b5e					      ENDIF
      5  5b5e				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  5b5e				   _BANK_SLOT SET	1 * 64
      0  5b5e					      NEWBANK	PIECE_HANDLER_1
      1  5e68 ????				      SEG	PIECE_HANDLER_1
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   PIECE_HANDLER_1_START SET	*
      6  5c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5c00				   PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  5c00
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  5c00					      include	"PIECE_PAWN.asm"
      1  5c00							; Copyright (C)2020 Andrew Davie
      2  5c00							; Pawn move handlers
      3  5c00
      4  5c00							;---------------------------------------------------------------------------------------------------
      5  5c00							; WHITE PAWN
      6  5c00							;---------------------------------------------------------------------------------------------------
      7  5c00
      8  5c00		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  5c00		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  5c00
     11  5c00							;---------------------------------------------------------------------------------------------------
     12  5c00
     13  5c00					      MAC	en_passant
     14  5c00					      SUBROUTINE
     15  5c00							; {1} = _LEFT or _RIGHT
     16  5c00
     17  5c00					      ldx	currentSquare
     18  5c00					      ldy	ValidSquare+{1},x
     19  5c00					      cpy	enPassantPawn
     20  5c00					      bne	.invalid
     21  5c00					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  5c00					      lda	Board,y
     23  5c00					      bne	.invalid
     24  5c00					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  5c00				   .invalid
     26  5c00					      ENDM
     27  5c00
     28  5c00							;---------------------------------------------------------------------------------------------------
     29  5c00
     30  5c00					      MAC	promote_pawn
     31  5c00							;SUBROUTINE
     32  5c00
     33  5c00							;{1} = BLACK or WHITE
     34  5c00
     35  5c00
     36  5c00					      sty	__temp
     37  5c00					      lda	#{1}|QUEEN
     38  5c00					      sta	currentPiece
     39  5c00					      jsr	AddMove
     40  5c00
     41  5c00					      lda	#{1}|ROOK
     42  5c00					      sta	currentPiece
     43  5c00					      ldy	__temp
     44  5c00					      jsr	AddMove
     45  5c00
     46  5c00					      lda	#{1}|BISHOP
     47  5c00					      sta	currentPiece
     48  5c00					      ldy	__temp
     49  5c00					      jsr	AddMove
     50  5c00
     51  5c00					      lda	#{1}|KNIGHT
     52  5c00					      sta	currentPiece
     53  5c00					      ldy	__temp
     54  5c00					      jsr	AddMove
     55  5c00
     56  5c00					      IF	{1} = WHITE
     57  5c00					      lda	#WHITE|WP
     58  5c00					      ENDIF
     59  5c00					      IF	{1} = BLACK
     60  5c00					      lda	#BLACK|BP
     61  5c00					      ENDIF
     62  5c00					      sta	currentPiece
     63  5c00					      ENDM
     64  5c00
     65  5c00							;---------------------------------------------------------------------------------------------------
     66  5c00
     67  5c00					      MAC	move_or_promote_pawn
     68  5c00							;SUBROUTINE
     69  5c00							; {1} = BLACK or WHITE
     70  5c00
     71  5c00					      IF	{1} = WHITE
     72  5c00					      cpy	#90	; last rank?
     73  5c00					      bcc	.standard
     74  5c00					      jsr	PromoteWhitePawn
     75  5c00					      jmp	.pMoved
     76  5c00					      ENDIF
     77  5c00
     78  5c00					      IF	{1} = BLACK
     79  5c00					      cpy	#30	; last rank?
     80  5c00					      bcs	.standard
     81  5c00					      jsr	PromoteBlackPawn
     82  5c00					      jmp	.pMoved
     83  5c00					      ENDIF
     84  5c00
     85  5c00				   .standard  jsr	AddMove	; add +1UP move
     86  5c00				   .pMoved
     87  5c00
     88  5c00					      ENDM
     89  5c00
     90  5c00							;---------------------------------------------------------------------------------------------------
     91  5c00
     92  5c00					      MAC	take
     93  5c00							;SUBROUTINE
     94  5c00							; {1} = capture square offset
     95  5c00
     96  5c00					      ldx	currentSquare
     97  5c00					      ldy	ValidSquare+{1},x
     98  5c00					      bmi	.invalid2
     99  5c00					      lda	Board,y
    100  5c00					      beq	.invalid2	; square empty
    101  5c00					      sta	capture
    102  5c00					      eor	currentPiece
    103  5c00					      bpl	.invalid	; same colour
    104  5c00
    105  5c00					      MOVE_OR_PROMOTE_PAWN	{2}
    106  5c00
    107  5c00					      jmp	.invalid2
    108  5c00				   .invalid   inc	protecting
    109  5c00				   .invalid2
    110  5c00					      ENDM
    111  5c00
    112  5c00							;---------------------------------------------------------------------------------------------------
    113  5c00
      0  5c00					      DEF	PromoteWhitePawn
      1  5c00				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  5c00				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  5c00				   PromoteWhitePawn
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	PromoteWhitePawn
    115  5c00					      SUBROUTINE
    116  5c00
      0  5c00					      REFER	Handle_WHITE_PAWN
      1  5c00					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  5c00				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  5c00					      ENDIF
      0  5c00					      VAR	__temp, 1
      1  5c00		       00 b7	   __temp     =	TEMPORARY_VAR
      2  5c00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5c00
      4  5c00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c00					      ENDIF
      8  5c00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c00				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  5c00				  -	      ERR
     11  5c00					      ENDIF
     12  5c00					      LIST	ON
      0  5c00					      VEND	PromoteWhitePawn
      1  5c00				  -	      IFNCONST	PromoteWhitePawn
      2  5c00				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  5c00				  -	      ERR
      4  5c00					      ENDIF
      5  5c00		       00 b8	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  5c00
      0  5c00					      PROMOTE_PAWN	WHITE
      1  5c00
      2  5c00
      3  5c00
      4  5c00
      5  5c00
      6  5c00		       84 b7		      sty	__temp
      7  5c02		       a9 06		      lda	#WHITE|QUEEN
      8  5c04		       85 91		      sta	currentPiece
      9  5c06		       20 5f f2 	      jsr	AddMove
     10  5c09
     11  5c09		       a9 05		      lda	#WHITE|ROOK
     12  5c0b		       85 91		      sta	currentPiece
     13  5c0d		       a4 b7		      ldy	__temp
     14  5c0f		       20 5f f2 	      jsr	AddMove
     15  5c12
     16  5c12		       a9 04		      lda	#WHITE|BISHOP
     17  5c14		       85 91		      sta	currentPiece
     18  5c16		       a4 b7		      ldy	__temp
     19  5c18		       20 5f f2 	      jsr	AddMove
     20  5c1b
     21  5c1b		       a9 03		      lda	#WHITE|KNIGHT
     22  5c1d		       85 91		      sta	currentPiece
     23  5c1f		       a4 b7		      ldy	__temp
     24  5c21		       20 5f f2 	      jsr	AddMove
     25  5c24
     26  5c24					      IF	WHITE = WHITE
     27  5c24		       a9 01		      lda	#WHITE|WP
     28  5c26					      ENDIF
     29  5c26				  -	      IF	WHITE = BLACK
     30  5c26				  -	      lda	#BLACK|BP
     31  5c26					      ENDIF
     32  5c26		       85 91		      sta	currentPiece
    122  5c28		       60		      rts
    123  5c29
    124  5c29							;---------------------------------------------------------------------------------------------------
    125  5c29
      0  5c29					      DEF	Handle_WHITE_PAWN
      1  5c29				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  5c29				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  5c29				   Handle_WHITE_PAWN
      4  5c29				   TEMPORARY_VAR SET	Overlay
      5  5c29				   TEMPORARY_OFFSET SET	0
      6  5c29				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  5c29				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  5c29					      SUBROUTINE
    128  5c29
      0  5c29					      REFER	GenerateAllMoves
      1  5c29					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5c29				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5c29					      ENDIF
      0  5c29					      VEND	Handle_WHITE_PAWN
      1  5c29				  -	      IFNCONST	Handle_WHITE_PAWN
      2  5c29				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  5c29				  -	      ERR
      4  5c29					      ENDIF
      5  5c29		       00 b7	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  5c29
    132  5c29		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  5c2c		       b9 79 fc 	      lda	Board,y
    134  5c2f		       d0 26		      bne	.pMoved	; occupied
    135  5c31		       85 9d		      sta	capture
    136  5c33
    137  5c33							; we may need to promote the pawn
    138  5c33							; All possibilites (Q/R/B/N) are added as individual moves
    139  5c33
      0  5c33					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  5c33
      2  5c33
      3  5c33
      4  5c33					      IF	WHITE = WHITE
      5  5c33		       c0 5a		      cpy	#90
      6  5c35		       90 06		      bcc	.standard
      7  5c37		       20 00 f4 	      jsr	PromoteWhitePawn
      8  5c3a		       4c 40 f4 	      jmp	.pMoved
      9  5c3d					      ENDIF
     10  5c3d
     11  5c3d				  -	      IF	WHITE = BLACK
     12  5c3d				  -	      cpy	#30
     13  5c3d				  -	      bcs	.standard
     14  5c3d				  -	      jsr	PromoteBlackPawn
     15  5c3d				  -	      jmp	.pMoved
     16  5c3d					      ENDIF
     17  5c3d
     18  5c3d		       20 5f f2    .standard  jsr	AddMove
     19  5c40				   .pMoved
     20  5c40
    141  5c40
    142  5c40							; the +2 move off the home rank...
    143  5c40
    144  5c40		       a6 92		      ldx	currentSquare
    145  5c42		       e0 28		      cpx	#WHITE_HOME_ROW
    146  5c44		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  5c46		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  5c49		       b9 79 fc 	      lda	Board,y
    149  5c4c		       d0 09		      bne	.pMoved	; destination square occupied
    150  5c4e
    151  5c4e		       a5 91		      lda	currentPiece
    152  5c50		       09 20		      ora	#FLAG_ENPASSANT
    153  5c52		       85 91		      sta	currentPiece	; GENERATE en-passant opportunity
    154  5c54
    155  5c54		       20 5f f2 	      jsr	AddMove	; add the +2UP move off home row
    156  5c57
    157  5c57				   .pMoved
    158  5c57
    159  5c57							; regular captures...
    160  5c57
      0  5c57					      TAKE	_UP+_LEFT, WHITE
      1  5c57
      2  5c57
      3  5c57
      4  5c57		       a6 92		      ldx	currentSquare
      5  5c59		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  5c5c		       30 1d		      bmi	.invalid2
      7  5c5e		       b9 79 fc 	      lda	Board,y
      8  5c61		       f0 18		      beq	.invalid2
      9  5c63		       85 9d		      sta	capture
     10  5c65		       45 91		      eor	currentPiece
     11  5c67		       10 10		      bpl	.invalid
     12  5c69
      0  5c69					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  5c69
      2  5c69
      3  5c69
      4  5c69					      IF	WHITE = WHITE
      5  5c69		       c0 5a		      cpy	#90
      6  5c6b		       90 06		      bcc	.standard
      7  5c6d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  5c70		       4c 76 f4 	      jmp	.pMoved
      9  5c73					      ENDIF
     10  5c73
     11  5c73				  -	      IF	WHITE = BLACK
     12  5c73				  -	      cpy	#30
     13  5c73				  -	      bcs	.standard
     14  5c73				  -	      jsr	PromoteBlackPawn
     15  5c73				  -	      jmp	.pMoved
     16  5c73					      ENDIF
     17  5c73
     18  5c73		       20 5f f2    .standard  jsr	AddMove
     19  5c76				   .pMoved
     20  5c76
     14  5c76
     15  5c76		       4c 7b f4 	      jmp	.invalid2
     16  5c79		       e6 a2	   .invalid   inc	protecting
     17  5c7b				   .invalid2
      0  5c7b					      TAKE	_UP+_RIGHT, WHITE
      1  5c7b
      2  5c7b
      3  5c7b
      4  5c7b		       a6 92		      ldx	currentSquare
      5  5c7d		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  5c80		       30 1d		      bmi	.invalid2
      7  5c82		       b9 79 fc 	      lda	Board,y
      8  5c85		       f0 18		      beq	.invalid2
      9  5c87		       85 9d		      sta	capture
     10  5c89		       45 91		      eor	currentPiece
     11  5c8b		       10 10		      bpl	.invalid
     12  5c8d
      0  5c8d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  5c8d
      2  5c8d
      3  5c8d
      4  5c8d					      IF	WHITE = WHITE
      5  5c8d		       c0 5a		      cpy	#90
      6  5c8f		       90 06		      bcc	.standard
      7  5c91		       20 00 f4 	      jsr	PromoteWhitePawn
      8  5c94		       4c 9a f4 	      jmp	.pMoved
      9  5c97					      ENDIF
     10  5c97
     11  5c97				  -	      IF	WHITE = BLACK
     12  5c97				  -	      cpy	#30
     13  5c97				  -	      bcs	.standard
     14  5c97				  -	      jsr	PromoteBlackPawn
     15  5c97				  -	      jmp	.pMoved
     16  5c97					      ENDIF
     17  5c97
     18  5c97		       20 5f f2    .standard  jsr	AddMove
     19  5c9a				   .pMoved
     20  5c9a
     14  5c9a
     15  5c9a		       4c 9f f4 	      jmp	.invalid2
     16  5c9d		       e6 a2	   .invalid   inc	protecting
     17  5c9f				   .invalid2
    163  5c9f
    164  5c9f
    165  5c9f				  -	      IF	ENPASSANT_ENABLED
    166  5c9f				  -			; en-passant captures...
    167  5c9f				  -
    168  5c9f				  -	      lda	enPassantPawn
    169  5c9f				  -	      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  5c9f				  -
    171  5c9f				  -	      lda	currentPiece
    172  5c9f				  -	      ora	#FLAG_ENPASSANT
    173  5c9f				  -	      sta	currentPiece	; CONSUME en-passant opportunity
    174  5c9f				  -
    175  5c9f				  -	      EN_PASSANT	_LEFT, _UP
    176  5c9f				  -	      EN_PASSANT	_RIGHT, _UP
    177  5c9f				  -
    178  5c9f				  -.noEnPassant
    179  5c9f					      ENDIF
    180  5c9f
    181  5c9f		       4c c0 f1 	      jmp	MoveReturn
    182  5ca2
    183  5ca2
    184  5ca2							;---------------------------------------------------------------------------------------------------
    185  5ca2							; BLACK PAWN
    186  5ca2							;---------------------------------------------------------------------------------------------------
    187  5ca2
      0  5ca2					      DEF	PromoteBlackPawn
      1  5ca2				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  5ca2				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  5ca2				   PromoteBlackPawn
      4  5ca2				   TEMPORARY_VAR SET	Overlay
      5  5ca2				   TEMPORARY_OFFSET SET	0
      6  5ca2				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  5ca2				   FUNCTION_NAME SET	PromoteBlackPawn
    189  5ca2					      SUBROUTINE
    190  5ca2
      0  5ca2					      REFER	Handle_BLACK_PAWN
      1  5ca2					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  5ca2				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  5ca2					      ENDIF
      0  5ca2					      VAR	__temp, 1
      1  5ca2		       00 b7	   __temp     =	TEMPORARY_VAR
      2  5ca2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5ca2
      4  5ca2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5ca2				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5ca2				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5ca2					      ENDIF
      8  5ca2				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5ca2				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  5ca2				  -	      ERR
     11  5ca2					      ENDIF
     12  5ca2					      LIST	ON
      0  5ca2					      VEND	PromoteBlackPawn
      1  5ca2				  -	      IFNCONST	PromoteBlackPawn
      2  5ca2				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  5ca2				  -	      ERR
      4  5ca2					      ENDIF
      5  5ca2		       00 b8	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  5ca2
      0  5ca2					      PROMOTE_PAWN	BLACK
      1  5ca2
      2  5ca2
      3  5ca2
      4  5ca2
      5  5ca2
      6  5ca2		       84 b7		      sty	__temp
      7  5ca4		       a9 86		      lda	#BLACK|QUEEN
      8  5ca6		       85 91		      sta	currentPiece
      9  5ca8		       20 5f f2 	      jsr	AddMove
     10  5cab
     11  5cab		       a9 85		      lda	#BLACK|ROOK
     12  5cad		       85 91		      sta	currentPiece
     13  5caf		       a4 b7		      ldy	__temp
     14  5cb1		       20 5f f2 	      jsr	AddMove
     15  5cb4
     16  5cb4		       a9 84		      lda	#BLACK|BISHOP
     17  5cb6		       85 91		      sta	currentPiece
     18  5cb8		       a4 b7		      ldy	__temp
     19  5cba		       20 5f f2 	      jsr	AddMove
     20  5cbd
     21  5cbd		       a9 83		      lda	#BLACK|KNIGHT
     22  5cbf		       85 91		      sta	currentPiece
     23  5cc1		       a4 b7		      ldy	__temp
     24  5cc3		       20 5f f2 	      jsr	AddMove
     25  5cc6
     26  5cc6				  -	      IF	BLACK = WHITE
     27  5cc6				  -	      lda	#WHITE|WP
     28  5cc6					      ENDIF
     29  5cc6					      IF	BLACK = BLACK
     30  5cc6		       a9 82		      lda	#BLACK|BP
     31  5cc8					      ENDIF
     32  5cc8		       85 91		      sta	currentPiece
    196  5cca		       60		      rts
    197  5ccb
      0  5ccb					      DEF	Handle_BLACK_PAWN
      1  5ccb				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  5ccb				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  5ccb				   Handle_BLACK_PAWN
      4  5ccb				   TEMPORARY_VAR SET	Overlay
      5  5ccb				   TEMPORARY_OFFSET SET	0
      6  5ccb				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  5ccb				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  5ccb					      SUBROUTINE
    200  5ccb
      0  5ccb					      REFER	GenerateAllMoves
      1  5ccb					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5ccb				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5ccb					      ENDIF
      0  5ccb					      VEND	Handle_BLACK_PAWN
      1  5ccb				  -	      IFNCONST	Handle_BLACK_PAWN
      2  5ccb				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  5ccb				  -	      ERR
      4  5ccb					      ENDIF
      5  5ccb		       00 b7	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  5ccb
    204  5ccb		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  5cce		       b9 79 fc 	      lda	Board,y
    206  5cd1		       d0 26		      bne	.pMoved	; occupied
    207  5cd3		       85 9d		      sta	capture
    208  5cd5
    209  5cd5							; we may need to promote the pawn
    210  5cd5							; All possibilites (Q/R/B/N) are added as individual moves
    211  5cd5
      0  5cd5					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  5cd5
      2  5cd5
      3  5cd5
      4  5cd5				  -	      IF	BLACK = WHITE
      5  5cd5				  -	      cpy	#90
      6  5cd5				  -	      bcc	.standard
      7  5cd5				  -	      jsr	PromoteWhitePawn
      8  5cd5				  -	      jmp	.pMoved
      9  5cd5					      ENDIF
     10  5cd5
     11  5cd5					      IF	BLACK = BLACK
     12  5cd5		       c0 1e		      cpy	#30
     13  5cd7		       b0 06		      bcs	.standard
     14  5cd9		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  5cdc		       4c e2 f4 	      jmp	.pMoved
     16  5cdf					      ENDIF
     17  5cdf
     18  5cdf		       20 5f f2    .standard  jsr	AddMove
     19  5ce2				   .pMoved
     20  5ce2
    213  5ce2
    214  5ce2							; the +2 move off the home rank...
    215  5ce2
    216  5ce2		       a6 92		      ldx	currentSquare
    217  5ce4		       e0 52		      cpx	#BLACK_HOME_ROW
    218  5ce6		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  5ce8
    220  5ce8
    221  5ce8		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  5ceb		       b9 79 fc 	      lda	Board,y
    223  5cee		       d0 09		      bne	.pMoved	; destination square occupied
    224  5cf0
    225  5cf0		       a5 91		      lda	currentPiece
    226  5cf2		       09 20		      ora	#FLAG_ENPASSANT
    227  5cf4		       85 91		      sta	currentPiece	; CAN en-passant
    228  5cf6
    229  5cf6		       20 5f f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  5cf9
    231  5cf9				   .pMoved
    232  5cf9
    233  5cf9							; regular captures... (with promotion)
    234  5cf9
      0  5cf9					      TAKE	_DOWN+_LEFT, BLACK
      1  5cf9
      2  5cf9
      3  5cf9
      4  5cf9		       a6 92		      ldx	currentSquare
      5  5cfb		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  5cfe		       30 1d		      bmi	.invalid2
      7  5d00		       b9 79 fc 	      lda	Board,y
      8  5d03		       f0 18		      beq	.invalid2
      9  5d05		       85 9d		      sta	capture
     10  5d07		       45 91		      eor	currentPiece
     11  5d09		       10 10		      bpl	.invalid
     12  5d0b
      0  5d0b					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  5d0b
      2  5d0b
      3  5d0b
      4  5d0b				  -	      IF	BLACK = WHITE
      5  5d0b				  -	      cpy	#90
      6  5d0b				  -	      bcc	.standard
      7  5d0b				  -	      jsr	PromoteWhitePawn
      8  5d0b				  -	      jmp	.pMoved
      9  5d0b					      ENDIF
     10  5d0b
     11  5d0b					      IF	BLACK = BLACK
     12  5d0b		       c0 1e		      cpy	#30
     13  5d0d		       b0 06		      bcs	.standard
     14  5d0f		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  5d12		       4c 18 f5 	      jmp	.pMoved
     16  5d15					      ENDIF
     17  5d15
     18  5d15		       20 5f f2    .standard  jsr	AddMove
     19  5d18				   .pMoved
     20  5d18
     14  5d18
     15  5d18		       4c 1d f5 	      jmp	.invalid2
     16  5d1b		       e6 a2	   .invalid   inc	protecting
     17  5d1d				   .invalid2
      0  5d1d					      TAKE	_DOWN+_RIGHT, BLACK
      1  5d1d
      2  5d1d
      3  5d1d
      4  5d1d		       a6 92		      ldx	currentSquare
      5  5d1f		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  5d22		       30 1d		      bmi	.invalid2
      7  5d24		       b9 79 fc 	      lda	Board,y
      8  5d27		       f0 18		      beq	.invalid2
      9  5d29		       85 9d		      sta	capture
     10  5d2b		       45 91		      eor	currentPiece
     11  5d2d		       10 10		      bpl	.invalid
     12  5d2f
      0  5d2f					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  5d2f
      2  5d2f
      3  5d2f
      4  5d2f				  -	      IF	BLACK = WHITE
      5  5d2f				  -	      cpy	#90
      6  5d2f				  -	      bcc	.standard
      7  5d2f				  -	      jsr	PromoteWhitePawn
      8  5d2f				  -	      jmp	.pMoved
      9  5d2f					      ENDIF
     10  5d2f
     11  5d2f					      IF	BLACK = BLACK
     12  5d2f		       c0 1e		      cpy	#30
     13  5d31		       b0 06		      bcs	.standard
     14  5d33		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  5d36		       4c 3c f5 	      jmp	.pMoved
     16  5d39					      ENDIF
     17  5d39
     18  5d39		       20 5f f2    .standard  jsr	AddMove
     19  5d3c				   .pMoved
     20  5d3c
     14  5d3c
     15  5d3c		       4c 41 f5 	      jmp	.invalid2
     16  5d3f		       e6 a2	   .invalid   inc	protecting
     17  5d41				   .invalid2
    237  5d41
    238  5d41
    239  5d41				  -	      IF	ENPASSANT_ENABLED
    240  5d41				  -			; en-passant captures...
    241  5d41				  -
    242  5d41				  -	      lda	enPassantPawn
    243  5d41				  -	      beq	.noEnPassant	; was last move en-passantable?
    244  5d41				  -
    245  5d41				  -	      lda	currentPiece
    246  5d41				  -	      ora	#FLAG_ENPASSANT
    247  5d41				  -	      sta	currentPiece	; any en-passant move added will have flag set
    248  5d41				  -
    249  5d41				  -	      EN_PASSANT	_LEFT, _DOWN
    250  5d41				  -	      EN_PASSANT	_RIGHT, _DOWN
    251  5d41				  -
    252  5d41				  -.noEnPassant
    253  5d41					      ENDIF
    254  5d41
    255  5d41		       4c c0 f1 	      jmp	MoveReturn
    256  5d44
    257  5d44							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  5d44					      include	"PIECE_KNIGHT.asm"
      1  5d44							; Copyright (C)2020 Andrew Davie
      2  5d44							; Knight move handler
      3  5d44
      4  5d44							;---------------------------------------------------------------------------------------------------
      5  5d44							; KNIGHT
      6  5d44							;---------------------------------------------------------------------------------------------------
      7  5d44
      0  5d44					      DEF	Handle_KNIGHT
      1  5d44				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  5d44				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  5d44				   Handle_KNIGHT
      4  5d44				   TEMPORARY_VAR SET	Overlay
      5  5d44				   TEMPORARY_OFFSET SET	0
      6  5d44				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  5d44				   FUNCTION_NAME SET	Handle_KNIGHT
      9  5d44					      SUBROUTINE
     10  5d44
      0  5d44					      REFER	GenerateAllMoves	;✅
      1  5d44					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5d44				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5d44					      ENDIF
      0  5d44					      VEND	Handle_KNIGHT
      1  5d44				  -	      IFNCONST	Handle_KNIGHT
      2  5d44				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  5d44				  -	      ERR
      4  5d44					      ENDIF
      5  5d44		       00 b7	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  5d44
     14  5d44							; x = currentSquare (square the piece is on)
     15  5d44							; currentPiece (with flags/colour attached)
     16  5d44
      0  5d44					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  5d44					      SUBROUTINE
      2  5d44		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  5d47		       30 0e		      bmi	.invalid
      4  5d49		       b9 79 fc 	      lda	Board,y
      5  5d4c		       85 9d		      sta	capture
      6  5d4e		       f0 04		      beq	.squareEmpty
      7  5d50		       45 91		      eor	currentPiece
      8  5d52		       10 03		      bpl	.invalid
      9  5d54		       20 5f f2    .squareEmpty jsr	AddMove
     10  5d57				   .invalid
      0  5d57					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  5d57		       a6 92		      ldx	currentSquare
      0  5d59					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  5d59					      SUBROUTINE
      2  5d59		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  5d5c		       30 0e		      bmi	.invalid
      4  5d5e		       b9 79 fc 	      lda	Board,y
      5  5d61		       85 9d		      sta	capture
      6  5d63		       f0 04		      beq	.squareEmpty
      7  5d65		       45 91		      eor	currentPiece
      8  5d67		       10 03		      bpl	.invalid
      9  5d69		       20 5f f2    .squareEmpty jsr	AddMove
     10  5d6c				   .invalid
      0  5d6c					      MOVE_TO_X	_UP+_UP+_LEFT
      1  5d6c		       a6 92		      ldx	currentSquare
      0  5d6e					      MOVE_TO	_UP+_UP+_LEFT
      1  5d6e					      SUBROUTINE
      2  5d6e		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  5d71		       30 0e		      bmi	.invalid
      4  5d73		       b9 79 fc 	      lda	Board,y
      5  5d76		       85 9d		      sta	capture
      6  5d78		       f0 04		      beq	.squareEmpty
      7  5d7a		       45 91		      eor	currentPiece
      8  5d7c		       10 03		      bpl	.invalid
      9  5d7e		       20 5f f2    .squareEmpty jsr	AddMove
     10  5d81				   .invalid
      0  5d81					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  5d81		       a6 92		      ldx	currentSquare
      0  5d83					      MOVE_TO	_UP+_UP+_RIGHT
      1  5d83					      SUBROUTINE
      2  5d83		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  5d86		       30 0e		      bmi	.invalid
      4  5d88		       b9 79 fc 	      lda	Board,y
      5  5d8b		       85 9d		      sta	capture
      6  5d8d		       f0 04		      beq	.squareEmpty
      7  5d8f		       45 91		      eor	currentPiece
      8  5d91		       10 03		      bpl	.invalid
      9  5d93		       20 5f f2    .squareEmpty jsr	AddMove
     10  5d96				   .invalid
     21  5d96
      0  5d96					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  5d96		       a6 92		      ldx	currentSquare
      0  5d98					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  5d98					      SUBROUTINE
      2  5d98		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  5d9b		       30 0e		      bmi	.invalid
      4  5d9d		       b9 79 fc 	      lda	Board,y
      5  5da0		       85 9d		      sta	capture
      6  5da2		       f0 04		      beq	.squareEmpty
      7  5da4		       45 91		      eor	currentPiece
      8  5da6		       10 03		      bpl	.invalid
      9  5da8		       20 5f f2    .squareEmpty jsr	AddMove
     10  5dab				   .invalid
      0  5dab					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  5dab		       a6 92		      ldx	currentSquare
      0  5dad					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  5dad					      SUBROUTINE
      2  5dad		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  5db0		       30 0e		      bmi	.invalid
      4  5db2		       b9 79 fc 	      lda	Board,y
      5  5db5		       85 9d		      sta	capture
      6  5db7		       f0 04		      beq	.squareEmpty
      7  5db9		       45 91		      eor	currentPiece
      8  5dbb		       10 03		      bpl	.invalid
      9  5dbd		       20 5f f2    .squareEmpty jsr	AddMove
     10  5dc0				   .invalid
      0  5dc0					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  5dc0		       a6 92		      ldx	currentSquare
      0  5dc2					      MOVE_TO	_UP+_LEFT+_LEFT
      1  5dc2					      SUBROUTINE
      2  5dc2		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  5dc5		       30 0e		      bmi	.invalid
      4  5dc7		       b9 79 fc 	      lda	Board,y
      5  5dca		       85 9d		      sta	capture
      6  5dcc		       f0 04		      beq	.squareEmpty
      7  5dce		       45 91		      eor	currentPiece
      8  5dd0		       10 03		      bpl	.invalid
      9  5dd2		       20 5f f2    .squareEmpty jsr	AddMove
     10  5dd5				   .invalid
      0  5dd5					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  5dd5		       a6 92		      ldx	currentSquare
      0  5dd7					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  5dd7					      SUBROUTINE
      2  5dd7		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  5dda		       30 0e		      bmi	.invalid
      4  5ddc		       b9 79 fc 	      lda	Board,y
      5  5ddf		       85 9d		      sta	capture
      6  5de1		       f0 04		      beq	.squareEmpty
      7  5de3		       45 91		      eor	currentPiece
      8  5de5		       10 03		      bpl	.invalid
      9  5de7		       20 5f f2    .squareEmpty jsr	AddMove
     10  5dea				   .invalid
     26  5dea
     27  5dea		       4c c0 f1 	      jmp	MoveReturn
     28  5ded
     29  5ded							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  5ded					      include	"PIECE_BISHOP.asm"
      1  5ded							; Copyright (C)2020 Andrew Davie
      2  5ded
      3  5ded							;---------------------------------------------------------------------------------------------------
      4  5ded							; BISHOP
      5  5ded							;---------------------------------------------------------------------------------------------------
      6  5ded
      0  5ded					      DEF	Handle_BISHOP
      1  5ded				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  5ded				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  5ded				   Handle_BISHOP
      4  5ded				   TEMPORARY_VAR SET	Overlay
      5  5ded				   TEMPORARY_OFFSET SET	0
      6  5ded				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  5ded				   FUNCTION_NAME SET	Handle_BISHOP
      8  5ded					      SUBROUTINE
      9  5ded
      0  5ded					      REFER	GenerateAllMoves	;✅
      1  5ded					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5ded				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5ded					      ENDIF
      0  5ded					      VEND	Handle_BISHOP
      1  5ded				  -	      IFNCONST	Handle_BISHOP
      2  5ded				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  5ded				  -	      ERR
      4  5ded					      ENDIF
      5  5ded		       00 b7	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  5ded
     13  5ded							; x = currentSquare (square the piece is on)
     14  5ded							; currentPiece (with flags/colour attached)
     15  5ded
      0  5ded					      MOVE_TOWARDS	_DOWN+_LEFT
      1  5ded					      SUBROUTINE
      2  5ded
      3  5ded
      4  5ded
      5  5ded		       a9 00		      lda	#0
      6  5def		       85 9d		      sta	capture
      7  5df1
      8  5df1		       a6 92		      ldx	currentSquare
      9  5df3		       d0 03		      bne	.project
     10  5df5
     11  5df5		       20 5f f2    .empty     jsr	AddMove
     12  5df8		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  5dfb		       30 0e		      bmi	.invalid
     14  5dfd		       b9 79 fc 	      lda	Board,y
     15  5e00		       f0 f3		      beq	.empty
     16  5e02		       85 9d		      sta	capture
     17  5e04		       45 91		      eor	currentPiece
     18  5e06		       10 03		      bpl	.invalid
     19  5e08		       20 5f f2 	      jsr	AddMove
     20  5e0b
     21  5e0b				   .invalid
      0  5e0b					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  5e0b					      SUBROUTINE
      2  5e0b
      3  5e0b
      4  5e0b
      5  5e0b		       a9 00		      lda	#0
      6  5e0d		       85 9d		      sta	capture
      7  5e0f
      8  5e0f		       a6 92		      ldx	currentSquare
      9  5e11		       d0 03		      bne	.project
     10  5e13
     11  5e13		       20 5f f2    .empty     jsr	AddMove
     12  5e16		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  5e19		       30 0e		      bmi	.invalid
     14  5e1b		       b9 79 fc 	      lda	Board,y
     15  5e1e		       f0 f3		      beq	.empty
     16  5e20		       85 9d		      sta	capture
     17  5e22		       45 91		      eor	currentPiece
     18  5e24		       10 03		      bpl	.invalid
     19  5e26		       20 5f f2 	      jsr	AddMove
     20  5e29
     21  5e29				   .invalid
      0  5e29					      MOVE_TOWARDS	_UP+_LEFT
      1  5e29					      SUBROUTINE
      2  5e29
      3  5e29
      4  5e29
      5  5e29		       a9 00		      lda	#0
      6  5e2b		       85 9d		      sta	capture
      7  5e2d
      8  5e2d		       a6 92		      ldx	currentSquare
      9  5e2f		       d0 03		      bne	.project
     10  5e31
     11  5e31		       20 5f f2    .empty     jsr	AddMove
     12  5e34		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  5e37		       30 0e		      bmi	.invalid
     14  5e39		       b9 79 fc 	      lda	Board,y
     15  5e3c		       f0 f3		      beq	.empty
     16  5e3e		       85 9d		      sta	capture
     17  5e40		       45 91		      eor	currentPiece
     18  5e42		       10 03		      bpl	.invalid
     19  5e44		       20 5f f2 	      jsr	AddMove
     20  5e47
     21  5e47				   .invalid
      0  5e47					      MOVE_TOWARDS	_UP+_RIGHT
      1  5e47					      SUBROUTINE
      2  5e47
      3  5e47
      4  5e47
      5  5e47		       a9 00		      lda	#0
      6  5e49		       85 9d		      sta	capture
      7  5e4b
      8  5e4b		       a6 92		      ldx	currentSquare
      9  5e4d		       d0 03		      bne	.project
     10  5e4f
     11  5e4f		       20 5f f2    .empty     jsr	AddMove
     12  5e52		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  5e55		       30 0e		      bmi	.invalid
     14  5e57		       b9 79 fc 	      lda	Board,y
     15  5e5a		       f0 f3		      beq	.empty
     16  5e5c		       85 9d		      sta	capture
     17  5e5e		       45 91		      eor	currentPiece
     18  5e60		       10 03		      bpl	.invalid
     19  5e62		       20 5f f2 	      jsr	AddMove
     20  5e65
     21  5e65				   .invalid
     20  5e65
     21  5e65		       4c c0 f1 	      jmp	MoveReturn
     22  5e68
     23  5e68							;---------------------------------------------------------------------------------------------------
     24  5e68							; EOF
------- FILE PIECE_HANDLER@1#1.asm
      7  5e68
      8  5e68							;---------------------------------------------------------------------------------------------------
      9  5e68
      0  5e68					      CHECK_BANK_SIZE	"PIECE_HANDLER_1"
      1  5e68		       02 68	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_1 (1K) SIZE =  $268 , FREE= $198
      2  5e68					      ECHO	"PIECE_HANDLER_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5e68				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5e68				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_1", " size=", * - ORIGIN
      5  5e68				  -	      ERR
      6  5e68					      ENDIF
     11  5e68
     12  5e68							;---------------------------------------------------------------------------------------------------
     13  5e68							; EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#2.asm LEVEL 2 PASS 4
      0  5e68					      include	"PIECE_HANDLER@1#2.asm"
      0  5e68					      SLOT	1
      1  5e68				  -	      IF	(1 < 0) || (1 > 3)
      2  5e68				  -	      ECHO	"Illegal bank address/segment location", 1
      3  5e68				  -	      ERR
      4  5e68					      ENDIF
      5  5e68				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  5e68				   _BANK_SLOT SET	1 * 64
      0  5e68					      NEWBANK	PIECE_HANDLER_2
      1  625c ????				      SEG	PIECE_HANDLER_2
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   PIECE_HANDLER_2_START SET	*
      6  6000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6000				   PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + 1024
      3  6000
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  6000					      include	"PIECE_ROOK.asm"
      1  6000							; Copyright (C)2020 Andrew Davie
      2  6000							; Rook move handler
      3  6000
      4  6000							;---------------------------------------------------------------------------------------------------
      5  6000							; ROOK
      6  6000							;---------------------------------------------------------------------------------------------------
      7  6000
      0  6000					      DEF	Handle_ROOK
      1  6000				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  6000				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  6000				   Handle_ROOK
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	Handle_ROOK
      9  6000					      SUBROUTINE
     10  6000
      0  6000					      REFER	GenerateAllMoves	;✅
      1  6000					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6000				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6000					      ENDIF
      0  6000					      VEND	Handle_ROOK
      1  6000				  -	      IFNCONST	Handle_ROOK
      2  6000				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  6000				  -	      ERR
      4  6000					      ENDIF
      5  6000		       00 b7	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  6000
     14  6000							; Pass...
     15  6000							; x = currentSquare (square the piece is on)
     16  6000							; currentPiece (with flags/colour attached)
     17  6000
      0  6000					      MOVE_TOWARDS	_DOWN
      1  6000					      SUBROUTINE
      2  6000
      3  6000
      4  6000
      5  6000		       a9 00		      lda	#0
      6  6002		       85 9d		      sta	capture
      7  6004
      8  6004		       a6 92		      ldx	currentSquare
      9  6006		       d0 03		      bne	.project
     10  6008
     11  6008		       20 5f f2    .empty     jsr	AddMove
     12  600b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  600e		       30 0e		      bmi	.invalid
     14  6010		       b9 79 fc 	      lda	Board,y
     15  6013		       f0 f3		      beq	.empty
     16  6015		       85 9d		      sta	capture
     17  6017		       45 91		      eor	currentPiece
     18  6019		       10 03		      bpl	.invalid
     19  601b		       20 5f f2 	      jsr	AddMove
     20  601e
     21  601e				   .invalid
      0  601e					      MOVE_TOWARDS	_RIGHT
      1  601e					      SUBROUTINE
      2  601e
      3  601e
      4  601e
      5  601e		       a9 00		      lda	#0
      6  6020		       85 9d		      sta	capture
      7  6022
      8  6022		       a6 92		      ldx	currentSquare
      9  6024		       d0 03		      bne	.project
     10  6026
     11  6026		       20 5f f2    .empty     jsr	AddMove
     12  6029		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  602c		       30 0e		      bmi	.invalid
     14  602e		       b9 79 fc 	      lda	Board,y
     15  6031		       f0 f3		      beq	.empty
     16  6033		       85 9d		      sta	capture
     17  6035		       45 91		      eor	currentPiece
     18  6037		       10 03		      bpl	.invalid
     19  6039		       20 5f f2 	      jsr	AddMove
     20  603c
     21  603c				   .invalid
      0  603c					      MOVE_TOWARDS	_UP
      1  603c					      SUBROUTINE
      2  603c
      3  603c
      4  603c
      5  603c		       a9 00		      lda	#0
      6  603e		       85 9d		      sta	capture
      7  6040
      8  6040		       a6 92		      ldx	currentSquare
      9  6042		       d0 03		      bne	.project
     10  6044
     11  6044		       20 5f f2    .empty     jsr	AddMove
     12  6047		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  604a		       30 0e		      bmi	.invalid
     14  604c		       b9 79 fc 	      lda	Board,y
     15  604f		       f0 f3		      beq	.empty
     16  6051		       85 9d		      sta	capture
     17  6053		       45 91		      eor	currentPiece
     18  6055		       10 03		      bpl	.invalid
     19  6057		       20 5f f2 	      jsr	AddMove
     20  605a
     21  605a				   .invalid
      0  605a					      MOVE_TOWARDS	_LEFT
      1  605a					      SUBROUTINE
      2  605a
      3  605a
      4  605a
      5  605a		       a9 00		      lda	#0
      6  605c		       85 9d		      sta	capture
      7  605e
      8  605e		       a6 92		      ldx	currentSquare
      9  6060		       d0 03		      bne	.project
     10  6062
     11  6062		       20 5f f2    .empty     jsr	AddMove
     12  6065		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  6068		       30 0e		      bmi	.invalid
     14  606a		       b9 79 fc 	      lda	Board,y
     15  606d		       f0 f3		      beq	.empty
     16  606f		       85 9d		      sta	capture
     17  6071		       45 91		      eor	currentPiece
     18  6073		       10 03		      bpl	.invalid
     19  6075		       20 5f f2 	      jsr	AddMove
     20  6078
     21  6078				   .invalid
     22  6078
     23  6078		       4c c0 f1 	      jmp	MoveReturn
     24  607b
     25  607b							;---------------------------------------------------------------------------------------------------
     26  607b							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  607b					      include	"PIECE_QUEEN.asm"
      1  607b							; Copyright (C)2020 Andrew Davie
      2  607b
      3  607b							;---------------------------------------------------------------------------------------------------
      4  607b							; QUEEN
      5  607b							;---------------------------------------------------------------------------------------------------
      6  607b
      0  607b					      DEF	Handle_QUEEN
      1  607b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  607b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  607b				   Handle_QUEEN
      4  607b				   TEMPORARY_VAR SET	Overlay
      5  607b				   TEMPORARY_OFFSET SET	0
      6  607b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  607b				   FUNCTION_NAME SET	Handle_QUEEN
      8  607b					      SUBROUTINE
      9  607b
      0  607b					      REFER	GenerateAllMoves	;✅
      1  607b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  607b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  607b					      ENDIF
      0  607b					      VEND	Handle_QUEEN
      1  607b				  -	      IFNCONST	Handle_QUEEN
      2  607b				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  607b				  -	      ERR
      4  607b					      ENDIF
      5  607b		       00 b7	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  607b
     13  607b							; Pass...
     14  607b							; x = currentSquare (square the piece is on)
     15  607b							; currentPiece (with flags/colour attached)
     16  607b
      0  607b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  607b					      SUBROUTINE
      2  607b
      3  607b
      4  607b
      5  607b		       a9 00		      lda	#0
      6  607d		       85 9d		      sta	capture
      7  607f
      8  607f		       a6 92		      ldx	currentSquare
      9  6081		       d0 03		      bne	.project
     10  6083
     11  6083		       20 5f f2    .empty     jsr	AddMove
     12  6086		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6089		       30 0e		      bmi	.invalid
     14  608b		       b9 79 fc 	      lda	Board,y
     15  608e		       f0 f3		      beq	.empty
     16  6090		       85 9d		      sta	capture
     17  6092		       45 91		      eor	currentPiece
     18  6094		       10 03		      bpl	.invalid
     19  6096		       20 5f f2 	      jsr	AddMove
     20  6099
     21  6099				   .invalid
      0  6099					      MOVE_TOWARDS	_DOWN
      1  6099					      SUBROUTINE
      2  6099
      3  6099
      4  6099
      5  6099		       a9 00		      lda	#0
      6  609b		       85 9d		      sta	capture
      7  609d
      8  609d		       a6 92		      ldx	currentSquare
      9  609f		       d0 03		      bne	.project
     10  60a1
     11  60a1		       20 5f f2    .empty     jsr	AddMove
     12  60a4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  60a7		       30 0e		      bmi	.invalid
     14  60a9		       b9 79 fc 	      lda	Board,y
     15  60ac		       f0 f3		      beq	.empty
     16  60ae		       85 9d		      sta	capture
     17  60b0		       45 91		      eor	currentPiece
     18  60b2		       10 03		      bpl	.invalid
     19  60b4		       20 5f f2 	      jsr	AddMove
     20  60b7
     21  60b7				   .invalid
      0  60b7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  60b7					      SUBROUTINE
      2  60b7
      3  60b7
      4  60b7
      5  60b7		       a9 00		      lda	#0
      6  60b9		       85 9d		      sta	capture
      7  60bb
      8  60bb		       a6 92		      ldx	currentSquare
      9  60bd		       d0 03		      bne	.project
     10  60bf
     11  60bf		       20 5f f2    .empty     jsr	AddMove
     12  60c2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  60c5		       30 0e		      bmi	.invalid
     14  60c7		       b9 79 fc 	      lda	Board,y
     15  60ca		       f0 f3		      beq	.empty
     16  60cc		       85 9d		      sta	capture
     17  60ce		       45 91		      eor	currentPiece
     18  60d0		       10 03		      bpl	.invalid
     19  60d2		       20 5f f2 	      jsr	AddMove
     20  60d5
     21  60d5				   .invalid
      0  60d5					      MOVE_TOWARDS	_RIGHT
      1  60d5					      SUBROUTINE
      2  60d5
      3  60d5
      4  60d5
      5  60d5		       a9 00		      lda	#0
      6  60d7		       85 9d		      sta	capture
      7  60d9
      8  60d9		       a6 92		      ldx	currentSquare
      9  60db		       d0 03		      bne	.project
     10  60dd
     11  60dd		       20 5f f2    .empty     jsr	AddMove
     12  60e0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  60e3		       30 0e		      bmi	.invalid
     14  60e5		       b9 79 fc 	      lda	Board,y
     15  60e8		       f0 f3		      beq	.empty
     16  60ea		       85 9d		      sta	capture
     17  60ec		       45 91		      eor	currentPiece
     18  60ee		       10 03		      bpl	.invalid
     19  60f0		       20 5f f2 	      jsr	AddMove
     20  60f3
     21  60f3				   .invalid
      0  60f3					      MOVE_TOWARDS	_UP+_RIGHT
      1  60f3					      SUBROUTINE
      2  60f3
      3  60f3
      4  60f3
      5  60f3		       a9 00		      lda	#0
      6  60f5		       85 9d		      sta	capture
      7  60f7
      8  60f7		       a6 92		      ldx	currentSquare
      9  60f9		       d0 03		      bne	.project
     10  60fb
     11  60fb		       20 5f f2    .empty     jsr	AddMove
     12  60fe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6101		       30 0e		      bmi	.invalid
     14  6103		       b9 79 fc 	      lda	Board,y
     15  6106		       f0 f3		      beq	.empty
     16  6108		       85 9d		      sta	capture
     17  610a		       45 91		      eor	currentPiece
     18  610c		       10 03		      bpl	.invalid
     19  610e		       20 5f f2 	      jsr	AddMove
     20  6111
     21  6111				   .invalid
      0  6111					      MOVE_TOWARDS	_UP
      1  6111					      SUBROUTINE
      2  6111
      3  6111
      4  6111
      5  6111		       a9 00		      lda	#0
      6  6113		       85 9d		      sta	capture
      7  6115
      8  6115		       a6 92		      ldx	currentSquare
      9  6117		       d0 03		      bne	.project
     10  6119
     11  6119		       20 5f f2    .empty     jsr	AddMove
     12  611c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  611f		       30 0e		      bmi	.invalid
     14  6121		       b9 79 fc 	      lda	Board,y
     15  6124		       f0 f3		      beq	.empty
     16  6126		       85 9d		      sta	capture
     17  6128		       45 91		      eor	currentPiece
     18  612a		       10 03		      bpl	.invalid
     19  612c		       20 5f f2 	      jsr	AddMove
     20  612f
     21  612f				   .invalid
      0  612f					      MOVE_TOWARDS	_UP+_LEFT
      1  612f					      SUBROUTINE
      2  612f
      3  612f
      4  612f
      5  612f		       a9 00		      lda	#0
      6  6131		       85 9d		      sta	capture
      7  6133
      8  6133		       a6 92		      ldx	currentSquare
      9  6135		       d0 03		      bne	.project
     10  6137
     11  6137		       20 5f f2    .empty     jsr	AddMove
     12  613a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  613d		       30 0e		      bmi	.invalid
     14  613f		       b9 79 fc 	      lda	Board,y
     15  6142		       f0 f3		      beq	.empty
     16  6144		       85 9d		      sta	capture
     17  6146		       45 91		      eor	currentPiece
     18  6148		       10 03		      bpl	.invalid
     19  614a		       20 5f f2 	      jsr	AddMove
     20  614d
     21  614d				   .invalid
      0  614d					      MOVE_TOWARDS	_LEFT
      1  614d					      SUBROUTINE
      2  614d
      3  614d
      4  614d
      5  614d		       a9 00		      lda	#0
      6  614f		       85 9d		      sta	capture
      7  6151
      8  6151		       a6 92		      ldx	currentSquare
      9  6153		       d0 03		      bne	.project
     10  6155
     11  6155		       20 5f f2    .empty     jsr	AddMove
     12  6158		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  615b		       30 0e		      bmi	.invalid
     14  615d		       b9 79 fc 	      lda	Board,y
     15  6160		       f0 f3		      beq	.empty
     16  6162		       85 9d		      sta	capture
     17  6164		       45 91		      eor	currentPiece
     18  6166		       10 03		      bpl	.invalid
     19  6168		       20 5f f2 	      jsr	AddMove
     20  616b
     21  616b				   .invalid
     25  616b
     26  616b		       4c c0 f1 	      jmp	MoveReturn
     27  616e
     28  616e							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  616e					      include	"PIECE_KING.asm"
      1  616e							; Copyright (C)2020 Andrew Davie
      2  616e
      3  616e							;---------------------------------------------------------------------------------------------------
      4  616e							; KING
      5  616e							; This is the move handler for a KING
      6  616e							; "Check" is detected in the next ply of the search.
      7  616e
      8  616e
      9  616e							;---------------------------------------------------------------------------------------------------
     10  616e
     11  616e							; MACRO - Castling
     12  616e
     13  616e		       00 03	   KINGSIDE   =	3
     14  616e		       ff ff ff fc QUEENSIDE  =	-4
     15  616e
     16  616e					      MAC	castle
     17  616e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  616e
     19  616e					      ldx	currentSquare
     20  616e					      lda	Board+{1},x	; kingside/queenside R position
     21  616e					      and	#PIECE_MASK|FLAG_MOVED
     22  616e					      cmp	#ROOK
     23  616e					      bne	.noCastle	; not a R that hasn't moved
     24  616e
     25  616e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  616e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  616e
     28  616e					      IF	{1} = QUEENSIDE
     29  616e					      lda	Board-3,x	; N pos
     30  616e					      ora	Board-2,x	; B pos
     31  616e					      ora	Board-1,x	; Q pos
     32  616e					      bne	.noCastle	; not vacant?
     33  616e
     34  616e					      ENDIF
     35  616e
     36  616e					      IF	{1} = KINGSIDE
     37  616e					      lda	Board+2,x	; N pos
     38  616e					      ora	Board+1,x	; B pos
     39  616e					      bne	.noCastle	; not vacant?
     40  616e					      ENDIF
     41  616e
     42  616e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  616e
     44  616e							; FINALLY -- king can castle
     45  616e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  616e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  616e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  616e
     49  616e					      lda	currentPiece
     50  616e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  616e					      sta	currentPiece
     52  616e
     53  616e					      IF	{1} = KINGSIDE
     54  616e					      ldy	ValidSquare+2,x
     55  616e					      ENDIF
     56  616e
     57  616e					      IF	{1} = QUEENSIDE
     58  616e					      ldy	ValidSquare-2,x
     59  616e					      ENDIF
     60  616e
     61  616e					      jsr	AddMove	; 57
     62  616e
     63  616e				   .noCastle
     64  616e					      ENDM
     65  616e
     66  616e
     67  616e							;---------------------------------------------------------------------------------------------------
     68  616e
      0  616e					      DEF	Handle_KING
      1  616e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  616e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  616e				   Handle_KING
      4  616e				   TEMPORARY_VAR SET	Overlay
      5  616e				   TEMPORARY_OFFSET SET	0
      6  616e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  616e				   FUNCTION_NAME SET	Handle_KING
     70  616e					      SUBROUTINE
     71  616e
      0  616e					      REFER	GenerateAllMoves	;✅
      1  616e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  616e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  616e					      ENDIF
      0  616e					      VEND	Handle_KING
      1  616e				  -	      IFNCONST	Handle_KING
      2  616e				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  616e				  -	      ERR
      4  616e					      ENDIF
      5  616e		       00 b7	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  616e
     75  616e							; x = currentSquare (square the KING is on)
     76  616e							; currentPiece (KING of course, but with flags/colour attached)
     77  616e
      0  616e					      MOVE_TO	_DOWN+_LEFT
      1  616e					      SUBROUTINE
      2  616e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  6171		       30 0e		      bmi	.invalid
      4  6173		       b9 79 fc 	      lda	Board,y
      5  6176		       85 9d		      sta	capture
      6  6178		       f0 04		      beq	.squareEmpty
      7  617a		       45 91		      eor	currentPiece
      8  617c		       10 03		      bpl	.invalid
      9  617e		       20 5f f2    .squareEmpty jsr	AddMove
     10  6181				   .invalid
      0  6181					      MOVE_TO_X	_DOWN
      1  6181		       a6 92		      ldx	currentSquare
      0  6183					      MOVE_TO	_DOWN
      1  6183					      SUBROUTINE
      2  6183		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      3  6186		       30 0e		      bmi	.invalid
      4  6188		       b9 79 fc 	      lda	Board,y
      5  618b		       85 9d		      sta	capture
      6  618d		       f0 04		      beq	.squareEmpty
      7  618f		       45 91		      eor	currentPiece
      8  6191		       10 03		      bpl	.invalid
      9  6193		       20 5f f2    .squareEmpty jsr	AddMove
     10  6196				   .invalid
      0  6196					      MOVE_TO_X	_DOWN+_RIGHT
      1  6196		       a6 92		      ldx	currentSquare
      0  6198					      MOVE_TO	_DOWN+_RIGHT
      1  6198					      SUBROUTINE
      2  6198		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  619b		       30 0e		      bmi	.invalid
      4  619d		       b9 79 fc 	      lda	Board,y
      5  61a0		       85 9d		      sta	capture
      6  61a2		       f0 04		      beq	.squareEmpty
      7  61a4		       45 91		      eor	currentPiece
      8  61a6		       10 03		      bpl	.invalid
      9  61a8		       20 5f f2    .squareEmpty jsr	AddMove
     10  61ab				   .invalid
      0  61ab					      MOVE_TO_X	_RIGHT
      1  61ab		       a6 92		      ldx	currentSquare
      0  61ad					      MOVE_TO	_RIGHT
      1  61ad					      SUBROUTINE
      2  61ad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      3  61b0		       30 0e		      bmi	.invalid
      4  61b2		       b9 79 fc 	      lda	Board,y
      5  61b5		       85 9d		      sta	capture
      6  61b7		       f0 04		      beq	.squareEmpty
      7  61b9		       45 91		      eor	currentPiece
      8  61bb		       10 03		      bpl	.invalid
      9  61bd		       20 5f f2    .squareEmpty jsr	AddMove
     10  61c0				   .invalid
      0  61c0					      MOVE_TO_X	_UP+_RIGHT
      1  61c0		       a6 92		      ldx	currentSquare
      0  61c2					      MOVE_TO	_UP+_RIGHT
      1  61c2					      SUBROUTINE
      2  61c2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  61c5		       30 0e		      bmi	.invalid
      4  61c7		       b9 79 fc 	      lda	Board,y
      5  61ca		       85 9d		      sta	capture
      6  61cc		       f0 04		      beq	.squareEmpty
      7  61ce		       45 91		      eor	currentPiece
      8  61d0		       10 03		      bpl	.invalid
      9  61d2		       20 5f f2    .squareEmpty jsr	AddMove
     10  61d5				   .invalid
      0  61d5					      MOVE_TO_X	_UP
      1  61d5		       a6 92		      ldx	currentSquare
      0  61d7					      MOVE_TO	_UP
      1  61d7					      SUBROUTINE
      2  61d7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      3  61da		       30 0e		      bmi	.invalid
      4  61dc		       b9 79 fc 	      lda	Board,y
      5  61df		       85 9d		      sta	capture
      6  61e1		       f0 04		      beq	.squareEmpty
      7  61e3		       45 91		      eor	currentPiece
      8  61e5		       10 03		      bpl	.invalid
      9  61e7		       20 5f f2    .squareEmpty jsr	AddMove
     10  61ea				   .invalid
      0  61ea					      MOVE_TO_X	_UP+_LEFT
      1  61ea		       a6 92		      ldx	currentSquare
      0  61ec					      MOVE_TO	_UP+_LEFT
      1  61ec					      SUBROUTINE
      2  61ec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      3  61ef		       30 0e		      bmi	.invalid
      4  61f1		       b9 79 fc 	      lda	Board,y
      5  61f4		       85 9d		      sta	capture
      6  61f6		       f0 04		      beq	.squareEmpty
      7  61f8		       45 91		      eor	currentPiece
      8  61fa		       10 03		      bpl	.invalid
      9  61fc		       20 5f f2    .squareEmpty jsr	AddMove
     10  61ff				   .invalid
      0  61ff					      MOVE_TO_X	_LEFT
      1  61ff		       a6 92		      ldx	currentSquare
      0  6201					      MOVE_TO	_LEFT
      1  6201					      SUBROUTINE
      2  6201		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      3  6204		       30 0e		      bmi	.invalid
      4  6206		       b9 79 fc 	      lda	Board,y
      5  6209		       85 9d		      sta	capture
      6  620b		       f0 04		      beq	.squareEmpty
      7  620d		       45 91		      eor	currentPiece
      8  620f		       10 03		      bpl	.invalid
      9  6211		       20 5f f2    .squareEmpty jsr	AddMove
     10  6214				   .invalid
     86  6214
     87  6214							;IF CASTLING_ENABLED
     88  6214
     89  6214		       24 91		      bit	currentPiece
     90  6216		       70 41		      bvs	.exit	; king has moved, so no castling
     91  6218
      0  6218					      CASTLE	KINGSIDE
      1  6218
      2  6218
      3  6218		       a6 92		      ldx	currentSquare
      4  621a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  621d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  621f		       c9 05		      cmp	#ROOK
      7  6221		       d0 14		      bne	.noCastle
      8  6223
      9  6223
     10  6223
     11  6223
     12  6223				  -	      IF	KINGSIDE = QUEENSIDE
     13  6223				  -	      lda	Board-3,x
     14  6223				  -	      ora	Board-2,x
     15  6223				  -	      ora	Board-1,x
     16  6223				  -	      bne	.noCastle
     17  6223				  -
     18  6223					      ENDIF
     19  6223
     20  6223					      IF	KINGSIDE = KINGSIDE
     21  6223		       bd 7b fc 	      lda	Board+2,x
     22  6226		       1d 7a fc 	      ora	Board+1,x
     23  6229		       d0 0c		      bne	.noCastle
     24  622b					      ENDIF
     25  622b
     26  622b
     27  622b
     28  622b
     29  622b
     30  622b
     31  622b
     32  622b
     33  622b		       a5 91		      lda	currentPiece
     34  622d		       09 10		      ora	#FLAG_CASTLE
     35  622f		       85 91		      sta	currentPiece
     36  6231
     37  6231					      IF	KINGSIDE = KINGSIDE
     38  6231		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  6234					      ENDIF
     40  6234
     41  6234				  -	      IF	KINGSIDE = QUEENSIDE
     42  6234				  -	      ldy	ValidSquare-2,x
     43  6234					      ENDIF
     44  6234
     45  6234		       20 5f f2 	      jsr	AddMove
     46  6237
     47  6237				   .noCastle
      0  6237					      CASTLE	QUEENSIDE
      1  6237
      2  6237
      3  6237		       a6 92		      ldx	currentSquare
      4  6239		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  623c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  623e		       c9 05		      cmp	#ROOK
      7  6240		       d0 17		      bne	.noCastle
      8  6242
      9  6242
     10  6242
     11  6242
     12  6242					      IF	QUEENSIDE = QUEENSIDE
     13  6242		       bd 76 fc 	      lda	Board-3,x
     14  6245		       1d 77 fc 	      ora	Board-2,x
     15  6248		       1d 78 fc 	      ora	Board-1,x
     16  624b		       d0 0c		      bne	.noCastle
     17  624d
     18  624d					      ENDIF
     19  624d
     20  624d				  -	      IF	QUEENSIDE = KINGSIDE
     21  624d				  -	      lda	Board+2,x
     22  624d				  -	      ora	Board+1,x
     23  624d				  -	      bne	.noCastle
     24  624d					      ENDIF
     25  624d
     26  624d
     27  624d
     28  624d
     29  624d
     30  624d
     31  624d
     32  624d
     33  624d		       a5 91		      lda	currentPiece
     34  624f		       09 10		      ora	#FLAG_CASTLE
     35  6251		       85 91		      sta	currentPiece
     36  6253
     37  6253				  -	      IF	QUEENSIDE = KINGSIDE
     38  6253				  -	      ldy	ValidSquare+2,x
     39  6253					      ENDIF
     40  6253
     41  6253					      IF	QUEENSIDE = QUEENSIDE
     42  6253		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  6256					      ENDIF
     44  6256
     45  6256		       20 5f f2 	      jsr	AddMove
     46  6259
     47  6259				   .noCastle
     94  6259
     95  6259							;ENDIF
     96  6259
     97  6259		       4c c0 f1    .exit      jmp	MoveReturn
     98  625c
     99  625c							;---------------------------------------------------------------------------------------------------
    100  625c							; EOF
------- FILE PIECE_HANDLER@1#2.asm
      7  625c
      8  625c							;---------------------------------------------------------------------------------------------------
      9  625c
      0  625c					      CHECK_BANK_SIZE	"PIECE_HANDLER_2"
      1  625c		       02 5c	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_2 (1K) SIZE =  $25c , FREE= $1a4
      2  625c					      ECHO	"PIECE_HANDLER_2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  625c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  625c				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_2", " size=", * - ORIGIN
      5  625c				  -	      ERR
      6  625c					      ENDIF
     11  625c
     12  625c							;---------------------------------------------------------------------------------------------------
     13  625c							; EOF
------- FILE ./chess.asm
------- FILE BANK_3.asm LEVEL 2 PASS 4
      0  625c					      include	"BANK_3.asm"
      1  625c							; Chess
      2  625c							; Copyright (c) 2019-2020 Andrew Davie
      3  625c							; andrew@taswegian.com
      4  625c
      0  625c					      SLOT	3	; this code assembles for bank #1
      1  625c				  -	      IF	(3 < 0) || (3 > 3)
      2  625c				  -	      ECHO	"Illegal bank address/segment location", 3
      3  625c				  -	      ERR
      4  625c					      ENDIF
      5  625c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  625c				   _BANK_SLOT SET	3 * 64
      0  625c					      NEWBANK	THREE
      1  645e ????				      SEG	THREE
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   THREE_START SET	*
      6  6400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6400				   THREE      SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + 1024
      7  6400
      8  6400							;---------------------------------------------------------------------------------------------------
      9  6400
      0  6400					      DEF	GetPiece
      1  6400				   SLOT_GetPiece SET	_BANK_SLOT
      2  6400				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  6400				   GetPiece
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	GetPiece
     11  6400					      SUBROUTINE
     12  6400
      0  6400					      REFER	aiSelectDestinationSquare	;✅
      1  6400					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  6400				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  6400					      ENDIF
      0  6400					      REFER	aiQuiescent	;✅
      1  6400				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  6400				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  6400					      ENDIF
      0  6400					      VEND	GetPiece
      1  6400				  -	      IFNCONST	GetPiece
      2  6400				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  6400				  -	      ERR
      4  6400					      ENDIF
      5  6400		       00 a8	   VAREND_GetPiece =	TEMPORARY_VAR
     16  6400
     17  6400							; Retrieve the piece+flags from the movelist, given from/to squares
     18  6400							; Required as moves have different flags but same origin squares (e.g., castling)
     19  6400
     20  6400		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
     21  6402							;lda currentPly
     22  6402		       85 3e		      sta	SET_BANK_RAM	;@2
     23  6404
     24  6404							; returns piece in A+fromPiece
     25  6404							; or Y=-1 if not found
     26  6404
     27  6404							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     28  6404							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     29  6404							; This fixes the move with/without castle flag
     30  6404
     31  6404
      0  6404					      ldy@PLY	moveIndex
      1  6404		       ac cf f9 	      ldy	moveIndex
     33  6407		       30 11		      bmi	.fail	; shouldn't happen
     34  6409
     35  6409		       a5 85	   .scan      lda	fromX12
      0  640b					      cmp@PLY	MoveFrom,y
      1  640b		       d9 00 f8 	      cmp	MoveFrom,y
     37  640e		       d0 07		      bne	.next
     38  6410		       a5 86		      lda	toX12
      0  6412					      cmp@PLY	MoveTo,y
      1  6412		       d9 64 f8 	      cmp	MoveTo,y
     40  6415		       f0 04		      beq	.found
     41  6417		       88	   .next      dey
     42  6418		       10 ef		      bpl	.scan
     43  641a		       60	   .fail      rts
     44  641b
      0  641b				   .found     lda@PLY	MovePiece,y
      1  641b		       b9 00 f9 	      lda	MovePiece,y
     46  641e		       85 96		      sta	fromPiece
     47  6420
     48  6420		       60		      rts
     49  6421
     50  6421
     51  6421							;---------------------------------------------------------------------------------------------------
     52  6421
      0  6421					      DEF	GenCastleMoveForRook
      1  6421				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  6421				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  6421				   GenCastleMoveForRook
      4  6421				   TEMPORARY_VAR SET	Overlay
      5  6421				   TEMPORARY_OFFSET SET	0
      6  6421				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  6421				   FUNCTION_NAME SET	GenCastleMoveForRook
     54  6421					      SUBROUTINE
     55  6421
      0  6421					      REFER	MakeMove	;✅
      1  6421					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  6421				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  6421					      ENDIF
      0  6421					      REFER	CastleFixupDraw	;✅
      1  6421				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  6421				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  6421					      ENDIF
      0  6421					      VEND	GenCastleMoveForRook
      1  6421				  -	      IFNCONST	GenCastleMoveForRook
      2  6421				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  6421				  -	      ERR
      4  6421					      ENDIF
      5  6421		       00 b4	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
     59  6421
     60  6421		       18		      clc
     61  6422
     62  6422		       a5 96		      lda	fromPiece
     63  6424		       29 10		      and	#FLAG_CASTLE
     64  6426		       f0 2b		      beq	.exit	; NOT involved in castle!
     65  6428
     66  6428		       a2 04		      ldx	#4
     67  642a		       a5 85		      lda	fromX12	; *destination*
     68  642c		       18	   .findCast  clc
     69  642d		       ca		      dex
     70  642e		       30 23		      bmi	.exit
     71  6430		       dd 93 f5 	      cmp	KSquare,x
     72  6433		       d0 f7		      bne	.findCast
     73  6435
     74  6435		       bd 9b f5 	      lda	RSquareEnd,x
     75  6438		       85 86		      sta	toX12
      0  643a					      sta@PLY	secondaryBlank
      1  643a		       8d ce fb 	      sta	[RAM]+secondaryBlank
     77  643d		       bc 97 f5 	      ldy	RSquareStart,x
     78  6440		       84 85		      sty	fromX12
     79  6442		       84 87		      sty	originX12
      0  6444					      sty@PLY	secondarySquare
      1  6444		       8c cd fb 	      sty	[RAM]+secondarySquare
     81  6447
     82  6447		       a5 96		      lda	fromPiece
     83  6449		       29 80		      and	#128	; colour bit
     84  644b		       09 05		      ora	#ROOK	; preserve colour
     85  644d		       85 96		      sta	fromPiece
      0  644f					      sta@PLY	secondaryPiece
      1  644f		       8d cc fb 	      sta	[RAM]+secondaryPiece
     87  6452
     88  6452		       38		      sec
     89  6453		       60	   .exit      rts
     90  6454
     91  6454
     92  6454							;---------------------------------------------------------------------------------------------------
     93  6454
      0  6454					      DEF	showPromoteOptions
      1  6454				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  6454				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  6454				   showPromoteOptions
      4  6454				   TEMPORARY_VAR SET	Overlay
      5  6454				   TEMPORARY_OFFSET SET	0
      6  6454				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  6454				   FUNCTION_NAME SET	showPromoteOptions
     95  6454					      SUBROUTINE
     96  6454
      0  6454					      REFER	aiRollPromotionPiece	;✅
      1  6454					      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  6454				   TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  6454					      ENDIF
      0  6454					      REFER	aiChoosePromotePiece	;✅
      1  6454				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  6454				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  6454					      ENDIF
      0  6454					      VEND	showPromoteOptions
      1  6454				  -	      IFNCONST	showPromoteOptions
      2  6454				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  6454				  -	      ERR
      4  6454					      ENDIF
      5  6454		       00 a8	   VAREND_showPromoteOptions =	TEMPORARY_VAR
    100  6454
    101  6454							; X = character shape # (?/N/B/R/Q)
    102  6454
    103  6454		       a4 86		      ldy	toX12
    104  6456		       84 80		      sty	squareToDraw
    105  6458
    106  6458		       20 91 f5 	      jsr	CopySetupForMarker	;@1	   ; TODO: WRONG
    107  645b		       4c c5 f0 	      jmp	InterceptMarkerCopy	;@0
    108  645e
    109  645e
    110  645e							;---------------------------------------------------------------------------------------------------
    111  645e
      0  645e					      CHECK_BANK_SIZE	"BANK_3"
      1  645e		       00 5e	   .TEMP      =	* - _BANK_START
 BANK_3 (1K) SIZE =  $5e , FREE= $3a2
      2  645e					      ECHO	"BANK_3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  645e				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  645e				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_3", " size=", * - ORIGIN
      5  645e				  -	      ERR
      6  645e					      ENDIF
    113  645e
    114  645e							;---------------------------------------------------------------------------------------------------
    115  645e							; EOF
------- FILE ./chess.asm
    645  645e
------- FILE BANK_LAST.asm LEVEL 2 PASS 4
      0  645e					      include	"BANK_LAST.asm"
      1  645e							; Chess
      2  645e							; Copyright (c) 2019-2020 Andrew Davie
      3  645e							; andrew@taswegian.com
      4  645e
      0  645e					      SLOT	3
      1  645e				  -	      IF	(3 < 0) || (3 > 3)
      2  645e				  -	      ECHO	"Illegal bank address/segment location", 3
      3  645e				  -	      ERR
      4  645e					      ENDIF
      5  645e				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  645e				   _BANK_SLOT SET	3 * 64
      0  645e					      NEWBANK	LAST
      1  6c00 ????				      SEG	LAST
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   LAST_START SET	*
      6  6800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6800				   LAST       SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + 1024
      7  6800
      8  6800
      9  6800		       00 00 00 00*	      ds	1024
     10  6c00
     11  6c00							; EOF
------- FILE ./chess.asm
    647  6c00
    648  6c00							;---------------------------------------------------------------------------------------------------
    649  6c00							;EOF
