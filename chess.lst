------- FILE ./chess.asm LEVEL 1 PASS 4
      1  6c00 ????						; Chess
      2  6c00 ????						; Atari 2600 Chess display system
      3  6c00 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  6c00 ????						; andrew@taswegian.com
      5  6c00 ????
      6  6c00 ????
      7  6c00 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  6c00 ????
      9  6c00 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  6c00 ????				      include	"vcs.h"
      1  6c00 ????						; VCS.H
      2  6c00 ????						; Version 1.05, 13/November/2003
      3  6c00 ????
      4  6c00 ????	       00 69	   VERSION_VCS =	105
      5  6c00 ????
      6  6c00 ????						; This file defines hardware registers and memory mapping for the
      7  6c00 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  6c00 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  6c00 ????						; available at at http://www.atari2600.org/dasm
     10  6c00 ????						;
     11  6c00 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  6c00 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  6c00 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  6c00 ????						; with your views.  Please contribute, if you think you can improve this
     15  6c00 ????						; file!
     16  6c00 ????						;
     17  6c00 ????						; Latest Revisions...
     18  6c00 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  6c00 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  6c00 ????						;			    This will allow conditional code to verify VCS.H being
     21  6c00 ????						;			    used for code assembly.
     22  6c00 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  6c00 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  6c00 ????						;			 mirrored reading/writing differences.	This is more a
     25  6c00 ????						;			 readability issue, and binary compatibility with disassembled
     26  6c00 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  6c00 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  6c00 ????						;			 which was broken by the use of segments in this file, as
     29  6c00 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  6c00 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  6c00 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  6c00 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  6c00 ????						;						   it is safe to leave it undefined, and the base address will
     34  6c00 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  6c00 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  6c00 ????						;			  - register definitions are now generated through assignment
     37  6c00 ????						;			    in uninitialised segments.	This allows a changeable base
     38  6c00 ????						;			    address architecture.
     39  6c00 ????						; 1.0	22/MAR/2003		Initial release
     40  6c00 ????
     41  6c00 ????
     42  6c00 ????						;-------------------------------------------------------------------------------
     43  6c00 ????
     44  6c00 ????						; TIA_BASE_ADDRESS
     45  6c00 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  6c00 ????						; Normally 0, the base address should (externally, before including this file)
     47  6c00 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  6c00 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  6c00 ????						; < $40 as a bankswitch.
     50  6c00 ????
     51  6c00 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  6c00 ????			  -TIA_BASE_ADDRESS =	0
     53  6c00 ????				      ENDIF
     54  6c00 ????
     55  6c00 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  6c00 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  6c00 ????						; *OR* by declaring the label before including this file, eg:
     58  6c00 ????						; TIA_BASE_ADDRESS = $40
     59  6c00 ????						;   include "vcs.h"
     60  6c00 ????
     61  6c00 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  6c00 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  6c00 ????						; for the mirrored ROM hardware registers.
     64  6c00 ????
     65  6c00 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  6c00 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  6c00 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  6c00 ????
     69  6c00 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  6c00 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  6c00 ????				      ENDIF
     72  6c00 ????
     73  6c00 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  6c00 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  6c00 ????				      ENDIF
     76  6c00 ????
     77  6c00 ????						;-------------------------------------------------------------------------------
     78  6c00 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						; Pathways
     94  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
     95  0000 ????						; if QuickDraw does immediate exit, 58✅
     96  0000 ????
     97  0000 ????						;---------------------------------------------------------------------------------------------------
     98  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./chess.asm
     20  0000 ????
     21  0000 ????
     22  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     23  0000 ????
     24  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     25  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     26  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     27  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????
     35  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     36  0000 ????
     37  0000 ????
     38  0000 ????						; assemble diagnostics. Remove for release.
     39  0000 ????
     40  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     41  0000 ????	       00 01	   DIAGNOSTICS =	1
     42  0000 ????	       00 01	   QUIESCENCE =	1
     43  0000 ????	       00 00	   ASSERTS    =	0
     44  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     45  0000 ????	       00 00	   ENPASSANT_ENABLED =	0
     46  0000 ????	       00 01	   CASTLING_ENABLED =	1
     47  0000 ????
     48  0000 ????						; NOTE: SEARCH_DEPTH cannot be < 3, because the player's moves are generated from PLY+1, and use
     49  0000 ????						; PLY+2 for computer response (thus, 3). The bank allocation gets stomped!
     50  0000 ????
     51  0000 ????
     52  0000 ????	       00 04	   SEARCH_DEPTH =	4
     53  0000 ????	       00 00	   QUIESCE_EXTRA_DEPTH =	0
     54  0000 ????
     55  0000 ????
     56  0000 ????			  -	      IF	SEARCH_DEPTH < 3
     57  0000 ????			  -	      ECHO	"ERROR: Search depth nust be >= 3"
     58  0000 ????			  -	      ERR
     59  0000 ????				      ENDIF
     60  0000 ????
     61  0000 ????
     62  0000 ????
     63  0000 ????	       00 04	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     64  0000 ????	       00 04	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     65  0000 ????
     66  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     67  0000 ????						;    ERR "Not enough RAM for PLY banks"
     68  0000 ????						;ENDIF
     69  0000 ????
     70  0000 ????
     71  0000 ????
     72  0000 ????
     73  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     74  0000 ????
     75  0000 ????
     76  0000 ????
     77  0000 ????						; DELAYS
     78  0000 ????
     79  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     80  0000 ????
     81  0000 ????						;===================================
     82  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     83  0000 ????						;===================================
     84  0000 ????
     85  0000 ????						;-------------------------------------------------------------------------------
     86  0000 ????						; The following are optional YES/NO depending on phase of the moon
     87  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     88  0000 ????						;-------------------------------------------------------------------------------
     89  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     90  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     91  0000 ????			  -	      IF	FINAL_VERSION = YES
     92  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     93  0000 ????				      ENDIF
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????
     97  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     98  0000 ????
     99  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    100  0000 ????
    101  0000 ????						;------------------------------------------------------------------------------
    102  0000 ????
    103  0000 ????	       00 01	   PLUSCART   =	YES
    104  0000 ????
    105  0000 ????						;------------------------------------------------------------------------------
    106  0000 ????
    107  0000 ????
    108  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
    109  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    110  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    111  0000 ????
    112  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    113  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    114  0000 ????
    115  0000 ????
    116  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    117  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    118  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    119  0000 ????
    120  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    121  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    122  0000 ????
    123  0000 ????
    124  0000 ????						; Platform constants:
    125  0000 ????	       00 02	   PAL	      =	%10
    126  0000 ????	       00 02	   PAL_50     =	PAL|0
    127  0000 ????	       00 03	   PAL_60     =	PAL|1
    128  0000 ????
    129  0000 ????
    130  0000 ????				      IF	L276
    131  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    132  0000 ????			  -	      ELSE
    133  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    134  0000 ????				      ENDIF
    135  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    136  0000 ????
    137  0000 ????				      IF	L276
    138  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    139  0000 ????			  -	      ELSE
    140  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    141  0000 ????				      ENDIF
    142  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    143  0000 ????
    144  0000 ????				      IF	L276
    145  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    146  0000 ????			  -	      ELSE
    147  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    148  0000 ????				      ENDIF
    149  0000 ????	       01 38	   SCANLINES_PAL =	312
    150  0000 ????
    151  0000 ????
    152  0000 ????	       00 2e	   TIME_PART_2 =	46
    153  0000 ????	       00 2e	   TIME_PART_1 =	46
    154  0000 ????
    155  0000 ????
    156  0000 ????	       00 00	   SLOT0      =	0
    157  0000 ????	       00 40	   SLOT1      =	64
    158  0000 ????	       00 80	   SLOT2      =	128
    159  0000 ????	       00 c0	   SLOT3      =	192
    160  0000 ????
    161  0000 ????						;------------------------------------------------------------------------------
    162  0000 ????						; MACRO definitions
    163  0000 ????
    164  0000 ????
    165  0000 ????
    166  0000 ????				      MAC	newbank
    167  0000 ????				      SEG	{1}
    168  0000 ????				      ORG	_ORIGIN
    169  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    170  0000 ????			   _BANK_START SET	*
    171  0000 ????			   {1}_START  SET	*
    172  0000 ????			   _CURRENT_BANK SET	_ORIGIN/1024
    173  0000 ????			   {1}	      SET	_BANK_SLOT + _CURRENT_BANK
    174  0000 ????			   _ORIGIN    SET	_ORIGIN + 1024
    175  0000 ????				      ENDM		; bank name
    176  0000 ????
    177  0000 ????						;	      MAC DEFINE_1K_SEGMENT ; {seg name}
    178  0000 ????						;		  ALIGN $400
    179  0000 ????						;SEGMENT_{1}	  SET *
    180  0000 ????						;BANK_{1}	  SET _CURRENT_BANK
    181  0000 ????						;	      ENDM
    182  0000 ????
    183  0000 ????				      MAC	check_bank_size
    184  0000 ????			   .TEMP      =	* - _BANK_START
    185  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    186  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    187  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    188  0000 ????				      ERR
    189  0000 ????				      ENDIF
    190  0000 ????				      ENDM		; name
    191  0000 ????
    192  0000 ????				      MAC	check_ram_bank_size
    193  0000 ????			   .TEMP      =	* - _BANK_START
    194  0000 ????				      ECHO	{1}, "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    195  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    196  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    197  0000 ????				      ERR
    198  0000 ????				      ENDIF
    199  0000 ????				      ENDM		; name
    200  0000 ????
    201  0000 ????						;---------------------------------------------------------------------------------------------------
    202  0000 ????
    203  0000 ????						; Macro inserts a page break if the object would overlap a page
    204  0000 ????
    205  0000 ????				      MAC	optional_pagebreak
    206  0000 ????				      LIST	OFF
    207  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    208  0000 ????			   EARLY_LOCATION SET	*
    209  0000 ????				      ALIGN	256
    210  0000 ????				      IF	VERBOSE=1
    211  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    212  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    213  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    214  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    215  0000 ????				      ENDIF
    216  0000 ????				      ENDIF
    217  0000 ????				      LIST	ON
    218  0000 ????				      ENDM		; { string, size }
    219  0000 ????
    220  0000 ????
    221  0000 ????				      MAC	check_page_crossing
    222  0000 ????				      LIST	OFF
    223  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    224  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    225  0000 ????				      ENDIF
    226  0000 ????				      LIST	ON
    227  0000 ????				      ENDM
    228  0000 ????
    229  0000 ????				      MAC	checkpage
    230  0000 ????				      LIST	OFF
    231  0000 ????				      IF	>. != >{1}
    232  0000 ????				      ECHO	""
    233  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    234  0000 ????				      ECHO	""
    235  0000 ????				      ERR
    236  0000 ????				      ENDIF
    237  0000 ????				      LIST	ON
    238  0000 ????				      ENDM
    239  0000 ????
    240  0000 ????				      MAC	checkpagex
    241  0000 ????				      LIST	OFF
    242  0000 ????				      IF	>. != >{1}
    243  0000 ????				      ECHO	""
    244  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    245  0000 ????				      ECHO	{2}
    246  0000 ????				      ECHO	""
    247  0000 ????				      ERR
    248  0000 ????				      ENDIF
    249  0000 ????				      LIST	ON
    250  0000 ????				      ENDM
    251  0000 ????
    252  0000 ????						;---------------------------------------------------------------------------------------------------
    253  0000 ????
    254  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    255  0000 ????				      MAC	variable
    256  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    257  0000 ????			   {1}	      ds	{2}
    258  0000 ????				      ENDM		; {name, size}
    259  0000 ????
    260  0000 ????
    261  0000 ????						;---------------------------------------------------------------------------------------------------
    262  0000 ????
    263  0000 ????				      MAC	def
    264  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
    265  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
    266  0000 ????			   {1}			; entry point
    267  0000 ????			   TEMPORARY_VAR SET	Overlay
    268  0000 ????			   TEMPORARY_OFFSET SET	0
    269  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    270  0000 ????			   FUNCTION_NAME SET	{1}
    271  0000 ????				      ENDM		; name of subroutine
    272  0000 ????
    273  0000 ????
    274  0000 ????						;---------------------------------------------------------------------------------------------------
    275  0000 ????
    276  0000 ????				      MAC	allocate
    277  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    278  0000 ????				      DEF	{1}
    279  0000 ????				      ENDM
    280  0000 ????
    281  0000 ????						;---------------------------------------------------------------------------------------------------
    282  0000 ????
    283  0000 ????				      MAC	slot
    284  0000 ????				      IF	({1} < 0) || ({1} > 3)
    285  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
    286  0000 ????				      ERR
    287  0000 ????				      ENDIF
    288  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
    289  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
    290  0000 ????				      ENDM		; {1}
    291  0000 ????
    292  0000 ????
    293  0000 ????						;---------------------------------------------------------------------------------------------------
    294  0000 ????
    295  0000 ????				      MAC	negeval
    296  0000 ????
    297  0000 ????				      sec
    298  0000 ????				      lda	#0
    299  0000 ????				      sbc	Evaluation
    300  0000 ????				      sta	Evaluation
    301  0000 ????				      lda	#0
    302  0000 ????				      sbc	Evaluation+1
    303  0000 ????				      sta	Evaluation+1
    304  0000 ????				      ENDM
    305  0000 ????
    306  0000 ????
    307  0000 ????				      MAC	swap
    308  0000 ????				      lda	sideToMove
    309  0000 ????				      eor	#SWAP_SIDE
    310  0000 ????				      sta	sideToMove
    311  0000 ????
    312  0000 ????						;NEGEVAL
    313  0000 ????				      ENDM
    314  0000 ????
    315  0000 ????
    316  0000 ????						;---------------------------------------------------------------------------------------------------
    317  0000 ????
    318  0000 ????			   TEMPORARY_OFFSET SET	0
    319  0000 ????
    320  0000 ????
    321  0000 ????				      MAC	vend
    322  0000 ????				      IFNCONST	{1}
    323  0000 ????				      ECHO	"Incorrect VEND label", {1}
    324  0000 ????				      ERR
    325  0000 ????				      ENDIF
    326  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    327  0000 ????				      ENDM		; {1}
    328  0000 ????
    329  0000 ????
    330  0000 ????				      MAC	refer
    331  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    332  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    333  0000 ????				      ENDIF
    334  0000 ????				      ENDM		; {1}
    335  0000 ????
    336  0000 ????
    337  0000 ????
    338  0000 ????						; Define a temporary variable for use in a subroutine
    339  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    340  0000 ????
    341  0000 ????				      MAC	var
    342  0000 ????			   {1}	      =	TEMPORARY_VAR
    343  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    344  0000 ????
    345  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    346  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    347  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    348  0000 ????				      ENDIF
    349  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    350  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    351  0000 ????				      ERR
    352  0000 ????				      ENDIF
    353  0000 ????				      LIST	ON
    354  0000 ????				      ENDM		; { name, size }
    355  0000 ????
    356  0000 ????
    357  0000 ????						;---------------------------------------------------------------------------------------------------
    358  0000 ????
    359  0000 ????				      MAC	tag
    360  0000 ????						; {0}
    361  0000 ????				      ENDM		; {ident/tag}
    362  0000 ????
    363  0000 ????						;---------------------------------------------------------------------------------------------------
    364  0000 ????
    365  0000 ????				      MAC	sta@ram
    366  0000 ????				      sta	[RAM]+{0}
    367  0000 ????				      ENDM		;{}
    368  0000 ????
    369  0000 ????				      MAC	stx@ram
    370  0000 ????				      stx	[RAM]+{0}
    371  0000 ????				      ENDM
    372  0000 ????
    373  0000 ????				      MAC	sty@ram
    374  0000 ????				      sty	[RAM]+{0}
    375  0000 ????				      ENDM
    376  0000 ????
    377  0000 ????				      MAC	sta@ply
    378  0000 ????				      sta	[RAM]+{0}
    379  0000 ????				      ENDM		;{}
    380  0000 ????
    381  0000 ????				      MAC	stx@ply
    382  0000 ????				      stx	[RAM]+{0}
    383  0000 ????				      ENDM
    384  0000 ????
    385  0000 ????				      MAC	sty@ply
    386  0000 ????				      sty	[RAM]+{0}
    387  0000 ????				      ENDM
    388  0000 ????
    389  0000 ????
    390  0000 ????				      MAC	lda@ram
    391  0000 ????				      lda	{0}
    392  0000 ????				      ENDM		;{}
    393  0000 ????
    394  0000 ????				      MAC	ldx@ram
    395  0000 ????				      ldx	{0}
    396  0000 ????				      ENDM		;{}
    397  0000 ????
    398  0000 ????				      MAC	ldy@ram
    399  0000 ????				      ldy	{0}
    400  0000 ????				      ENDM		;{}
    401  0000 ????
    402  0000 ????
    403  0000 ????				      MAC	lda@ply
    404  0000 ????				      lda	{0}
    405  0000 ????				      ENDM		;{}
    406  0000 ????
    407  0000 ????				      MAC	ldx@ply
    408  0000 ????				      ldx	{0}
    409  0000 ????				      ENDM		;{}
    410  0000 ????
    411  0000 ????				      MAC	ldy@ply
    412  0000 ????				      ldy	{0}
    413  0000 ????				      ENDM		;{}
    414  0000 ????
    415  0000 ????
    416  0000 ????				      MAC	adc@ply
    417  0000 ????				      adc	{0}
    418  0000 ????				      ENDM		;{}
    419  0000 ????
    420  0000 ????				      MAC	sbc@ply
    421  0000 ????				      sbc	{0}
    422  0000 ????				      ENDM		;{}
    423  0000 ????
    424  0000 ????				      MAC	cmp@ply
    425  0000 ????				      cmp	{0}
    426  0000 ????				      ENDM		;{}
    427  0000 ????
    428  0000 ????						;---------------------------------------------------------------------------------------------------
    429  0000 ????
    430  0000 ????				      MAC	newrambank
    431  0000 ????						; {1}	     bank name
    432  0000 ????						; {2}	     RAM bank number
    433  0000 ????
    434  0000 ????				      SEG.U	{1}
    435  0000 ????				      ORG	ORIGIN_RAM
    436  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    437  0000 ????			   _BANK_START SET	*
    438  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
    439  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    440  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    441  0000 ????				      ENDM		; bank name
    442  0000 ????
    443  0000 ????						;---------------------------------------------------------------------------------------------------
    444  0000 ????
    445  0000 ????				      MAC	resync
    446  0000 ????						; resync screen, X and Y == 0 afterwards
    447  0000 ????				      lda	#%10	; make sure VBLANK is ON
    448  0000 ????				      sta	VBLANK
    449  0000 ????
    450  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    451  0000 ????			   .loopResync
    452  0000 ????				      VERTICAL_SYNC
    453  0000 ????
    454  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    455  0000 ????				      lda	Platform
    456  0000 ????				      eor	#PAL_50	; PAL-50?
    457  0000 ????				      bne	.ntsc
    458  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    459  0000 ????			   .ntsc
    460  0000 ????			   .loopWait
    461  0000 ????				      sta	WSYNC
    462  0000 ????				      sta	WSYNC
    463  0000 ????				      dey
    464  0000 ????				      bne	.loopWait
    465  0000 ????				      dex
    466  0000 ????				      bne	.loopResync
    467  0000 ????				      ENDM
    468  0000 ????
    469  0000 ????				      MAC	set_platform
    470  0000 ????						; 00 = NTSC
    471  0000 ????						; 01 = NTSC
    472  0000 ????						; 10 = PAL-50
    473  0000 ????						; 11 = PAL-60
    474  0000 ????				      lda	SWCHB
    475  0000 ????				      rol
    476  0000 ????				      rol
    477  0000 ????				      rol
    478  0000 ????				      and	#%11
    479  0000 ????				      eor	#PAL
    480  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    481  0000 ????				      ENDM
    482  0000 ????
    483  0000 ????
    484  0000 ????						;---------------------------------------------------------------------------------------------------
    485  0000 ????
    486  0000 ????						;    MAC JSROM_SAFE ; {routine}
    487  0000 ????						;    ; Saves bank of routine to variable for later restore.
    488  0000 ????						;    ; Switches to the bank and does a JSR to the routine.
    489  0000 ????
    490  0000 ????						;		  lda #BANK_{1}
    491  0000 ????						;		  sta savedBank
    492  0000 ????						;		  sta SET_BANK
    493  0000 ????						;		  jsr {1}
    494  0000 ????						;    ENDM
    495  0000 ????
    496  0000 ????
    497  0000 ????						;    MAC JSROM ; {routine}
    498  0000 ????
    499  0000 ????						;		  lda #BANK_{1}
    500  0000 ????						;		  sta SET_BANK
    501  0000 ????						;		  jsr {1}
    502  0000 ????						;    ENDM
    503  0000 ????
    504  0000 ????
    505  0000 ????						;    MAC JSRAM
    506  0000 ????						;		  lda #BANK_{1}
    507  0000 ????						;		  sta SET_BANK_RAM
    508  0000 ????						;		  jsr {1}
    509  0000 ????						;    ENDM
    510  0000 ????
    511  0000 ????
    512  0000 ????
    513  0000 ????				      MAC	timecheck
    514  0000 ????				      lda	INTIM
    515  0000 ????				      cmp	#SPEEDOF_{1}
    516  0000 ????				      bcc	{2}
    517  0000 ????				      ENDM		; {ident}, {branch if out of time}
    518  0000 ????
    519  0000 ????
    520  0000 ????				      MAC	timing
    521  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    522  0000 ????				      ENDM		; {label}, {cycles}
    523  0000 ????
    524  0000 ????
    525  0000 ????						;---------------------------------------------------------------------------------------------------
    526  0000 ????
    527  0000 ????						; Failsafe call of function in another bank
    528  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    529  0000 ????
    530  0000 ????				      MAC	call
    531  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    532  0000 ????				      ECHO	"ERROR: Incompatible call to function requiring same slot..."
    533  0000 ????				      ECHO	"Cannot switch bank in use for", {0}
    534  0000 ????				      ERR
    535  0000 ????				      ENDIF
    536  0000 ????				      lda	#BANK_{1}
    537  0000 ????				      sta	SET_BANK
    538  0000 ????				      jsr	{1}
    539  0000 ????				      ENDM		; function name
    540  0000 ????
    541  0000 ????
    542  0000 ????
    543  0000 ????						;---------------------------------------------------------------------------------------------------
    544  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00fc ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   aiState    ds	1	; state
     24 U008c		       00	   aiFlashDelay ds	1
     25 U008d
     26 U008d		       00	   aiMoveIndex ds	1
     27 U008e
     28 U008e		       00	   aiFlashPhase ds	1
     29 U008f
     30 U008f		       00 00	   Evaluation ds	2	; tracks value of the board position
     31 U0091
     32 U0091		       00	   currentPiece ds	1
     33 U0092		       00	   currentSquare ds	1
     34 U0093		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     35 U0094		       00	   currentPly ds	1
     36 U0095
     37 U0095		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     38 U0096		       00	   fromPiece  ds	1
     39 U0097		       00	   lastPiece  ds	1
     40 U0098		       00	   previousPiece ds	1
     41 U0099
     42 U0099		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U009a		       00 00	   speech_addr ds	2
     44 U009c		       00	   bg	      ds	1
     45 U009d
     46 U009d		       00	   capture    ds	1
     47 U009e
     48 U009e					      IF	DIAGNOSTICS
     49 U009e		       00 00 00    positionCount ds	3
     50 U00a1					      ENDIF
     51 U00a1
     52 U00a1							;maxPly			  ds 1
     53 U00a1		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     54 U00a2		       00	   protecting ds	1
     55 U00a3		       00	   randomness ds	1
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a4					      include	"overlays.asm"
      1 U00a4							; Chess
      2 U00a4							; Atari 2600 Chess display system
      3 U00a4							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a4							; andrew@taswegian.com
      5 U00a4
      6 U00a4							;---------------------------------------------------------------------------------------------------
      7 U00a4							; OVERLAYS!
      8 U00a4							; These variables are overlays, and should be managed with care
      9 U00a4							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a4							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a4							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a4							; overlay #2
     13 U00a4
     14 U00a4							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a4
     16 U00a4							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a4							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a4							;---------------------------------------------------------------------------------------------------
     19 U00a4
     20 U00a4					      MAC	overlay
     21 U00a4				   OVERLAY_NAME SET	{1}
     22 U00a4					      SEG.U	OVERLAY_{1}
     23 U00a4					      org	Overlay
     24 U00a4					      ENDM		; {name}
     25 U00a4
     26 U00a4							;---------------------------------------------------------------------------------------------------
     27 U00a4
     28 U00a4					      MAC	validate_overlay
     29 U00a4					      LIST	OFF
     30 U00a4				   OVERLAY_DELTA SET	* - Overlay
     31 U00a4					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a4				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a4					      ENDIF
     34 U00a4					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a4					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a4					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a4					      ERR
     38 U00a4					      ENDIF
     39 U00a4					      LIST	ON
     40 U00a4					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a4					      ENDM
     42 U00a4
     43 U00a4							;---------------------------------------------------------------------------------------------------
     44 U00a4
     45 U00a4				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a4				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a4
     48 U00a4
     49 U00a4							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a4							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a4							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a4							; (especially the latter ones) are only used in rare occasions.
     53 U00a4
     54 U00a4							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a4							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a4
      0 U00a4					      DEF	Overlay
      1 U00a4				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a4				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a4				   Overlay
      4 U00a4				   TEMPORARY_VAR SET	Overlay
      5 U00a4				   TEMPORARY_OFFSET SET	0
      6 U00a4				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a4				   FUNCTION_NAME SET	Overlay
     58 U00a4		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00f0				   END_OF_OVERLAY
     60 U00f0
     61 U00f0							;---------------------------------------------------------------------------------------------------
     62 U00f0							; And now... the overlays....
     63 U00f0
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00f0					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00f0
     66 U00f0							;---------------------------------------------------------------------------------------------------
     67 U00f0
     68 U00f0							; Some overlays are used across multiple routines/calls, and they will need to be defined
     69 U00f0							; "globally" in this file.
     70 U00f0
      0 U00f0					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00f0		       00 a4	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00f0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00f0
      4 U00f0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00f0					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00f0				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00f0					      ENDIF
      8 U00f0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00f0				  -	      ECHO	"Temporary Variable", __pieceShapeBuffer, "overflow!"
     10 U00f0				  -	      ERR
     11 U00f0					      ENDIF
     12 U00f0					      LIST	ON
      0 U00f0					      VAR	__ptr, 2
      1 U00f0		       00 ec	   __ptr      =	TEMPORARY_VAR
      2 U00f0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00f0
      4 U00f0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00f0					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00f0				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00f0					      ENDIF
      8 U00f0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00f0				  -	      ECHO	"Temporary Variable", __ptr, "overflow!"
     10 U00f0				  -	      ERR
     11 U00f0					      ENDIF
     12 U00f0					      LIST	ON
      0 U00f0					      VAR	__ptr2, 2
      1 U00f0		       00 ee	   __ptr2     =	TEMPORARY_VAR
      2 U00f0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00f0
      4 U00f0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00f0					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00f0				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00f0					      ENDIF
      8 U00f0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00f0				  -	      ECHO	"Temporary Variable", __ptr2, "overflow!"
     10 U00f0				  -	      ERR
     11 U00f0					      ENDIF
     12 U00f0					      LIST	ON
     74 U00f0
     75 U00f0							;---------------------------------------------------------------------------------------------------
     76 U00f0
     77 U00f0
     78 U00f0					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     79 U00f0					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $4c
     80 U00f0					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     81 U00f0
     82 U00f0							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00f0					      include	"stack.asm"
      1 U00f0							; Chess
      2 U00f0							; Atari 2600 Chess display system
      3 U00f0							; Copyright (c) 2019-2020 Andrew Davie
      4 U00f0							; andrew@taswegian.com
      5 U00f0
      6 U00f0
      7 U00f0		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00f0
      9 U00f0		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00fc
     11 U00fc							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00fc							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00fc							;  but since overlay is not generally stressed during alphabeta, we're good.
------- FILE ./chess.asm
    548 U00fc
 FREE BYTES IN ZERO PAGE =  $3
    549 U00fc					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    550 U00fc				  -	      IF	* > $FF
    551 U00fc				  -	      ERR	"Zero Page overflow!"
    552 U00fc					      ENDIF
    553 U00fc
    554 U00fc							;------------------------------------------------------------------------------
    555 U00fc							;##############################################################################
    556 U00fc							;------------------------------------------------------------------------------
    557 U00fc
    558 U00fc							; NOW THE VERY INTERESTING '3E' RAM BANKS
    559 U00fc							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    560 U00fc							; IN A 1K MEMORY SPACE
    561 U00fc
      0 U00fc					      SLOT	0
      1 U00fc				  -	      IF	(0 < 0) || (0 > 3)
      2 U00fc				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U00fc				  -	      ERR
      4 U00fc					      ENDIF
      5 U00fc				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U00fc				   _BANK_SLOT SET	0 * 64
      0 U00fc					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00fc
      2 U00fc
      3 U00fc
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0000				   _BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0400				   _BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0800				   _BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U0c00				   _BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1000				   _BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1400				   _BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1800				   _BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    564 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U1c00				   _BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    566 U1c00					      REPEND
    567 U1c00
    568 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    569 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    570 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    571 U1c00
    572 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    573 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    574 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    575 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    576 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    577 U1c00
    578 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    579 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    580 U1c00
    581 U1c00							;---------------------------------------------------------------------------------------------------
    582 U1c00
    583 U1c00
    584 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    585 U1c00
    586 U1c00					      MAC	next_random
    587 U1c00					      lda	rnd
    588 U1c00					      lsr
    589 U1c00					      bcc	.skipEOR
    590 U1c00					      eor	#RND_EOR_VAL
    591 U1c00				   .skipEOR   sta	rnd
    592 U1c00					      ENDM
    593 U1c00
    594 U1c00							;--------------------------------------------------------------------------------
    595 U1c00
    596 U1c00					      MAC	phase
    597 U1c00					      lda	#{1}
    598 U1c00					      sta	aiState
    599 U1c00					      ENDM		;#
    600 U1c00
    601 U1c00
    602 U1c00							;--------------------------------------------------------------------------------
    603 U1c00
    604 U1c00					      MAC	common_vars_alphabeta
    605 U1c00
    606 U1c00					      VAR	__thinkbar, 1
    607 U1c00					      VAR	__toggle, 1
    608 U1c00
    609 U1c00					      VAR	__bestMove, 1
    610 U1c00					      VAR	__alpha, 2
    611 U1c00					      VAR	__beta, 2
    612 U1c00					      VAR	__negaMax, 2
    613 U1c00					      VAR	__value, 2
    614 U1c00
    615 U1c00					      VAR	__quiesceCapOnly, 1
    616 U1c00
    617 U1c00					      ENDM
    618 U1c00
    619 U1c00
    620 U1c00							;---------------------------------------------------------------------------------------------------
    621 U1c00
------- FILE BANK_FIRST@0.asm LEVEL 2 PASS 4
      0 U1c00					      include	"BANK_FIRST@0.asm"	; MUST be first in ROM - contains reset vectors
      1 U1c00							; Chess
      2 U1c00							; Copyright (c) 2019-2020 Andrew Davie
      3 U1c00							; andrew@taswegian.com
      4 U1c00
      5 U1c00
      6 U1c00							; SLOT0 - screen draw, state machine dispatcher
      7 U1c00							; SLOT1 - anything
      8 U1c00							; SLOT2 - moves/ply
      9 U1c00							; SLOT3 - board
     10 U1c00
     11 U1c00
     12 U1c00
     13 U1c00
     14 U1c00
     15 U1c00
      0 U1c00					      SLOT	0
      1 U1c00				  -	      IF	(0 < 0) || (0 > 3)
      2 U1c00				  -	      ECHO	"Illegal bank address/segment location", 0
      3 U1c00				  -	      ERR
      4 U1c00					      ENDIF
      5 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6 U1c00				   _BANK_SLOT SET	0 * 64
     17 U1c00
     18 U1c00							;---------------------------------------------------------------------------------------------------
     19 U1c00							;#########################################  FIXED BANK  ############################################
     20 U1c00							;---------------------------------------------------------------------------------------------------
     21 U1c00
     22 U1c00				   _ORIGIN    SET	_FIRST_BANK
     23 U1c00
      0 U1c00					      NEWBANK	THE_FIRST_BANK
      1  0385 ????				      SEG	THE_FIRST_BANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   THE_FIRST_BANK_START SET	*
      6  0000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0000				   THE_FIRST_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + 1024
     25  0000					      RORG	$f000
     26  0000
     27  0000							;---------------------------------------------------------------------------------------------------
     28  0000
      0  0000					      DEF	StartupBankReset
      1  0000				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0000				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0000				   StartupBankReset
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartupBankReset
     30  0000					      SUBROUTINE
     31  0000
      0  0000					      VEND	StartupBankReset
      1  0000				  -	      IFNCONST	StartupBankReset
      2  0000				  -	      ECHO	"Incorrect VEND label", StartupBankReset
      3  0000				  -	      ERR
      4  0000					      ENDIF
      5  0000		       00 a4	   VAREND_StartupBankReset =	TEMPORARY_VAR
     33  0000
     34  0000							; On startup, 3E+ switches banks 0 and 3 to the 1st ROM bank (1K), from which the reset
     35  0000							; vector is obtained from bank 0 (+$FFC). Chess3E+ (maybe) will leave this bank (3) alone
     36  0000							; so that a system reset will always have the reset vectors available at FFFC, where expected
     37  0000
     38  0000		       a2 ff		      ldx	#$FF
     39  0002		       9a		      txs
     40  0003
      0  0003					      CALL	CartInit
      1  0003				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0003				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0003				  -	      ECHO	"Cannot switch bank in use for", CartInit
      4  0003				  -	      ERR
      5  0003					      ENDIF
      6  0003		       a9 41		      lda	#BANK_CartInit
      7  0005		       85 3f		      sta	SET_BANK
      8  0007		       20 00 f4 	      jsr	CartInit
      0  000a					      CALL	SetupBanks
      1  000a				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  000a				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  000a				  -	      ECHO	"Cannot switch bank in use for", SetupBanks
      4  000a				  -	      ERR
      5  000a					      ENDIF
      6  000a		       a9 41		      lda	#BANK_SetupBanks
      7  000c		       85 3f		      sta	SET_BANK
      8  000e		       20 3a f4 	      jsr	SetupBanks
      0  0011					      CALL	InitialisePieceSquares
      1  0011				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  0011				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0011				  -	      ECHO	"Cannot switch bank in use for", InitialisePieceSquares
      4  0011				  -	      ERR
      5  0011					      ENDIF
      6  0011		       a9 41		      lda	#BANK_InitialisePieceSquares
      7  0013		       85 3f		      sta	SET_BANK
      8  0015		       20 9a f4 	      jsr	InitialisePieceSquares
     44  0018		       20 30 f2 	      jsr	ListPlayerMoves	;@0
     45  001b
     46  001b
     47  001b				   .StartFrame
     48  001b
     49  001b
     50  001b							; START OF FRAME
     51  001b
     52  001b		       a9 0e		      lda	#%1110	; VSYNC ON
     53  001d		       85 42	   .loopVSync3 sta	WSYNC
     54  001f		       85 40		      sta	VSYNC
     55  0021		       4a		      lsr
     56  0022		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     57  0024
     58  0024		       85 41		      sta	VBLANK
     59  0026
     60  0026		       a0 2e		      ldy	#TIME_PART_1
     61  0028		       8c 96 02 	      sty	TIM64T
     62  002b
     63  002b							; LOTS OF PROCESSING TIME - USE IT
     64  002b
     65  002b
     66  002b
     67  002b		       20 78 f1 	      jsr	AiStateMachine
     68  002e
     69  002e				  -	      IF	ASSERTS
     70  002e				  -			; Catch timer expired already
     71  002e				  -			;		      bit TIMINT
     72  002e				  -			;.whoops	      bmi .whoops
     73  002e					      ENDIF
     74  002e
     75  002e
     76  002e		       2c 85 02    .wait      bit	TIMINT
     77  0031		       10 fb		      bpl	.wait
     78  0033
     79  0033
     80  0033							; START OF VISIBLE SCANLINES
     81  0033
     82  0033
      0  0033					      CALL	longD
      1  0033				  -	      IF	SLOT_longD == _BANK_SLOT
      2  0033				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0033				  -	      ECHO	"Cannot switch bank in use for", longD
      4  0033				  -	      ERR
      5  0033					      ENDIF
      6  0033		       a9 91		      lda	#BANK_longD
      7  0035		       85 3f		      sta	SET_BANK
      8  0037		       20 18 f8 	      jsr	longD
     84  003a
     85  003a
     86  003a		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     87  003c		       86 3e		      stx	SET_BANK_RAM
     88  003e		       20 03 f9 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     89  0041
      0  0041					      CALL	tidySc
      1  0041				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  0041				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0041				  -	      ECHO	"Cannot switch bank in use for", tidySc
      4  0041				  -	      ERR
      5  0041					      ENDIF
      6  0041		       a9 91		      lda	#BANK_tidySc
      7  0043		       85 3f		      sta	SET_BANK
      8  0045		       20 04 f8 	      jsr	tidySc
     91  0048
     92  0048		       20 78 f1 	      jsr	AiStateMachine
     93  004b
     94  004b		       ad 84 02 	      lda	INTIM
     95  004e		       c9 14		      cmp	#20
     96  0050		       90 24		      bcc	.notnow
     97  0052
     98  0052							;CALL GameSpeak
      0  0052					      CALL	PositionSprites
      1  0052				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  0052				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0052				  -	      ECHO	"Cannot switch bank in use for", PositionSprites
      4  0052				  -	      ERR
      5  0052					      ENDIF
      6  0052		       a9 47		      lda	#BANK_PositionSprites
      7  0054		       85 3f		      sta	SET_BANK
      8  0056		       20 00 f6 	      jsr	PositionSprites
    100  0059
    101  0059
    102  0059					      IF	1
    103  0059							; "draw" sprite shapes into row banks
    104  0059
    105  0059		       a2 07		      ldx	#7
    106  005b		       8a	   zapem      txa
    107  005c		       18		      clc
    108  005d		       69 80		      adc	#SLOT_DrawRow
    109  005f		       85 3e		      sta	SET_BANK_RAM
      0  0061					      CALL	WriteBlank	;@3
      1  0061				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  0061				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0061				  -	      ECHO	"Cannot switch bank in use for", WriteBlank
      4  0061				  -	      ERR
      5  0061					      ENDIF
      6  0061		       a9 c3		      lda	#BANK_WriteBlank
      7  0063		       85 3f		      sta	SET_BANK
      8  0065		       20 0b fc 	      jsr	WriteBlank
    111  0068		       ca		      dex
    112  0069		       10 f0		      bpl	zapem
    113  006b
    114  006b		       a9 c3		      lda	#BANK_WriteCursor
    115  006d		       85 3f		      sta	SET_BANK
      0  006f					      CALL	WriteCursor	;@3
      1  006f				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  006f				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  006f				  -	      ECHO	"Cannot switch bank in use for", WriteCursor
      4  006f				  -	      ERR
      5  006f					      ENDIF
      6  006f		       a9 c3		      lda	#BANK_WriteCursor
      7  0071		       85 3f		      sta	SET_BANK
      8  0073		       20 34 fc 	      jsr	WriteCursor
    117  0076					      ENDIF
    118  0076
    119  0076				   .notnow
    120  0076
    121  0076		       2c 85 02    .waitTime  bit	TIMINT
    122  0079		       10 fb		      bpl	.waitTime
    123  007b
    124  007b		       4c 1b f0 	      jmp	.StartFrame
    125  007e
    126  007e
    127  007e							;---------------------------------------------------------------------------------------------------
    128  007e
      0  007e					      DEF	ThinkBar
      1  007e				   SLOT_ThinkBar SET	_BANK_SLOT
      2  007e				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  007e				   ThinkBar
      4  007e				   TEMPORARY_VAR SET	Overlay
      5  007e				   TEMPORARY_OFFSET SET	0
      6  007e				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  007e				   FUNCTION_NAME SET	ThinkBar
    130  007e					      SUBROUTINE
    131  007e
      0  007e					      REFER	negaMax	;✅
      1  007e					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  007e				   TEMPORARY_VAR SET	VAREND_negaMax
      3  007e					      ENDIF
      0  007e					      REFER	quiesce	;✅
      1  007e				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  007e				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  007e					      ENDIF
      0  007e					      VEND	ThinkBar
      1  007e				  -	      IFNCONST	ThinkBar
      2  007e				  -	      ECHO	"Incorrect VEND label", ThinkBar
      3  007e				  -	      ERR
      4  007e					      ENDIF
      5  007e		       00 b0	   VAREND_ThinkBar =	TEMPORARY_VAR
    135  007e
    136  007e					      IF	DIAGNOSTICS
    137  007e
    138  007e		       e6 9e		      inc	positionCount
    139  0080		       d0 06		      bne	.p1
    140  0082		       e6 9f		      inc	positionCount+1
    141  0084		       d0 02		      bne	.p1
    142  0086		       e6 a0		      inc	positionCount+2
    143  0088				   .p1
    144  0088					      ENDIF
    145  0088
    146  0088							; The 'thinkbar' pattern...
    147  0088
    148  0088		       a9 00		      lda	#0
    149  008a		       a4 4c		      ldy	INPT4
    150  008c		       30 0f		      bmi	.doThink
    151  008e
    152  008e		       e6 a4		      inc	__thinkbar
    153  0090		       a5 a4		      lda	__thinkbar
    154  0092		       29 0f		      and	#15
    155  0094		       a8		      tay
    156  0095		       b9 a2 f0 	      lda	TBcol,y
    157  0098		       85 48		      sta	COLUPF
    158  009a
    159  009a		       b9 b2 f0 	      lda	SynapsePattern,y
    160  009d		       85 4f	   .doThink   sta	PF2
    161  009f		       85 4e		      sta	PF1
    162  00a1		       60		      rts
    163  00a2
    164  00a2
    165  00a2				   TBcol
    166  00a2				   .TBC       SET	2
    167  00a2					      REPEAT	16
    168  00a2		       02		      .byte.b	.TBC
    169  00a2				   .TBC       SET	.TBC + 16
    167  00a2					      REPEND
    168  00a3		       12		      .byte.b	.TBC
    169  00a3				   .TBC       SET	.TBC + 16
    167  00a3					      REPEND
    168  00a4		       22		      .byte.b	.TBC
    169  00a4				   .TBC       SET	.TBC + 16
    167  00a4					      REPEND
    168  00a5		       32		      .byte.b	.TBC
    169  00a5				   .TBC       SET	.TBC + 16
    167  00a5					      REPEND
    168  00a6		       42		      .byte.b	.TBC
    169  00a6				   .TBC       SET	.TBC + 16
    167  00a6					      REPEND
    168  00a7		       52		      .byte.b	.TBC
    169  00a7				   .TBC       SET	.TBC + 16
    167  00a7					      REPEND
    168  00a8		       62		      .byte.b	.TBC
    169  00a8				   .TBC       SET	.TBC + 16
    167  00a8					      REPEND
    168  00a9		       72		      .byte.b	.TBC
    169  00a9				   .TBC       SET	.TBC + 16
    167  00a9					      REPEND
    168  00aa		       82		      .byte.b	.TBC
    169  00aa				   .TBC       SET	.TBC + 16
    167  00aa					      REPEND
    168  00ab		       92		      .byte.b	.TBC
    169  00ab				   .TBC       SET	.TBC + 16
    167  00ab					      REPEND
    168  00ac		       a2		      .byte.b	.TBC
    169  00ac				   .TBC       SET	.TBC + 16
    167  00ac					      REPEND
    168  00ad		       b2		      .byte.b	.TBC
    169  00ad				   .TBC       SET	.TBC + 16
    167  00ad					      REPEND
    168  00ae		       c2		      .byte.b	.TBC
    169  00ae				   .TBC       SET	.TBC + 16
    167  00ae					      REPEND
    168  00af		       d2		      .byte.b	.TBC
    169  00af				   .TBC       SET	.TBC + 16
    167  00af					      REPEND
    168  00b0		       e2		      .byte.b	.TBC
    169  00b0				   .TBC       SET	.TBC + 16
    167  00b0					      REPEND
    168  00b1		       f2		      .byte.b	.TBC
    169  00b1				   .TBC       SET	.TBC + 16
    170  00b2					      REPEND
    171  00b2
    172  00b2				   SynapsePattern
    173  00b2
    174  00b2		       c1		      .byte.b	%11000001
    175  00b3		       60		      .byte.b	%01100000
    176  00b4		       30		      .byte.b	%00110000
    177  00b5		       18		      .byte.b	%00011000
    178  00b6		       0c		      .byte.b	%00001100
    179  00b7		       06		      .byte.b	%00000110
    180  00b8		       83		      .byte.b	%10000011
    181  00b9		       c1		      .byte.b	%11000001
    182  00ba
    183  00ba		       83		      .byte.b	%10000011
    184  00bb		       06		      .byte.b	%00000110
    185  00bc		       0c		      .byte.b	%00001100
    186  00bd		       18		      .byte.b	%00011000
    187  00be		       30		      .byte.b	%00110000
    188  00bf		       60		      .byte.b	%01100000
    189  00c0		       c1		      .byte.b	%11000001
    190  00c1		       83		      .byte.b	%10000011
    191  00c2
    192  00c2
    193  00c2							;---------------------------------------------------------------------------------------------------
    194  00c2
      0  00c2					      DEF	CopySinglePiece
      1  00c2				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  00c2				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  00c2				   CopySinglePiece
      4  00c2				   TEMPORARY_VAR SET	Overlay
      5  00c2				   TEMPORARY_OFFSET SET	0
      6  00c2				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  00c2				   FUNCTION_NAME SET	CopySinglePiece
    196  00c2					      SUBROUTINE
    197  00c2
      0  00c2					      TIMING	COPYSINGLEPIECE, (2600)
      1  00c2		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    199  00c2
      0  00c2					      REFER	showMoveCaptures	;✅
      1  00c2					      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  00c2				   TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  00c2					      ENDIF
      0  00c2					      REFER	aiDrawEntireBoard	;✅
      1  00c2				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  00c2					      ENDIF
      0  00c2					      REFER	aiDrawPart2	;✅
      1  00c2				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  00c2					      ENDIF
      0  00c2					      REFER	aiMarchB	;✅
      1  00c2				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  00c2					      ENDIF
      0  00c2					      REFER	aiFlashComputerMove	;✅
      1  00c2				  -	      IF	VAREND_aiFlashComputerMove > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiFlashComputerMove
      3  00c2					      ENDIF
      0  00c2					      REFER	aiSelectDestinationSquare	;✅
      1  00c2				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  00c2					      ENDIF
      0  00c2					      REFER	aiMarchA2	;✅
      1  00c2				  -	      IF	VAREND_aiMarchA2 > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiMarchA2
      3  00c2					      ENDIF
      0  00c2					      REFER	aiMarchB2	;✅
      1  00c2				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  00c2					      ENDIF
      0  00c2					      REFER	aiWriteStartPieceBlank	;✅
      1  00c2				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  00c2					      ENDIF
      0  00c2					      REFER	aiChoosePromotePiece	;✅
      1  00c2				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  00c2					      ENDIF
      0  00c2					      REFER	aiMarchToTargetB	;✅
      1  00c2				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  00c2					      ENDIF
      0  00c2					      REFER	aiPromotePawnStart	;✅
      1  00c2				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  00c2					      ENDIF
      0  00c2					      REFER	aiFinalFlash	;✅
      1  00c2				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  00c2				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  00c2					      ENDIF
    213  00c2
    214  00c2				  -	      IF	ENPASSANT_ENABLED
    215  00c2				  -	      REFER	EnPassantCheck	;✅
    216  00c2					      ENDIF
    217  00c2
      0  00c2					      VEND	CopySinglePiece
      1  00c2				  -	      IFNCONST	CopySinglePiece
      2  00c2				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  00c2				  -	      ERR
      4  00c2					      ENDIF
      5  00c2		       00 a7	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    219  00c2
    220  00c2							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    221  00c2							; ALSO CAN'T USE IN THIS ROUTINE
    222  00c2							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    223  00c2							; @2150 max
    224  00c2							; = 33 TIM64T
    225  00c2
    226  00c2							; Board is [SLOT3]
    227  00c2
    228  00c2
      0  00c2					      CALL	CopySetup	;@2
      1  00c2				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  00c2				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  00c2				  -	      ECHO	"Cannot switch bank in use for", CopySetup
      4  00c2				  -	      ERR
      5  00c2					      ENDIF
      6  00c2		       a9 91		      lda	#BANK_CopySetup
      7  00c4		       85 3f		      sta	SET_BANK
      8  00c6		       20 58 f8 	      jsr	CopySetup
    230  00c9
    231  00c9
      0  00c9					      DEF	InterceptMarkerCopy
      1  00c9				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  00c9				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  00c9				   InterceptMarkerCopy
      4  00c9				   TEMPORARY_VAR SET	Overlay
      5  00c9				   TEMPORARY_OFFSET SET	0
      6  00c9				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  00c9				   FUNCTION_NAME SET	InterceptMarkerCopy
    233  00c9					      SUBROUTINE
    234  00c9
      0  00c9					      REFER	CopySinglePiece	;✅✅
      1  00c9					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  00c9				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  00c9					      ENDIF
      0  00c9					      REFER	showPromoteOptions	;✅
      1  00c9				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  00c9				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  00c9					      ENDIF
      0  00c9					      REFER	showMoveOptions	;✅
      1  00c9				  -	      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  00c9				  -TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  00c9					      ENDIF
    238  00c9
      0  00c9					      VEND	InterceptMarkerCopy
      1  00c9				  -	      IFNCONST	InterceptMarkerCopy
      2  00c9				  -	      ECHO	"Incorrect VEND label", InterceptMarkerCopy
      3  00c9				  -	      ERR
      4  00c9					      ENDIF
      5  00c9		       00 a7	   VAREND_InterceptMarkerCopy =	TEMPORARY_VAR
    240  00c9
    241  00c9							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    242  00c9							; y = piece index
    243  00c9
    244  00c9		       a9 91		      lda	#BANK_PIECE_VECTOR_BANK
    245  00cb		       85 3f		      sta	SET_BANK	;@2
    246  00cd
    247  00cd		       b9 63 f9 	      lda	PIECE_VECTOR_LO,y
    248  00d0		       85 ec		      sta	__ptr
    249  00d2		       b9 f3 f9 	      lda	PIECE_VECTOR_HI,y
    250  00d5		       85 ed		      sta	__ptr+1
    251  00d7		       b9 83 fa 	      lda	PIECE_VECTOR_BANK,y
    252  00da		       85 3f		      sta	SET_BANK	;@2
    253  00dc
    254  00dc		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    255  00de		       b1 ec	   .copy      lda	(__ptr),y
    256  00e0		       99 a4 00 	      sta	__pieceShapeBuffer,y
    257  00e3		       88		      dey
    258  00e4		       10 f8		      bpl	.copy
    259  00e6
    260  00e6		       a5 80		      lda	squareToDraw
    261  00e8		       38		      sec
    262  00e9		       a2 0a		      ldx	#10
    263  00eb		       e9 0a	   .sub10     sbc	#10
    264  00ed		       ca		      dex
    265  00ee		       b0 fb		      bcs	.sub10
    266  00f0
    267  00f0		       69 08		      adc	#8
    268  00f2		       c9 04		      cmp	#4	; CS = right side of screen
    269  00f4
    270  00f4		       8a		      txa
    271  00f5		       09 80		      ora	#[SLOT2]
    272  00f7		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    273  00f9
    274  00f9		       20 21 f3 	      jsr	CopyPieceToRowBitmap	;@3
    275  00fc		       60		      rts
    276  00fd
    277  00fd
    278  00fd							;---------------------------------------------------------------------------------------------------
    279  00fd
    280  00fd				   P	      SET	0
    281  00fd					      MAC	ain
    282  00fd				   AI_{1}     SET	P
    283  00fd				   P	      SET	P+1
    284  00fd					      ENDM
    285  00fd
    286  00fd					      MAC	lo
    287  00fd					      .byte	<ai{1}
    288  00fd					      ENDM
    289  00fd
    290  00fd					      MAC	hi
    291  00fd					      .byte	>ai{1}
    292  00fd					      ENDM
    293  00fd
    294  00fd					      MAC	bk
    295  00fd					      .byte	BANK_ai{1}
    296  00fd					      ENDM
    297  00fd
    298  00fd
    299  00fd		       00 28	   ONCEPERFRAME =	40
    300  00fd
    301  00fd					      MAC	tabdef
    302  00fd
    303  00fd					      {1}	FlashComputerMove	; 0
    304  00fd					      {1}	BeginSelectMovePhase	; 1
    305  00fd					      {1}	SelectStartSquare	; 2
    306  00fd					      {1}	StartSquareSelected	; 3
    307  00fd					      {1}	DrawMoves	; 4
    308  00fd					      {1}	ShowMoveCaptures	; 5
    309  00fd					      {1}	SlowFlash	; 6
    310  00fd					      {1}	UnDrawTargetSquares	; 7
    311  00fd					      {1}	SelectDestinationSquare	; 8
    312  00fd					      {1}	Quiescent	; 9
    313  00fd					      {1}	ReselectDebounce	; 10
    314  00fd					      {1}	StartMoveGen	; 11
    315  00fd					      {1}	StepMoveGen	; 12
    316  00fd					      {1}	StartClearBoard	; 13
    317  00fd					      {1}	ClearEachRow	; 14
    318  00fd					      {1}	DrawEntireBoard	; 15
    319  00fd					      {1}	DrawPart2	; 16
    320  00fd					      {1}	DrawPart3	; 17
    321  00fd					      {1}	GenerateMoves	; 18
    322  00fd					      {1}	ComputerMove	; 19
    323  00fd					      {1}	MoveIsSelected	; 20
    324  00fd					      {1}	WriteStartPieceBlank	; 21
    325  00fd					      {1}	MarchToTargetA	; 22
    326  00fd					      {1}	MarchA2	; 23
    327  00fd					      {1}	MarchB	; 24
    328  00fd					      {1}	MarchToTargetB	; 25
    329  00fd					      {1}	MarchB2	; 26
    330  00fd					      {1}	FinalFlash	; 27
    331  00fd					      {1}	SpecialMoveFixup	; 28
    332  00fd					      {1}	InCheckBackup	; 29
    333  00fd					      {1}	InCheckDelay	; 30
    334  00fd					      {1}	PromotePawnStart	; 31
    335  00fd					      {1}	RollPromotionPiece	; 32
    336  00fd					      {1}	ChoosePromotePiece	; 33
    337  00fd					      {1}	ChooseDebounce	; 34
    338  00fd					      {1}	CheckMate	; 35
    339  00fd					      {1}	Draw	; 36
    340  00fd					      {1}	DelayAfterMove	; 37
    341  00fd					      {1}	DelayAfterMove2	; 38
    342  00fd					      {1}	DelayAfterPlaced	; 39
    343  00fd					      {1}	DelayAfterPlaced2	; 40
    344  00fd
    345  00fd					      ENDM		; {1} = macro to use
    346  00fd
      0  00fd					      TABDEF	AIN
      1  00fd
      0  00fd					      AIN	FlashComputerMove
      1  00fd				   AI_FlashComputerMove SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	BeginSelectMovePhase
      1  00fd				   AI_BeginSelectMovePhase SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	SelectStartSquare
      1  00fd				   AI_SelectStartSquare SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	StartSquareSelected
      1  00fd				   AI_StartSquareSelected SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	DrawMoves
      1  00fd				   AI_DrawMoves SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	ShowMoveCaptures
      1  00fd				   AI_ShowMoveCaptures SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	SlowFlash
      1  00fd				   AI_SlowFlash SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	UnDrawTargetSquares
      1  00fd				   AI_UnDrawTargetSquares SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	SelectDestinationSquare
      1  00fd				   AI_SelectDestinationSquare SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	Quiescent
      1  00fd				   AI_Quiescent SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	ReselectDebounce
      1  00fd				   AI_ReselectDebounce SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	StartMoveGen
      1  00fd				   AI_StartMoveGen SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	StepMoveGen
      1  00fd				   AI_StepMoveGen SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	StartClearBoard
      1  00fd				   AI_StartClearBoard SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	ClearEachRow
      1  00fd				   AI_ClearEachRow SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	DrawEntireBoard
      1  00fd				   AI_DrawEntireBoard SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	DrawPart2
      1  00fd				   AI_DrawPart2 SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	DrawPart3
      1  00fd				   AI_DrawPart3 SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	GenerateMoves
      1  00fd				   AI_GenerateMoves SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	ComputerMove
      1  00fd				   AI_ComputerMove SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	MoveIsSelected
      1  00fd				   AI_MoveIsSelected SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	WriteStartPieceBlank
      1  00fd				   AI_WriteStartPieceBlank SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	MarchToTargetA
      1  00fd				   AI_MarchToTargetA SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	MarchA2
      1  00fd				   AI_MarchA2 SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	MarchB
      1  00fd				   AI_MarchB  SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	MarchToTargetB
      1  00fd				   AI_MarchToTargetB SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	MarchB2
      1  00fd				   AI_MarchB2 SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	FinalFlash
      1  00fd				   AI_FinalFlash SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	SpecialMoveFixup
      1  00fd				   AI_SpecialMoveFixup SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	InCheckBackup
      1  00fd				   AI_InCheckBackup SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	InCheckDelay
      1  00fd				   AI_InCheckDelay SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	PromotePawnStart
      1  00fd				   AI_PromotePawnStart SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	RollPromotionPiece
      1  00fd				   AI_RollPromotionPiece SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	ChoosePromotePiece
      1  00fd				   AI_ChoosePromotePiece SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	ChooseDebounce
      1  00fd				   AI_ChooseDebounce SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	CheckMate
      1  00fd				   AI_CheckMate SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	Draw
      1  00fd				   AI_Draw    SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	DelayAfterMove
      1  00fd				   AI_DelayAfterMove SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	DelayAfterMove2
      1  00fd				   AI_DelayAfterMove2 SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	DelayAfterPlaced
      1  00fd				   AI_DelayAfterPlaced SET	P
      2  00fd				   P	      SET	P+1
      0  00fd					      AIN	DelayAfterPlaced2
      1  00fd				   AI_DelayAfterPlaced2 SET	P
      2  00fd				   P	      SET	P+1
     43  00fd
    348  00fd
      0  00fd					      DEF	AiVectorLO
      1  00fd				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  00fd				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  00fd				   AiVectorLO
      4  00fd				   TEMPORARY_VAR SET	Overlay
      5  00fd				   TEMPORARY_OFFSET SET	0
      6  00fd				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  00fd				   FUNCTION_NAME SET	AiVectorLO
      0  00fd					      TABDEF	LO
      1  00fd
      0  00fd					      LO	FlashComputerMove
      1  00fd		       3c		      .byte.b	<aiFlashComputerMove
      0  00fe					      LO	BeginSelectMovePhase
      1  00fe		       1d		      .byte.b	<aiBeginSelectMovePhase
      0  00ff					      LO	SelectStartSquare
      1  00ff		       64		      .byte.b	<aiSelectStartSquare
      0  0100					      LO	StartSquareSelected
      1  0100		       e4		      .byte.b	<aiStartSquareSelected
      0  0101					      LO	DrawMoves
      1  0101		       ff		      .byte.b	<aiDrawMoves
      0  0102					      LO	ShowMoveCaptures
      1  0102		       e2		      .byte.b	<aiShowMoveCaptures
      0  0103					      LO	SlowFlash
      1  0103		       04		      .byte.b	<aiSlowFlash
      0  0104					      LO	UnDrawTargetSquares
      1  0104		       bc		      .byte.b	<aiUnDrawTargetSquares
      0  0105					      LO	SelectDestinationSquare
      1  0105		       5b		      .byte.b	<aiSelectDestinationSquare
      0  0106					      LO	Quiescent
      1  0106		       bd		      .byte.b	<aiQuiescent
      0  0107					      LO	ReselectDebounce
      1  0107		       b4		      .byte.b	<aiReselectDebounce
      0  0108					      LO	StartMoveGen
      1  0108		       00		      .byte.b	<aiStartMoveGen
      0  0109					      LO	StepMoveGen
      1  0109		       fc		      .byte.b	<aiStepMoveGen
      0  010a					      LO	StartClearBoard
      1  010a		       2c		      .byte.b	<aiStartClearBoard
      0  010b					      LO	ClearEachRow
      1  010b		       39		      .byte.b	<aiClearEachRow
      0  010c					      LO	DrawEntireBoard
      1  010c		       15		      .byte.b	<aiDrawEntireBoard
      0  010d					      LO	DrawPart2
      1  010d		       49		      .byte.b	<aiDrawPart2
      0  010e					      LO	DrawPart3
      1  010e		       4c		      .byte.b	<aiDrawPart3
      0  010f					      LO	GenerateMoves
      1  010f		       ea		      .byte.b	<aiGenerateMoves
      0  0110					      LO	ComputerMove
      1  0110		       00		      .byte.b	<aiComputerMove
      0  0111					      LO	MoveIsSelected
      1  0111		       46		      .byte.b	<aiMoveIsSelected
      0  0112					      LO	WriteStartPieceBlank
      1  0112		       84		      .byte.b	<aiWriteStartPieceBlank
      0  0113					      LO	MarchToTargetA
      1  0113		       38		      .byte.b	<aiMarchToTargetA
      0  0114					      LO	MarchA2
      1  0114		       2b		      .byte.b	<aiMarchA2
      0  0115					      LO	MarchB
      1  0115		       66		      .byte.b	<aiMarchB
      0  0116					      LO	MarchToTargetB
      1  0116		       ab		      .byte.b	<aiMarchToTargetB
      0  0117					      LO	MarchB2
      1  0117		       58		      .byte.b	<aiMarchB2
      0  0118					      LO	FinalFlash
      1  0118		       87		      .byte.b	<aiFinalFlash
      0  0119					      LO	SpecialMoveFixup
      1  0119		       dc		      .byte.b	<aiSpecialMoveFixup
      0  011a					      LO	InCheckBackup
      1  011a		       05		      .byte.b	<aiInCheckBackup
      0  011b					      LO	InCheckDelay
      1  011b		       10		      .byte.b	<aiInCheckDelay
      0  011c					      LO	PromotePawnStart
      1  011c		       c6		      .byte.b	<aiPromotePawnStart
      0  011d					      LO	RollPromotionPiece
      1  011d		       e5		      .byte.b	<aiRollPromotionPiece
      0  011e					      LO	ChoosePromotePiece
      1  011e		       00		      .byte.b	<aiChoosePromotePiece
      0  011f					      LO	ChooseDebounce
      1  011f		       6f		      .byte.b	<aiChooseDebounce
      0  0120					      LO	CheckMate
      1  0120		       7b		      .byte.b	<aiCheckMate
      0  0121					      LO	Draw
      1  0121		       76		      .byte.b	<aiDraw
      0  0122					      LO	DelayAfterMove
      1  0122		       81		      .byte.b	<aiDelayAfterMove
      0  0123					      LO	DelayAfterMove2
      1  0123		       8a		      .byte.b	<aiDelayAfterMove2
      0  0124					      LO	DelayAfterPlaced
      1  0124		       93		      .byte.b	<aiDelayAfterPlaced
      0  0125					      LO	DelayAfterPlaced2
      1  0125		       a2		      .byte.b	<aiDelayAfterPlaced2
     43  0126
    351  0126
      0  0126					      DEF	AiVectorHI
      1  0126				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  0126				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  0126				   AiVectorHI
      4  0126				   TEMPORARY_VAR SET	Overlay
      5  0126				   TEMPORARY_OFFSET SET	0
      6  0126				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  0126				   FUNCTION_NAME SET	AiVectorHI
      0  0126					      TABDEF	HI
      1  0126
      0  0126					      HI	FlashComputerMove
      1  0126		       f4		      .byte.b	>aiFlashComputerMove
      0  0127					      HI	BeginSelectMovePhase
      1  0127		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0128					      HI	SelectStartSquare
      1  0128		       f4		      .byte.b	>aiSelectStartSquare
      0  0129					      HI	StartSquareSelected
      1  0129		       f4		      .byte.b	>aiStartSquareSelected
      0  012a					      HI	DrawMoves
      1  012a		       f4		      .byte.b	>aiDrawMoves
      0  012b					      HI	ShowMoveCaptures
      1  012b		       f5		      .byte.b	>aiShowMoveCaptures
      0  012c					      HI	SlowFlash
      1  012c		       f6		      .byte.b	>aiSlowFlash
      0  012d					      HI	UnDrawTargetSquares
      1  012d		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  012e					      HI	SelectDestinationSquare
      1  012e		       f6		      .byte.b	>aiSelectDestinationSquare
      0  012f					      HI	Quiescent
      1  012f		       f6		      .byte.b	>aiQuiescent
      0  0130					      HI	ReselectDebounce
      1  0130		       f6		      .byte.b	>aiReselectDebounce
      0  0131					      HI	StartMoveGen
      1  0131		       f4		      .byte.b	>aiStartMoveGen
      0  0132					      HI	StepMoveGen
      1  0132		       f4		      .byte.b	>aiStepMoveGen
      0  0133					      HI	StartClearBoard
      1  0133		       f8		      .byte.b	>aiStartClearBoard
      0  0134					      HI	ClearEachRow
      1  0134		       f8		      .byte.b	>aiClearEachRow
      0  0135					      HI	DrawEntireBoard
      1  0135		       f6		      .byte.b	>aiDrawEntireBoard
      0  0136					      HI	DrawPart2
      1  0136		       f6		      .byte.b	>aiDrawPart2
      0  0137					      HI	DrawPart3
      1  0137		       f6		      .byte.b	>aiDrawPart3
      0  0138					      HI	GenerateMoves
      1  0138		       f4		      .byte.b	>aiGenerateMoves
      0  0139					      HI	ComputerMove
      1  0139		       f4		      .byte.b	>aiComputerMove
      0  013a					      HI	MoveIsSelected
      1  013a		       f8		      .byte.b	>aiMoveIsSelected
      0  013b					      HI	WriteStartPieceBlank
      1  013b		       f7		      .byte.b	>aiWriteStartPieceBlank
      0  013c					      HI	MarchToTargetA
      1  013c		       f6		      .byte.b	>aiMarchToTargetA
      0  013d					      HI	MarchA2
      1  013d		       f7		      .byte.b	>aiMarchA2
      0  013e					      HI	MarchB
      1  013e		       f6		      .byte.b	>aiMarchB
      0  013f					      HI	MarchToTargetB
      1  013f		       f4		      .byte.b	>aiMarchToTargetB
      0  0140					      HI	MarchB2
      1  0140		       f7		      .byte.b	>aiMarchB2
      0  0141					      HI	FinalFlash
      1  0141		       f6		      .byte.b	>aiFinalFlash
      0  0142					      HI	SpecialMoveFixup
      1  0142		       f5		      .byte.b	>aiSpecialMoveFixup
      0  0143					      HI	InCheckBackup
      1  0143		       f4		      .byte.b	>aiInCheckBackup
      0  0144					      HI	InCheckDelay
      1  0144		       f4		      .byte.b	>aiInCheckDelay
      0  0145					      HI	PromotePawnStart
      1  0145		       f4		      .byte.b	>aiPromotePawnStart
      0  0146					      HI	RollPromotionPiece
      1  0146		       f6		      .byte.b	>aiRollPromotionPiece
      0  0147					      HI	ChoosePromotePiece
      1  0147		       f4		      .byte.b	>aiChoosePromotePiece
      0  0148					      HI	ChooseDebounce
      1  0148		       f4		      .byte.b	>aiChooseDebounce
      0  0149					      HI	CheckMate
      1  0149		       f6		      .byte.b	>aiCheckMate
      0  014a					      HI	Draw
      1  014a		       f6		      .byte.b	>aiDraw
      0  014b					      HI	DelayAfterMove
      1  014b		       f4		      .byte.b	>aiDelayAfterMove
      0  014c					      HI	DelayAfterMove2
      1  014c		       f4		      .byte.b	>aiDelayAfterMove2
      0  014d					      HI	DelayAfterPlaced
      1  014d		       f4		      .byte.b	>aiDelayAfterPlaced
      0  014e					      HI	DelayAfterPlaced2
      1  014e		       f4		      .byte.b	>aiDelayAfterPlaced2
     43  014f
    354  014f
      0  014f					      DEF	AiVectorBANK
      1  014f				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  014f				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  014f				   AiVectorBANK
      4  014f				   TEMPORARY_VAR SET	Overlay
      5  014f				   TEMPORARY_OFFSET SET	0
      6  014f				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  014f				   FUNCTION_NAME SET	AiVectorBANK
      0  014f					      TABDEF	BK
      1  014f
      0  014f					      BK	FlashComputerMove
      1  014f		       46		      .byte.b	BANK_aiFlashComputerMove
      0  0150					      BK	BeginSelectMovePhase
      1  0150		       46		      .byte.b	BANK_aiBeginSelectMovePhase
      0  0151					      BK	SelectStartSquare
      1  0151		       46		      .byte.b	BANK_aiSelectStartSquare
      0  0152					      BK	StartSquareSelected
      1  0152		       46		      .byte.b	BANK_aiStartSquareSelected
      0  0153					      BK	DrawMoves
      1  0153		       46		      .byte.b	BANK_aiDrawMoves
      0  0154					      BK	ShowMoveCaptures
      1  0154		       46		      .byte.b	BANK_aiShowMoveCaptures
      0  0155					      BK	SlowFlash
      1  0155		       46		      .byte.b	BANK_aiSlowFlash
      0  0156					      BK	UnDrawTargetSquares
      1  0156		       46		      .byte.b	BANK_aiUnDrawTargetSquares
      0  0157					      BK	SelectDestinationSquare
      1  0157		       46		      .byte.b	BANK_aiSelectDestinationSquare
      0  0158					      BK	Quiescent
      1  0158		       46		      .byte.b	BANK_aiQuiescent
      0  0159					      BK	ReselectDebounce
      1  0159		       46		      .byte.b	BANK_aiReselectDebounce
      0  015a					      BK	StartMoveGen
      1  015a		       46		      .byte.b	BANK_aiStartMoveGen
      0  015b					      BK	StepMoveGen
      1  015b		       47		      .byte.b	BANK_aiStepMoveGen
      0  015c					      BK	StartClearBoard
      1  015c		       91		      .byte.b	BANK_aiStartClearBoard
      0  015d					      BK	ClearEachRow
      1  015d		       91		      .byte.b	BANK_aiClearEachRow
      0  015e					      BK	DrawEntireBoard
      1  015e		       41		      .byte.b	BANK_aiDrawEntireBoard
      0  015f					      BK	DrawPart2
      1  015f		       41		      .byte.b	BANK_aiDrawPart2
      0  0160					      BK	DrawPart3
      1  0160		       41		      .byte.b	BANK_aiDrawPart3
      0  0161					      BK	GenerateMoves
      1  0161		       47		      .byte.b	BANK_aiGenerateMoves
      0  0162					      BK	ComputerMove
      1  0162		       56		      .byte.b	BANK_aiComputerMove
      0  0163					      BK	MoveIsSelected
      1  0163		       91		      .byte.b	BANK_aiMoveIsSelected
      0  0164					      BK	WriteStartPieceBlank
      1  0164		       46		      .byte.b	BANK_aiWriteStartPieceBlank
      0  0165					      BK	MarchToTargetA
      1  0165		       47		      .byte.b	BANK_aiMarchToTargetA
      0  0166					      BK	MarchA2
      1  0166		       46		      .byte.b	BANK_aiMarchA2
      0  0167					      BK	MarchB
      1  0167		       41		      .byte.b	BANK_aiMarchB
      0  0168					      BK	MarchToTargetB
      1  0168		       47		      .byte.b	BANK_aiMarchToTargetB
      0  0169					      BK	MarchB2
      1  0169		       46		      .byte.b	BANK_aiMarchB2
      0  016a					      BK	FinalFlash
      1  016a		       47		      .byte.b	BANK_aiFinalFlash
      0  016b					      BK	SpecialMoveFixup
      1  016b		       41		      .byte.b	BANK_aiSpecialMoveFixup
      0  016c					      BK	InCheckBackup
      1  016c		       46		      .byte.b	BANK_aiInCheckBackup
      0  016d					      BK	InCheckDelay
      1  016d		       46		      .byte.b	BANK_aiInCheckDelay
      0  016e					      BK	PromotePawnStart
      1  016e		       47		      .byte.b	BANK_aiPromotePawnStart
      0  016f					      BK	RollPromotionPiece
      1  016f		       46		      .byte.b	BANK_aiRollPromotionPiece
      0  0170					      BK	ChoosePromotePiece
      1  0170		       47		      .byte.b	BANK_aiChoosePromotePiece
      0  0171					      BK	ChooseDebounce
      1  0171		       47		      .byte.b	BANK_aiChooseDebounce
      0  0172					      BK	CheckMate
      1  0172		       41		      .byte.b	BANK_aiCheckMate
      0  0173					      BK	Draw
      1  0173		       41		      .byte.b	BANK_aiDraw
      0  0174					      BK	DelayAfterMove
      1  0174		       47		      .byte.b	BANK_aiDelayAfterMove
      0  0175					      BK	DelayAfterMove2
      1  0175		       47		      .byte.b	BANK_aiDelayAfterMove2
      0  0176					      BK	DelayAfterPlaced
      1  0176		       47		      .byte.b	BANK_aiDelayAfterPlaced
      0  0177					      BK	DelayAfterPlaced2
      1  0177		       47		      .byte.b	BANK_aiDelayAfterPlaced2
     43  0178
    357  0178
    358  0178
    359  0178							;---------------------------------------------------------------------------------------------------
    360  0178
      0  0178					      DEF	AiStateMachine
      1  0178				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0178				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0178				   AiStateMachine
      4  0178				   TEMPORARY_VAR SET	Overlay
      5  0178				   TEMPORARY_OFFSET SET	0
      6  0178				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0178				   FUNCTION_NAME SET	AiStateMachine
    362  0178					      SUBROUTINE
    363  0178
      0  0178					      REFER	StartupBankReset	;✅
      1  0178				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0178				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0178					      ENDIF
      0  0178					      VEND	AiStateMachine
      1  0178				  -	      IFNCONST	AiStateMachine
      2  0178				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  0178				  -	      ERR
      4  0178					      ENDIF
      5  0178		       00 a4	   VAREND_AiStateMachine =	TEMPORARY_VAR
    366  0178
    367  0178
    368  0178							; State machine vector setup - points to current routine to execute
    369  0178
    370  0178		       a6 8b		      ldx	aiState
    371  017a		       bd fd f0 	      lda	AiVectorLO,x
    372  017d		       85 ec		      sta	__ptr
    373  017f		       bd 26 f1 	      lda	AiVectorHI,x
    374  0182		       85 ed		      sta	__ptr+1
    375  0184
    376  0184		       bd 4f f1 	      lda	AiVectorBANK,x
    377  0187		       85 3f		      sta	SET_BANK
    378  0189		       6c ec 00 	      jmp	(__ptr)	; NOTE: could branch back to squeeze cycles
    379  018c
    380  018c
    381  018c							;---------------------------------------------------------------------------------------------------
    382  018c
      0  018c					      DEF	GenerateAllMoves
      1  018c				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  018c				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  018c				   GenerateAllMoves
      4  018c				   TEMPORARY_VAR SET	Overlay
      5  018c				   TEMPORARY_OFFSET SET	0
      6  018c				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  018c				   FUNCTION_NAME SET	GenerateAllMoves
    384  018c					      SUBROUTINE
    385  018c
      0  018c					      REFER	ListPlayerMoves	;✅
      1  018c					      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  018c				   TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  018c					      ENDIF
      0  018c					      REFER	aiComputerMove	;✅
      1  018c				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  018c				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  018c					      ENDIF
      0  018c					      REFER	quiesce	;✅
      1  018c				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  018c				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  018c					      ENDIF
      0  018c					      REFER	negaMax	;✅
      1  018c				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  018c				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  018c					      ENDIF
    390  018c
      0  018c					      VAR	__vector, 2
      1  018c		       00 b0	   __vector   =	TEMPORARY_VAR
      2  018c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  018c
      4  018c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  018c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  018c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  018c					      ENDIF
      8  018c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  018c				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  018c				  -	      ERR
     11  018c					      ENDIF
     12  018c					      LIST	ON
      0  018c					      VAR	__masker, 2
      1  018c		       00 b2	   __masker   =	TEMPORARY_VAR
      2  018c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  018c
      4  018c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  018c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  018c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  018c					      ENDIF
      8  018c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  018c				  -	      ECHO	"Temporary Variable", __masker, "overflow!"
     10  018c				  -	      ERR
     11  018c					      ENDIF
     12  018c					      LIST	ON
      0  018c					      VAR	__pieceFilter, 1
      1  018c		       00 b4	   __pieceFilter =	TEMPORARY_VAR
      2  018c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  018c
      4  018c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  018c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  018c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  018c					      ENDIF
      8  018c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  018c				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  018c				  -	      ERR
     11  018c					      ENDIF
     12  018c					      LIST	ON
    394  018c
      0  018c					      VEND	GenerateAllMoves
      1  018c				  -	      IFNCONST	GenerateAllMoves
      2  018c				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  018c				  -	      ERR
      4  018c					      ENDIF
      5  018c		       00 b5	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    396  018c
    397  018c							; Do the move generation in two passes - pawns then pieces
    398  018c							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    399  018c
    400  018c							;...
    401  018c							; This MUST be called at the start of a new ply
    402  018c							; It initialises the movelist to empty
    403  018c							; x must be preserved
    404  018c
    405  018c		       a5 94		      lda	currentPly
    406  018e		       85 3e		      sta	SET_BANK_RAM	;@2
    407  0190
    408  0190							; note that 'alpha' and 'beta' are set externally!!
    409  0190
    410  0190		       a9 ff		      lda	#-1
      0  0192					      sta@PLY	moveIndex	; no valid moves
      1  0192		       8d d0 fb 	      sta	[RAM]+moveIndex
      0  0195					      sta@PLY	bestMove
      1  0195		       8d d2 fb 	      sta	[RAM]+bestMove
    413  0198
    414  0198		       a5 93		      lda	enPassantPawn	; flag/square from last actual move made
      0  019a					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  019a		       8d ca fb 	      sta	[RAM]+enPassantSquare
    416  019d
    417  019d
    418  019d							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    419  019d							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    420  019d							; start of each new ply.
    421  019d
    422  019d		       a5 8f		      lda	Evaluation
      0  019f					      sta@PLY	savedEvaluation
      1  019f		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    424  01a2		       a5 90		      lda	Evaluation+1
      0  01a4					      sta@PLY	savedEvaluation+1
      1  01a4		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    426  01a7							;^
    427  01a7
    428  01a7
    429  01a7
    430  01a7		       a9 08		      lda	#8	; pawns
    431  01a9		       85 b4		      sta	__pieceFilter
    432  01ab		       20 c0 f1 	      jsr	MoveGenX
    433  01ae		       a9 63		      lda	#99
    434  01b0		       85 92		      sta	currentSquare
    435  01b2		       a9 00		      lda	#0
    436  01b4		       85 b4		      sta	__pieceFilter
    437  01b6		       20 c0 f1 	      jsr	MoveGenX
    438  01b9
    439  01b9		       a9 56		      lda	#BANK_Sort
    440  01bb		       85 3f		      sta	SET_BANK
    441  01bd		       4c 0e f6 	      jmp	Sort	;@1
    442  01c0
    443  01c0
    444  01c0
      0  01c0					      DEF	MoveGenX
      1  01c0				   SLOT_MoveGenX SET	_BANK_SLOT
      2  01c0				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  01c0				   MoveGenX
      4  01c0				   TEMPORARY_VAR SET	Overlay
      5  01c0				   TEMPORARY_OFFSET SET	0
      6  01c0				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  01c0				   FUNCTION_NAME SET	MoveGenX
    446  01c0					      SUBROUTINE
    447  01c0
    448  01c0		       a9 cc		      lda	#RAMBANK_BOARD
    449  01c2		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    450  01c4
    451  01c4		       a2 64		      ldx	#100
    452  01c6		       d0 02		      bne	.next
    453  01c8
      0  01c8					      DEF	MoveReturn
      1  01c8				   SLOT_MoveReturn SET	_BANK_SLOT
      2  01c8				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  01c8				   MoveReturn
      4  01c8				   TEMPORARY_VAR SET	Overlay
      5  01c8				   TEMPORARY_OFFSET SET	0
      6  01c8				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  01c8				   FUNCTION_NAME SET	MoveReturn
    455  01c8
    456  01c8		       a6 92		      ldx	currentSquare
    457  01ca		       ca	   .next      dex
    458  01cb		       e0 16		      cpx	#22
    459  01cd		       90 2c		      bcc	.exit
    460  01cf
    461  01cf		       bd 79 fc 	      lda	Board,x
    462  01d2		       f0 f6		      beq	.next
    463  01d4		       c9 ff		      cmp	#-1
    464  01d6		       f0 f2		      beq	.next
    465  01d8		       45 95		      eor	sideToMove
    466  01da		       30 ee		      bmi	.next
    467  01dc
    468  01dc		       86 92		      stx	currentSquare
    469  01de
    470  01de		       45 95		      eor	sideToMove
    471  01e0		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    472  01e2		       85 91		      sta	currentPiece
    473  01e4		       29 0f		      and	#PIECE_MASK
    474  01e6		       05 b4		      ora	__pieceFilter
    475  01e8		       a8		      tay
    476  01e9
    477  01e9		       b9 10 f2 	      lda	HandlerVectorHI,y
    478  01ec		       85 b1		      sta	__vector+1
    479  01ee		       b9 00 f2 	      lda	HandlerVectorLO,y
    480  01f1		       85 b0		      sta	__vector
    481  01f3
    482  01f3		       b9 20 f2 	      lda	HandlerVectorBANK,y
    483  01f6		       85 3f		      sta	SET_BANK	;@1
    484  01f8
    485  01f8		       6c b0 00 	      jmp	(__vector)
    486  01fb
    487  01fb
    488  01fb		       a9 56	   .exit      lda	#BANK_negaMax
    489  01fd		       85 3f		      sta	SET_BANK
    490  01ff		       60		      rts
    491  0200
    492  0200					      MAC	handlevec
    493  0200
    494  0200					      .byte	{1}MoveReturn
    495  0200					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
    496  0200					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
    497  0200					      .byte	{1}Handle_KNIGHT	; 3
    498  0200					      .byte	{1}Handle_BISHOP	; 4
    499  0200					      .byte	{1}Handle_ROOK	; 5
    500  0200					      .byte	{1}Handle_QUEEN	; 6
    501  0200					      .byte	{1}Handle_KING	; 7
    502  0200
    503  0200					      .byte	{1}MoveReturn
    504  0200					      .byte	{1}Handle_WHITE_PAWN	; 1
    505  0200					      .byte	{1}Handle_BLACK_PAWN	; 2
    506  0200					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
    507  0200					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
    508  0200					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
    509  0200					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
    510  0200					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
    511  0200					      ENDM
    512  0200
    513  0200
    514  0200							;    .byte 0	  ; dummy to prevent page cross access on index 0
    515  0200
      0  0200					      DEF	HandlerVectorLO
      1  0200				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  0200				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  0200				   HandlerVectorLO
      4  0200				   TEMPORARY_VAR SET	Overlay
      5  0200				   TEMPORARY_OFFSET SET	0
      6  0200				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  0200				   FUNCTION_NAME SET	HandlerVectorLO
      0  0200					      HANDLEVEC	<
      1  0200
      2  0200		       c8		      .byte.b	<MoveReturn
      3  0201		       c8		      .byte.b	<MoveReturn
      4  0202		       c8		      .byte.b	<MoveReturn
      5  0203		       44		      .byte.b	<Handle_KNIGHT
      6  0204		       ed		      .byte.b	<Handle_BISHOP
      7  0205		       00		      .byte.b	<Handle_ROOK
      8  0206		       7b		      .byte.b	<Handle_QUEEN
      9  0207		       6e		      .byte.b	<Handle_KING
     10  0208
     11  0208		       c8		      .byte.b	<MoveReturn
     12  0209		       29		      .byte.b	<Handle_WHITE_PAWN
     13  020a		       cb		      .byte.b	<Handle_BLACK_PAWN
     14  020b		       c8		      .byte.b	<MoveReturn
     15  020c		       c8		      .byte.b	<MoveReturn
     16  020d		       c8		      .byte.b	<MoveReturn
     17  020e		       c8		      .byte.b	<MoveReturn
     18  020f		       c8		      .byte.b	<MoveReturn
      0  0210					      DEF	HandlerVectorHI
      1  0210				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  0210				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  0210				   HandlerVectorHI
      4  0210				   TEMPORARY_VAR SET	Overlay
      5  0210				   TEMPORARY_OFFSET SET	0
      6  0210				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  0210				   FUNCTION_NAME SET	HandlerVectorHI
      0  0210					      HANDLEVEC	>
      1  0210
      2  0210		       f1		      .byte.b	>MoveReturn
      3  0211		       f1		      .byte.b	>MoveReturn
      4  0212		       f1		      .byte.b	>MoveReturn
      5  0213		       f5		      .byte.b	>Handle_KNIGHT
      6  0214		       f5		      .byte.b	>Handle_BISHOP
      7  0215		       f4		      .byte.b	>Handle_ROOK
      8  0216		       f4		      .byte.b	>Handle_QUEEN
      9  0217		       f5		      .byte.b	>Handle_KING
     10  0218
     11  0218		       f1		      .byte.b	>MoveReturn
     12  0219		       f4		      .byte.b	>Handle_WHITE_PAWN
     13  021a		       f4		      .byte.b	>Handle_BLACK_PAWN
     14  021b		       f1		      .byte.b	>MoveReturn
     15  021c		       f1		      .byte.b	>MoveReturn
     16  021d		       f1		      .byte.b	>MoveReturn
     17  021e		       f1		      .byte.b	>MoveReturn
     18  021f		       f1		      .byte.b	>MoveReturn
      0  0220					      DEF	HandlerVectorBANK
      1  0220				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  0220				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  0220				   HandlerVectorBANK
      4  0220				   TEMPORARY_VAR SET	Overlay
      5  0220				   TEMPORARY_OFFSET SET	0
      6  0220				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  0220				   FUNCTION_NAME SET	HandlerVectorBANK
      0  0220					      HANDLEVEC	BANK_
      1  0220
      2  0220		       00		      .byte.b	BANK_MoveReturn
      3  0221		       00		      .byte.b	BANK_MoveReturn
      4  0222		       00		      .byte.b	BANK_MoveReturn
      5  0223		       57		      .byte.b	BANK_Handle_KNIGHT
      6  0224		       57		      .byte.b	BANK_Handle_BISHOP
      7  0225		       58		      .byte.b	BANK_Handle_ROOK
      8  0226		       58		      .byte.b	BANK_Handle_QUEEN
      9  0227		       58		      .byte.b	BANK_Handle_KING
     10  0228
     11  0228		       00		      .byte.b	BANK_MoveReturn
     12  0229		       57		      .byte.b	BANK_Handle_WHITE_PAWN
     13  022a		       57		      .byte.b	BANK_Handle_BLACK_PAWN
     14  022b		       00		      .byte.b	BANK_MoveReturn
     15  022c		       00		      .byte.b	BANK_MoveReturn
     16  022d		       00		      .byte.b	BANK_MoveReturn
     17  022e		       00		      .byte.b	BANK_MoveReturn
     18  022f		       00		      .byte.b	BANK_MoveReturn
    522  0230
    523  0230
    524  0230							;---------------------------------------------------------------------------------------------------
    525  0230
      0  0230					      DEF	ListPlayerMoves
      1  0230				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  0230				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  0230				   ListPlayerMoves
      4  0230				   TEMPORARY_VAR SET	Overlay
      5  0230				   TEMPORARY_OFFSET SET	0
      6  0230				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  0230				   FUNCTION_NAME SET	ListPlayerMoves
    527  0230					      SUBROUTINE
    528  0230
    529  0230							; Build a list of (mostly) valid player moves. The list of all moves is generated, and then
    530  0230							; these are each verified by making the move and listing all opponent moves. If the opponent
    531  0230							; can capture the king, the move is invalidated by setting its "from" square to zero.
    532  0230
    533  0230							; The movelist is built in the second ply so as not to stomp on the movelist from the computer
    534  0230							; on the previous response. This allows the player movelist to be generated BEFORE the
    535  0230							; computer's move has been visually shown on the screen.
    536  0230
    537  0230							; This in turn requires the minimum memory for PLY banks to be 3 (computer, player, response)
    538  0230
      0  0230					      COMMON_VARS_ALPHABETA		;✅
      1  0230
      0  0230					      VAR	__thinkbar, 1
      1  0230		       00 a4	   __thinkbar =	TEMPORARY_VAR
      2  0230				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0230
      4  0230				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0230				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0230				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0230					      ENDIF
      8  0230				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0230				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0230				  -	      ERR
     11  0230					      ENDIF
     12  0230					      LIST	ON
      0  0230					      VAR	__toggle, 1
      1  0230		       00 a5	   __toggle   =	TEMPORARY_VAR
      2  0230				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0230
      4  0230				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0230				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0230				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0230					      ENDIF
      8  0230				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0230				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0230				  -	      ERR
     11  0230					      ENDIF
     12  0230					      LIST	ON
      4  0230
      0  0230					      VAR	__bestMove, 1
      1  0230		       00 a6	   __bestMove =	TEMPORARY_VAR
      2  0230				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0230
      4  0230				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0230				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0230				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0230					      ENDIF
      8  0230				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0230				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0230				  -	      ERR
     11  0230					      ENDIF
     12  0230					      LIST	ON
      0  0230					      VAR	__alpha, 2
      1  0230		       00 a7	   __alpha    =	TEMPORARY_VAR
      2  0230				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0230
      4  0230				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0230				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0230				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0230					      ENDIF
      8  0230				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0230				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0230				  -	      ERR
     11  0230					      ENDIF
     12  0230					      LIST	ON
      0  0230					      VAR	__beta, 2
      1  0230		       00 a9	   __beta     =	TEMPORARY_VAR
      2  0230				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0230
      4  0230				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0230				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0230				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0230					      ENDIF
      8  0230				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0230				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0230				  -	      ERR
     11  0230					      ENDIF
     12  0230					      LIST	ON
      0  0230					      VAR	__negaMax, 2
      1  0230		       00 ab	   __negaMax  =	TEMPORARY_VAR
      2  0230				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0230
      4  0230				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0230				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0230				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0230					      ENDIF
      8  0230				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0230				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0230				  -	      ERR
     11  0230					      ENDIF
     12  0230					      LIST	ON
      0  0230					      VAR	__value, 2
      1  0230		       00 ad	   __value    =	TEMPORARY_VAR
      2  0230				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0230
      4  0230				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0230				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0230				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0230					      ENDIF
      8  0230				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0230				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0230				  -	      ERR
     11  0230					      ENDIF
     12  0230					      LIST	ON
     10  0230
      0  0230					      VAR	__quiesceCapOnly, 1
      1  0230		       00 af	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0230				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0230
      4  0230				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0230				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0230				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0230					      ENDIF
      8  0230				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0230				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0230				  -	      ERR
     11  0230					      ENDIF
     12  0230					      LIST	ON
     12  0230
      0  0230					      REFER	selectmove	;✅
      1  0230				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0230				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0230					      ENDIF
      0  0230					      REFER	StartupBankReset	;✅
      1  0230				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0230				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0230					      ENDIF
    542  0230
      0  0230					      VEND	ListPlayerMoves
      1  0230				  -	      IFNCONST	ListPlayerMoves
      2  0230				  -	      ECHO	"Incorrect VEND label", ListPlayerMoves
      3  0230				  -	      ERR
      4  0230					      ENDIF
      5  0230		       00 b0	   VAREND_ListPlayerMoves =	TEMPORARY_VAR
    544  0230
    545  0230
    546  0230		       a9 00		      lda	#0
    547  0232		       85 af		      sta	__quiesceCapOnly	; gen ALL moves
    548  0234
    549  0234		       a9 89		      lda	#RAMBANK_PLY+1
    550  0236		       85 94		      sta	currentPly
    551  0238
    552  0238		       20 8c f1 	      jsr	GenerateAllMoves	;@this
    553  023b
    554  023b		       e6 af		      inc	__quiesceCapOnly	; only interested in captures now...
    555  023d
      0  023d					      ldx@PLY	moveIndex
      1  023d		       ae d0 f9 	      ldx	moveIndex
      0  0240				   .scan      stx@PLY	movePtr
      1  0240		       8e d1 fb 	      stx	[RAM]+movePtr
    558  0243
      0  0243					      CALL	MakeMove	;@1
      1  0243				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  0243				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  0243				  -	      ECHO	"Cannot switch bank in use for", MakeMove
      4  0243				  -	      ERR
      5  0243					      ENDIF
      6  0243		       a9 56		      lda	#BANK_MakeMove
      7  0245		       85 3f		      sta	SET_BANK
      8  0247		       20 87 f4 	      jsr	MakeMove
    560  024a
    561  024a		       e6 94		      inc	currentPly
    562  024c		       20 8c f1 	      jsr	GenerateAllMoves	;@this
    563  024f
    564  024f		       c6 94		      dec	currentPly
    565  0251
    566  0251		       20 8f f2 	      jsr	unmakeMove	;@this
    567  0254
    568  0254		       a5 a1		      lda	flagCheck
    569  0256		       f0 08		      beq	.next
    570  0258
      0  0258					      ldx@PLY	movePtr
      1  0258		       ae d1 f9 	      ldx	movePtr
    572  025b		       a9 00		      lda	#0
      0  025d					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  025d		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    574  0260
      0  0260				   .next      ldx@PLY	movePtr
      1  0260		       ae d1 f9 	      ldx	movePtr
    576  0263		       ca		      dex
    577  0264		       10 da		      bpl	.scan
    578  0266
    579  0266		       60		      rts
    580  0267
    581  0267
    582  0267							;---------------------------------------------------------------------------------------------------
    583  0267
      0  0267					      DEF	AddMove
      1  0267				   SLOT_AddMove SET	_BANK_SLOT
      2  0267				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  0267				   AddMove
      4  0267				   TEMPORARY_VAR SET	Overlay
      5  0267				   TEMPORARY_OFFSET SET	0
      6  0267				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  0267				   FUNCTION_NAME SET	AddMove
    585  0267					      SUBROUTINE
    586  0267
      0  0267					      REFER	Handle_KING	;✅
      1  0267					      IF	VAREND_Handle_KING > TEMPORARY_VAR
      2  0267				   TEMPORARY_VAR SET	VAREND_Handle_KING
      3  0267					      ENDIF
      0  0267					      REFER	Handle_QUEEN	;✅
      1  0267				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  0267				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  0267					      ENDIF
      0  0267					      REFER	Handle_ROOK	;✅
      1  0267				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  0267				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  0267					      ENDIF
      0  0267					      REFER	Handle_BISHOP	;✅
      1  0267				  -	      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  0267				  -TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  0267					      ENDIF
      0  0267					      REFER	Handle_KNIGHT	;✅
      1  0267				  -	      IF	VAREND_Handle_KNIGHT > TEMPORARY_VAR
      2  0267				  -TEMPORARY_VAR SET	VAREND_Handle_KNIGHT
      3  0267					      ENDIF
      0  0267					      REFER	Handle_WHITE_PAWN	;✅
      1  0267				  -	      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  0267				  -TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  0267					      ENDIF
      0  0267					      REFER	Handle_BLACK_PAWN	;✅
      1  0267				  -	      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  0267				  -TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  0267					      ENDIF
    594  0267
      0  0267					      VEND	AddMove
      1  0267				  -	      IFNCONST	AddMove
      2  0267				  -	      ECHO	"Incorrect VEND label", AddMove
      3  0267				  -	      ERR
      4  0267					      ENDIF
      5  0267		       00 b5	   VAREND_AddMove =	TEMPORARY_VAR
    596  0267
    597  0267							; add square in y register to movelist as destination (X12 format)
    598  0267							; [y]		     to square (X12)
    599  0267							; currentSquare     from square (X12)
    600  0267							; currentPiece      piece.
    601  0267							;   ENPASSANT flag set if pawn double-moving off opening rank
    602  0267							; capture	     captured piece
    603  0267
    604  0267
    605  0267		       a5 9d		      lda	capture
    606  0269		       d0 04		      bne	.always
    607  026b		       a5 af		      lda	__quiesceCapOnly
    608  026d		       d0 1c		      bne	.abort
    609  026f
    610  026f		       98	   .always    tya
    611  0270		       aa		      tax
    612  0271
      0  0271					      ldy@PLY	moveIndex
      1  0271		       ac d0 f9 	      ldy	moveIndex
    614  0274		       c8		      iny
      0  0275					      sty@PLY	moveIndex
      1  0275		       8c d0 fb 	      sty	[RAM]+moveIndex
    616  0278
      0  0278					      sta@PLY	MoveTo,y
      1  0278		       99 64 fa 	      sta	[RAM]+MoveTo,y
    618  027b		       a5 92		      lda	currentSquare
      0  027d					      sta@PLY	MoveFrom,y
      1  027d		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    620  0280		       a5 91		      lda	currentPiece
      0  0282					      sta@PLY	MovePiece,y
      1  0282		       99 00 fb 	      sta	[RAM]+MovePiece,y
    622  0285		       a5 9d		      lda	capture
      0  0287					      sta@PLY	MoveCapture,y
      1  0287		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    624  028a		       60		      rts
    625  028b
    626  028b		       98	   .abort     tya
    627  028c		       aa		      tax
    628  028d		       60		      rts
    629  028e
    630  028e
    631  028e
    632  028e							;---------------------------------------------------------------------------------------------------
    633  028e
      0  028e					      DEF	debug
      1  028e				   SLOT_debug SET	_BANK_SLOT
      2  028e				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  028e				   debug
      4  028e				   TEMPORARY_VAR SET	Overlay
      5  028e				   TEMPORARY_OFFSET SET	0
      6  028e				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  028e				   FUNCTION_NAME SET	debug
    635  028e					      SUBROUTINE
    636  028e		       60		      rts
    637  028f
    638  028f
    639  028f							;---------------------------------------------------------------------------------------------------
    640  028f
      0  028f					      DEF	unmakeMove
      1  028f				   SLOT_unmakeMove SET	_BANK_SLOT
      2  028f				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  028f				   unmakeMove
      4  028f				   TEMPORARY_VAR SET	Overlay
      5  028f				   TEMPORARY_OFFSET SET	0
      6  028f				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  028f				   FUNCTION_NAME SET	unmakeMove
    642  028f					      SUBROUTINE
    643  028f
      0  028f					      REFER	selectmove	;✅
      1  028f					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  028f				   TEMPORARY_VAR SET	VAREND_selectmove
      3  028f					      ENDIF
      0  028f					      REFER	ListPlayerMoves	;✅
      1  028f				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  028f				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  028f					      ENDIF
      0  028f					      REFER	quiesce	;✅
      1  028f				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  028f				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  028f					      ENDIF
      0  028f					      REFER	negaMax	;✅
      1  028f				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  028f				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  028f					      ENDIF
      0  028f					      VEND	unmakeMove
      1  028f				  -	      IFNCONST	unmakeMove
      2  028f				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  028f				  -	      ERR
      4  028f					      ENDIF
      5  028f		       00 b0	   VAREND_unmakeMove =	TEMPORARY_VAR
    649  028f
    650  028f							; restore the board evaluation to what it was at the start of this ply
    651  028f							; TODO: note: moved flag seems wrong on restoration??
    652  028f
    653  028f		       a5 94		      lda	currentPly
    654  0291		       85 3e		      sta	SET_BANK_RAM	;@2
    655  0293		       a2 cc		      ldx	#RAMBANK_BOARD
    656  0295		       86 3e		      stx	SET_BANK_RAM	;@3
    657  0297
      0  0297					      lda@PLY	savedEvaluation
      1  0297		       ad c8 f9 	      lda	savedEvaluation
    659  029a		       85 8f		      sta	Evaluation
      0  029c					      lda@PLY	savedEvaluation+1
      1  029c		       ad c9 f9 	      lda	savedEvaluation+1
    661  029f		       85 90		      sta	Evaluation+1
    662  02a1
      0  02a1					      ldx@PLY	movePtr
      1  02a1		       ae d1 f9 	      ldx	movePtr
      0  02a4					      ldy@PLY	MoveFrom,x
      1  02a4		       bc 00 f8 	      ldy	MoveFrom,x
      0  02a7					      lda@PLY	restorePiece
      1  02a7		       ad da f9 	      lda	restorePiece
      0  02aa					      sta@RAM	Board,y
      1  02aa		       99 79 fe 	      sta	[RAM]+Board,y
    667  02ad
      0  02ad					      ldy@PLY	MoveTo,x
      1  02ad		       bc 64 f8 	      ldy	MoveTo,x
      0  02b0					      lda@PLY	capturedPiece
      1  02b0		       ad cb f9 	      lda	capturedPiece
      0  02b3					      sta@RAM	Board,y
      1  02b3		       99 79 fe 	      sta	[RAM]+Board,y
    671  02b6
    672  02b6
    673  02b6							; See if there are any 'secondary' pieces that moved
    674  02b6							; here we're dealing with reverting a castling or enPassant move
    675  02b6
      0  02b6					      lda@PLY	secondaryPiece
      1  02b6		       ad cd f9 	      lda	secondaryPiece
    677  02b9		       f0 0e		      beq	.noSecondary
      0  02bb					      ldx@PLY	secondarySquare
      1  02bb		       ae ce f9 	      ldx	secondarySquare
      0  02be					      sta@RAM	Board,x	; put piece back
      1  02be		       9d 79 fe 	      sta	[RAM]+Board,x
      0  02c1					      ldy@PLY	secondaryBlank
      1  02c1		       ac cf f9 	      ldy	secondaryBlank
    681  02c4		       a9 00		      lda	#0
      0  02c6					      sta@RAM	Board,y	; blank piece origin
      1  02c6		       99 79 fe 	      sta	[RAM]+Board,y
    683  02c9
      0  02c9				   .noSecondary SWAP
      1  02c9		       a5 95		      lda	sideToMove
      2  02cb		       49 80		      eor	#SWAP_SIDE
      3  02cd		       85 95		      sta	sideToMove
      4  02cf
      5  02cf
    685  02cf		       60		      rts
    686  02d0
    687  02d0
    688  02d0							;---------------------------------------------------------------------------------------------------
    689  02d0
      0  02d0					      DEF	showMoveCaptures
      1  02d0				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  02d0				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  02d0				   showMoveCaptures
      4  02d0				   TEMPORARY_VAR SET	Overlay
      5  02d0				   TEMPORARY_OFFSET SET	0
      6  02d0				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  02d0				   FUNCTION_NAME SET	showMoveCaptures
    691  02d0					      SUBROUTINE
    692  02d0
      0  02d0					      REFER	aiShowMoveCaptures	;✅
      1  02d0				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  02d0				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  02d0					      ENDIF
    694  02d0
      0  02d0					      VAR	__toSquareX12, 1
      1  02d0		       00 a4	   __toSquareX12 =	TEMPORARY_VAR
      2  02d0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02d0
      4  02d0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02d0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02d0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02d0					      ENDIF
      8  02d0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02d0				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  02d0				  -	      ERR
     11  02d0					      ENDIF
     12  02d0					      LIST	ON
      0  02d0					      VAR	__fromPiece, 1
      1  02d0		       00 a5	   __fromPiece =	TEMPORARY_VAR
      2  02d0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02d0
      4  02d0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02d0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02d0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02d0					      ENDIF
      8  02d0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02d0				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  02d0				  -	      ERR
     11  02d0					      ENDIF
     12  02d0					      LIST	ON
      0  02d0					      VAR	__aiMoveIndex, 1
      1  02d0		       00 a6	   __aiMoveIndex =	TEMPORARY_VAR
      2  02d0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  02d0
      4  02d0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  02d0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  02d0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  02d0					      ENDIF
      8  02d0				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  02d0				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  02d0				  -	      ERR
     11  02d0					      ENDIF
     12  02d0					      LIST	ON
    698  02d0
      0  02d0					      VEND	showMoveCaptures
      1  02d0				  -	      IFNCONST	showMoveCaptures
      2  02d0				  -	      ECHO	"Incorrect VEND label", showMoveCaptures
      3  02d0				  -	      ERR
      4  02d0					      ENDIF
      5  02d0		       00 a7	   VAREND_showMoveCaptures =	TEMPORARY_VAR
    700  02d0
    701  02d0							; place a marker on the board for any square matching the piece
    702  02d0							; EXCEPT for squares which are occupied (we'll flash those later)
    703  02d0							; x = movelist item # being checked
    704  02d0
    705  02d0
    706  02d0		       a6 8d	   .next      ldx	aiMoveIndex
    707  02d2		       86 a6		      stx	__aiMoveIndex
    708  02d4		       30 4a		      bmi	.skip	; no moves in list
    709  02d6
    710  02d6		       ad 84 02 	      lda	INTIM
    711  02d9		       c9 14		      cmp	#20
    712  02db		       90 43		      bcc	.skip
    713  02dd
    714  02dd		       c6 8d		      dec	aiMoveIndex
    715  02df
    716  02df		       a9 89		      lda	#RAMBANK_PLY+1
    717  02e1		       85 3e		      sta	SET_BANK_RAM
      0  02e3					      lda@PLY	MoveFrom,x
      1  02e3		       bd 00 f8 	      lda	MoveFrom,x
    719  02e6		       c5 85		      cmp	fromX12
    720  02e8		       d0 e6		      bne	.next
    721  02ea
      0  02ea					      lda@PLY	MoveTo,x
      1  02ea		       bd 64 f8 	      lda	MoveTo,x
    723  02ed		       85 a4		      sta	__toSquareX12
    724  02ef		       a8		      tay
    725  02f0
    726  02f0		       a9 cc		      lda	#RAMBANK_BOARD
    727  02f2		       85 3e		      sta	SET_BANK_RAM	;@3
    728  02f4		       b9 79 fc 	      lda	Board,y
    729  02f7		       29 0f		      and	#PIECE_MASK
    730  02f9		       f0 d5		      beq	.next
    731  02fb
    732  02fb							; There's something on the board at destination, so it's a capture
    733  02fb							; Let's see if we are doing a pawn promote...
    734  02fb
    735  02fb		       a4 85		      ldy	fromX12
    736  02fd
    737  02fd		       a9 cc		      lda	#RAMBANK_BOARD
    738  02ff		       85 3e		      sta	SET_BANK_RAM	;@3
    739  0301		       b9 79 fc 	      lda	Board,y
    740  0304		       85 a5		      sta	__fromPiece
    741  0306
    742  0306		       a9 89		      lda	#RAMBANK_PLY+1
    743  0308		       85 3e		      sta	SET_BANK_RAM
      0  030a					      lda@PLY	MovePiece,x
      1  030a		       bd 00 f9 	      lda	MovePiece,x
    745  030d		       45 a5		      eor	__fromPiece
    746  030f		       29 0f		      and	#PIECE_MASK
    747  0311		       f0 06		      beq	.legit	; from == to, so not a promote
    748  0313
    749  0313							; Have detected a promotion duplicate - skip all 3 of them
    750  0313
    751  0313		       c6 8d		      dec	aiMoveIndex	; skip "KBRQ" promotes
    752  0315		       c6 8d		      dec	aiMoveIndex
    753  0317		       c6 8d		      dec	aiMoveIndex
    754  0319
    755  0319				   .legit
    756  0319
    757  0319							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
    758  0319
    759  0319		       a5 a4		      lda	__toSquareX12
    760  031b		       85 80		      sta	squareToDraw
    761  031d
    762  031d		       20 c2 f0 	      jsr	CopySinglePiece	;@0
    763  0320
    764  0320		       60	   .skip      rts
    765  0321
    766  0321
    767  0321							;---------------------------------------------------------------------------------------------------
    768  0321
      0  0321					      DEF	CopyPieceToRowBitmap
      1  0321				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  0321				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  0321				   CopyPieceToRowBitmap
      4  0321				   TEMPORARY_VAR SET	Overlay
      5  0321				   TEMPORARY_OFFSET SET	0
      6  0321				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  0321				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    770  0321					      SUBROUTINE
    771  0321
      0  0321					      REFER	InterceptMarkerCopy	;✅
      1  0321					      IF	VAREND_InterceptMarkerCopy > TEMPORARY_VAR
      2  0321				   TEMPORARY_VAR SET	VAREND_InterceptMarkerCopy
      3  0321					      ENDIF
    773  0321
      0  0321					      VEND	CopyPieceToRowBitmap
      1  0321				  -	      IFNCONST	CopyPieceToRowBitmap
      2  0321				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  0321				  -	      ERR
      4  0321					      ENDIF
      5  0321		       00 a7	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
    775  0321
    776  0321		       a0 11		      ldy	#17
    777  0323		       b0 30		      bcs	.rightSide
    778  0325
    779  0325		       b9 a4 00    .copyPiece lda	__pieceShapeBuffer,y
    780  0328		       f0 06		      beq	.blank1
    781  032a		       59 00 f8 	      eor	ChessBitmap,y
      0  032d					      sta@RAM	ChessBitmap,y
      1  032d		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    783  0330
    784  0330		       b9 b6 00    .blank1    lda	__pieceShapeBuffer+18,y
    785  0333		       f0 06		      beq	.blank2
    786  0335		       59 12 f8 	      eor	ChessBitmap+18,y
      0  0338					      sta@RAM	ChessBitmap+18,y
      1  0338		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    788  033b
    789  033b		       b9 c8 00    .blank2    lda	__pieceShapeBuffer+36,y
    790  033e		       f0 06		      beq	.blank3
    791  0340		       59 24 f8 	      eor	ChessBitmap+36,y
      0  0343					      sta@RAM	ChessBitmap+36,y
      1  0343		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    793  0346
    794  0346		       b9 da 00    .blank3    lda	__pieceShapeBuffer+54,y
    795  0349		       f0 06		      beq	.blank4
    796  034b		       59 36 f8 	      eor	ChessBitmap+54,y
      0  034e					      sta@RAM	ChessBitmap+54,y
      1  034e		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    798  0351
    799  0351		       88	   .blank4    dey
    800  0352		       10 d1		      bpl	.copyPiece
    801  0354		       60		      rts
    802  0355
    803  0355				   .rightSide
    804  0355
    805  0355					      SUBROUTINE
    806  0355
    807  0355		       b9 a4 00    .copyPieceR lda	__pieceShapeBuffer,y
    808  0358		       f0 06		      beq	.blank1
    809  035a		       59 48 f8 	      eor	ChessBitmap+72,y
      0  035d					      sta@RAM	ChessBitmap+72,y
      1  035d		       99 48 fa 	      sta	[RAM]+ChessBitmap+72,y
    811  0360
    812  0360		       b9 b6 00    .blank1    lda	__pieceShapeBuffer+18,y
    813  0363		       f0 06		      beq	.blank2
    814  0365		       59 5a f8 	      eor	ChessBitmap+72+18,y
      0  0368					      sta@RAM	ChessBitmap+72+18,y
      1  0368		       99 5a fa 	      sta	[RAM]+ChessBitmap+72+18,y
    816  036b
    817  036b		       b9 c8 00    .blank2    lda	__pieceShapeBuffer+36,y
    818  036e		       f0 06		      beq	.blank3
    819  0370		       59 6c f8 	      eor	ChessBitmap+72+36,y
      0  0373					      sta@RAM	ChessBitmap+72+36,y
      1  0373		       99 6c fa 	      sta	[RAM]+ChessBitmap+72+36,y
    821  0376
    822  0376		       b9 da 00    .blank3    lda	__pieceShapeBuffer+54,y
    823  0379		       f0 06		      beq	.blank4
    824  037b		       59 7e f8 	      eor	ChessBitmap+72+54,y
      0  037e					      sta@RAM	ChessBitmap+72+54,y
      1  037e		       99 7e fa 	      sta	[RAM]+ChessBitmap+72+54,y
    826  0381
    827  0381		       88	   .blank4    dey
    828  0382		       10 d1		      bpl	.copyPieceR
    829  0384		       60		      rts
    830  0385
    831  0385							;---------------------------------------------------------------------------------------------------
    832  0385
 FREE BYTES IN BANK_FIRST@0 BANK =  $77
    833  0385					      ECHO	"FREE BYTES IN BANK_FIRST@0 BANK = ", $F3FC - *
    834  0385
    835  0385							;---------------------------------------------------------------------------------------------------
    836  0385							; The reset vectors
    837  0385							; these must live in the first 1K bank of the ROM
    838  0385
    839  0400 ????				      SEG	StartupInterruptVectors
    840  03fc					      ORG	_FIRST_BANK + $3FC
    841  03fc
    842  03fc		       00 f0		      .word.w	StartupBankReset	; RESET
    843  03fe		       00 f0		      .word.w	StartupBankReset	; IRQ	      (not used)
    844  0400
    845  0400							;---------------------------------------------------------------------------------------------------
    846  0400
    847  0400
    848  0400							; EOF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@1#1.asm LEVEL 2 PASS 4
      0  0400					      include	"BANK_GENERIC@1#1.asm"
      1  0400							; Chess
      2  0400							; Copyright (c) 2019-2020 Andrew Davie
      3  0400							; andrew@taswegian.com
      4  0400
      0  0400					      SLOT	1	; which bank this code switches to
      1  0400				  -	      IF	(1 < 0) || (1 > 3)
      2  0400				  -	      ECHO	"Illegal bank address/segment location", 1
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  0400				   _BANK_SLOT SET	1 * 64
      0  0400					      NEWBANK	ONE
      1  0680 ????				      SEG	ONE
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   ONE_START  SET	*
      6  0400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0400				   ONE	      SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + 1024
      7  0400
      8  0400
      9  0400							;---------------------------------------------------------------------------------------------------
     10  0400							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     11  0400							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     12  0400							; bank finishes.  Just continue on from where it left off...
     13  0400							;---------------------------------------------------------------------------------------------------
     14  0400
      0  0400					      DEF	CartInit
      1  0400				   SLOT_CartInit SET	_BANK_SLOT
      2  0400				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0400				   CartInit
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	CartInit
     16  0400					      SUBROUTINE
     17  0400
      0  0400					      REFER	StartupBankReset	;✅
      1  0400				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0400				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0400					      ENDIF
     19  0400
      0  0400					      VEND	CartInit
      1  0400				  -	      IFNCONST	CartInit
      2  0400				  -	      ECHO	"Incorrect VEND label", CartInit
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400		       00 a4	   VAREND_CartInit =	TEMPORARY_VAR
     21  0400
     22  0400		       78		      sei
     23  0401		       d8		      cld
     24  0402							; See if we can come up with something 'random' for startup
     25  0402
     26  0402		       ac 84 02 	      ldy	INTIM
     27  0405		       d0 02		      bne	.toR
     28  0407		       a0 9a		      ldy	#$9A
     29  0409		       84 81	   .toR       sty	rnd
     30  040b
     31  040b		       a9 ff		      lda	#255
     32  040d		       85 a3		      sta	randomness
     33  040f
     34  040f		       a9 00		      lda	#0
     35  0411		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     36  0414		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     37  0417		       85 6b		      sta	HMCLR
     38  0419
     39  0419							; cleanup remains of title screen
     40  0419		       85 5b		      sta	GRP0
     41  041b		       85 5c		      sta	GRP1
     42  041d
     43  041d		       a9 10		      lda	#%00010000	; double width missile, double width player
     44  041f		       85 44		      sta	NUSIZ0
     45  0421		       85 45		      sta	NUSIZ1
     46  0423
     47  0423		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     48  0425		       85 4a		      sta	CTRLPF
     49  0427		       a9 07		      lda	#%111
     50  0429		       85 44		      sta	NUSIZ0
     51  042b		       85 45		      sta	NUSIZ1	; quad-width
     52  042d
     53  042d		       a9 04		      lda	#%00000100
     54  042f		       85 4a		      sta	CTRLPF
     55  0431		       a9 00		      lda	#BACKGCOL
     56  0433		       85 49		      sta	COLUBK
     57  0435
     58  0435
     59  0435		       a9 00		      lda	#WHITE	;tmp+RAMBANK_PLY
     60  0437		       85 95		      sta	sideToMove
     61  0439
     62  0439		       60		      rts
     63  043a
     64  043a
     65  043a							;---------------------------------------------------------------------------------------------------
     66  043a
      0  043a					      DEF	SetupBanks
      1  043a				   SLOT_SetupBanks SET	_BANK_SLOT
      2  043a				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  043a				   SetupBanks
      4  043a				   TEMPORARY_VAR SET	Overlay
      5  043a				   TEMPORARY_OFFSET SET	0
      6  043a				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  043a				   FUNCTION_NAME SET	SetupBanks
     68  043a					      SUBROUTINE
     69  043a
     70  043a							; Move a copy of the row bank template to the first 8 banks of RAM
     71  043a							; and then terminate the draw subroutine by substituting in a RTS on the last one
     72  043a
      0  043a					      REFER	StartupBankReset	;✅
      1  043a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  043a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  043a					      ENDIF
     74  043a
      0  043a					      VAR	__plyBank, 1
      1  043a		       00 a4	   __plyBank  =	TEMPORARY_VAR
      2  043a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  043a
      4  043a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  043a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  043a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  043a					      ENDIF
      8  043a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  043a				  -	      ECHO	"Temporary Variable", __plyBank, "overflow!"
     10  043a				  -	      ERR
     11  043a					      ENDIF
     12  043a					      LIST	ON
     76  043a
      0  043a					      VEND	SetupBanks
      1  043a				  -	      IFNCONST	SetupBanks
      2  043a				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  043a				  -	      ERR
      4  043a					      ENDIF
      5  043a		       00 a5	   VAREND_SetupBanks =	TEMPORARY_VAR
     78  043a
     79  043a							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     80  043a
     81  043a				   .ROWBANK   SET	0
     82  043a					      REPEAT	8
     83  043a		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     84  043c		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     85  043e		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     86  043e				   .ROWBANK   SET	.ROWBANK+1
     82  043e					      REPEND
     83  0441		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     84  0443		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     85  0445		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     86  0445				   .ROWBANK   SET	.ROWBANK+1
     82  0445					      REPEND
     83  0448		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     84  044a		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     85  044c		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     86  044c				   .ROWBANK   SET	.ROWBANK+1
     82  044c					      REPEND
     83  044f		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     84  0451		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     85  0453		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     86  0453				   .ROWBANK   SET	.ROWBANK+1
     82  0453					      REPEND
     83  0456		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     84  0458		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     85  045a		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     86  045a				   .ROWBANK   SET	.ROWBANK+1
     82  045a					      REPEND
     83  045d		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     84  045f		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     85  0461		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     86  0461				   .ROWBANK   SET	.ROWBANK+1
     82  0461					      REPEND
     83  0464		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     84  0466		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     85  0468		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     86  0468				   .ROWBANK   SET	.ROWBANK+1
     82  0468					      REPEND
     83  046b		       a2 82		      ldx	#BANK_SHADOW_ChessBitmap
     84  046d		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     85  046f		       20 83 f4 	      jsr	CopyShadowROMtoRAM
     86  046f				   .ROWBANK   SET	.ROWBANK+1
     87  0472					      REPEND
     88  0472
     89  0472
     90  0472							; Patch the final row's "loop" to a RTS
     91  0472
     92  0472		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     93  0474		       86 3e		      stx	SET_BANK_RAM
     94  0476		       a9 60		      lda	#$60	; "rts"
      0  0478					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0478		       8d 00 fb 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     96  047b
     97  047b
     98  047b
     99  047b							; copy the BOARD/MOVES bank
    100  047b
    101  047b		       a2 84		      ldx	#SHADOW_BOARD
    102  047d		       a0 cc		      ldy	#RAMBANK_BOARD
    103  047f		       20 83 f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    104  0482
    105  0482
    106  0482							; copy the PLY banks
    107  0482							; If there's no content (only variable decs) then we don't really need to do this.
    108  0482
    109  0482							;.PLY SET 0
    110  0482							;    REPEAT PLY_BANKS
    111  0482
    112  0482							;		      ldx #SHADOW_PLY
    113  0482							;		      ldy #RAMBANK_PLY + .PLY
    114  0482							;jsr CopyShadowROMtoRAM
    115  0482							;.PLY SET .PLY + 1
    116  0482							;    REPEND
    117  0482
    118  0482							; copy the evaluation code/tables
    119  0482							; 3E+ moved from RAM to ROM
    120  0482
    121  0482							;		      ldx #[SLOT2] + SHADOW_EVAL
    122  0482							;		      ldy #[SLOT3] + EVAL
    123  0482							;		      jsr CopyShadowROMtoRAM
    124  0482
    125  0482
    126  0482							;		      ldy #RAMBANK_RAM_PIECELIST
    127  0482							;		      ldx #ROM_PIECELIST
    128  0482							;		      jsr CopyShadowROMtoRAM
    129  0482
    130  0482		       60		      rts
    131  0483
    132  0483
    133  0483							;---------------------------------------------------------------------------------------------------
    134  0483
      0  0483					      DEF	CopyShadowROMtoRAM
      1  0483				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  0483				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  0483				   CopyShadowROMtoRAM
      4  0483				   TEMPORARY_VAR SET	Overlay
      5  0483				   TEMPORARY_OFFSET SET	0
      6  0483				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  0483				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    136  0483					      SUBROUTINE
    137  0483
      0  0483					      REFER	SetupBanks	;✅
      1  0483					      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  0483				   TEMPORARY_VAR SET	VAREND_SetupBanks
      3  0483					      ENDIF
    139  0483
      0  0483					      VEND	CopyShadowROMtoRAM
      1  0483				  -	      IFNCONST	CopyShadowROMtoRAM
      2  0483				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  0483				  -	      ERR
      4  0483					      ENDIF
      5  0483		       00 a5	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    141  0483
    142  0483							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    143  0483							; used to setup callable RAM code from ROM templates
    144  0483
    145  0483							; x = source ROM bank
    146  0483							; y = destination RAM bank (preserved)
    147  0483
    148  0483		       86 3f		      stx	SET_BANK
    149  0485		       84 3e		      sty	SET_BANK_RAM
    150  0487
    151  0487		       a2 00		      ldx	#0
    152  0489		       bd 00 f8    .copyPage  lda	$F800,x
      0  048c					      sta@RAM	$FC00,x
      1  048c		       9d 00 fe 	      sta	[RAM]+$FC00,x
    154  048f		       bd 00 f9 	      lda	$F900,x
      0  0492					      sta@RAM	$FD00,x
      1  0492		       9d 00 ff 	      sta	[RAM]+$FD00,x
    156  0495		       ca		      dex
    157  0496		       d0 f1		      bne	.copyPage
    158  0498		       60		      rts
    159  0499
    160  0499
    161  0499							;---------------------------------------------------------------------------------------------------
    162  0499
      0  0499					      DEF	CallClear
      1  0499				   SLOT_CallClear SET	_BANK_SLOT
      2  0499				   BANK_CallClear SET	SLOT_CallClear + _CURRENT_BANK
      3  0499				   CallClear
      4  0499				   TEMPORARY_VAR SET	Overlay
      5  0499				   TEMPORARY_OFFSET SET	0
      6  0499				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      7  0499				   FUNCTION_NAME SET	CallClear
    164  0499					      SUBROUTINE
    165  0499
    166  0499				  -	      IF	0
    167  0499				  -	      REFER	aiClearEachRow	;TODO
    168  0499					      ENDIF
    169  0499
      0  0499					      VEND	CallClear
      1  0499				  -	      IFNCONST	CallClear
      2  0499				  -	      ECHO	"Incorrect VEND label", CallClear
      3  0499				  -	      ERR
      4  0499					      ENDIF
      5  0499		       00 a4	   VAREND_CallClear =	TEMPORARY_VAR
    171  0499
    172  0499				  -	      IF	0
    173  0499				  -			; No transient variable dependencies/calls
    174  0499				  -
    175  0499				  -	      sty	SET_BANK_RAM
    176  0499				  -	      jsr	ClearRowBitmap
    177  0499					      ENDIF
    178  0499		       60		      rts
    179  049a
    180  049a
    181  049a							;---------------------------------------------------------------------------------------------------
    182  049a
      0  049a					      DEF	InitialisePieceSquares
      1  049a				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  049a				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  049a				   InitialisePieceSquares
      4  049a				   TEMPORARY_VAR SET	Overlay
      5  049a				   TEMPORARY_OFFSET SET	0
      6  049a				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  049a				   FUNCTION_NAME SET	InitialisePieceSquares
    184  049a					      SUBROUTINE
    185  049a
      0  049a					      REFER	StartupBankReset	;✅
      1  049a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  049a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  049a					      ENDIF
    187  049a
      0  049a					      VAR	__initPiece, 1
      1  049a		       00 a4	   __initPiece =	TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  049a
      4  049a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  049a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  049a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  049a					      ENDIF
      8  049a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  049a				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  049a				  -	      ERR
     11  049a					      ENDIF
     12  049a					      LIST	ON
      0  049a					      VAR	__initSquare, 1
      1  049a		       00 a5	   __initSquare =	TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  049a
      4  049a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  049a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  049a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  049a					      ENDIF
      8  049a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  049a				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  049a				  -	      ERR
     11  049a					      ENDIF
     12  049a					      LIST	ON
      0  049a					      VAR	__initListPtr, 1
      1  049a		       00 a6	   __initListPtr =	TEMPORARY_VAR
      2  049a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  049a
      4  049a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  049a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  049a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  049a					      ENDIF
      8  049a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  049a				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  049a				  -	      ERR
     11  049a					      ENDIF
     12  049a					      LIST	ON
    191  049a
      0  049a					      VEND	InitialisePieceSquares
      1  049a				  -	      IFNCONST	InitialisePieceSquares
      2  049a				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  049a				  -	      ERR
      4  049a					      ENDIF
      5  049a		       00 a7	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    193  049a
    194  049a		       a9 00		      lda	#0
    195  049c		       85 8f		      sta	Evaluation
    196  049e		       85 90		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    197  04a0		       85 93		      sta	enPassantPawn	; no en-passant
    198  04a2
    199  04a2
      0  04a2					      PHASE	AI_StartClearBoard
      1  04a2		       a9 0d		      lda	#AI_StartClearBoard
      2  04a4		       85 8b		      sta	aiState
    201  04a6
    202  04a6		       a2 00		      ldx	#0
    203  04a8				   .fillPieceLists
    204  04a8
    205  04a8
    206  04a8		       bd fa f4 	      lda	InitPieceList,x	; colour/-1
    207  04ab		       f0 4c		      beq	.exit
    208  04ad		       85 b2		      sta	__originalPiece	; type
    209  04af		       bc fb f4 	      ldy	InitPieceList+1,x	; square
    210  04b2		       84 a5		      sty	__initSquare
    211  04b4
    212  04b4		       a9 cc		      lda	#RAMBANK_BOARD
    213  04b6		       85 3e		      sta	SET_BANK_RAM
    214  04b8		       a5 b2		      lda	__originalPiece
      0  04ba					      sta@RAM	Board,y
      1  04ba		       99 79 fe 	      sta	[RAM]+Board,y
    216  04bd		       10 0d		      bpl	.white
    217  04bf
      0  04bf					      NEGEVAL
      1  04bf
      2  04bf		       38		      sec
      3  04c0		       a9 00		      lda	#0
      4  04c2		       e5 8f		      sbc	Evaluation
      5  04c4		       85 8f		      sta	Evaluation
      6  04c6		       a9 00		      lda	#0
      7  04c8		       e5 90		      sbc	Evaluation+1
      8  04ca		       85 90		      sta	Evaluation+1
    219  04cc				   .white
    220  04cc
    221  04cc		       86 a6		      stx	__initListPtr
    222  04ce
    223  04ce							; Add the material value of the piece to the evaluation
    224  04ce
    225  04ce		       a5 b2		      lda	__originalPiece
    226  04d0		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    227  04d2		       86 3f		      stx	SET_BANK	;@2
    228  04d4		       20 0f f9 	      jsr	AddPieceMaterialValue
    229  04d7
    230  04d7
    231  04d7							; add the positional value of the piece to the evaluation
    232  04d7
    233  04d7		       a4 a5		      ldy	__initSquare
    234  04d9		       a5 b2		      lda	__originalPiece
    235  04db		       a2 91		      ldx	#BANK_AddPiecePositionValue
    236  04dd		       86 3f		      stx	SET_BANK
    237  04df		       20 32 f9 	      jsr	AddPiecePositionValue
    238  04e2
    239  04e2		       a5 b2		      lda	__originalPiece	; type/colour
    240  04e4		       10 0d		      bpl	.white2
      0  04e6					      NEGEVAL
      1  04e6
      2  04e6		       38		      sec
      3  04e7		       a9 00		      lda	#0
      4  04e9		       e5 8f		      sbc	Evaluation
      5  04eb		       85 8f		      sta	Evaluation
      6  04ed		       a9 00		      lda	#0
      7  04ef		       e5 90		      sbc	Evaluation+1
      8  04f1		       85 90		      sta	Evaluation+1
    242  04f3				   .white2
    243  04f3
    244  04f3		       a6 a6		      ldx	__initListPtr
    245  04f5		       e8		      inx
    246  04f6		       e8		      inx
    247  04f7		       10 af		      bpl	.fillPieceLists
    248  04f9
    249  04f9				   .exit
    250  04f9		       60		      rts
    251  04fa
    252  04fa
    253  04fa				   InitPieceList
    254  04fa
    255  04fa
    256  04fa					      IF	!TEST_POSITION
    257  04fa
    258  04fa		       06 19		      .byte.b	WHITE|Q, 25
    259  04fc		       04 18		      .byte.b	WHITE|B, 24
    260  04fe		       04 1b		      .byte.b	WHITE|B, 27
    261  0500		       05 16		      .byte.b	WHITE|R, 22
    262  0502		       05 1d		      .byte.b	WHITE|R, 29
    263  0504		       03 17		      .byte.b	WHITE|N, 23
    264  0506		       03 1c		      .byte.b	WHITE|N, 28
    265  0508
    266  0508		       01 23		      .byte.b	WHITE|WP, 35
    267  050a		       01 24		      .byte.b	WHITE|WP, 36
    268  050c		       01 22		      .byte.b	WHITE|WP, 34
    269  050e		       01 25		      .byte.b	WHITE|WP, 37
    270  0510		       01 21		      .byte.b	WHITE|WP, 33
    271  0512		       01 26		      .byte.b	WHITE|WP, 38
    272  0514		       01 20		      .byte.b	WHITE|WP, 32
    273  0516		       01 27		      .byte.b	WHITE|WP, 39
    274  0518
    275  0518		       07 1a		      .byte.b	WHITE|K, 26
    276  051a
    277  051a		       86 5f		      .byte.b	BLACK|Q, 95
    278  051c		       84 5e		      .byte.b	BLACK|B, 94
    279  051e		       84 61		      .byte.b	BLACK|B, 97
    280  0520		       85 5c		      .byte.b	BLACK|R, 92
    281  0522		       85 63		      .byte.b	BLACK|R, 99
    282  0524		       83 5d		      .byte.b	BLACK|N, 93
    283  0526		       83 62		      .byte.b	BLACK|N, 98
    284  0528
    285  0528		       82 55		      .byte.b	BLACK|BP, 85
    286  052a		       82 56		      .byte.b	BLACK|BP, 86
    287  052c		       82 54		      .byte.b	BLACK|BP, 84
    288  052e		       82 57		      .byte.b	BLACK|BP, 87
    289  0530		       82 53		      .byte.b	BLACK|BP, 83
    290  0532		       82 58		      .byte.b	BLACK|BP, 88
    291  0534		       82 52		      .byte.b	BLACK|BP, 82
    292  0536		       82 59		      .byte.b	BLACK|BP, 89
    293  0538
    294  0538		       87 60		      .byte.b	BLACK|K, 96
    295  053a
    296  053a		       00		      .byte.b	0	;end
    297  053b
    298  053b				  -	      ELSE		; test position...
    299  053b				  -
    300  053b				  -	      IF	1
    301  053b				  -
    302  053b				  -	      .byte	WHITE|N, 28
    303  053b				  -	      .byte	WHITE|K, 26
    304  053b				  -
    305  053b				  -	      .byte	BLACK|Q, 29
    306  053b				  -
    307  053b				  -	      .byte	0	;end
    308  053b				  -
    309  053b				  -	      ENDIF
    310  053b				  -
    311  053b				  -	      IF	0
    312  053b				  -
    313  053b				  -	      .byte	WHITE|K, 28
    314  053b				  -	      .byte	WHITE|WP, 37
    315  053b				  -	      .byte	WHITE|WP, 38
    316  053b				  -	      .byte	WHITE|WP, 53
    317  053b				  -	      .byte	WHITE|WP, 49
    318  053b				  -	      .byte	WHITE|WP, 32
    319  053b				  -	      .byte	WHITE|R, 27
    320  053b				  -	      .byte	WHITE|B, 46
    321  053b				  -	      .byte	WHITE|R, 54
    322  053b				  -
    323  053b				  -	      .byte	BLACK|BP, 56
    324  053b				  -	      .byte	BLACK|BP, 87
    325  053b				  -	      .byte	BLACK|BP, 88
    326  053b				  -	      .byte	BLACK|BP, 89
    327  053b				  -	      .byte	BLACK|BP, 84
    328  053b				  -	      .byte	BLACK|B, 66
    329  053b				  -	      .byte	BLACK|R, 69
    330  053b				  -	      .byte	BLACK|K, 98
    331  053b				  -
    332  053b				  -	      .byte	BLACK|R, 92
    333  053b				  -
    334  053b				  -
    335  053b				  -
    336  053b				  -	      ENDIF
    337  053b				  -
    338  053b				  -
    339  053b				  -	      IF	0
    340  053b				  -			; En passant test
    341  053b				  -
    342  053b				  -	      .byte	BLACK|BP, 88
    343  053b				  -	      .byte	BLACK|BP, 86
    344  053b				  -
    345  053b				  -	      .byte	WHITE|WP, 67
    346  053b				  -	      .byte	WHITE|K, 52
    347  053b				  -
    348  053b				  -
    349  053b				  -	      ENDIF
    350  053b				  -
    351  053b				  -
    352  053b				  -
    353  053b				  -
    354  053b				  -	      IF	0
    355  053b				  -
    356  053b				  -
    357  053b				  -			;.byte BLACK|R, 97
    358  053b				  -	      .byte	BLACK|K, 98
    359  053b				  -	      .byte	BLACK|BP, 87
    360  053b				  -	      .byte	BLACK|BP, 88
    361  053b				  -	      .byte	BLACK|BP, 89
    362  053b				  -			;    .byte BLACK|B, 76
    363  053b				  -
    364  053b				  -
    365  053b				  -	      .byte	WHITE|R,28
    366  053b				  -	      .byte	WHITE|Q,58
    367  053b				  -			;   .byte WHITE|N,65
    368  053b				  -	      ENDIF
    369  053b				  -
    370  053b				  -	      IF	0
    371  053b				  -			;.byte WHITE|WP, 56
    372  053b				  -
    373  053b				  -
    374  053b				  -	      .byte	BLACK|K, 98
    375  053b				  -
    376  053b				  -
    377  053b				  -	      .byte	WHITE|R,29
    378  053b				  -	      .byte	WHITE|Q,49
    379  053b				  -	      .byte	WHITE|N,65
    380  053b				  -	      ENDIF
    381  053b				  -	      .byte	0	;end
    382  053b				  -
    383  053b					      ENDIF
    384  053b
    385  053b
    386  053b							;---------------------------------------------------------------------------------------------------
    387  053b
      0  053b					      DEF	EnPassantRemovePiece
      1  053b				   SLOT_EnPassantRemovePiece SET	_BANK_SLOT
      2  053b				   BANK_EnPassantRemovePiece SET	SLOT_EnPassantRemovePiece + _CURRENT_BANK
      3  053b				   EnPassantRemovePiece
      4  053b				   TEMPORARY_VAR SET	Overlay
      5  053b				   TEMPORARY_OFFSET SET	0
      6  053b				   VAR_BOUNDARY_EnPassantRemovePiece SET	TEMPORARY_OFFSET
      7  053b				   FUNCTION_NAME SET	EnPassantRemovePiece
    389  053b					      SUBROUTINE
    390  053b
      0  053b					      REFER	MakeMove
      1  053b					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  053b				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  053b					      ENDIF
    392  053b
    393  053b				  -	      IF	ENPASSANT_ENABLED
    394  053b				  -	      REFER	EnPassantCheck	;✅
    395  053b					      ENDIF
    396  053b
      0  053b					      VAR	__y, 1
      1  053b		       00 b2	   __y	      =	TEMPORARY_VAR
      2  053b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  053b
      4  053b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  053b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  053b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  053b					      ENDIF
      8  053b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  053b				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  053b				  -	      ERR
     11  053b					      ENDIF
     12  053b					      LIST	ON
      0  053b					      VAR	__col, 1
      1  053b		       00 b3	   __col      =	TEMPORARY_VAR
      2  053b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  053b
      4  053b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  053b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  053b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  053b					      ENDIF
      8  053b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  053b				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  053b				  -	      ERR
     11  053b					      ENDIF
     12  053b					      LIST	ON
    399  053b
      0  053b					      VEND	EnPassantRemovePiece
      1  053b				  -	      IFNCONST	EnPassantRemovePiece
      2  053b				  -	      ECHO	"Incorrect VEND label", EnPassantRemovePiece
      3  053b				  -	      ERR
      4  053b					      ENDIF
      5  053b		       00 b4	   VAREND_EnPassantRemovePiece =	TEMPORARY_VAR
    401  053b
    402  053b
    403  053b							; Based on piece square, adjust material and position value with piece deleted
    404  053b							; y = piece square
    405  053b
    406  053b		       84 b2		      sty	__y
    407  053d
    408  053d		       a9 cc		      lda	#RAMBANK_BOARD
    409  053f		       85 3e		      sta	SET_BANK_RAM	;@3
    410  0541		       b9 79 fc 	      lda	Board,y
    411  0544		       85 b3		      sta	__col
    412  0546		       a2 91		      ldx	#BANK_AddPieceMaterialValue
    413  0548		       86 3f		      stx	SET_BANK	;@2
    414  054a		       20 0f f9 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
    415  054d
    416  054d		       a5 b3		      lda	__col
    417  054f		       a4 b2		      ldy	__y
    418  0551		       20 32 f9 	      jsr	AddPiecePositionValue	; (same bank) adding for opponent = taking
    419  0554
    420  0554		       60		      rts
    421  0555
    422  0555
    423  0555							;---------------------------------------------------------------------------------------------------
    424  0555
      0  0555					      ALLOCATE	FlipSquareIndex, 100
      0  0555					      OPTIONAL_PAGEBREAK	"Table", 100
     12  0555					      LIST	ON
      0  0555					      DEF	FlipSquareIndex
      1  0555				   SLOT_FlipSquareIndex SET	_BANK_SLOT
      2  0555				   BANK_FlipSquareIndex SET	SLOT_FlipSquareIndex + _CURRENT_BANK
      3  0555				   FlipSquareIndex
      4  0555				   TEMPORARY_VAR SET	Overlay
      5  0555				   TEMPORARY_OFFSET SET	0
      6  0555				   VAR_BOUNDARY_FlipSquareIndex SET	TEMPORARY_OFFSET
      7  0555				   FUNCTION_NAME SET	FlipSquareIndex
    426  0555
    427  0555		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    428  055f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    429  0569
    430  0569				   .SQBASE    SET	90-1
    431  0569					      REPEAT	8
    432  0569		       00 00		      .byte.b	0,0
    433  0569				   .SQX       SET	2
    434  056b					      REPEAT	8
    435  056b		       5b		      .byte.b	(.SQBASE+.SQX)
    436  056b				   .SQX       SET	.SQX + 1
    434  056b					      REPEND
    435  056c		       5c		      .byte.b	(.SQBASE+.SQX)
    436  056c				   .SQX       SET	.SQX + 1
    434  056c					      REPEND
    435  056d		       5d		      .byte.b	(.SQBASE+.SQX)
    436  056d				   .SQX       SET	.SQX + 1
    434  056d					      REPEND
    435  056e		       5e		      .byte.b	(.SQBASE+.SQX)
    436  056e				   .SQX       SET	.SQX + 1
    434  056e					      REPEND
    435  056f		       5f		      .byte.b	(.SQBASE+.SQX)
    436  056f				   .SQX       SET	.SQX + 1
    434  056f					      REPEND
    435  0570		       60		      .byte.b	(.SQBASE+.SQX)
    436  0570				   .SQX       SET	.SQX + 1
    434  0570					      REPEND
    435  0571		       61		      .byte.b	(.SQBASE+.SQX)
    436  0571				   .SQX       SET	.SQX + 1
    434  0571					      REPEND
    435  0572		       62		      .byte.b	(.SQBASE+.SQX)
    436  0572				   .SQX       SET	.SQX + 1
    437  0573					      REPEND
    438  0573				   .SQBASE    SET	.SQBASE - 10
    431  0573					      REPEND
    432  0573		       00 00		      .byte.b	0,0
    433  0573				   .SQX       SET	2
    434  0575					      REPEAT	8
    435  0575		       51		      .byte.b	(.SQBASE+.SQX)
    436  0575				   .SQX       SET	.SQX + 1
    434  0575					      REPEND
    435  0576		       52		      .byte.b	(.SQBASE+.SQX)
    436  0576				   .SQX       SET	.SQX + 1
    434  0576					      REPEND
    435  0577		       53		      .byte.b	(.SQBASE+.SQX)
    436  0577				   .SQX       SET	.SQX + 1
    434  0577					      REPEND
    435  0578		       54		      .byte.b	(.SQBASE+.SQX)
    436  0578				   .SQX       SET	.SQX + 1
    434  0578					      REPEND
    435  0579		       55		      .byte.b	(.SQBASE+.SQX)
    436  0579				   .SQX       SET	.SQX + 1
    434  0579					      REPEND
    435  057a		       56		      .byte.b	(.SQBASE+.SQX)
    436  057a				   .SQX       SET	.SQX + 1
    434  057a					      REPEND
    435  057b		       57		      .byte.b	(.SQBASE+.SQX)
    436  057b				   .SQX       SET	.SQX + 1
    434  057b					      REPEND
    435  057c		       58		      .byte.b	(.SQBASE+.SQX)
    436  057c				   .SQX       SET	.SQX + 1
    437  057d					      REPEND
    438  057d				   .SQBASE    SET	.SQBASE - 10
    431  057d					      REPEND
    432  057d		       00 00		      .byte.b	0,0
    433  057d				   .SQX       SET	2
    434  057f					      REPEAT	8
    435  057f		       47		      .byte.b	(.SQBASE+.SQX)
    436  057f				   .SQX       SET	.SQX + 1
    434  057f					      REPEND
    435  0580		       48		      .byte.b	(.SQBASE+.SQX)
    436  0580				   .SQX       SET	.SQX + 1
    434  0580					      REPEND
    435  0581		       49		      .byte.b	(.SQBASE+.SQX)
    436  0581				   .SQX       SET	.SQX + 1
    434  0581					      REPEND
    435  0582		       4a		      .byte.b	(.SQBASE+.SQX)
    436  0582				   .SQX       SET	.SQX + 1
    434  0582					      REPEND
    435  0583		       4b		      .byte.b	(.SQBASE+.SQX)
    436  0583				   .SQX       SET	.SQX + 1
    434  0583					      REPEND
    435  0584		       4c		      .byte.b	(.SQBASE+.SQX)
    436  0584				   .SQX       SET	.SQX + 1
    434  0584					      REPEND
    435  0585		       4d		      .byte.b	(.SQBASE+.SQX)
    436  0585				   .SQX       SET	.SQX + 1
    434  0585					      REPEND
    435  0586		       4e		      .byte.b	(.SQBASE+.SQX)
    436  0586				   .SQX       SET	.SQX + 1
    437  0587					      REPEND
    438  0587				   .SQBASE    SET	.SQBASE - 10
    431  0587					      REPEND
    432  0587		       00 00		      .byte.b	0,0
    433  0587				   .SQX       SET	2
    434  0589					      REPEAT	8
    435  0589		       3d		      .byte.b	(.SQBASE+.SQX)
    436  0589				   .SQX       SET	.SQX + 1
    434  0589					      REPEND
    435  058a		       3e		      .byte.b	(.SQBASE+.SQX)
    436  058a				   .SQX       SET	.SQX + 1
    434  058a					      REPEND
    435  058b		       3f		      .byte.b	(.SQBASE+.SQX)
    436  058b				   .SQX       SET	.SQX + 1
    434  058b					      REPEND
    435  058c		       40		      .byte.b	(.SQBASE+.SQX)
    436  058c				   .SQX       SET	.SQX + 1
    434  058c					      REPEND
    435  058d		       41		      .byte.b	(.SQBASE+.SQX)
    436  058d				   .SQX       SET	.SQX + 1
    434  058d					      REPEND
    435  058e		       42		      .byte.b	(.SQBASE+.SQX)
    436  058e				   .SQX       SET	.SQX + 1
    434  058e					      REPEND
    435  058f		       43		      .byte.b	(.SQBASE+.SQX)
    436  058f				   .SQX       SET	.SQX + 1
    434  058f					      REPEND
    435  0590		       44		      .byte.b	(.SQBASE+.SQX)
    436  0590				   .SQX       SET	.SQX + 1
    437  0591					      REPEND
    438  0591				   .SQBASE    SET	.SQBASE - 10
    431  0591					      REPEND
    432  0591		       00 00		      .byte.b	0,0
    433  0591				   .SQX       SET	2
    434  0593					      REPEAT	8
    435  0593		       33		      .byte.b	(.SQBASE+.SQX)
    436  0593				   .SQX       SET	.SQX + 1
    434  0593					      REPEND
    435  0594		       34		      .byte.b	(.SQBASE+.SQX)
    436  0594				   .SQX       SET	.SQX + 1
    434  0594					      REPEND
    435  0595		       35		      .byte.b	(.SQBASE+.SQX)
    436  0595				   .SQX       SET	.SQX + 1
    434  0595					      REPEND
    435  0596		       36		      .byte.b	(.SQBASE+.SQX)
    436  0596				   .SQX       SET	.SQX + 1
    434  0596					      REPEND
    435  0597		       37		      .byte.b	(.SQBASE+.SQX)
    436  0597				   .SQX       SET	.SQX + 1
    434  0597					      REPEND
    435  0598		       38		      .byte.b	(.SQBASE+.SQX)
    436  0598				   .SQX       SET	.SQX + 1
    434  0598					      REPEND
    435  0599		       39		      .byte.b	(.SQBASE+.SQX)
    436  0599				   .SQX       SET	.SQX + 1
    434  0599					      REPEND
    435  059a		       3a		      .byte.b	(.SQBASE+.SQX)
    436  059a				   .SQX       SET	.SQX + 1
    437  059b					      REPEND
    438  059b				   .SQBASE    SET	.SQBASE - 10
    431  059b					      REPEND
    432  059b		       00 00		      .byte.b	0,0
    433  059b				   .SQX       SET	2
    434  059d					      REPEAT	8
    435  059d		       29		      .byte.b	(.SQBASE+.SQX)
    436  059d				   .SQX       SET	.SQX + 1
    434  059d					      REPEND
    435  059e		       2a		      .byte.b	(.SQBASE+.SQX)
    436  059e				   .SQX       SET	.SQX + 1
    434  059e					      REPEND
    435  059f		       2b		      .byte.b	(.SQBASE+.SQX)
    436  059f				   .SQX       SET	.SQX + 1
    434  059f					      REPEND
    435  05a0		       2c		      .byte.b	(.SQBASE+.SQX)
    436  05a0				   .SQX       SET	.SQX + 1
    434  05a0					      REPEND
    435  05a1		       2d		      .byte.b	(.SQBASE+.SQX)
    436  05a1				   .SQX       SET	.SQX + 1
    434  05a1					      REPEND
    435  05a2		       2e		      .byte.b	(.SQBASE+.SQX)
    436  05a2				   .SQX       SET	.SQX + 1
    434  05a2					      REPEND
    435  05a3		       2f		      .byte.b	(.SQBASE+.SQX)
    436  05a3				   .SQX       SET	.SQX + 1
    434  05a3					      REPEND
    435  05a4		       30		      .byte.b	(.SQBASE+.SQX)
    436  05a4				   .SQX       SET	.SQX + 1
    437  05a5					      REPEND
    438  05a5				   .SQBASE    SET	.SQBASE - 10
    431  05a5					      REPEND
    432  05a5		       00 00		      .byte.b	0,0
    433  05a5				   .SQX       SET	2
    434  05a7					      REPEAT	8
    435  05a7		       1f		      .byte.b	(.SQBASE+.SQX)
    436  05a7				   .SQX       SET	.SQX + 1
    434  05a7					      REPEND
    435  05a8		       20		      .byte.b	(.SQBASE+.SQX)
    436  05a8				   .SQX       SET	.SQX + 1
    434  05a8					      REPEND
    435  05a9		       21		      .byte.b	(.SQBASE+.SQX)
    436  05a9				   .SQX       SET	.SQX + 1
    434  05a9					      REPEND
    435  05aa		       22		      .byte.b	(.SQBASE+.SQX)
    436  05aa				   .SQX       SET	.SQX + 1
    434  05aa					      REPEND
    435  05ab		       23		      .byte.b	(.SQBASE+.SQX)
    436  05ab				   .SQX       SET	.SQX + 1
    434  05ab					      REPEND
    435  05ac		       24		      .byte.b	(.SQBASE+.SQX)
    436  05ac				   .SQX       SET	.SQX + 1
    434  05ac					      REPEND
    435  05ad		       25		      .byte.b	(.SQBASE+.SQX)
    436  05ad				   .SQX       SET	.SQX + 1
    434  05ad					      REPEND
    435  05ae		       26		      .byte.b	(.SQBASE+.SQX)
    436  05ae				   .SQX       SET	.SQX + 1
    437  05af					      REPEND
    438  05af				   .SQBASE    SET	.SQBASE - 10
    431  05af					      REPEND
    432  05af		       00 00		      .byte.b	0,0
    433  05af				   .SQX       SET	2
    434  05b1					      REPEAT	8
    435  05b1		       15		      .byte.b	(.SQBASE+.SQX)
    436  05b1				   .SQX       SET	.SQX + 1
    434  05b1					      REPEND
    435  05b2		       16		      .byte.b	(.SQBASE+.SQX)
    436  05b2				   .SQX       SET	.SQX + 1
    434  05b2					      REPEND
    435  05b3		       17		      .byte.b	(.SQBASE+.SQX)
    436  05b3				   .SQX       SET	.SQX + 1
    434  05b3					      REPEND
    435  05b4		       18		      .byte.b	(.SQBASE+.SQX)
    436  05b4				   .SQX       SET	.SQX + 1
    434  05b4					      REPEND
    435  05b5		       19		      .byte.b	(.SQBASE+.SQX)
    436  05b5				   .SQX       SET	.SQX + 1
    434  05b5					      REPEND
    435  05b6		       1a		      .byte.b	(.SQBASE+.SQX)
    436  05b6				   .SQX       SET	.SQX + 1
    434  05b6					      REPEND
    435  05b7		       1b		      .byte.b	(.SQBASE+.SQX)
    436  05b7				   .SQX       SET	.SQX + 1
    434  05b7					      REPEND
    435  05b8		       1c		      .byte.b	(.SQBASE+.SQX)
    436  05b8				   .SQX       SET	.SQX + 1
    437  05b9					      REPEND
    438  05b9				   .SQBASE    SET	.SQBASE - 10
    439  05b9					      REPEND
    440  05b9
    441  05b9
    442  05b9							;---------------------------------------------------------------------------------------------------
    443  05b9
    444  05b9				  -	      IF	0
    445  05b9				  -	      DEF	SAFE_BackupBitmaps
    446  05b9				  -	      SUBROUTINE
    447  05b9				  -
    448  05b9				  -	      REFER	aiInCheckBackup
    449  05b9				  -	      VEND	SAFE_BackupBitmaps
    450  05b9				  -
    451  05b9				  -	      sty	SET_BANK_RAM
    452  05b9				  -	      jsr	SaveBitmap
    453  05b9				  -	      rts
    454  05b9					      ENDIF
    455  05b9
    456  05b9
    457  05b9							;---------------------------------------------------------------------------------------------------
    458  05b9
      0  05b9					      DEF	AddMoveSimple
      1  05b9				   SLOT_AddMoveSimple SET	_BANK_SLOT
      2  05b9				   BANK_AddMoveSimple SET	SLOT_AddMoveSimple + _CURRENT_BANK
      3  05b9				   AddMoveSimple
      4  05b9				   TEMPORARY_VAR SET	Overlay
      5  05b9				   TEMPORARY_OFFSET SET	0
      6  05b9				   VAR_BOUNDARY_AddMoveSimple SET	TEMPORARY_OFFSET
      7  05b9				   FUNCTION_NAME SET	AddMoveSimple
    460  05b9					      SUBROUTINE
    461  05b9
      0  05b9					      VEND	AddMoveSimple
      1  05b9				  -	      IFNCONST	AddMoveSimple
      2  05b9				  -	      ECHO	"Incorrect VEND label", AddMoveSimple
      3  05b9				  -	      ERR
      4  05b9					      ENDIF
      5  05b9		       00 a4	   VAREND_AddMoveSimple =	TEMPORARY_VAR
    463  05b9
    464  05b9							; add square in y register to movelist as destination (X12 format)
    465  05b9							; [y]		     to square (X12)
    466  05b9							; currentSquare     from square (X12)
    467  05b9							; currentPiece      piece.
    468  05b9							;   ENPASSANT flag set if pawn double-moving off opening rank
    469  05b9							; capture	     captured piece
    470  05b9
    471  05b9		       a5 9d		      lda	capture
    472  05bb		       d0 04		      bne	.always
    473  05bd		       a5 af		      lda	__quiesceCapOnly
    474  05bf		       d0 1a		      bne	.abort
    475  05c1
    476  05c1		       98	   .always    tya
    477  05c2
      0  05c2					      ldy@PLY	moveIndex
      1  05c2		       ac d0 f9 	      ldy	moveIndex
    479  05c5		       c8		      iny
      0  05c6					      sty@PLY	moveIndex
      1  05c6		       8c d0 fb 	      sty	[RAM]+moveIndex
    481  05c9
      0  05c9					      sta@PLY	MoveTo,y
      1  05c9		       99 64 fa 	      sta	[RAM]+MoveTo,y
    483  05cc		       a5 92		      lda	currentSquare
      0  05ce					      sta@PLY	MoveFrom,y
      1  05ce		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    485  05d1		       a5 91		      lda	currentPiece
      0  05d3					      sta@PLY	MovePiece,y
      1  05d3		       99 00 fb 	      sta	[RAM]+MovePiece,y
    487  05d6		       a5 9d		      lda	capture
      0  05d8					      sta@PLY	MoveCapture,y
      1  05d8		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    489  05db
    490  05db		       60	   .abort     rts
    491  05dc
    492  05dc
    493  05dc							;---------------------------------------------------------------------------------------------------
    494  05dc
      0  05dc					      DEF	aiSpecialMoveFixup
      1  05dc				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  05dc				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  05dc				   aiSpecialMoveFixup
      4  05dc				   TEMPORARY_VAR SET	Overlay
      5  05dc				   TEMPORARY_OFFSET SET	0
      6  05dc				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  05dc				   FUNCTION_NAME SET	aiSpecialMoveFixup
    496  05dc					      SUBROUTINE
    497  05dc
      0  05dc					      COMMON_VARS_ALPHABETA
      1  05dc
      0  05dc					      VAR	__thinkbar, 1
      1  05dc		       00 a4	   __thinkbar =	TEMPORARY_VAR
      2  05dc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05dc
      4  05dc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05dc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05dc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05dc					      ENDIF
      8  05dc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05dc				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  05dc				  -	      ERR
     11  05dc					      ENDIF
     12  05dc					      LIST	ON
      0  05dc					      VAR	__toggle, 1
      1  05dc		       00 a5	   __toggle   =	TEMPORARY_VAR
      2  05dc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05dc
      4  05dc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05dc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05dc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05dc					      ENDIF
      8  05dc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05dc				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  05dc				  -	      ERR
     11  05dc					      ENDIF
     12  05dc					      LIST	ON
      4  05dc
      0  05dc					      VAR	__bestMove, 1
      1  05dc		       00 a6	   __bestMove =	TEMPORARY_VAR
      2  05dc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05dc
      4  05dc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05dc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05dc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05dc					      ENDIF
      8  05dc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05dc				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  05dc				  -	      ERR
     11  05dc					      ENDIF
     12  05dc					      LIST	ON
      0  05dc					      VAR	__alpha, 2
      1  05dc		       00 a7	   __alpha    =	TEMPORARY_VAR
      2  05dc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  05dc
      4  05dc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05dc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05dc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05dc					      ENDIF
      8  05dc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05dc				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  05dc				  -	      ERR
     11  05dc					      ENDIF
     12  05dc					      LIST	ON
      0  05dc					      VAR	__beta, 2
      1  05dc		       00 a9	   __beta     =	TEMPORARY_VAR
      2  05dc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  05dc
      4  05dc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05dc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05dc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05dc					      ENDIF
      8  05dc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05dc				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  05dc				  -	      ERR
     11  05dc					      ENDIF
     12  05dc					      LIST	ON
      0  05dc					      VAR	__negaMax, 2
      1  05dc		       00 ab	   __negaMax  =	TEMPORARY_VAR
      2  05dc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  05dc
      4  05dc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05dc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05dc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05dc					      ENDIF
      8  05dc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05dc				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  05dc				  -	      ERR
     11  05dc					      ENDIF
     12  05dc					      LIST	ON
      0  05dc					      VAR	__value, 2
      1  05dc		       00 ad	   __value    =	TEMPORARY_VAR
      2  05dc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  05dc
      4  05dc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05dc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05dc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05dc					      ENDIF
      8  05dc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05dc				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  05dc				  -	      ERR
     11  05dc					      ENDIF
     12  05dc					      LIST	ON
     10  05dc
      0  05dc					      VAR	__quiesceCapOnly, 1
      1  05dc		       00 af	   __quiesceCapOnly =	TEMPORARY_VAR
      2  05dc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05dc
      4  05dc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05dc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05dc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05dc					      ENDIF
      8  05dc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  05dc				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  05dc				  -	      ERR
     11  05dc					      ENDIF
     12  05dc					      LIST	ON
     12  05dc
    499  05dc
      0  05dc					      REFER	AiStateMachine	;✅
      1  05dc				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  05dc				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  05dc					      ENDIF
    501  05dc
      0  05dc					      VEND	aiSpecialMoveFixup
      1  05dc				  -	      IFNCONST	aiSpecialMoveFixup
      2  05dc				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  05dc				  -	      ERR
      4  05dc					      ENDIF
      5  05dc		       00 b0	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    503  05dc
    504  05dc		       ad 84 02 	      lda	INTIM
    505  05df		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    506  05e1		       b0 01		      bcs	.cont
    507  05e3		       60		      rts
    508  05e4
    509  05e4
    510  05e4				   .cont
    511  05e4
      0  05e4					      PHASE	AI_DelayAfterPlaced
      1  05e4		       a9 27		      lda	#AI_DelayAfterPlaced
      2  05e6		       85 8b		      sta	aiState
    513  05e8
    514  05e8
    515  05e8							; Special move fixup
    516  05e8
    517  05e8				  -	      IF	ENPASSANT_ENABLED
    518  05e8				  -
    519  05e8				  -			; Handle en-passant captures
    520  05e8				  -			; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
    521  05e8				  -			; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
    522  05e8				  -			; need to do the appropriate things...
    523  05e8				  -
    524  05e8				  -	      jsr	EnPassantCheck
    525  05e8				  -
    526  05e8					      ENDIF
    527  05e8
    528  05e8
    529  05e8		       a5 94		      lda	currentPly
    530  05ea		       85 3e		      sta	SET_BANK_RAM
    531  05ec
    532  05ec		       20 f4 f5 	      jsr	CastleFixupDraw
    533  05ef
    534  05ef		       a5 85		      lda	fromX12
    535  05f1		       85 80		      sta	squareToDraw
    536  05f3
    537  05f3		       60		      rts
    538  05f4
    539  05f4
    540  05f4							;---------------------------------------------------------------------------------------------------
    541  05f4
      0  05f4					      DEF	CastleFixupDraw
      1  05f4				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  05f4				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  05f4				   CastleFixupDraw
      4  05f4				   TEMPORARY_VAR SET	Overlay
      5  05f4				   TEMPORARY_OFFSET SET	0
      6  05f4				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  05f4				   FUNCTION_NAME SET	CastleFixupDraw
    543  05f4					      SUBROUTINE
    544  05f4
      0  05f4					      REFER	aiSpecialMoveFixup	;✅
      1  05f4					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  05f4				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  05f4					      ENDIF
    546  05f4
      0  05f4					      VEND	CastleFixupDraw
      1  05f4				  -	      IFNCONST	CastleFixupDraw
      2  05f4				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  05f4				  -	      ERR
      4  05f4					      ENDIF
      5  05f4		       00 b0	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    548  05f4
    549  05f4							; fixup any castling issues
    550  05f4							; at this point the king has finished his two-square march
    551  05f4							; based on the finish square, we determine which rook we're interacting with
    552  05f4							; and generate a 'move' for the rook to position on the other side of the king
    553  05f4
    554  05f4
    555  05f4					      IF	CASTLING_ENABLED
      0  05f4					      CALL	GenCastleMoveForRook	;@3
      1  05f4				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  05f4				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  05f4				  -	      ECHO	"Cannot switch bank in use for", GenCastleMoveForRook
      4  05f4				  -	      ERR
      5  05f4					      ENDIF
      6  05f4		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      7  05f6		       85 3f		      sta	SET_BANK
      8  05f8		       20 21 fc 	      jsr	GenCastleMoveForRook
    557  05fb		       b0 07		      bcs	.phase
    558  05fd					      ENDIF
    559  05fd
      0  05fd					      SWAP
      1  05fd		       a5 95		      lda	sideToMove
      2  05ff		       49 80		      eor	#SWAP_SIDE
      3  0601		       85 95		      sta	sideToMove
      4  0603
      5  0603
    561  0603		       60		      rts
    562  0604
    563  0604				   .phase
    564  0604
    565  0604							; in this siutation (castle, rook moving) we do not change sides yet!
    566  0604
      0  0604					      PHASE	AI_MoveIsSelected
      1  0604		       a9 14		      lda	#AI_MoveIsSelected
      2  0606		       85 8b		      sta	aiState
    568  0608		       60		      rts
    569  0609
    570  0609
    571  0609
    572  0609		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    573  060d		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    574  0611		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    575  0615
    576  0615
    577  0615							;---------------------------------------------------------------------------------------------------
    578  0615
      0  0615					      DEF	aiDrawEntireBoard
      1  0615				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  0615				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  0615				   aiDrawEntireBoard
      4  0615				   TEMPORARY_VAR SET	Overlay
      5  0615				   TEMPORARY_OFFSET SET	0
      6  0615				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  0615				   FUNCTION_NAME SET	aiDrawEntireBoard
    580  0615					      SUBROUTINE
    581  0615
      0  0615					      REFER	AiStateMachine	;✅
      1  0615				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0615				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0615					      ENDIF
    583  0615
      0  0615					      VEND	aiDrawEntireBoard
      1  0615				  -	      IFNCONST	aiDrawEntireBoard
      2  0615				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  0615				  -	      ERR
      4  0615					      ENDIF
      5  0615		       00 a4	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    585  0615
    586  0615
    587  0615		       ad 84 02 	      lda	INTIM
    588  0618		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    589  061a		       90 2c		      bcc	.exit
    590  061c
    591  061c							; We use [SLOT3] for accessing board
    592  061c
    593  061c		       a9 cc		      lda	#RAMBANK_BOARD
    594  061e		       85 3e		      sta	SET_BANK_RAM
    595  0620		       a4 80		      ldy	squareToDraw
    596  0622		       b9 15 fc 	      lda	ValidSquare,y
    597  0625		       30 1d		      bmi	.isablank2
    598  0627
    599  0627		       b9 79 fc 	      lda	Board,y
    600  062a		       f0 13		      beq	.isablank
    601  062c		       48		      pha
    602  062d		       a9 00		      lda	#BLANK
      0  062f					      sta@RAM	Board,y
      1  062f		       99 79 fe 	      sta	[RAM]+Board,y
    604  0632
    605  0632		       20 c2 f0 	      jsr	CopySinglePiece	;@0
    606  0635
    607  0635		       a9 cc		      lda	#RAMBANK_BOARD
    608  0637		       85 3e		      sta	SET_BANK_RAM
    609  0639
    610  0639		       a4 80		      ldy	squareToDraw
    611  063b		       68		      pla
      0  063c					      sta@RAM	Board,y
      1  063c		       99 79 fe 	      sta	[RAM]+Board,y
    613  063f
      0  063f				   .isablank  PHASE	AI_DrawPart2
      1  063f		       a9 10		      lda	#AI_DrawPart2
      2  0641		       85 8b		      sta	aiState
    615  0643		       60		      rts
    616  0644
      0  0644				   .isablank2 PHASE	AI_DrawPart3
      1  0644		       a9 11		      lda	#AI_DrawPart3
      2  0646		       85 8b		      sta	aiState
    618  0648		       60	   .exit      rts
    619  0649
    620  0649
    621  0649							;---------------------------------------------------------------------------------------------------
    622  0649
    623  0649				  -	      IF	ENPASSANT_ENABLED
    624  0649				  -
    625  0649				  -	      DEF	EnPassantCheck
    626  0649				  -	      SUBROUTINE
    627  0649				  -
    628  0649				  -	      REFER	MakeMove	;✅
    629  0649				  -	      REFER	aiSpecialMoveFixup	;✅
    630  0649				  -	      VEND	EnPassantCheck
    631  0649				  -
    632  0649				  -			; {
    633  0649				  -			; With en-passant flag, it is essentially dual-use.
    634  0649				  -			; First, it marks if the move is *involved* somehow in an en-passant
    635  0649				  -			; if the piece has MOVED already, then it's an en-passant capture
    636  0649				  -			; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    637  0649				  -
    638  0649				  -	      ldy	enPassantPawn	; save from previous side move
    639  0649				  -
    640  0649				  -	      ldx	#0	; (probably) NO en-passant this time
    641  0649				  -	      lda	fromPiece
    642  0649				  -	      and	#FLAG_ENPASSANT|FLAG_MOVED
    643  0649				  -	      cmp	#FLAG_ENPASSANT
    644  0649				  -	      bne	.noep	; HAS moved, or not en-passant
    645  0649				  -
    646  0649				  -	      eor	fromPiece	; clear FLAG_ENPASSANT
    647  0649				  -	      sta	fromPiece
    648  0649				  -
    649  0649				  -	      ldx	fromX12	; this IS an en-passantable opening, so record the square
    650  0649				  -.noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
    651  0649				  -
    652  0649				  -			; }
    653  0649				  -
    654  0649				  -
    655  0649				  -			; Check to see if we are doing an actual en-passant capture...
    656  0649				  -
    657  0649				  -			; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
    658  0649				  -			;  as the en-passant will fail if the taking piece does not have this flag set correctly
    659  0649				  -
    660  0649				  -	      lda	fromPiece
    661  0649				  -	      and	#FLAG_ENPASSANT
    662  0649				  -	      beq	.notEnPassant	; not an en-passant, or it's enpassant by a MOVED piece
    663  0649				  -
    664  0649				  -
    665  0649				  -			; {
    666  0649				  -
    667  0649				  -			; Here we are the aggressor and we need to take the pawn 'en passant' fashion
    668  0649				  -			; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
    669  0649				  -
    670  0649				  -			; Remove the pawn from the board and piecelist, and undraw
    671  0649				  -
    672  0649				  -	      sty	squareToDraw
    673  0649				  -	      jsr	CopySinglePiece	;@0	      ; undraw captured pawn
    674  0649				  -
    675  0649				  -	      lda	#EVAL
    676  0649				  -	      sta	SET_BANK	;@3
    677  0649				  -
    678  0649				  -	      ldy	originX12	; taken pawn's square
    679  0649				  -	      jsr	EnPassantRemovePiece
    680  0649				  -
    681  0649				  -.notEnPassant
    682  0649				  -			; }
    683  0649				  -
    684  0649				  -	      rts
    685  0649				  -
    686  0649					      ENDIF
    687  0649
    688  0649
    689  0649							;---------------------------------------------------------------------------------------------------
    690  0649
      0  0649					      DEF	aiDrawPart2
      1  0649				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  0649				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  0649				   aiDrawPart2
      4  0649				   TEMPORARY_VAR SET	Overlay
      5  0649				   TEMPORARY_OFFSET SET	0
      6  0649				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  0649				   FUNCTION_NAME SET	aiDrawPart2
    692  0649					      SUBROUTINE
    693  0649
      0  0649					      REFER	AiStateMachine
      1  0649				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0649				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0649					      ENDIF
      0  0649					      VEND	aiDrawPart2
      1  0649				  -	      IFNCONST	aiDrawPart2
      2  0649				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  0649				  -	      ERR
      4  0649					      ENDIF
      5  0649		       00 a4	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
    696  0649
    697  0649		       20 c2 f0 	      jsr	CopySinglePiece	;@0
    698  064c
      0  064c					      DEF	aiDrawPart3
      1  064c				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  064c				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  064c				   aiDrawPart3
      4  064c				   TEMPORARY_VAR SET	Overlay
      5  064c				   TEMPORARY_OFFSET SET	0
      6  064c				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  064c				   FUNCTION_NAME SET	aiDrawPart3
    700  064c					      SUBROUTINE
    701  064c
    702  064c		       c6 80		      dec	squareToDraw
    703  064e		       a5 80		      lda	squareToDraw
    704  0650		       c9 16		      cmp	#22
    705  0652		       90 05		      bcc	.comp
    706  0654
      0  0654					      PHASE	AI_DrawEntireBoard
      1  0654		       a9 0f		      lda	#AI_DrawEntireBoard
      2  0656		       85 8b		      sta	aiState
    708  0658		       60		      rts
    709  0659
    710  0659				   .comp
    711  0659
    712  0659		       a9 ff		      lda	#-1
    713  065b		       85 86		      sta	toX12	; becomes startup flash square
    714  065d		       a9 24		      lda	#36	; becomes cursor position
    715  065f		       85 87		      sta	originX12
    716  0661
    717  0661
      0  0661					      PHASE	AI_GenerateMoves
      1  0661		       a9 12		      lda	#AI_GenerateMoves
      2  0663		       85 8b		      sta	aiState
    719  0665		       60		      rts
    720  0666
    721  0666
    722  0666							;---------------------------------------------------------------------------------------------------
    723  0666
      0  0666					      DEF	aiMarchB
      1  0666				   SLOT_aiMarchB SET	_BANK_SLOT
      2  0666				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  0666				   aiMarchB
      4  0666				   TEMPORARY_VAR SET	Overlay
      5  0666				   TEMPORARY_OFFSET SET	0
      6  0666				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  0666				   FUNCTION_NAME SET	aiMarchB
    725  0666					      SUBROUTINE
    726  0666
      0  0666					      REFER	AiStateMachine
      1  0666				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0666				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0666					      ENDIF
      0  0666					      VEND	aiMarchB
      1  0666				  -	      IFNCONST	aiMarchB
      2  0666				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  0666				  -	      ERR
      4  0666					      ENDIF
      5  0666		       00 a4	   VAREND_aiMarchB =	TEMPORARY_VAR
    729  0666
    730  0666							; Draw the piece in the new square
    731  0666
    732  0666		       a5 85		      lda	fromX12
    733  0668		       85 80		      sta	squareToDraw
    734  066a
    735  066a		       20 c2 f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
    736  066d
    737  066d		       a9 0a		      lda	#10	; snail trail delay ??
    738  066f		       85 82		      sta	drawDelay
    739  0671
      0  0671					      PHASE	AI_MarchToTargetB
      1  0671		       a9 19		      lda	#AI_MarchToTargetB
      2  0673		       85 8b		      sta	aiState
    741  0675		       60		      rts
    742  0676
    743  0676
    744  0676							;---------------------------------------------------------------------------------------------------
    745  0676
      0  0676					      DEF	aiDraw
      1  0676				   SLOT_aiDraw SET	_BANK_SLOT
      2  0676				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  0676				   aiDraw
      4  0676				   TEMPORARY_VAR SET	Overlay
      5  0676				   TEMPORARY_OFFSET SET	0
      6  0676				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  0676				   FUNCTION_NAME SET	aiDraw
    747  0676					      SUBROUTINE
    748  0676		       a9 c0		      lda	#$C0
    749  0678		       85 49		      sta	COLUBK
    750  067a		       60		      rts
    751  067b
    752  067b
    753  067b							;---------------------------------------------------------------------------------------------------
    754  067b
      0  067b					      DEF	aiCheckMate
      1  067b				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  067b				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  067b				   aiCheckMate
      4  067b				   TEMPORARY_VAR SET	Overlay
      5  067b				   TEMPORARY_OFFSET SET	0
      6  067b				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  067b				   FUNCTION_NAME SET	aiCheckMate
    756  067b					      SUBROUTINE
    757  067b		       a9 44		      lda	#$44
    758  067d		       85 49		      sta	COLUBK
    759  067f		       60		      rts
    760  0680
    761  0680							;---------------------------------------------------------------------------------------------------
    762  0680
      0  0680					      CHECK_BANK_SIZE	"BANK_GENERIC@1#1"
      1  0680		       02 80	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@1#1 (1K) SIZE =  $280 , FREE= $180
      2  0680					      ECHO	"BANK_GENERIC@1#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  0680				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0680				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@1#1", " size=", * - ORIGIN
      5  0680				  -	      ERR
      6  0680					      ENDIF
    764  0680
    765  0680							;---------------------------------------------------------------------------------------------------
    766  0680							; EOF
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 4
      0  0680					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  0680
      0  0680					      SLOT	2
      1  0680				  -	      IF	(2 < 0) || (2 > 3)
      2  0680				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0680				  -	      ERR
      4  0680					      ENDIF
      5  0680				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0680				   _BANK_SLOT SET	2 * 64
      0  0680					      NEWBANK	BITMAP
      1  09a6 ????				      SEG	BITMAP
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   BITMAP_START SET	*
      6  0800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0800				   BITMAP     SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + 1024
      4  0800
      5  0800							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
      6  0800
      7  0800		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
      8  0800
      9  0800		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     10  0800		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     11  0800		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     12  0800		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     13  0800		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     14  0800		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     15  0800
     16  0800							; Template bank for a SINGLE ROW of the chessboard display.
     17  0800							; There are 8x of these.
     18  0800							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     19  0800							; The bank is copied from ROM into RAM at startup.
     20  0800							; The draw switches between consecutive row banks, with the last returning
     21  0800							; we effectively have 1K
     22  0800							;---------------------------------------------------------------------------------------------------
     23  0800
     24  0800		       00 82	   COLOUR_LINE_1 =	$82
     25  0800		       00 36	   COLOUR_LINE_2 =	$36
     26  0800		       00 28	   COLOUR_LINE_3 =	$28
     27  0800		       00 00	   BACKGCOL   =	$00
     28  0800
     29  0800
     30  0800		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     31  0800
     32  0800
      0  0800					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      0  0800					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0800					      LIST	ON
      0  0800					      DEF	SHADOW_ChessBitmap
      1  0800				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  0800				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  0800				   SHADOW_ChessBitmap
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	SHADOW_ChessBitmap
     34  0800		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     35  0818		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     36  0830		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     37  0848		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     38  0860		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     39  0878		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     40  0890
      0  0890					      ALLOCATE	BlankSprite, 8
      0  0890					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0890					      LIST	ON
      0  0890					      DEF	BlankSprite
      1  0890				   SLOT_BlankSprite SET	_BANK_SLOT
      2  0890				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  0890				   BlankSprite
      4  0890				   TEMPORARY_VAR SET	Overlay
      5  0890				   TEMPORARY_OFFSET SET	0
      6  0890				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  0890				   FUNCTION_NAME SET	BlankSprite
     42  0890		       00 00 00 00*	      ds	8, 0
     43  0898
      0  0898					      ALLOCATE	SpriteBuffer, 8
      0  0898					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0898					      LIST	ON
      0  0898					      DEF	SpriteBuffer
      1  0898				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  0898				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  0898				   SpriteBuffer
      4  0898				   TEMPORARY_VAR SET	Overlay
      5  0898				   TEMPORARY_OFFSET SET	0
      6  0898				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  0898				   FUNCTION_NAME SET	SpriteBuffer
     45  0898				   SpriteBuffer2
     46  0898		       f8		      .byte.b	%11111000
     47  0899		       f8		      .byte.b	%11111000
     48  089a		       f8		      .byte.b	%11111000
     49  089b		       f8		      .byte.b	%11111000
     50  089c		       f8		      .byte.b	%11111000
     51  089d		       f8		      .byte.b	%11111000
     52  089e		       f8		      .byte.b	%11111000
     53  089f		       f8		      .byte.b	%11111000
     54  08a0
     55  08a0				  -	      IF	0
     56  08a0				  -	      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
     57  08a0				  -	      ds	ROW_BITMAP_SIZE, 0
     58  08a0					      ENDIF
     59  08a0
     60  08a0							;---------------------------------------------------------------------------------------------------
     61  08a0
     62  0900		       00 00 00 00*	      ALIGN	256
     63  0900					      SUBROUTINE
     64  0900
      0  0900					      REFER	StartupBankReset
      1  0900				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0900				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0900					      ENDIF
     66  0900				   __dummy
      0  0900					      VEND	__dummy
      1  0900				  -	      IFNCONST	__dummy
      2  0900				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0900				  -	      ERR
      4  0900					      ENDIF
      5  0900		       00 a4	   VAREND___dummy =	TEMPORARY_VAR
     68  0900
     69  0900							; x = row # (and bank#)
     70  0900
     71  0900				   .endline
     72  0900
     73  0900							;@59
     74  0900
     75  0900							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
     76  0900							; Note that the other 7 row banks are unmodified (keeping the 'inx')
     77  0900				   SELFMOD_RTS_ON_LAST_ROW
     78  0900
     79  0900		       e8		      inx		; 2
     80  0901		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
     81  0903
      0  0903					      DEF	DrawRow
      1  0903				   SLOT_DrawRow SET	_BANK_SLOT
      2  0903				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  0903				   DrawRow
      4  0903				   TEMPORARY_VAR SET	Overlay
      5  0903				   TEMPORARY_OFFSET SET	0
      6  0903				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  0903				   FUNCTION_NAME SET	DrawRow
     83  0903
     84  0903							;@64
     85  0903		       a0 07		      ldy	#7	; 2
     86  0905		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
     87  0907
     88  0907							;@58...
     89  0907
     90  0907				   .l3
     91  0907
     92  0907		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
     93  090a		       85 5b		      sta	GRP0	; 3
     94  090c		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
     95  090f		       85 5c		      sta	GRP1	; 3
     96  0911
     97  0911							;@-4
     98  0911
     99  0911		       a9 82		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    100  0913		       85 48		      sta	COLUPF	; 3 @1
    101  0915
    102  0915		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    103  0918		       85 4d		      sta	PF0	; 3
    104  091a		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    105  091d		       85 4e		      sta	PF1	; 3
    106  091f		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    107  0922		       85 4f		      sta	PF2	; 3 @22
    108  0924
      0  0924					      SLEEP	6	; 6 @28
      1  0924				   .CYCLES    SET	6
      2  0924
      3  0924				  -	      IF	.CYCLES < 2
      4  0924				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0924				  -	      ERR
      6  0924					      ENDIF
      7  0924
      8  0924				  -	      IF	.CYCLES & 1
      9  0924				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0924				  -	      nop	0
     11  0924				  -	      ELSE
     12  0924				  -	      bit	VSYNC
     13  0924				  -	      ENDIF
     14  0924				  -.CYCLES    SET	.CYCLES - 3
     15  0924					      ENDIF
     16  0924
     17  0924					      REPEAT	.CYCLES / 2
     18  0924		       ea		      nop
     17  0924					      REPEND
     18  0925		       ea		      nop
     17  0925					      REPEND
     18  0926		       ea		      nop
     19  0927					      REPEND
    110  0927
    111  0927		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    112  092a		       85 4d		      sta	PF0	; 3
    113  092c		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    114  092f		       85 4e		      sta	PF1	; 3
    115  0931		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    116  0934		       8d 4f 00 	      sta.w	PF2	; 4 @50
    117  0937
      0  0937					      SLEEP	4	; 4
      1  0937				   .CYCLES    SET	4
      2  0937
      3  0937				  -	      IF	.CYCLES < 2
      4  0937				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0937				  -	      ERR
      6  0937					      ENDIF
      7  0937
      8  0937				  -	      IF	.CYCLES & 1
      9  0937				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0937				  -	      nop	0
     11  0937				  -	      ELSE
     12  0937				  -	      bit	VSYNC
     13  0937				  -	      ENDIF
     14  0937				  -.CYCLES    SET	.CYCLES - 3
     15  0937					      ENDIF
     16  0937
     17  0937					      REPEAT	.CYCLES / 2
     18  0937		       ea		      nop
     17  0937					      REPEND
     18  0938		       ea		      nop
     19  0939					      REPEND
    119  0939
    120  0939		       88		      dey		; 2
    121  093a		       30 c4		      bmi	.endline	; 2 (3)
    122  093c
    123  093c							;@57
    124  093c				   .drawLine
    125  093c
      0  093c					      SLEEP	11
      1  093c				   .CYCLES    SET	11
      2  093c
      3  093c				  -	      IF	.CYCLES < 2
      4  093c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  093c				  -	      ERR
      6  093c					      ENDIF
      7  093c
      8  093c					      IF	.CYCLES & 1
      9  093c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  093c		       04 00		      nop	0
     11  093e				  -	      ELSE
     12  093e				  -	      bit	VSYNC
     13  093e					      ENDIF
     14  093e				   .CYCLES    SET	.CYCLES - 3
     15  093e					      ENDIF
     16  093e
     17  093e					      REPEAT	.CYCLES / 2
     18  093e		       ea		      nop
     17  093e					      REPEND
     18  093f		       ea		      nop
     17  093f					      REPEND
     18  0940		       ea		      nop
     17  0940					      REPEND
     18  0941		       ea		      nop
     19  0942					      REPEND
    127  0942
    128  0942				   .dl2
    129  0942		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    130  0945		       85 5b		      sta	GRP0	; 3
    131  0947		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    132  094a		       85 5c		      sta	GRP1	; 3
    133  094c
    134  094c							;@7
    135  094c
    136  094c		       a9 36		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    137  094e		       85 48		      sta	COLUPF	; 3 @12
    138  0950
    139  0950		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    140  0953		       85 4d		      sta	PF0	; 3
    141  0955		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    142  0958		       85 4e		      sta	PF1	; 3
    143  095a		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    144  095d		       85 4f		      sta	PF2	; 3 @33
    145  095f
      0  095f					      SLEEP	3	; 3 @36
      1  095f				   .CYCLES    SET	3
      2  095f
      3  095f				  -	      IF	.CYCLES < 2
      4  095f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  095f				  -	      ERR
      6  095f					      ENDIF
      7  095f
      8  095f					      IF	.CYCLES & 1
      9  095f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  095f		       04 00		      nop	0
     11  0961				  -	      ELSE
     12  0961				  -	      bit	VSYNC
     13  0961					      ENDIF
     14  0961				   .CYCLES    SET	.CYCLES - 3
     15  0961					      ENDIF
     16  0961
     17  0961				  -	      REPEAT	.CYCLES / 2
     18  0961				  -	      nop
     19  0961					      REPEND
    147  0961
    148  0961		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    149  0964		       85 4d		      sta	PF0	; 3
    150  0966		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    151  0969		       85 4e		      sta	PF1	; 3
    152  096b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    153  096e		       85 4f		      sta	PF2	; 3 @57
    154  0970
      0  0970					      SLEEP	5
      1  0970				   .CYCLES    SET	5
      2  0970
      3  0970				  -	      IF	.CYCLES < 2
      4  0970				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0970				  -	      ERR
      6  0970					      ENDIF
      7  0970
      8  0970					      IF	.CYCLES & 1
      9  0970					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0970		       04 00		      nop	0
     11  0972				  -	      ELSE
     12  0972				  -	      bit	VSYNC
     13  0972					      ENDIF
     14  0972				   .CYCLES    SET	.CYCLES - 3
     15  0972					      ENDIF
     16  0972
     17  0972					      REPEAT	.CYCLES / 2
     18  0972		       ea		      nop
     19  0973					      REPEND
    156  0973
    157  0973		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    158  0976		       85 5b		      sta	GRP0	; 3
    159  0978		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    160  097b		       85 5c		      sta	GRP1	; 3
    161  097d
    162  097d							;@0
    163  097d		       a9 28		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    164  097f		       85 48		      sta	COLUPF	; 3 @5
    165  0981
    166  0981		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    167  0984		       85 4d		      sta	PF0	; 3
    168  0986		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    169  0989		       85 4e		      sta	PF1	; 3
    170  098b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    171  098e		       85 4f		      sta	PF2	; 3 @26
    172  0990
      0  0990					      SLEEP	8	; 6 @34
      1  0990				   .CYCLES    SET	8
      2  0990
      3  0990				  -	      IF	.CYCLES < 2
      4  0990				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0990				  -	      ERR
      6  0990					      ENDIF
      7  0990
      8  0990				  -	      IF	.CYCLES & 1
      9  0990				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0990				  -	      nop	0
     11  0990				  -	      ELSE
     12  0990				  -	      bit	VSYNC
     13  0990				  -	      ENDIF
     14  0990				  -.CYCLES    SET	.CYCLES - 3
     15  0990					      ENDIF
     16  0990
     17  0990					      REPEAT	.CYCLES / 2
     18  0990		       ea		      nop
     17  0990					      REPEND
     18  0991		       ea		      nop
     17  0991					      REPEND
     18  0992		       ea		      nop
     17  0992					      REPEND
     18  0993		       ea		      nop
     19  0994					      REPEND
    174  0994
    175  0994		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    176  0997		       85 4d		      sta	PF0	; 3
    177  0999		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    178  099c		       85 4e		      sta	PF1	; 3
    179  099e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    180  09a1		       85 4f		      sta	PF2	; 3 @55
    181  09a3
    182  09a3		       4c 07 f9 	      jmp	.l3	; 3 @58
    183  09a6
    184  09a6
    185  09a6
    186  09a6							;---------------------------------------------------------------------------------------------------
    187  09a6
      0  09a6					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  09a6		       01 a6	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $1a6 , FREE= $5a
      2  09a6					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  09a6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  09a6				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  09a6				  -	      ERR
      6  09a6					      ENDIF
    189  09a6
    190  09a6							;---------------------------------------------------------------------------------------------------
    191  09a6							;EOF
------- FILE ./chess.asm
------- FILE ROM_SCREEN@3.asm LEVEL 2 PASS 4
      0  09a6					      include	"ROM_SCREEN@3.asm"
      1  09a6
      0  09a6					      SLOT	3
      1  09a6				  -	      IF	(3 < 0) || (3 > 3)
      2  09a6				  -	      ECHO	"Illegal bank address/segment location", 3
      3  09a6				  -	      ERR
      4  09a6					      ENDIF
      5  09a6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  09a6				   _BANK_SLOT SET	3 * 64
      0  09a6					      NEWBANK	ROM_SCREEN
      1  0c5c ????				      SEG	ROM_SCREEN
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   ROM_SCREEN_START SET	*
      6  0c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0c00				   ROM_SCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + 1024
      4  0c00
      5  0c00							;---------------------------------------------------------------------------------------------------
      6  0c00
      0  0c00					      DEF	ClearRowBitmap
      1  0c00				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  0c00				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  0c00				   ClearRowBitmap
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	ClearRowBitmap
      8  0c00					      SUBROUTINE
      9  0c00
      0  0c00					      REFER	CallClear
      1  0c00				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  0c00				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  0c00					      ENDIF
      0  0c00					      VEND	ClearRowBitmap
      1  0c00				  -	      IFNCONST	ClearRowBitmap
      2  0c00				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  0c00				  -	      ERR
      4  0c00					      ENDIF
      5  0c00		       00 a4	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     12  0c00
     13  0c00							; No transient variable dependencies/calls
     14  0c00
     15  0c00		       a9 00		      lda	#0
     16  0c02		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  0c04				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  0c04		       99 ff f9 	      sta	[RAM]+ChessBitmap-1,y
     18  0c07		       88		      dey
     19  0c08		       d0 fa		      bne	.clearRow
     20  0c0a		       60		      rts
     21  0c0b
     22  0c0b
     23  0c0b							;---------------------------------------------------------------------------------------------------
     24  0c0b
     25  0c0b					      IF	1
      0  0c0b					      DEF	WriteBlank
      1  0c0b				   SLOT_WriteBlank SET	_BANK_SLOT
      2  0c0b				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  0c0b				   WriteBlank
      4  0c0b				   TEMPORARY_VAR SET	Overlay
      5  0c0b				   TEMPORARY_OFFSET SET	0
      6  0c0b				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  0c0b				   FUNCTION_NAME SET	WriteBlank
     27  0c0b					      SUBROUTINE
     28  0c0b
      0  0c0b					      REFER	StartupBankReset
      1  0c0b				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c0b				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c0b					      ENDIF
      0  0c0b					      VEND	WriteBlank
      1  0c0b				  -	      IFNCONST	WriteBlank
      2  0c0b				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  0c0b				  -	      ERR
      4  0c0b					      ENDIF
      5  0c0b		       00 a4	   VAREND_WriteBlank =	TEMPORARY_VAR
     31  0c0b
     32  0c0b		       a9 90		      lda	#<BlankSprite
      0  0c0d					      sta@RAM	SMSPRITE0_0+1
      1  0c0d		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c10					      sta@RAM	SMSPRITE8_0+1
      1  0c10		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c13					      sta@RAM	SMSPRITE16_0+1
      1  0c13		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
      0  0c16					      sta@RAM	SMSPRITE0_1+1
      1  0c16		       8d 48 fb 	      sta	[RAM]+SMSPRITE0_1+1
      0  0c19					      sta@RAM	SMSPRITE8_1+1
      1  0c19		       8d 79 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  0c1c					      sta@RAM	SMSPRITE16_1+1
      1  0c1c		       8d 0d fb 	      sta	[RAM]+SMSPRITE16_1+1
     39  0c1f
     40  0c1f		       a9 f8		      lda	#>BlankSprite
      0  0c21					      sta@RAM	SMSPRITE0_0+2
      1  0c21		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c24					      sta@RAM	SMSPRITE8_0+2
      1  0c24		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c27					      sta@RAM	SMSPRITE16_0+2
      1  0c27		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
      0  0c2a					      sta@RAM	SMSPRITE0_1+2
      1  0c2a		       8d 49 fb 	      sta	[RAM]+SMSPRITE0_1+2
      0  0c2d					      sta@RAM	SMSPRITE8_1+2
      1  0c2d		       8d 7a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  0c30					      sta@RAM	SMSPRITE16_1+2
      1  0c30		       8d 0e fb 	      sta	[RAM]+SMSPRITE16_1+2
     47  0c33
     48  0c33		       60		      rts
     49  0c34					      ENDIF
     50  0c34
     51  0c34							;---------------------------------------------------------------------------------------------------
     52  0c34
     53  0c34					      IF	1
      0  0c34					      DEF	WriteCursor
      1  0c34				   SLOT_WriteCursor SET	_BANK_SLOT
      2  0c34				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  0c34				   WriteCursor
      4  0c34				   TEMPORARY_VAR SET	Overlay
      5  0c34				   TEMPORARY_OFFSET SET	0
      6  0c34				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  0c34				   FUNCTION_NAME SET	WriteCursor
     55  0c34					      SUBROUTINE
     56  0c34
      0  0c34					      REFER	StartupBankReset
      1  0c34				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0c34				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0c34					      ENDIF
      0  0c34					      VEND	WriteCursor
      1  0c34				  -	      IFNCONST	WriteCursor
      2  0c34				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  0c34				  -	      ERR
      4  0c34					      ENDIF
      5  0c34		       00 a4	   VAREND_WriteCursor =	TEMPORARY_VAR
     59  0c34
     60  0c34		       38		      sec
     61  0c35		       a5 88		      lda	cursorX12
     62  0c37		       30 22		      bmi	.exit
     63  0c39		       a2 0a		      ldx	#10
     64  0c3b		       e9 0a	   .sub10     sbc	#10
     65  0c3d		       ca		      dex
     66  0c3e		       b0 fb		      bcs	.sub10
     67  0c40
     68  0c40		       8a		      txa
     69  0c41		       69 80		      adc	#SLOT_DrawRow	;cc implied
     70  0c43		       85 3e		      sta	SET_BANK_RAM
     71  0c45
     72  0c45		       a9 98		      lda	#<SpriteBuffer
      0  0c47					      sta@RAM	SMSPRITE0_0+1
      1  0c47		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  0c4a					      sta@RAM	SMSPRITE8_0+1
      1  0c4a		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  0c4d					      sta@RAM	SMSPRITE16_0+1
      1  0c4d		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
     76  0c50		       a9 f8		      lda	#>SpriteBuffer
      0  0c52					      sta@RAM	SMSPRITE0_0+2
      1  0c52		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  0c55					      sta@RAM	SMSPRITE8_0+2
      1  0c55		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  0c58					      sta@RAM	SMSPRITE16_0+2
      1  0c58		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
     80  0c5b
     81  0c5b		       60	   .exit      rts
     82  0c5c					      ENDIF
     83  0c5c
     84  0c5c
     85  0c5c							;---------------------------------------------------------------------------------------------------
     86  0c5c
     87  0c5c				  -	      IF	0
     88  0c5c				  -	      DEF	SaveBitmap
     89  0c5c				  -	      SUBROUTINE
     90  0c5c				  -
     91  0c5c				  -	      REFER	SAFE_BackupBitmaps
     92  0c5c				  -	      VEND	SaveBitmap
     93  0c5c				  -
     94  0c5c				  -	      ldy	#71
     95  0c5c				  -.fromTo    lda	ChessBitmap,y
     96  0c5c				  -	      sta@RAM	BackupBitmap,y
     97  0c5c				  -	      lda	ChessBitmap+72,y
     98  0c5c				  -	      sta@RAM	BackupBitmap+72,y
     99  0c5c				  -	      dey
    100  0c5c				  -	      bpl	.fromTo
    101  0c5c				  -	      rts
    102  0c5c					      ENDIF
    103  0c5c
    104  0c5c							;---------------------------------------------------------------------------------------------------
    105  0c5c
    106  0c5c				  -	      IF	0
    107  0c5c				  -
    108  0c5c				  -	      DEF	RestoreBitmap
    109  0c5c				  -	      SUBROUTINE
    110  0c5c				  -
    111  0c5c				  -	      VEND	RestoreBitmap
    112  0c5c				  -
    113  0c5c				  -	      ldy	#71
    114  0c5c				  -.fromTo    lda	BackupBitmap,y
    115  0c5c				  -	      sta@RAM	ChessBitmap,y
    116  0c5c				  -	      lda	BackupBitmap+72,y
    117  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    118  0c5c				  -	      dey
    119  0c5c				  -	      bpl	.fromTo
    120  0c5c				  -	      rts
    121  0c5c					      ENDIF
    122  0c5c
    123  0c5c							;---------------------------------------------------------------------------------------------------
    124  0c5c
    125  0c5c				  -	      IF	0
    126  0c5c				  -
    127  0c5c				  -	      DEF	CopyTextToRowBitmap
    128  0c5c				  -	      SUBROUTINE
    129  0c5c				  -
    130  0c5c				  -	      VEND	CopyTextToRowBitmap
    131  0c5c				  -
    132  0c5c				  -			; An OR-draw, used for placing matricies/text onscreen
    133  0c5c				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    134  0c5c				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    135  0c5c				  -			; in original state once text disappears
    136  0c5c				  -
    137  0c5c				  -	      ldy	#71
    138  0c5c				  -	      bcs	.rightSide
    139  0c5c				  -
    140  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    141  0c5c				  -	      ora	ChessBitmap,y
    142  0c5c				  -	      sta@RAM	ChessBitmap,y
    143  0c5c				  -	      dey
    144  0c5c				  -	      bpl	.copy
    145  0c5c				  -
    146  0c5c				  -	      rts
    147  0c5c				  -
    148  0c5c				  -.rightSide
    149  0c5c				  -
    150  0c5c				  -	      SUBROUTINE
    151  0c5c				  -
    152  0c5c				  -.copy      lda	__pieceShapeBuffer,y
    153  0c5c				  -	      ora	ChessBitmap+72,y
    154  0c5c				  -	      sta@RAM	ChessBitmap+72,y
    155  0c5c				  -	      dey
    156  0c5c				  -	      bpl	.copy
    157  0c5c				  -
    158  0c5c				  -	      rts
    159  0c5c				  -
    160  0c5c					      ENDIF
    161  0c5c
    162  0c5c							;---------------------------------------------------------------------------------------------------
    163  0c5c
      0  0c5c					      CHECK_RAM_BANK_SIZE	"ROM_SCREEN@3"
      1  0c5c		       00 5c	   .TEMP      =	* - _BANK_START
 ROM_SCREEN@3 (512 byte) SIZE =  $5c , FREE= $1a4
      2  0c5c					      ECHO	"ROM_SCREEN@3", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  0c5c				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  0c5c				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SCREEN@3", " size=", * - ORIGIN
      5  0c5c				  -	      ERR
      6  0c5c					      ENDIF
    165  0c5c
    166  0c5c							;---------------------------------------------------------------------------------------------------
    167  0c5c							;EOF
------- FILE ./chess.asm
------- FILE SHADOW_PLY.asm LEVEL 2 PASS 4
      0  0c5c					      include	"SHADOW_PLY.asm"
      1  0c5c							; Chess
      2  0c5c							; Copyright (c) 2019-2020 Andrew Davie
      3  0c5c							; andrew@taswegian.com
      4  0c5c
      5  0c5c
      6  0c5c							;---------------------------------------------------------------------------------------------------
      7  0c5c							; Define the RAM banks
      8  0c5c							; A "PLY" bank represents all the data required on any single ply of the search tree.
      9  0c5c							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     10  0c5c							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     11  0c5c							; they act as independant switchable banks usable for data on each ply during the search.
     12  0c5c							; A ply will hold the move list for that position
     13  0c5c
     14  0c5c
      0  0c5c					      SLOT	2
      1  0c5c				  -	      IF	(2 < 0) || (2 > 3)
      2  0c5c				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0c5c				  -	      ERR
      4  0c5c					      ENDIF
      5  0c5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0c5c				   _BANK_SLOT SET	2 * 64
      0  0c5c					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  0c5c
      2  0c5c
      3  0c5c
      4 U21de ????				      SEG.U	PLY
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2000				   _BANK_START SET	*
      8 U2000				   RAMBANK_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U2000
     18 U2000							;---------------------------------------------------------------------------------------------------
     19 U2000
     20 U2000		       00 64	   MAX_MOVES  =	100	; big is good
     21 U2000
      0 U2000					      VARIABLE	MoveFrom, MAX_MOVES
      0 U2000					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2000					      LIST	ON
      2 U2000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0 U2064					      VARIABLE	MoveTo, MAX_MOVES
      0 U2064					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2064					      LIST	ON
      2 U2064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0 U20c8					      VARIABLE	MovePiece, MAX_MOVES
      0 U20c8					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2100					      LIST	ON
      2 U2100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0 U2164					      VARIABLE	MoveCapture, MAX_MOVES
      0 U2164					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U2164					      LIST	ON
      2 U2164		       00 00 00 00*MoveCapture ds	MAX_MOVES
     26 U21c8
     27 U21c8
     28 U21c8							;---------------------------------------------------------------------------------------------------
     29 U21c8
     30 U21c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     31 U21c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     32 U21c8
      0 U21c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0 U21c8					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21c8					      LIST	ON
      2 U21c8		       00 00	   savedEvaluation ds	2
      0 U21ca					      VARIABLE	enPassantSquare, 1
      0 U21ca					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ca					      LIST	ON
      2 U21ca		       00	   enPassantSquare ds	1
      0 U21cb					      VARIABLE	capturedPiece, 1
      0 U21cb					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cb					      LIST	ON
      2 U21cb		       00	   capturedPiece ds	1
      0 U21cc					      VARIABLE	originalPiece, 1
      0 U21cc					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cc					      LIST	ON
      2 U21cc		       00	   originalPiece ds	1
      0 U21cd					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0 U21cd					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cd					      LIST	ON
      2 U21cd		       00	   secondaryPiece ds	1
      0 U21ce					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0 U21ce					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21ce					      LIST	ON
      2 U21ce		       00	   secondarySquare ds	1
      0 U21cf					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0 U21cf					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21cf					      LIST	ON
      2 U21cf		       00	   secondaryBlank ds	1
      0 U21d0					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0 U21d0					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d0					      LIST	ON
      2 U21d0		       00	   moveIndex  ds	1
      0 U21d1					      VARIABLE	movePtr, 1
      0 U21d1					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d1					      LIST	ON
      2 U21d1		       00	   movePtr    ds	1
      0 U21d2					      VARIABLE	bestMove, 1
      0 U21d2					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d2					      LIST	ON
      2 U21d2		       00	   bestMove   ds	1
      0 U21d3					      VARIABLE	alpha, 2
      0 U21d3					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d3					      LIST	ON
      2 U21d3		       00 00	   alpha      ds	2
      0 U21d5					      VARIABLE	beta, 2
      0 U21d5					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d5					      LIST	ON
      2 U21d5		       00 00	   beta       ds	2
      0 U21d7					      VARIABLE	value, 2
      0 U21d7					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U21d7					      LIST	ON
      2 U21d7		       00 00	   value      ds	2
      0 U21d9					      VARIABLE	depthLeft, 1
      0 U21d9					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21d9					      LIST	ON
      2 U21d9		       00	   depthLeft  ds	1
      0 U21da					      VARIABLE	restorePiece, 1
      0 U21da					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U21da					      LIST	ON
      2 U21da		       00	   restorePiece ds	1
      0 U21db					      VARIABLE	kingSquare, 3	; traversing squares for castle/check
      0 U21db					      OPTIONAL_PAGEBREAK	"Variable", 3
     12 U21db					      LIST	ON
      2 U21db		       00 00 00    kingSquare ds	3
     49 U21de
     50 U21de
      0 U21de					      CHECK_RAM_BANK_SIZE	"SHADOW_PLY"
      1 U21de		       01 de	   .TEMP      =	* - _BANK_START
 SHADOW_PLY (512 byte) SIZE =  $1de , FREE= $22
      2 U21de					      ECHO	"SHADOW_PLY", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3 U21de				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U21de				  -	      ECHO	"BANK OVERFLOW @ ", "SHADOW_PLY", " size=", * - ORIGIN
      5 U21de				  -	      ERR
      6 U21de					      ENDIF
     52 U21de
     53 U21de					      REPEAT	PLY_BANKS-1
      0 U21de					      NEWRAMBANK	.DUMMY_PLY
      1 U21de
      2 U21de
      3 U21de
      4 U2c00 ????				      SEG.U	.DUMMY_PLY
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2400				   _BANK_START SET	*
      8 U2400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2400					      REPEND
      0 U2400					      NEWRAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400
      3 U2400
      4 U2400					      SEG.U	.DUMMY_PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2800				   _BANK_START SET	*
      8 U2800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     53 U2800					      REPEND
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U2800					      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	_BANK_ADDRESS_ORIGIN
      7 U2c00				   _BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     55 U2c00					      REPEND
     56 U2c00
     57 U2c00
     58 U2c00							;---------------------------------------------------------------------------------------------------
     59 U2c00							; EOF
------- FILE ./chess.asm
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0 U2c00					      include	"SHADOW_BOARD.asm"
      1 U2c00							; Copyright (C)2020 Andrew Davie
      2 U2c00
      3 U2c00
      4 U2c00							;---------------------------------------------------------------------------------------------------
      0 U2c00					      SLOT	3
      1 U2c00				  -	      IF	(3 < 0) || (3 > 3)
      2 U2c00				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U2c00				  -	      ERR
      4 U2c00					      ENDIF
      5 U2c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U2c00				   _BANK_SLOT SET	3 * 64
      0 U2c00					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1 U2c00
      2 U2c00
      3 U2c00
      4 U3000 ????				      SEG.U	BOARD
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3000				   _BANK_START SET	*
      8 U3000				   RAMBANK_BOARD SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      7 U3000
      8 U3000		       fc 15	   ValidSquare =	ShadowValidSquare + $400
      9 U3000		       fc 79	   Board      =	ShadowBoard + $400
     10 U3000
      0 U3000					      SLOT	2
      1 U3000				  -	      IF	(2 < 0) || (2 > 3)
      2 U3000				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U3000				  -	      ERR
      4 U3000					      ENDIF
      5 U3000				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U3000				   _BANK_SLOT SET	2 * 64
      0 U3000					      NEWBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  10dd ????				      SEG	SHADOW_BOARD
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   SHADOW_BOARD_START SET	*
      6  1000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1000				   SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + 1024
     13  1000
     14  1000							; Board is a 10 x 12 object which simplifies the generation of moves
     15  1000							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     16  1000							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     17  1000
     18  1000							;     X12 numbering
     19  1000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     20  1000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     21  1000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     22  1000							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     23  1000							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     24  1000							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     25  1000							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     26  1000							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     27  1000							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     28  1000							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     29  1000							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     30  1000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     31  1000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     32  1000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     33  1000							;	0   1	2   3	4   5	6   7	8   9
     34  1000							;		A   B	C   D	E   F	G   H
     35  1000
     36  1000							;     HEX X12
     37  1000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     38  1000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     39  1000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     40  1000							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     41  1000							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     42  1000							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     43  1000							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     44  1000							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     45  1000							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     46  1000							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     47  1000							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     48  1000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     49  1000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     50  1000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     51  1000							;	0   1	2   3	4   5	6   7	8   9
     52  1000							;		A   B	C   D	E   F	G   H
     53  1000
     54  1000
     55  1000							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     56  1000							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     57  1000							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     58  1000							; be re-used for something else - we just need to guarantee there are 21 of them there
     59  1000
      0  1000					      ALLOCATE	Valid, 120 + 80 + 21
      0  1000					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  1000					      LIST	ON
      0  1000					      DEF	Valid
      1  1000				   SLOT_Valid SET	_BANK_SLOT
      2  1000				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  1000				   Valid
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	Valid
     61  1000		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     62  1015							; Note, we will never index INTO the above bytes - x will always be >= 21
     63  1015							; We just need to make sure that the actual indexing will not have an address before
     64  1015							; the index of outside the page.
     65  1015
      0  1015					      DEF	ShadowValidSquare
      1  1015				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  1015				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  1015				   ShadowValidSquare
      4  1015				   TEMPORARY_VAR SET	Overlay
      5  1015				   TEMPORARY_OFFSET SET	0
      6  1015				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  1015				   FUNCTION_NAME SET	ShadowValidSquare
     67  1015
     68  1015
     69  1015							; Use this table to
     70  1015							;   a) Determine if a square is valid (-1 = NO)
     71  1015							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     72  1015							;	if a white pawn on square "x" can move "up" the board.
     73  1015
     74  1015		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     75  101f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     76  1029		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     77  1033		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     78  103d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     79  1047		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     80  1051		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     81  105b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     82  1065		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     83  106f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     84  1079
      0  1079					      DEF	ShadowBoard
      1  1079				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  1079				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  1079				   ShadowBoard
      4  1079				   TEMPORARY_VAR SET	Overlay
      5  1079				   TEMPORARY_OFFSET SET	0
      6  1079				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  1079				   FUNCTION_NAME SET	ShadowBoard
     86  1079
     87  1079							; A 10X10... we should never write using invalid square
     88  1079							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     89  1079							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     90  1079
     91  1079		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     92  1083		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     93  108d
     94  108d					      REPEAT	8
     95  108d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  108d					      REPEND
     95  1097		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  1097					      REPEND
     95  10a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10a1					      REPEND
     95  10ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10ab					      REPEND
     95  10b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10b5					      REPEND
     95  10bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10bf					      REPEND
     95  10c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  10c9					      REPEND
     95  10d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     96  10dd					      REPEND
     97  10dd
     98  10dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     99  10dd
    100  10dd
    101  10dd							;---------------------------------------------------------------------------------------------------
    102  10dd							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 4
      0  10dd					      include	"BANK_EVAL.asm"
      1  10dd
      0  10dd					      SLOT	3
      1  10dd				  -	      IF	(3 < 0) || (3 > 3)
      2  10dd				  -	      ECHO	"Illegal bank address/segment location", 3
      3  10dd				  -	      ERR
      4  10dd					      ENDIF
      5  10dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  10dd				   _BANK_SLOT SET	3 * 64
      3  10dd
      4  10dd
      0  10dd					      NEWRAMBANK	BANK_EVAL
      1  10dd
      2  10dd
      3  10dd
      4 U3400 ????				      SEG.U	BANK_EVAL
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	_BANK_ADDRESS_ORIGIN
      7 U3400				   _BANK_START SET	*
      8 U3400				   RAMBANK_BANK_EVAL SET	_BANK_SLOT + (ORIGIN_RAM / RAM_SIZE)
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U3400					      NEWBANK	EVAL
      1  1640 ????				      SEG	EVAL
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   EVAL_START SET	*
      6  1400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1400				   EVAL       SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + 1024
      7  1400
      8  1400
      9  1400							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     10  1400
     11  1400
     12  1400
     13  1400							;---------------------------------------------------------------------------------------------------
     14  1400							; Vectors to the position value tables for each piece
     15  1400
     16  1400					      MAC	posval
     17  1400					      .byte	0
     18  1400					      .byte	{1}(PositionalValue_PAWN - 22)
     19  1400					      .byte	{1}(PositionalValue_PAWN - 22)
     20  1400					      .byte	{1}(PositionalValue_KNIGHT - 22)
     21  1400					      .byte	{1}(PositionalValue_BISHOP - 22)
     22  1400					      .byte	{1}(PositionalValue_ROOK - 22)
     23  1400					      .byte	{1}(PositionalValue_QUEEN - 22)
     24  1400					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
     25  1400					      ENDM
     26  1400
      0  1400					      ALLOCATE	PosValVecLO, 8
      0  1400					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1400					      LIST	ON
      0  1400					      DEF	PosValVecLO
      1  1400				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  1400				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  1400				   PosValVecLO
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	PosValVecLO
      0  1400					      POSVAL	<
      1  1400		       00		      .byte.b	0
      2  1401		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      3  1402		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      4  1403		       4a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  1404		       9a		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  1405		       ea		      .byte.b	<(PositionalValue_ROOK - 22)
      7  1406		       3a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  1407		       8a		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  1408					      ALLOCATE	PosValVecHI, 8
      0  1408					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1408					      LIST	ON
      0  1408					      DEF	PosValVecHI
      1  1408				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  1408				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  1408				   PosValVecHI
      4  1408				   TEMPORARY_VAR SET	Overlay
      5  1408				   TEMPORARY_OFFSET SET	0
      6  1408				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  1408				   FUNCTION_NAME SET	PosValVecHI
      0  1408					      POSVAL	>
      1  1408		       00		      .byte.b	0
      2  1409		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      3  140a		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      4  140b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  140c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  140d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  140e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  140f		       fd		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
     31  1410
     32  1410		       00 32	   BZ	      =	50
     33  1410
     34  1410					      MAC	pval
     35  1410					      .byte	BZ + {1}
     36  1410					      .byte	BZ + {2}
     37  1410					      .byte	BZ + {3}
     38  1410					      .byte	BZ + {4}
     39  1410					      .byte	BZ + {5}
     40  1410					      .byte	BZ + {6}
     41  1410					      .byte	BZ + {7}
     42  1410					      .byte	BZ + {8}
     43  1410					      .byte	BZ
     44  1410					      .byte	BZ
     45  1410					      ENDM		;{ 10 entries }
     46  1410
     47  1410							;---------------------------------------------------------------------------------------------------
     48  1410
     49  1410				   PositionalValue_PAWN
     50  1410
      0  1410					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1410		       32		      .byte.b	BZ + 0
      2  1411		       32		      .byte.b	BZ + 0
      3  1412		       32		      .byte.b	BZ + 0
      4  1413		       32		      .byte.b	BZ + 0
      5  1414		       32		      .byte.b	BZ + 0
      6  1415		       32		      .byte.b	BZ + 0
      7  1416		       32		      .byte.b	BZ + 0
      8  1417		       32		      .byte.b	BZ + 0
      9  1418		       32		      .byte.b	BZ
     10  1419		       32		      .byte.b	BZ
      0  141a					      PVAL	15, 10, 0, -20, -20, 0, 10, 15
      1  141a		       41		      .byte.b	BZ + 15
      2  141b		       3c		      .byte.b	BZ + 10
      3  141c		       32		      .byte.b	BZ + 0
      4  141d		       1e		      .byte.b	BZ + -20
      5  141e		       1e		      .byte.b	BZ + -20
      6  141f		       32		      .byte.b	BZ + 0
      7  1420		       3c		      .byte.b	BZ + 10
      8  1421		       41		      .byte.b	BZ + 15
      9  1422		       32		      .byte.b	BZ
     10  1423		       32		      .byte.b	BZ
      0  1424					      PVAL	5, -5, -10, 0, 0, -10, -5, 5
      1  1424		       37		      .byte.b	BZ + 5
      2  1425		       2d		      .byte.b	BZ + -5
      3  1426		       28		      .byte.b	BZ + -10
      4  1427		       32		      .byte.b	BZ + 0
      5  1428		       32		      .byte.b	BZ + 0
      6  1429		       28		      .byte.b	BZ + -10
      7  142a		       2d		      .byte.b	BZ + -5
      8  142b		       37		      .byte.b	BZ + 5
      9  142c		       32		      .byte.b	BZ
     10  142d		       32		      .byte.b	BZ
      0  142e					      PVAL	0, 0, 0, 10, 40, 0, 0, 0
      1  142e		       32		      .byte.b	BZ + 0
      2  142f		       32		      .byte.b	BZ + 0
      3  1430		       32		      .byte.b	BZ + 0
      4  1431		       3c		      .byte.b	BZ + 10
      5  1432		       5a		      .byte.b	BZ + 40
      6  1433		       32		      .byte.b	BZ + 0
      7  1434		       32		      .byte.b	BZ + 0
      8  1435		       32		      .byte.b	BZ + 0
      9  1436		       32		      .byte.b	BZ
     10  1437		       32		      .byte.b	BZ
      0  1438					      PVAL	15, 15, 20, 20, 50, 20, 15, 15
      1  1438		       41		      .byte.b	BZ + 15
      2  1439		       41		      .byte.b	BZ + 15
      3  143a		       46		      .byte.b	BZ + 20
      4  143b		       46		      .byte.b	BZ + 20
      5  143c		       64		      .byte.b	BZ + 50
      6  143d		       46		      .byte.b	BZ + 20
      7  143e		       41		      .byte.b	BZ + 15
      8  143f		       41		      .byte.b	BZ + 15
      9  1440		       32		      .byte.b	BZ
     10  1441		       32		      .byte.b	BZ
      0  1442					      PVAL	30, 30, 40, 50, 50, 40, 30, 30
      1  1442		       50		      .byte.b	BZ + 30
      2  1443		       50		      .byte.b	BZ + 30
      3  1444		       5a		      .byte.b	BZ + 40
      4  1445		       64		      .byte.b	BZ + 50
      5  1446		       64		      .byte.b	BZ + 50
      6  1447		       5a		      .byte.b	BZ + 40
      7  1448		       50		      .byte.b	BZ + 30
      8  1449		       50		      .byte.b	BZ + 30
      9  144a		       32		      .byte.b	BZ
     10  144b		       32		      .byte.b	BZ
      0  144c					      PVAL	40, 50, 60, 70, 70, 60, 50, 40
      1  144c		       5a		      .byte.b	BZ + 40
      2  144d		       64		      .byte.b	BZ + 50
      3  144e		       6e		      .byte.b	BZ + 60
      4  144f		       78		      .byte.b	BZ + 70
      5  1450		       78		      .byte.b	BZ + 70
      6  1451		       6e		      .byte.b	BZ + 60
      7  1452		       64		      .byte.b	BZ + 50
      8  1453		       5a		      .byte.b	BZ + 40
      9  1454		       32		      .byte.b	BZ
     10  1455		       32		      .byte.b	BZ
      0  1456					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1456		       32		      .byte.b	BZ + 0
      2  1457		       32		      .byte.b	BZ + 0
      3  1458		       32		      .byte.b	BZ + 0
      4  1459		       32		      .byte.b	BZ + 0
      5  145a		       32		      .byte.b	BZ + 0
      6  145b		       32		      .byte.b	BZ + 0
      7  145c		       32		      .byte.b	BZ + 0
      8  145d		       32		      .byte.b	BZ + 0
      9  145e		       32		      .byte.b	BZ
     10  145f		       32		      .byte.b	BZ
     59  1460
     60  1460							;---------------------------------------------------------------------------------------------------
     61  1460
     62  1460				   PositionalValue_KNIGHT
     63  1460
      0  1460					      PVAL	-50, -40, -30, -30, -30, -30, -40, -50
      1  1460		       00		      .byte.b	BZ + -50
      2  1461		       0a		      .byte.b	BZ + -40
      3  1462		       14		      .byte.b	BZ + -30
      4  1463		       14		      .byte.b	BZ + -30
      5  1464		       14		      .byte.b	BZ + -30
      6  1465		       14		      .byte.b	BZ + -30
      7  1466		       0a		      .byte.b	BZ + -40
      8  1467		       00		      .byte.b	BZ + -50
      9  1468		       32		      .byte.b	BZ
     10  1469		       32		      .byte.b	BZ
      0  146a					      PVAL	-40, -20, 0, 5, 5, 0, -20, -40
      1  146a		       0a		      .byte.b	BZ + -40
      2  146b		       1e		      .byte.b	BZ + -20
      3  146c		       32		      .byte.b	BZ + 0
      4  146d		       37		      .byte.b	BZ + 5
      5  146e		       37		      .byte.b	BZ + 5
      6  146f		       32		      .byte.b	BZ + 0
      7  1470		       1e		      .byte.b	BZ + -20
      8  1471		       0a		      .byte.b	BZ + -40
      9  1472		       32		      .byte.b	BZ
     10  1473		       32		      .byte.b	BZ
      0  1474					      PVAL	-30, 0, 20, 15, 15, 20, 0, -30
      1  1474		       14		      .byte.b	BZ + -30
      2  1475		       32		      .byte.b	BZ + 0
      3  1476		       46		      .byte.b	BZ + 20
      4  1477		       41		      .byte.b	BZ + 15
      5  1478		       41		      .byte.b	BZ + 15
      6  1479		       46		      .byte.b	BZ + 20
      7  147a		       32		      .byte.b	BZ + 0
      8  147b		       14		      .byte.b	BZ + -30
      9  147c		       32		      .byte.b	BZ
     10  147d		       32		      .byte.b	BZ
      0  147e					      PVAL	-30, 0, 15, 30, 30, 15, 0, -30
      1  147e		       14		      .byte.b	BZ + -30
      2  147f		       32		      .byte.b	BZ + 0
      3  1480		       41		      .byte.b	BZ + 15
      4  1481		       50		      .byte.b	BZ + 30
      5  1482		       50		      .byte.b	BZ + 30
      6  1483		       41		      .byte.b	BZ + 15
      7  1484		       32		      .byte.b	BZ + 0
      8  1485		       14		      .byte.b	BZ + -30
      9  1486		       32		      .byte.b	BZ
     10  1487		       32		      .byte.b	BZ
      0  1488					      PVAL	-30, 5, 15, 30, 30, 15, 5, -30
      1  1488		       14		      .byte.b	BZ + -30
      2  1489		       37		      .byte.b	BZ + 5
      3  148a		       41		      .byte.b	BZ + 15
      4  148b		       50		      .byte.b	BZ + 30
      5  148c		       50		      .byte.b	BZ + 30
      6  148d		       41		      .byte.b	BZ + 15
      7  148e		       37		      .byte.b	BZ + 5
      8  148f		       14		      .byte.b	BZ + -30
      9  1490		       32		      .byte.b	BZ
     10  1491		       32		      .byte.b	BZ
      0  1492					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      1  1492		       14		      .byte.b	BZ + -30
      2  1493		       32		      .byte.b	BZ + 0
      3  1494		       3c		      .byte.b	BZ + 10
      4  1495		       41		      .byte.b	BZ + 15
      5  1496		       41		      .byte.b	BZ + 15
      6  1497		       3c		      .byte.b	BZ + 10
      7  1498		       32		      .byte.b	BZ + 0
      8  1499		       14		      .byte.b	BZ + -30
      9  149a		       32		      .byte.b	BZ
     10  149b		       32		      .byte.b	BZ
      0  149c					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      1  149c		       0a		      .byte.b	BZ + -40
      2  149d		       1e		      .byte.b	BZ + -20
      3  149e		       50		      .byte.b	BZ + 30
      4  149f		       32		      .byte.b	BZ + 0
      5  14a0		       32		      .byte.b	BZ + 0
      6  14a1		       50		      .byte.b	BZ + 30
      7  14a2		       1e		      .byte.b	BZ + -20
      8  14a3		       0a		      .byte.b	BZ + -40
      9  14a4		       32		      .byte.b	BZ
     10  14a5		       32		      .byte.b	BZ
      0  14a6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      1  14a6		       00		      .byte.b	BZ + -50
      2  14a7		       1e		      .byte.b	BZ + -20
      3  14a8		       14		      .byte.b	BZ + -30
      4  14a9		       14		      .byte.b	BZ + -30
      5  14aa		       14		      .byte.b	BZ + -30
      6  14ab		       14		      .byte.b	BZ + -30
      7  14ac		       1e		      .byte.b	BZ + -20
      8  14ad		       00		      .byte.b	BZ + -50
      9  14ae		       32		      .byte.b	BZ
     10  14af		       32		      .byte.b	BZ
     72  14b0
     73  14b0
     74  14b0							;---------------------------------------------------------------------------------------------------
     75  14b0
     76  14b0				   PositionalValue_BISHOP
     77  14b0
      0  14b0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      1  14b0		       1e		      .byte.b	BZ + -20
      2  14b1		       28		      .byte.b	BZ + -10
      3  14b2		       00		      .byte.b	BZ + -50
      4  14b3		       28		      .byte.b	BZ + -10
      5  14b4		       28		      .byte.b	BZ + -10
      6  14b5		       00		      .byte.b	BZ + -50
      7  14b6		       28		      .byte.b	BZ + -10
      8  14b7		       1e		      .byte.b	BZ + -20
      9  14b8		       32		      .byte.b	BZ
     10  14b9		       32		      .byte.b	BZ
      0  14ba					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      1  14ba		       28		      .byte.b	BZ + -10
      2  14bb		       37		      .byte.b	BZ + 5
      3  14bc		       32		      .byte.b	BZ + 0
      4  14bd		       32		      .byte.b	BZ + 0
      5  14be		       32		      .byte.b	BZ + 0
      6  14bf		       32		      .byte.b	BZ + 0
      7  14c0		       37		      .byte.b	BZ + 5
      8  14c1		       28		      .byte.b	BZ + -10
      9  14c2		       32		      .byte.b	BZ
     10  14c3		       32		      .byte.b	BZ
      0  14c4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      1  14c4		       28		      .byte.b	BZ + -10
      2  14c5		       3c		      .byte.b	BZ + 10
      3  14c6		       3c		      .byte.b	BZ + 10
      4  14c7		       3c		      .byte.b	BZ + 10
      5  14c8		       3c		      .byte.b	BZ + 10
      6  14c9		       3c		      .byte.b	BZ + 10
      7  14ca		       3c		      .byte.b	BZ + 10
      8  14cb		       28		      .byte.b	BZ + -10
      9  14cc		       32		      .byte.b	BZ
     10  14cd		       32		      .byte.b	BZ
      0  14ce					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      1  14ce		       28		      .byte.b	BZ + -10
      2  14cf		       32		      .byte.b	BZ + 0
      3  14d0		       3c		      .byte.b	BZ + 10
      4  14d1		       46		      .byte.b	BZ + 20
      5  14d2		       46		      .byte.b	BZ + 20
      6  14d3		       3c		      .byte.b	BZ + 10
      7  14d4		       32		      .byte.b	BZ + 0
      8  14d5		       28		      .byte.b	BZ + -10
      9  14d6		       32		      .byte.b	BZ
     10  14d7		       32		      .byte.b	BZ
      0  14d8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      1  14d8		       28		      .byte.b	BZ + -10
      2  14d9		       37		      .byte.b	BZ + 5
      3  14da		       37		      .byte.b	BZ + 5
      4  14db		       46		      .byte.b	BZ + 20
      5  14dc		       46		      .byte.b	BZ + 20
      6  14dd		       37		      .byte.b	BZ + 5
      7  14de		       37		      .byte.b	BZ + 5
      8  14df		       28		      .byte.b	BZ + -10
      9  14e0		       32		      .byte.b	BZ
     10  14e1		       32		      .byte.b	BZ
      0  14e2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      1  14e2		       28		      .byte.b	BZ + -10
      2  14e3		       32		      .byte.b	BZ + 0
      3  14e4		       37		      .byte.b	BZ + 5
      4  14e5		       3c		      .byte.b	BZ + 10
      5  14e6		       3c		      .byte.b	BZ + 10
      6  14e7		       37		      .byte.b	BZ + 5
      7  14e8		       32		      .byte.b	BZ + 0
      8  14e9		       28		      .byte.b	BZ + -10
      9  14ea		       32		      .byte.b	BZ
     10  14eb		       32		      .byte.b	BZ
      0  14ec					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  14ec		       28		      .byte.b	BZ + -10
      2  14ed		       32		      .byte.b	BZ + 0
      3  14ee		       32		      .byte.b	BZ + 0
      4  14ef		       32		      .byte.b	BZ + 0
      5  14f0		       32		      .byte.b	BZ + 0
      6  14f1		       32		      .byte.b	BZ + 0
      7  14f2		       32		      .byte.b	BZ + 0
      8  14f3		       28		      .byte.b	BZ + -10
      9  14f4		       32		      .byte.b	BZ
     10  14f5		       32		      .byte.b	BZ
      0  14f6					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      1  14f6		       1e		      .byte.b	BZ + -20
      2  14f7		       28		      .byte.b	BZ + -10
      3  14f8		       28		      .byte.b	BZ + -10
      4  14f9		       28		      .byte.b	BZ + -10
      5  14fa		       28		      .byte.b	BZ + -10
      6  14fb		       28		      .byte.b	BZ + -10
      7  14fc		       28		      .byte.b	BZ + -10
      8  14fd		       1e		      .byte.b	BZ + -20
      9  14fe		       32		      .byte.b	BZ
     10  14ff		       32		      .byte.b	BZ
     86  1500
     87  1500
     88  1500							;---------------------------------------------------------------------------------------------------
     89  1500
     90  1500				   PositionalValue_ROOK
     91  1500
      0  1500					      PVAL	-40, -40, 10, 25, 25, 10, 0, -40
      1  1500		       0a		      .byte.b	BZ + -40
      2  1501		       0a		      .byte.b	BZ + -40
      3  1502		       3c		      .byte.b	BZ + 10
      4  1503		       4b		      .byte.b	BZ + 25
      5  1504		       4b		      .byte.b	BZ + 25
      6  1505		       3c		      .byte.b	BZ + 10
      7  1506		       32		      .byte.b	BZ + 0
      8  1507		       0a		      .byte.b	BZ + -40
      9  1508		       32		      .byte.b	BZ
     10  1509		       32		      .byte.b	BZ
      0  150a					      PVAL	-60, 0, 0, 0, 0, 0, 0, -60
      1  150a		       f6		      .byte.b	BZ + -60
      2  150b		       32		      .byte.b	BZ + 0
      3  150c		       32		      .byte.b	BZ + 0
      4  150d		       32		      .byte.b	BZ + 0
      5  150e		       32		      .byte.b	BZ + 0
      6  150f		       32		      .byte.b	BZ + 0
      7  1510		       32		      .byte.b	BZ + 0
      8  1511		       f6		      .byte.b	BZ + -60
      9  1512		       32		      .byte.b	BZ
     10  1513		       32		      .byte.b	BZ
      0  1514					      PVAL	-50, 0, 0, 0, 0, 0, 0, -50
      1  1514		       00		      .byte.b	BZ + -50
      2  1515		       32		      .byte.b	BZ + 0
      3  1516		       32		      .byte.b	BZ + 0
      4  1517		       32		      .byte.b	BZ + 0
      5  1518		       32		      .byte.b	BZ + 0
      6  1519		       32		      .byte.b	BZ + 0
      7  151a		       32		      .byte.b	BZ + 0
      8  151b		       00		      .byte.b	BZ + -50
      9  151c		       32		      .byte.b	BZ
     10  151d		       32		      .byte.b	BZ
      0  151e					      PVAL	-0, 0, 0, 0, 0, 0, 0, 0
      1  151e		       32		      .byte.b	BZ + -0
      2  151f		       32		      .byte.b	BZ + 0
      3  1520		       32		      .byte.b	BZ + 0
      4  1521		       32		      .byte.b	BZ + 0
      5  1522		       32		      .byte.b	BZ + 0
      6  1523		       32		      .byte.b	BZ + 0
      7  1524		       32		      .byte.b	BZ + 0
      8  1525		       32		      .byte.b	BZ + 0
      9  1526		       32		      .byte.b	BZ
     10  1527		       32		      .byte.b	BZ
      0  1528					      PVAL	-50, 0, 0, 0, 0, 0, 0, -50
      1  1528		       00		      .byte.b	BZ + -50
      2  1529		       32		      .byte.b	BZ + 0
      3  152a		       32		      .byte.b	BZ + 0
      4  152b		       32		      .byte.b	BZ + 0
      5  152c		       32		      .byte.b	BZ + 0
      6  152d		       32		      .byte.b	BZ + 0
      7  152e		       32		      .byte.b	BZ + 0
      8  152f		       00		      .byte.b	BZ + -50
      9  1530		       32		      .byte.b	BZ
     10  1531		       32		      .byte.b	BZ
      0  1532					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      1  1532		       2d		      .byte.b	BZ + -5
      2  1533		       32		      .byte.b	BZ + 0
      3  1534		       50		      .byte.b	BZ + 30
      4  1535		       50		      .byte.b	BZ + 30
      5  1536		       50		      .byte.b	BZ + 30
      6  1537		       50		      .byte.b	BZ + 30
      7  1538		       32		      .byte.b	BZ + 0
      8  1539		       2d		      .byte.b	BZ + -5
      9  153a		       32		      .byte.b	BZ
     10  153b		       32		      .byte.b	BZ
      0  153c					      PVAL	5, 10, 50, 50, 50, 50, 10, 5
      1  153c		       37		      .byte.b	BZ + 5
      2  153d		       3c		      .byte.b	BZ + 10
      3  153e		       64		      .byte.b	BZ + 50
      4  153f		       64		      .byte.b	BZ + 50
      5  1540		       64		      .byte.b	BZ + 50
      6  1541		       64		      .byte.b	BZ + 50
      7  1542		       3c		      .byte.b	BZ + 10
      8  1543		       37		      .byte.b	BZ + 5
      9  1544		       32		      .byte.b	BZ
     10  1545		       32		      .byte.b	BZ
      0  1546					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  1546		       32		      .byte.b	BZ + 0
      2  1547		       32		      .byte.b	BZ + 0
      3  1548		       32		      .byte.b	BZ + 0
      4  1549		       32		      .byte.b	BZ + 0
      5  154a		       32		      .byte.b	BZ + 0
      6  154b		       32		      .byte.b	BZ + 0
      7  154c		       32		      .byte.b	BZ + 0
      8  154d		       32		      .byte.b	BZ + 0
      9  154e		       32		      .byte.b	BZ
     10  154f		       32		      .byte.b	BZ
    100  1550
    101  1550
    102  1550							;---------------------------------------------------------------------------------------------------
    103  1550
    104  1550				   PositionalValue_QUEEN
    105  1550
      0  1550					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      1  1550		       1e		      .byte.b	BZ + -20
      2  1551		       28		      .byte.b	BZ + -10
      3  1552		       2d		      .byte.b	BZ + -5
      4  1553		       2d		      .byte.b	BZ + -5
      5  1554		       2d		      .byte.b	BZ + -5
      6  1555		       28		      .byte.b	BZ + -10
      7  1556		       28		      .byte.b	BZ + -10
      8  1557		       1e		      .byte.b	BZ + -20
      9  1558		       32		      .byte.b	BZ
     10  1559		       32		      .byte.b	BZ
      0  155a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      1  155a		       28		      .byte.b	BZ + -10
      2  155b		       32		      .byte.b	BZ + 0
      3  155c		       37		      .byte.b	BZ + 5
      4  155d		       32		      .byte.b	BZ + 0
      5  155e		       32		      .byte.b	BZ + 0
      6  155f		       32		      .byte.b	BZ + 0
      7  1560		       32		      .byte.b	BZ + 0
      8  1561		       28		      .byte.b	BZ + -10
      9  1562		       32		      .byte.b	BZ
     10  1563		       32		      .byte.b	BZ
      0  1564					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      1  1564		       28		      .byte.b	BZ + -10
      2  1565		       37		      .byte.b	BZ + 5
      3  1566		       37		      .byte.b	BZ + 5
      4  1567		       37		      .byte.b	BZ + 5
      5  1568		       37		      .byte.b	BZ + 5
      6  1569		       4b		      .byte.b	BZ + 25
      7  156a		       32		      .byte.b	BZ + 0
      8  156b		       28		      .byte.b	BZ + -10
      9  156c		       32		      .byte.b	BZ
     10  156d		       32		      .byte.b	BZ
      0  156e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      1  156e		       28		      .byte.b	BZ + -10
      2  156f		       32		      .byte.b	BZ + 0
      3  1570		       37		      .byte.b	BZ + 5
      4  1571		       4b		      .byte.b	BZ + 25
      5  1572		       4b		      .byte.b	BZ + 25
      6  1573		       4b		      .byte.b	BZ + 25
      7  1574		       32		      .byte.b	BZ + 0
      8  1575		       28		      .byte.b	BZ + -10
      9  1576		       32		      .byte.b	BZ
     10  1577		       32		      .byte.b	BZ
      0  1578					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      1  1578		       2d		      .byte.b	BZ + -5
      2  1579		       32		      .byte.b	BZ + 0
      3  157a		       41		      .byte.b	BZ + 15
      4  157b		       69		      .byte.b	BZ + 55
      5  157c		       69		      .byte.b	BZ + 55
      6  157d		       69		      .byte.b	BZ + 55
      7  157e		       32		      .byte.b	BZ + 0
      8  157f		       2d		      .byte.b	BZ + -5
      9  1580		       32		      .byte.b	BZ
     10  1581		       32		      .byte.b	BZ
      0  1582					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      1  1582		       28		      .byte.b	BZ + -10
      2  1583		       32		      .byte.b	BZ + 0
      3  1584		       4b		      .byte.b	BZ + 25
      4  1585		       7d		      .byte.b	BZ + 75
      5  1586		       7d		      .byte.b	BZ + 75
      6  1587		       7d		      .byte.b	BZ + 75
      7  1588		       32		      .byte.b	BZ + 0
      8  1589		       28		      .byte.b	BZ + -10
      9  158a		       32		      .byte.b	BZ
     10  158b		       32		      .byte.b	BZ
      0  158c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  158c		       28		      .byte.b	BZ + -10
      2  158d		       32		      .byte.b	BZ + 0
      3  158e		       32		      .byte.b	BZ + 0
      4  158f		       32		      .byte.b	BZ + 0
      5  1590		       32		      .byte.b	BZ + 0
      6  1591		       32		      .byte.b	BZ + 0
      7  1592		       32		      .byte.b	BZ + 0
      8  1593		       28		      .byte.b	BZ + -10
      9  1594		       32		      .byte.b	BZ
     10  1595		       32		      .byte.b	BZ
      0  1596					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      1  1596		       1e		      .byte.b	BZ + -20
      2  1597		       28		      .byte.b	BZ + -10
      3  1598		       28		      .byte.b	BZ + -10
      4  1599		       2d		      .byte.b	BZ + -5
      5  159a		       2d		      .byte.b	BZ + -5
      6  159b		       28		      .byte.b	BZ + -10
      7  159c		       28		      .byte.b	BZ + -10
      8  159d		       1e		      .byte.b	BZ + -20
      9  159e		       32		      .byte.b	BZ
     10  159f		       32		      .byte.b	BZ
    114  15a0
    115  15a0
    116  15a0							;---------------------------------------------------------------------------------------------------
    117  15a0
    118  15a0				   PositionalValue_KING_MIDGAME
    119  15a0
      0  15a0					      PVAL	0, 0, 30, -20, 0, 10, 40, 10
      1  15a0		       32		      .byte.b	BZ + 0
      2  15a1		       32		      .byte.b	BZ + 0
      3  15a2		       50		      .byte.b	BZ + 30
      4  15a3		       1e		      .byte.b	BZ + -20
      5  15a4		       32		      .byte.b	BZ + 0
      6  15a5		       3c		      .byte.b	BZ + 10
      7  15a6		       5a		      .byte.b	BZ + 40
      8  15a7		       3c		      .byte.b	BZ + 10
      9  15a8		       32		      .byte.b	BZ
     10  15a9		       32		      .byte.b	BZ
      0  15aa					      PVAL	20, 20, 0, -10, -10, 0, 20, 20
      1  15aa		       46		      .byte.b	BZ + 20
      2  15ab		       46		      .byte.b	BZ + 20
      3  15ac		       32		      .byte.b	BZ + 0
      4  15ad		       28		      .byte.b	BZ + -10
      5  15ae		       28		      .byte.b	BZ + -10
      6  15af		       32		      .byte.b	BZ + 0
      7  15b0		       46		      .byte.b	BZ + 20
      8  15b1		       46		      .byte.b	BZ + 20
      9  15b2		       32		      .byte.b	BZ
     10  15b3		       32		      .byte.b	BZ
      0  15b4					      PVAL	-10, -20, -20, -20, -20, -20, -20, -10
      1  15b4		       28		      .byte.b	BZ + -10
      2  15b5		       1e		      .byte.b	BZ + -20
      3  15b6		       1e		      .byte.b	BZ + -20
      4  15b7		       1e		      .byte.b	BZ + -20
      5  15b8		       1e		      .byte.b	BZ + -20
      6  15b9		       1e		      .byte.b	BZ + -20
      7  15ba		       1e		      .byte.b	BZ + -20
      8  15bb		       28		      .byte.b	BZ + -10
      9  15bc		       32		      .byte.b	BZ
     10  15bd		       32		      .byte.b	BZ
      0  15be					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      1  15be		       1e		      .byte.b	BZ + -20
      2  15bf		       14		      .byte.b	BZ + -30
      3  15c0		       14		      .byte.b	BZ + -30
      4  15c1		       0a		      .byte.b	BZ + -40
      5  15c2		       0a		      .byte.b	BZ + -40
      6  15c3		       14		      .byte.b	BZ + -30
      7  15c4		       14		      .byte.b	BZ + -30
      8  15c5		       1e		      .byte.b	BZ + -20
      9  15c6		       32		      .byte.b	BZ
     10  15c7		       32		      .byte.b	BZ
      0  15c8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  15c8		       14		      .byte.b	BZ + -30
      2  15c9		       0a		      .byte.b	BZ + -40
      3  15ca		       0a		      .byte.b	BZ + -40
      4  15cb		       00		      .byte.b	BZ + -50
      5  15cc		       00		      .byte.b	BZ + -50
      6  15cd		       0a		      .byte.b	BZ + -40
      7  15ce		       0a		      .byte.b	BZ + -40
      8  15cf		       14		      .byte.b	BZ + -30
      9  15d0		       32		      .byte.b	BZ
     10  15d1		       32		      .byte.b	BZ
      0  15d2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  15d2		       14		      .byte.b	BZ + -30
      2  15d3		       0a		      .byte.b	BZ + -40
      3  15d4		       0a		      .byte.b	BZ + -40
      4  15d5		       00		      .byte.b	BZ + -50
      5  15d6		       00		      .byte.b	BZ + -50
      6  15d7		       0a		      .byte.b	BZ + -40
      7  15d8		       0a		      .byte.b	BZ + -40
      8  15d9		       14		      .byte.b	BZ + -30
      9  15da		       32		      .byte.b	BZ
     10  15db		       32		      .byte.b	BZ
      0  15dc					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  15dc		       14		      .byte.b	BZ + -30
      2  15dd		       0a		      .byte.b	BZ + -40
      3  15de		       0a		      .byte.b	BZ + -40
      4  15df		       00		      .byte.b	BZ + -50
      5  15e0		       00		      .byte.b	BZ + -50
      6  15e1		       0a		      .byte.b	BZ + -40
      7  15e2		       0a		      .byte.b	BZ + -40
      8  15e3		       14		      .byte.b	BZ + -30
      9  15e4		       32		      .byte.b	BZ
     10  15e5		       32		      .byte.b	BZ
      0  15e6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  15e6		       14		      .byte.b	BZ + -30
      2  15e7		       0a		      .byte.b	BZ + -40
      3  15e8		       0a		      .byte.b	BZ + -40
      4  15e9		       00		      .byte.b	BZ + -50
      5  15ea		       00		      .byte.b	BZ + -50
      6  15eb		       0a		      .byte.b	BZ + -40
      7  15ec		       0a		      .byte.b	BZ + -40
      8  15ed		       14		      .byte.b	BZ + -30
      9  15ee		       32		      .byte.b	BZ
     10  15ef		       32		      .byte.b	BZ
    128  15f0
    129  15f0
    130  15f0							;---------------------------------------------------------------------------------------------------
    131  15f0
    132  15f0				   PositionalValue_KING_ENDGAME
    133  15f0
      0  15f0					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      1  15f0		       00		      .byte.b	BZ + -50
      2  15f1		       14		      .byte.b	BZ + -30
      3  15f2		       14		      .byte.b	BZ + -30
      4  15f3		       14		      .byte.b	BZ + -30
      5  15f4		       14		      .byte.b	BZ + -30
      6  15f5		       14		      .byte.b	BZ + -30
      7  15f6		       14		      .byte.b	BZ + -30
      8  15f7		       00		      .byte.b	BZ + -50
      9  15f8		       32		      .byte.b	BZ
     10  15f9		       32		      .byte.b	BZ
      0  15fa					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      1  15fa		       14		      .byte.b	BZ + -30
      2  15fb		       14		      .byte.b	BZ + -30
      3  15fc		       32		      .byte.b	BZ + 0
      4  15fd		       32		      .byte.b	BZ + 0
      5  15fe		       32		      .byte.b	BZ + 0
      6  15ff		       32		      .byte.b	BZ + 0
      7  1600		       14		      .byte.b	BZ + -30
      8  1601		       14		      .byte.b	BZ + -30
      9  1602		       32		      .byte.b	BZ
     10  1603		       32		      .byte.b	BZ
      0  1604					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1604		       14		      .byte.b	BZ + -30
      2  1605		       28		      .byte.b	BZ + -10
      3  1606		       46		      .byte.b	BZ + 20
      4  1607		       50		      .byte.b	BZ + 30
      5  1608		       50		      .byte.b	BZ + 30
      6  1609		       46		      .byte.b	BZ + 20
      7  160a		       28		      .byte.b	BZ + -10
      8  160b		       14		      .byte.b	BZ + -30
      9  160c		       32		      .byte.b	BZ
     10  160d		       32		      .byte.b	BZ
      0  160e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  160e		       14		      .byte.b	BZ + -30
      2  160f		       28		      .byte.b	BZ + -10
      3  1610		       50		      .byte.b	BZ + 30
      4  1611		       5a		      .byte.b	BZ + 40
      5  1612		       5a		      .byte.b	BZ + 40
      6  1613		       50		      .byte.b	BZ + 30
      7  1614		       28		      .byte.b	BZ + -10
      8  1615		       14		      .byte.b	BZ + -30
      9  1616		       32		      .byte.b	BZ
     10  1617		       32		      .byte.b	BZ
      0  1618					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  1618		       14		      .byte.b	BZ + -30
      2  1619		       28		      .byte.b	BZ + -10
      3  161a		       50		      .byte.b	BZ + 30
      4  161b		       5a		      .byte.b	BZ + 40
      5  161c		       5a		      .byte.b	BZ + 40
      6  161d		       50		      .byte.b	BZ + 30
      7  161e		       28		      .byte.b	BZ + -10
      8  161f		       14		      .byte.b	BZ + -30
      9  1620		       32		      .byte.b	BZ
     10  1621		       32		      .byte.b	BZ
      0  1622					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  1622		       14		      .byte.b	BZ + -30
      2  1623		       28		      .byte.b	BZ + -10
      3  1624		       46		      .byte.b	BZ + 20
      4  1625		       50		      .byte.b	BZ + 30
      5  1626		       50		      .byte.b	BZ + 30
      6  1627		       46		      .byte.b	BZ + 20
      7  1628		       28		      .byte.b	BZ + -10
      8  1629		       14		      .byte.b	BZ + -30
      9  162a		       32		      .byte.b	BZ
     10  162b		       32		      .byte.b	BZ
      0  162c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      1  162c		       14		      .byte.b	BZ + -30
      2  162d		       1e		      .byte.b	BZ + -20
      3  162e		       28		      .byte.b	BZ + -10
      4  162f		       32		      .byte.b	BZ + 0
      5  1630		       32		      .byte.b	BZ + 0
      6  1631		       28		      .byte.b	BZ + -10
      7  1632		       1e		      .byte.b	BZ + -20
      8  1633		       14		      .byte.b	BZ + -30
      9  1634		       32		      .byte.b	BZ
     10  1635		       32		      .byte.b	BZ
      0  1636					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      1  1636		       00		      .byte.b	BZ + -50
      2  1637		       0a		      .byte.b	BZ + -40
      3  1638		       14		      .byte.b	BZ + -30
      4  1639		       1e		      .byte.b	BZ + -20
      5  163a		       1e		      .byte.b	BZ + - 20
      6  163b		       14		      .byte.b	BZ + -30
      7  163c		       0a		      .byte.b	BZ + -40
      8  163d		       00		      .byte.b	BZ + -50
      9  163e		       32		      .byte.b	BZ
     10  163f		       32		      .byte.b	BZ
    142  1640
    143  1640
      0  1640					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  1640		       02 40	   .TEMP      =	* - _BANK_START
 BANK_EVAL (1K) SIZE =  $240 , FREE= $1c0
      2  1640					      ECHO	"BANK_EVAL", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1640				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1640				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_EVAL", " size=", * - ORIGIN
      5  1640				  -	      ERR
      6  1640					      ENDIF
    145  1640
    146  1640							;---------------------------------------------------------------------------------------------------
    147  1640							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#1.asm LEVEL 2 PASS 4
      0  1640					      include	"BANK_StateMachine@1#1.asm"
      0  1640					      SLOT	1
      1  1640				  -	      IF	(1 < 0) || (1 > 3)
      2  1640				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1640				  -	      ERR
      4  1640					      ENDIF
      5  1640				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1640				   _BANK_SLOT SET	1 * 64
      0  1640					      NEWBANK	STATEMACHINE
      1  1bad ????				      SEG	STATEMACHINE
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   STATEMACHINE_START SET	*
      6  1800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1800				   STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + 1024
      3  1800
      4  1800
      5  1800							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      6  1800
      7  1800
      8  1800		       00 10	   CURSOR_MOVE_SPEED =	16
      9  1800		       00 14	   CAP_SPEED  =	20
     10  1800		       00 28	   HOLD_DELAY =	40
     11  1800
     12  1800
     13  1800							;---------------------------------------------------------------------------------------------------
     14  1800
     15  1800
     16  1800							;---------------------------------------------------------------------------------------------------
     17  1800
      0  1800					      DEF	aiStartMoveGen
      1  1800				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  1800				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  1800				   aiStartMoveGen
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	aiStartMoveGen
     19  1800					      SUBROUTINE
     20  1800
      0  1800					      REFER	AiStateMachine
      1  1800				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1800				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1800					      ENDIF
      0  1800					      VEND	aiStartMoveGen
      1  1800				  -	      IFNCONST	aiStartMoveGen
      2  1800				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  1800				  -	      ERR
      4  1800					      ENDIF
      5  1800		       00 a4	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
     23  1800
     24  1800							; To assist with castling, generate the moves for the opponent, giving us effectively
     25  1800							; a list of squares that are being attacked. The castling can't happen if the king is
     26  1800							; in check or if the squares it would have to move over are in check
     27  1800
     28  1800							; we don't need to worry about this if K has moved, or relevant R has moved or if
     29  1800							; the squares between are occupied. We can tell THAT by examining the movelist to see
     30  1800							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     31  1800
     32  1800							;inc currentPly
     33  1800							;jsr InitialiseMoveGeneration
     34  1800
      0  1800					      PHASE	AI_StepMoveGen
      1  1800		       a9 0c		      lda	#AI_StepMoveGen
      2  1802		       85 8b		      sta	aiState
     36  1804		       60		      rts
     37  1805
     38  1805
     39  1805							;---------------------------------------------------------------------------------------------------
     40  1805
      0  1805					      DEF	aiInCheckBackup
      1  1805				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  1805				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  1805				   aiInCheckBackup
      4  1805				   TEMPORARY_VAR SET	Overlay
      5  1805				   TEMPORARY_OFFSET SET	0
      6  1805				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  1805				   FUNCTION_NAME SET	aiInCheckBackup
     42  1805					      SUBROUTINE
     43  1805
      0  1805					      REFER	AiStateMachine
      1  1805				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1805				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1805					      ENDIF
      0  1805					      VEND	aiInCheckBackup
      1  1805				  -	      IFNCONST	aiInCheckBackup
      2  1805				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  1805				  -	      ERR
      4  1805					      ENDIF
      5  1805		       00 a4	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
     46  1805
     47  1805							; We're about to draw some large text on the screen
     48  1805							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     49  1805
     50  1805		       c6 84		      dec	drawCount
     51  1807		       30 02		      bmi	.exit	; done all rows
     52  1809		       a4 84		      ldy	drawCount
     53  180b				  -	      IF	0
     54  180b				  -	      jmp	SAFE_BackupBitmaps
     55  180b					      ENDIF
     56  180b
      0  180b				   .exit      PHASE	AI_InCheckDelay
      1  180b		       a9 1e		      lda	#AI_InCheckDelay
      2  180d		       85 8b		      sta	aiState
     58  180f		       60		      rts
     59  1810
     60  1810
     61  1810							;---------------------------------------------------------------------------------------------------
     62  1810
      0  1810					      DEF	aiInCheckDelay
      1  1810				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  1810				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  1810				   aiInCheckDelay
      4  1810				   TEMPORARY_VAR SET	Overlay
      5  1810				   TEMPORARY_OFFSET SET	0
      6  1810				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  1810				   FUNCTION_NAME SET	aiInCheckDelay
     64  1810					      SUBROUTINE
     65  1810
      0  1810					      REFER	AiStateMachine
      1  1810				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1810				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1810					      ENDIF
      0  1810					      VEND	aiInCheckDelay
      1  1810				  -	      IFNCONST	aiInCheckDelay
      2  1810				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  1810				  -	      ERR
      4  1810					      ENDIF
      5  1810		       00 a4	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
     68  1810
     69  1810		       c6 89		      dec	mdelay
     70  1812		       d0 08		      bne	.exit
     71  1814
     72  1814		       a9 00		      lda	#0
     73  1816		       85 49		      sta	COLUBK
     74  1818
      0  1818					      PHASE	AI_BeginSelectMovePhase
      1  1818		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  181a		       85 8b		      sta	aiState
     76  181c		       60	   .exit      rts
     77  181d
     78  181d
     79  181d							;---------------------------------------------------------------------------------------------------
     80  181d
      0  181d					      DEF	aiBeginSelectMovePhase
      1  181d				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  181d				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  181d				   aiBeginSelectMovePhase
      4  181d				   TEMPORARY_VAR SET	Overlay
      5  181d				   TEMPORARY_OFFSET SET	0
      6  181d				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  181d				   FUNCTION_NAME SET	aiBeginSelectMovePhase
     82  181d					      SUBROUTINE
     83  181d
      0  181d					      REFER	AiStateMachine
      1  181d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  181d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  181d					      ENDIF
      0  181d					      VEND	aiBeginSelectMovePhase
      1  181d				  -	      IFNCONST	aiBeginSelectMovePhase
      2  181d				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  181d				  -	      ERR
      4  181d					      ENDIF
      5  181d		       00 a4	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
     86  181d
     87  181d
     88  181d		       a9 02		      lda	#$2
     89  181f		       85 46		      sta	COLUP0
     90  1821		       a2 04		      ldx	#%100
     91  1823		       86 4a		      stx	CTRLPF	; under
     92  1825
     93  1825		       a9 00		      lda	#0
     94  1827		       85 89		      sta	mdelay	;?
     95  1829		       85 8e		      sta	aiFlashPhase	; odd/even for flashing pieces
     96  182b
     97  182b		       a9 28		      lda	#CAP_SPEED*2
     98  182d		       85 8c		      sta	aiFlashDelay
     99  182f
    100  182f		       a9 ff		      lda	#-1
    101  1831		       85 85		      sta	fromX12
    102  1833		       85 86		      sta	toX12
    103  1835
    104  1835		       46 a3		      lsr	randomness
    105  1837
    106  1837
      0  1837					      PHASE	AI_FlashComputerMove
      1  1837		       a9 00		      lda	#AI_FlashComputerMove
      2  1839		       85 8b		      sta	aiState
    108  183b		       60		      rts
    109  183c
    110  183c							;---------------------------------------------------------------------------------------------------
    111  183c
      0  183c					      DEF	aiFlashComputerMove
      1  183c				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  183c				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  183c				   aiFlashComputerMove
      4  183c				   TEMPORARY_VAR SET	Overlay
      5  183c				   TEMPORARY_OFFSET SET	0
      6  183c				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  183c				   FUNCTION_NAME SET	aiFlashComputerMove
    113  183c					      SUBROUTINE
    114  183c
      0  183c					      REFER	AiStateMachine
      1  183c				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  183c				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  183c					      ENDIF
      0  183c					      VEND	aiFlashComputerMove
      1  183c				  -	      IFNCONST	aiFlashComputerMove
      2  183c				  -	      ECHO	"Incorrect VEND label", aiFlashComputerMove
      3  183c				  -	      ERR
      4  183c					      ENDIF
      5  183c		       00 a4	   VAREND_aiFlashComputerMove =	TEMPORARY_VAR
    117  183c
    118  183c		       a5 80		      lda	squareToDraw
    119  183e		       30 1f		      bmi	.initial2	; startup - no computer move to show
    120  1840
    121  1840							; "squareToDraw" is the piece that should flash while human waits
    122  1840
    123  1840		       ad 80 02 	      lda	SWCHA
    124  1843		       29 f0		      and	#$F0
    125  1845		       c9 f0		      cmp	#$F0
    126  1847		       f0 08		      beq	.nodir
    127  1849
    128  1849		       a9 01		      lda	#1
    129  184b		       85 8c		      sta	aiFlashDelay
    130  184d		       25 8e		      and	aiFlashPhase
    131  184f		       f0 0e		      beq	.initial
    132  1851
    133  1851		       c6 8c	   .nodir     dec	aiFlashDelay
    134  1853		       d0 0e		      bne	.exit	; don't flash
    135  1855		       a9 28		      lda	#CAP_SPEED*2
    136  1857		       85 8c		      sta	aiFlashDelay
    137  1859
    138  1859		       e6 8e		      inc	aiFlashPhase
    139  185b
    140  185b		       20 c2 f0 	      jsr	CopySinglePiece	;@0
    141  185e		       60		      rts
    142  185f
    143  185f				   .initial
    144  185f
    145  185f							;SWAP
      0  185f				   .initial2  PHASE	AI_SelectStartSquare
      1  185f		       a9 02		      lda	#AI_SelectStartSquare
      2  1861		       85 8b		      sta	aiState
    147  1863
    148  1863		       60	   .exit      rts
    149  1864
    150  1864
    151  1864							;---------------------------------------------------------------------------------------------------
    152  1864
      0  1864					      DEF	aiSelectStartSquare
      1  1864				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  1864				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  1864				   aiSelectStartSquare
      4  1864				   TEMPORARY_VAR SET	Overlay
      5  1864				   TEMPORARY_OFFSET SET	0
      6  1864				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  1864				   FUNCTION_NAME SET	aiSelectStartSquare
    154  1864					      SUBROUTINE
    155  1864
      0  1864					      REFER	AiStateMachine
      1  1864				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1864				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1864					      ENDIF
      0  1864					      VEND	aiSelectStartSquare
      1  1864				  -	      IFNCONST	aiSelectStartSquare
      2  1864				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  1864				  -	      ERR
      4  1864					      ENDIF
      5  1864		       00 a4	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    158  1864
      0  1864					      NEXT_RANDOM
      1  1864		       a5 81		      lda	rnd
      2  1866		       4a		      lsr
      3  1867		       90 02		      bcc	.skipEOR
      4  1869		       49 fe		      eor	#RND_EOR_VAL
      5  186b		       85 81	   .skipEOR   sta	rnd
    160  186d
    161  186d		       20 29 f6 	      jsr	moveCursor
    162  1870
    163  1870							; Search the player's movelist for the square, so we can set cursor colour
    164  1870
    165  1870		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
    166  1872		       85 3e		      sta	SET_BANK_RAM	;@2
    167  1874
    168  1874		       a5 88		      lda	cursorX12
    169  1876		       85 85		      sta	fromX12
    170  1878
      0  1878					      ldy@PLY	moveIndex
      1  1878		       ac d0 f9 	      ldy	moveIndex
    172  187b		       30 0d		      bmi	.done
    173  187d
    174  187d		       d9 00 f8    .scan      cmp	MoveFrom,y
    175  1880		       f0 03		      beq	.scanned
    176  1882		       88		      dey
    177  1883		       10 f8		      bpl	.scan
    178  1885
      0  1885				   .scanned   lda@PLY	MovePiece,y
      1  1885		       b9 00 f9 	      lda	MovePiece,y
    180  1888		       85 96		      sta	fromPiece
    181  188a
    182  188a		       c6 8a	   .done      dec	ccur	; pulse colour for valid squares
    183  188c		       20 b1 f4 	      jsr	setCursorColours
    184  188f
    185  188f		       98		      tya
    186  1890		       05 4c		      ora	INPT4
    187  1892		       30 04		      bmi	.exit	; illegal square or no button press
    188  1894
      0  1894					      PHASE	AI_StartSquareSelected
      1  1894		       a9 03		      lda	#AI_StartSquareSelected
      2  1896		       85 8b		      sta	aiState
    190  1898
    191  1898		       60	   .exit      rts
    192  1899
    193  1899							;---------------------------------------------------------------------------------------------------
    194  1899
      0  1899					      DEF	setCursorPriority
      1  1899				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  1899				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  1899				   setCursorPriority
      4  1899				   TEMPORARY_VAR SET	Overlay
      5  1899				   TEMPORARY_OFFSET SET	0
      6  1899				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  1899				   FUNCTION_NAME SET	setCursorPriority
    196  1899					      SUBROUTINE
    197  1899
      0  1899					      REFER	moveCursor
      1  1899					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  1899				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  1899					      ENDIF
      0  1899					      VEND	setCursorPriority
      1  1899				  -	      IFNCONST	setCursorPriority
      2  1899				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  1899				  -	      ERR
      4  1899					      ENDIF
      5  1899		       00 a5	   VAREND_setCursorPriority =	TEMPORARY_VAR
    200  1899
    201  1899		       98		      tya
    202  189a		       48		      pha
    203  189b
    204  189b		       a2 04		      ldx	#%100
    205  189d
    206  189d		       a4 88		      ldy	cursorX12
    207  189f		       30 0b		      bmi	.under
    208  18a1
    209  18a1		       a9 cc		      lda	#RAMBANK_BOARD
    210  18a3		       85 3e		      sta	SET_BANK_RAM	;@3
    211  18a5		       b9 79 fc 	      lda	Board,y
    212  18a8		       d0 02		      bne	.under
    213  18aa		       a2 00		      ldx	#0
    214  18ac		       86 4a	   .under     stx	CTRLPF	; UNDER
    215  18ae
    216  18ae		       68		      pla
    217  18af		       a8		      tay
    218  18b0		       60		      rts
    219  18b1
    220  18b1							;---------------------------------------------------------------------------------------------------
    221  18b1
      0  18b1					      DEF	setCursorColours
      1  18b1				   SLOT_setCursorColours SET	_BANK_SLOT
      2  18b1				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  18b1				   setCursorColours
      4  18b1				   TEMPORARY_VAR SET	Overlay
      5  18b1				   TEMPORARY_OFFSET SET	0
      6  18b1				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  18b1				   FUNCTION_NAME SET	setCursorColours
    223  18b1					      SUBROUTINE
    224  18b1
      0  18b1					      REFER	aiSelectStartSquare
      1  18b1				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  18b1					      ENDIF
      0  18b1					      REFER	aiDrawMoves
      1  18b1				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  18b1					      ENDIF
      0  18b1					      REFER	aiUnDrawTargetSquares
      1  18b1				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  18b1					      ENDIF
      0  18b1					      REFER	aiShowMoveCaptures
      1  18b1				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  18b1					      ENDIF
      0  18b1					      REFER	aiSlowFlash
      1  18b1				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  18b1					      ENDIF
      0  18b1					      REFER	aiSelectDestinationSquare
      1  18b1				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  18b1				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  18b1					      ENDIF
      0  18b1					      VEND	setCursorColours
      1  18b1				  -	      IFNCONST	setCursorColours
      2  18b1				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  18b1				  -	      ERR
      4  18b1					      ENDIF
      5  18b1		       00 a4	   VAREND_setCursorColours =	TEMPORARY_VAR
    232  18b1
    233  18b1							; pass y=-1 if move is NOT in the movelist
    234  18b1							; preserve y
    235  18b1
    236  18b1		       a9 40		      lda	#$40
    237  18b3
    238  18b3		       c0 ff		      cpy	#-1
    239  18b5		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    240  18b7
    241  18b7		       a5 8a		      lda	ccur
    242  18b9		       4a		      lsr
    243  18ba		       4a		      lsr
    244  18bb		       4a		      lsr
    245  18bc		       29 03		      and	#3
    246  18be		       18		      clc
    247  18bf		       69 d0		      adc	#$D0	;COLOUR_LINE_1
    248  18c1
    249  18c1		       85 46	   .writeCursorCol sta	COLUP0
    250  18c3		       60		      rts
    251  18c4
    252  18c4
    253  18c4							;---------------------------------------------------------------------------------------------------
    254  18c4
    255  18c4							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    256  18c4							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    257  18c4
      0  18c4					      ALLOCATE	JoyCombined, 16
      0  18c4					      OPTIONAL_PAGEBREAK	"Table", 16
     12  18c4					      LIST	ON
      0  18c4					      DEF	JoyCombined
      1  18c4				   SLOT_JoyCombined SET	_BANK_SLOT
      2  18c4				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  18c4				   JoyCombined
      4  18c4				   TEMPORARY_VAR SET	Overlay
      5  18c4				   TEMPORARY_OFFSET SET	0
      6  18c4				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  18c4				   FUNCTION_NAME SET	JoyCombined
    259  18c4		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    260  18d4
      0  18d4					      ALLOCATE	JoyMoveCursor, 16
      0  18d4					      OPTIONAL_PAGEBREAK	"Table", 16
     12  18d4					      LIST	ON
      0  18d4					      DEF	JoyMoveCursor
      1  18d4				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  18d4				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  18d4				   JoyMoveCursor
      4  18d4				   TEMPORARY_VAR SET	Overlay
      5  18d4				   TEMPORARY_OFFSET SET	0
      6  18d4				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  18d4				   FUNCTION_NAME SET	JoyMoveCursor
    262  18d4		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    263  18e4
    264  18e4
    265  18e4							;---------------------------------------------------------------------------------------------------
    266  18e4
      0  18e4					      DEF	aiStartSquareSelected
      1  18e4				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  18e4				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  18e4				   aiStartSquareSelected
      4  18e4				   TEMPORARY_VAR SET	Overlay
      5  18e4				   TEMPORARY_OFFSET SET	0
      6  18e4				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  18e4				   FUNCTION_NAME SET	aiStartSquareSelected
    268  18e4					      SUBROUTINE
    269  18e4
      0  18e4					      REFER	AiStateMachine
      1  18e4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  18e4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  18e4					      ENDIF
      0  18e4					      VEND	aiStartSquareSelected
      1  18e4				  -	      IFNCONST	aiStartSquareSelected
      2  18e4				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  18e4				  -	      ERR
      4  18e4					      ENDIF
      5  18e4		       00 a4	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    272  18e4
    273  18e4
    274  18e4							; Mark all the valid moves for the selected piece on the board
    275  18e4							; and then start pulsing the piece
    276  18e4							; AND start choosing for selection of TO square
    277  18e4
    278  18e4							; Iterate the movelist and for all from squares which = drawPieceNumber
    279  18e4							; then draw a BLANK at that square
    280  18e4							; do 1 by one, when none found then increment state
    281  18e4
    282  18e4		       a5 88		      lda	cursorX12
    283  18e6		       85 80		      sta	squareToDraw
    284  18e8
    285  18e8		       a9 0a		      lda	#10
    286  18ea		       85 8c		      sta	aiFlashDelay
    287  18ec
    288  18ec		       a9 00		      lda	#0
    289  18ee		       85 86		      sta	toX12	;aiToSquareX12
    290  18f0		       85 8e		      sta	aiFlashPhase	; for debounce exit timing
    291  18f2
    292  18f2		       a9 ff		      lda	#-1
    293  18f4		       85 8d		      sta	aiMoveIndex
    294  18f6
    295  18f6		       a9 28		      lda	#HOLD_DELAY
    296  18f8		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    297  18fa
      0  18fa					      PHASE	AI_DrawMoves
      1  18fa		       a9 04		      lda	#AI_DrawMoves
      2  18fc		       85 8b		      sta	aiState
    299  18fe		       60		      rts
    300  18ff
    301  18ff
    302  18ff							;---------------------------------------------------------------------------------------------------
    303  18ff
      0  18ff					      DEF	aiDrawMoves
      1  18ff				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  18ff				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  18ff				   aiDrawMoves
      4  18ff				   TEMPORARY_VAR SET	Overlay
      5  18ff				   TEMPORARY_OFFSET SET	0
      6  18ff				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  18ff				   FUNCTION_NAME SET	aiDrawMoves
    305  18ff					      SUBROUTINE
    306  18ff
      0  18ff					      REFER	AiStateMachine
      1  18ff				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  18ff				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  18ff					      ENDIF
      0  18ff					      VEND	aiDrawMoves
      1  18ff				  -	      IFNCONST	aiDrawMoves
      2  18ff				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  18ff				  -	      ERR
      4  18ff					      ENDIF
      5  18ff		       00 a4	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    309  18ff
    310  18ff		       c6 8a		      dec	ccur
    311  1901		       20 b1 f4 	      jsr	setCursorColours
    312  1904
    313  1904		       c6 89		      dec	mdelay
    314  1906		       d0 25		      bne	.exit
    315  1908		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    316  190a		       85 89		      sta	mdelay	; once triggered, runs always
    317  190c
    318  190c		       a5 8d		      lda	aiMoveIndex
    319  190e		       10 09		      bpl	.valid
    320  1910
    321  1910		       a9 89		      lda	#RAMBANK_PLY+1
    322  1912		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1914					      lda@PLY	moveIndex
      1  1914		       ad d0 f9 	      lda	moveIndex
    324  1917		       85 8d		      sta	aiMoveIndex
    325  1919				   .valid
    326  1919
    327  1919		       20 3a f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    328  191c		       a5 8d		      lda	aiMoveIndex
    329  191e		       10 19		      bpl	.unsure	; still drawing in this phase
    330  1920
    331  1920		       a9 14		      lda	#CAP_SPEED
    332  1922		       85 89		      sta	mdelay
    333  1924
    334  1924		       a9 00		      lda	#0
    335  1926		       85 8e		      sta	aiFlashPhase	; controls odd/even exit of flashing
    336  1928
      0  1928					      PHASE	AI_ShowMoveCaptures
      1  1928		       a9 05		      lda	#AI_ShowMoveCaptures
      2  192a		       85 8b		      sta	aiState
    338  192c		       60		      rts
    339  192d
    340  192d				   .exit
    341  192d
    342  192d							; Initial piece selection has happened, but the button hasn't been released yet
    343  192d							; AND we're still in the waiting phase to see if the button was held long enough for move show
    344  192d
    345  192d		       a5 4c		      lda	INPT4
    346  192f		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    347  1931
    348  1931							; Aha! Button released, so we know the selected piece and can start flashing it
    349  1931							; and allowing movement of the selector to a destination square...
    350  1931
    351  1931		       a9 18		      lda	#6*4
    352  1933		       85 8a		      sta	ccur	; bright green square for selection
    353  1935
      0  1935					      PHASE	AI_SelectDestinationSquare
      1  1935		       a9 08		      lda	#AI_SelectDestinationSquare
      2  1937		       85 8b		      sta	aiState
    355  1939
    356  1939		       60	   .unsure    rts
    357  193a
    358  193a
    359  193a							;---------------------------------------------------------------------------------------------------
    360  193a
      0  193a					      DEF	showMoveOptions
      1  193a				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  193a				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  193a				   showMoveOptions
      4  193a				   TEMPORARY_VAR SET	Overlay
      5  193a				   TEMPORARY_OFFSET SET	0
      6  193a				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  193a				   FUNCTION_NAME SET	showMoveOptions
    362  193a					      SUBROUTINE
    363  193a
      0  193a					      REFER	aiDrawMoves
      1  193a				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  193a				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  193a					      ENDIF
      0  193a					      REFER	aiUnDrawTargetSquares
      1  193a				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  193a				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  193a					      ENDIF
    366  193a
      0  193a					      VAR	__saveIdx, 1
      1  193a		       00 a4	   __saveIdx  =	TEMPORARY_VAR
      2  193a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  193a
      4  193a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  193a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  193a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  193a					      ENDIF
      8  193a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  193a				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  193a				  -	      ERR
     11  193a					      ENDIF
     12  193a					      LIST	ON
      0  193a					      VAR	__piece, 1
      1  193a		       00 a5	   __piece    =	TEMPORARY_VAR
      2  193a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  193a
      4  193a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  193a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  193a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  193a					      ENDIF
      8  193a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  193a				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  193a				  -	      ERR
     11  193a					      ENDIF
     12  193a					      LIST	ON
    369  193a
      0  193a					      VEND	showMoveOptions
      1  193a				  -	      IFNCONST	showMoveOptions
      2  193a				  -	      ECHO	"Incorrect VEND label", showMoveOptions
      3  193a				  -	      ERR
      4  193a					      ENDIF
      5  193a		       00 a6	   VAREND_showMoveOptions =	TEMPORARY_VAR
    371  193a
    372  193a							; place a marker on the board for any square matching the piece
    373  193a							; EXCEPT for squares which are occupied (we'll flash those later)
    374  193a
    375  193a		       a6 8d	   .next      ldx	aiMoveIndex
    376  193c		       86 a4		      stx	__saveIdx
    377  193e		       30 4c		      bmi	.skip
    378  1940
    379  1940		       ad 84 02 	      lda	INTIM
    380  1943		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    381  1945		       90 45		      bcc	.skip
    382  1947
    383  1947		       c6 8d		      dec	aiMoveIndex
    384  1949
    385  1949		       a9 89		      lda	#RAMBANK_PLY+1
    386  194b		       85 3e		      sta	SET_BANK_RAM	;@2
    387  194d
      0  194d					      lda@PLY	MoveFrom,x
      1  194d		       bd 00 f8 	      lda	MoveFrom,x
    389  1950		       c5 85		      cmp	fromX12
    390  1952		       d0 e6		      bne	.next
    391  1954
      0  1954					      lda@PLY	MoveTo,x
      1  1954		       bd 64 f8 	      lda	MoveTo,x
    393  1957		       85 80		      sta	squareToDraw
    394  1959
      0  1959					      lda@PLY	MovePiece,x
      1  1959		       bd 00 f9 	      lda	MovePiece,x
    396  195c		       85 a5		      sta	__piece
    397  195e
    398  195e							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    399  195e							; TODO this could/will fail on sorted lists. MMh.
    400  195e
    401  195e		       ca		      dex
    402  195f		       30 16		      bmi	.prom
    403  1961
      0  1961					      lda@PLY	MoveTo,x
      1  1961		       bd 64 f8 	      lda	MoveTo,x
    405  1964		       c5 80		      cmp	squareToDraw
    406  1966		       d0 0f		      bne	.prom
    407  1968
      0  1968					      lda@PLY	MovePiece,x
      1  1968		       bd 00 f9 	      lda	MovePiece,x
    409  196b		       45 a5		      eor	__piece
    410  196d		       29 0f		      and	#PIECE_MASK
    411  196f		       f0 06		      beq	.prom	; same piece type so not a promote
    412  1971
    413  1971		       c6 8d		      dec	aiMoveIndex
    414  1973		       c6 8d		      dec	aiMoveIndex
    415  1975		       c6 8d		      dec	aiMoveIndex
    416  1977				   .prom
    417  1977
    418  1977		       a4 80		      ldy	squareToDraw
    419  1979
    420  1979		       a9 cc		      lda	#RAMBANK_BOARD
    421  197b		       85 3e		      sta	SET_BANK_RAM	;@3
    422  197d		       b9 79 fc 	      lda	Board,y
    423  1980		       29 0f		      and	#PIECE_MASK
    424  1982		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    425  1984
    426  1984
    427  1984							;lda INTIM
    428  1984							;cmp #SPEEDOF_COPYSINGLEPIECE
    429  1984							;bcc .skip
    430  1984
    431  1984							;lda aiMoveIndex
    432  1984							;sta __saveIdx
    433  1984
    434  1984							; Draw the marker...?
    435  1984
    436  1984		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    437  1986		       20 91 f5 	      jsr	CopySetupForMarker	;@1
    438  1989		       4c c9 f0 	      jmp	InterceptMarkerCopy	;@0
    439  198c
    440  198c
    441  198c
    442  198c		       a5 a4	   .skip      lda	__saveIdx
    443  198e		       85 8d		      sta	aiMoveIndex
    444  1990		       60		      rts
    445  1991
    446  1991
    447  1991							;---------------------------------------------------------------------------------------------------
    448  1991
      0  1991					      DEF	CopySetupForMarker
      1  1991				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  1991				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  1991				   CopySetupForMarker
      4  1991				   TEMPORARY_VAR SET	Overlay
      5  1991				   TEMPORARY_OFFSET SET	0
      6  1991				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  1991				   FUNCTION_NAME SET	CopySetupForMarker
    450  1991					      SUBROUTINE
    451  1991
      0  1991					      REFER	showMoveOptions
      1  1991					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  1991					      ENDIF
      0  1991					      REFER	showPromoteOptions
      1  1991				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  1991				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  1991					      ENDIF
    454  1991
      0  1991					      VAR	__pieceColour, 1
      1  1991		       00 a6	   __pieceColour =	TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1991
      4  1991				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1991				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1991				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1991					      ENDIF
      8  1991				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1991				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  1991				  -	      ERR
     11  1991					      ENDIF
     12  1991					      LIST	ON
      0  1991					      VAR	__oddeven, 1
      1  1991		       00 a7	   __oddeven  =	TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1991
      4  1991				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1991				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1991				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1991					      ENDIF
      8  1991				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1991				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  1991				  -	      ERR
     11  1991					      ENDIF
     12  1991					      LIST	ON
      0  1991					      VAR	__pmcol, 1
      1  1991		       00 a8	   __pmcol    =	TEMPORARY_VAR
      2  1991				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1991
      4  1991				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1991				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1991				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1991					      ENDIF
      8  1991				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1991				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  1991				  -	      ERR
     11  1991					      ENDIF
     12  1991					      LIST	ON
    458  1991
      0  1991					      VEND	CopySetupForMarker
      1  1991				  -	      IFNCONST	CopySetupForMarker
      2  1991				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  1991				  -	      ERR
      4  1991					      ENDIF
      5  1991		       00 a9	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    460  1991
    461  1991		       a5 80		      lda	squareToDraw
    462  1993		       38		      sec
    463  1994		       a0 0a		      ldy	#10
    464  1996		       e9 0a	   .sub10     sbc	#10
    465  1998		       88		      dey
    466  1999		       b0 fb		      bcs	.sub10
    467  199b		       84 a7		      sty	__oddeven
    468  199d		       69 08		      adc	#8
    469  199f		       85 a8		      sta	__pmcol
    470  19a1		       65 a7		      adc	__oddeven
    471  19a3
    472  19a3		       29 01		      and	#1
    473  19a5		       49 01		      eor	#1
    474  19a7		       f0 02		      beq	.white
    475  19a9		       a9 24		      lda	#36
    476  19ab				   .white
    477  19ab		       85 a6		      sta	__pieceColour	; actually SQUARE black/white
    478  19ad
    479  19ad		       8a		      txa
    480  19ae		       18		      clc
    481  19af		       65 a6		      adc	__pieceColour
    482  19b1		       85 a6		      sta	__pieceColour
    483  19b3
    484  19b3		       a5 a8		      lda	__pmcol
    485  19b5		       29 03		      and	#3
    486  19b7
    487  19b7		       18		      clc
    488  19b8		       65 a6		      adc	__pieceColour
    489  19ba		       a8		      tay
    490  19bb		       60		      rts
    491  19bc
    492  19bc
    493  19bc							;---------------------------------------------------------------------------------------------------
    494  19bc
      0  19bc					      DEF	aiUnDrawTargetSquares
      1  19bc				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  19bc				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  19bc				   aiUnDrawTargetSquares
      4  19bc				   TEMPORARY_VAR SET	Overlay
      5  19bc				   TEMPORARY_OFFSET SET	0
      6  19bc				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  19bc				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    496  19bc					      SUBROUTINE
    497  19bc
      0  19bc					      REFER	AiStateMachine
      1  19bc				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  19bc				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  19bc					      ENDIF
      0  19bc					      VEND	aiUnDrawTargetSquares
      1  19bc				  -	      IFNCONST	aiUnDrawTargetSquares
      2  19bc				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  19bc				  -	      ERR
      4  19bc					      ENDIF
      5  19bc		       00 a4	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    500  19bc
    501  19bc
    502  19bc		       c6 8a		      dec	ccur
    503  19be		       20 b1 f4 	      jsr	setCursorColours
    504  19c1
    505  19c1		       c6 89		      dec	mdelay
    506  19c3		       d0 1c		      bne	.exit
    507  19c5		       a9 01		      lda	#1
    508  19c7		       85 89		      sta	mdelay	; once triggered, runs always
    509  19c9
    510  19c9		       a5 8d		      lda	aiMoveIndex
    511  19cb		       10 09		      bpl	.valid
    512  19cd
    513  19cd		       a9 89		      lda	#RAMBANK_PLY+1
    514  19cf		       85 3e		      sta	SET_BANK_RAM	;@2
      0  19d1					      lda@PLY	moveIndex
      1  19d1		       ad d0 f9 	      lda	moveIndex
    516  19d4		       85 8d		      sta	aiMoveIndex
    517  19d6				   .valid
    518  19d6
    519  19d6		       20 3a f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    520  19d9		       a5 8d		      lda	aiMoveIndex
    521  19db		       10 04		      bpl	.exit	; still drawing in this phase
    522  19dd
      0  19dd					      PHASE	AI_SelectStartSquare
      1  19dd		       a9 02		      lda	#AI_SelectStartSquare
      2  19df		       85 8b		      sta	aiState
    524  19e1
    525  19e1		       60	   .exit      rts
    526  19e2
    527  19e2
    528  19e2							;---------------------------------------------------------------------------------------------------
    529  19e2
    530  19e2
      0  19e2					      DEF	aiShowMoveCaptures
      1  19e2				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  19e2				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  19e2				   aiShowMoveCaptures
      4  19e2				   TEMPORARY_VAR SET	Overlay
      5  19e2				   TEMPORARY_OFFSET SET	0
      6  19e2				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  19e2				   FUNCTION_NAME SET	aiShowMoveCaptures
    532  19e2					      SUBROUTINE
    533  19e2
      0  19e2					      REFER	AiStateMachine
      1  19e2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  19e2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  19e2					      ENDIF
      0  19e2					      VEND	aiShowMoveCaptures
      1  19e2				  -	      IFNCONST	aiShowMoveCaptures
      2  19e2				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  19e2				  -	      ERR
      4  19e2					      ENDIF
      5  19e2		       00 a4	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    536  19e2
    537  19e2							; draw/undraw ALL captured pieces
    538  19e2							; we should do this an even number of times so that pieces don't disappEOR
    539  19e2
    540  19e2		       c6 8a		      dec	ccur
    541  19e4		       20 b1 f4 	      jsr	setCursorColours
    542  19e7
    543  19e7		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    544  19e9
    545  19e9		       a5 8d		      lda	aiMoveIndex
    546  19eb		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    547  19ed		       a9 89		      lda	#RAMBANK_PLY+1
    548  19ef		       85 3e		      sta	SET_BANK_RAM	;@2
      0  19f1					      lda@PLY	moveIndex
      1  19f1		       ad d0 f9 	      lda	moveIndex
    550  19f4		       85 8d		      sta	aiMoveIndex
    551  19f6				   .valid
    552  19f6
    553  19f6							;lda #BANK_showMoveCaptures
    554  19f6							;sta SET_BANK;@0
    555  19f6
    556  19f6		       20 d0 f2 	      jsr	showMoveCaptures	;@0
    557  19f9		       a5 8d		      lda	aiMoveIndex
    558  19fb		       10 06		      bpl	.exit
    559  19fd
    560  19fd		       e6 8e		      inc	aiFlashPhase
    561  19ff
      0  19ff					      PHASE	AI_SlowFlash
      1  19ff		       a9 06		      lda	#AI_SlowFlash
      2  1a01		       85 8b		      sta	aiState
    563  1a03
    564  1a03		       60	   .exit      rts
    565  1a04
    566  1a04
    567  1a04							;---------------------------------------------------------------------------------------------------
    568  1a04
      0  1a04					      DEF	aiSlowFlash
      1  1a04				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  1a04				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  1a04				   aiSlowFlash
      4  1a04				   TEMPORARY_VAR SET	Overlay
      5  1a04				   TEMPORARY_OFFSET SET	0
      6  1a04				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  1a04				   FUNCTION_NAME SET	aiSlowFlash
    570  1a04					      SUBROUTINE
    571  1a04
      0  1a04					      REFER	AiStateMachine
      1  1a04				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1a04				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1a04					      ENDIF
      0  1a04					      VEND	aiSlowFlash
      1  1a04				  -	      IFNCONST	aiSlowFlash
      2  1a04				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  1a04				  -	      ERR
      4  1a04					      ENDIF
      5  1a04		       00 a4	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    574  1a04
    575  1a04							; Joystick button is held down, so we're displaying the available moves
    576  1a04							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    577  1a04
    578  1a04		       c6 8a		      dec	ccur
    579  1a06		       20 b1 f4 	      jsr	setCursorColours
    580  1a09
    581  1a09		       a5 8e		      lda	aiFlashPhase
    582  1a0b		       29 01		      and	#1
    583  1a0d		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    584  1a0f
    585  1a0f		       a5 4c		      lda	INPT4
    586  1a11		       30 0d		      bmi	.butpress	; exit on button release
    587  1a13
    588  1a13				   .notEven
    589  1a13
    590  1a13							; Wait for delay to expire then back and flash 'em again
    591  1a13
    592  1a13		       c6 89		      dec	mdelay
    593  1a15		       10 08		      bpl	.slowWait
    594  1a17
    595  1a17		       a9 14		      lda	#CAP_SPEED
    596  1a19		       85 89		      sta	mdelay
    597  1a1b
      0  1a1b					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  1a1b		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1a1d		       85 8b		      sta	aiState
    599  1a1f
    600  1a1f		       60	   .slowWait  rts
    601  1a20
    602  1a20
    603  1a20		       a9 01	   .butpress  lda	#1
    604  1a22		       85 89		      sta	mdelay
    605  1a24
      0  1a24					      PHASE	AI_UnDrawTargetSquares
      1  1a24		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  1a26		       85 8b		      sta	aiState
    607  1a28		       60		      rts
    608  1a29
    609  1a29
    610  1a29							;---------------------------------------------------------------------------------------------------
    611  1a29
      0  1a29					      DEF	moveCursor
      1  1a29				   SLOT_moveCursor SET	_BANK_SLOT
      2  1a29				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  1a29				   moveCursor
      4  1a29				   TEMPORARY_VAR SET	Overlay
      5  1a29				   TEMPORARY_OFFSET SET	0
      6  1a29				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  1a29				   FUNCTION_NAME SET	moveCursor
    613  1a29					      SUBROUTINE
    614  1a29
      0  1a29					      REFER	aiSelectStartSquare
      1  1a29				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  1a29				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  1a29					      ENDIF
      0  1a29					      REFER	aiSelectDestinationSquare
      1  1a29				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  1a29				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  1a29					      ENDIF
    617  1a29
      0  1a29					      VAR	__newCursor, 1
      1  1a29		       00 a4	   __newCursor =	TEMPORARY_VAR
      2  1a29				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1a29
      4  1a29				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1a29				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1a29				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1a29					      ENDIF
      8  1a29				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1a29				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  1a29				  -	      ERR
     11  1a29					      ENDIF
     12  1a29					      LIST	ON
    619  1a29
      0  1a29					      VEND	moveCursor
      1  1a29				  -	      IFNCONST	moveCursor
      2  1a29				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  1a29				  -	      ERR
      4  1a29					      ENDIF
      5  1a29		       00 a5	   VAREND_moveCursor =	TEMPORARY_VAR
    621  1a29
    622  1a29							; Part (a) move cursor around the board waiting for joystick press
    623  1a29
    624  1a29		       a2 00		      ldx	#0	; delay
    625  1a2b
    626  1a2b		       ad 80 02 	      lda	SWCHA
    627  1a2e		       4a		      lsr
    628  1a2f		       4a		      lsr
    629  1a30		       4a		      lsr
    630  1a31		       4a		      lsr
    631  1a32		       a8		      tay
    632  1a33
    633  1a33		       c9 0f		      cmp	#15
    634  1a35		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
    635  1a37
    636  1a37		       c6 89		      dec	mdelay
    637  1a39		       10 1f		      bpl	.delaym
    638  1a3b
    639  1a3b		       18		      clc
    640  1a3c		       a5 88		      lda	cursorX12
    641  1a3e		       79 d4 f4 	      adc	JoyMoveCursor,y
    642  1a41		       85 a4		      sta	__newCursor
    643  1a43		       a8		      tay
    644  1a44
    645  1a44		       a9 cc		      lda	#RAMBANK_BOARD
    646  1a46		       85 3e		      sta	SET_BANK_RAM	;@3
    647  1a48		       b9 15 fc 	      lda	ValidSquare,y
    648  1a4b		       c9 ff		      cmp	#-1
    649  1a4d		       f0 04		      beq	.invalid
    650  1a4f		       a5 a4		      lda	__newCursor
    651  1a51		       85 88		      sta	cursorX12
    652  1a53				   .invalid
    653  1a53
    654  1a53		       a2 10		      ldx	#CURSOR_MOVE_SPEED
    655  1a55		       86 89	   .cursor    stx	mdelay
    656  1a57		       20 99 f4 	      jsr	setCursorPriority
    657  1a5a		       60	   .delaym    rts
    658  1a5b
    659  1a5b
    660  1a5b							;---------------------------------------------------------------------------------------------------
    661  1a5b
      0  1a5b					      DEF	aiSelectDestinationSquare
      1  1a5b				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  1a5b				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  1a5b				   aiSelectDestinationSquare
      4  1a5b				   TEMPORARY_VAR SET	Overlay
      5  1a5b				   TEMPORARY_OFFSET SET	0
      6  1a5b				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  1a5b				   FUNCTION_NAME SET	aiSelectDestinationSquare
    663  1a5b					      SUBROUTINE
    664  1a5b
      0  1a5b					      REFER	AiStateMachine
      1  1a5b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1a5b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1a5b					      ENDIF
      0  1a5b					      VEND	aiSelectDestinationSquare
      1  1a5b				  -	      IFNCONST	aiSelectDestinationSquare
      2  1a5b				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  1a5b				  -	      ERR
      4  1a5b					      ENDIF
      5  1a5b		       00 a4	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    667  1a5b
    668  1a5b							; Piece is selected and now we're looking for a button press on a destination square
    669  1a5b							; we flash the piece on-and-off while we're doing that
    670  1a5b							; Flash the selected piece
    671  1a5b
    672  1a5b		       ad 84 02 	      lda	INTIM
    673  1a5e		       c9 28		      cmp	#ONCEPERFRAME
    674  1a60		       90 0e		      bcc	.exit
    675  1a62
    676  1a62
    677  1a62		       c6 8c		      dec	aiFlashDelay
    678  1a64		       d0 0a		      bne	.exit	; don't flash
    679  1a66		       a9 14		      lda	#CAP_SPEED
    680  1a68		       85 8c		      sta	aiFlashDelay
    681  1a6a
    682  1a6a		       e6 8e		      inc	aiFlashPhase
    683  1a6c
    684  1a6c		       20 c2 f0 	      jsr	CopySinglePiece	;@0
    685  1a6f		       60		      rts
    686  1a70
    687  1a70				   .exit
    688  1a70		       20 29 f6 	      jsr	moveCursor
    689  1a73
    690  1a73		       ad 84 02 	      lda	INTIM
    691  1a76		       c9 14		      cmp	#20
    692  1a78		       90 39		      bcc	.noButton
    693  1a7a
    694  1a7a
    695  1a7a		       a4 88		      ldy	cursorX12
    696  1a7c		       84 86		      sty	toX12
    697  1a7e
      0  1a7e					      CALL	GetPiece	;@3
      1  1a7e				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1a7e				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1a7e				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1a7e				  -	      ERR
      5  1a7e					      ENDIF
      6  1a7e		       a9 d9		      lda	#BANK_GetPiece
      7  1a80		       85 3f		      sta	SET_BANK
      8  1a82		       20 00 fc 	      jsr	GetPiece
    699  1a85		       20 b1 f4 	      jsr	setCursorColours
    700  1a88
    701  1a88
    702  1a88							; y = valid square
    703  1a88
    704  1a88		       a5 4c		      lda	INPT4
    705  1a8a		       30 27		      bmi	.noButton
    706  1a8c
    707  1a8c		       a5 86		      lda	toX12
    708  1a8e		       c5 85		      cmp	fromX12
    709  1a90		       f0 0d		      beq	.cancel
    710  1a92
    711  1a92		       c0 ff		      cpy	#-1
    712  1a94		       f0 1d		      beq	.noButton	; not a valid square
    713  1a96
    714  1a96		       a5 8e		      lda	aiFlashPhase
    715  1a98		       29 01		      and	#1
    716  1a9a		       f0 13		      beq	.done
    717  1a9c		       85 8c		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    718  1a9e		       60		      rts
    719  1a9f
    720  1a9f				   .cancel
    721  1a9f
    722  1a9f		       a5 8e		      lda	aiFlashPhase
    723  1aa1		       29 01		      and	#1
    724  1aa3		       f0 05		      beq	.doCancel
    725  1aa5
    726  1aa5							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    727  1aa5
    728  1aa5		       a9 01		      lda	#1
    729  1aa7		       85 8c		      sta	aiFlashDelay
    730  1aa9		       60		      rts
    731  1aaa
    732  1aaa
      0  1aaa				   .doCancel  PHASE	AI_ReselectDebounce
      1  1aaa		       a9 0a		      lda	#AI_ReselectDebounce
      2  1aac		       85 8b		      sta	aiState
    734  1aae		       60		      rts
    735  1aaf
      0  1aaf				   .done      PHASE	AI_Quiescent	; destination selected!
      1  1aaf		       a9 09		      lda	#AI_Quiescent
      2  1ab1		       85 8b		      sta	aiState
    737  1ab3		       60	   .noButton  rts
    738  1ab4
    739  1ab4
    740  1ab4
    741  1ab4
    742  1ab4							;---------------------------------------------------------------------------------------------------
    743  1ab4
      0  1ab4					      DEF	aiReselectDebounce
      1  1ab4				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  1ab4				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  1ab4				   aiReselectDebounce
      4  1ab4				   TEMPORARY_VAR SET	Overlay
      5  1ab4				   TEMPORARY_OFFSET SET	0
      6  1ab4				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  1ab4				   FUNCTION_NAME SET	aiReselectDebounce
    745  1ab4					      SUBROUTINE
    746  1ab4
      0  1ab4					      REFER	AiStateMachine
      1  1ab4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ab4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ab4					      ENDIF
      0  1ab4					      VEND	aiReselectDebounce
      1  1ab4				  -	      IFNCONST	aiReselectDebounce
      2  1ab4				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  1ab4				  -	      ERR
      4  1ab4					      ENDIF
      5  1ab4		       00 a4	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    749  1ab4
    750  1ab4							; We've just cancelled the move. Wait for the button to be released
    751  1ab4							; and then go back to selecting a piece to move
    752  1ab4
    753  1ab4		       a5 4c		      lda	INPT4
    754  1ab6		       10 04		      bpl	.exit	; button still pressed, so wait
    755  1ab8
      0  1ab8					      PHASE	AI_SelectStartSquare
      1  1ab8		       a9 02		      lda	#AI_SelectStartSquare
      2  1aba		       85 8b		      sta	aiState
    757  1abc		       60	   .exit      rts
    758  1abd
    759  1abd
    760  1abd							;---------------------------------------------------------------------------------------------------
    761  1abd
      0  1abd					      DEF	aiQuiescent
      1  1abd				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  1abd				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  1abd				   aiQuiescent
      4  1abd				   TEMPORARY_VAR SET	Overlay
      5  1abd				   TEMPORARY_OFFSET SET	0
      6  1abd				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  1abd				   FUNCTION_NAME SET	aiQuiescent
    763  1abd					      SUBROUTINE
    764  1abd
      0  1abd					      REFER	AiStateMachine
      1  1abd				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1abd				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1abd					      ENDIF
      0  1abd					      VEND	aiQuiescent
      1  1abd				  -	      IFNCONST	aiQuiescent
      2  1abd				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  1abd				  -	      ERR
      4  1abd					      ENDIF
      5  1abd		       00 a4	   VAREND_aiQuiescent =	TEMPORARY_VAR
    767  1abd
    768  1abd							; Move has been selected
    769  1abd
    770  1abd		       a9 ff		      lda	#-1
    771  1abf		       85 88		      sta	cursorX12
    772  1ac1
    773  1ac1		       a5 85		      lda	fromX12
    774  1ac3		       85 87		      sta	originX12
      0  1ac5					      CALL	GetPiece	;@3		    ; from the movelist
      1  1ac5				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1ac5				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  1ac5				  -	      ECHO	"Cannot switch bank in use for", GetPiece
      4  1ac5				  -	      ERR
      5  1ac5					      ENDIF
      6  1ac5		       a9 d9		      lda	#BANK_GetPiece
      7  1ac7		       85 3f		      sta	SET_BANK
      8  1ac9		       20 00 fc 	      jsr	GetPiece
    776  1acc
    777  1acc		       a4 85		      ldy	fromX12
    778  1ace		       a9 cc		      lda	#RAMBANK_BOARD
    779  1ad0		       85 3e		      sta	SET_BANK_RAM	;@3
    780  1ad2		       b9 79 fc 	      lda	Board,y
    781  1ad5		       45 96		      eor	fromPiece
    782  1ad7		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    783  1ad9		       d0 05		      bne	.promote	; promote a pawn
    784  1adb
      0  1adb					      PHASE	AI_MoveIsSelected
      1  1adb		       a9 14		      lda	#AI_MoveIsSelected
      2  1add		       85 8b		      sta	aiState
    786  1adf		       60		      rts
    787  1ae0
      0  1ae0				   .promote   PHASE	AI_PromotePawnStart
      1  1ae0		       a9 1f		      lda	#AI_PromotePawnStart
      2  1ae2		       85 8b		      sta	aiState
    789  1ae4		       60		      rts
    790  1ae5
    791  1ae5
    792  1ae5							;---------------------------------------------------------------------------------------------------
    793  1ae5
      0  1ae5					      DEF	aiRollPromotionPiece
      1  1ae5				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  1ae5				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  1ae5				   aiRollPromotionPiece
      4  1ae5				   TEMPORARY_VAR SET	Overlay
      5  1ae5				   TEMPORARY_OFFSET SET	0
      6  1ae5				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  1ae5				   FUNCTION_NAME SET	aiRollPromotionPiece
    795  1ae5					      SUBROUTINE
    796  1ae5
      0  1ae5					      REFER	AiStateMachine
      1  1ae5				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ae5				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ae5					      ENDIF
      0  1ae5					      VEND	aiRollPromotionPiece
      1  1ae5				  -	      IFNCONST	aiRollPromotionPiece
      2  1ae5				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  1ae5				  -	      ERR
      4  1ae5					      ENDIF
      5  1ae5		       00 a4	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    799  1ae5
    800  1ae5							; Flash the '?' and wait for an UDLR move
    801  1ae5
    802  1ae5		       ad 84 02 	      lda	INTIM
    803  1ae8		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    804  1aea		       90 28		      bcc	.exit
    805  1aec
    806  1aec		       ad 80 02 	      lda	SWCHA
    807  1aef		       29 f0		      and	#$F0
    808  1af1		       c9 f0		      cmp	#$F0
    809  1af3		       f0 0a		      beq	.nojoy
    810  1af5
    811  1af5		       a9 00		      lda	#0
    812  1af7		       85 8c		      sta	aiFlashDelay
    813  1af9
    814  1af9		       a5 8e		      lda	aiFlashPhase
    815  1afb		       29 01		      and	#1
    816  1afd		       f0 16		      beq	.even
    817  1aff
    818  1aff		       c6 8c	   .nojoy     dec	aiFlashDelay
    819  1b01		       10 11		      bpl	.exit
    820  1b03
    821  1b03		       a9 0a		      lda	#10
    822  1b05		       85 8c		      sta	aiFlashDelay
    823  1b07
    824  1b07		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    825  1b09		       a5 95		      lda	sideToMove
    826  1b0b		       10 02		      bpl	.wtm
    827  1b0d		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    828  1b0f				   .wtm
    829  1b0f		       20 54 fc 	      jsr	showPromoteOptions
    830  1b12
    831  1b12		       e6 8e		      inc	aiFlashPhase
    832  1b14
    833  1b14		       60	   .exit      rts
    834  1b15
    835  1b15
    836  1b15		       a9 03	   .even      lda	#3	; QUEEN
    837  1b17		       85 96		      sta	fromPiece	; cycles as index to NBRQ
    838  1b19
    839  1b19		       e6 8e		      inc	aiFlashPhase
    840  1b1b
    841  1b1b
    842  1b1b		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    843  1b1d		       a5 95		      lda	sideToMove
    844  1b1f		       10 02		      bpl	.whiteToMove
    845  1b21		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    846  1b23				   .whiteToMove
    847  1b23
    848  1b23		       20 54 fc 	      jsr	showPromoteOptions
    849  1b26
      0  1b26					      PHASE	AI_ChooseDebounce
      1  1b26		       a9 22		      lda	#AI_ChooseDebounce
      2  1b28		       85 8b		      sta	aiState
    851  1b2a		       60		      rts
    852  1b2b
    853  1b2b
    854  1b2b
    855  1b2b							;---------------------------------------------------------------------------------------------------
    856  1b2b
      0  1b2b					      DEF	aiMarchA2
      1  1b2b				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  1b2b				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  1b2b				   aiMarchA2
      4  1b2b				   TEMPORARY_VAR SET	Overlay
      5  1b2b				   TEMPORARY_OFFSET SET	0
      6  1b2b				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  1b2b				   FUNCTION_NAME SET	aiMarchA2
    858  1b2b					      SUBROUTINE
    859  1b2b
      0  1b2b					      REFER	AiStateMachine
      1  1b2b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b2b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b2b					      ENDIF
    861  1b2b
      0  1b2b					      VEND	aiMarchA2
      1  1b2b				  -	      IFNCONST	aiMarchA2
      2  1b2b				  -	      ECHO	"Incorrect VEND label", aiMarchA2
      3  1b2b				  -	      ERR
      4  1b2b					      ENDIF
      5  1b2b		       00 a4	   VAREND_aiMarchA2 =	TEMPORARY_VAR
    863  1b2b
    864  1b2b							; erase object in new sqare --> blank
    865  1b2b
    866  1b2b		       a4 85		      ldy	fromX12
    867  1b2d		       84 80		      sty	squareToDraw
    868  1b2f
    869  1b2f		       a9 cc		      lda	#RAMBANK_BOARD
    870  1b31		       85 3e		      sta	SET_BANK_RAM	;@3
    871  1b33		       b9 79 fc 	      lda	Board,y
    872  1b36		       f0 03		      beq	.skipbl
    873  1b38		       20 c2 f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    874  1b3b
    875  1b3b				   .skipbl
    876  1b3b		       a4 85		      ldy	fromX12
    877  1b3d		       84 a5		      sty	__boardIndex
    878  1b3f
    879  1b3f		       a9 cc		      lda	#RAMBANK_BOARD
    880  1b41		       85 3e		      sta	SET_BANK_RAM	;@3
    881  1b43		       b9 79 fc 	      lda	Board,y
    882  1b46		       85 97		      sta	lastPiece	; what we are overwriting
    883  1b48		       a5 96		      lda	fromPiece
    884  1b4a		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    885  1b4c		       29 df		      and	#~FLAG_ENPASSANT
    886  1b4e		       a4 a5		      ldy	__boardIndex
      0  1b50					      sta@RAM	Board,y	; and what's actually moving there
      1  1b50		       99 79 fe 	      sta	[RAM]+Board,y
    888  1b53
    889  1b53
      0  1b53					      PHASE	AI_MarchB
      1  1b53		       a9 18		      lda	#AI_MarchB
      2  1b55		       85 8b		      sta	aiState
    891  1b57		       60		      rts
    892  1b58
    893  1b58
    894  1b58							;---------------------------------------------------------------------------------------------------
    895  1b58
      0  1b58					      DEF	aiMarchB2
      1  1b58				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  1b58				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  1b58				   aiMarchB2
      4  1b58				   TEMPORARY_VAR SET	Overlay
      5  1b58				   TEMPORARY_OFFSET SET	0
      6  1b58				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  1b58				   FUNCTION_NAME SET	aiMarchB2
    897  1b58					      SUBROUTINE
    898  1b58
      0  1b58					      REFER	AiStateMachine
      1  1b58				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b58				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b58					      ENDIF
      0  1b58					      VEND	aiMarchB2
      1  1b58				  -	      IFNCONST	aiMarchB2
      2  1b58				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  1b58				  -	      ERR
      4  1b58					      ENDIF
      5  1b58		       00 a4	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    901  1b58
    902  1b58		       a4 83		      ldy	lastSquareX12
    903  1b5a		       84 80		      sty	squareToDraw
    904  1b5c
    905  1b5c		       a9 cc		      lda	#RAMBANK_BOARD
    906  1b5e		       85 3e		      sta	SET_BANK_RAM	;@3
    907  1b60		       b9 79 fc 	      lda	Board,y
    908  1b63		       f0 03		      beq	.skipbl2
    909  1b65
    910  1b65		       20 c2 f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    911  1b68				   .skipbl2
    912  1b68
    913  1b68		       a5 85		      lda	fromX12
    914  1b6a		       c5 86		      cmp	toX12
    915  1b6c		       f0 09		      beq	xhalt
    916  1b6e
    917  1b6e		       a9 64		      lda	#100	;??? inter-move segment speed (can be 0)
    918  1b70		       85 82		      sta	drawDelay
      0  1b72					      PHASE	AI_MarchToTargetA
      1  1b72		       a9 16		      lda	#AI_MarchToTargetA
      2  1b74		       85 8b		      sta	aiState
    920  1b76
    921  1b76		       60		      rts
    922  1b77
    923  1b77				   xhalt
    924  1b77
    925  1b77							;??? jsr FinaliseMove
    926  1b77
    927  1b77		       a9 04		      lda	#4	; on/off count
    928  1b79		       85 84		      sta	drawCount	; flashing for piece about to move
    929  1b7b		       a9 00		      lda	#0
    930  1b7d		       85 82		      sta	drawDelay
    931  1b7f
      0  1b7f					      PHASE	AI_FinalFlash
      1  1b7f		       a9 1b		      lda	#AI_FinalFlash
      2  1b81		       85 8b		      sta	aiState
    933  1b83		       60		      rts
    934  1b84
    935  1b84
    936  1b84							;---------------------------------------------------------------------------------------------------
    937  1b84
    938  1b84
      0  1b84					      DEF	aiWriteStartPieceBlank
      1  1b84				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  1b84				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  1b84				   aiWriteStartPieceBlank
      4  1b84				   TEMPORARY_VAR SET	Overlay
      5  1b84				   TEMPORARY_OFFSET SET	0
      6  1b84				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  1b84				   FUNCTION_NAME SET	aiWriteStartPieceBlank
    940  1b84					      SUBROUTINE
    941  1b84
      0  1b84					      REFER	AiStateMachine
      1  1b84				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1b84				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1b84					      ENDIF
      0  1b84					      VEND	aiWriteStartPieceBlank
      1  1b84				  -	      IFNCONST	aiWriteStartPieceBlank
      2  1b84				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  1b84				  -	      ERR
      4  1b84					      ENDIF
      5  1b84		       00 a4	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    944  1b84
    945  1b84							; Flash the piece in-place preparatory to moving it.
    946  1b84							; drawDelay = flash speed
    947  1b84							; drawCount = # of flashes
    948  1b84
    949  1b84		       a5 87		      lda	originX12
    950  1b86		       85 88		      sta	cursorX12
    951  1b88
    952  1b88		       a9 04		      lda	#%100
    953  1b8a		       85 4a		      sta	CTRLPF
    954  1b8c		       a9 02		      lda	#2
    955  1b8e		       85 46		      sta	COLUP0
    956  1b90
    957  1b90
    958  1b90		       a5 82		      lda	drawDelay
    959  1b92		       f0 03		      beq	deCount
    960  1b94		       c6 82		      dec	drawDelay
    961  1b96		       60		      rts
    962  1b97				   deCount
    963  1b97
    964  1b97		       a5 84		      lda	drawCount
    965  1b99		       f0 0d		      beq	flashDone
    966  1b9b		       c6 84		      dec	drawCount
    967  1b9d
    968  1b9d		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    969  1b9f		       85 82		      sta	drawDelay	; "getting ready to move" flash
    970  1ba1
    971  1ba1		       a5 85		      lda	fromX12
    972  1ba3		       85 80		      sta	squareToDraw
    973  1ba5
    974  1ba5		       4c c2 f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
    975  1ba8
    976  1ba8				   flashDone
    977  1ba8
      0  1ba8					      PHASE	AI_MarchToTargetA
      1  1ba8		       a9 16		      lda	#AI_MarchToTargetA
      2  1baa		       85 8b		      sta	aiState
    979  1bac		       60		      rts
    980  1bad
    981  1bad
    982  1bad							;---------------------------------------------------------------------------------------------------
    983  1bad
      0  1bad					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  1bad		       03 ad	   .TEMP      =	* - _BANK_START
 BANK_StateMachine (1K) SIZE =  $3ad , FREE= $53
      2  1bad					      ECHO	"BANK_StateMachine", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1bad				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1bad				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine", " size=", * - ORIGIN
      5  1bad				  -	      ERR
      6  1bad					      ENDIF
    985  1bad
    986  1bad
    987  1bad							;---------------------------------------------------------------------------------------------------
    988  1bad
    989  1bad							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#2.asm LEVEL 2 PASS 4
      0  1bad					      include	"BANK_StateMachine@1#2.asm"
      0  1bad					      SLOT	1
      1  1bad				  -	      IF	(1 < 0) || (1 > 3)
      2  1bad				  -	      ECHO	"Illegal bank address/segment location", 1
      3  1bad				  -	      ERR
      4  1bad					      ENDIF
      5  1bad				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  1bad				   _BANK_SLOT SET	1 * 64
      0  1bad					      NEWBANK	STATEMACHINE2
      1  1ea9 ????				      SEG	STATEMACHINE2
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   STATEMACHINE2_START SET	*
      6  1c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1c00				   STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  1c00
      4  1c00							;---------------------------------------------------------------------------------------------------
      5  1c00
      0  1c00					      DEF	aiChoosePromotePiece
      1  1c00				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  1c00				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  1c00				   aiChoosePromotePiece
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  1c00					      SUBROUTINE
      8  1c00
      0  1c00					      REFER	AiStateMachine
      1  1c00				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c00				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c00					      ENDIF
      0  1c00					      VEND	aiChoosePromotePiece
      1  1c00				  -	      IFNCONST	aiChoosePromotePiece
      2  1c00				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  1c00				  -	      ERR
      4  1c00					      ENDIF
      5  1c00		       00 a4	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
     11  1c00
     12  1c00							; Question-mark phase has exited via joystick direction
     13  1c00							; Now we cycle through the selectable pieces
     14  1c00
     15  1c00		       ad 84 02 	      lda	INTIM
     16  1c03		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
     17  1c05		       90 40		      bcc	.exit
     18  1c07
     19  1c07		       a5 4c		      lda	INPT4
     20  1c09		       30 0a		      bmi	.nobut	; no press
     21  1c0b
     22  1c0b							; button pressed but make sure phase is correct for exit
     23  1c0b
     24  1c0b		       a9 00		      lda	#0
     25  1c0d		       85 8c		      sta	aiFlashDelay
     26  1c0f
     27  1c0f		       a5 8e		      lda	aiFlashPhase
     28  1c11		       29 01		      and	#1
     29  1c13		       f0 33		      beq	.chosen	; button pressed --> selection made
     30  1c15
     31  1c15				   .nobut
     32  1c15		       ad 80 02 	      lda	SWCHA
     33  1c18		       29 f0		      and	#$F0
     34  1c1a		       c9 f0		      cmp	#$F0
     35  1c1c		       f0 17		      beq	.odd	; no direction pressed
     36  1c1e
     37  1c1e		       4a		      lsr
     38  1c1f		       4a		      lsr
     39  1c20		       4a		      lsr
     40  1c21		       4a		      lsr
     41  1c22		       a8		      tay
     42  1c23
     43  1c23							; joystick but make sure phase is correct
     44  1c23
     45  1c23		       a5 8e		      lda	aiFlashPhase
     46  1c25		       4a		      lsr
     47  1c26		       b0 0d		      bcs	.odd	; must wait until piece undrawn
     48  1c28
     49  1c28							; cycle to the next promotable piece (N/B/R/Q)
     50  1c28							; TODO; use joy table for mod instead of just incrementing all the time
     51  1c28
     52  1c28							;clc
     53  1c28		       a5 96		      lda	fromPiece
     54  1c2a		       79 c4 f4 	      adc	JoyCombined,y
     55  1c2d		       29 03		      and	#3
     56  1c2f		       85 96		      sta	fromPiece
     57  1c31
      0  1c31					      PHASE	AI_ChooseDebounce	; wait for release
      1  1c31		       a9 22		      lda	#AI_ChooseDebounce
      2  1c33		       85 8b		      sta	aiState
     59  1c35
     60  1c35		       c6 8c	   .odd       dec	aiFlashDelay
     61  1c37		       10 0e		      bpl	.exit
     62  1c39
     63  1c39		       a9 0a	   .force     lda	#10
     64  1c3b		       85 8c		      sta	aiFlashDelay
     65  1c3d
     66  1c3d		       e6 8e		      inc	aiFlashPhase
     67  1c3f
     68  1c3f		       a4 96		      ldy	fromPiece
     69  1c41		       be 67 f4 	      ldx	promotePiece,y
     70  1c44		       20 54 fc 	      jsr	showPromoteOptions
     71  1c47
     72  1c47		       60	   .exit      rts
     73  1c48
     74  1c48
     75  1c48				   .chosen
     76  1c48		       a5 96		      lda	fromPiece
     77  1c4a		       29 0f		      and	#PIECE_MASK
     78  1c4c		       aa		      tax
     79  1c4d
     80  1c4d		       bd 6b f4 	      lda	promoteType,x
     81  1c50		       85 96		      sta	fromPiece
     82  1c52
     83  1c52		       a4 86		      ldy	toX12
     84  1c54		       a9 cc		      lda	#RAMBANK_BOARD
     85  1c56		       85 3e		      sta	SET_BANK_RAM	;@3
     86  1c58		       b9 79 fc 	      lda	Board,y
     87  1c5b		       29 0f		      and	#PIECE_MASK
     88  1c5d		       f0 03		      beq	.nothing
     89  1c5f
     90  1c5f		       20 c2 f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
     91  1c62
      0  1c62				   .nothing   PHASE	AI_MoveIsSelected
      1  1c62		       a9 14		      lda	#AI_MoveIsSelected
      2  1c64		       85 8b		      sta	aiState
     93  1c66		       60		      rts
     94  1c67
      0  1c67					      ALLOCATE	promotePiece, 4
      0  1c67					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1c67					      LIST	ON
      0  1c67					      DEF	promotePiece
      1  1c67				   SLOT_promotePiece SET	_BANK_SLOT
      2  1c67				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  1c67				   promotePiece
      4  1c67				   TEMPORARY_VAR SET	Overlay
      5  1c67				   TEMPORARY_OFFSET SET	0
      6  1c67				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  1c67				   FUNCTION_NAME SET	promotePiece
     96  1c67		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
     97  1c68		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
     98  1c69		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
     99  1c6a		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    100  1c6b
      0  1c6b					      ALLOCATE	promoteType,4
      0  1c6b					      OPTIONAL_PAGEBREAK	"Table", 4
     12  1c6b					      LIST	ON
      0  1c6b					      DEF	promoteType
      1  1c6b				   SLOT_promoteType SET	_BANK_SLOT
      2  1c6b				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  1c6b				   promoteType
      4  1c6b				   TEMPORARY_VAR SET	Overlay
      5  1c6b				   TEMPORARY_OFFSET SET	0
      6  1c6b				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  1c6b				   FUNCTION_NAME SET	promoteType
    102  1c6b		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    103  1c6f
    104  1c6f
    105  1c6f							;---------------------------------------------------------------------------------------------------
    106  1c6f
      0  1c6f					      DEF	aiChooseDebounce
      1  1c6f				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  1c6f				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  1c6f				   aiChooseDebounce
      4  1c6f				   TEMPORARY_VAR SET	Overlay
      5  1c6f				   TEMPORARY_OFFSET SET	0
      6  1c6f				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  1c6f				   FUNCTION_NAME SET	aiChooseDebounce
    108  1c6f					      SUBROUTINE
    109  1c6f
      0  1c6f					      REFER	AiStateMachine
      1  1c6f				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c6f				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c6f					      ENDIF
      0  1c6f					      VEND	aiChooseDebounce
      1  1c6f				  -	      IFNCONST	aiChooseDebounce
      2  1c6f				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  1c6f				  -	      ERR
      4  1c6f					      ENDIF
      5  1c6f		       00 a4	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    112  1c6f
    113  1c6f							; We've changed promotion piece, but wait for joystick to be released
    114  1c6f
    115  1c6f		       ad 80 02 	      lda	SWCHA
    116  1c72		       29 f0		      and	#$F0
    117  1c74		       c9 f0		      cmp	#$F0
    118  1c76		       d0 08		      bne	.exit	; wait while joystick still pressed
    119  1c78
    120  1c78		       a9 01		      lda	#1
    121  1c7a		       85 8c		      sta	aiFlashDelay
    122  1c7c
      0  1c7c					      PHASE	AI_ChoosePromotePiece
      1  1c7c		       a9 21		      lda	#AI_ChoosePromotePiece
      2  1c7e		       85 8b		      sta	aiState
    124  1c80		       60	   .exit      rts
    125  1c81
    126  1c81
    127  1c81							;---------------------------------------------------------------------------------------------------
    128  1c81
      0  1c81					      DEF	aiDelayAfterMove
      1  1c81				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  1c81				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  1c81				   aiDelayAfterMove
      4  1c81				   TEMPORARY_VAR SET	Overlay
      5  1c81				   TEMPORARY_OFFSET SET	0
      6  1c81				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  1c81				   FUNCTION_NAME SET	aiDelayAfterMove
    130  1c81					      SUBROUTINE
    131  1c81
      0  1c81					      REFER	AiStateMachine
      1  1c81				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c81				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c81					      ENDIF
      0  1c81					      VEND	aiDelayAfterMove
      1  1c81				  -	      IFNCONST	aiDelayAfterMove
      2  1c81				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  1c81				  -	      ERR
      4  1c81					      ENDIF
      5  1c81		       00 a4	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    134  1c81
    135  1c81		       a9 32		      lda	#50
    136  1c83		       85 8c		      sta	aiFlashDelay
      0  1c85					      PHASE	AI_DelayAfterMove2
      1  1c85		       a9 26		      lda	#AI_DelayAfterMove2
      2  1c87		       85 8b		      sta	aiState
    138  1c89		       60	   .exit      rts
    139  1c8a
    140  1c8a
    141  1c8a							;---------------------------------------------------------------------------------------------------
    142  1c8a
      0  1c8a					      DEF	aiDelayAfterMove2
      1  1c8a				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  1c8a				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  1c8a				   aiDelayAfterMove2
      4  1c8a				   TEMPORARY_VAR SET	Overlay
      5  1c8a				   TEMPORARY_OFFSET SET	0
      6  1c8a				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  1c8a				   FUNCTION_NAME SET	aiDelayAfterMove2
    144  1c8a					      SUBROUTINE
    145  1c8a
      0  1c8a					      REFER	AiStateMachine
      1  1c8a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c8a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c8a					      ENDIF
      0  1c8a					      VEND	aiDelayAfterMove
      1  1c8a				  -	      IFNCONST	aiDelayAfterMove
      2  1c8a				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  1c8a				  -	      ERR
      4  1c8a					      ENDIF
      5  1c8a		       00 a4	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
    148  1c8a
    149  1c8a		       c6 8c		      dec	aiFlashDelay
    150  1c8c		       d0 04		      bne	.exit
      0  1c8e					      PHASE	AI_MoveIsSelected
      1  1c8e		       a9 14		      lda	#AI_MoveIsSelected
      2  1c90		       85 8b		      sta	aiState
    152  1c92		       60	   .exit      rts
    153  1c93
    154  1c93
    155  1c93							;---------------------------------------------------------------------------------------------------
    156  1c93
      0  1c93					      DEF	aiDelayAfterPlaced
      1  1c93				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  1c93				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  1c93				   aiDelayAfterPlaced
      4  1c93				   TEMPORARY_VAR SET	Overlay
      5  1c93				   TEMPORARY_OFFSET SET	0
      6  1c93				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  1c93				   FUNCTION_NAME SET	aiDelayAfterPlaced
    158  1c93					      SUBROUTINE
    159  1c93
      0  1c93					      REFER	AiStateMachine
      1  1c93				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1c93				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1c93					      ENDIF
      0  1c93					      VEND	aiDelayAfterPlaced
      1  1c93				  -	      IFNCONST	aiDelayAfterPlaced
      2  1c93				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  1c93				  -	      ERR
      4  1c93					      ENDIF
      5  1c93		       00 a4	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
    162  1c93
    163  1c93		       a2 4b		      ldx	#75	; delay after human move
    164  1c95		       a5 95		      lda	sideToMove
    165  1c97		       30 02		      bmi	.computer
    166  1c99		       a2 01		      ldx	#1	; delay after computer move
    167  1c9b		       86 8c	   .computer  stx	aiFlashDelay
    168  1c9d
      0  1c9d					      PHASE	AI_DelayAfterPlaced2
      1  1c9d		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  1c9f		       85 8b		      sta	aiState
    170  1ca1		       60		      rts
    171  1ca2
    172  1ca2
    173  1ca2							;---------------------------------------------------------------------------------------------------
    174  1ca2
      0  1ca2					      DEF	aiDelayAfterPlaced2
      1  1ca2				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  1ca2				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  1ca2				   aiDelayAfterPlaced2
      4  1ca2				   TEMPORARY_VAR SET	Overlay
      5  1ca2				   TEMPORARY_OFFSET SET	0
      6  1ca2				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  1ca2				   FUNCTION_NAME SET	aiDelayAfterPlaced2
    176  1ca2					      SUBROUTINE
    177  1ca2
      0  1ca2					      REFER	AiStateMachine
      1  1ca2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1ca2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1ca2					      ENDIF
      0  1ca2					      VEND	aiDelayAfterPlaced2
      1  1ca2				  -	      IFNCONST	aiDelayAfterPlaced2
      2  1ca2				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced2
      3  1ca2				  -	      ERR
      4  1ca2					      ENDIF
      5  1ca2		       00 a4	   VAREND_aiDelayAfterPlaced2 =	TEMPORARY_VAR
    180  1ca2
    181  1ca2		       c6 8c		      dec	aiFlashDelay
    182  1ca4		       d0 04		      bne	.exit
    183  1ca6
    184  1ca6							;SWAP
    185  1ca6
      0  1ca6					      PHASE	AI_GenerateMoves
      1  1ca6		       a9 12		      lda	#AI_GenerateMoves
      2  1ca8		       85 8b		      sta	aiState
    187  1caa		       60	   .exit      rts
    188  1cab
    189  1cab
    190  1cab							;---------------------------------------------------------------------------------------------------
    191  1cab
      0  1cab					      DEF	aiMarchToTargetB
      1  1cab				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  1cab				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  1cab				   aiMarchToTargetB
      4  1cab				   TEMPORARY_VAR SET	Overlay
      5  1cab				   TEMPORARY_OFFSET SET	0
      6  1cab				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  1cab				   FUNCTION_NAME SET	aiMarchToTargetB
    193  1cab					      SUBROUTINE
    194  1cab
      0  1cab					      REFER	AiStateMachine
      1  1cab				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cab				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cab					      ENDIF
      0  1cab					      VEND	aiMarchToTargetB
      1  1cab				  -	      IFNCONST	aiMarchToTargetB
      2  1cab				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  1cab				  -	      ERR
      4  1cab					      ENDIF
      5  1cab		       00 a4	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    197  1cab
    198  1cab							; now we want to undraw the piece in the old square
    199  1cab
    200  1cab		       a5 83		      lda	lastSquareX12
    201  1cad		       85 80		      sta	squareToDraw
    202  1caf
    203  1caf		       20 c2 f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    204  1cb2
    205  1cb2		       a4 83		      ldy	lastSquareX12
    206  1cb4		       a5 98		      lda	previousPiece
    207  1cb6
    208  1cb6		       a2 cc		      ldx	#RAMBANK_BOARD
    209  1cb8		       86 3e		      stx	SET_BANK_RAM	;@3
      0  1cba					      sta@RAM	Board,y	; and what's actually moving there
      1  1cba		       99 79 fe 	      sta	[RAM]+Board,y
    211  1cbd
    212  1cbd		       a5 97		      lda	lastPiece
    213  1cbf		       85 98		      sta	previousPiece
    214  1cc1
      0  1cc1					      PHASE	AI_MarchB2
      1  1cc1		       a9 1a		      lda	#AI_MarchB2
      2  1cc3		       85 8b		      sta	aiState
    216  1cc5		       60		      rts
    217  1cc6
    218  1cc6
    219  1cc6							;---------------------------------------------------------------------------------------------------
    220  1cc6
      0  1cc6					      DEF	aiPromotePawnStart
      1  1cc6				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  1cc6				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  1cc6				   aiPromotePawnStart
      4  1cc6				   TEMPORARY_VAR SET	Overlay
      5  1cc6				   TEMPORARY_OFFSET SET	0
      6  1cc6				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  1cc6				   FUNCTION_NAME SET	aiPromotePawnStart
    222  1cc6					      SUBROUTINE
    223  1cc6
      0  1cc6					      REFER	AiStateMachine
      1  1cc6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cc6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cc6					      ENDIF
      0  1cc6					      VEND	aiPromotePawnStart
      1  1cc6				  -	      IFNCONST	aiPromotePawnStart
      2  1cc6				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  1cc6				  -	      ERR
      4  1cc6					      ENDIF
      5  1cc6		       00 a4	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    226  1cc6
    227  1cc6
    228  1cc6		       ad 84 02 	      lda	INTIM
    229  1cc9		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    230  1ccb		       90 1c		      bcc	.exit
    231  1ccd
    232  1ccd		       a9 00		      lda	#0
    233  1ccf		       85 8e		      sta	aiFlashPhase
    234  1cd1		       85 8c		      sta	aiFlashDelay
    235  1cd3
    236  1cd3		       a4 86		      ldy	toX12
    237  1cd5		       84 80		      sty	squareToDraw
    238  1cd7
    239  1cd7		       a9 cc		      lda	#RAMBANK_BOARD
    240  1cd9		       85 3e		      sta	SET_BANK_RAM	;@3
    241  1cdb		       b9 79 fc 	      lda	Board,y
    242  1cde		       29 0f		      and	#PIECE_MASK
    243  1ce0		       f0 03		      beq	.empty
    244  1ce2
    245  1ce2		       20 c2 f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    246  1ce5
      0  1ce5				   .empty     PHASE	AI_RollPromotionPiece
      1  1ce5		       a9 20		      lda	#AI_RollPromotionPiece
      2  1ce7		       85 8b		      sta	aiState
    248  1ce9		       60	   .exit      rts
    249  1cea
    250  1cea
    251  1cea							;---------------------------------------------------------------------------------------------------
    252  1cea
      0  1cea					      DEF	aiGenerateMoves
      1  1cea				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  1cea				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  1cea				   aiGenerateMoves
      4  1cea				   TEMPORARY_VAR SET	Overlay
      5  1cea				   TEMPORARY_OFFSET SET	0
      6  1cea				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  1cea				   FUNCTION_NAME SET	aiGenerateMoves
    254  1cea					      SUBROUTINE
    255  1cea
      0  1cea					      REFER	AiStateMachine
      1  1cea				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cea				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cea					      ENDIF
      0  1cea					      VEND	aiGenerateMoves
      1  1cea				  -	      IFNCONST	aiGenerateMoves
      2  1cea				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  1cea				  -	      ERR
      4  1cea					      ENDIF
      5  1cea		       00 a4	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    258  1cea
    259  1cea		       a5 86		      lda	toX12
    260  1cec		       85 80		      sta	squareToDraw	; for showing move (display square)
    261  1cee
    262  1cee		       a6 95		      ldx	sideToMove
    263  1cf0		       10 05		      bpl	.player
    264  1cf2
    265  1cf2
      0  1cf2				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  1cf2		       a9 13		      lda	#AI_ComputerMove
      2  1cf4		       85 8b		      sta	aiState
    267  1cf6		       60		      rts
    268  1cf7
    269  1cf7
      0  1cf7				   .player    PHASE	AI_StartMoveGen
      1  1cf7		       a9 0b		      lda	#AI_StartMoveGen
      2  1cf9		       85 8b		      sta	aiState
    271  1cfb		       60		      rts
    272  1cfc
    273  1cfc
    274  1cfc							;---------------------------------------------------------------------------------------------------
    275  1cfc
      0  1cfc					      DEF	aiStepMoveGen
      1  1cfc				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  1cfc				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  1cfc				   aiStepMoveGen
      4  1cfc				   TEMPORARY_VAR SET	Overlay
      5  1cfc				   TEMPORARY_OFFSET SET	0
      6  1cfc				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  1cfc				   FUNCTION_NAME SET	aiStepMoveGen
    277  1cfc					      SUBROUTINE
    278  1cfc
      0  1cfc					      REFER	AiStateMachine
      1  1cfc				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1cfc				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1cfc					      ENDIF
      0  1cfc					      VEND	aiStepMoveGen
      1  1cfc				  -	      IFNCONST	aiStepMoveGen
      2  1cfc				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  1cfc				  -	      ERR
      4  1cfc					      ENDIF
      5  1cfc		       00 a4	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    281  1cfc
    282  1cfc		       a5 87		      lda	originX12	; location of cursor (show move)
    283  1cfe		       85 88		      sta	cursorX12
      0  1d00					      PHASE	AI_BeginSelectMovePhase
      1  1d00		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  1d02		       85 8b		      sta	aiState
    285  1d04		       60		      rts
    286  1d05
    287  1d05
    288  1d05							;---------------------------------------------------------------------------------------------------
    289  1d05
    290  1e00		       00 00 00 00*	      align	256	; TODO?
      0  1e00					      DEF	PositionSprites
      1  1e00				   SLOT_PositionSprites SET	_BANK_SLOT
      2  1e00				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  1e00				   PositionSprites
      4  1e00				   TEMPORARY_VAR SET	Overlay
      5  1e00				   TEMPORARY_OFFSET SET	0
      6  1e00				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  1e00				   FUNCTION_NAME SET	PositionSprites
    292  1e00					      SUBROUTINE
    293  1e00
      0  1e00					      REFER	StartupBankReset
      1  1e00				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1e00				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1e00					      ENDIF
      0  1e00					      VEND	PositionSprites
      1  1e00				  -	      IFNCONST	PositionSprites
      2  1e00				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  1e00				  -	      ERR
      4  1e00					      ENDIF
      5  1e00		       00 a4	   VAREND_PositionSprites =	TEMPORARY_VAR
    296  1e00
    297  1e00
    298  1e00		       a5 88		      lda	cursorX12
    299  1e02		       38		      sec
    300  1e03		       e9 0a	   .sub10     sbc	#10
    301  1e05		       b0 fc		      bcs	.sub10
    302  1e07		       69 08		      adc	#8
    303  1e09		       a8		      tay
    304  1e0a
    305  1e0a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    306  1e0c
    307  1e0c		       b9 30 f6 	      lda	colToPixel,y
    308  1e0f
    309  1e0f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    310  1e10		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    311  1e12		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    312  1e14
    313  1e14		       a8		      tay
    314  1e15		       b9 30 f5 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    315  1e18		       85 60		      sta	HMP0
    316  1e1a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    317  1e1c
    318  1e1c		       85 42		      sta	WSYNC
    319  1e1e		       85 6a		      sta	HMOVE
    320  1e20
    321  1e20		       60		      rts
    322  1e21
    323  1e21							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    324  1e21							; fine adjustment value. This table is on a page boundary to guarantee the processor
    325  1e21							; will cross a page boundary and waste a cycle in order to be at the precise position
    326  1e21							; for a RESP0,x write
    327  1e21
    328  1e21				   fineAdjustBegin
    329  1e21
    330  1e21		       70		      DC.B	%01110000	; Left 7
    331  1e22		       60		      DC.B	%01100000	; Left 6
    332  1e23		       50		      DC.B	%01010000	; Left 5
    333  1e24		       40		      DC.B	%01000000	; Left 4
    334  1e25		       30		      DC.B	%00110000	; Left 3
    335  1e26		       20		      DC.B	%00100000	; Left 2
    336  1e27		       10		      DC.B	%00010000	; Left 1
    337  1e28		       00		      DC.B	%00000000	; No movement.
    338  1e29		       f0		      DC.B	%11110000	; Right 1
    339  1e2a		       e0		      DC.B	%11100000	; Right 2
    340  1e2b		       d0		      DC.B	%11010000	; Right 3
    341  1e2c		       c0		      DC.B	%11000000	; Right 4
    342  1e2d		       b0		      DC.B	%10110000	; Right 5
    343  1e2e		       a0		      DC.B	%10100000	; Right 6
    344  1e2f		       90		      DC.B	%10010000	; Right 7
    345  1e30
    346  1e30		       f5 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    347  1e30
    348  1e30
      0  1e30					      ALLOCATE	colToPixel, 8
      0  1e30					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1e30					      LIST	ON
      0  1e30					      DEF	colToPixel
      1  1e30				   SLOT_colToPixel SET	_BANK_SLOT
      2  1e30				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  1e30				   colToPixel
      4  1e30				   TEMPORARY_VAR SET	Overlay
      5  1e30				   TEMPORARY_OFFSET SET	0
      6  1e30				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  1e30				   FUNCTION_NAME SET	colToPixel
    350  1e30		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    351  1e38
    352  1e38
    353  1e38							;---------------------------------------------------------------------------------------------------
    354  1e38
      0  1e38					      DEF	aiMarchToTargetA
      1  1e38				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  1e38				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  1e38				   aiMarchToTargetA
      4  1e38				   TEMPORARY_VAR SET	Overlay
      5  1e38				   TEMPORARY_OFFSET SET	0
      6  1e38				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  1e38				   FUNCTION_NAME SET	aiMarchToTargetA
    356  1e38					      SUBROUTINE
    357  1e38
      0  1e38					      REFER	AiStateMachine
      1  1e38				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e38				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e38					      ENDIF
    359  1e38
      0  1e38					      VAR	__fromRow, 1
      1  1e38		       00 a4	   __fromRow  =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
      0  1e38					      VAR	__boardIndex, 1
      1  1e38		       00 a5	   __boardIndex =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
      0  1e38					      VAR	__fromCol, 1
      1  1e38		       00 a6	   __fromCol  =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
      0  1e38					      VAR	__toCol, 1
      1  1e38		       00 a7	   __toCol    =	TEMPORARY_VAR
      2  1e38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1e38
      4  1e38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1e38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1e38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1e38					      ENDIF
      8  1e38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1e38				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  1e38				  -	      ERR
     11  1e38					      ENDIF
     12  1e38					      LIST	ON
    364  1e38
      0  1e38					      VEND	aiMarchToTargetA
      1  1e38				  -	      IFNCONST	aiMarchToTargetA
      2  1e38				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  1e38				  -	      ERR
      4  1e38					      ENDIF
      5  1e38		       00 a8	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    366  1e38
    367  1e38
    368  1e38							; Now we calculate move to new square
    369  1e38
    370  1e38		       a5 85		      lda	fromX12
    371  1e3a		       c5 86		      cmp	toX12
    372  1e3c		       f0 44		      beq	.unmovedx
    373  1e3e		       85 83		      sta	lastSquareX12
    374  1e40
    375  1e40		       38		      sec
    376  1e41		       a2 fd		      ldx	#-3
    377  1e43		       e9 0a	   .sub10     sbc	#10
    378  1e45		       e8		      inx
    379  1e46		       b0 fb		      bcs	.sub10
    380  1e48		       69 08		      adc	#8
    381  1e4a		       85 a6		      sta	__fromCol
    382  1e4c		       86 a4		      stx	__fromRow
    383  1e4e
    384  1e4e		       a5 86		      lda	toX12
    385  1e50		       38		      sec
    386  1e51		       a2 fd		      ldx	#-3
    387  1e53		       e9 0a	   .sub10b    sbc	#10
    388  1e55		       e8		      inx
    389  1e56		       b0 fb		      bcs	.sub10b
    390  1e58		       69 08		      adc	#8
    391  1e5a		       85 a7		      sta	__toCol
    392  1e5c
    393  1e5c
    394  1e5c		       e4 a4		      cpx	__fromRow
    395  1e5e		       f0 13		      beq	.rowDone
    396  1e60
    397  1e60		       b0 0a		      bcs	.incRow
    398  1e62
    399  1e62		       38		      sec
    400  1e63		       a5 85		      lda	fromX12
    401  1e65		       e9 0a		      sbc	#10
    402  1e67		       85 85		      sta	fromX12
    403  1e69		       4c 73 f6 	      jmp	.rowDone
    404  1e6c
    405  1e6c		       18	   .incRow    clc
    406  1e6d		       a5 85		      lda	fromX12
    407  1e6f		       69 0a		      adc	#10
    408  1e71		       85 85		      sta	fromX12
    409  1e73
    410  1e73				   .rowDone
    411  1e73
    412  1e73		       a5 a7		      lda	__toCol
    413  1e75		       c5 a6		      cmp	__fromCol
    414  1e77		       f0 09		      beq	.colDone
    415  1e79
    416  1e79		       b0 05		      bcs	.incCol
    417  1e7b
    418  1e7b		       c6 85		      dec	fromX12
    419  1e7d		       4c 82 f6 	      jmp	.colDone
    420  1e80
    421  1e80		       e6 85	   .incCol    inc	fromX12
    422  1e82				   .colDone
    423  1e82				   .unmovedx
    424  1e82
      0  1e82					      PHASE	AI_MarchA2
      1  1e82		       a9 17		      lda	#AI_MarchA2
      2  1e84		       85 8b		      sta	aiState
    426  1e86		       60		      rts
    427  1e87
    428  1e87
    429  1e87							;---------------------------------------------------------------------------------------------------
    430  1e87
      0  1e87					      DEF	aiFinalFlash
      1  1e87				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  1e87				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  1e87				   aiFinalFlash
      4  1e87				   TEMPORARY_VAR SET	Overlay
      5  1e87				   TEMPORARY_OFFSET SET	0
      6  1e87				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  1e87				   FUNCTION_NAME SET	aiFinalFlash
    432  1e87					      SUBROUTINE
    433  1e87
      0  1e87					      REFER	AiStateMachine
      1  1e87				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1e87				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1e87					      ENDIF
      0  1e87					      VEND	aiFinalFlash
      1  1e87				  -	      IFNCONST	aiFinalFlash
      2  1e87				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  1e87				  -	      ERR
      4  1e87					      ENDIF
      5  1e87		       00 a4	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    436  1e87
    437  1e87							; Piece has finished the animated move and is now in destination square.
    438  1e87							; Flash the piece
    439  1e87
    440  1e87		       a5 82		      lda	drawDelay
    441  1e89		       f0 03		      beq	.deCount
    442  1e8b		       c6 82		      dec	drawDelay
    443  1e8d		       60		      rts
    444  1e8e
    445  1e8e		       a5 84	   .deCount   lda	drawCount
    446  1e90		       f0 0e		      beq	.flashDone2
    447  1e92		       c6 84		      dec	drawCount
    448  1e94
    449  1e94		       a9 0a		      lda	#10
    450  1e96		       85 82		      sta	drawDelay	; "getting ready to move" flash
    451  1e98
    452  1e98		       a5 85		      lda	fromX12
    453  1e9a		       85 80		      sta	squareToDraw
    454  1e9c
    455  1e9c		       20 c2 f0 	      jsr	CopySinglePiece	;@0
    456  1e9f		       60		      rts
    457  1ea0
    458  1ea0				   .flashDone2
    459  1ea0
    460  1ea0		       a9 64		      lda	#100
    461  1ea2		       85 8c		      sta	aiFlashDelay
    462  1ea4
      0  1ea4					      PHASE	AI_SpecialMoveFixup
      1  1ea4		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  1ea6		       85 8b		      sta	aiState
    464  1ea8		       60		      rts
    465  1ea9
    466  1ea9
    467  1ea9							;---------------------------------------------------------------------------------------------------
    468  1ea9
    469  1ea9
      0  1ea9					      CHECK_BANK_SIZE	"BANK_StateMachine2"
      1  1ea9		       02 a9	   .TEMP      =	* - _BANK_START
 BANK_StateMachine2 (1K) SIZE =  $2a9 , FREE= $157
      2  1ea9					      ECHO	"BANK_StateMachine2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1ea9				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1ea9				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine2", " size=", * - ORIGIN
      5  1ea9				  -	      ERR
      6  1ea9					      ENDIF
    471  1ea9
    472  1ea9
    473  1ea9							;---------------------------------------------------------------------------------------------------
    474  1ea9
    475  1ea9							; EOF
------- FILE ./chess.asm
------- FILE piece_graphics.asm LEVEL 2 PASS 4
      0  1ea9					      include	"piece_graphics.asm"
      1  1ea9							; Import the graphics definitions generated by ConvertChessPieces.py
      2  1ea9
      0  1ea9					      SLOT	2
      1  1ea9				  -	      IF	(2 < 0) || (2 > 3)
      2  1ea9				  -	      ECHO	"Illegal bank address/segment location", 2
      3  1ea9				  -	      ERR
      4  1ea9					      ENDIF
      5  1ea9				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  1ea9				   _BANK_SLOT SET	2 * 64
      0  1ea9					      NEWBANK	PIECES_0
      1  23d8 ????				      SEG	PIECES_0
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   PIECES_0_START SET	*
      6  2000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2000				   PIECES_0   SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + 1024
      5  2000
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2000					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  2000					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  2000					      LIST	ON
      0  2000					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  2000				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2000				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2000				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  2000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  2018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  2030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2048					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  2048					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  2048					      LIST	ON
      0  2048					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  2048				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2048				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2048				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  2048				   TEMPORARY_VAR SET	Overlay
      5  2048				   TEMPORARY_OFFSET SET	0
      6  2048				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2048				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  2048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2090					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  2090					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  2090					      LIST	ON
      0  2090					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  2090				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2090				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2090				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  2090				   TEMPORARY_VAR SET	Overlay
      5  2090				   TEMPORARY_OFFSET SET	0
      6  2090				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2090				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  2090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  20a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  20c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  20d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  20d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  2100					      LIST	ON
      0  2100					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  2100				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2100				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2100				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  2100				   TEMPORARY_VAR SET	Overlay
      5  2100				   TEMPORARY_OFFSET SET	0
      6  2100				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2100				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  2100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2148					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  2148					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  2148					      LIST	ON
      0  2148					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  2148				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2148				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2148				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  2148				   TEMPORARY_VAR SET	Overlay
      5  2148				   TEMPORARY_OFFSET SET	0
      6  2148				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2148				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  2148		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2190					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  2190					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  2190					      LIST	ON
      0  2190					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  2190				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2190				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2190				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  2190				   TEMPORARY_VAR SET	Overlay
      5  2190				   TEMPORARY_OFFSET SET	0
      6  2190				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2190				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  2190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  21a8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  21c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  21d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  21d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  2200					      LIST	ON
      0  2200					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  2200				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2200				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2200				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  2200				   TEMPORARY_VAR SET	Overlay
      5  2200				   TEMPORARY_OFFSET SET	0
      6  2200				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2200				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  2200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2218		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2230		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2248					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  2248					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  2248					      LIST	ON
      0  2248					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  2248				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2248				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2248				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  2248				   TEMPORARY_VAR SET	Overlay
      5  2248				   TEMPORARY_OFFSET SET	0
      6  2248				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2248				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  2248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2278		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2290					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2290					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2290					      LIST	ON
      0  2290					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  2290				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2290				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2290				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  2290				   TEMPORARY_VAR SET	Overlay
      5  2290				   TEMPORARY_OFFSET SET	0
      6  2290				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2290				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  2290		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  22a8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  22c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  22d8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  22d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2300					      LIST	ON
      0  2300					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  2300				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2300				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2300				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  2300				   TEMPORARY_VAR SET	Overlay
      5  2300				   TEMPORARY_OFFSET SET	0
      6  2300				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2300				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  2300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2318		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2348					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2348					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2348					      LIST	ON
      0  2348					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  2348				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2348				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2348				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  2348				   TEMPORARY_VAR SET	Overlay
      5  2348				   TEMPORARY_OFFSET SET	0
      6  2348				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2348				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  2348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2360		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2378		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2390					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2390					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2390					      LIST	ON
      0  2390					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  2390				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2390				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2390				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  2390				   TEMPORARY_VAR SET	Overlay
      5  2390				   TEMPORARY_OFFSET SET	0
      6  2390				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2390				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  2390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  23a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  23c0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  23d8					      CHECK_BANK_SIZE	"PIECES_0 (1K)"
      1  23d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_0 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  23d8					      ECHO	"PIECES_0 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  23d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  23d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_0 (1K)", " size=", * - ORIGIN
      5  23d8				  -	      ERR
      6  23d8					      ENDIF
     19  23d8
      0  23d8					      SLOT	2
      1  23d8				  -	      IF	(2 < 0) || (2 > 3)
      2  23d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  23d8				  -	      ERR
      4  23d8					      ENDIF
      5  23d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  23d8				   _BANK_SLOT SET	2 * 64
      0  23d8					      NEWBANK	PIECES_1
      1  27d8 ????				      SEG	PIECES_1
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   PIECES_1_START SET	*
      6  2400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2400				   PIECES_1   SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2400					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2400					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  2400					      LIST	ON
      0  2400					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  2400				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2400				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2400				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  2400				   TEMPORARY_VAR SET	Overlay
      5  2400				   TEMPORARY_OFFSET SET	0
      6  2400				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2400				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  2400		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  2418		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2448					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  2448					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  2448					      LIST	ON
      0  2448					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  2448				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2448				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2448				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  2448				   TEMPORARY_VAR SET	Overlay
      5  2448				   TEMPORARY_OFFSET SET	0
      6  2448				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2448				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  2448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2460		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  2478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2490					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2490					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  2490					      LIST	ON
      0  2490					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  2490				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2490				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2490				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  2490				   TEMPORARY_VAR SET	Overlay
      5  2490				   TEMPORARY_OFFSET SET	0
      6  2490				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2490				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  2490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  24a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  24c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  24d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  24d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  2500					      LIST	ON
      0  2500					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  2500				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2500				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2500				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  2500				   TEMPORARY_VAR SET	Overlay
      5  2500				   TEMPORARY_OFFSET SET	0
      6  2500				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2500				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  2500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2530		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2548					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  2548					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  2548					      LIST	ON
      0  2548					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  2548				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2548				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2548				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  2548				   TEMPORARY_VAR SET	Overlay
      5  2548				   TEMPORARY_OFFSET SET	0
      6  2548				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2548				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  2548		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2560		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2590					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  2590					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  2590					      LIST	ON
      0  2590					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  2590				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2590				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2590				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  2590				   TEMPORARY_VAR SET	Overlay
      5  2590				   TEMPORARY_OFFSET SET	0
      6  2590				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2590				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  2590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  25a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  25c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  25d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  25d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  2600					      LIST	ON
      0  2600					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  2600				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2600				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2600				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  2600				   TEMPORARY_VAR SET	Overlay
      5  2600				   TEMPORARY_OFFSET SET	0
      6  2600				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2600				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  2600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2618		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2630		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2648					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  2648					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  2648					      LIST	ON
      0  2648					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  2648				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2648				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2648				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  2648				   TEMPORARY_VAR SET	Overlay
      5  2648				   TEMPORARY_OFFSET SET	0
      6  2648				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2648				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  2648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2678		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2690					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  2690					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  2690					      LIST	ON
      0  2690					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  2690				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2690				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2690				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  2690				   TEMPORARY_VAR SET	Overlay
      5  2690				   TEMPORARY_OFFSET SET	0
      6  2690				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2690				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  2690		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  26a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  26c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  26d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  26d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  2700					      LIST	ON
      0  2700					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  2700				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2700				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2700				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  2700				   TEMPORARY_VAR SET	Overlay
      5  2700				   TEMPORARY_OFFSET SET	0
      6  2700				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2700				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  2700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2718		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2748					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  2748					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  2748					      LIST	ON
      0  2748					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  2748				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2748				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2748				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  2748				   TEMPORARY_VAR SET	Overlay
      5  2748				   TEMPORARY_OFFSET SET	0
      6  2748				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2748				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  2748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2760		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2778		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2790					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  2790					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  2790					      LIST	ON
      0  2790					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  2790				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2790				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2790				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  2790				   TEMPORARY_VAR SET	Overlay
      5  2790				   TEMPORARY_OFFSET SET	0
      6  2790				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2790				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  2790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  27a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  27c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  27d8					      CHECK_BANK_SIZE	"PIECES_1 (1K)"
      1  27d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_1 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  27d8					      ECHO	"PIECES_1 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  27d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  27d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_1 (1K)", " size=", * - ORIGIN
      5  27d8				  -	      ERR
      6  27d8					      ENDIF
      0  27d8					      SLOT	2
      1  27d8				  -	      IF	(2 < 0) || (2 > 3)
      2  27d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  27d8				  -	      ERR
      4  27d8					      ENDIF
      5  27d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  27d8				   _BANK_SLOT SET	2 * 64
      0  27d8					      NEWBANK	PIECES_2
      1  2bd8 ????				      SEG	PIECES_2
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   PIECES_2_START SET	*
      6  2800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2800				   PIECES_2   SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2800					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  2800				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2800				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2800				   WHITE_KING_on_WHITE_SQUARE_0
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  2800		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  2818		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2848					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  2848				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2848				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2848				   WHITE_KING_on_WHITE_SQUARE_1
      4  2848				   TEMPORARY_VAR SET	Overlay
      5  2848				   TEMPORARY_OFFSET SET	0
      6  2848				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2848				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2890					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  2890				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2890				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2890				   WHITE_KING_on_WHITE_SQUARE_2
      4  2890				   TEMPORARY_VAR SET	Overlay
      5  2890				   TEMPORARY_OFFSET SET	0
      6  2890				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2890				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  28c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  28d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  2900				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2900				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2900				   WHITE_KING_on_WHITE_SQUARE_3
      4  2900				   TEMPORARY_VAR SET	Overlay
      5  2900				   TEMPORARY_OFFSET SET	0
      6  2900				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2900				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2948					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  2948				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2948				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2948				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  2948				   TEMPORARY_VAR SET	Overlay
      5  2948				   TEMPORARY_OFFSET SET	0
      6  2948				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2948				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  2948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2990					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  2990				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2990				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2990				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  2990				   TEMPORARY_VAR SET	Overlay
      5  2990				   TEMPORARY_OFFSET SET	0
      6  2990				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2990				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  29d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  2a00				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2a00				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2a00				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  2a00				   TEMPORARY_VAR SET	Overlay
      5  2a00				   TEMPORARY_OFFSET SET	0
      6  2a00				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2a00				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2a48					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  2a48				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2a48				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2a48				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  2a48				   TEMPORARY_VAR SET	Overlay
      5  2a48				   TEMPORARY_OFFSET SET	0
      6  2a48				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2a48				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2a90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  2a90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2a90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2a90				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  2a90				   TEMPORARY_VAR SET	Overlay
      5  2a90				   TEMPORARY_OFFSET SET	0
      6  2a90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2a90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  2a90		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  2aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ad8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  2b00				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2b00				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2b00				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  2b00				   TEMPORARY_VAR SET	Overlay
      5  2b00				   TEMPORARY_OFFSET SET	0
      6  2b00				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2b00				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2b48					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  2b48				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2b48				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2b48				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  2b48				   TEMPORARY_VAR SET	Overlay
      5  2b48				   TEMPORARY_OFFSET SET	0
      6  2b48				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2b48				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  2b78		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2b90					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  2b90				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2b90				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2b90				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  2b90				   TEMPORARY_VAR SET	Overlay
      5  2b90				   TEMPORARY_OFFSET SET	0
      6  2b90				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2b90				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
      0  2bd8					      CHECK_BANK_SIZE	"PIECES_2 (1K)"
      1  2bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_2 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2bd8					      ECHO	"PIECES_2 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_2 (1K)", " size=", * - ORIGIN
      5  2bd8				  -	      ERR
      6  2bd8					      ENDIF
      0  2bd8					      SLOT	2
      1  2bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2bd8				  -	      ERR
      4  2bd8					      ENDIF
      5  2bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2bd8				   _BANK_SLOT SET	2 * 64
      0  2bd8					      NEWBANK	PIECES_3
      1  2fd8 ????				      SEG	PIECES_3
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   PIECES_3_START SET	*
      6  2c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2c00				   PIECES_3   SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  2c00				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2c00				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  2c00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  2c18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  2c48				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2c48				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  2c90				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2c90				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  2cc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  2d00				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2d00				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  2d48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2d48				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  2d48		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  2d60		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  2d90				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2d90				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  2e00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2e00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  2e30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  2e48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2e48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  2e90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  2e90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  2ea8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  2f00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  2f48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  2f78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  2f90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECES_3 (1K)"
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_3 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  2fd8					      ECHO	"PIECES_3 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_3 (1K)", " size=", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      0  2fd8					      SLOT	2
      1  2fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  2fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  2fd8				  -	      ERR
      4  2fd8					      ENDIF
      5  2fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  2fd8				   _BANK_SLOT SET	2 * 64
      0  2fd8					      NEWBANK	PIECE_4
      1  33d8 ????				      SEG	PIECE_4
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   PIECE_4_START SET	*
      6  3000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3000				   PIECE_4    SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  3000				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  3000		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  3048				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  3090				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  30c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  3100				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3100				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3100				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  3148				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3148				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3148				   WHITE_KING_on_BLACK_SQUARE_0
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  3148		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  3160		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  3190				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3190				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3190				   WHITE_KING_on_BLACK_SQUARE_1
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  3200				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3200				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3200				   WHITE_KING_on_BLACK_SQUARE_2
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3230		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  3248				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3248				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3248				   WHITE_KING_on_BLACK_SQUARE_3
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  3290				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3290				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3290				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  3290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  32a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  3300				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3300				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3300				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  3348				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3348				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3348				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3378		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  3390				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3390				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3390				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
      0  33d8					      CHECK_BANK_SIZE	"PIECES_4 (1K)"
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_4 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  33d8					      ECHO	"PIECES_4 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_4 (1K)", " size=", * - ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      0  33d8					      SLOT	2
      1  33d8				  -	      IF	(2 < 0) || (2 > 3)
      2  33d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  33d8				  -	      ERR
      4  33d8					      ENDIF
      5  33d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  33d8				   _BANK_SLOT SET	2 * 64
      0  33d8					      NEWBANK	PIECE_5
      1  37d8 ????				      SEG	PIECE_5
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   PIECE_5_START SET	*
      6  3400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3400				   PIECE_5    SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  3400				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3400				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3400				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  3400		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  3418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  3448				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3448				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3448				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  3490				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3490				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3490				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  34c0		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  3500				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3500				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3500				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  3548				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3548				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3548				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  3548		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  3560		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  3590				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3590				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3590				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  3600				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3600				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3600				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  3630		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  3648				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3648				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  3690				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3690				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  3690		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  36a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  3700				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3700				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  3748				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3748				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  3778		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  3790				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3790				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECES_5 (1K)"
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_5 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  37d8					      ECHO	"PIECES_5 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_5 (1K)", " size=", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      0  37d8					      SLOT	2
      1  37d8				  -	      IF	(2 < 0) || (2 > 3)
      2  37d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  37d8				  -	      ERR
      4  37d8					      ENDIF
      5  37d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  37d8				   _BANK_SLOT SET	2 * 64
      0  37d8					      NEWBANK	PIECE_6
      1  3b90 ????				      SEG	PIECE_6
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   PIECE_6_START SET	*
      6  3800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3800				   PIECE_6    SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  3800					      LIST	ON
      0  3800					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  3800				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3800				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  3800		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  3818		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  3848					      LIST	ON
      0  3848					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  3848				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3848				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  3890					      LIST	ON
      0  3890					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  3890				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3890				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  38c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  3900					      LIST	ON
      0  3900					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  3900				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3900				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  3948					      LIST	ON
      0  3948					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  3948				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3948				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  3948		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  3990					      LIST	ON
      0  3990					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  3990				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3990				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  3a00					      LIST	ON
      0  3a00					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  3a00				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3a00				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  3a30		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  3a48					      LIST	ON
      0  3a48					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  3a48				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3a48				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  3a90					      LIST	ON
      0  3a90					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  3a90				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3a90				   BLACK_KING_on_WHITE_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  3a90		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  3aa8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  3b00					      LIST	ON
      0  3b00					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  3b00				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3b00				   BLACK_KING_on_WHITE_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  3b48					      LIST	ON
      0  3b48					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  3b48				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3b48				   BLACK_KING_on_WHITE_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  3b78		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
      0  3b90					      CHECK_BANK_SIZE	"PIECES_6 (1K)"
      1  3b90		       03 90	   .TEMP      =	* - _BANK_START
 PIECES_6 (1K) (1K) SIZE =  $390 , FREE= $70
      2  3b90					      ECHO	"PIECES_6 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3b90				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3b90				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_6 (1K)", " size=", * - ORIGIN
      5  3b90				  -	      ERR
      6  3b90					      ENDIF
      0  3b90					      SLOT	2
      1  3b90				  -	      IF	(2 < 0) || (2 > 3)
      2  3b90				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3b90				  -	      ERR
      4  3b90					      ENDIF
      5  3b90				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3b90				   _BANK_SLOT SET	2 * 64
      0  3b90					      NEWBANK	PIECE_7
      1  3fd8 ????				      SEG	PIECE_7
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECE_7_START SET	*
      6  3c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3c00				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  3c00					      LIST	ON
      0  3c00					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  3c00				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3c00				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3c00				   BLACK_KING_on_WHITE_SQUARE_3
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  3c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  3c48					      LIST	ON
      0  3c48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  3c48				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3c48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3c48				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  3c90					      LIST	ON
      0  3c90					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  3c90				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3c90				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3c90				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  3d00				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3d00				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3d00				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  3d48				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3d48				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3d48				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  3d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  3d90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3d90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3d90				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  3d90		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  3e00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3e00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3e00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  3e48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3e48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3e48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  3e90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3e90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3e90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  3e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  3f00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3f00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3f00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  3f00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  3f18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  3f48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3f48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3f48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  3f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3f90					      LIST	ON
      0  3f90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  3f90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3f90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3f90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  3fd8					      CHECK_BANK_SIZE	"PIECE_7 (1K)"
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_7 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3fd8					      ECHO	"PIECE_7 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_7 (1K)", " size=", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      0  3fd8					      SLOT	2
      1  3fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3fd8				  -	      ERR
      4  3fd8					      ENDIF
      5  3fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3fd8				   _BANK_SLOT SET	2 * 64
      0  3fd8					      NEWBANK	PIECE_8
      1  4048 ????				      SEG	PIECE_8
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECE_8_START SET	*
      6  4000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4000				   PIECE_8    SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  4000					      LIST	ON
      0  4000					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  4000				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4000				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4000				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  4000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
    127  4048
      0  4048					      CHECK_BANK_SIZE	"PIECES_8 (1K)"
      1  4048		       00 48	   .TEMP      =	* - _BANK_START
 PIECES_8 (1K) (1K) SIZE =  $48 , FREE= $3b8
      2  4048					      ECHO	"PIECES_8 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4048				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4048				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_8 (1K)", " size=", * - ORIGIN
      5  4048				  -	      ERR
      6  4048					      ENDIF
    129  4048
    130  4048							;    NEWBANK PIECES_5
    131  4048
    132  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    133  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    134  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    135  4048							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    136  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    137  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    138  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    139  4048							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    140  4048
    141  4048
    142  4048				  -	      IF	0
    143  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    144  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    145  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    146  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    147  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    148  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    149  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    150  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    151  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    152  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    153  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    154  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    155  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    156  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    157  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    158  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    159  4048					      ENDIF
    160  4048
    161  4048							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    162  4048
    163  4048				  -	      IF	0
    164  4048				  -	      NEWBANK	PIECES_6
    165  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    166  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    167  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    168  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    169  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    170  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    171  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    172  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    173  4048				  -
    174  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    175  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    176  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    177  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    178  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    179  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    180  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    181  4048				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    182  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    183  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    184  4048				  -
    185  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    186  4048				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    187  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    188  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    189  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    190  4048				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    191  4048				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    192  4048				  -
    193  4048				  -
    194  4048				  -	      NEWBANK	PIECES_7
    195  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    196  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    197  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    198  4048				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    199  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    200  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    201  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    202  4048				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    203  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    204  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    205  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    206  4048				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    207  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    208  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    209  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    210  4048				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    211  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    212  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    213  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    214  4048				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    215  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    216  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    217  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    218  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    219  4048				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    220  4048				  -
    221  4048				  -
    222  4048				  -	      NEWBANK	PIECES_8
    223  4048				  -
    224  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    225  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    226  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    227  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    228  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    229  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    230  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    231  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    232  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    233  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    234  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    235  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    236  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    237  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    238  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    239  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    240  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    241  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    242  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    243  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    244  4048				  -
    245  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    246  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    247  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    248  4048				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    249  4048				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    250  4048				  -
    251  4048					      ENDIF
    252  4048
    253  4048							;    NEWBANK PIECES_9
    254  4048
    255  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    256  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    257  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    258  4048							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    259  4048							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    260  4048
    261  4048				  -	      IF	0
    262  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    263  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    264  4048				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    265  4048					      ENDIF
    266  4048
    267  4048							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    268  4048
    269  4048				  -	      IF	0
    270  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    271  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    272  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    273  4048				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    274  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    275  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    276  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    277  4048				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    278  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    279  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    280  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    281  4048				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    282  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    283  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    284  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    285  4048				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    286  4048					      ENDIF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2.asm LEVEL 2 PASS 4
      0  4048					      include	"BANK_GENERIC@2.asm"
      1  4048
      0  4048					      SLOT	2
      1  4048				  -	      IF	(2 < 0) || (2 > 3)
      2  4048				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4048				  -	      ERR
      4  4048					      ENDIF
      5  4048				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4048				   _BANK_SLOT SET	2 * 64
      0  4048					      NEWBANK	GENERIC_BANK@2
      1  4713 ????				      SEG	GENERIC_BANK@2
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   GENERIC_BANK@2_START SET	*
      6  4400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4400				   GENERIC_BANK@2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + 1024
      4  4400
      5  4400							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
      6  4400
      7  4400				  -	      IF	0
      8  4400				  -	      IF	PLUSCART = YES
      9  4400				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     10  4400				  -	      .byte	"pluscart.firmaplus.de", #0
     11  4400				  -	      ENDIF
     12  4400					      ENDIF
     13  4400
     14  4400		       54 4a 33 45 STELLA_AUTODETECT dc	"TJ3E"	; 3E+ autodetect
     15  4404
     16  4404
     17  4404							;---------------------------------------------------------------------------------------------------
     18  4404
      0  4404					      DEF	tidySc
      1  4404				   SLOT_tidySc SET	_BANK_SLOT
      2  4404				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  4404				   tidySc
      4  4404				   TEMPORARY_VAR SET	Overlay
      5  4404				   TEMPORARY_OFFSET SET	0
      6  4404				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  4404				   FUNCTION_NAME SET	tidySc
     20  4404					      SUBROUTINE
     21  4404
      0  4404					      REFER	StartupBankReset	;✅
      1  4404				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  4404				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  4404					      ENDIF
      0  4404					      VEND	tidySc
      1  4404				  -	      IFNCONST	tidySc
      2  4404				  -	      ECHO	"Incorrect VEND label", tidySc
      3  4404				  -	      ERR
      4  4404					      ENDIF
      5  4404		       00 a4	   VAREND_tidySc =	TEMPORARY_VAR
     24  4404
     25  4404		       a9 00		      lda	#0
     26  4406		       85 4d		      sta	PF0
     27  4408		       85 4e		      sta	PF1
     28  440a		       85 4f		      sta	PF2
     29  440c		       85 5b		      sta	GRP0
     30  440e		       85 5c		      sta	GRP1
     31  4410
     32  4410		       a9 42		      lda	#%01000010	; bit6 is not required
     33  4412							;sta VBLANK			  ; end of screen - enter blanking
     34  4412
     35  4412
     36  4412							; END OF VISIBLE SCREEN
     37  4412							; HERE'S SOME TIME TO DO STUFF
     38  4412
     39  4412		       a9 2e		      lda	#TIME_PART_2
     40  4414		       8d 96 02 	      sta	TIM64T
     41  4417		       60		      rts
     42  4418
     43  4418
     44  4418							;---------------------------------------------------------------------------------------------------
     45  4418
      0  4418					      DEF	longD
      1  4418				   SLOT_longD SET	_BANK_SLOT
      2  4418				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  4418				   longD
      4  4418				   TEMPORARY_VAR SET	Overlay
      5  4418				   TEMPORARY_OFFSET SET	0
      6  4418				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  4418				   FUNCTION_NAME SET	longD
     47  4418					      SUBROUTINE
     48  4418
      0  4418					      REFER	StartupBankReset	;✅
      1  4418				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  4418				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  4418					      ENDIF
      0  4418					      VEND	longD
      1  4418				  -	      IFNCONST	longD
      2  4418				  -	      ECHO	"Incorrect VEND label", longD
      3  4418				  -	      ERR
      4  4418					      ENDIF
      5  4418		       00 a4	   VAREND_longD =	TEMPORARY_VAR
     51  4418
     52  4418		       85 42		      sta	WSYNC
     53  441a
     54  441a		       20 2b f8 	      jsr	_rts
     55  441d		       20 2b f8 	      jsr	_rts
     56  4420		       20 2b f8 	      jsr	_rts
      0  4423					      SLEEP	7
      1  4423				   .CYCLES    SET	7
      2  4423
      3  4423				  -	      IF	.CYCLES < 2
      4  4423				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4423				  -	      ERR
      6  4423					      ENDIF
      7  4423
      8  4423					      IF	.CYCLES & 1
      9  4423					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4423		       04 00		      nop	0
     11  4425				  -	      ELSE
     12  4425				  -	      bit	VSYNC
     13  4425					      ENDIF
     14  4425				   .CYCLES    SET	.CYCLES - 3
     15  4425					      ENDIF
     16  4425
     17  4425					      REPEAT	.CYCLES / 2
     18  4425		       ea		      nop
     17  4425					      REPEND
     18  4426		       ea		      nop
     19  4427					      REPEND
     58  4427
     59  4427		       a2 00		      ldx	#0
     60  4429		       86 41		      stx	VBLANK
     61  442b		       60	   _rts       rts
     62  442c
     63  442c
     64  442c							;---------------------------------------------------------------------------------------------------
     65  442c
      0  442c					      DEF	aiStartClearBoard
      1  442c				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  442c				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  442c				   aiStartClearBoard
      4  442c				   TEMPORARY_VAR SET	Overlay
      5  442c				   TEMPORARY_OFFSET SET	0
      6  442c				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  442c				   FUNCTION_NAME SET	aiStartClearBoard
     67  442c					      SUBROUTINE
     68  442c
      0  442c					      REFER	AiStateMachine	;✅
      1  442c				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  442c				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  442c					      ENDIF
      0  442c					      VEND	aiStartClearBoard
      1  442c				  -	      IFNCONST	aiStartClearBoard
      2  442c				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  442c				  -	      ERR
      4  442c					      ENDIF
      5  442c		       00 a4	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     71  442c
     72  442c		       a2 08		      ldx	#8
     73  442e		       86 84		      stx	drawCount	; = bank
     74  4430
     75  4430		       a9 ff		      lda	#-1
     76  4432		       85 88		      sta	cursorX12
     77  4434
      0  4434					      PHASE	AI_ClearEachRow
      1  4434		       a9 0e		      lda	#AI_ClearEachRow
      2  4436		       85 8b		      sta	aiState
     79  4438		       60		      rts
     80  4439
     81  4439
     82  4439							;---------------------------------------------------------------------------------------------------
     83  4439
      0  4439					      DEF	aiClearEachRow
      1  4439				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  4439				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  4439				   aiClearEachRow
      4  4439				   TEMPORARY_VAR SET	Overlay
      5  4439				   TEMPORARY_OFFSET SET	0
      6  4439				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  4439				   FUNCTION_NAME SET	aiClearEachRow
     85  4439					      SUBROUTINE
     86  4439
      0  4439					      REFER	AiStateMachine	;✅
      1  4439				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4439				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4439					      ENDIF
      0  4439					      VEND	aiClearEachRow
      1  4439				  -	      IFNCONST	aiClearEachRow
      2  4439				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  4439				  -	      ERR
      4  4439					      ENDIF
      5  4439		       00 a4	   VAREND_aiClearEachRow =	TEMPORARY_VAR
     89  4439
     90  4439		       c6 84		      dec	drawCount
     91  443b		       30 00		      bmi	.bitmapCleared
     92  443d							;TODOldy drawCount
     93  443d							;TODO jmp CallClear
     94  443d
     95  443d				   .bitmapCleared
     96  443d
     97  443d		       a9 63		      lda	#99
     98  443f		       85 80		      sta	squareToDraw
     99  4441
      0  4441					      PHASE	AI_DrawEntireBoard
      1  4441		       a9 0f		      lda	#AI_DrawEntireBoard
      2  4443		       85 8b		      sta	aiState
    101  4445		       60		      rts
    102  4446
    103  4446
    104  4446							;---------------------------------------------------------------------------------------------------
    105  4446
      0  4446					      DEF	aiMoveIsSelected
      1  4446				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  4446				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  4446				   aiMoveIsSelected
      4  4446				   TEMPORARY_VAR SET	Overlay
      5  4446				   TEMPORARY_OFFSET SET	0
      6  4446				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  4446				   FUNCTION_NAME SET	aiMoveIsSelected
    107  4446					      SUBROUTINE
    108  4446
      0  4446					      REFER	AiStateMachine	;✅
      1  4446				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  4446				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  4446					      ENDIF
      0  4446					      VEND	aiMoveIsSelected
      1  4446				  -	      IFNCONST	aiMoveIsSelected
      2  4446				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  4446				  -	      ERR
      4  4446					      ENDIF
      5  4446		       00 a4	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    111  4446
    112  4446							; Both computer and human have now seleted a move, and converge here
    113  4446
    114  4446
    115  4446							; fromPiece	 piece doing the move
    116  4446							; fromX12	 current square X12
    117  4446							; originX12	 starting square X12
    118  4446							; toX12	 ending square X12
    119  4446
    120  4446		       20 b3 f8 	      jsr	AdjustMaterialPositionalValue	;@this
    121  4449
    122  4449		       a9 00		      lda	#0
    123  444b		       85 98		      sta	previousPiece
    124  444d		       85 82		      sta	drawDelay
    125  444f
    126  444f		       a9 0a		      lda	#10	; on/off count
    127  4451		       85 84		      sta	drawCount	; flashing for piece about to move
    128  4453
      0  4453					      PHASE	AI_WriteStartPieceBlank
      1  4453		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  4455		       85 8b		      sta	aiState
    130  4457		       60	   .idleErase rts
    131  4458
    132  4458
    133  4458							;---------------------------------------------------------------------------------------------------
    134  4458
      0  4458					      DEF	CopySetup
      1  4458				   SLOT_CopySetup SET	_BANK_SLOT
      2  4458				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  4458				   CopySetup
      4  4458				   TEMPORARY_VAR SET	Overlay
      5  4458				   TEMPORARY_OFFSET SET	0
      6  4458				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  4458				   FUNCTION_NAME SET	CopySetup
    136  4458					      SUBROUTINE
    137  4458
      0  4458					      REFER	CopySinglePiece	;✅
      1  4458					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  4458				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  4458					      ENDIF
    139  4458
      0  4458					      VAR	__tmp, 1
      1  4458		       00 a7	   __tmp      =	TEMPORARY_VAR
      2  4458				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4458
      4  4458				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4458				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4458				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4458					      ENDIF
      8  4458				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4458				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  4458				  -	      ERR
     11  4458					      ENDIF
     12  4458					      LIST	ON
      0  4458					      VAR	__shiftx, 1
      1  4458		       00 a8	   __shiftx   =	TEMPORARY_VAR
      2  4458				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4458
      4  4458				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4458				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4458				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4458					      ENDIF
      8  4458				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4458				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  4458				  -	      ERR
     11  4458					      ENDIF
     12  4458					      LIST	ON
      0  4458					      VAR	__pieceColour2, 1
      1  4458		       00 a9	   __pieceColour2 =	TEMPORARY_VAR
      2  4458				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4458
      4  4458				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4458				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4458				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4458					      ENDIF
      8  4458				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4458				  -	      ECHO	"Temporary Variable", __pieceColour2, "overflow!"
     10  4458				  -	      ERR
     11  4458					      ENDIF
     12  4458					      LIST	ON
    143  4458
      0  4458					      VEND	CopySetup
      1  4458				  -	      IFNCONST	CopySetup
      2  4458				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  4458				  -	      ERR
      4  4458					      ENDIF
      5  4458		       00 aa	   VAREND_CopySetup =	TEMPORARY_VAR
    145  4458
    146  4458							; figure colouration of square
    147  4458
    148  4458		       a5 80		      lda	squareToDraw
    149  445a
    150  445a					      IF	DIAGNOSTICS
    151  445a							; Catch out-of-range piece square
    152  445a							; will not catch off left/right edge
    153  445a
    154  445a		       c9 64	   .fail      cmp	#100
    155  445c		       b0 fc		      bcs	.fail
    156  445e		       c9 16		      cmp	#22
    157  4460		       90 f8		      bcc	.fail
    158  4462					      ENDIF
    159  4462
    160  4462
    161  4462		       a2 0a		      ldx	#10
    162  4464		       38		      sec
    163  4465		       e9 0a	   .sub10     sbc	#10
    164  4467		       ca		      dex
    165  4468		       b0 fb		      bcs	.sub10
    166  446a		       69 08		      adc	#8
    167  446c		       85 a8		      sta	__shiftx
    168  446e					      IF	DIAGNOSTICS
    169  446e		       c9 08	   .fail2     cmp	#8
    170  4470		       b0 fc		      bcs	.fail2
    171  4472		       e0 08		      cpx	#8
    172  4474		       b0 f8		      bcs	.fail2
    173  4476					      ENDIF
    174  4476		       86 a7		      stx	__tmp
    175  4478		       65 a7		      adc	__tmp
    176  447a
    177  447a
    178  447a		       29 01		      and	#1
    179  447c		       49 01		      eor	#1
    180  447e		       f0 02		      beq	.white
    181  4480		       a9 24		      lda	#36
    182  4482				   .white
    183  4482		       85 a9		      sta	__pieceColour2	; actually SQUARE black/white
    184  4484
    185  4484							; PieceColour = 0 for white square, 36 for black square
    186  4484
    187  4484		       a9 cc		      lda	#RAMBANK_BOARD
    188  4486		       85 3e		      sta	SET_BANK_RAM	;@3
    189  4488
    190  4488		       a4 80		      ldy	squareToDraw
    191  448a		       b9 79 fc 	      lda	Board,y
    192  448d							;and #$87
    193  448d		       0a		      asl
    194  448e		       90 02		      bcc	.blackAdjust
    195  4490		       09 10		      ora	#16	; switch white pieces
    196  4492		       4a	   .blackAdjust lsr
    197  4493		       29 0f		      and	#%1111
    198  4495		       aa		      tax
    199  4496
    200  4496		       a5 a8		      lda	__shiftx
    201  4498		       29 03		      and	#3	; shift position in P
    202  449a
    203  449a		       18		      clc
    204  449b		       7d a3 f8 	      adc	PieceToShape,x
    205  449e		       18		      clc
    206  449f		       65 a9		      adc	__pieceColour2
    207  44a1		       a8		      tay
    208  44a2		       60		      rts
    209  44a3
    210  44a3				   PieceToShape
    211  44a3
    212  44a3		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    213  44a4		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    214  44a5		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    215  44a6		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    216  44a7		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    217  44a8		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    218  44a9		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    219  44aa		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    220  44ab
    221  44ab		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    222  44ac		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    223  44ad		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    224  44ae		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    225  44af		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    226  44b0		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    227  44b1		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    228  44b2		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    229  44b3
    230  44b3
    231  44b3							;---------------------------------------------------------------------------------------------------
    232  44b3
      0  44b3					      DEF	AdjustMaterialPositionalValue
      1  44b3				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  44b3				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  44b3				   AdjustMaterialPositionalValue
      4  44b3				   TEMPORARY_VAR SET	Overlay
      5  44b3				   TEMPORARY_OFFSET SET	0
      6  44b3				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  44b3				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    234  44b3					      SUBROUTINE
    235  44b3
    236  44b3							; A move is about to be made, so  adjust material and positional values based on from/to and
    237  44b3							; capture.
    238  44b3
    239  44b3							; First, nominate referencing subroutines so that local variables can be adjusted properly
    240  44b3
      0  44b3					      REFER	MakeMove	;✅
      1  44b3					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  44b3				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  44b3					      ENDIF
      0  44b3					      REFER	aiMoveIsSelected	;✅
      1  44b3				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  44b3				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  44b3					      ENDIF
    243  44b3
      0  44b3					      VAR	__originalPiece, 1
      1  44b3		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  44b3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44b3
      4  44b3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44b3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44b3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44b3					      ENDIF
      8  44b3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44b3				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  44b3				  -	      ERR
     11  44b3					      ENDIF
     12  44b3					      LIST	ON
      0  44b3					      VAR	__capturedPiece, 1
      1  44b3		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  44b3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  44b3
      4  44b3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  44b3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  44b3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  44b3					      ENDIF
      8  44b3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  44b3				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  44b3				  -	      ERR
     11  44b3					      ENDIF
     12  44b3					      LIST	ON
    246  44b3
      0  44b3					      VEND	AdjustMaterialPositionalValue
      1  44b3				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  44b3				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  44b3				  -	      ERR
      4  44b3					      ENDIF
      5  44b3		       00 b4	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    248  44b3
    249  44b3							; fromPiece	 piece doing the move (promoted type)
    250  44b3							; fromX12	 current square
    251  44b3							; originX12	 starting square
    252  44b3							; toX12	 ending square
    253  44b3
    254  44b3
    255  44b3							; get the piece types from the board
    256  44b3
    257  44b3		       a9 cc		      lda	#RAMBANK_BOARD
    258  44b5		       85 3e		      sta	SET_BANK_RAM	;@3
    259  44b7		       a4 87		      ldy	originX12
    260  44b9		       b9 79 fc 	      lda	Board,y
    261  44bc		       85 b2		      sta	__originalPiece
    262  44be		       a4 86		      ldy	toX12
    263  44c0		       b9 79 fc 	      lda	Board,y
    264  44c3		       85 b3		      sta	__capturedPiece
    265  44c5
    266  44c5							; {
    267  44c5							;   adjust the positional value  (originX12 --> fromX12)
    268  44c5
    269  44c5							;ldy toX12			 ; already loaded
    270  44c5		       a5 96		      lda	fromPiece
    271  44c7		       20 32 f9 	      jsr	AddPiecePositionValue	; add pos value for new position
    272  44ca
    273  44ca
    274  44ca		       a5 b2		      lda	__originalPiece
    275  44cc		       45 96		      eor	fromPiece	; the new piece
    276  44ce		       29 0f		      and	#PIECE_MASK
    277  44d0		       f0 05		      beq	.same1	; unchanged, so skip
    278  44d2
    279  44d2		       a5 96		      lda	fromPiece	; new piece
    280  44d4		       20 0f f9 	      jsr	AddPieceMaterialValue
    281  44d7
    282  44d7				   .same1
    283  44d7
    284  44d7							; and now the 'subtracts'
    285  44d7
      0  44d7					      NEGEVAL
      1  44d7
      2  44d7		       38		      sec
      3  44d8		       a9 00		      lda	#0
      4  44da		       e5 8f		      sbc	Evaluation
      5  44dc		       85 8f		      sta	Evaluation
      6  44de		       a9 00		      lda	#0
      7  44e0		       e5 90		      sbc	Evaluation+1
      8  44e2		       85 90		      sta	Evaluation+1
    287  44e4
    288  44e4		       a4 87		      ldy	originX12
    289  44e6		       a5 b2		      lda	__originalPiece
    290  44e8		       20 32 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    291  44eb
    292  44eb
    293  44eb		       a5 b2		      lda	__originalPiece
    294  44ed		       45 96		      eor	fromPiece	; the new piece
    295  44ef		       29 0f		      and	#PIECE_MASK
    296  44f1		       f0 05		      beq	.same2	; unchanged, so skip
    297  44f3
    298  44f3		       a5 b2		      lda	__originalPiece
    299  44f5		       20 0f f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    300  44f8				   .same2
    301  44f8
      0  44f8					      NEGEVAL
      1  44f8
      2  44f8		       38		      sec
      3  44f9		       a9 00		      lda	#0
      4  44fb		       e5 8f		      sbc	Evaluation
      5  44fd		       85 8f		      sta	Evaluation
      6  44ff		       a9 00		      lda	#0
      7  4501		       e5 90		      sbc	Evaluation+1
      8  4503		       85 90		      sta	Evaluation+1
    303  4505
    304  4505							; If there's a capture, we adjust the material value
    305  4505
    306  4505							;		      lda __capturedPiece
    307  4505							;		      eor __originalPiece
    308  4505							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    309  4505
    310  4505
    311  4505		       a5 b3		      lda	__capturedPiece
    312  4507		       29 0f		      and	#PIECE_MASK
    313  4509		       f0 03		      beq	.noCapture
    314  450b		       20 0f f9 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    315  450e				   .noCapture
    316  450e
    317  450e							; }
    318  450e		       60		      rts
    319  450f
    320  450f
    321  450f							;---------------------------------------------------------------------------------------------------
    322  450f
      0  450f					      DEF	AddPieceMaterialValue
      1  450f				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  450f				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  450f				   AddPieceMaterialValue
      4  450f				   TEMPORARY_VAR SET	Overlay
      5  450f				   TEMPORARY_OFFSET SET	0
      6  450f				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  450f				   FUNCTION_NAME SET	AddPieceMaterialValue
    324  450f					      SUBROUTINE
    325  450f
      0  450f					      REFER	InitialisePieceSquares	;✅
      1  450f					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  450f				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  450f					      ENDIF
      0  450f					      REFER	AdjustMaterialPositionalValue	;✅
      1  450f					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  450f				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  450f					      ENDIF
      0  450f					      REFER	EnPassantRemovePiece	;✅
      1  450f				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  450f				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  450f					      ENDIF
    329  450f
      0  450f					      VEND	AddPieceMaterialValue
      1  450f				  -	      IFNCONST	AddPieceMaterialValue
      2  450f				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  450f				  -	      ERR
      4  450f					      ENDIF
      5  450f		       00 b4	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
    331  450f
    332  450f							; Adjust the material score based on the piece
    333  450f							; a = piece type + flags
    334  450f
    335  450f		       29 0f		      and	#PIECE_MASK
    336  4511		       a8		      tay
    337  4512
    338  4512		       18		      clc
    339  4513		       b9 22 f9 	      lda	PieceValueLO,y
    340  4516		       65 8f		      adc	Evaluation
    341  4518		       85 8f		      sta	Evaluation
    342  451a		       b9 2a f9 	      lda	PieceValueHI,y
    343  451d		       65 90		      adc	Evaluation+1
    344  451f		       85 90		      sta	Evaluation+1
    345  4521		       60		      rts
    346  4522
    347  4522
    348  4522
    349  4522					      MAC	vequ
    350  4522				   VALUE_{1}  =	{2}
    351  4522					      ENDM
    352  4522
    353  4522					      MAC	lobyte
    354  4522					      .byte	<{2}
    355  4522					      ENDM
    356  4522
    357  4522					      MAC	hibyte
    358  4522					      .byte	>{2}
    359  4522					      ENDM
    360  4522
    361  4522
    362  4522					      MAC	valuetable
    363  4522					      {1}	BLANK, 0
    364  4522					      {1}	PAWN, 100	; white
    365  4522					      {1}	PAWN, 100	; black
    366  4522					      {1}	KNIGHT, 320
    367  4522					      {1}	BISHOP, 375
    368  4522					      {1}	ROOK, 575
    369  4522					      {1}	QUEEN, 900
    370  4522					      {1}	KING, 10000
    371  4522					      ENDM
    372  4522
    373  4522
      0  4522					      VALUETABLE	VEQU
      0  4522					      VEQU	BLANK, 0
      1  4522		       00 00	   VALUE_BLANK =	0
      0  4522					      VEQU	PAWN, 100
      1  4522		       00 64	   VALUE_PAWN =	100
      0  4522					      VEQU	PAWN, 100
      1  4522		       00 64	   VALUE_PAWN =	100
      0  4522					      VEQU	KNIGHT, 320
      1  4522		       01 40	   VALUE_KNIGHT =	320
      0  4522					      VEQU	BISHOP, 375
      1  4522		       01 77	   VALUE_BISHOP =	375
      0  4522					      VEQU	ROOK, 575
      1  4522		       02 3f	   VALUE_ROOK =	575
      0  4522					      VEQU	QUEEN, 900
      1  4522		       03 84	   VALUE_QUEEN =	900
      0  4522					      VEQU	KING, 10000
      1  4522		       27 10	   VALUE_KING =	10000
    375  4522
      0  4522					      DEF	PieceValueLO
      1  4522				   SLOT_PieceValueLO SET	_BANK_SLOT
      2  4522				   BANK_PieceValueLO SET	SLOT_PieceValueLO + _CURRENT_BANK
      3  4522				   PieceValueLO
      4  4522				   TEMPORARY_VAR SET	Overlay
      5  4522				   TEMPORARY_OFFSET SET	0
      6  4522				   VAR_BOUNDARY_PieceValueLO SET	TEMPORARY_OFFSET
      7  4522				   FUNCTION_NAME SET	PieceValueLO
      0  4522					      VALUETABLE	LOBYTE
      0  4522					      LOBYTE	BLANK, 0
      1  4522		       00		      .byte.b	<0
      0  4523					      LOBYTE	PAWN, 100
      1  4523		       64		      .byte.b	<100
      0  4524					      LOBYTE	PAWN, 100
      1  4524		       64		      .byte.b	<100
      0  4525					      LOBYTE	KNIGHT, 320
      1  4525		       40		      .byte.b	<320
      0  4526					      LOBYTE	BISHOP, 375
      1  4526		       77		      .byte.b	<375
      0  4527					      LOBYTE	ROOK, 575
      1  4527		       3f		      .byte.b	<575
      0  4528					      LOBYTE	QUEEN, 900
      1  4528		       84		      .byte.b	<900
      0  4529					      LOBYTE	KING, 10000
      1  4529		       10		      .byte.b	<10000
    378  452a
      0  452a					      DEF	PieceValueHI
      1  452a				   SLOT_PieceValueHI SET	_BANK_SLOT
      2  452a				   BANK_PieceValueHI SET	SLOT_PieceValueHI + _CURRENT_BANK
      3  452a				   PieceValueHI
      4  452a				   TEMPORARY_VAR SET	Overlay
      5  452a				   TEMPORARY_OFFSET SET	0
      6  452a				   VAR_BOUNDARY_PieceValueHI SET	TEMPORARY_OFFSET
      7  452a				   FUNCTION_NAME SET	PieceValueHI
      0  452a					      VALUETABLE	HIBYTE
      0  452a					      HIBYTE	BLANK, 0
      1  452a		       00		      .byte.b	>0
      0  452b					      HIBYTE	PAWN, 100
      1  452b		       00		      .byte.b	>100
      0  452c					      HIBYTE	PAWN, 100
      1  452c		       00		      .byte.b	>100
      0  452d					      HIBYTE	KNIGHT, 320
      1  452d		       01		      .byte.b	>320
      0  452e					      HIBYTE	BISHOP, 375
      1  452e		       01		      .byte.b	>375
      0  452f					      HIBYTE	ROOK, 575
      1  452f		       02		      .byte.b	>575
      0  4530					      HIBYTE	QUEEN, 900
      1  4530		       03		      .byte.b	>900
      0  4531					      HIBYTE	KING, 10000
      1  4531		       27		      .byte.b	>10000
    381  4532
    382  4532
    383  4532							;---------------------------------------------------------------------------------------------------
    384  4532
      0  4532					      DEF	AddPiecePositionValue
      1  4532				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  4532				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  4532				   AddPiecePositionValue
      4  4532				   TEMPORARY_VAR SET	Overlay
      5  4532				   TEMPORARY_OFFSET SET	0
      6  4532				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  4532				   FUNCTION_NAME SET	AddPiecePositionValue
    386  4532					      SUBROUTINE
    387  4532
      0  4532					      REFER	InitialisePieceSquares	;✅
      1  4532					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  4532				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  4532					      ENDIF
      0  4532					      REFER	AdjustMaterialPositionalValue	;✅
      1  4532					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  4532				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  4532					      ENDIF
      0  4532					      REFER	EnPassantRemovePiece	;✅
      1  4532				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  4532				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  4532					      ENDIF
    391  4532
      0  4532					      VAR	__valPtr, 2
      1  4532		       00 b4	   __valPtr   =	TEMPORARY_VAR
      2  4532				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  4532
      4  4532				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4532				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4532				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4532					      ENDIF
      8  4532				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4532				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  4532				  -	      ERR
     11  4532					      ENDIF
     12  4532					      LIST	ON
      0  4532					      VAR	__valHi, 1
      1  4532		       00 b6	   __valHi    =	TEMPORARY_VAR
      2  4532				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  4532
      4  4532				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  4532				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  4532				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  4532					      ENDIF
      8  4532				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  4532				  -	      ECHO	"Temporary Variable", __valHi, "overflow!"
     10  4532				  -	      ERR
     11  4532					      ENDIF
     12  4532					      LIST	ON
    394  4532
      0  4532					      VEND	AddPiecePositionValue
      1  4532				  -	      IFNCONST	AddPiecePositionValue
      2  4532				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  4532				  -	      ERR
      4  4532					      ENDIF
      5  4532		       00 b7	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    396  4532
    397  4532
    398  4532							; adds value of square piece is on to the evaluation
    399  4532							; note to do the subtraction as -( -x + val) == x - val
    400  4532
    401  4532							; y = square
    402  4532							; a = piece type (+flags)
    403  4532
    404  4532
    405  4532
    406  4532		       c9 80		      cmp	#128	; black = CS
    407  4534		       29 0f		      and	#PIECE_MASK
    408  4536		       aa		      tax
    409  4537
    410  4537		       a9 c5		      lda	#EVAL
    411  4539		       85 3f		      sta	SET_BANK	;@3
    412  453b
    413  453b							; black pieces flip rows so we can use the same eval tables
    414  453b
    415  453b		       98		      tya
    416  453c		       90 03		      bcc	.white
    417  453e		       b9 55 f5 	      lda	FlipSquareIndex,y
    418  4541							;clc
    419  4541				   .white
    420  4541		       7d 00 fc 	      adc	PosValVecLO,x
    421  4544		       85 b4		      sta	__valPtr
    422  4546		       bd 08 fc 	      lda	PosValVecHI,x
    423  4549		       69 00		      adc	#0
    424  454b		       85 b5		      sta	__valPtr+1
    425  454d
    426  454d		       a0 00		      ldy	#0
    427  454f		       84 b6		      sty	__valHi
    428  4551		       b1 b4		      lda	(__valPtr),y
    429  4553		       10 02		      bpl	.sum
    430  4555		       c6 b6		      dec	__valHi
    431  4557
    432  4557		       18	   .sum       clc
    433  4558		       65 8f		      adc	Evaluation
    434  455a		       85 8f		      sta	Evaluation
    435  455c		       a5 90		      lda	Evaluation+1
    436  455e		       65 b6		      adc	__valHi
    437  4560		       85 90		      sta	Evaluation+1
    438  4562		       60		      rts
    439  4563
    440  4563
    441  4563							;---------------------------------------------------------------------------------------------------
    442  4563
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  4563					      include	"piece_vectors.asm"
      1  4563							; Created by ConvertChessPieces.py
      0  4563					      DEF	PIECE_VECTOR_LO
      1  4563				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  4563				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  4563				   PIECE_VECTOR_LO
      4  4563				   TEMPORARY_VAR SET	Overlay
      5  4563				   TEMPORARY_OFFSET SET	0
      6  4563				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  4563				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  4563		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  4564		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  4565		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  4566		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  4567		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  4568		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  4569		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  456a		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  456b		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  456c		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  456d		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  456e		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  456f		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  4570		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  4571		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  4572		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  4573		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  4574		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  4575		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  4576		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  4577		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  4578		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  4579		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  457a		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  457b		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  457c		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  457d		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  457e		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  457f		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  4580		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  4581		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  4582		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  4583		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  4584		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  4585		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  4586		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  4587		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  4588		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  4589		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  458a		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  458b		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  458c		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  458d		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  458e		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  458f		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  4590		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  4591		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  4592		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  4593		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  4594		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  4595		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  4596		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  4597		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  4598		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  4599		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  459a		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  459b		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  459c		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  459d		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  459e		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  459f		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  45a0		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  45a1		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  45a2		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  45a3		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  45a4		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  45a5		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  45a6		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  45a7		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  45a8		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  45a9		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  45aa		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  45ab		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  45ac		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  45ad		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  45ae		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  45af		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  45b0		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  45b1		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  45b2		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  45b3		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  45b4		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  45b5		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  45b6		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  45b7		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  45b8		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  45b9		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  45ba		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  45bb		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  45bc		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  45bd		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  45be		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  45bf		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  45c0		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  45c1		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  45c2		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  45c3		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  45c4		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  45c5		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  45c6		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  45c7		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  45c8		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  45c9		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  45ca		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  45cb		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  45cc		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  45cd		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  45ce		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  45cf		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  45d0		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  45d1		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  45d2		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  45d3		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  45d4		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  45d5		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  45d6		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  45d7		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  45d8		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  45d9		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  45da		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  45db		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  45dc		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  45dd		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  45de		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  45df		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  45e0		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  45e1		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  45e2		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  45e3		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  45e4		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  45e5		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  45e6		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  45e7		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  45e8		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  45e9		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  45ea		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  45eb		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  45ec		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  45ed		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  45ee		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  45ef		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  45f0		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  45f1		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  45f2		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  45f3					      DEF	PIECE_VECTOR_HI
      1  45f3				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  45f3				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  45f3				   PIECE_VECTOR_HI
      4  45f3				   TEMPORARY_VAR SET	Overlay
      5  45f3				   TEMPORARY_OFFSET SET	0
      6  45f3				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  45f3				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  45f3		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  45f4		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  45f5		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  45f6		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  45f7		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  45f8		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  45f9		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  45fa		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  45fb		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  45fc		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  45fd		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  45fe		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  45ff		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  4600		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  4601		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  4602		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  4603		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  4604		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  4605		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  4606		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  4607		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  4608		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  4609		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  460a		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  460b		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  460c		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  460d		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  460e		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  460f		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  4610		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  4611		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  4612		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  4613		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  4614		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  4615		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  4616		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  4617		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  4618		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  4619		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  461a		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  461b		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  461c		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  461d		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  461e		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  461f		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  4620		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  4621		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  4622		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  4623		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  4624		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  4625		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  4626		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  4627		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  4628		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  4629		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  462a		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  462b		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  462c		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  462d		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  462e		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  462f		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  4630		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  4631		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  4632		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  4633		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  4634		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  4635		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  4636		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  4637		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  4638		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  4639		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  463a		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  463b		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  463c		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  463d		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  463e		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  463f		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  4640		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  4641		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  4642		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  4643		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  4644		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  4645		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  4646		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  4647		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  4648		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  4649		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  464a		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  464b		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  464c		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  464d		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  464e		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  464f		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  4650		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  4651		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  4652		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  4653		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  4654		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  4655		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  4656		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  4657		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  4658		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  4659		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  465a		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  465b		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  465c		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  465d		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  465e		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  465f		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  4660		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  4661		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  4662		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  4663		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  4664		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  4665		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  4666		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  4667		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  4668		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  4669		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  466a		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  466b		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  466c		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  466d		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  466e		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  466f		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  4670		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  4671		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  4672		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  4673		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  4674		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  4675		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  4676		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  4677		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  4678		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  4679		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  467a		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  467b		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  467c		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  467d		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  467e		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  467f		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  4680		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  4681		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  4682		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  4683					      DEF	PIECE_VECTOR_BANK
      1  4683				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  4683				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  4683				   PIECE_VECTOR_BANK
      4  4683				   TEMPORARY_VAR SET	Overlay
      5  4683				   TEMPORARY_OFFSET SET	0
      6  4683				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  4683				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  4683		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  4684		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  4685		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  4686		       88		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  4687		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  4688		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  4689		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  468a		       88		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  468b		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  468c		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  468d		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  468e		       88		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  468f		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  4690		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  4691		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  4692		       89		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  4693		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  4694		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  4695		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  4696		       89		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  4697		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  4698		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  4699		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  469a		       89		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  469b		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  469c		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  469d		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  469e		       8a		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  469f		       93		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  46a0		       93		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  46a1		       93		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  46a2		       94		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  46a3		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  46a4		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  46a5		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  46a6		       95		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  46a7		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  46a8		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  46a9		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  46aa		       8a		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  46ab		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  46ac		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  46ad		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  46ae		       8a		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  46af		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  46b0		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  46b1		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  46b2		       8b		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  46b3		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  46b4		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  46b5		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  46b6		       8b		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  46b7		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  46b8		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  46b9		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  46ba		       8b		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  46bb		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  46bc		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  46bd		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  46be		       8c		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  46bf		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  46c0		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  46c1		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  46c2		       8c		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  46c3		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  46c4		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  46c5		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  46c6		       92		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  46c7		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  46c8		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  46c9		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  46ca		       95		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  46cb		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  46cc		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  46cd		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  46ce		       8c		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  46cf		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  46d0		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  46d1		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  46d2		       8d		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  46d3		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  46d4		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  46d5		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  46d6		       8d		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  46d7		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  46d8		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  46d9		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  46da		       8d		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  46db		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  46dc		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  46dd		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  46de		       8e		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  46df		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  46e0		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  46e1		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  46e2		       8e		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  46e3		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  46e4		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  46e5		       8e		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  46e6		       8f		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  46e7		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  46e8		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  46e9		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  46ea		       95		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  46eb		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  46ec		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  46ed		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  46ee		       92		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  46ef		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  46f0		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  46f1		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  46f2		       8f		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  46f3		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  46f4		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  46f5		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  46f6		       8f		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  46f7		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  46f8		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  46f9		       8f		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  46fa		       90		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  46fb		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  46fc		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  46fd		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  46fe		       93		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  46ff		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  4700		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  4701		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  4702		       93		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  4703		       93		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  4704		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  4705		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  4706		       94		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  4707		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  4708		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  4709		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  470a		       94		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  470b		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  470c		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  470d		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  470e		       94		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  470f		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  4710		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  4711		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  4712		       92		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  4713
    438  4713							; piece index equates...
    439  4713		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  4713		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  4713		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  4713		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  4713		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  4713		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  4713		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  4713		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  4713		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  4713		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  4713		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  4713		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  4713		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  4713		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  4713		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  4713		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  4713		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  4713		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  4713		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  4713		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  4713		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  4713		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  4713		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  4713		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  4713		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  4713		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  4713		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  4713		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  4713		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  4713		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  4713		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  4713		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  4713		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  4713		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  4713		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  4713		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  4713		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  4713		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  4713		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  4713		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  4713		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  4713		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  4713		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  4713		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  4713		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  4713		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  4713		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  4713		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  4713		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  4713		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  4713		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  4713		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  4713		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  4713		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  4713		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  4713		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  4713		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  4713		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  4713		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  4713		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  4713		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  4713		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  4713		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  4713		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  4713		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  4713		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  4713		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  4713		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  4713		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  4713		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  4713		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  4713		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  4713		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  4713		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  4713		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  4713		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  4713		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  4713		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  4713		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  4713		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  4713		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  4713		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  4713		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  4713		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  4713		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  4713		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  4713		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  4713		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  4713		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  4713		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  4713		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  4713		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  4713		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  4713		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  4713		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  4713		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  4713		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  4713		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  4713		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  4713		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  4713		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  4713		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  4713		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  4713		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  4713		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  4713		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  4713		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  4713		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  4713		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  4713		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  4713		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  4713		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  4713		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  4713		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  4713		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  4713		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  4713		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  4713		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  4713		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  4713		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  4713		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  4713		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  4713		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  4713		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  4713		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  4713		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  4713		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  4713		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  4713		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  4713		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  4713		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  4713		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  4713		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  4713		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  4713		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  4713		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  4713		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  4713		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  4713		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  4713		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  4713		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  4713		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  4713		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  4713		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC@2.asm
    444  4713
    445  4713							;---------------------------------------------------------------------------------------------------
    446  4713
      0  4713					      CHECK_BANK_SIZE	"BANK_GENERIC@2"
      1  4713		       03 13	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2 (1K) SIZE =  $313 , FREE= $ed
      2  4713					      ECHO	"BANK_GENERIC@2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4713				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4713				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2", " size=", * - ORIGIN
      5  4713				  -	      ERR
      6  4713					      ENDIF
    448  4713
    449  4713							;---------------------------------------------------------------------------------------------------
    450  4713							;EOF
------- FILE ./chess.asm
------- FILE GFX1.asm LEVEL 2 PASS 4
      0  4713					      include	"GFX1.asm"
      0  4713					      SLOT	2
      1  4713				  -	      IF	(2 < 0) || (2 > 3)
      2  4713				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4713				  -	      ERR
      4  4713					      ENDIF
      5  4713				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4713				   _BANK_SLOT SET	2 * 64
      0  4713					      NEWBANK	GFX1
      1  4bd8 ????				      SEG	GFX1
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   GFX1_START SET	*
      6  4800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4800				   GFX1       SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + 1024
      3  4800
      4  4800
      5  4800							;---------------------------------------------------------------------------------------------------
      6  4800
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  4800					      LIST	ON
      0  4800					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  4800				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4800				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4800				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  4800		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4848					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  4848					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  4848					      LIST	ON
      0  4848					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  4848				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4848				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4848				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  4848				   TEMPORARY_VAR SET	Overlay
      5  4848				   TEMPORARY_OFFSET SET	0
      6  4848				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4848				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  4848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4860		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4890					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  4890					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  4890					      LIST	ON
      0  4890					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  4890				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4890				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4890				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  4890				   TEMPORARY_VAR SET	Overlay
      5  4890				   TEMPORARY_OFFSET SET	0
      6  4890				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4890				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  4890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  48a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  48c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  48d8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  48d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  4900					      LIST	ON
      0  4900					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  4900				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4900				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4900				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  4900				   TEMPORARY_VAR SET	Overlay
      5  4900				   TEMPORARY_OFFSET SET	0
      6  4900				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4900				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  4900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4930		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4948					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  4948					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  4948					      LIST	ON
      0  4948					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  4948				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4948				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4948				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  4948				   TEMPORARY_VAR SET	Overlay
      5  4948				   TEMPORARY_OFFSET SET	0
      6  4948				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4948				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  4948		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  4960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4990					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  4990					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  4990					      LIST	ON
      0  4990					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  4990				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4990				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4990				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  4990				   TEMPORARY_VAR SET	Overlay
      5  4990				   TEMPORARY_OFFSET SET	0
      6  4990				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4990				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  4990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  49a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  49c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  49d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  49d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  4a00					      LIST	ON
      0  4a00					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  4a00				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4a00				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4a00				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  4a00				   TEMPORARY_VAR SET	Overlay
      5  4a00				   TEMPORARY_OFFSET SET	0
      6  4a00				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4a00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  4a30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4a48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  4a48					      LIST	ON
      0  4a48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  4a48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4a48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4a48				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  4a48				   TEMPORARY_VAR SET	Overlay
      5  4a48				   TEMPORARY_OFFSET SET	0
      6  4a48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4a48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX1.asm
     15  4a90
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4a90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  4a90					      LIST	ON
      0  4a90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  4a90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4a90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4a90				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  4a90				   TEMPORARY_VAR SET	Overlay
      5  4a90				   TEMPORARY_OFFSET SET	0
      6  4a90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4a90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  4a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  4aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ad8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  4b00					      LIST	ON
      0  4b00					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  4b00				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4b00				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4b00				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  4b00				   TEMPORARY_VAR SET	Overlay
      5  4b00				   TEMPORARY_OFFSET SET	0
      6  4b00				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4b00				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  4b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4b48					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  4b48					      LIST	ON
      0  4b48					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  4b48				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4b48				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4b48				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  4b48				   TEMPORARY_VAR SET	Overlay
      5  4b48				   TEMPORARY_OFFSET SET	0
      6  4b48				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4b48				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  4b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4b90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  4b90					      LIST	ON
      0  4b90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  4b90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4b90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4b90				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  4b90				   TEMPORARY_VAR SET	Overlay
      5  4b90				   TEMPORARY_OFFSET SET	0
      6  4b90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4b90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE GFX1.asm
     20  4bd8
     21  4bd8
     22  4bd8							;---------------------------------------------------------------------------------------------------
     23  4bd8
      0  4bd8					      CHECK_BANK_SIZE	"BANK_GFX1"
      1  4bd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX1 (1K) SIZE =  $3d8 , FREE= $28
      2  4bd8					      ECHO	"BANK_GFX1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4bd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX1", " size=", * - ORIGIN
      5  4bd8				  -	      ERR
      6  4bd8					      ENDIF
     25  4bd8
     26  4bd8							;---------------------------------------------------------------------------------------------------
     27  4bd8							;EOF
------- FILE ./chess.asm
------- FILE GFX2.asm LEVEL 2 PASS 4
      0  4bd8					      include	"GFX2.asm"
      0  4bd8					      SLOT	2
      1  4bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4bd8				  -	      ERR
      4  4bd8					      ENDIF
      5  4bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4bd8				   _BANK_SLOT SET	2 * 64
      0  4bd8					      NEWBANK	GFX2
      1  4fd8 ????				      SEG	GFX2
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   GFX2_START SET	*
      6  4c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4c00				   GFX2       SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  4c00
      4  4c00							;---------------------------------------------------------------------------------------------------
      5  4c00
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  4c00					      LIST	ON
      0  4c00					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  4c00				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4c00				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4c00				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  4c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4c48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  4c48					      LIST	ON
      0  4c48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  4c48				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4c48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4c48				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  4c48				   TEMPORARY_VAR SET	Overlay
      5  4c48				   TEMPORARY_OFFSET SET	0
      6  4c48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4c48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  4c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4c90					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  4c90					      LIST	ON
      0  4c90					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  4c90				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4c90				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4c90				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  4c90				   TEMPORARY_VAR SET	Overlay
      5  4c90				   TEMPORARY_OFFSET SET	0
      6  4c90				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4c90				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
      9  4cd8
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4cd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  4d00					      LIST	ON
      0  4d00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  4d00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4d00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4d00				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  4d00				   TEMPORARY_VAR SET	Overlay
      5  4d00				   TEMPORARY_OFFSET SET	0
      6  4d00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4d00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  4d00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  4d18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4d48					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  4d48					      LIST	ON
      0  4d48					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  4d48				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4d48				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4d48				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  4d48				   TEMPORARY_VAR SET	Overlay
      5  4d48				   TEMPORARY_OFFSET SET	0
      6  4d48				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4d48				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  4d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  4d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4d90					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  4d90					      LIST	ON
      0  4d90					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  4d90				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4d90				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4d90				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  4d90				   TEMPORARY_VAR SET	Overlay
      5  4d90				   TEMPORARY_OFFSET SET	0
      6  4d90				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4d90				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  4d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4da8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4dc0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4dd8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  4e00					      LIST	ON
      0  4e00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  4e00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4e00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4e00				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  4e00				   TEMPORARY_VAR SET	Overlay
      5  4e00				   TEMPORARY_OFFSET SET	0
      6  4e00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4e00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4e48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  4e48					      LIST	ON
      0  4e48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  4e48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4e48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4e48				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  4e48				   TEMPORARY_VAR SET	Overlay
      5  4e48				   TEMPORARY_OFFSET SET	0
      6  4e48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4e48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  4e48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  4e60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4e90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  4e90					      LIST	ON
      0  4e90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  4e90				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4e90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4e90				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  4e90				   TEMPORARY_VAR SET	Overlay
      5  4e90				   TEMPORARY_OFFSET SET	0
      6  4e90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4e90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ea8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  4ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4ed8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  4f00					      LIST	ON
      0  4f00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  4f00				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4f00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4f00				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  4f00				   TEMPORARY_VAR SET	Overlay
      5  4f00				   TEMPORARY_OFFSET SET	0
      6  4f00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4f00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  4f30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4f48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  4f48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  4f48					      LIST	ON
      0  4f48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  4f48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4f48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4f48				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  4f48				   TEMPORARY_VAR SET	Overlay
      5  4f48				   TEMPORARY_OFFSET SET	0
      6  4f48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4f48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  4f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4f78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE GFX2.asm
     18  4f90
     19  4f90
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4f90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  4f90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  4f90					      LIST	ON
      0  4f90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  4f90				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4f90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4f90				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  4f90				   TEMPORARY_VAR SET	Overlay
      5  4f90				   TEMPORARY_OFFSET SET	0
      6  4f90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4f90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  4f90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4fa8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX2.asm
     21  4fd8
     22  4fd8
     23  4fd8							;---------------------------------------------------------------------------------------------------
     24  4fd8
      0  4fd8					      CHECK_BANK_SIZE	"BANK_GFX2"
      1  4fd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX2 (1K) SIZE =  $3d8 , FREE= $28
      2  4fd8					      ECHO	"BANK_GFX2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4fd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX2", " size=", * - ORIGIN
      5  4fd8				  -	      ERR
      6  4fd8					      ENDIF
     26  4fd8
     27  4fd8							;---------------------------------------------------------------------------------------------------
     28  4fd8							;EOF
------- FILE ./chess.asm
------- FILE GFX3.asm LEVEL 2 PASS 4
      0  4fd8					      include	"GFX3.asm"
      0  4fd8					      SLOT	2
      1  4fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4fd8				  -	      ERR
      4  4fd8					      ENDIF
      5  4fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4fd8				   _BANK_SLOT SET	2 * 64
      0  4fd8					      NEWBANK	GFX3
      1  53d8 ????				      SEG	GFX3
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   GFX3_START SET	*
      6  5000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5000				   GFX3       SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + 1024
      3  5000
      4  5000							;---------------------------------------------------------------------------------------------------
      5  5000
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5000					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  5000					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  5000					      LIST	ON
      0  5000					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  5000				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5000				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5000				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  5000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5018		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
      7  5048
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5048					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  5048					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  5048					      LIST	ON
      0  5048					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  5048				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5048				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5048				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  5048				   TEMPORARY_VAR SET	Overlay
      5  5048				   TEMPORARY_OFFSET SET	0
      6  5048				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5048				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  5048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5060		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5078		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5090					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  5090					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  5090					      LIST	ON
      0  5090					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  5090				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5090				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5090				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  5090				   TEMPORARY_VAR SET	Overlay
      5  5090				   TEMPORARY_OFFSET SET	0
      6  5090				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5090				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  5090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  50a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  50c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     10  50d8
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  50d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  50d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  5100					      LIST	ON
      0  5100					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  5100				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5100				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5100				   BLACK_KING_on_BLACK_SQUARE_0
      4  5100				   TEMPORARY_VAR SET	Overlay
      5  5100				   TEMPORARY_OFFSET SET	0
      6  5100				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5100				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  5100		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5118		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5148					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  5148					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  5148					      LIST	ON
      0  5148					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  5148				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5148				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5148				   BLACK_KING_on_BLACK_SQUARE_1
      4  5148				   TEMPORARY_VAR SET	Overlay
      5  5148				   TEMPORARY_OFFSET SET	0
      6  5148				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5148				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  5148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5160		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5190					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  5190					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  5190					      LIST	ON
      0  5190					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  5190				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5190				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5190				   BLACK_KING_on_BLACK_SQUARE_2
      4  5190				   TEMPORARY_VAR SET	Overlay
      5  5190				   TEMPORARY_OFFSET SET	0
      6  5190				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5190				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  5190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  51a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  51c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  51d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  51d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  5200					      LIST	ON
      0  5200					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  5200				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5200				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5200				   BLACK_KING_on_BLACK_SQUARE_3
      4  5200				   TEMPORARY_VAR SET	Overlay
      5  5200				   TEMPORARY_OFFSET SET	0
      6  5200				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5200				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  5200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5230		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     15  5248
     16  5248
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5248					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  5248					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  5248					      LIST	ON
      0  5248					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  5248				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5248				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5248				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  5248				   TEMPORARY_VAR SET	Overlay
      5  5248				   TEMPORARY_OFFSET SET	0
      6  5248				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5248				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  5248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     18  5290
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5290					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  5290					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  5290					      LIST	ON
      0  5290					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  5290				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5290				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5290				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  5290				   TEMPORARY_VAR SET	Overlay
      5  5290				   TEMPORARY_OFFSET SET	0
      6  5290				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5290				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  5290		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  52a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  52c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  52d8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  52d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  5300					      LIST	ON
      0  5300					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  5300				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5300				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5300				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  5300				   TEMPORARY_VAR SET	Overlay
      5  5300				   TEMPORARY_OFFSET SET	0
      6  5300				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5300				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  5300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5318		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5348					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  5348					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  5348					      LIST	ON
      0  5348					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  5348				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5348				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5348				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  5348				   TEMPORARY_VAR SET	Overlay
      5  5348				   TEMPORARY_OFFSET SET	0
      6  5348				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5348				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  5348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5378		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5390					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  5390					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  5390					      LIST	ON
      0  5390					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  5390				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5390				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5390				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  5390				   TEMPORARY_VAR SET	Overlay
      5  5390				   TEMPORARY_OFFSET SET	0
      6  5390				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5390				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  5390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  53a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX3.asm
     23  53d8
     24  53d8							;---------------------------------------------------------------------------------------------------
     25  53d8
      0  53d8					      CHECK_BANK_SIZE	"BANK_GFX3"
      1  53d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX3 (1K) SIZE =  $3d8 , FREE= $28
      2  53d8					      ECHO	"BANK_GFX3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  53d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  53d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX3", " size=", * - ORIGIN
      5  53d8				  -	      ERR
      6  53d8					      ENDIF
     27  53d8
     28  53d8							;---------------------------------------------------------------------------------------------------
     29  53d8							;EOF
------- FILE ./chess.asm
------- FILE GFX4.asm LEVEL 2 PASS 4
      0  53d8					      include	"GFX4.asm"
      0  53d8					      SLOT	2
      1  53d8				  -	      IF	(2 < 0) || (2 > 3)
      2  53d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  53d8				  -	      ERR
      4  53d8					      ENDIF
      5  53d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  53d8				   _BANK_SLOT SET	2 * 64
      0  53d8					      NEWBANK	GFX4
      1  57d8 ????				      SEG	GFX4
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   GFX4_START SET	*
      6  5400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5400				   GFX4       SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + 1024
      3  5400
      4  5400							;---------------------------------------------------------------------------------------------------
      5  5400
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  5400					      LIST	ON
      0  5400					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  5400				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5400				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5400				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  5400		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  5418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  5448					      LIST	ON
      0  5448					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  5448				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5448				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5448				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  5490					      LIST	ON
      0  5490					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  5490				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5490				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5490				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  54c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  5500					      LIST	ON
      0  5500					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  5500				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5500				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  5500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE GFX4.asm
     10  5548
     11  5548
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  5548					      LIST	ON
      0  5548					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  5548				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5548				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5548				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  5548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  5560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  5590					      LIST	ON
      0  5590					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  5590				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5590				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5590				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  55c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  5600					      LIST	ON
      0  5600					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  5600				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5600				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5600				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  5630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  5648					      LIST	ON
      0  5648					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  5648				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5648				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5648				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  5690					      LIST	ON
      0  5690					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  5690				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5690				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5690				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  5690		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  56a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  5700					      LIST	ON
      0  5700					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  5700				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5700				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5700				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$04,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  5748					      LIST	ON
      0  5748					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  5748				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5748				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5748				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5778		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$04,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5790					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  5790					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  5790					      LIST	ON
      0  5790					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  5790				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5790				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5790				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  5790				   TEMPORARY_VAR SET	Overlay
      5  5790				   TEMPORARY_OFFSET SET	0
      6  5790				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5790				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  5790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  57a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  57c0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$80,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE GFX4.asm
     20  57d8
     21  57d8
     22  57d8							;---------------------------------------------------------------------------------------------------
     23  57d8
      0  57d8					      CHECK_BANK_SIZE	"BANK_GFX4"
      1  57d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX4 (1K) SIZE =  $3d8 , FREE= $28
      2  57d8					      ECHO	"BANK_GFX4", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  57d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  57d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX4", " size=", * - ORIGIN
      5  57d8				  -	      ERR
      6  57d8					      ENDIF
     25  57d8
     26  57d8							;---------------------------------------------------------------------------------------------------
     27  57d8							;EOF
------- FILE ./chess.asm
------- FILE NEGAMAX@1.asm LEVEL 2 PASS 4
      0  57d8					      include	"NEGAMAX@1.asm"
      1  57d8							; Chess
      2  57d8							; Copyright (c) 2019-2020 Andrew Davie
      3  57d8							; andrew@taswegian.com
      4  57d8
      0  57d8					      SLOT	1
      1  57d8				  -	      IF	(1 < 0) || (1 > 3)
      2  57d8				  -	      ECHO	"Illegal bank address/segment location", 1
      3  57d8				  -	      ERR
      4  57d8					      ENDIF
      5  57d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  57d8				   _BANK_SLOT SET	1 * 64
      0  57d8					      NEWBANK	NEGAMAX
      1  5b5b ????				      SEG	NEGAMAX
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   NEGAMAX_START SET	*
      6  5800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5800				   NEGAMAX    SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + 1024
      7  5800
      8  5800							;---------------------------------------------------------------------------------------------------
      9  5800
      0  5800					      DEF	aiComputerMove
      1  5800				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  5800				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  5800				   aiComputerMove
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	aiComputerMove
     11  5800					      SUBROUTINE
     12  5800
      0  5800					      REFER	AiStateMachine
      1  5800				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5800				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5800					      ENDIF
      0  5800					      VEND	aiComputerMove
      1  5800				  -	      IFNCONST	aiComputerMove
      2  5800				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  5800				  -	      ERR
      4  5800					      ENDIF
      5  5800		       00 a4	   VAREND_aiComputerMove =	TEMPORARY_VAR
     15  5800
     16  5800
     17  5800		       a9 88		      lda	#RAMBANK_PLY
     18  5802		       85 94		      sta	currentPly
     19  5804		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     20  5806
     21  5806		       a9 01		      lda	#1
     22  5808		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
     23  580a
     24  580a
     25  580a		       20 3a f4 	      jsr	selectmove	;@this
     26  580d
     27  580d
     28  580d		       a9 00		      lda	#0
     29  580f		       85 4a		      sta	CTRLPF	; clear mirroring
     30  5811		       85 4e		      sta	PF1
     31  5813		       85 4f		      sta	PF2
     32  5815
     33  5815							; correct ply is already switched
     34  5815
      0  5815					      lda@PLY	bestMove
      1  5815		       ad d2 f9 	      lda	bestMove
     36  5818		       10 17		      bpl	.notComputer
     37  581a
     38  581a							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     39  581a
      0  581a					      SWAP
      1  581a		       a5 95		      lda	sideToMove
      2  581c		       49 80		      eor	#SWAP_SIDE
      3  581e		       85 95		      sta	sideToMove
      4  5820
      5  5820
     41  5820		       20 8c f1 	      jsr	GenerateAllMoves	;@0
     42  5823		       a5 a1		      lda	flagCheck
     43  5825		       f0 05		      beq	.gameDrawn
     44  5827
      0  5827					      PHASE	AI_CheckMate
      1  5827		       a9 23		      lda	#AI_CheckMate
      2  5829		       85 8b		      sta	aiState
     46  582b		       60		      rts
     47  582c
     48  582c
      0  582c				   .gameDrawn PHASE	AI_Draw
      1  582c		       a9 24		      lda	#AI_Draw
      2  582e		       85 8b		      sta	aiState
     50  5830		       60		      rts
     51  5831
     52  5831				   .notComputer
     53  5831
     54  5831
     55  5831		       a9 ff		      lda	#-1
     56  5833		       85 88		      sta	cursorX12
     57  5835
      0  5835					      PHASE	AI_DelayAfterMove
      1  5835		       a9 25		      lda	#AI_DelayAfterMove
      2  5837		       85 8b		      sta	aiState
     59  5839		       60	   .halted    rts
     60  583a
     61  583a
     62  583a							;---------------------------------------------------------------------------------------------------
     63  583a
      0  583a					      DEF	selectmove
      1  583a				   SLOT_selectmove SET	_BANK_SLOT
      2  583a				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  583a				   selectmove
      4  583a				   TEMPORARY_VAR SET	Overlay
      5  583a				   TEMPORARY_OFFSET SET	0
      6  583a				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  583a				   FUNCTION_NAME SET	selectmove
     65  583a					      SUBROUTINE
     66  583a
      0  583a					      COMMON_VARS_ALPHABETA
      1  583a
      0  583a					      VAR	__thinkbar, 1
      1  583a		       00 a4	   __thinkbar =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__toggle, 1
      1  583a		       00 a5	   __toggle   =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      4  583a
      0  583a					      VAR	__bestMove, 1
      1  583a		       00 a6	   __bestMove =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__alpha, 2
      1  583a		       00 a7	   __alpha    =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__beta, 2
      1  583a		       00 a9	   __beta     =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__negaMax, 2
      1  583a		       00 ab	   __negaMax  =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
      0  583a					      VAR	__value, 2
      1  583a		       00 ad	   __value    =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
     10  583a
      0  583a					      VAR	__quiesceCapOnly, 1
      1  583a		       00 af	   __quiesceCapOnly =	TEMPORARY_VAR
      2  583a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  583a
      4  583a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  583a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  583a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  583a					      ENDIF
      8  583a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  583a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  583a				  -	      ERR
     11  583a					      ENDIF
     12  583a					      LIST	ON
     12  583a
      0  583a					      REFER	aiComputerMove
      1  583a				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  583a				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  583a					      ENDIF
      0  583a					      VEND	selectmove
      1  583a				  -	      IFNCONST	selectmove
      2  583a				  -	      ECHO	"Incorrect VEND label", selectmove
      3  583a				  -	      ERR
      4  583a					      ENDIF
      5  583a		       00 b0	   VAREND_selectmove =	TEMPORARY_VAR
     70  583a
     71  583a
     72  583a							; RAM bank already switched in!!!
     73  583a							; returns with RAM bank switched
     74  583a
     75  583a
     76  583a					      IF	DIAGNOSTICS
     77  583a
     78  583a		       a9 00		      lda	#0
     79  583c		       85 9e		      sta	positionCount
     80  583e		       85 9f		      sta	positionCount+1
     81  5840		       85 a0		      sta	positionCount+2
     82  5842							;sta maxPly
     83  5842					      ENDIF
     84  5842
     85  5842
     86  5842		       a9 00		      lda	#<INFINITY
     87  5844		       85 a9		      sta	__beta
     88  5846		       a9 70		      lda	#>INFINITY
     89  5848		       85 aa		      sta	__beta+1
     90  584a
     91  584a		       a9 00		      lda	#<-INFINITY
     92  584c		       85 a7		      sta	__alpha
     93  584e		       a9 90		      lda	#>-INFINITY
     94  5850		       85 a8		      sta	__alpha+1	; player tries to maximise
     95  5852
     96  5852		       a2 04		      ldx	#SEARCH_DEPTH
     97  5854		       a9 00		      lda	#0	; no captured piece
     98  5856		       85 af		      sta	__quiesceCapOnly	; ALL moves to be generated
     99  5858
    100  5858		       20 14 f5 	      jsr	negaMax
    101  585b
    102  585b							;lda currentPly
    103  585b							;sta SET_BANK_RAM ;tmp?
    104  585b
      0  585b					      ldx@PLY	bestMove
      1  585b		       ae d2 f9 	      ldx	bestMove
    106  585e		       30 26		      bmi	.nomove
    107  5860
    108  5860							; Generate player's moves in reply
    109  5860							; Make the computer move, list player moves (PLY+1), unmake computer move
    110  5860
      0  5860					      stx@PLY	movePtr
      1  5860		       8e d1 fb 	      stx	[RAM]+movePtr
    112  5863		       20 87 f4 	      jsr	MakeMove	;@this
    113  5866		       20 30 f2 	      jsr	ListPlayerMoves	;@0
    114  5869
    115  5869		       c6 94		      dec	currentPly
    116  586b		       20 8f f2 	      jsr	unmakeMove	;@0
    117  586e
    118  586e							; Grab the computer move details for the UI animation
    119  586e
    120  586e		       a9 88		      lda	#RAMBANK_PLY
    121  5870		       85 3e		      sta	SET_BANK_RAM
    122  5872
      0  5872					      ldx@PLY	bestMove
      1  5872		       ae d2 f9 	      ldx	bestMove
      0  5875					      lda@PLY	MoveTo,x
      1  5875		       bd 64 f8 	      lda	MoveTo,x
    125  5878		       85 86		      sta	toX12
      0  587a					      lda@PLY	MoveFrom,x
      1  587a		       bd 00 f8 	      lda	MoveFrom,x
    127  587d		       85 87		      sta	originX12
    128  587f		       85 85		      sta	fromX12
      0  5881					      lda@PLY	MovePiece,x
      1  5881		       bd 00 f9 	      lda	MovePiece,x
    130  5884		       85 96		      sta	fromPiece
    131  5886
    132  5886				   .nomove
    133  5886		       60		      rts
    134  5887
    135  5887
    136  5887							;---------------------------------------------------------------------------------------------------
    137  5887
      0  5887					      DEF	MakeMove
      1  5887				   SLOT_MakeMove SET	_BANK_SLOT
      2  5887				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  5887				   MakeMove
      4  5887				   TEMPORARY_VAR SET	Overlay
      5  5887				   TEMPORARY_OFFSET SET	0
      6  5887				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  5887				   FUNCTION_NAME SET	MakeMove
    139  5887					      SUBROUTINE
    140  5887
      0  5887					      REFER	selectmove
      1  5887					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	VAREND_selectmove
      3  5887					      ENDIF
      0  5887					      REFER	ListPlayerMoves
      1  5887				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  5887					      ENDIF
      0  5887					      REFER	quiesce
      1  5887				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  5887					      ENDIF
      0  5887					      REFER	negaMax
      1  5887				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  5887				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  5887					      ENDIF
    145  5887
      0  5887					      VAR	__capture, 1
      1  5887		       00 b0	   __capture  =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __capture, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
      0  5887					      VAR	__restore, 1
      1  5887		       00 b1	   __restore  =	TEMPORARY_VAR
      2  5887				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5887
      4  5887				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5887				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5887				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5887					      ENDIF
      8  5887				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5887				  -	      ECHO	"Temporary Variable", __restore, "overflow!"
     10  5887				  -	      ERR
     11  5887					      ENDIF
     12  5887					      LIST	ON
    148  5887
      0  5887					      VEND	MakeMove
      1  5887				  -	      IFNCONST	MakeMove
      2  5887				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  5887				  -	      ERR
      4  5887					      ENDIF
      5  5887		       00 b2	   VAREND_MakeMove =	TEMPORARY_VAR
    150  5887
    151  5887							; Do a move without any GUI stuff
    152  5887							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    153  5887							; and all relevant flags in original state. This is NOT used for the visible move on the
    154  5887							; screen.
    155  5887
    156  5887
    157  5887							; fromPiece	 piece doing the move
    158  5887							; fromX12	 current square X12
    159  5887							; originX12	 starting square X12
    160  5887							; toX12	 ending square X12
    161  5887
    162  5887							; BANK:SLOT2 = currentPly
    163  5887
    164  5887
    165  5887							; There are potentially "two" moves, with the following
    166  5887							; a) Castling, moving both rook and king
    167  5887							; b) en-Passant, capturing pawn on "odd" square
    168  5887							; These both set "secondary" movers which are used for restoring during unmakeMove
    169  5887
    170  5887		       a9 00		      lda	#0
      0  5889					      sta@PLY	secondaryPiece
      1  5889		       8d cd fb 	      sta	[RAM]+secondaryPiece
    172  588c
      0  588c					      ldx@PLY	movePtr
      1  588c		       ae d1 f9 	      ldx	movePtr
      0  588f					      lda@PLY	MoveFrom,x
      1  588f		       bd 00 f8 	      lda	MoveFrom,x
    175  5892		       85 85		      sta	fromX12
    176  5894		       85 87		      sta	originX12
      0  5896					      lda@PLY	MoveTo,x
      1  5896		       bd 64 f8 	      lda	MoveTo,x
    178  5899		       85 86		      sta	toX12
      0  589b					      lda@PLY	MovePiece,x
      1  589b		       bd 00 f9 	      lda	MovePiece,x
    180  589e		       85 96		      sta	fromPiece
    181  58a0
      0  58a0				   .move      CALL	AdjustMaterialPositionalValue	;@2
      1  58a0				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  58a0				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  58a0				  -	      ECHO	"Cannot switch bank in use for", AdjustMaterialPositionalValue
      4  58a0				  -	      ERR
      5  58a0					      ENDIF
      6  58a0		       a9 91		      lda	#BANK_AdjustMaterialPositionalValue
      7  58a2		       85 3f		      sta	SET_BANK
      8  58a4		       20 b3 f8 	      jsr	AdjustMaterialPositionalValue
    183  58a7
    184  58a7							; Modify the board
    185  58a7
    186  58a7		       a0 cc		      ldy	#RAMBANK_BOARD
    187  58a9		       84 3e		      sty	SET_BANK_RAM	;@3
    188  58ab		       a4 87		      ldy	originX12
      0  58ad					      lda@RAM	Board,y
      1  58ad		       b9 79 fc 	      lda	Board,y
    190  58b0		       85 b1		      sta	__restore
    191  58b2		       a9 00		      lda	#0
      0  58b4					      sta@RAM	Board,y
      1  58b4		       99 79 fe 	      sta	[RAM]+Board,y
    193  58b7		       a4 86		      ldy	toX12
      0  58b9					      lda@RAM	Board,y
      1  58b9		       b9 79 fc 	      lda	Board,y
    195  58bc		       85 b0		      sta	__capture
    196  58be		       a5 96		      lda	fromPiece
    197  58c0		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
    198  58c2		       09 40		      ora	#FLAG_MOVED
      0  58c4					      sta@RAM	Board,y
      1  58c4		       99 79 fe 	      sta	[RAM]+Board,y
    200  58c7
    201  58c7		       a5 94		      lda	currentPly
    202  58c9		       85 3e		      sta	SET_BANK_RAM	;@2
    203  58cb		       a5 b0		      lda	__capture
      0  58cd					      sta@PLY	capturedPiece
      1  58cd		       8d cb fb 	      sta	[RAM]+capturedPiece
    205  58d0		       a5 b1		      lda	__restore
      0  58d2					      sta@PLY	restorePiece
      1  58d2		       8d da fb 	      sta	[RAM]+restorePiece
    207  58d5
    208  58d5					      IF	CASTLING_ENABLED
    209  58d5
    210  58d5							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    211  58d5							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    212  58d5							; redo the moving code (for the rook, this time).
    213  58d5
      0  58d5					      CALL	GenCastleMoveForRook	;@3
      1  58d5				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  58d5				  -	      ECHO	"ERROR: Incompatible call to function requiring same slot..."
      3  58d5				  -	      ECHO	"Cannot switch bank in use for", GenCastleMoveForRook
      4  58d5				  -	      ERR
      5  58d5					      ENDIF
      6  58d5		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      7  58d7		       85 3f		      sta	SET_BANK
      8  58d9		       20 21 fc 	      jsr	GenCastleMoveForRook
    215  58dc		       b0 c2		      bcs	.move	; move the rook!
    216  58de					      ENDIF
    217  58de
    218  58de
    219  58de				  -	      IF	ENPASSANT_ENABLED
    220  58de				  -	      jsr	EnPassantCheck
    221  58de				  -	      beq	.notEnPassant
    222  58de				  -	      jsr	EnPassantRemovePiece	; TODO will crash wrong bank!!!  y = origin X12
    223  58de				  -.notEnPassant
    224  58de					      ENDIF
    225  58de
    226  58de							; Swap over sides
    227  58de
      0  58de					      NEGEVAL
      1  58de
      2  58de		       38		      sec
      3  58df		       a9 00		      lda	#0
      4  58e1		       e5 8f		      sbc	Evaluation
      5  58e3		       85 8f		      sta	Evaluation
      6  58e5		       a9 00		      lda	#0
      7  58e7		       e5 90		      sbc	Evaluation+1
      8  58e9		       85 90		      sta	Evaluation+1
      0  58eb					      SWAP
      1  58eb		       a5 95		      lda	sideToMove
      2  58ed		       49 80		      eor	#SWAP_SIDE
      3  58ef		       85 95		      sta	sideToMove
      4  58f1
      5  58f1
    230  58f1
    231  58f1		       a5 94		      lda	currentPly
    232  58f3		       85 3e		      sta	SET_BANK_RAM
    233  58f5		       60		      rts
    234  58f6
    235  58f6
    236  58f6							;---------------------------------------------------------------------------------------------------
    237  58f6
    238  58f6							;function negaMax(node, depth, α, β, color) is
    239  58f6							;    if depth = 0 or node is a terminal node then
    240  58f6							;	  return color × the heuristic value of node
    241  58f6
    242  58f6							;    childNodes := generateMoves(node)
    243  58f6							;    childNodes := orderMoves(childNodes)
    244  58f6							;    value := −∞
    245  58f6							;    foreach child in childNodes do
    246  58f6							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    247  58f6							;	  α := max(α, value)
    248  58f6							;	  if α ≥ β then
    249  58f6							;	      break (* cut-off *)
    250  58f6							;    return value
    251  58f6							;(* Initial call for Player A's root node *)
    252  58f6							;negaMax(rootNode, depth, −∞, +∞, 1)
    253  58f6
    254  58f6
    255  58f6					      SUBROUTINE
    256  58f6
    257  58f6		       a9 ff	   .doQ       lda	#-1
    258  58f8		       85 af		      sta	__quiesceCapOnly
    259  58fa		       20 72 f6 	      jsr	quiesce
    260  58fd		       e6 af		      inc	__quiesceCapOnly
    261  58ff		       60		      rts
    262  5900
    263  5900
      0  5900				   .exit      lda@PLY	value
      1  5900		       ad d7 f9 	      lda	value
    265  5903		       85 ab		      sta	__negaMax
      0  5905					      lda@PLY	value+1
      1  5905		       ad d8 f9 	      lda	value+1
    267  5908		       85 ac		      sta	__negaMax+1
    268  590a		       60		      rts
    269  590b
    270  590b
    271  590b				   .terminal
    272  590b
    273  590b				  -	      IF	QUIESCE_EXTRA_DEPTH > 0
    274  590b				  -	      cmp	#0	; captured piece
    275  590b				  -	      bne	.doQ	; last move was capture, so quiesce
    276  590b					      ENDIF
    277  590b
    278  590b		       a5 8f		      lda	Evaluation
    279  590d		       85 ab		      sta	__negaMax
    280  590f		       a5 90		      lda	Evaluation+1
    281  5911		       85 ac		      sta	__negaMax+1
    282  5913
    283  5913		       60	   .inCheck2  rts
    284  5914
    285  5914
    286  5914
      0  5914					      DEF	negaMax
      1  5914				   SLOT_negaMax SET	_BANK_SLOT
      2  5914				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  5914				   negaMax
      4  5914				   TEMPORARY_VAR SET	Overlay
      5  5914				   TEMPORARY_OFFSET SET	0
      6  5914				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  5914				   FUNCTION_NAME SET	negaMax
    288  5914
    289  5914							; PARAMS depth-1, -beta, -alpha
    290  5914							; pased through temporary variables (__alpha, __beta) and X reg
    291  5914
    292  5914							; pass...
    293  5914							; x = depthleft
    294  5914							; a = captured piece
    295  5914							; SET_BANK_RAM      --> current ply
    296  5914							; __alpha[2] = param alpha
    297  5914							; __beta[2] = param beta
    298  5914
    299  5914
      0  5914					      COMMON_VARS_ALPHABETA
      1  5914
      0  5914					      VAR	__thinkbar, 1
      1  5914		       00 a4	   __thinkbar =	TEMPORARY_VAR
      2  5914				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5914
      4  5914				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5914				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5914				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5914					      ENDIF
      8  5914				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5914				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5914				  -	      ERR
     11  5914					      ENDIF
     12  5914					      LIST	ON
      0  5914					      VAR	__toggle, 1
      1  5914		       00 a5	   __toggle   =	TEMPORARY_VAR
      2  5914				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5914
      4  5914				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5914				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5914				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5914					      ENDIF
      8  5914				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5914				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5914				  -	      ERR
     11  5914					      ENDIF
     12  5914					      LIST	ON
      4  5914
      0  5914					      VAR	__bestMove, 1
      1  5914		       00 a6	   __bestMove =	TEMPORARY_VAR
      2  5914				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5914
      4  5914				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5914				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5914				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5914					      ENDIF
      8  5914				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5914				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5914				  -	      ERR
     11  5914					      ENDIF
     12  5914					      LIST	ON
      0  5914					      VAR	__alpha, 2
      1  5914		       00 a7	   __alpha    =	TEMPORARY_VAR
      2  5914				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5914
      4  5914				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5914				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5914				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5914					      ENDIF
      8  5914				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5914				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5914				  -	      ERR
     11  5914					      ENDIF
     12  5914					      LIST	ON
      0  5914					      VAR	__beta, 2
      1  5914		       00 a9	   __beta     =	TEMPORARY_VAR
      2  5914				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5914
      4  5914				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5914				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5914				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5914					      ENDIF
      8  5914				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5914				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5914				  -	      ERR
     11  5914					      ENDIF
     12  5914					      LIST	ON
      0  5914					      VAR	__negaMax, 2
      1  5914		       00 ab	   __negaMax  =	TEMPORARY_VAR
      2  5914				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5914
      4  5914				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5914				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5914				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5914					      ENDIF
      8  5914				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5914				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5914				  -	      ERR
     11  5914					      ENDIF
     12  5914					      LIST	ON
      0  5914					      VAR	__value, 2
      1  5914		       00 ad	   __value    =	TEMPORARY_VAR
      2  5914				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5914
      4  5914				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5914				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5914				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5914					      ENDIF
      8  5914				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5914				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5914				  -	      ERR
     11  5914					      ENDIF
     12  5914					      LIST	ON
     10  5914
      0  5914					      VAR	__quiesceCapOnly, 1
      1  5914		       00 af	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5914				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5914
      4  5914				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5914				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5914				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5914					      ENDIF
      8  5914				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5914				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5914				  -	      ERR
     11  5914					      ENDIF
     12  5914					      LIST	ON
     12  5914
      0  5914					      REFER	selectmove
      1  5914				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  5914				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  5914					      ENDIF
      0  5914					      VEND	negaMax
      1  5914				  -	      IFNCONST	negaMax
      2  5914				  -	      ECHO	"Incorrect VEND label", negaMax
      3  5914				  -	      ERR
      4  5914					      ENDIF
      5  5914		       00 b0	   VAREND_negaMax =	TEMPORARY_VAR
    303  5914
    304  5914		       48		      pha
    305  5915
    306  5915		       20 7e f0 	      jsr	ThinkBar	;@0
    307  5918
    308  5918		       a5 94		      lda	currentPly
    309  591a		       85 3e		      sta	SET_BANK_RAM	;@2
    310  591c
    311  591c		       68		      pla
    312  591d		       ca		      dex
    313  591e		       30 eb		      bmi	.terminal
      0  5920					      stx@PLY	depthLeft
      1  5920		       8e d9 fb 	      stx	[RAM]+depthLeft
    315  5923
    316  5923
    317  5923							; Allow the player to force computer to select a move. Press the SELECT switch
    318  5923
      0  5923					      lda@PLY	bestMove
      1  5923		       ad d2 f9 	      lda	bestMove
    320  5926		       30 07		      bmi	.noCheat	; can't force if no move chosen!
    321  5928		       ad 82 02 	      lda	SWCHB
    322  592b		       29 02		      and	#2
    323  592d		       f0 d1		      beq	.exit	; SELECT abort
    324  592f				   .noCheat
    325  592f
    326  592f							;lda #2
    327  592f							;sta COLUPF			  ; grey thinkbars
    328  592f
    329  592f		       a5 a7		      lda	__alpha
      0  5931					      sta@PLY	alpha
      1  5931		       8d d3 fb 	      sta	[RAM]+alpha
    331  5934		       a5 a8		      lda	__alpha+1
      0  5936					      sta@PLY	alpha+1
      1  5936		       8d d4 fb 	      sta	[RAM]+alpha+1
    333  5939
    334  5939		       a5 a9		      lda	__beta
      0  593b					      sta@PLY	beta
      1  593b		       8d d5 fb 	      sta	[RAM]+beta
    336  593e		       a5 aa		      lda	__beta+1
      0  5940					      sta@PLY	beta+1
      1  5940		       8d d6 fb 	      sta	[RAM]+beta+1
    338  5943
    339  5943
    340  5943				  -	      IF	0
    341  5943				  -	      NEXT_RANDOM
    342  5943				  -	      lda	Evaluation
    343  5943				  -	      adc	randomness
    344  5943				  -	      sta	Evaluation
    345  5943				  -	      bcc	.evh
    346  5943				  -	      inc	Evaluation+1
    347  5943				  -.evh
    348  5943					      ENDIF
    349  5943
    350  5943
    351  5943		       20 8c f1 	      jsr	GenerateAllMoves	;@0
    352  5946
    353  5946		       a5 a1		      lda	flagCheck
    354  5948		       d0 c9		      bne	.inCheck2	; OTHER guy in check
    355  594a
    356  594a				  -	      IF	0
    357  594a				  -	      lda@PLY	moveIndex
    358  594a				  -	      bmi	.none
    359  594a				  -	      lsr
    360  594a				  -	      lsr
    361  594a				  -	      lsr
    362  594a				  -	      lsr
    363  594a				  -	      lsr
    364  594a				  -	      adc	Evaluation
    365  594a				  -	      sta	Evaluation
    366  594a				  -	      lda	Evaluation+1
    367  594a				  -	      adc	#0
    368  594a				  -	      sta	Evaluation+1
    369  594a				  -.none
    370  594a					      ENDIF
    371  594a
    372  594a
    373  594a		       a9 00		      lda	#<-INFINITY
      0  594c					      sta@PLY	value
      1  594c		       8d d7 fb 	      sta	[RAM]+value
    375  594f		       a9 90		      lda	#>-INFINITY
      0  5951					      sta@PLY	value+1
      1  5951		       8d d8 fb 	      sta	[RAM]+value+1
    377  5954
      0  5954					      ldx@PLY	moveIndex
      1  5954		       ae d0 f9 	      ldx	moveIndex
    379  5957		       10 03		      bpl	.forChild
    380  5959		       4c 00 f5 	      jmp	.exit
    381  595c
      0  595c				   .forChild  stx@PLY	movePtr
      1  595c		       8e d1 fb 	      stx	[RAM]+movePtr
    383  595f
    384  595f		       20 87 f4 	      jsr	MakeMove	;@this
    385  5962
    386  5962
    387  5962							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    388  5962
    389  5962							; PARAMS depth-1, -beta, -alpha
    390  5962							; pased through temporary variables (__alpha, __beta) and X reg
    391  5962
    392  5962		       38		      sec
    393  5963		       a9 00		      lda	#0
      0  5965					      sbc@PLY	beta
      1  5965		       ed d5 f9 	      sbc	beta
    395  5968		       85 a7		      sta	__alpha
    396  596a		       a9 00		      lda	#0
      0  596c					      sbc@PLY	beta+1
      1  596c		       ed d6 f9 	      sbc	beta+1
    398  596f		       85 a8		      sta	__alpha+1
    399  5971
    400  5971		       38		      sec
    401  5972		       a9 00		      lda	#0
      0  5974					      sbc@PLY	alpha
      1  5974		       ed d3 f9 	      sbc	alpha
    403  5977		       85 a9		      sta	__beta
    404  5979		       a9 00		      lda	#0
      0  597b					      sbc@PLY	alpha+1
      1  597b		       ed d4 f9 	      sbc	alpha+1
    406  597e		       85 aa		      sta	__beta+1
    407  5980
    408  5980
      0  5980					      ldx@PLY	depthLeft
      1  5980		       ae d9 f9 	      ldx	depthLeft
      0  5983					      lda@PLY	capturedPiece
      1  5983		       ad cb f9 	      lda	capturedPiece
    411  5986
    412  5986		       e6 94		      inc	currentPly
    413  5988		       a4 94		      ldy	currentPly
    414  598a		       84 3e		      sty	SET_BANK_RAM	; self-switch
    415  598c
    416  598c		       20 14 f5 	      jsr	negaMax	;@this
    417  598f
    418  598f		       c6 94		      dec	currentPly
    419  5991		       a5 94		      lda	currentPly
    420  5993		       85 3e		      sta	SET_BANK_RAM
    421  5995
    422  5995		       20 8f f2 	      jsr	unmakeMove	;@0
    423  5998
    424  5998		       38		      sec
    425  5999		       a9 00		      lda	#0
    426  599b		       e5 ab		      sbc	__negaMax
    427  599d		       85 ab		      sta	__negaMax
    428  599f		       a9 00		      lda	#0
    429  59a1		       e5 ac		      sbc	__negaMax+1
    430  59a3		       85 ac		      sta	__negaMax+1	; -negaMax(...)
    431  59a5
    432  59a5					      IF	1
    433  59a5		       a5 a1		      lda	flagCheck
    434  59a7		       f0 06		      beq	.notCheck
    435  59a9
    436  59a9							; at this point we've determined that the move was illegal, because the next ply detected
    437  59a9							; a king capture. So, the move should be totally discounted
    438  59a9
    439  59a9		       a9 00		      lda	#0
    440  59ab		       85 a1		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    441  59ad		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    442  59af					      ENDIF
    443  59af
    444  59af		       38	   .notCheck  sec
      0  59b0					      lda@PLY	value
      1  59b0		       ad d7 f9 	      lda	value
    446  59b3		       e5 ab		      sbc	__negaMax
      0  59b5					      lda@PLY	value+1
      1  59b5		       ad d8 f9 	      lda	value+1
    448  59b8		       e5 ac		      sbc	__negaMax+1
    449  59ba		       50 02		      bvc	.lab0
    450  59bc		       49 80		      eor	#$80
    451  59be		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    452  59c0
    453  59c0							; so, negaMax > value!
    454  59c0
    455  59c0		       a5 ab		      lda	__negaMax
      0  59c2					      sta@PLY	value
      1  59c2		       8d d7 fb 	      sta	[RAM]+value
    457  59c5		       a5 ac		      lda	__negaMax+1
      0  59c7					      sta@PLY	value+1	; max(value, -negaMax)
      1  59c7		       8d d8 fb 	      sta	[RAM]+value+1
    459  59ca
      0  59ca					      lda@PLY	movePtr
      1  59ca		       ad d1 f9 	      lda	movePtr
      0  59cd					      sta@PLY	bestMove
      1  59cd		       8d d2 fb 	      sta	[RAM]+bestMove
    462  59d0				   .lt0
    463  59d0
    464  59d0							;	  α := max(α, value)
    465  59d0
    466  59d0		       38		      sec
      0  59d1					      lda@PLY	value
      1  59d1		       ad d7 f9 	      lda	value
      0  59d4					      sbc@PLY	alpha
      1  59d4		       ed d3 f9 	      sbc	alpha
      0  59d7					      lda@PLY	value+1
      1  59d7		       ad d8 f9 	      lda	value+1
      0  59da					      sbc@PLY	alpha+1
      1  59da		       ed d4 f9 	      sbc	alpha+1
    471  59dd		       50 02		      bvc	.lab1
    472  59df		       49 80		      eor	#$80
    473  59e1		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    474  59e3
      0  59e3					      lda@PLY	value
      1  59e3		       ad d7 f9 	      lda	value
      0  59e6					      sta@PLY	alpha
      1  59e6		       8d d3 fb 	      sta	[RAM]+alpha
      0  59e9					      lda@PLY	value+1
      1  59e9		       ad d8 f9 	      lda	value+1
      0  59ec					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  59ec		       8d d4 fb 	      sta	[RAM]+alpha+1
    479  59ef
    480  59ef				   .lt1
    481  59ef
    482  59ef							;	  if α ≥ β then
    483  59ef							;	      break (* cut-off *)
    484  59ef
    485  59ef		       38		      sec
      0  59f0					      lda@PLY	alpha
      1  59f0		       ad d3 f9 	      lda	alpha
      0  59f3					      sbc@PLY	beta
      1  59f3		       ed d5 f9 	      sbc	beta
      0  59f6					      lda@PLY	alpha+1
      1  59f6		       ad d4 f9 	      lda	alpha+1
      0  59f9					      sbc@PLY	beta+1
      1  59f9		       ed d6 f9 	      sbc	beta+1
    490  59fc		       50 02		      bvc	.lab2
    491  59fe		       49 80		      eor	#$80
    492  5a00		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    493  5a02
    494  5a02
      0  5a02				   .nextMove  ldx@PLY	movePtr
      1  5a02		       ae d1 f9 	      ldx	movePtr
    496  5a05		       ca	   .nextX     dex
    497  5a06		       30 03		      bmi	.retrn
    498  5a08		       4c 5c f5 	      jmp	.forChild
    499  5a0b
    500  5a0b		       4c 00 f5    .retrn     jmp	.exit
    501  5a0e
    502  5a0e							;---------------------------------------------------------------------------------------------------
    503  5a0e
    504  5a0e					      MAC	xchg
    505  5a0e					      lda@PLY	{1},x
    506  5a0e					      pha		;sta __xchg
    507  5a0e					      lda@PLY	{1},y
    508  5a0e					      sta@PLY	{1},x
    509  5a0e					      pla		;lda __xchg
    510  5a0e					      sta@PLY	{1},y
    511  5a0e					      ENDM		;{name}
    512  5a0e
    513  5a0e
      0  5a0e					      DEF	Sort
      1  5a0e				   SLOT_Sort  SET	_BANK_SLOT
      2  5a0e				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  5a0e				   Sort
      4  5a0e				   TEMPORARY_VAR SET	Overlay
      5  5a0e				   TEMPORARY_OFFSET SET	0
      6  5a0e				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  5a0e				   FUNCTION_NAME SET	Sort
    515  5a0e					      SUBROUTINE
    516  5a0e
      0  5a0e					      REFER	GenerateAllMoves
      1  5a0e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5a0e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5a0e					      ENDIF
      0  5a0e					      VAR	__xchg, 1
      1  5a0e		       00 b5	   __xchg     =	TEMPORARY_VAR
      2  5a0e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a0e
      4  5a0e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a0e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a0e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a0e					      ENDIF
      8  5a0e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a0e				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  5a0e				  -	      ERR
     11  5a0e					      ENDIF
     12  5a0e					      LIST	ON
      0  5a0e					      VEND	Sort
      1  5a0e				  -	      IFNCONST	Sort
      2  5a0e				  -	      ECHO	"Incorrect VEND label", Sort
      3  5a0e				  -	      ERR
      4  5a0e					      ENDIF
      5  5a0e		       00 b6	   VAREND_Sort =	TEMPORARY_VAR
    520  5a0e
    521  5a0e		       a5 af		      lda	__quiesceCapOnly
    522  5a10		       d0 4a		      bne	.exit	; only caps present so already sorted!
    523  5a12
      0  5a12					      ldx@PLY	moveIndex
      1  5a12		       ae d0 f9 	      ldx	moveIndex
      0  5a15					      ldy@PLY	moveIndex
      1  5a15		       ac d0 f9 	      ldy	moveIndex
    526  5a18		       c8		      iny		; this is OK - swaps "1st" with itself if it's a capture
    527  5a19
    528  5a19		       88	   .next      dey
    529  5a1a		       30 40		      bmi	.exit
    530  5a1c
      0  5a1c					      lda@PLY	MoveCapture,y
      1  5a1c		       b9 64 f9 	      lda	MoveCapture,y
    532  5a1f		       f0 f8		      beq	.next
    533  5a21
      0  5a21					      XCHG	MoveFrom
      0  5a21					      lda@PLY	MoveFrom,x
      1  5a21		       bd 00 f8 	      lda	MoveFrom,x
      2  5a24		       48		      pha
      0  5a25					      lda@PLY	MoveFrom,y
      1  5a25		       b9 00 f8 	      lda	MoveFrom,y
      0  5a28					      sta@PLY	MoveFrom,x
      1  5a28		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  5a2b		       68		      pla
      0  5a2c					      sta@PLY	MoveFrom,y
      1  5a2c		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  5a2f					      XCHG	MoveTo
      0  5a2f					      lda@PLY	MoveTo,x
      1  5a2f		       bd 64 f8 	      lda	MoveTo,x
      2  5a32		       48		      pha
      0  5a33					      lda@PLY	MoveTo,y
      1  5a33		       b9 64 f8 	      lda	MoveTo,y
      0  5a36					      sta@PLY	MoveTo,x
      1  5a36		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  5a39		       68		      pla
      0  5a3a					      sta@PLY	MoveTo,y
      1  5a3a		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  5a3d					      XCHG	MovePiece
      0  5a3d					      lda@PLY	MovePiece,x
      1  5a3d		       bd 00 f9 	      lda	MovePiece,x
      2  5a40		       48		      pha
      0  5a41					      lda@PLY	MovePiece,y
      1  5a41		       b9 00 f9 	      lda	MovePiece,y
      0  5a44					      sta@PLY	MovePiece,x
      1  5a44		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  5a47		       68		      pla
      0  5a48					      sta@PLY	MovePiece,y
      1  5a48		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  5a4b					      XCHG	MoveCapture
      0  5a4b					      lda@PLY	MoveCapture,x
      1  5a4b		       bd 64 f9 	      lda	MoveCapture,x
      2  5a4e		       48		      pha
      0  5a4f					      lda@PLY	MoveCapture,y
      1  5a4f		       b9 64 f9 	      lda	MoveCapture,y
      0  5a52					      sta@PLY	MoveCapture,x
      1  5a52		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  5a55		       68		      pla
      0  5a56					      sta@PLY	MoveCapture,y
      1  5a56		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    538  5a59
    539  5a59		       ca		      dex
    540  5a5a		       10 bd		      bpl	.next
    541  5a5c
    542  5a5c				   .exit
    543  5a5c
    544  5a5c
    545  5a5c
    546  5a5c
    547  5a5c							; Scan for capture of king
    548  5a5c
      0  5a5c					      ldx@PLY	moveIndex
      1  5a5c		       ae d0 f9 	      ldx	moveIndex
    550  5a5f
      0  5a5f				   .scanCheck lda@PLY	MoveCapture,x
      1  5a5f		       bd 64 f9 	      lda	MoveCapture,x
    552  5a62		       f0 0b		      beq	.check	; since they're sorted with captures "first" we can exit
    553  5a64		       29 0f		      and	#PIECE_MASK
    554  5a66		       c9 07		      cmp	#KING
    555  5a68		       f0 05		      beq	.check
    556  5a6a		       ca		      dex
    557  5a6b		       10 f2		      bpl	.scanCheck
    558  5a6d
    559  5a6d		       a9 00		      lda	#0
    560  5a6f		       85 a1	   .check     sta	flagCheck
    561  5a71		       60		      rts
    562  5a72
    563  5a72
    564  5a72							;---------------------------------------------------------------------------------------------------
    565  5a72							; QUIESCE!
    566  5a72
    567  5a72							;int Quiesce( int alpha, int beta ) {
    568  5a72							;    int stand_pat = Evaluate();
    569  5a72							;    if( stand_pat >= beta )
    570  5a72							;	  return beta;
    571  5a72							;    if( alpha < stand_pat )
    572  5a72							;	  alpha = stand_pat;
    573  5a72
    574  5a72							;    until( every_capture_has_been_examined )	{
    575  5a72							;	  MakeCapture();
    576  5a72							;	  score = -Quiesce( -beta, -alpha );
    577  5a72							;	  TakeBackMove();
    578  5a72
    579  5a72							;	  if( score >= beta )
    580  5a72							;	      return beta;
    581  5a72							;	  if( score > alpha )
    582  5a72							;	     alpha = score;
    583  5a72							;    }
    584  5a72							;    return alpha;
    585  5a72							;}
    586  5a72
    587  5a72
    588  5a72							;---------------------------------------------------------------------------------------------------
    589  5a72
      0  5a72					      DEF	quiesce
      1  5a72				   SLOT_quiesce SET	_BANK_SLOT
      2  5a72				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  5a72				   quiesce
      4  5a72				   TEMPORARY_VAR SET	Overlay
      5  5a72				   TEMPORARY_OFFSET SET	0
      6  5a72				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  5a72				   FUNCTION_NAME SET	quiesce
    591  5a72					      SUBROUTINE
    592  5a72
    593  5a72							; pass...
    594  5a72							; x = depthleft
    595  5a72							; SET_BANK_RAM      --> current ply
    596  5a72							; __alpha[2] = param alpha
    597  5a72							; __beta[2] = param beta
    598  5a72
    599  5a72
      0  5a72					      COMMON_VARS_ALPHABETA
      1  5a72
      0  5a72					      VAR	__thinkbar, 1
      1  5a72		       00 a4	   __thinkbar =	TEMPORARY_VAR
      2  5a72				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a72
      4  5a72				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a72				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a72				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a72					      ENDIF
      8  5a72				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a72				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  5a72				  -	      ERR
     11  5a72					      ENDIF
     12  5a72					      LIST	ON
      0  5a72					      VAR	__toggle, 1
      1  5a72		       00 a5	   __toggle   =	TEMPORARY_VAR
      2  5a72				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a72
      4  5a72				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a72				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a72				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a72					      ENDIF
      8  5a72				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a72				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  5a72				  -	      ERR
     11  5a72					      ENDIF
     12  5a72					      LIST	ON
      4  5a72
      0  5a72					      VAR	__bestMove, 1
      1  5a72		       00 a6	   __bestMove =	TEMPORARY_VAR
      2  5a72				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a72
      4  5a72				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a72				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a72				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a72					      ENDIF
      8  5a72				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a72				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  5a72				  -	      ERR
     11  5a72					      ENDIF
     12  5a72					      LIST	ON
      0  5a72					      VAR	__alpha, 2
      1  5a72		       00 a7	   __alpha    =	TEMPORARY_VAR
      2  5a72				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a72
      4  5a72				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a72				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a72				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a72					      ENDIF
      8  5a72				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a72				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  5a72				  -	      ERR
     11  5a72					      ENDIF
     12  5a72					      LIST	ON
      0  5a72					      VAR	__beta, 2
      1  5a72		       00 a9	   __beta     =	TEMPORARY_VAR
      2  5a72				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a72
      4  5a72				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a72				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a72				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a72					      ENDIF
      8  5a72				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a72				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  5a72				  -	      ERR
     11  5a72					      ENDIF
     12  5a72					      LIST	ON
      0  5a72					      VAR	__negaMax, 2
      1  5a72		       00 ab	   __negaMax  =	TEMPORARY_VAR
      2  5a72				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a72
      4  5a72				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a72				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a72				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a72					      ENDIF
      8  5a72				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a72				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  5a72				  -	      ERR
     11  5a72					      ENDIF
     12  5a72					      LIST	ON
      0  5a72					      VAR	__value, 2
      1  5a72		       00 ad	   __value    =	TEMPORARY_VAR
      2  5a72				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5a72
      4  5a72				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a72				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a72				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a72					      ENDIF
      8  5a72				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a72				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  5a72				  -	      ERR
     11  5a72					      ENDIF
     12  5a72					      LIST	ON
     10  5a72
      0  5a72					      VAR	__quiesceCapOnly, 1
      1  5a72		       00 af	   __quiesceCapOnly =	TEMPORARY_VAR
      2  5a72				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5a72
      4  5a72				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5a72				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5a72				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5a72					      ENDIF
      8  5a72				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5a72				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  5a72				  -	      ERR
     11  5a72					      ENDIF
     12  5a72					      LIST	ON
     12  5a72
      0  5a72					      REFER	negaMax
      1  5a72				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  5a72				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  5a72					      ENDIF
      0  5a72					      VEND	quiesce
      1  5a72				  -	      IFNCONST	quiesce
      2  5a72				  -	      ECHO	"Incorrect VEND label", quiesce
      3  5a72				  -	      ERR
      4  5a72					      ENDIF
      5  5a72		       00 b0	   VAREND_quiesce =	TEMPORARY_VAR
    603  5a72
    604  5a72		       a5 94		      lda	currentPly
    605  5a74		       c9 8b		      cmp	#RAMBANK_PLY + PLY_BANKS -1
    606  5a76		       b0 2a		      bcs	.retBeta
    607  5a78		       85 3e		      sta	SET_BANK_RAM	;tmp
    608  5a7a
    609  5a7a
    610  5a7a		       20 7e f0 	      jsr	ThinkBar	;@0
    611  5a7d
    612  5a7d		       a5 a9		      lda	__beta
      0  5a7f					      sta@PLY	beta
      1  5a7f		       8d d5 fb 	      sta	[RAM]+beta
    614  5a82		       a5 aa		      lda	__beta+1
      0  5a84					      sta@PLY	beta+1
      1  5a84		       8d d6 fb 	      sta	[RAM]+beta+1
    616  5a87
    617  5a87		       a5 a7		      lda	__alpha
      0  5a89					      sta@PLY	alpha
      1  5a89		       8d d3 fb 	      sta	[RAM]+alpha
    619  5a8c		       a5 a8		      lda	__alpha+1
      0  5a8e					      sta@PLY	alpha+1
      1  5a8e		       8d d4 fb 	      sta	[RAM]+alpha+1
    621  5a91
    622  5a91
    623  5a91							;    int stand_pat = Evaluate();
    624  5a91							;    if( stand_pat >= beta )
    625  5a91							;	  return beta;
    626  5a91
    627  5a91		       38		      sec
    628  5a92		       a5 8f		      lda	Evaluation
      0  5a94					      sbc@PLY	beta
      1  5a94		       ed d5 f9 	      sbc	beta
    630  5a97		       a5 90		      lda	Evaluation+1
      0  5a99					      sbc@PLY	beta+1
      1  5a99		       ed d6 f9 	      sbc	beta+1
    632  5a9c		       50 02		      bvc	.spat0
    633  5a9e		       49 80		      eor	#$80
    634  5aa0		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    635  5aa2
    636  5aa2		       ad d5 f9    .retBeta   lda	beta
    637  5aa5		       85 ab		      sta	__negaMax
    638  5aa7		       ad d6 f9 	      lda	beta+1
    639  5aaa		       85 ac		      sta	__negaMax+1
    640  5aac
    641  5aac		       60	   .abort     rts
    642  5aad
    643  5aad				   .norb
    644  5aad
    645  5aad
    646  5aad							;    if( alpha < stand_pat )
    647  5aad							;	  alpha = stand_pat;
    648  5aad
    649  5aad		       38		      sec
    650  5aae		       ad d3 f9 	      lda	alpha
    651  5ab1		       e5 8f		      sbc	Evaluation
    652  5ab3		       ad d4 f9 	      lda	alpha+1
    653  5ab6		       e5 90		      sbc	Evaluation+1
    654  5ab8		       50 02		      bvc	.spat1
    655  5aba		       49 80		      eor	#$80
    656  5abc		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    657  5abe
    658  5abe							; alpha < stand_pat
    659  5abe
    660  5abe		       a5 8f		      lda	Evaluation
      0  5ac0					      sta@PLY	alpha
      1  5ac0		       8d d3 fb 	      sta	[RAM]+alpha
    662  5ac3		       a5 90		      lda	Evaluation+1
      0  5ac5					      sta@PLY	alpha+1
      1  5ac5		       8d d4 fb 	      sta	[RAM]+alpha+1
    664  5ac8
    665  5ac8				   .alpha
    666  5ac8		       20 8c f1 	      jsr	GenerateAllMoves
    667  5acb		       a5 a1		      lda	flagCheck
    668  5acd		       d0 dd		      bne	.abort	; pure abort
    669  5acf
      0  5acf					      ldx@PLY	moveIndex
      1  5acf		       ae d0 f9 	      ldx	moveIndex
    671  5ad2		       30 76		      bmi	.exit
    672  5ad4
      0  5ad4				   .forChild  stx@PLY	movePtr
      1  5ad4		       8e d1 fb 	      stx	[RAM]+movePtr
    674  5ad7
    675  5ad7							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    676  5ad7
    677  5ad7		       20 87 f4 	      jsr	MakeMove	;@this
    678  5ada
    679  5ada		       38		      sec
    680  5adb		       a9 00		      lda	#0
      0  5add					      sbc@PLY	beta
      1  5add		       ed d5 f9 	      sbc	beta
    682  5ae0		       85 a7		      sta	__alpha
    683  5ae2		       a9 00		      lda	#0
      0  5ae4					      sbc@PLY	beta+1
      1  5ae4		       ed d6 f9 	      sbc	beta+1
    685  5ae7		       85 a8		      sta	__alpha+1
    686  5ae9
    687  5ae9		       38		      sec
    688  5aea		       a9 00		      lda	#0
      0  5aec					      sbc@PLY	alpha
      1  5aec		       ed d3 f9 	      sbc	alpha
    690  5aef		       85 a9		      sta	__beta
    691  5af1		       a9 00		      lda	#0
      0  5af3					      sbc@PLY	alpha+1
      1  5af3		       ed d4 f9 	      sbc	alpha+1
    693  5af6		       85 aa		      sta	__beta+1
    694  5af8
    695  5af8		       e6 94		      inc	currentPly
    696  5afa		       a5 94		      lda	currentPly
    697  5afc		       85 3e		      sta	SET_BANK_RAM	; self-switch
    698  5afe
    699  5afe		       20 72 f6 	      jsr	quiesce	;@this
    700  5b01
    701  5b01		       c6 94		      dec	currentPly
    702  5b03
    703  5b03		       20 8f f2 	      jsr	unmakeMove	;@0
    704  5b06
    705  5b06		       a5 a1		      lda	flagCheck	; don't consider moves which leave us in check
    706  5b08		       d0 4b		      bne	.inCheck
    707  5b0a
    708  5b0a		       38		      sec
    709  5b0b							;lda #0			 ; already 0
    710  5b0b		       e5 ab		      sbc	__negaMax
    711  5b0d		       85 ab		      sta	__negaMax
    712  5b0f		       a9 00		      lda	#0
    713  5b11		       e5 ac		      sbc	__negaMax+1
    714  5b13		       85 ac		      sta	__negaMax+1	; -negaMax(...)
    715  5b15
    716  5b15
    717  5b15
    718  5b15							;	  if( score >= beta )
    719  5b15							;	      return beta;
    720  5b15
    721  5b15
    722  5b15		       38		      sec
    723  5b16		       a5 ab		      lda	__negaMax
      0  5b18					      sbc@PLY	beta
      1  5b18		       ed d5 f9 	      sbc	beta
    725  5b1b		       a5 ac		      lda	__negaMax+1
      0  5b1d					      sbc@PLY	beta+1
      1  5b1d		       ed d6 f9 	      sbc	beta+1
    727  5b20		       50 02		      bvc	.lab0
    728  5b22		       49 80		      eor	#$80
    729  5b24		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    730  5b26		       4c a2 f6 	      jmp	.retBeta
    731  5b29				   .nrb2
    732  5b29
    733  5b29							;	  if( score > alpha )
    734  5b29							;	     alpha = score;
    735  5b29							;    }
    736  5b29
    737  5b29		       38		      sec
      0  5b2a					      lda@PLY	alpha
      1  5b2a		       ad d3 f9 	      lda	alpha
    739  5b2d		       e5 ab		      sbc	__negaMax
      0  5b2f					      lda@PLY	alpha+1
      1  5b2f		       ad d4 f9 	      lda	alpha+1
    741  5b32		       e5 ac		      sbc	__negaMax+1
    742  5b34		       50 02		      bvc	.lab2
    743  5b36		       49 80		      eor	#$80
    744  5b38		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    745  5b3a
    746  5b3a							; score > alpha
    747  5b3a
    748  5b3a		       a5 ab		      lda	__negaMax
      0  5b3c					      sta@PLY	alpha
      1  5b3c		       8d d3 fb 	      sta	[RAM]+alpha
    750  5b3f		       a5 ac		      lda	__negaMax+1
      0  5b41					      sta@PLY	alpha+1
      1  5b41		       8d d4 fb 	      sta	[RAM]+alpha+1
    752  5b44
      0  5b44				   .nextMove  ldx@PLY	movePtr
      1  5b44		       ae d1 f9 	      ldx	movePtr
    754  5b47		       ca		      dex
    755  5b48		       10 8a		      bpl	.forChild
    756  5b4a
    757  5b4a							;    return alpha;
    758  5b4a
    759  5b4a				   .exit
      0  5b4a					      lda@PLY	alpha
      1  5b4a		       ad d3 f9 	      lda	alpha
    761  5b4d		       85 ab		      sta	__negaMax
      0  5b4f					      lda@PLY	alpha+1
      1  5b4f		       ad d4 f9 	      lda	alpha+1
    763  5b52		       85 ac		      sta	__negaMax+1
    764  5b54		       60		      rts
    765  5b55
    766  5b55		       a9 00	   .inCheck   lda	#0
    767  5b57		       85 a1		      sta	flagCheck
    768  5b59		       f0 e9		      beq	.nextMove
    769  5b5b
    770  5b5b
    771  5b5b							;---------------------------------------------------------------------------------------------------
    772  5b5b
      0  5b5b					      CHECK_BANK_SIZE	"NEGAMAX"
      1  5b5b		       03 5b	   .TEMP      =	* - _BANK_START
 NEGAMAX (1K) SIZE =  $35b , FREE= $a5
      2  5b5b					      ECHO	"NEGAMAX", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5b5b				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5b5b				  -	      ECHO	"BANK OVERFLOW @ ", "NEGAMAX", " size=", * - ORIGIN
      5  5b5b				  -	      ERR
      6  5b5b					      ENDIF
    774  5b5b
    775  5b5b							;---------------------------------------------------------------------------------------------------
    776  5b5b							; EOF
------- FILE ./chess.asm
    638  5b5b
------- FILE PIECE_MACROS.asm LEVEL 2 PASS 4
      0  5b5b					      include	"PIECE_MACROS.asm"
      1  5b5b							; Copyright (C)2020 Andrew Davie
      2  5b5b							; Common macros for piece move handlers
      3  5b5b
      4  5b5b							;---------------------------------------------------------------------------------------------------
      5  5b5b							; Looks at a square offset {1} to see if piece can move to it
      6  5b5b							; Adds the square to the movelist if it can
      7  5b5b							; Keeps moving in the same direction until it's blocked/off=board
      8  5b5b
      9  5b5b					      MAC	move_towards
     10  5b5b					      SUBROUTINE
     11  5b5b
     12  5b5b							; = 76 for single square (empty/take)
     13  5b5b
     14  5b5b					      lda	#0
     15  5b5b					      sta	capture
     16  5b5b
     17  5b5b					      ldx	currentSquare	; 3
     18  5b5b					      bne	.project	; 3   unconditional
     19  5b5b
     20  5b5b				   .empty     jsr	AddMove	; 57
     21  5b5b				   .project   ldy	ValidSquare+{1},x	; 4
     22  5b5b					      bmi	.invalid	; 2/3 off board!
     23  5b5b					      lda	Board,y	; 4   piece @ destination
     24  5b5b					      beq	.empty	; 2/3
     25  5b5b					      sta	capture
     26  5b5b					      eor	currentPiece	; 3
     27  5b5b					      bpl	.invalid	; 2/3 same colour
     28  5b5b					      jsr	AddMove	; 57  and exit
     29  5b5b
     30  5b5b				   .invalid
     31  5b5b					      ENDM
     32  5b5b
     33  5b5b
     34  5b5b							;---------------------------------------------------------------------------------------------------
     35  5b5b
     36  5b5b					      MAC	move_to
     37  5b5b					      SUBROUTINE
     38  5b5b					      ldy	ValidSquare+{1},x
     39  5b5b					      bmi	.invalid	; off board!
     40  5b5b					      lda	Board,y	; piece @ destination
     41  5b5b					      sta	capture
     42  5b5b					      beq	.squareEmpty
     43  5b5b					      eor	currentPiece
     44  5b5b					      bpl	.invalid	; same colour
     45  5b5b				   .squareEmpty jsr	AddMove
     46  5b5b				   .invalid
     47  5b5b					      ENDM
     48  5b5b
     49  5b5b
     50  5b5b							;---------------------------------------------------------------------------------------------------
     51  5b5b
     52  5b5b					      MAC	move_to_x
     53  5b5b					      ldx	currentSquare
     54  5b5b					      MOVE_TO	{1}
     55  5b5b					      ENDM
     56  5b5b
     57  5b5b
     58  5b5b							;---------------------------------------------------------------------------------------------------
     59  5b5b							; EOF
------- FILE ./chess.asm
    640  5b5b
------- FILE PIECE_HANDLER@1#1.asm LEVEL 2 PASS 4
      0  5b5b					      include	"PIECE_HANDLER@1#1.asm"
      0  5b5b					      SLOT	1
      1  5b5b				  -	      IF	(1 < 0) || (1 > 3)
      2  5b5b				  -	      ECHO	"Illegal bank address/segment location", 1
      3  5b5b				  -	      ERR
      4  5b5b					      ENDIF
      5  5b5b				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  5b5b				   _BANK_SLOT SET	1 * 64
      0  5b5b					      NEWBANK	PIECE_HANDLER_1
      1  5e68 ????				      SEG	PIECE_HANDLER_1
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   PIECE_HANDLER_1_START SET	*
      6  5c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5c00				   PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  5c00
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  5c00					      include	"PIECE_PAWN.asm"
      1  5c00							; Copyright (C)2020 Andrew Davie
      2  5c00							; Pawn move handlers
      3  5c00
      4  5c00							;---------------------------------------------------------------------------------------------------
      5  5c00							; WHITE PAWN
      6  5c00							;---------------------------------------------------------------------------------------------------
      7  5c00
      8  5c00		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  5c00		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  5c00
     11  5c00							;---------------------------------------------------------------------------------------------------
     12  5c00
     13  5c00					      MAC	en_passant
     14  5c00					      SUBROUTINE
     15  5c00							; {1} = _LEFT or _RIGHT
     16  5c00
     17  5c00					      ldx	currentSquare
     18  5c00					      ldy	ValidSquare+{1},x
     19  5c00					      cpy	enPassantPawn
     20  5c00					      bne	.invalid
     21  5c00					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  5c00					      lda	Board,y
     23  5c00					      bne	.invalid
     24  5c00					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  5c00				   .invalid
     26  5c00					      ENDM
     27  5c00
     28  5c00							;---------------------------------------------------------------------------------------------------
     29  5c00
     30  5c00					      MAC	promote_pawn
     31  5c00							;SUBROUTINE
     32  5c00
     33  5c00							;{1} = BLACK or WHITE
     34  5c00
     35  5c00
     36  5c00					      sty	__temp
     37  5c00					      lda	#{1}|QUEEN
     38  5c00					      sta	currentPiece
     39  5c00					      jsr	AddMove
     40  5c00
     41  5c00					      lda	#{1}|ROOK
     42  5c00					      sta	currentPiece
     43  5c00					      ldy	__temp
     44  5c00					      jsr	AddMove
     45  5c00
     46  5c00					      lda	#{1}|BISHOP
     47  5c00					      sta	currentPiece
     48  5c00					      ldy	__temp
     49  5c00					      jsr	AddMove
     50  5c00
     51  5c00					      lda	#{1}|KNIGHT
     52  5c00					      sta	currentPiece
     53  5c00					      ldy	__temp
     54  5c00					      jsr	AddMove
     55  5c00
     56  5c00					      IF	{1} = WHITE
     57  5c00					      lda	#WHITE|WP
     58  5c00					      ENDIF
     59  5c00					      IF	{1} = BLACK
     60  5c00					      lda	#BLACK|BP
     61  5c00					      ENDIF
     62  5c00					      sta	currentPiece
     63  5c00					      ENDM
     64  5c00
     65  5c00							;---------------------------------------------------------------------------------------------------
     66  5c00
     67  5c00					      MAC	move_or_promote_pawn
     68  5c00							;SUBROUTINE
     69  5c00							; {1} = BLACK or WHITE
     70  5c00
     71  5c00					      IF	{1} = WHITE
     72  5c00					      cpy	#90	; last rank?
     73  5c00					      bcc	.standard
     74  5c00					      jsr	PromoteWhitePawn
     75  5c00					      jmp	.pMoved
     76  5c00					      ENDIF
     77  5c00
     78  5c00					      IF	{1} = BLACK
     79  5c00					      cpy	#30	; last rank?
     80  5c00					      bcs	.standard
     81  5c00					      jsr	PromoteBlackPawn
     82  5c00					      jmp	.pMoved
     83  5c00					      ENDIF
     84  5c00
     85  5c00				   .standard  jsr	AddMove	; add +1UP move
     86  5c00				   .pMoved
     87  5c00
     88  5c00					      ENDM
     89  5c00
     90  5c00							;---------------------------------------------------------------------------------------------------
     91  5c00
     92  5c00					      MAC	take
     93  5c00							;SUBROUTINE
     94  5c00							; {1} = capture square offset
     95  5c00
     96  5c00					      ldx	currentSquare
     97  5c00					      ldy	ValidSquare+{1},x
     98  5c00					      bmi	.invalid2
     99  5c00					      lda	Board,y
    100  5c00					      beq	.invalid2	; square empty
    101  5c00					      sta	capture
    102  5c00					      eor	currentPiece
    103  5c00					      bpl	.invalid	; same colour
    104  5c00
    105  5c00					      MOVE_OR_PROMOTE_PAWN	{2}
    106  5c00
    107  5c00					      jmp	.invalid2
    108  5c00				   .invalid   inc	protecting
    109  5c00				   .invalid2
    110  5c00					      ENDM
    111  5c00
    112  5c00							;---------------------------------------------------------------------------------------------------
    113  5c00
      0  5c00					      DEF	PromoteWhitePawn
      1  5c00				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  5c00				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  5c00				   PromoteWhitePawn
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	PromoteWhitePawn
    115  5c00					      SUBROUTINE
    116  5c00
      0  5c00					      REFER	Handle_WHITE_PAWN
      1  5c00					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  5c00				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  5c00					      ENDIF
      0  5c00					      VAR	__temp, 1
      1  5c00		       00 b5	   __temp     =	TEMPORARY_VAR
      2  5c00				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5c00
      4  5c00				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5c00				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5c00				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5c00					      ENDIF
      8  5c00				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5c00				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  5c00				  -	      ERR
     11  5c00					      ENDIF
     12  5c00					      LIST	ON
      0  5c00					      VEND	PromoteWhitePawn
      1  5c00				  -	      IFNCONST	PromoteWhitePawn
      2  5c00				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  5c00				  -	      ERR
      4  5c00					      ENDIF
      5  5c00		       00 b6	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  5c00
      0  5c00					      PROMOTE_PAWN	WHITE
      1  5c00
      2  5c00
      3  5c00
      4  5c00
      5  5c00
      6  5c00		       84 b5		      sty	__temp
      7  5c02		       a9 06		      lda	#WHITE|QUEEN
      8  5c04		       85 91		      sta	currentPiece
      9  5c06		       20 67 f2 	      jsr	AddMove
     10  5c09
     11  5c09		       a9 05		      lda	#WHITE|ROOK
     12  5c0b		       85 91		      sta	currentPiece
     13  5c0d		       a4 b5		      ldy	__temp
     14  5c0f		       20 67 f2 	      jsr	AddMove
     15  5c12
     16  5c12		       a9 04		      lda	#WHITE|BISHOP
     17  5c14		       85 91		      sta	currentPiece
     18  5c16		       a4 b5		      ldy	__temp
     19  5c18		       20 67 f2 	      jsr	AddMove
     20  5c1b
     21  5c1b		       a9 03		      lda	#WHITE|KNIGHT
     22  5c1d		       85 91		      sta	currentPiece
     23  5c1f		       a4 b5		      ldy	__temp
     24  5c21		       20 67 f2 	      jsr	AddMove
     25  5c24
     26  5c24					      IF	WHITE = WHITE
     27  5c24		       a9 01		      lda	#WHITE|WP
     28  5c26					      ENDIF
     29  5c26				  -	      IF	WHITE = BLACK
     30  5c26				  -	      lda	#BLACK|BP
     31  5c26					      ENDIF
     32  5c26		       85 91		      sta	currentPiece
    122  5c28		       60		      rts
    123  5c29
    124  5c29							;---------------------------------------------------------------------------------------------------
    125  5c29
      0  5c29					      DEF	Handle_WHITE_PAWN
      1  5c29				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  5c29				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  5c29				   Handle_WHITE_PAWN
      4  5c29				   TEMPORARY_VAR SET	Overlay
      5  5c29				   TEMPORARY_OFFSET SET	0
      6  5c29				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  5c29				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  5c29					      SUBROUTINE
    128  5c29
      0  5c29					      REFER	GenerateAllMoves
      1  5c29					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5c29				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5c29					      ENDIF
      0  5c29					      VEND	Handle_WHITE_PAWN
      1  5c29				  -	      IFNCONST	Handle_WHITE_PAWN
      2  5c29				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  5c29				  -	      ERR
      4  5c29					      ENDIF
      5  5c29		       00 b5	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  5c29
    132  5c29		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  5c2c		       b9 79 fc 	      lda	Board,y
    134  5c2f		       d0 26		      bne	.pMoved	; occupied
    135  5c31		       85 9d		      sta	capture
    136  5c33
    137  5c33							; we may need to promote the pawn
    138  5c33							; All possibilites (Q/R/B/N) are added as individual moves
    139  5c33
      0  5c33					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  5c33
      2  5c33
      3  5c33
      4  5c33					      IF	WHITE = WHITE
      5  5c33		       c0 5a		      cpy	#90
      6  5c35		       90 06		      bcc	.standard
      7  5c37		       20 00 f4 	      jsr	PromoteWhitePawn
      8  5c3a		       4c 40 f4 	      jmp	.pMoved
      9  5c3d					      ENDIF
     10  5c3d
     11  5c3d				  -	      IF	WHITE = BLACK
     12  5c3d				  -	      cpy	#30
     13  5c3d				  -	      bcs	.standard
     14  5c3d				  -	      jsr	PromoteBlackPawn
     15  5c3d				  -	      jmp	.pMoved
     16  5c3d					      ENDIF
     17  5c3d
     18  5c3d		       20 67 f2    .standard  jsr	AddMove
     19  5c40				   .pMoved
     20  5c40
    141  5c40
    142  5c40							; the +2 move off the home rank...
    143  5c40
    144  5c40		       a6 92		      ldx	currentSquare
    145  5c42		       e0 28		      cpx	#WHITE_HOME_ROW
    146  5c44		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  5c46		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  5c49		       b9 79 fc 	      lda	Board,y
    149  5c4c		       d0 09		      bne	.pMoved	; destination square occupied
    150  5c4e
    151  5c4e		       a5 91		      lda	currentPiece
    152  5c50		       09 20		      ora	#FLAG_ENPASSANT
    153  5c52		       85 91		      sta	currentPiece	; GENERATE en-passant opportunity
    154  5c54
    155  5c54		       20 67 f2 	      jsr	AddMove	; add the +2UP move off home row
    156  5c57
    157  5c57				   .pMoved
    158  5c57
    159  5c57							; regular captures...
    160  5c57
      0  5c57					      TAKE	_UP+_LEFT, WHITE
      1  5c57
      2  5c57
      3  5c57
      4  5c57		       a6 92		      ldx	currentSquare
      5  5c59		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  5c5c		       30 1d		      bmi	.invalid2
      7  5c5e		       b9 79 fc 	      lda	Board,y
      8  5c61		       f0 18		      beq	.invalid2
      9  5c63		       85 9d		      sta	capture
     10  5c65		       45 91		      eor	currentPiece
     11  5c67		       10 10		      bpl	.invalid
     12  5c69
      0  5c69					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  5c69
      2  5c69
      3  5c69
      4  5c69					      IF	WHITE = WHITE
      5  5c69		       c0 5a		      cpy	#90
      6  5c6b		       90 06		      bcc	.standard
      7  5c6d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  5c70		       4c 76 f4 	      jmp	.pMoved
      9  5c73					      ENDIF
     10  5c73
     11  5c73				  -	      IF	WHITE = BLACK
     12  5c73				  -	      cpy	#30
     13  5c73				  -	      bcs	.standard
     14  5c73				  -	      jsr	PromoteBlackPawn
     15  5c73				  -	      jmp	.pMoved
     16  5c73					      ENDIF
     17  5c73
     18  5c73		       20 67 f2    .standard  jsr	AddMove
     19  5c76				   .pMoved
     20  5c76
     14  5c76
     15  5c76		       4c 7b f4 	      jmp	.invalid2
     16  5c79		       e6 a2	   .invalid   inc	protecting
     17  5c7b				   .invalid2
      0  5c7b					      TAKE	_UP+_RIGHT, WHITE
      1  5c7b
      2  5c7b
      3  5c7b
      4  5c7b		       a6 92		      ldx	currentSquare
      5  5c7d		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  5c80		       30 1d		      bmi	.invalid2
      7  5c82		       b9 79 fc 	      lda	Board,y
      8  5c85		       f0 18		      beq	.invalid2
      9  5c87		       85 9d		      sta	capture
     10  5c89		       45 91		      eor	currentPiece
     11  5c8b		       10 10		      bpl	.invalid
     12  5c8d
      0  5c8d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  5c8d
      2  5c8d
      3  5c8d
      4  5c8d					      IF	WHITE = WHITE
      5  5c8d		       c0 5a		      cpy	#90
      6  5c8f		       90 06		      bcc	.standard
      7  5c91		       20 00 f4 	      jsr	PromoteWhitePawn
      8  5c94		       4c 9a f4 	      jmp	.pMoved
      9  5c97					      ENDIF
     10  5c97
     11  5c97				  -	      IF	WHITE = BLACK
     12  5c97				  -	      cpy	#30
     13  5c97				  -	      bcs	.standard
     14  5c97				  -	      jsr	PromoteBlackPawn
     15  5c97				  -	      jmp	.pMoved
     16  5c97					      ENDIF
     17  5c97
     18  5c97		       20 67 f2    .standard  jsr	AddMove
     19  5c9a				   .pMoved
     20  5c9a
     14  5c9a
     15  5c9a		       4c 9f f4 	      jmp	.invalid2
     16  5c9d		       e6 a2	   .invalid   inc	protecting
     17  5c9f				   .invalid2
    163  5c9f
    164  5c9f
    165  5c9f				  -	      IF	ENPASSANT_ENABLED
    166  5c9f				  -			; en-passant captures...
    167  5c9f				  -
    168  5c9f				  -	      lda	enPassantPawn
    169  5c9f				  -	      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  5c9f				  -
    171  5c9f				  -	      lda	currentPiece
    172  5c9f				  -	      ora	#FLAG_ENPASSANT
    173  5c9f				  -	      sta	currentPiece	; CONSUME en-passant opportunity
    174  5c9f				  -
    175  5c9f				  -	      EN_PASSANT	_LEFT, _UP
    176  5c9f				  -	      EN_PASSANT	_RIGHT, _UP
    177  5c9f				  -
    178  5c9f				  -.noEnPassant
    179  5c9f					      ENDIF
    180  5c9f
    181  5c9f		       4c c8 f1 	      jmp	MoveReturn
    182  5ca2
    183  5ca2
    184  5ca2							;---------------------------------------------------------------------------------------------------
    185  5ca2							; BLACK PAWN
    186  5ca2							;---------------------------------------------------------------------------------------------------
    187  5ca2
      0  5ca2					      DEF	PromoteBlackPawn
      1  5ca2				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  5ca2				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  5ca2				   PromoteBlackPawn
      4  5ca2				   TEMPORARY_VAR SET	Overlay
      5  5ca2				   TEMPORARY_OFFSET SET	0
      6  5ca2				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  5ca2				   FUNCTION_NAME SET	PromoteBlackPawn
    189  5ca2					      SUBROUTINE
    190  5ca2
      0  5ca2					      REFER	Handle_BLACK_PAWN
      1  5ca2					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  5ca2				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  5ca2					      ENDIF
      0  5ca2					      VAR	__temp, 1
      1  5ca2		       00 b5	   __temp     =	TEMPORARY_VAR
      2  5ca2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5ca2
      4  5ca2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5ca2				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5ca2				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5ca2					      ENDIF
      8  5ca2				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5ca2				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  5ca2				  -	      ERR
     11  5ca2					      ENDIF
     12  5ca2					      LIST	ON
      0  5ca2					      VEND	PromoteBlackPawn
      1  5ca2				  -	      IFNCONST	PromoteBlackPawn
      2  5ca2				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  5ca2				  -	      ERR
      4  5ca2					      ENDIF
      5  5ca2		       00 b6	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  5ca2
      0  5ca2					      PROMOTE_PAWN	BLACK
      1  5ca2
      2  5ca2
      3  5ca2
      4  5ca2
      5  5ca2
      6  5ca2		       84 b5		      sty	__temp
      7  5ca4		       a9 86		      lda	#BLACK|QUEEN
      8  5ca6		       85 91		      sta	currentPiece
      9  5ca8		       20 67 f2 	      jsr	AddMove
     10  5cab
     11  5cab		       a9 85		      lda	#BLACK|ROOK
     12  5cad		       85 91		      sta	currentPiece
     13  5caf		       a4 b5		      ldy	__temp
     14  5cb1		       20 67 f2 	      jsr	AddMove
     15  5cb4
     16  5cb4		       a9 84		      lda	#BLACK|BISHOP
     17  5cb6		       85 91		      sta	currentPiece
     18  5cb8		       a4 b5		      ldy	__temp
     19  5cba		       20 67 f2 	      jsr	AddMove
     20  5cbd
     21  5cbd		       a9 83		      lda	#BLACK|KNIGHT
     22  5cbf		       85 91		      sta	currentPiece
     23  5cc1		       a4 b5		      ldy	__temp
     24  5cc3		       20 67 f2 	      jsr	AddMove
     25  5cc6
     26  5cc6				  -	      IF	BLACK = WHITE
     27  5cc6				  -	      lda	#WHITE|WP
     28  5cc6					      ENDIF
     29  5cc6					      IF	BLACK = BLACK
     30  5cc6		       a9 82		      lda	#BLACK|BP
     31  5cc8					      ENDIF
     32  5cc8		       85 91		      sta	currentPiece
    196  5cca		       60		      rts
    197  5ccb
      0  5ccb					      DEF	Handle_BLACK_PAWN
      1  5ccb				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  5ccb				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  5ccb				   Handle_BLACK_PAWN
      4  5ccb				   TEMPORARY_VAR SET	Overlay
      5  5ccb				   TEMPORARY_OFFSET SET	0
      6  5ccb				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  5ccb				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  5ccb					      SUBROUTINE
    200  5ccb
      0  5ccb					      REFER	GenerateAllMoves
      1  5ccb					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5ccb				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5ccb					      ENDIF
      0  5ccb					      VEND	Handle_BLACK_PAWN
      1  5ccb				  -	      IFNCONST	Handle_BLACK_PAWN
      2  5ccb				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  5ccb				  -	      ERR
      4  5ccb					      ENDIF
      5  5ccb		       00 b5	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  5ccb
    204  5ccb		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  5cce		       b9 79 fc 	      lda	Board,y
    206  5cd1		       d0 26		      bne	.pMoved	; occupied
    207  5cd3		       85 9d		      sta	capture
    208  5cd5
    209  5cd5							; we may need to promote the pawn
    210  5cd5							; All possibilites (Q/R/B/N) are added as individual moves
    211  5cd5
      0  5cd5					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  5cd5
      2  5cd5
      3  5cd5
      4  5cd5				  -	      IF	BLACK = WHITE
      5  5cd5				  -	      cpy	#90
      6  5cd5				  -	      bcc	.standard
      7  5cd5				  -	      jsr	PromoteWhitePawn
      8  5cd5				  -	      jmp	.pMoved
      9  5cd5					      ENDIF
     10  5cd5
     11  5cd5					      IF	BLACK = BLACK
     12  5cd5		       c0 1e		      cpy	#30
     13  5cd7		       b0 06		      bcs	.standard
     14  5cd9		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  5cdc		       4c e2 f4 	      jmp	.pMoved
     16  5cdf					      ENDIF
     17  5cdf
     18  5cdf		       20 67 f2    .standard  jsr	AddMove
     19  5ce2				   .pMoved
     20  5ce2
    213  5ce2
    214  5ce2							; the +2 move off the home rank...
    215  5ce2
    216  5ce2		       a6 92		      ldx	currentSquare
    217  5ce4		       e0 52		      cpx	#BLACK_HOME_ROW
    218  5ce6		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  5ce8
    220  5ce8
    221  5ce8		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  5ceb		       b9 79 fc 	      lda	Board,y
    223  5cee		       d0 09		      bne	.pMoved	; destination square occupied
    224  5cf0
    225  5cf0		       a5 91		      lda	currentPiece
    226  5cf2		       09 20		      ora	#FLAG_ENPASSANT
    227  5cf4		       85 91		      sta	currentPiece	; CAN en-passant
    228  5cf6
    229  5cf6		       20 67 f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  5cf9
    231  5cf9				   .pMoved
    232  5cf9
    233  5cf9							; regular captures... (with promotion)
    234  5cf9
      0  5cf9					      TAKE	_DOWN+_LEFT, BLACK
      1  5cf9
      2  5cf9
      3  5cf9
      4  5cf9		       a6 92		      ldx	currentSquare
      5  5cfb		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  5cfe		       30 1d		      bmi	.invalid2
      7  5d00		       b9 79 fc 	      lda	Board,y
      8  5d03		       f0 18		      beq	.invalid2
      9  5d05		       85 9d		      sta	capture
     10  5d07		       45 91		      eor	currentPiece
     11  5d09		       10 10		      bpl	.invalid
     12  5d0b
      0  5d0b					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  5d0b
      2  5d0b
      3  5d0b
      4  5d0b				  -	      IF	BLACK = WHITE
      5  5d0b				  -	      cpy	#90
      6  5d0b				  -	      bcc	.standard
      7  5d0b				  -	      jsr	PromoteWhitePawn
      8  5d0b				  -	      jmp	.pMoved
      9  5d0b					      ENDIF
     10  5d0b
     11  5d0b					      IF	BLACK = BLACK
     12  5d0b		       c0 1e		      cpy	#30
     13  5d0d		       b0 06		      bcs	.standard
     14  5d0f		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  5d12		       4c 18 f5 	      jmp	.pMoved
     16  5d15					      ENDIF
     17  5d15
     18  5d15		       20 67 f2    .standard  jsr	AddMove
     19  5d18				   .pMoved
     20  5d18
     14  5d18
     15  5d18		       4c 1d f5 	      jmp	.invalid2
     16  5d1b		       e6 a2	   .invalid   inc	protecting
     17  5d1d				   .invalid2
      0  5d1d					      TAKE	_DOWN+_RIGHT, BLACK
      1  5d1d
      2  5d1d
      3  5d1d
      4  5d1d		       a6 92		      ldx	currentSquare
      5  5d1f		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  5d22		       30 1d		      bmi	.invalid2
      7  5d24		       b9 79 fc 	      lda	Board,y
      8  5d27		       f0 18		      beq	.invalid2
      9  5d29		       85 9d		      sta	capture
     10  5d2b		       45 91		      eor	currentPiece
     11  5d2d		       10 10		      bpl	.invalid
     12  5d2f
      0  5d2f					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  5d2f
      2  5d2f
      3  5d2f
      4  5d2f				  -	      IF	BLACK = WHITE
      5  5d2f				  -	      cpy	#90
      6  5d2f				  -	      bcc	.standard
      7  5d2f				  -	      jsr	PromoteWhitePawn
      8  5d2f				  -	      jmp	.pMoved
      9  5d2f					      ENDIF
     10  5d2f
     11  5d2f					      IF	BLACK = BLACK
     12  5d2f		       c0 1e		      cpy	#30
     13  5d31		       b0 06		      bcs	.standard
     14  5d33		       20 a2 f4 	      jsr	PromoteBlackPawn
     15  5d36		       4c 3c f5 	      jmp	.pMoved
     16  5d39					      ENDIF
     17  5d39
     18  5d39		       20 67 f2    .standard  jsr	AddMove
     19  5d3c				   .pMoved
     20  5d3c
     14  5d3c
     15  5d3c		       4c 41 f5 	      jmp	.invalid2
     16  5d3f		       e6 a2	   .invalid   inc	protecting
     17  5d41				   .invalid2
    237  5d41
    238  5d41
    239  5d41				  -	      IF	ENPASSANT_ENABLED
    240  5d41				  -			; en-passant captures...
    241  5d41				  -
    242  5d41				  -	      lda	enPassantPawn
    243  5d41				  -	      beq	.noEnPassant	; was last move en-passantable?
    244  5d41				  -
    245  5d41				  -	      lda	currentPiece
    246  5d41				  -	      ora	#FLAG_ENPASSANT
    247  5d41				  -	      sta	currentPiece	; any en-passant move added will have flag set
    248  5d41				  -
    249  5d41				  -	      EN_PASSANT	_LEFT, _DOWN
    250  5d41				  -	      EN_PASSANT	_RIGHT, _DOWN
    251  5d41				  -
    252  5d41				  -.noEnPassant
    253  5d41					      ENDIF
    254  5d41
    255  5d41		       4c c8 f1 	      jmp	MoveReturn
    256  5d44
    257  5d44							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  5d44					      include	"PIECE_KNIGHT.asm"
      1  5d44							; Copyright (C)2020 Andrew Davie
      2  5d44							; Knight move handler
      3  5d44
      4  5d44							;---------------------------------------------------------------------------------------------------
      5  5d44							; KNIGHT
      6  5d44							;---------------------------------------------------------------------------------------------------
      7  5d44
      0  5d44					      DEF	Handle_KNIGHT
      1  5d44				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  5d44				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  5d44				   Handle_KNIGHT
      4  5d44				   TEMPORARY_VAR SET	Overlay
      5  5d44				   TEMPORARY_OFFSET SET	0
      6  5d44				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  5d44				   FUNCTION_NAME SET	Handle_KNIGHT
      9  5d44					      SUBROUTINE
     10  5d44
      0  5d44					      REFER	GenerateAllMoves
      1  5d44					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5d44				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5d44					      ENDIF
      0  5d44					      VEND	Handle_KNIGHT
      1  5d44				  -	      IFNCONST	Handle_KNIGHT
      2  5d44				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  5d44				  -	      ERR
      4  5d44					      ENDIF
      5  5d44		       00 b5	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  5d44
     14  5d44							; x = currentSquare (square the piece is on)
     15  5d44							; currentPiece (with flags/colour attached)
     16  5d44
      0  5d44					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  5d44					      SUBROUTINE
      2  5d44		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  5d47		       30 0e		      bmi	.invalid
      4  5d49		       b9 79 fc 	      lda	Board,y
      5  5d4c		       85 9d		      sta	capture
      6  5d4e		       f0 04		      beq	.squareEmpty
      7  5d50		       45 91		      eor	currentPiece
      8  5d52		       10 03		      bpl	.invalid
      9  5d54		       20 67 f2    .squareEmpty jsr	AddMove
     10  5d57				   .invalid
      0  5d57					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  5d57		       a6 92		      ldx	currentSquare
      0  5d59					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  5d59					      SUBROUTINE
      2  5d59		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  5d5c		       30 0e		      bmi	.invalid
      4  5d5e		       b9 79 fc 	      lda	Board,y
      5  5d61		       85 9d		      sta	capture
      6  5d63		       f0 04		      beq	.squareEmpty
      7  5d65		       45 91		      eor	currentPiece
      8  5d67		       10 03		      bpl	.invalid
      9  5d69		       20 67 f2    .squareEmpty jsr	AddMove
     10  5d6c				   .invalid
      0  5d6c					      MOVE_TO_X	_UP+_UP+_LEFT
      1  5d6c		       a6 92		      ldx	currentSquare
      0  5d6e					      MOVE_TO	_UP+_UP+_LEFT
      1  5d6e					      SUBROUTINE
      2  5d6e		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  5d71		       30 0e		      bmi	.invalid
      4  5d73		       b9 79 fc 	      lda	Board,y
      5  5d76		       85 9d		      sta	capture
      6  5d78		       f0 04		      beq	.squareEmpty
      7  5d7a		       45 91		      eor	currentPiece
      8  5d7c		       10 03		      bpl	.invalid
      9  5d7e		       20 67 f2    .squareEmpty jsr	AddMove
     10  5d81				   .invalid
      0  5d81					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  5d81		       a6 92		      ldx	currentSquare
      0  5d83					      MOVE_TO	_UP+_UP+_RIGHT
      1  5d83					      SUBROUTINE
      2  5d83		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  5d86		       30 0e		      bmi	.invalid
      4  5d88		       b9 79 fc 	      lda	Board,y
      5  5d8b		       85 9d		      sta	capture
      6  5d8d		       f0 04		      beq	.squareEmpty
      7  5d8f		       45 91		      eor	currentPiece
      8  5d91		       10 03		      bpl	.invalid
      9  5d93		       20 67 f2    .squareEmpty jsr	AddMove
     10  5d96				   .invalid
     21  5d96
      0  5d96					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  5d96		       a6 92		      ldx	currentSquare
      0  5d98					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  5d98					      SUBROUTINE
      2  5d98		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  5d9b		       30 0e		      bmi	.invalid
      4  5d9d		       b9 79 fc 	      lda	Board,y
      5  5da0		       85 9d		      sta	capture
      6  5da2		       f0 04		      beq	.squareEmpty
      7  5da4		       45 91		      eor	currentPiece
      8  5da6		       10 03		      bpl	.invalid
      9  5da8		       20 67 f2    .squareEmpty jsr	AddMove
     10  5dab				   .invalid
      0  5dab					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  5dab		       a6 92		      ldx	currentSquare
      0  5dad					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  5dad					      SUBROUTINE
      2  5dad		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  5db0		       30 0e		      bmi	.invalid
      4  5db2		       b9 79 fc 	      lda	Board,y
      5  5db5		       85 9d		      sta	capture
      6  5db7		       f0 04		      beq	.squareEmpty
      7  5db9		       45 91		      eor	currentPiece
      8  5dbb		       10 03		      bpl	.invalid
      9  5dbd		       20 67 f2    .squareEmpty jsr	AddMove
     10  5dc0				   .invalid
      0  5dc0					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  5dc0		       a6 92		      ldx	currentSquare
      0  5dc2					      MOVE_TO	_UP+_LEFT+_LEFT
      1  5dc2					      SUBROUTINE
      2  5dc2		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  5dc5		       30 0e		      bmi	.invalid
      4  5dc7		       b9 79 fc 	      lda	Board,y
      5  5dca		       85 9d		      sta	capture
      6  5dcc		       f0 04		      beq	.squareEmpty
      7  5dce		       45 91		      eor	currentPiece
      8  5dd0		       10 03		      bpl	.invalid
      9  5dd2		       20 67 f2    .squareEmpty jsr	AddMove
     10  5dd5				   .invalid
      0  5dd5					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  5dd5		       a6 92		      ldx	currentSquare
      0  5dd7					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  5dd7					      SUBROUTINE
      2  5dd7		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  5dda		       30 0e		      bmi	.invalid
      4  5ddc		       b9 79 fc 	      lda	Board,y
      5  5ddf		       85 9d		      sta	capture
      6  5de1		       f0 04		      beq	.squareEmpty
      7  5de3		       45 91		      eor	currentPiece
      8  5de5		       10 03		      bpl	.invalid
      9  5de7		       20 67 f2    .squareEmpty jsr	AddMove
     10  5dea				   .invalid
     26  5dea
     27  5dea		       4c c8 f1 	      jmp	MoveReturn
     28  5ded
     29  5ded							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  5ded					      include	"PIECE_BISHOP.asm"
      1  5ded							; Copyright (C)2020 Andrew Davie
      2  5ded
      3  5ded							;---------------------------------------------------------------------------------------------------
      4  5ded							; BISHOP
      5  5ded							;---------------------------------------------------------------------------------------------------
      6  5ded
      0  5ded					      DEF	Handle_BISHOP
      1  5ded				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  5ded				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  5ded				   Handle_BISHOP
      4  5ded				   TEMPORARY_VAR SET	Overlay
      5  5ded				   TEMPORARY_OFFSET SET	0
      6  5ded				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  5ded				   FUNCTION_NAME SET	Handle_BISHOP
      8  5ded					      SUBROUTINE
      9  5ded
      0  5ded					      REFER	GenerateAllMoves
      1  5ded					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  5ded				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  5ded					      ENDIF
      0  5ded					      VEND	Handle_BISHOP
      1  5ded				  -	      IFNCONST	Handle_BISHOP
      2  5ded				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  5ded				  -	      ERR
      4  5ded					      ENDIF
      5  5ded		       00 b5	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  5ded
     13  5ded							; x = currentSquare (square the piece is on)
     14  5ded							; currentPiece (with flags/colour attached)
     15  5ded
      0  5ded					      MOVE_TOWARDS	_DOWN+_LEFT
      1  5ded					      SUBROUTINE
      2  5ded
      3  5ded
      4  5ded
      5  5ded		       a9 00		      lda	#0
      6  5def		       85 9d		      sta	capture
      7  5df1
      8  5df1		       a6 92		      ldx	currentSquare
      9  5df3		       d0 03		      bne	.project
     10  5df5
     11  5df5		       20 67 f2    .empty     jsr	AddMove
     12  5df8		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  5dfb		       30 0e		      bmi	.invalid
     14  5dfd		       b9 79 fc 	      lda	Board,y
     15  5e00		       f0 f3		      beq	.empty
     16  5e02		       85 9d		      sta	capture
     17  5e04		       45 91		      eor	currentPiece
     18  5e06		       10 03		      bpl	.invalid
     19  5e08		       20 67 f2 	      jsr	AddMove
     20  5e0b
     21  5e0b				   .invalid
      0  5e0b					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  5e0b					      SUBROUTINE
      2  5e0b
      3  5e0b
      4  5e0b
      5  5e0b		       a9 00		      lda	#0
      6  5e0d		       85 9d		      sta	capture
      7  5e0f
      8  5e0f		       a6 92		      ldx	currentSquare
      9  5e11		       d0 03		      bne	.project
     10  5e13
     11  5e13		       20 67 f2    .empty     jsr	AddMove
     12  5e16		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  5e19		       30 0e		      bmi	.invalid
     14  5e1b		       b9 79 fc 	      lda	Board,y
     15  5e1e		       f0 f3		      beq	.empty
     16  5e20		       85 9d		      sta	capture
     17  5e22		       45 91		      eor	currentPiece
     18  5e24		       10 03		      bpl	.invalid
     19  5e26		       20 67 f2 	      jsr	AddMove
     20  5e29
     21  5e29				   .invalid
      0  5e29					      MOVE_TOWARDS	_UP+_LEFT
      1  5e29					      SUBROUTINE
      2  5e29
      3  5e29
      4  5e29
      5  5e29		       a9 00		      lda	#0
      6  5e2b		       85 9d		      sta	capture
      7  5e2d
      8  5e2d		       a6 92		      ldx	currentSquare
      9  5e2f		       d0 03		      bne	.project
     10  5e31
     11  5e31		       20 67 f2    .empty     jsr	AddMove
     12  5e34		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  5e37		       30 0e		      bmi	.invalid
     14  5e39		       b9 79 fc 	      lda	Board,y
     15  5e3c		       f0 f3		      beq	.empty
     16  5e3e		       85 9d		      sta	capture
     17  5e40		       45 91		      eor	currentPiece
     18  5e42		       10 03		      bpl	.invalid
     19  5e44		       20 67 f2 	      jsr	AddMove
     20  5e47
     21  5e47				   .invalid
      0  5e47					      MOVE_TOWARDS	_UP+_RIGHT
      1  5e47					      SUBROUTINE
      2  5e47
      3  5e47
      4  5e47
      5  5e47		       a9 00		      lda	#0
      6  5e49		       85 9d		      sta	capture
      7  5e4b
      8  5e4b		       a6 92		      ldx	currentSquare
      9  5e4d		       d0 03		      bne	.project
     10  5e4f
     11  5e4f		       20 67 f2    .empty     jsr	AddMove
     12  5e52		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  5e55		       30 0e		      bmi	.invalid
     14  5e57		       b9 79 fc 	      lda	Board,y
     15  5e5a		       f0 f3		      beq	.empty
     16  5e5c		       85 9d		      sta	capture
     17  5e5e		       45 91		      eor	currentPiece
     18  5e60		       10 03		      bpl	.invalid
     19  5e62		       20 67 f2 	      jsr	AddMove
     20  5e65
     21  5e65				   .invalid
     20  5e65
     21  5e65		       4c c8 f1 	      jmp	MoveReturn
     22  5e68
     23  5e68							;---------------------------------------------------------------------------------------------------
     24  5e68							; EOF
------- FILE PIECE_HANDLER@1#1.asm
      7  5e68
      8  5e68							;---------------------------------------------------------------------------------------------------
      9  5e68
      0  5e68					      CHECK_BANK_SIZE	"PIECE_HANDLER_1"
      1  5e68		       02 68	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_1 (1K) SIZE =  $268 , FREE= $198
      2  5e68					      ECHO	"PIECE_HANDLER_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5e68				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5e68				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_1", " size=", * - ORIGIN
      5  5e68				  -	      ERR
      6  5e68					      ENDIF
     11  5e68
     12  5e68							;---------------------------------------------------------------------------------------------------
     13  5e68							; EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#2.asm LEVEL 2 PASS 4
      0  5e68					      include	"PIECE_HANDLER@1#2.asm"
      0  5e68					      SLOT	1
      1  5e68				  -	      IF	(1 < 0) || (1 > 3)
      2  5e68				  -	      ECHO	"Illegal bank address/segment location", 1
      3  5e68				  -	      ERR
      4  5e68					      ENDIF
      5  5e68				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  5e68				   _BANK_SLOT SET	1 * 64
      0  5e68					      NEWBANK	PIECE_HANDLER_2
      1  625c ????				      SEG	PIECE_HANDLER_2
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   PIECE_HANDLER_2_START SET	*
      6  6000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6000				   PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + 1024
      3  6000
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  6000					      include	"PIECE_ROOK.asm"
      1  6000							; Copyright (C)2020 Andrew Davie
      2  6000							; Rook move handler
      3  6000
      4  6000							;---------------------------------------------------------------------------------------------------
      5  6000							; ROOK
      6  6000							;---------------------------------------------------------------------------------------------------
      7  6000
      0  6000					      DEF	Handle_ROOK
      1  6000				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  6000				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  6000				   Handle_ROOK
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	Handle_ROOK
      9  6000					      SUBROUTINE
     10  6000
      0  6000					      REFER	GenerateAllMoves
      1  6000					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6000				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6000					      ENDIF
      0  6000					      VEND	Handle_ROOK
      1  6000				  -	      IFNCONST	Handle_ROOK
      2  6000				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  6000				  -	      ERR
      4  6000					      ENDIF
      5  6000		       00 b5	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  6000
     14  6000							; Pass...
     15  6000							; x = currentSquare (square the piece is on)
     16  6000							; currentPiece (with flags/colour attached)
     17  6000
      0  6000					      MOVE_TOWARDS	_DOWN
      1  6000					      SUBROUTINE
      2  6000
      3  6000
      4  6000
      5  6000		       a9 00		      lda	#0
      6  6002		       85 9d		      sta	capture
      7  6004
      8  6004		       a6 92		      ldx	currentSquare
      9  6006		       d0 03		      bne	.project
     10  6008
     11  6008		       20 67 f2    .empty     jsr	AddMove
     12  600b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  600e		       30 0e		      bmi	.invalid
     14  6010		       b9 79 fc 	      lda	Board,y
     15  6013		       f0 f3		      beq	.empty
     16  6015		       85 9d		      sta	capture
     17  6017		       45 91		      eor	currentPiece
     18  6019		       10 03		      bpl	.invalid
     19  601b		       20 67 f2 	      jsr	AddMove
     20  601e
     21  601e				   .invalid
      0  601e					      MOVE_TOWARDS	_RIGHT
      1  601e					      SUBROUTINE
      2  601e
      3  601e
      4  601e
      5  601e		       a9 00		      lda	#0
      6  6020		       85 9d		      sta	capture
      7  6022
      8  6022		       a6 92		      ldx	currentSquare
      9  6024		       d0 03		      bne	.project
     10  6026
     11  6026		       20 67 f2    .empty     jsr	AddMove
     12  6029		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  602c		       30 0e		      bmi	.invalid
     14  602e		       b9 79 fc 	      lda	Board,y
     15  6031		       f0 f3		      beq	.empty
     16  6033		       85 9d		      sta	capture
     17  6035		       45 91		      eor	currentPiece
     18  6037		       10 03		      bpl	.invalid
     19  6039		       20 67 f2 	      jsr	AddMove
     20  603c
     21  603c				   .invalid
      0  603c					      MOVE_TOWARDS	_UP
      1  603c					      SUBROUTINE
      2  603c
      3  603c
      4  603c
      5  603c		       a9 00		      lda	#0
      6  603e		       85 9d		      sta	capture
      7  6040
      8  6040		       a6 92		      ldx	currentSquare
      9  6042		       d0 03		      bne	.project
     10  6044
     11  6044		       20 67 f2    .empty     jsr	AddMove
     12  6047		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  604a		       30 0e		      bmi	.invalid
     14  604c		       b9 79 fc 	      lda	Board,y
     15  604f		       f0 f3		      beq	.empty
     16  6051		       85 9d		      sta	capture
     17  6053		       45 91		      eor	currentPiece
     18  6055		       10 03		      bpl	.invalid
     19  6057		       20 67 f2 	      jsr	AddMove
     20  605a
     21  605a				   .invalid
      0  605a					      MOVE_TOWARDS	_LEFT
      1  605a					      SUBROUTINE
      2  605a
      3  605a
      4  605a
      5  605a		       a9 00		      lda	#0
      6  605c		       85 9d		      sta	capture
      7  605e
      8  605e		       a6 92		      ldx	currentSquare
      9  6060		       d0 03		      bne	.project
     10  6062
     11  6062		       20 67 f2    .empty     jsr	AddMove
     12  6065		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  6068		       30 0e		      bmi	.invalid
     14  606a		       b9 79 fc 	      lda	Board,y
     15  606d		       f0 f3		      beq	.empty
     16  606f		       85 9d		      sta	capture
     17  6071		       45 91		      eor	currentPiece
     18  6073		       10 03		      bpl	.invalid
     19  6075		       20 67 f2 	      jsr	AddMove
     20  6078
     21  6078				   .invalid
     22  6078
     23  6078		       4c c8 f1 	      jmp	MoveReturn
     24  607b
     25  607b							;---------------------------------------------------------------------------------------------------
     26  607b							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  607b					      include	"PIECE_QUEEN.asm"
      1  607b							; Copyright (C)2020 Andrew Davie
      2  607b
      3  607b							;---------------------------------------------------------------------------------------------------
      4  607b							; QUEEN
      5  607b							;---------------------------------------------------------------------------------------------------
      6  607b
      0  607b					      DEF	Handle_QUEEN
      1  607b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  607b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  607b				   Handle_QUEEN
      4  607b				   TEMPORARY_VAR SET	Overlay
      5  607b				   TEMPORARY_OFFSET SET	0
      6  607b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  607b				   FUNCTION_NAME SET	Handle_QUEEN
      8  607b					      SUBROUTINE
      9  607b
      0  607b					      REFER	GenerateAllMoves
      1  607b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  607b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  607b					      ENDIF
      0  607b					      VEND	Handle_QUEEN
      1  607b				  -	      IFNCONST	Handle_QUEEN
      2  607b				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  607b				  -	      ERR
      4  607b					      ENDIF
      5  607b		       00 b5	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  607b
     13  607b							; Pass...
     14  607b							; x = currentSquare (square the piece is on)
     15  607b							; currentPiece (with flags/colour attached)
     16  607b
      0  607b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  607b					      SUBROUTINE
      2  607b
      3  607b
      4  607b
      5  607b		       a9 00		      lda	#0
      6  607d		       85 9d		      sta	capture
      7  607f
      8  607f		       a6 92		      ldx	currentSquare
      9  6081		       d0 03		      bne	.project
     10  6083
     11  6083		       20 67 f2    .empty     jsr	AddMove
     12  6086		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6089		       30 0e		      bmi	.invalid
     14  608b		       b9 79 fc 	      lda	Board,y
     15  608e		       f0 f3		      beq	.empty
     16  6090		       85 9d		      sta	capture
     17  6092		       45 91		      eor	currentPiece
     18  6094		       10 03		      bpl	.invalid
     19  6096		       20 67 f2 	      jsr	AddMove
     20  6099
     21  6099				   .invalid
      0  6099					      MOVE_TOWARDS	_DOWN
      1  6099					      SUBROUTINE
      2  6099
      3  6099
      4  6099
      5  6099		       a9 00		      lda	#0
      6  609b		       85 9d		      sta	capture
      7  609d
      8  609d		       a6 92		      ldx	currentSquare
      9  609f		       d0 03		      bne	.project
     10  60a1
     11  60a1		       20 67 f2    .empty     jsr	AddMove
     12  60a4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  60a7		       30 0e		      bmi	.invalid
     14  60a9		       b9 79 fc 	      lda	Board,y
     15  60ac		       f0 f3		      beq	.empty
     16  60ae		       85 9d		      sta	capture
     17  60b0		       45 91		      eor	currentPiece
     18  60b2		       10 03		      bpl	.invalid
     19  60b4		       20 67 f2 	      jsr	AddMove
     20  60b7
     21  60b7				   .invalid
      0  60b7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  60b7					      SUBROUTINE
      2  60b7
      3  60b7
      4  60b7
      5  60b7		       a9 00		      lda	#0
      6  60b9		       85 9d		      sta	capture
      7  60bb
      8  60bb		       a6 92		      ldx	currentSquare
      9  60bd		       d0 03		      bne	.project
     10  60bf
     11  60bf		       20 67 f2    .empty     jsr	AddMove
     12  60c2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  60c5		       30 0e		      bmi	.invalid
     14  60c7		       b9 79 fc 	      lda	Board,y
     15  60ca		       f0 f3		      beq	.empty
     16  60cc		       85 9d		      sta	capture
     17  60ce		       45 91		      eor	currentPiece
     18  60d0		       10 03		      bpl	.invalid
     19  60d2		       20 67 f2 	      jsr	AddMove
     20  60d5
     21  60d5				   .invalid
      0  60d5					      MOVE_TOWARDS	_RIGHT
      1  60d5					      SUBROUTINE
      2  60d5
      3  60d5
      4  60d5
      5  60d5		       a9 00		      lda	#0
      6  60d7		       85 9d		      sta	capture
      7  60d9
      8  60d9		       a6 92		      ldx	currentSquare
      9  60db		       d0 03		      bne	.project
     10  60dd
     11  60dd		       20 67 f2    .empty     jsr	AddMove
     12  60e0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  60e3		       30 0e		      bmi	.invalid
     14  60e5		       b9 79 fc 	      lda	Board,y
     15  60e8		       f0 f3		      beq	.empty
     16  60ea		       85 9d		      sta	capture
     17  60ec		       45 91		      eor	currentPiece
     18  60ee		       10 03		      bpl	.invalid
     19  60f0		       20 67 f2 	      jsr	AddMove
     20  60f3
     21  60f3				   .invalid
      0  60f3					      MOVE_TOWARDS	_UP+_RIGHT
      1  60f3					      SUBROUTINE
      2  60f3
      3  60f3
      4  60f3
      5  60f3		       a9 00		      lda	#0
      6  60f5		       85 9d		      sta	capture
      7  60f7
      8  60f7		       a6 92		      ldx	currentSquare
      9  60f9		       d0 03		      bne	.project
     10  60fb
     11  60fb		       20 67 f2    .empty     jsr	AddMove
     12  60fe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6101		       30 0e		      bmi	.invalid
     14  6103		       b9 79 fc 	      lda	Board,y
     15  6106		       f0 f3		      beq	.empty
     16  6108		       85 9d		      sta	capture
     17  610a		       45 91		      eor	currentPiece
     18  610c		       10 03		      bpl	.invalid
     19  610e		       20 67 f2 	      jsr	AddMove
     20  6111
     21  6111				   .invalid
      0  6111					      MOVE_TOWARDS	_UP
      1  6111					      SUBROUTINE
      2  6111
      3  6111
      4  6111
      5  6111		       a9 00		      lda	#0
      6  6113		       85 9d		      sta	capture
      7  6115
      8  6115		       a6 92		      ldx	currentSquare
      9  6117		       d0 03		      bne	.project
     10  6119
     11  6119		       20 67 f2    .empty     jsr	AddMove
     12  611c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  611f		       30 0e		      bmi	.invalid
     14  6121		       b9 79 fc 	      lda	Board,y
     15  6124		       f0 f3		      beq	.empty
     16  6126		       85 9d		      sta	capture
     17  6128		       45 91		      eor	currentPiece
     18  612a		       10 03		      bpl	.invalid
     19  612c		       20 67 f2 	      jsr	AddMove
     20  612f
     21  612f				   .invalid
      0  612f					      MOVE_TOWARDS	_UP+_LEFT
      1  612f					      SUBROUTINE
      2  612f
      3  612f
      4  612f
      5  612f		       a9 00		      lda	#0
      6  6131		       85 9d		      sta	capture
      7  6133
      8  6133		       a6 92		      ldx	currentSquare
      9  6135		       d0 03		      bne	.project
     10  6137
     11  6137		       20 67 f2    .empty     jsr	AddMove
     12  613a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  613d		       30 0e		      bmi	.invalid
     14  613f		       b9 79 fc 	      lda	Board,y
     15  6142		       f0 f3		      beq	.empty
     16  6144		       85 9d		      sta	capture
     17  6146		       45 91		      eor	currentPiece
     18  6148		       10 03		      bpl	.invalid
     19  614a		       20 67 f2 	      jsr	AddMove
     20  614d
     21  614d				   .invalid
      0  614d					      MOVE_TOWARDS	_LEFT
      1  614d					      SUBROUTINE
      2  614d
      3  614d
      4  614d
      5  614d		       a9 00		      lda	#0
      6  614f		       85 9d		      sta	capture
      7  6151
      8  6151		       a6 92		      ldx	currentSquare
      9  6153		       d0 03		      bne	.project
     10  6155
     11  6155		       20 67 f2    .empty     jsr	AddMove
     12  6158		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  615b		       30 0e		      bmi	.invalid
     14  615d		       b9 79 fc 	      lda	Board,y
     15  6160		       f0 f3		      beq	.empty
     16  6162		       85 9d		      sta	capture
     17  6164		       45 91		      eor	currentPiece
     18  6166		       10 03		      bpl	.invalid
     19  6168		       20 67 f2 	      jsr	AddMove
     20  616b
     21  616b				   .invalid
     25  616b
     26  616b		       4c c8 f1 	      jmp	MoveReturn
     27  616e
     28  616e							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  616e					      include	"PIECE_KING.asm"
      1  616e							; Copyright (C)2020 Andrew Davie
      2  616e
      3  616e							;---------------------------------------------------------------------------------------------------
      4  616e							; KING
      5  616e							; This is the move handler for a KING
      6  616e							; "Check" is detected in the next ply of the search.
      7  616e
      8  616e
      9  616e							;---------------------------------------------------------------------------------------------------
     10  616e
     11  616e							; MACRO - Castling
     12  616e
     13  616e		       00 03	   KINGSIDE   =	3
     14  616e		       ff ff ff fc QUEENSIDE  =	-4
     15  616e
     16  616e					      MAC	castle
     17  616e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  616e
     19  616e					      ldx	currentSquare
     20  616e					      lda	Board+{1},x	; kingside/queenside R position
     21  616e					      and	#PIECE_MASK|FLAG_MOVED
     22  616e					      cmp	#ROOK
     23  616e					      bne	.noCastle	; not a R that hasn't moved
     24  616e
     25  616e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  616e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  616e
     28  616e					      IF	{1} = QUEENSIDE
     29  616e					      lda	Board-3,x	; N pos
     30  616e					      ora	Board-2,x	; B pos
     31  616e					      ora	Board-1,x	; Q pos
     32  616e					      bne	.noCastle	; not vacant?
     33  616e
     34  616e					      ENDIF
     35  616e
     36  616e					      IF	{1} = KINGSIDE
     37  616e					      lda	Board+2,x	; N pos
     38  616e					      ora	Board+1,x	; B pos
     39  616e					      bne	.noCastle	; not vacant?
     40  616e					      ENDIF
     41  616e
     42  616e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  616e
     44  616e							; FINALLY -- king can castle
     45  616e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  616e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  616e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  616e
     49  616e					      lda	currentPiece
     50  616e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  616e					      sta	currentPiece
     52  616e
     53  616e					      IF	{1} = KINGSIDE
     54  616e					      ldy	ValidSquare+2,x
     55  616e					      ENDIF
     56  616e
     57  616e					      IF	{1} = QUEENSIDE
     58  616e					      ldy	ValidSquare-2,x
     59  616e					      ENDIF
     60  616e
     61  616e					      jsr	AddMove	; 57
     62  616e
     63  616e				   .noCastle
     64  616e					      ENDM
     65  616e
     66  616e
     67  616e							;---------------------------------------------------------------------------------------------------
     68  616e
      0  616e					      DEF	Handle_KING
      1  616e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  616e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  616e				   Handle_KING
      4  616e				   TEMPORARY_VAR SET	Overlay
      5  616e				   TEMPORARY_OFFSET SET	0
      6  616e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  616e				   FUNCTION_NAME SET	Handle_KING
     70  616e					      SUBROUTINE
     71  616e
      0  616e					      REFER	GenerateAllMoves
      1  616e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  616e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  616e					      ENDIF
      0  616e					      VEND	Handle_KING
      1  616e				  -	      IFNCONST	Handle_KING
      2  616e				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  616e				  -	      ERR
      4  616e					      ENDIF
      5  616e		       00 b5	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  616e
     75  616e							; x = currentSquare (square the KING is on)
     76  616e							; currentPiece (KING of course, but with flags/colour attached)
     77  616e
      0  616e					      MOVE_TO	_DOWN+_LEFT
      1  616e					      SUBROUTINE
      2  616e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  6171		       30 0e		      bmi	.invalid
      4  6173		       b9 79 fc 	      lda	Board,y
      5  6176		       85 9d		      sta	capture
      6  6178		       f0 04		      beq	.squareEmpty
      7  617a		       45 91		      eor	currentPiece
      8  617c		       10 03		      bpl	.invalid
      9  617e		       20 67 f2    .squareEmpty jsr	AddMove
     10  6181				   .invalid
      0  6181					      MOVE_TO_X	_DOWN
      1  6181		       a6 92		      ldx	currentSquare
      0  6183					      MOVE_TO	_DOWN
      1  6183					      SUBROUTINE
      2  6183		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      3  6186		       30 0e		      bmi	.invalid
      4  6188		       b9 79 fc 	      lda	Board,y
      5  618b		       85 9d		      sta	capture
      6  618d		       f0 04		      beq	.squareEmpty
      7  618f		       45 91		      eor	currentPiece
      8  6191		       10 03		      bpl	.invalid
      9  6193		       20 67 f2    .squareEmpty jsr	AddMove
     10  6196				   .invalid
      0  6196					      MOVE_TO_X	_DOWN+_RIGHT
      1  6196		       a6 92		      ldx	currentSquare
      0  6198					      MOVE_TO	_DOWN+_RIGHT
      1  6198					      SUBROUTINE
      2  6198		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  619b		       30 0e		      bmi	.invalid
      4  619d		       b9 79 fc 	      lda	Board,y
      5  61a0		       85 9d		      sta	capture
      6  61a2		       f0 04		      beq	.squareEmpty
      7  61a4		       45 91		      eor	currentPiece
      8  61a6		       10 03		      bpl	.invalid
      9  61a8		       20 67 f2    .squareEmpty jsr	AddMove
     10  61ab				   .invalid
      0  61ab					      MOVE_TO_X	_RIGHT
      1  61ab		       a6 92		      ldx	currentSquare
      0  61ad					      MOVE_TO	_RIGHT
      1  61ad					      SUBROUTINE
      2  61ad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      3  61b0		       30 0e		      bmi	.invalid
      4  61b2		       b9 79 fc 	      lda	Board,y
      5  61b5		       85 9d		      sta	capture
      6  61b7		       f0 04		      beq	.squareEmpty
      7  61b9		       45 91		      eor	currentPiece
      8  61bb		       10 03		      bpl	.invalid
      9  61bd		       20 67 f2    .squareEmpty jsr	AddMove
     10  61c0				   .invalid
      0  61c0					      MOVE_TO_X	_UP+_RIGHT
      1  61c0		       a6 92		      ldx	currentSquare
      0  61c2					      MOVE_TO	_UP+_RIGHT
      1  61c2					      SUBROUTINE
      2  61c2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  61c5		       30 0e		      bmi	.invalid
      4  61c7		       b9 79 fc 	      lda	Board,y
      5  61ca		       85 9d		      sta	capture
      6  61cc		       f0 04		      beq	.squareEmpty
      7  61ce		       45 91		      eor	currentPiece
      8  61d0		       10 03		      bpl	.invalid
      9  61d2		       20 67 f2    .squareEmpty jsr	AddMove
     10  61d5				   .invalid
      0  61d5					      MOVE_TO_X	_UP
      1  61d5		       a6 92		      ldx	currentSquare
      0  61d7					      MOVE_TO	_UP
      1  61d7					      SUBROUTINE
      2  61d7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      3  61da		       30 0e		      bmi	.invalid
      4  61dc		       b9 79 fc 	      lda	Board,y
      5  61df		       85 9d		      sta	capture
      6  61e1		       f0 04		      beq	.squareEmpty
      7  61e3		       45 91		      eor	currentPiece
      8  61e5		       10 03		      bpl	.invalid
      9  61e7		       20 67 f2    .squareEmpty jsr	AddMove
     10  61ea				   .invalid
      0  61ea					      MOVE_TO_X	_UP+_LEFT
      1  61ea		       a6 92		      ldx	currentSquare
      0  61ec					      MOVE_TO	_UP+_LEFT
      1  61ec					      SUBROUTINE
      2  61ec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      3  61ef		       30 0e		      bmi	.invalid
      4  61f1		       b9 79 fc 	      lda	Board,y
      5  61f4		       85 9d		      sta	capture
      6  61f6		       f0 04		      beq	.squareEmpty
      7  61f8		       45 91		      eor	currentPiece
      8  61fa		       10 03		      bpl	.invalid
      9  61fc		       20 67 f2    .squareEmpty jsr	AddMove
     10  61ff				   .invalid
      0  61ff					      MOVE_TO_X	_LEFT
      1  61ff		       a6 92		      ldx	currentSquare
      0  6201					      MOVE_TO	_LEFT
      1  6201					      SUBROUTINE
      2  6201		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      3  6204		       30 0e		      bmi	.invalid
      4  6206		       b9 79 fc 	      lda	Board,y
      5  6209		       85 9d		      sta	capture
      6  620b		       f0 04		      beq	.squareEmpty
      7  620d		       45 91		      eor	currentPiece
      8  620f		       10 03		      bpl	.invalid
      9  6211		       20 67 f2    .squareEmpty jsr	AddMove
     10  6214				   .invalid
     86  6214
     87  6214							;IF CASTLING_ENABLED
     88  6214
     89  6214		       24 91		      bit	currentPiece
     90  6216		       70 41		      bvs	.exit	; king has moved, so no castling
     91  6218
      0  6218					      CASTLE	KINGSIDE
      1  6218
      2  6218
      3  6218		       a6 92		      ldx	currentSquare
      4  621a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  621d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  621f		       c9 05		      cmp	#ROOK
      7  6221		       d0 14		      bne	.noCastle
      8  6223
      9  6223
     10  6223
     11  6223
     12  6223				  -	      IF	KINGSIDE = QUEENSIDE
     13  6223				  -	      lda	Board-3,x
     14  6223				  -	      ora	Board-2,x
     15  6223				  -	      ora	Board-1,x
     16  6223				  -	      bne	.noCastle
     17  6223				  -
     18  6223					      ENDIF
     19  6223
     20  6223					      IF	KINGSIDE = KINGSIDE
     21  6223		       bd 7b fc 	      lda	Board+2,x
     22  6226		       1d 7a fc 	      ora	Board+1,x
     23  6229		       d0 0c		      bne	.noCastle
     24  622b					      ENDIF
     25  622b
     26  622b
     27  622b
     28  622b
     29  622b
     30  622b
     31  622b
     32  622b
     33  622b		       a5 91		      lda	currentPiece
     34  622d		       09 10		      ora	#FLAG_CASTLE
     35  622f		       85 91		      sta	currentPiece
     36  6231
     37  6231					      IF	KINGSIDE = KINGSIDE
     38  6231		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  6234					      ENDIF
     40  6234
     41  6234				  -	      IF	KINGSIDE = QUEENSIDE
     42  6234				  -	      ldy	ValidSquare-2,x
     43  6234					      ENDIF
     44  6234
     45  6234		       20 67 f2 	      jsr	AddMove
     46  6237
     47  6237				   .noCastle
      0  6237					      CASTLE	QUEENSIDE
      1  6237
      2  6237
      3  6237		       a6 92		      ldx	currentSquare
      4  6239		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  623c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  623e		       c9 05		      cmp	#ROOK
      7  6240		       d0 17		      bne	.noCastle
      8  6242
      9  6242
     10  6242
     11  6242
     12  6242					      IF	QUEENSIDE = QUEENSIDE
     13  6242		       bd 76 fc 	      lda	Board-3,x
     14  6245		       1d 77 fc 	      ora	Board-2,x
     15  6248		       1d 78 fc 	      ora	Board-1,x
     16  624b		       d0 0c		      bne	.noCastle
     17  624d
     18  624d					      ENDIF
     19  624d
     20  624d				  -	      IF	QUEENSIDE = KINGSIDE
     21  624d				  -	      lda	Board+2,x
     22  624d				  -	      ora	Board+1,x
     23  624d				  -	      bne	.noCastle
     24  624d					      ENDIF
     25  624d
     26  624d
     27  624d
     28  624d
     29  624d
     30  624d
     31  624d
     32  624d
     33  624d		       a5 91		      lda	currentPiece
     34  624f		       09 10		      ora	#FLAG_CASTLE
     35  6251		       85 91		      sta	currentPiece
     36  6253
     37  6253				  -	      IF	QUEENSIDE = KINGSIDE
     38  6253				  -	      ldy	ValidSquare+2,x
     39  6253					      ENDIF
     40  6253
     41  6253					      IF	QUEENSIDE = QUEENSIDE
     42  6253		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  6256					      ENDIF
     44  6256
     45  6256		       20 67 f2 	      jsr	AddMove
     46  6259
     47  6259				   .noCastle
     94  6259
     95  6259							;ENDIF
     96  6259
     97  6259		       4c c8 f1    .exit      jmp	MoveReturn
     98  625c
     99  625c							;---------------------------------------------------------------------------------------------------
    100  625c							; EOF
------- FILE PIECE_HANDLER@1#2.asm
      7  625c
      8  625c							;---------------------------------------------------------------------------------------------------
      9  625c
      0  625c					      CHECK_BANK_SIZE	"PIECE_HANDLER_2"
      1  625c		       02 5c	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_2 (1K) SIZE =  $25c , FREE= $1a4
      2  625c					      ECHO	"PIECE_HANDLER_2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  625c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  625c				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_2", " size=", * - ORIGIN
      5  625c				  -	      ERR
      6  625c					      ENDIF
     11  625c
     12  625c							;---------------------------------------------------------------------------------------------------
     13  625c							; EOF
------- FILE ./chess.asm
------- FILE BANK_3.asm LEVEL 2 PASS 4
      0  625c					      include	"BANK_3.asm"
      1  625c							; Chess
      2  625c							; Copyright (c) 2019-2020 Andrew Davie
      3  625c							; andrew@taswegian.com
      4  625c
      0  625c					      SLOT	3	; this code assembles for bank #1
      1  625c				  -	      IF	(3 < 0) || (3 > 3)
      2  625c				  -	      ECHO	"Illegal bank address/segment location", 3
      3  625c				  -	      ERR
      4  625c					      ENDIF
      5  625c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  625c				   _BANK_SLOT SET	3 * 64
      0  625c					      NEWBANK	THREE
      1  645e ????				      SEG	THREE
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   THREE_START SET	*
      6  6400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6400				   THREE      SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + 1024
      7  6400
      8  6400							;---------------------------------------------------------------------------------------------------
      9  6400
      0  6400					      DEF	GetPiece
      1  6400				   SLOT_GetPiece SET	_BANK_SLOT
      2  6400				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  6400				   GetPiece
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	GetPiece
     11  6400					      SUBROUTINE
     12  6400
      0  6400					      REFER	aiSelectDestinationSquare	;✅
      1  6400				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  6400				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  6400					      ENDIF
      0  6400					      REFER	aiQuiescent	;✅
      1  6400				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  6400				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  6400					      ENDIF
      0  6400					      VEND	GetPiece
      1  6400				  -	      IFNCONST	GetPiece
      2  6400				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  6400				  -	      ERR
      4  6400					      ENDIF
      5  6400		       00 a4	   VAREND_GetPiece =	TEMPORARY_VAR
     16  6400
     17  6400							; Retrieve the piece+flags from the movelist, given from/to squares
     18  6400							; Required as moves have different flags but same origin squares (e.g., castling)
     19  6400
     20  6400		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
     21  6402							;lda currentPly
     22  6402		       85 3e		      sta	SET_BANK_RAM	;@2
     23  6404
     24  6404							; returns piece in A+fromPiece
     25  6404							; or Y=-1 if not found
     26  6404
     27  6404							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     28  6404							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     29  6404							; This fixes the move with/without castle flag
     30  6404
     31  6404
      0  6404					      ldy@PLY	moveIndex
      1  6404		       ac d0 f9 	      ldy	moveIndex
     33  6407		       30 11		      bmi	.fail	; shouldn't happen
     34  6409
     35  6409		       a5 85	   .scan      lda	fromX12
      0  640b					      cmp@PLY	MoveFrom,y
      1  640b		       d9 00 f8 	      cmp	MoveFrom,y
     37  640e		       d0 07		      bne	.next
     38  6410		       a5 86		      lda	toX12
      0  6412					      cmp@PLY	MoveTo,y
      1  6412		       d9 64 f8 	      cmp	MoveTo,y
     40  6415		       f0 04		      beq	.found
     41  6417		       88	   .next      dey
     42  6418		       10 ef		      bpl	.scan
     43  641a		       60	   .fail      rts
     44  641b
      0  641b				   .found     lda@PLY	MovePiece,y
      1  641b		       b9 00 f9 	      lda	MovePiece,y
     46  641e		       85 96		      sta	fromPiece
     47  6420
     48  6420		       60		      rts
     49  6421
     50  6421
     51  6421							;---------------------------------------------------------------------------------------------------
     52  6421
      0  6421					      DEF	GenCastleMoveForRook
      1  6421				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  6421				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  6421				   GenCastleMoveForRook
      4  6421				   TEMPORARY_VAR SET	Overlay
      5  6421				   TEMPORARY_OFFSET SET	0
      6  6421				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  6421				   FUNCTION_NAME SET	GenCastleMoveForRook
     54  6421					      SUBROUTINE
     55  6421
      0  6421					      REFER	MakeMove	;✅
      1  6421					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  6421				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  6421					      ENDIF
      0  6421					      REFER	CastleFixupDraw	;✅
      1  6421				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  6421				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  6421					      ENDIF
      0  6421					      VEND	GenCastleMoveForRook
      1  6421				  -	      IFNCONST	GenCastleMoveForRook
      2  6421				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  6421				  -	      ERR
      4  6421					      ENDIF
      5  6421		       00 b2	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
     59  6421
     60  6421		       18		      clc
     61  6422
     62  6422		       a5 96		      lda	fromPiece
     63  6424		       29 10		      and	#FLAG_CASTLE
     64  6426		       f0 2b		      beq	.exit	; NOT involved in castle!
     65  6428
     66  6428		       a2 04		      ldx	#4
     67  642a		       a5 85		      lda	fromX12	; *destination*
     68  642c		       18	   .findCast  clc
     69  642d		       ca		      dex
     70  642e		       30 23		      bmi	.exit
     71  6430		       dd 09 f6 	      cmp	KSquare,x
     72  6433		       d0 f7		      bne	.findCast
     73  6435
     74  6435		       bd 11 f6 	      lda	RSquareEnd,x
     75  6438		       85 86		      sta	toX12
      0  643a					      sta@PLY	secondaryBlank
      1  643a		       8d cf fb 	      sta	[RAM]+secondaryBlank
     77  643d		       bc 0d f6 	      ldy	RSquareStart,x
     78  6440		       84 85		      sty	fromX12
     79  6442		       84 87		      sty	originX12
      0  6444					      sty@PLY	secondarySquare
      1  6444		       8c ce fb 	      sty	[RAM]+secondarySquare
     81  6447
     82  6447		       a5 96		      lda	fromPiece
     83  6449		       29 80		      and	#128	; colour bit
     84  644b		       09 05		      ora	#ROOK	; preserve colour
     85  644d		       85 96		      sta	fromPiece
      0  644f					      sta@PLY	secondaryPiece
      1  644f		       8d cd fb 	      sta	[RAM]+secondaryPiece
     87  6452
     88  6452		       38		      sec
     89  6453		       60	   .exit      rts
     90  6454
     91  6454
     92  6454							;---------------------------------------------------------------------------------------------------
     93  6454
      0  6454					      DEF	showPromoteOptions
      1  6454				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  6454				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  6454				   showPromoteOptions
      4  6454				   TEMPORARY_VAR SET	Overlay
      5  6454				   TEMPORARY_OFFSET SET	0
      6  6454				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  6454				   FUNCTION_NAME SET	showPromoteOptions
     95  6454					      SUBROUTINE
     96  6454
      0  6454					      REFER	aiRollPromotionPiece	;✅
      1  6454				  -	      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  6454				  -TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  6454					      ENDIF
      0  6454					      REFER	aiChoosePromotePiece	;✅
      1  6454				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  6454				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  6454					      ENDIF
      0  6454					      VEND	showPromoteOptions
      1  6454				  -	      IFNCONST	showPromoteOptions
      2  6454				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  6454				  -	      ERR
      4  6454					      ENDIF
      5  6454		       00 a4	   VAREND_showPromoteOptions =	TEMPORARY_VAR
    100  6454
    101  6454							; X = character shape # (?/N/B/R/Q)
    102  6454
    103  6454		       a4 86		      ldy	toX12
    104  6456		       84 80		      sty	squareToDraw
    105  6458
    106  6458		       20 91 f5 	      jsr	CopySetupForMarker	;@1	   ; TODO: WRONG
    107  645b		       4c c9 f0 	      jmp	InterceptMarkerCopy	;@0
    108  645e
    109  645e
    110  645e							;---------------------------------------------------------------------------------------------------
    111  645e
      0  645e					      CHECK_BANK_SIZE	"BANK_3"
      1  645e		       00 5e	   .TEMP      =	* - _BANK_START
 BANK_3 (1K) SIZE =  $5e , FREE= $3a2
      2  645e					      ECHO	"BANK_3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  645e				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  645e				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_3", " size=", * - ORIGIN
      5  645e				  -	      ERR
      6  645e					      ENDIF
    113  645e
    114  645e							;---------------------------------------------------------------------------------------------------
    115  645e							; EOF
------- FILE ./chess.asm
    644  645e
------- FILE BANK_LAST.asm LEVEL 2 PASS 4
      0  645e					      include	"BANK_LAST.asm"
      1  645e							; Chess
      2  645e							; Copyright (c) 2019-2020 Andrew Davie
      3  645e							; andrew@taswegian.com
      4  645e
      0  645e					      SLOT	3
      1  645e				  -	      IF	(3 < 0) || (3 > 3)
      2  645e				  -	      ECHO	"Illegal bank address/segment location", 3
      3  645e				  -	      ERR
      4  645e					      ENDIF
      5  645e				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  645e				   _BANK_SLOT SET	3 * 64
      0  645e					      NEWBANK	LAST
      1  6c00 ????				      SEG	LAST
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   LAST_START SET	*
      6  6800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6800				   LAST       SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + 1024
      7  6800
      8  6800
      9  6800		       00 00 00 00*	      ds	1024
     10  6c00
     11  6c00							; EOF
------- FILE ./chess.asm
    646  6c00
    647  6c00							;---------------------------------------------------------------------------------------------------
    648  6c00							;EOF
