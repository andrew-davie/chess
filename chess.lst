------- FILE ./chess.asm LEVEL 1 PASS 4
      1  7800 ????						; Chess
      2  7800 ????						; Atari 2600 Chess display system
      3  7800 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  7800 ????						; andrew@taswegian.com
      5  7800 ????
      6  7800 ????
      7  7800 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  7800 ????
      9  7800 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  7800 ????				      include	"vcs.h"
      1  7800 ????						; VCS.H
      2  7800 ????						; Version 1.05, 13/November/2003
      3  7800 ????
      4  7800 ????	       00 69	   VERSION_VCS =	105
      5  7800 ????
      6  7800 ????						; This file defines hardware registers and memory mapping for the
      7  7800 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  7800 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  7800 ????						; available at at http://www.atari2600.org/dasm
     10  7800 ????						;
     11  7800 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  7800 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  7800 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  7800 ????						; with your views.  Please contribute, if you think you can improve this
     15  7800 ????						; file!
     16  7800 ????						;
     17  7800 ????						; Latest Revisions...
     18  7800 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  7800 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  7800 ????						;			    This will allow conditional code to verify VCS.H being
     21  7800 ????						;			    used for code assembly.
     22  7800 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  7800 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  7800 ????						;			 mirrored reading/writing differences.	This is more a
     25  7800 ????						;			 readability issue, and binary compatibility with disassembled
     26  7800 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  7800 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  7800 ????						;			 which was broken by the use of segments in this file, as
     29  7800 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  7800 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  7800 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  7800 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  7800 ????						;						   it is safe to leave it undefined, and the base address will
     34  7800 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  7800 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  7800 ????						;			  - register definitions are now generated through assignment
     37  7800 ????						;			    in uninitialised segments.	This allows a changeable base
     38  7800 ????						;			    address architecture.
     39  7800 ????						; 1.0	22/MAR/2003		Initial release
     40  7800 ????
     41  7800 ????
     42  7800 ????						;-------------------------------------------------------------------------------
     43  7800 ????
     44  7800 ????						; TIA_BASE_ADDRESS
     45  7800 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  7800 ????						; Normally 0, the base address should (externally, before including this file)
     47  7800 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  7800 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  7800 ????						; < $40 as a bankswitch.
     50  7800 ????
     51  7800 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  7800 ????			  -TIA_BASE_ADDRESS =	0
     53  7800 ????				      ENDIF
     54  7800 ????
     55  7800 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  7800 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  7800 ????						; *OR* by declaring the label before including this file, eg:
     58  7800 ????						; TIA_BASE_ADDRESS = $40
     59  7800 ????						;   include "vcs.h"
     60  7800 ????
     61  7800 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  7800 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  7800 ????						; for the mirrored ROM hardware registers.
     64  7800 ????
     65  7800 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  7800 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  7800 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  7800 ????
     69  7800 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  7800 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  7800 ????				      ENDIF
     72  7800 ????
     73  7800 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  7800 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  7800 ????				      ENDIF
     76  7800 ????
     77  7800 ????						;-------------------------------------------------------------------------------
     78  7800 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
     19  0000 ????						;include "segtime.asm"
     20  0000 ????
     21  0000 ????
     22  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     23  0000 ????
     24  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     25  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     26  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     27  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????	       00 40	   HUMAN      =	64
     35  0000 ????
     36  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     37  0000 ????
     38  0000 ????
     39  0000 ????						; assemble diagnostics. Remove for release.
     40  0000 ????
     41  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     42  0000 ????	       00 01	   DIAGNOSTICS =	1
     43  0000 ????	       00 01	   QUIESCENCE =	1
     44  0000 ????	       00 00	   ASSERTS    =	0
     45  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     46  0000 ????	       00 01	   ENPASSANT_ENABLED =	1
     47  0000 ????	       00 01	   CASTLING_ENABLED =	1
     48  0000 ????
     49  0000 ????
     50  0000 ????	       00 02	   SELECT_SWITCH =	2	; (SWCHB & SELECT_SWITCH)  0 == PRESSED
     51  0000 ????
     52  0000 ????
     53  0000 ????						; NOTE: SEARCH_DEPTH cannot be < 3, because the player's moves are generated from PLY+1, and use
     54  0000 ????						; PLY+2 for computer response (thus, 3). The bank allocation gets stomped!
     55  0000 ????
     56  0000 ????
     57  0000 ????	       00 03	   SEARCH_DEPTH =	3
     58  0000 ????	       00 06	   QUIESCE_EXTRA_DEPTH =	6
     59  0000 ????
     60  0000 ????
     61  0000 ????			  -	      IF	SEARCH_DEPTH < 3
     62  0000 ????			  -	      ECHO	"ERROR: Search depth must be >= 3"
     63  0000 ????			  -	      ERR
     64  0000 ????				      ENDIF
     65  0000 ????
     66  0000 ????
     67  0000 ????
     68  0000 ????	       00 09	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     69  0000 ????	       00 09	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     70  0000 ????
     71  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     72  0000 ????						;    ERR "Not enough RAM for PLY banks"
     73  0000 ????						;ENDIF
     74  0000 ????
     75  0000 ????
     76  0000 ????
     77  0000 ????
     78  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     79  0000 ????
     80  0000 ????
     81  0000 ????
     82  0000 ????						; DELAYS
     83  0000 ????
     84  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     85  0000 ????
     86  0000 ????						;===================================
     87  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     88  0000 ????						;===================================
     89  0000 ????
     90  0000 ????						;-------------------------------------------------------------------------------
     91  0000 ????						; The following are optional YES/NO depending on phase of the moon
     92  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     93  0000 ????						;-------------------------------------------------------------------------------
     94  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     95  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     96  0000 ????			  -	      IF	FINAL_VERSION = YES
     97  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     98  0000 ????				      ENDIF
     99  0000 ????
    100  0000 ????						;-------------------------------------------------------------------------------
    101  0000 ????
    102  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    103  0000 ????
    104  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    105  0000 ????
    106  0000 ????						;------------------------------------------------------------------------------
    107  0000 ????
    108  0000 ????	       00 01	   PLUSCART   =	YES
    109  0000 ????
    110  0000 ????						;------------------------------------------------------------------------------
    111  0000 ????
    112  0000 ????
    113  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
    114  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    115  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    116  0000 ????
    117  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    118  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    119  0000 ????
    120  0000 ????
    121  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    122  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    123  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    124  0000 ????
    125  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    126  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    127  0000 ????
    128  0000 ????
    129  0000 ????						; Platform constants:
    130  0000 ????	       00 02	   PAL	      =	%10
    131  0000 ????	       00 02	   PAL_50     =	PAL|0
    132  0000 ????	       00 03	   PAL_60     =	PAL|1
    133  0000 ????
    134  0000 ????
    135  0000 ????				      IF	L276
    136  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    137  0000 ????			  -	      ELSE
    138  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    139  0000 ????				      ENDIF
    140  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    141  0000 ????
    142  0000 ????				      IF	L276
    143  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    144  0000 ????			  -	      ELSE
    145  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    146  0000 ????				      ENDIF
    147  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    148  0000 ????
    149  0000 ????				      IF	L276
    150  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    151  0000 ????			  -	      ELSE
    152  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    153  0000 ????				      ENDIF
    154  0000 ????	       01 38	   SCANLINES_PAL =	312
    155  0000 ????
    156  0000 ????
    157  0000 ????	       00 2e	   TIME_PART_2 =	46
    158  0000 ????	       00 2e	   TIME_PART_1 =	46
    159  0000 ????
    160  0000 ????
    161  0000 ????	       00 00	   SLOT0      =	0
    162  0000 ????	       00 40	   SLOT1      =	64
    163  0000 ????	       00 80	   SLOT2      =	128
    164  0000 ????	       00 c0	   SLOT3      =	192
    165  0000 ????
    166  0000 ????						;------------------------------------------------------------------------------
    167  0000 ????						; MACRO definitions
    168  0000 ????
    169  0000 ????
    170  0000 ????
    171  0000 ????				      MAC	rombank
    172  0000 ????				      SEG	{1}
    173  0000 ????				      ORG	_ORIGIN
    174  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    175  0000 ????			   _BANK_START SET	*
    176  0000 ????			   {1}_START  SET	*
    177  0000 ????			   _CURRENT_BANK SET	_ORIGIN/1024
    178  0000 ????			   {1}	      SET	_BANK_SLOT + _CURRENT_BANK
    179  0000 ????			   _ORIGIN    SET	_ORIGIN + 1024
    180  0000 ????				      ENDM		; bank name
    181  0000 ????
    182  0000 ????						;	      MAC DEFINE_1K_SEGMENT ; {seg name}
    183  0000 ????						;		  ALIGN $400
    184  0000 ????						;SEGMENT_{1}	  SET *
    185  0000 ????						;BANK_{1}	  SET _CURRENT_BANK
    186  0000 ????						;	      ENDM
    187  0000 ????
    188  0000 ????				      MAC	check_bank_size
    189  0000 ????			   .TEMP      =	* - _BANK_START
    190  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    191  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    192  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    193  0000 ????				      ERR
    194  0000 ????				      ENDIF
    195  0000 ????				      ENDM		; name
    196  0000 ????
    197  0000 ????				      MAC	check_ram_bank_size
    198  0000 ????			   .TEMP      =	* - _BANK_START
    199  0000 ????				      ECHO	{1}, "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    200  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    201  0000 ????				      ECHO	"BANK OVERFLOW @ ", {1}, " size=", * - ORIGIN
    202  0000 ????				      ERR
    203  0000 ????				      ENDIF
    204  0000 ????				      ENDM		; name
    205  0000 ????
    206  0000 ????						;---------------------------------------------------------------------------------------------------
    207  0000 ????
    208  0000 ????						; Macro inserts a page break if the object would overlap a page
    209  0000 ????
    210  0000 ????				      MAC	optional_pagebreak
    211  0000 ????				      LIST	OFF
    212  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    213  0000 ????			   EARLY_LOCATION SET	*
    214  0000 ????				      ALIGN	256
    215  0000 ????				      IF	VERBOSE=1
    216  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    217  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    218  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    219  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    220  0000 ????				      ENDIF
    221  0000 ????				      ENDIF
    222  0000 ????				      LIST	ON
    223  0000 ????				      ENDM		; { string, size }
    224  0000 ????
    225  0000 ????
    226  0000 ????				      MAC	check_page_crossing
    227  0000 ????				      LIST	OFF
    228  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    229  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    230  0000 ????				      ENDIF
    231  0000 ????				      LIST	ON
    232  0000 ????				      ENDM
    233  0000 ????
    234  0000 ????				      MAC	checkpage
    235  0000 ????				      LIST	OFF
    236  0000 ????				      IF	>. != >{1}
    237  0000 ????				      ECHO	""
    238  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    239  0000 ????				      ECHO	""
    240  0000 ????				      ERR
    241  0000 ????				      ENDIF
    242  0000 ????				      LIST	ON
    243  0000 ????				      ENDM
    244  0000 ????
    245  0000 ????				      MAC	checkpagex
    246  0000 ????				      LIST	OFF
    247  0000 ????				      IF	>. != >{1}
    248  0000 ????				      ECHO	""
    249  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    250  0000 ????				      ECHO	{2}
    251  0000 ????				      ECHO	""
    252  0000 ????				      ERR
    253  0000 ????				      ENDIF
    254  0000 ????				      LIST	ON
    255  0000 ????				      ENDM
    256  0000 ????
    257  0000 ????						;---------------------------------------------------------------------------------------------------
    258  0000 ????
    259  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    260  0000 ????				      MAC	variable
    261  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    262  0000 ????			   {1}	      ds	{2}
    263  0000 ????				      ENDM		; {name, size}
    264  0000 ????
    265  0000 ????
    266  0000 ????						;---------------------------------------------------------------------------------------------------
    267  0000 ????
    268  0000 ????				      MAC	def
    269  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
    270  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
    271  0000 ????			   {1}			; entry point
    272  0000 ????			   TEMPORARY_VAR SET	Overlay
    273  0000 ????			   TEMPORARY_OFFSET SET	0
    274  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    275  0000 ????			   FUNCTION_NAME SET	{1}
    276  0000 ????				      ENDM		; name of subroutine
    277  0000 ????
    278  0000 ????
    279  0000 ????						;---------------------------------------------------------------------------------------------------
    280  0000 ????
    281  0000 ????				      MAC	allocate
    282  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    283  0000 ????				      DEF	{1}
    284  0000 ????				      ENDM
    285  0000 ????
    286  0000 ????						;---------------------------------------------------------------------------------------------------
    287  0000 ????
    288  0000 ????				      MAC	slot
    289  0000 ????				      IF	({1} < 0) || ({1} > 3)
    290  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
    291  0000 ????				      ERR
    292  0000 ????				      ENDIF
    293  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
    294  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
    295  0000 ????				      ENDM		; {1}
    296  0000 ????
    297  0000 ????
    298  0000 ????						;---------------------------------------------------------------------------------------------------
    299  0000 ????
    300  0000 ????				      MAC	negeval
    301  0000 ????
    302  0000 ????				      sec
    303  0000 ????				      lda	#0
    304  0000 ????				      sbc	Evaluation
    305  0000 ????				      sta	Evaluation
    306  0000 ????				      lda	#0
    307  0000 ????				      sbc	Evaluation+1
    308  0000 ????				      sta	Evaluation+1
    309  0000 ????				      ENDM
    310  0000 ????
    311  0000 ????
    312  0000 ????				      MAC	swap
    313  0000 ????				      lda	sideToMove
    314  0000 ????				      eor	#SWAP_SIDE|HUMAN
    315  0000 ????				      sta	sideToMove
    316  0000 ????
    317  0000 ????						;NEGEVAL
    318  0000 ????				      ENDM
    319  0000 ????
    320  0000 ????
    321  0000 ????						;---------------------------------------------------------------------------------------------------
    322  0000 ????
    323  0000 ????			   TEMPORARY_OFFSET SET	0
    324  0000 ????
    325  0000 ????
    326  0000 ????				      MAC	vend
    327  0000 ????				      IFNCONST	{1}
    328  0000 ????				      ECHO	"Incorrect VEND label", {1}
    329  0000 ????				      ERR
    330  0000 ????				      ENDIF
    331  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    332  0000 ????				      ENDM		; {1}
    333  0000 ????
    334  0000 ????
    335  0000 ????				      MAC	refer
    336  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    337  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    338  0000 ????				      ENDIF
    339  0000 ????				      ENDM		; {1}
    340  0000 ????
    341  0000 ????
    342  0000 ????
    343  0000 ????						; Define a temporary variable for use in a subroutine
    344  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    345  0000 ????
    346  0000 ????				      MAC	var
    347  0000 ????			   {1}	      =	TEMPORARY_VAR
    348  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    349  0000 ????
    350  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    351  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    352  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    353  0000 ????				      ENDIF
    354  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    355  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    356  0000 ????				      ERR
    357  0000 ????				      ENDIF
    358  0000 ????				      LIST	ON
    359  0000 ????				      ENDM		; { name, size }
    360  0000 ????
    361  0000 ????
    362  0000 ????						;---------------------------------------------------------------------------------------------------
    363  0000 ????
    364  0000 ????				      MAC	tag
    365  0000 ????						; {0}
    366  0000 ????				      ENDM		; {ident/tag}
    367  0000 ????
    368  0000 ????						;---------------------------------------------------------------------------------------------------
    369  0000 ????
    370  0000 ????				      MAC	sta@ram
    371  0000 ????				      sta	[RAM]+{0}
    372  0000 ????				      ENDM		;{}
    373  0000 ????
    374  0000 ????				      MAC	stx@ram
    375  0000 ????				      stx	[RAM]+{0}
    376  0000 ????				      ENDM
    377  0000 ????
    378  0000 ????				      MAC	sty@ram
    379  0000 ????				      sty	[RAM]+{0}
    380  0000 ????				      ENDM
    381  0000 ????
    382  0000 ????				      MAC	sta@ply
    383  0000 ????				      sta	[RAM]+{0}
    384  0000 ????				      ENDM		;{}
    385  0000 ????
    386  0000 ????				      MAC	stx@ply
    387  0000 ????				      stx	[RAM]+{0}
    388  0000 ????				      ENDM
    389  0000 ????
    390  0000 ????				      MAC	sty@ply
    391  0000 ????				      sty	[RAM]+{0}
    392  0000 ????				      ENDM
    393  0000 ????
    394  0000 ????
    395  0000 ????				      MAC	lda@ram
    396  0000 ????				      lda	{0}
    397  0000 ????				      ENDM		;{}
    398  0000 ????
    399  0000 ????				      MAC	ldx@ram
    400  0000 ????				      ldx	{0}
    401  0000 ????				      ENDM		;{}
    402  0000 ????
    403  0000 ????				      MAC	ldy@ram
    404  0000 ????				      ldy	{0}
    405  0000 ????				      ENDM		;{}
    406  0000 ????
    407  0000 ????
    408  0000 ????				      MAC	lda@ply
    409  0000 ????				      lda	{0}
    410  0000 ????				      ENDM		;{}
    411  0000 ????
    412  0000 ????				      MAC	ldx@ply
    413  0000 ????				      ldx	{0}
    414  0000 ????				      ENDM		;{}
    415  0000 ????
    416  0000 ????				      MAC	ldy@ply
    417  0000 ????				      ldy	{0}
    418  0000 ????				      ENDM		;{}
    419  0000 ????
    420  0000 ????
    421  0000 ????				      MAC	adc@ply
    422  0000 ????				      adc	{0}
    423  0000 ????				      ENDM		;{}
    424  0000 ????
    425  0000 ????				      MAC	sbc@ply
    426  0000 ????				      sbc	{0}
    427  0000 ????				      ENDM		;{}
    428  0000 ????
    429  0000 ????				      MAC	cmp@ply
    430  0000 ????				      cmp	{0}
    431  0000 ????				      ENDM		;{}
    432  0000 ????
    433  0000 ????						;---------------------------------------------------------------------------------------------------
    434  0000 ????
    435  0000 ????				      MAC	set_platform
    436  0000 ????						; 00 = NTSC
    437  0000 ????						; 01 = NTSC
    438  0000 ????						; 10 = PAL-50
    439  0000 ????						; 11 = PAL-60
    440  0000 ????				      lda	SWCHB
    441  0000 ????				      rol
    442  0000 ????				      rol
    443  0000 ????				      rol
    444  0000 ????				      and	#%11
    445  0000 ????				      eor	#PAL
    446  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    447  0000 ????				      ENDM
    448  0000 ????
    449  0000 ????
    450  0000 ????						;---------------------------------------------------------------------------------------------------
    451  0000 ????
    452  0000 ????						;    MAC JSROM_SAFE ; {routine}
    453  0000 ????						;    ; Saves bank of routine to variable for later restore.
    454  0000 ????						;    ; Switches to the bank and does a JSR to the routine.
    455  0000 ????
    456  0000 ????						;		  lda #BANK_{1}
    457  0000 ????						;		  sta savedBank
    458  0000 ????						;		  sta SET_BANK
    459  0000 ????						;		  jsr {1}
    460  0000 ????						;    ENDM
    461  0000 ????
    462  0000 ????
    463  0000 ????						;    MAC JSROM ; {routine}
    464  0000 ????
    465  0000 ????						;		  lda #BANK_{1}
    466  0000 ????						;		  sta SET_BANK
    467  0000 ????						;		  jsr {1}
    468  0000 ????						;    ENDM
    469  0000 ????
    470  0000 ????
    471  0000 ????						;    MAC JSRAM
    472  0000 ????						;		  lda #BANK_{1}
    473  0000 ????						;		  sta SET_BANK_RAM
    474  0000 ????						;		  jsr {1}
    475  0000 ????						;    ENDM
    476  0000 ????
    477  0000 ????
    478  0000 ????
    479  0000 ????				      MAC	timecheck
    480  0000 ????				      lda	INTIM
    481  0000 ????				      cmp	#SPEEDOF_{1}
    482  0000 ????				      bcc	{2}
    483  0000 ????				      ENDM		; {ident}, {branch if out of time}
    484  0000 ????
    485  0000 ????
    486  0000 ????				      MAC	timing
    487  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    488  0000 ????				      ENDM		; {label}, {cycles}
    489  0000 ????
    490  0000 ????
    491  0000 ????						;---------------------------------------------------------------------------------------------------
    492  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00ff ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   aiState    ds	1	; state
     24 U008c		       00	   aiFlashDelay ds	1
     25 U008d
     26 U008d		       00	   aiMoveIndex ds	1
     27 U008e
     28 U008e		       00	   aiFlashPhase ds	1
     29 U008f
     30 U008f		       00 00	   Evaluation ds	2	; tracks value of the board position
     31 U0091
     32 U0091		       00	   currentPiece ds	1
     33 U0092		       00	   currentSquare ds	1
     34 U0093		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     35 U0094		       00	   currentPly ds	1
     36 U0095
     37 U0095		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     38 U0096		       00	   fromPiece  ds	1
     39 U0097		       00	   lastPiece  ds	1
     40 U0098		       00	   previousPiece ds	1
     41 U0099
     42 U0099							;Platform			  ds 1		      ; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U0099		       00 00	   speech_addr ds	2
     44 U009b							;bg				  ds 1
     45 U009b
     46 U009b		       00	   capture    ds	1
     47 U009c
     48 U009c					      IF	DIAGNOSTICS
     49 U009c		       00 00 00    positionCount ds	3
     50 U009f					      ENDIF
     51 U009f
     52 U009f							;maxPly			  ds 1
     53 U009f		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     54 U00a0		       00	   protecting ds	1
     55 U00a1		       00	   randomness ds	1
     56 U00a2		       00 00	   __psb      ds	2
     57 U00a4
     58 U00a4		       00 00	   vkSquare   ds	2	; current move's king traversal squares during castling
     59 U00a6		       00	   human      ds	1	; colour of human
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a7					      include	"overlays.asm"
      1 U00a7							; Chess
      2 U00a7							; Atari 2600 Chess display system
      3 U00a7							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a7							; andrew@taswegian.com
      5 U00a7
      6 U00a7							;---------------------------------------------------------------------------------------------------
      7 U00a7							; OVERLAYS!
      8 U00a7							; These variables are overlays, and should be managed with care
      9 U00a7							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a7							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a7							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a7							; overlay #2
     13 U00a7
     14 U00a7							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a7
     16 U00a7							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a7							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a7							;---------------------------------------------------------------------------------------------------
     19 U00a7
     20 U00a7					      MAC	overlay
     21 U00a7				   OVERLAY_NAME SET	{1}
     22 U00a7					      SEG.U	OVERLAY_{1}
     23 U00a7					      org	Overlay
     24 U00a7					      ENDM		; {name}
     25 U00a7
     26 U00a7							;---------------------------------------------------------------------------------------------------
     27 U00a7
     28 U00a7					      MAC	validate_overlay
     29 U00a7					      LIST	OFF
     30 U00a7				   OVERLAY_DELTA SET	* - Overlay
     31 U00a7					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a7					      ENDIF
     34 U00a7					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a7					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a7					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a7					      ERR
     38 U00a7					      ENDIF
     39 U00a7					      LIST	ON
     40 U00a7					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a7					      ENDM
     42 U00a7
     43 U00a7							;---------------------------------------------------------------------------------------------------
     44 U00a7
     45 U00a7				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a7
     48 U00a7
     49 U00a7							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a7							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a7							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a7							; (especially the latter ones) are only used in rare occasions.
     53 U00a7
     54 U00a7							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a7							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a7
      0 U00a7					      DEF	Overlay
      1 U00a7				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a7				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a7				   Overlay
      4 U00a7				   TEMPORARY_VAR SET	Overlay
      5 U00a7				   TEMPORARY_OFFSET SET	0
      6 U00a7				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a7				   FUNCTION_NAME SET	Overlay
     58 U00a7		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00f3				   END_OF_OVERLAY
     60 U00f3
     61 U00f3							;---------------------------------------------------------------------------------------------------
     62 U00f3							; And now... the overlays....
     63 U00f3
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00f3					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00f3
     66 U00f3							;---------------------------------------------------------------------------------------------------
     67 U00f3
     68 U00f3		       00 a7	   __pieceShapeBuffer =	Overlay	; size = PIECE_SHAPE_SIZE
     69 U00f3
     70 U00f3							;---------------------------------------------------------------------------------------------------
     71 U00f3
     72 U00f3
     73 U00f3					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     74 U00f3					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $0
     75 U00f3					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     76 U00f3
     77 U00f3							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00f3					      include	"stack.asm"
      1 U00f3							; Chess
      2 U00f3							; Atari 2600 Chess display system
      3 U00f3							; Copyright (c) 2019-2020 Andrew Davie
      4 U00f3							; andrew@taswegian.com
      5 U00f3
      6 U00f3
      7 U00f3		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00f3
      9 U00f3		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00ff
     11 U00ff							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00ff							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00ff							;  but since overlay is not generally stressed during alphabeta, we're good.
     14 U00ff
     15 U00ff							; Ensure there isn't any stomping of stack/overlay excess usage
     16 U00ff
 Overlay boundary:  $a7
     17 U00ff					      ECHO	"Overlay boundary: ", Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE
 Stack boundary:  $ed
     18 U00ff					      ECHO	"Stack boundary: ", $FF- PLY_BANKS*2
     19 U00ff
     20 U00ff				  -	      IF	($FF - PLY_BANKS*2) < (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     21 U00ff				  -	      ECHO	"ERROR: Not enough reserved space for stack with given #PLY"
     22 U00ff				  -	      ERR
     23 U00ff					      ENDIF
     24 U00ff
     25 U00ff
------- FILE ./chess.asm
    496 U00ff
 FREE BYTES IN ZERO PAGE =  $0
    497 U00ff					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    498 U00ff				  -	      IF	* > $FF
    499 U00ff				  -	      ERR	"Zero Page overflow!"
    500 U00ff					      ENDIF
    501 U00ff
    502 U00ff							;------------------------------------------------------------------------------
    503 U00ff							;##############################################################################
    504 U00ff							;------------------------------------------------------------------------------
    505 U00ff
    506 U00ff							; NOW THE VERY INTERESTING '3E' RAM BANKS
    507 U00ff							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    508 U00ff							; IN A 1K MEMORY SPACE
    509 U00ff
    510 U00ff
    511 U00ff							;---------------------------------------------------------------------------------------------------
    512 U00ff
    513 U00ff
    514 U00ff					      MAC	phase
    515 U00ff					      lda	#{1}
    516 U00ff					      sta	aiState
    517 U00ff					      ENDM		;#
    518 U00ff
    519 U00ff
    520 U00ff							;--------------------------------------------------------------------------------
    521 U00ff
    522 U00ff					      MAC	common_vars
    523 U00ff
    524 U00ff					      VAR	__thinkbar, 1
    525 U00ff					      VAR	__toggle, 1
    526 U00ff
    527 U00ff					      VAR	__bestMove, 1
    528 U00ff					      VAR	__alpha, 2
    529 U00ff					      VAR	__beta, 2
    530 U00ff					      VAR	__negaMax, 2
    531 U00ff					      VAR	__value, 2
    532 U00ff
    533 U00ff					      VAR	__quiesceCapOnly, 1
    534 U00ff
    535 U00ff					      VAR	__originalPiece, 1
    536 U00ff					      VAR	__capturedPiece, 1
    537 U00ff
    538 U00ff					      ENDM
    539 U00ff							;---------------------------------------------------------------------------------------------------
    540 U00ff
------- FILE _ MACROS.asm LEVEL 2 PASS 4
      0 U00ff					      include	"_ MACROS.asm"
      1 U00ff							; MACROS.asm
      2 U00ff
      3 U00ff
      4 U00ff							;---------------------------------------------------------------------------------------------------
      5 U00ff
      6 U00ff					      MAC	def
      7 U00ff
      8 U00ff							; Declare a subroutine
      9 U00ff							; Sets up a whole lot of helper stuff
     10 U00ff							;   slot and bank equates
     11 U00ff							;   local variable setup
     12 U00ff
     13 U00ff				   SLOT_{1}   SET	_BANK_SLOT
     14 U00ff				   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
     15 U00ff				   {1}			; entry point
     16 U00ff				   TEMPORARY_VAR SET	Overlay
     17 U00ff				   TEMPORARY_OFFSET SET	0
     18 U00ff				   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
     19 U00ff				   _FUNCTION_NAME SETSTR	{1}
     20 U00ff					      ENDM		; {name of subroutine}
     21 U00ff
     22 U00ff
     23 U00ff							;---------------------------------------------------------------------------------------------------
     24 U00ff
     25 U00ff					      MAC	ramdef
     26 U00ff
     27 U00ff							; Just an alternate name for "DEF" that makes it clear the subroutine is in RAM
     28 U00ff
     29 U00ff					      DEF	{1}
     30 U00ff					      ENDM		; {name of subroutine}
     31 U00ff
     32 U00ff							;---------------------------------------------------------------------------------------------------
     33 U00ff
     34 U00ff					      MAC	slot
     35 U00ff
     36 U00ff					      IF	({1} < 0) || ({1} > 3)
     37 U00ff					      ECHO	"Illegal bank address/segment location", {1}
     38 U00ff					      ERR
     39 U00ff					      ENDIF
     40 U00ff
     41 U00ff				   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
     42 U00ff				   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
     43 U00ff
     44 U00ff					      ENDM		; {1}
     45 U00ff
     46 U00ff							;---------------------------------------------------------------------------------------------------
     47 U00ff							; Temporary local variables
     48 U00ff							; usage:
     49 U00ff							;
     50 U00ff							;   DEF fna
     51 U00ff							;	 REFER fnc
     52 U00ff							;	 REFER fnd
     53 U00ff							;	 VAR localVar1,1
     54 U00ff							;	 VAR ptr,2
     55 U00ff							;	 VEND fna
     56 U00ff							;
     57 U00ff							; The above declares a functino named 'fna'
     58 U00ff							; The function declares two local variables, 'localVar1' (1 byte) and 'ptr' (2 bytes)
     59 U00ff							; These variables are given an address in the overlay area which does NOT overlap any of
     60 U00ff							; the local variables which are declared in the referring functions 'fnc' and 'fnd'
     61 U00ff							; Although the local variables are available to other functions (i.e., global in scope), care
     62 U00ff							; should be taken NOT to use them in other functions unless absolutely necessary and required.
     63 U00ff							; To share local variables between functions, they should be (re)declared in both so that they
     64 U00ff							; have exactly the same addresses.
     65 U00ff
     66 U00ff
     67 U00ff
     68 U00ff							; The relative offset into the overlay area for the next variable declaration...
     69 U00ff				   TEMPORARY_OFFSET SET	0
     70 U00ff
     71 U00ff
     72 U00ff
     73 U00ff							; Finalise the declaration block for local variables
     74 U00ff							; {1} = name of the function for which this block is defined
     75 U00ff					      MAC	vend
     76 U00ff							; register the end of variables for this function
     77 U00ff
     78 U00ff				   VAREND_{1} =	TEMPORARY_VAR
     79 U00ff							;V2_._FUNCTION_NAME = TEMPORARY_VAR
     80 U00ff					      ENDM
     81 U00ff
     82 U00ff
     83 U00ff							; Note a reference to this function by an external function
     84 U00ff							; The external function's VEND block is used to guarantee that variables for
     85 U00ff							; the function we are declaring will start AFTER all other variables in all referencing blocks
     86 U00ff
     87 U00ff					      MAC	ref
     88 U00ff					      IF	VAREND_{1} > TEMPORARY_VAR
     89 U00ff				   TEMPORARY_VAR SET	VAREND_{1}
     90 U00ff					      ENDIF
     91 U00ff					      ENDM		; {1}
     92 U00ff
     93 U00ff
     94 U00ff
     95 U00ff							; Define a temporary variable for use in a subroutine
     96 U00ff							; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
     97 U00ff
     98 U00ff					      MAC	var
     99 U00ff							;	  ;LIST OFF
    100 U00ff				   {1}	      =	TEMPORARY_VAR
    101 U00ff				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    102 U00ff
    103 U00ff				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    104 U00ff					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    105 U00ff				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    106 U00ff					      ENDIF
    107 U00ff					      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
    108 U00ff					      LIST	ON
    109 U00ff					      VNAME	SETSTR {1}
    110 U00ff					      ECHO	"Temporary Variable", VNAME, "overflow!"
    111 U00ff					      ERR
    112 U00ff					      ECHO	"Temporary Variable overlow!"
    113 U00ff					      ENDIF
    114 U00ff					      LIST	ON
    115 U00ff					      ENDM		; { name, size }
    116 U00ff
    117 U00ff
    118 U00ff					      MAC	rombank
    119 U00ff					      SEG	ROM_{1}
    120 U00ff					      ORG	_ORIGIN
    121 U00ff					      RORG	_BANK_ADDRESS_ORIGIN
    122 U00ff				   _BANK_START SET	*
    123 U00ff				   {1}_START  SET	*
    124 U00ff				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
    125 U00ff				   ROMBANK_{1} SET	_BANK_SLOT + _CURRENT_BANK
    126 U00ff				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
    127 U00ff				   _LAST_BANK SETSTR	{1}
    128 U00ff					      ENDM		; bank name
    129 U00ff
    130 U00ff
    131 U00ff							;---------------------------------------------------------------------------------------------------
    132 U00ff
    133 U00ff					      MAC	check_bank_size
    134 U00ff				   .TEMP      =	* - _BANK_START
    135 U00ff					      ECHO	_LAST_BANK, "SIZE =", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
    136 U00ff					      IF	( .TEMP ) > _ROM_BANK_SIZE
    137 U00ff					      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN
    138 U00ff					      ERR
    139 U00ff					      ENDIF
    140 U00ff					      ENDM
    141 U00ff
    142 U00ff
    143 U00ff							;---------------------------------------------------------------------------------------------------
    144 U00ff
    145 U00ff					      MAC	check_ram_bank_size
    146 U00ff				   .TEMP      =	* - _BANK_START
    147 U00ff					      ECHO	_LAST_BANK, "SIZE =", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
    148 U00ff					      IF	( .TEMP ) > _RAM_BANK_SIZE
    149 U00ff					      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN
    150 U00ff					      ERR
    151 U00ff					      ENDIF
    152 U00ff					      ENDM
    153 U00ff
    154 U00ff
    155 U00ff							;---------------------------------------------------------------------------------------------------
    156 U00ff
    157 U00ff					      MAC	rambank
    158 U00ff
    159 U00ff					      SEG.U	RAM_{1}
    160 U00ff					      ORG	ORIGIN_RAM
    161 U00ff					      RORG	_BANK_ADDRESS_ORIGIN
    162 U00ff				   _BANK_START SET	*
    163 U00ff				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
    164 U00ff				   RAMBANK_{1} SET	_BANK_SLOT + _CURRENT_RAMBANK
    165 U00ff				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
    166 U00ff				   _LAST_BANK SETSTR	{1}
    167 U00ff
    168 U00ff					      ENDM		; {bank name}
    169 U00ff
    170 U00ff
    171 U00ff							;---------------------------------------------------------------------------------------------------
    172 U00ff
    173 U00ff							; Failsafe call of function in another bank
    174 U00ff							; This will check the slot #s for current, call to make sure they're not the same!
    175 U00ff
    176 U00ff					      MAC	call
    177 U00ff					      IF	SLOT_{1} == _BANK_SLOT
    178 U00ff				   FNAME      SETSTR	{1}
    179 U00ff					      ECHO	""
    180 U00ff					      ECHO	"ERROR: Incompatible slot for call to function", FNAME
    181 U00ff					      ECHO	"Cannot switch bank in use for ", FNAME
    182 U00ff					      ERR
    183 U00ff					      ENDIF
    184 U00ff					      lda	#BANK_{1}
    185 U00ff					      sta	SET_BANK
    186 U00ff					      jsr	{1}
    187 U00ff					      ENDM		; function name
    188 U00ff
    189 U00ff
    190 U00ff					      MAC	jump
    191 U00ff					      IF	SLOT_{1} == _BANK_SLOT
    192 U00ff				   FNAME      SETSTR	{1}
    193 U00ff					      ECHO	""
    194 U00ff					      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
    195 U00ff					      ECHO	"Cannot switch bank in use for ", FNAME
    196 U00ff					      ERR
    197 U00ff					      ENDIF
    198 U00ff					      lda	#BANK_{1}
    199 U00ff					      sta	SET_BANK
    200 U00ff					      jsr	{1}
    201 U00ff					      ENDM		; function name
    202 U00ff
    203 U00ff
    204 U00ff							;---------------------------------------------------------------------------------------------------
    205 U00ff							; RAM accessor macros
    206 U00ff							; ALL RAM usage (reads and writes) should use these
    207 U00ff							; They automate the write offset address addition, and make it clear what memory is being accessed
    208 U00ff
    209 U00ff
    210 U00ff					      MAC	sta@ram
    211 U00ff					      sta	[RAM]+{0}
    212 U00ff					      ENDM		;{}
    213 U00ff
    214 U00ff					      MAC	stx@ram
    215 U00ff					      stx	[RAM]+{0}
    216 U00ff					      ENDM		;{}
    217 U00ff
    218 U00ff					      MAC	sty@ram
    219 U00ff					      sty	[RAM]+{0}
    220 U00ff					      ENDM		;{}
    221 U00ff
    222 U00ff
    223 U00ff					      MAC	lda@ram
    224 U00ff					      lda	{0}
    225 U00ff					      ENDM		;{}
    226 U00ff
    227 U00ff					      MAC	ldx@ram
    228 U00ff					      ldx	{0}
    229 U00ff					      ENDM		;{}
    230 U00ff
    231 U00ff					      MAC	ldy@ram
    232 U00ff					      ldy	{0}
    233 U00ff					      ENDM		;{}
    234 U00ff
    235 U00ff
    236 U00ff					      MAC	adc@ram
    237 U00ff					      lda	{0}
    238 U00ff					      ENDM		;{}
    239 U00ff
    240 U00ff					      MAC	sbc@ram
    241 U00ff					      lda	{0}
    242 U00ff					      ENDM		;{}
    243 U00ff
    244 U00ff					      MAC	cmp@ram
    245 U00ff					      cmp	{0}
    246 U00ff					      ENDM		;{}
    247 U00ff
    248 U00ff
    249 U00ff							;---------------------------------------------------------------------------------------------------
    250 U00ff
    251 U00ff					      MAC	overlay
    252 U00ff					      SEG.U	OVERLAY_{1}
    253 U00ff					      org	Overlay
    254 U00ff					      ENDM		; {name}
    255 U00ff
    256 U00ff
    257 U00ff							;---------------------------------------------------------------------------------------------------
    258 U00ff
    259 U00ff					      MAC	validate_overlay
    260 U00ff							;	  ;LIST OFF
    261 U00ff					      if	* - Overlay > OVERLAY_SIZE
    262 U00ff					      ERR
    263 U00ff					      endif
    264 U00ff					      LIST	ON
    265 U00ff					      ENDM
    266 U00ff
    267 U00ff
    268 U00ff							;---------------------------------------------------------------------------------------------------
    269 U00ff							; Macro inserts a page break if the object would overlap a page
    270 U00ff
    271 U00ff					      MAC	optional_pagebreak
    272 U00ff							;	  ;LIST OFF
    273 U00ff					      IF	(>( * + {2} -1 )) > ( >* )
    274 U00ff				   EARLY_LOCATION SET	*
    275 U00ff					      ALIGN	256
    276 U00ff					      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    277 U00ff					      ECHO	"REQUESTED SIZE = ", {2}
    278 U00ff					      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    279 U00ff					      ECHO	"PAGEBREAK LOCATION = ", *
    280 U00ff					      ENDIF
    281 U00ff					      LIST	ON
    282 U00ff					      ENDM		; { string, size }
    283 U00ff
    284 U00ff
    285 U00ff							;---------------------------------------------------------------------------------------------------
    286 U00ff
    287 U00ff		       00 fe	   RND_EOR_VAL =	$FE	;B4
    288 U00ff
    289 U00ff					      MAC	next_random
    290 U00ff					      lda	rnd
    291 U00ff					      lsr
    292 U00ff					      bcc	.skipEOR
    293 U00ff					      eor	#RND_EOR_VAL
    294 U00ff				   .skipEOR   sta	rnd
    295 U00ff					      ENDM
    296 U00ff
    297 U00ff
    298 U00ff							;---------------------------------------------------------------------------------------------------
    299 U00ff
    300 U00ff
    301 U00ff					      MAC	set_platform
    302 U00ff							; 00 = NTSC
    303 U00ff							; 01 = NTSC
    304 U00ff							; 10 = PAL-50
    305 U00ff							; 11 = PAL-60
    306 U00ff					      lda	SWCHB	; 4
    307 U00ff					      and	#%11000000	; 2	 make sure carry is clear afterwards
    308 U00ff					      asl		; 2
    309 U00ff					      rol		; 2
    310 U00ff					      rol		; 2
    311 U00ff					      if	NTSC_MODE = NO
    312 U00ff					      eor	#PAL
    313 U00ff					      endif
    314 U00ff					      sta	Platform	; 3 = 15 P1 difficulty ──▷ TV system (0=NTSC, 1=PAL)
    315 U00ff					      ENDM
    316 U00ff
    317 U00ff
    318 U00ff							;---------------------------------------------------------------------------------------------------
    319 U00ff
    320 U00ff					      MAC	nop_b
    321 U00ff					      .byte	$82
    322 U00ff					      ENDM		; unused
    323 U00ff
    324 U00ff
    325 U00ff							;---------------------------------------------------------------------------------------------------
    326 U00ff
    327 U00ff					      MAC	nop_w
    328 U00ff					      .byte	$0c
    329 U00ff					      ENDM
    330 U00ff
    331 U00ff
    332 U00ff							;---------------------------------------------------------------------------------------------------
    333 U00ff							;EOF
------- FILE ./chess.asm
------- FILE _ PIECE MACROS.asm LEVEL 2 PASS 4
      0 U00ff					      include	"_ PIECE MACROS.asm"
      1 U00ff							; Copyright (C)2020 Andrew Davie
      2 U00ff							; Common macros for piece move handlers
      3 U00ff
      4 U00ff							;---------------------------------------------------------------------------------------------------
      5 U00ff							; Looks at a square offset {1} to see if piece can move to it
      6 U00ff							; Adds the square to the movelist if it can
      7 U00ff							; Keeps moving in the same direction until it's blocked/off=board
      8 U00ff
      9 U00ff					      MAC	move_towards
     10 U00ff					      SUBROUTINE
     11 U00ff
     12 U00ff							; = 76 for single square (empty/take)
     13 U00ff
     14 U00ff					      lda	#0
     15 U00ff					      sta	capture
     16 U00ff
     17 U00ff					      ldx	currentSquare	; 3
     18 U00ff					      bne	.project	; 3   unconditional
     19 U00ff
     20 U00ff				   .empty     jsr	AddMove	; 57
     21 U00ff				   .project   ldy	ValidSquare+{1},x	; 4
     22 U00ff					      bmi	.invalid	; 2/3 off board!
     23 U00ff					      lda	Board,y	; 4   piece @ destination
     24 U00ff					      beq	.empty	; 2/3
     25 U00ff					      sta	capture
     26 U00ff					      eor	currentPiece	; 3
     27 U00ff					      bpl	.invalid	; 2/3 same colour
     28 U00ff					      jsr	AddMove	; 57  and exit
     29 U00ff
     30 U00ff				   .invalid
     31 U00ff					      ENDM
     32 U00ff
     33 U00ff
     34 U00ff							;---------------------------------------------------------------------------------------------------
     35 U00ff
     36 U00ff					      MAC	move_to
     37 U00ff					      SUBROUTINE
     38 U00ff					      ldy	ValidSquare+{1},x
     39 U00ff					      bmi	.invalid	; off board!
     40 U00ff					      lda	Board,y	; piece @ destination
     41 U00ff					      sta	capture
     42 U00ff					      beq	.squareEmpty
     43 U00ff					      eor	currentPiece
     44 U00ff					      bpl	.invalid	; same colour
     45 U00ff				   .squareEmpty jsr	AddMove
     46 U00ff				   .invalid
     47 U00ff					      ENDM
     48 U00ff
     49 U00ff
     50 U00ff							;---------------------------------------------------------------------------------------------------
     51 U00ff
     52 U00ff					      MAC	move_to_x
     53 U00ff					      ldx	currentSquare
     54 U00ff					      MOVE_TO	{1}
     55 U00ff					      ENDM
     56 U00ff
     57 U00ff
     58 U00ff							;---------------------------------------------------------------------------------------------------
     59 U00ff							; EOF
------- FILE ./chess.asm
    543 U00ff
------- FILE @3 STARTBANK.asm LEVEL 2 PASS 4
      0 U00ff					      include	"@3 STARTBANK.asm"	; MUST be first ROM bank
      1 U00ff				   _ORIGIN    SET	_FIRST_BANK
      2 U00ff
      3 U00ff							; This is the first (START UP) bank for the 3E+ cartridge/scheme
      4 U00ff							; This bank is guaranteed to be mapped to SLOT 3 by the hardware implementation.
      5 U00ff							; It must contain the reset vector for the game!
      6 U00ff							; It does NOT need to be switched in for the remainder of the game!
      7 U00ff
      8 U00ff							;---------------------------------------------------------------------------------------------------
      9 U00ff
      0 U00ff					      SLOT	3
      1 U00ff				  -	      IF	(3 < 0) || (3 > 3)
      2 U00ff				  -	      ECHO	"Illegal bank address/segment location", 3
      3 U00ff				  -	      ERR
      4 U00ff					      ENDIF
      5 U00ff				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6 U00ff				   _BANK_SLOT SET	3 * 64
      0 U00ff					      ROMBANK	STARTBANK
      1  0400 ????				      SEG	STARTBANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   STARTBANK_START SET	*
      6  0000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0000				   STARTBANK  SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + 1024
     12  0000
     13  0000
     14  0000							;---------------------------------------------------------------------------------------------------
     15  0000
      0  0000					      DEF	StartCartridge
      1  0000				   SLOT_StartCartridge SET	_BANK_SLOT
      2  0000				   BANK_StartCartridge SET	SLOT_StartCartridge + _CURRENT_BANK
      3  0000				   StartCartridge
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartCartridge SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartCartridge
     17  0000
      0  0000					      CLEAN_START
      1  0000		       78		      sei
      2  0001		       d8		      cld
      3  0002
      4  0002		       a2 00		      ldx	#0
      5  0004		       8a		      txa
      6  0005		       a8		      tay
      7  0006		       ca	   .CLEAR_STACK dex
      8  0007		       9a		      txs
      9  0008		       48		      pha
     10  0009		       d0 fb		      bne	.CLEAR_STACK
     11  000b
     19  000b
      0  000b					      JUMP	StartupBankReset	;@0
      1  000b				  -	      IF	SLOT_StartupBankReset == _BANK_SLOT
      2  000b				  -FNAME      SETSTR	StartupBankReset
      3  000b				  -	      ECHO	""
      4  000b				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  000b				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  000b				  -	      ERR
      7  000b					      ENDIF
      8  000b		       a9 01		      lda	#BANK_StartupBankReset
      9  000d		       85 3f		      sta	SET_BANK
     10  000f		       20 00 f0 	      jsr	StartupBankReset
     21  0012
     22  0012							;---------------------------------------------------------------------------------------------------
     23  0012
     24  0012							; Lots of free space here
     25  0012
     26  0012							;---------------------------------------------------------------------------------------------------
     27  0012
 FREE BYTES IN STARTBANK =  $3ea
     28  0012					      ECHO	"FREE BYTES IN STARTBANK = ", $FFFC - *
     29  0012
     30  0012
     31  0012							;---------------------------------------------------------------------------------------------------
     32  0012
     33  0012							; The reset vectors
     34  0012							; these must live in the fixed bank (bank 0 in 3E+ format)
     35  0012
     36  03fc					      ORG	_FIRST_BANK + $3FC
     37  03fc					      RORG	$FFFC
      0  03fc					      DEF	InterruptVectors
      1  03fc				   SLOT_InterruptVectors SET	_BANK_SLOT
      2  03fc				   BANK_InterruptVectors SET	SLOT_InterruptVectors + _CURRENT_BANK
      3  03fc				   InterruptVectors
      4  03fc				   TEMPORARY_VAR SET	Overlay
      5  03fc				   TEMPORARY_OFFSET SET	0
      6  03fc				   VAR_BOUNDARY_InterruptVectors SET	TEMPORARY_OFFSET
      7  03fc				   FUNCTION_NAME SET	InterruptVectors
     39  03fc					      SUBROUTINE
     40  03fc
     41  03fc		       00 fc		      .word.w	StartCartridge	; RESET
     42  03fe		       00 fc		      .word.w	StartCartridge	; IRQ	      (not used)
     43  0400
     44  0400							;---------------------------------------------------------------------------------------------------
     45  0400							;EOF
------- FILE ./chess.asm
    545  0400
------- FILE @0 HOME.asm LEVEL 2 PASS 4
      0  0400					      include	"@0 HOME.asm"
      1  0400							; Chess
      2  0400							; Copyright (c) 2019-2020 Andrew Davie
      3  0400							; andrew@taswegian.com
      4  0400
      5  0400
      6  0400							; SLOT0 - screen draw, state machine dispatcher
      7  0400							; SLOT1 - anything
      8  0400							; SLOT2 - moves/ply
      9  0400							; SLOT3 - board
     10  0400
     11  0400
     12  0400
     13  0400
     14  0400
     15  0400
      0  0400					      SLOT	0
      1  0400				  -	      IF	(0 < 0) || (0 > 3)
      2  0400				  -	      ECHO	"Illegal bank address/segment location", 0
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      6  0400				   _BANK_SLOT SET	0 * 64
     17  0400
     18  0400							;---------------------------------------------------------------------------------------------------
     19  0400							;#########################################  FIXED BANK  ############################################
     20  0400							;---------------------------------------------------------------------------------------------------
     21  0400
     22  0400							;_ORIGIN	      SET _FIRST_BANK
     23  0400
      0  0400					      ROMBANK	THE_FIRST_BANK
      1  07ce ????				      SEG	THE_FIRST_BANK
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   THE_FIRST_BANK_START SET	*
      6  0400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0400				   THE_FIRST_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + 1024
     25  0400					      RORG	$f000
     26  0400
     27  0400							;---------------------------------------------------------------------------------------------------
     28  0400
      0  0400					      DEF	StartupBankReset
      1  0400				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0400				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0400				   StartupBankReset
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	StartupBankReset
     30  0400					      SUBROUTINE
     31  0400
      0  0400					      VEND	StartupBankReset
      1  0400				  -	      IFNCONST	StartupBankReset
      2  0400				  -	      ECHO	"Incorrect VEND label", StartupBankReset
      3  0400				  -	      ERR
      4  0400					      ENDIF
      5  0400		       00 a7	   VAREND_StartupBankReset =	TEMPORARY_VAR
     33  0400
     34  0400
     35  0400							;CALL TitleScreen
     36  0400
      0  0400					      CALL	CartInit
      1  0400				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0400				  -FNAME      SETSTR	CartInit
      3  0400				  -	      ECHO	""
      4  0400				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0400				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0400				  -	      ERR
      7  0400					      ENDIF
      8  0400		       a9 42		      lda	#BANK_CartInit
      9  0402		       85 3f		      sta	SET_BANK
     10  0404		       20 00 f4 	      jsr	CartInit
      0  0407					      CALL	SetupBanks
      1  0407				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  0407				  -FNAME      SETSTR	SetupBanks
      3  0407				  -	      ECHO	""
      4  0407				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0407				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0407				  -	      ERR
      7  0407					      ENDIF
      8  0407		       a9 42		      lda	#BANK_SetupBanks
      9  0409		       85 3f		      sta	SET_BANK
     10  040b		       20 30 f4 	      jsr	SetupBanks
      0  040e					      CALL	InitialisePieceSquares
      1  040e				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  040e				  -FNAME      SETSTR	InitialisePieceSquares
      3  040e				  -	      ECHO	""
      4  040e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  040e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  040e				  -	      ERR
      7  040e					      ENDIF
      8  040e		       a9 42		      lda	#BANK_InitialisePieceSquares
      9  0410		       85 3f		      sta	SET_BANK
     10  0412		       20 90 f4 	      jsr	InitialisePieceSquares
     40  0415		       20 3e f2 	      jsr	ListPlayerMoves	;@0
     41  0418
     42  0418
     43  0418				   .StartFrame
     44  0418
     45  0418
     46  0418							; START OF FRAME
     47  0418
     48  0418		       a9 0e		      lda	#%1110	; VSYNC ON
     49  041a		       85 42	   .loopVSync3 sta	WSYNC
     50  041c		       85 40		      sta	VSYNC
     51  041e		       4a		      lsr
     52  041f		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     53  0421
     54  0421		       85 41		      sta	VBLANK
     55  0423
     56  0423		       a0 2e		      ldy	#TIME_PART_1
     57  0425		       8c 96 02 	      sty	TIM64T
     58  0428
     59  0428							; LOTS OF PROCESSING TIME - USE IT
     60  0428
     61  0428
     62  0428
     63  0428		       20 80 f1 	      jsr	AiStateMachine
     64  042b
     65  042b				  -	      IF	ASSERTS
     66  042b				  -			; Catch timer expired already
     67  042b				  -			;		      bit TIMINT
     68  042b				  -			;.whoops	      bmi .whoops
     69  042b					      ENDIF
     70  042b
     71  042b
     72  042b		       2c 85 02    .wait      bit	TIMINT
     73  042e		       10 fb		      bpl	.wait
     74  0430
     75  0430
     76  0430							; START OF VISIBLE SCANLINES
     77  0430
     78  0430
      0  0430					      CALL	longD
      1  0430				  -	      IF	SLOT_longD == _BANK_SLOT
      2  0430				  -FNAME      SETSTR	longD
      3  0430				  -	      ECHO	""
      4  0430				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0430				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0430				  -	      ERR
      7  0430					      ENDIF
      8  0430		       a9 84		      lda	#BANK_longD
      9  0432		       85 3f		      sta	SET_BANK
     10  0434		       20 16 f8 	      jsr	longD
     80  0437
     81  0437
     82  0437		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     83  0439		       86 3e		      stx	SET_BANK_RAM
     84  043b		       20 03 f9 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     85  043e
      0  043e					      CALL	tidySc
      1  043e				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  043e				  -FNAME      SETSTR	tidySc
      3  043e				  -	      ECHO	""
      4  043e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  043e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  043e				  -	      ERR
      7  043e					      ENDIF
      8  043e		       a9 84		      lda	#BANK_tidySc
      9  0440		       85 3f		      sta	SET_BANK
     10  0442		       20 04 f8 	      jsr	tidySc
     87  0445
     88  0445		       20 80 f1 	      jsr	AiStateMachine
     89  0448
     90  0448		       ad 84 02 	      lda	INTIM
     91  044b		       c9 14		      cmp	#20
     92  044d		       90 20		      bcc	.notnow
     93  044f
     94  044f							;CALL GameSpeak
      0  044f					      CALL	PositionSprites
      1  044f				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  044f				  -FNAME      SETSTR	PositionSprites
      3  044f				  -	      ECHO	""
      4  044f				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  044f				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  044f				  -	      ERR
      7  044f					      ENDIF
      8  044f		       a9 4e		      lda	#BANK_PositionSprites
      9  0451		       85 3f		      sta	SET_BANK
     10  0453		       20 00 f5 	      jsr	PositionSprites
     96  0456
     97  0456
     98  0456					      IF	1
     99  0456							; "draw" sprite shapes into row banks
    100  0456
    101  0456		       a2 07		      ldx	#7
    102  0458		       8a	   zapem      txa
    103  0459		       18		      clc
    104  045a		       69 80		      adc	#SLOT_DrawRow
    105  045c		       85 3e		      sta	SET_BANK_RAM
      0  045e					      CALL	WriteBlank	;@3
      1  045e				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  045e				  -FNAME      SETSTR	WriteBlank
      3  045e				  -	      ECHO	""
      4  045e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  045e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  045e				  -	      ERR
      7  045e					      ENDIF
      8  045e		       a9 ca		      lda	#BANK_WriteBlank
      9  0460		       85 3f		      sta	SET_BANK
     10  0462		       20 0b fc 	      jsr	WriteBlank
    107  0465		       ca		      dex
    108  0466		       10 f0		      bpl	zapem
    109  0468
      0  0468					      CALL	WriteCursor	;@3
      1  0468				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  0468				  -FNAME      SETSTR	WriteCursor
      3  0468				  -	      ECHO	""
      4  0468				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0468				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0468				  -	      ERR
      7  0468					      ENDIF
      8  0468		       a9 ca		      lda	#BANK_WriteCursor
      9  046a		       85 3f		      sta	SET_BANK
     10  046c		       20 34 fc 	      jsr	WriteCursor
    111  046f					      ENDIF
    112  046f
    113  046f				   .notnow
    114  046f
    115  046f		       2c 85 02    .waitTime  bit	TIMINT
    116  0472		       10 fb		      bpl	.waitTime
    117  0474
    118  0474		       4c 18 f0 	      jmp	.StartFrame
    119  0477
    120  0477
    121  0477							;---------------------------------------------------------------------------------------------------
    122  0477
      0  0477					      DEF	ThinkBar
      1  0477				   SLOT_ThinkBar SET	_BANK_SLOT
      2  0477				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  0477				   ThinkBar
      4  0477				   TEMPORARY_VAR SET	Overlay
      5  0477				   TEMPORARY_OFFSET SET	0
      6  0477				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  0477				   FUNCTION_NAME SET	ThinkBar
    124  0477					      SUBROUTINE
    125  0477
      0  0477					      COMMON_VARS
      1  0477
      0  0477					      VAR	__thinkbar, 1
      1  0477		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
      0  0477					      VAR	__toggle, 1
      1  0477		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
      4  0477
      0  0477					      VAR	__bestMove, 1
      1  0477		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
      0  0477					      VAR	__alpha, 2
      1  0477		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
      0  0477					      VAR	__beta, 2
      1  0477		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
      0  0477					      VAR	__negaMax, 2
      1  0477		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
      0  0477					      VAR	__value, 2
      1  0477		       00 b0	   __value    =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
     10  0477
      0  0477					      VAR	__quiesceCapOnly, 1
      1  0477		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
     12  0477
      0  0477					      VAR	__originalPiece, 1
      1  0477		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
      0  0477					      VAR	__capturedPiece, 1
      1  0477		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0477				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0477
      4  0477				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0477					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0477				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0477					      ENDIF
      8  0477				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0477				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0477				  -	      ERR
     11  0477					      ENDIF
     12  0477					      LIST	ON
     15  0477
      0  0477					      REFER	negaMax	;✅
      1  0477				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0477				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0477					      ENDIF
      0  0477					      REFER	quiesce	;✅
      1  0477				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0477				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0477					      ENDIF
      0  0477					      VEND	ThinkBar
      1  0477				  -	      IFNCONST	ThinkBar
      2  0477				  -	      ECHO	"Incorrect VEND label", ThinkBar
      3  0477				  -	      ERR
      4  0477					      ENDIF
      5  0477		       00 b5	   VAREND_ThinkBar =	TEMPORARY_VAR
    130  0477
    131  0477					      IF	DIAGNOSTICS
    132  0477
    133  0477		       e6 9c		      inc	positionCount
    134  0479		       d0 06		      bne	.p1
    135  047b		       e6 9d		      inc	positionCount+1
    136  047d		       d0 02		      bne	.p1
    137  047f		       e6 9e		      inc	positionCount+2
    138  0481				   .p1
    139  0481					      ENDIF
    140  0481
    141  0481							; The 'thinkbar' pattern...
    142  0481
    143  0481		       a9 00		      lda	#0
    144  0483		       a4 4c		      ldy	INPT4
    145  0485		       30 13		      bmi	.doThink
    146  0487
    147  0487		       e6 a7		      inc	__thinkbar
    148  0489		       a5 a7		      lda	__thinkbar
    149  048b		       29 0f		      and	#15
    150  048d		       a8		      tay
    151  048e		       a5 81		      lda	rnd
    152  0490		       29 04		      and	#4
    153  0492		       19 a1 f0 	      ora	TBcol,y
    154  0495		       85 48		      sta	COLUPF
    155  0497
    156  0497		       b9 b1 f0 	      lda	SynapsePattern,y
    157  049a		       85 4f	   .doThink   sta	PF2
    158  049c		       85 4e		      sta	PF1
    159  049e		       85 4d		      sta	PF0
    160  04a0		       60		      rts
    161  04a1
    162  04a1
    163  04a1				   TBcol
    164  04a1				   .TBC       SET	2
    165  04a1					      REPEAT	16
    166  04a1		       02		      .byte.b	.TBC
    167  04a1				   .TBC       SET	.TBC + 16
    165  04a1					      REPEND
    166  04a2		       12		      .byte.b	.TBC
    167  04a2				   .TBC       SET	.TBC + 16
    165  04a2					      REPEND
    166  04a3		       22		      .byte.b	.TBC
    167  04a3				   .TBC       SET	.TBC + 16
    165  04a3					      REPEND
    166  04a4		       32		      .byte.b	.TBC
    167  04a4				   .TBC       SET	.TBC + 16
    165  04a4					      REPEND
    166  04a5		       42		      .byte.b	.TBC
    167  04a5				   .TBC       SET	.TBC + 16
    165  04a5					      REPEND
    166  04a6		       52		      .byte.b	.TBC
    167  04a6				   .TBC       SET	.TBC + 16
    165  04a6					      REPEND
    166  04a7		       62		      .byte.b	.TBC
    167  04a7				   .TBC       SET	.TBC + 16
    165  04a7					      REPEND
    166  04a8		       72		      .byte.b	.TBC
    167  04a8				   .TBC       SET	.TBC + 16
    165  04a8					      REPEND
    166  04a9		       82		      .byte.b	.TBC
    167  04a9				   .TBC       SET	.TBC + 16
    165  04a9					      REPEND
    166  04aa		       92		      .byte.b	.TBC
    167  04aa				   .TBC       SET	.TBC + 16
    165  04aa					      REPEND
    166  04ab		       a2		      .byte.b	.TBC
    167  04ab				   .TBC       SET	.TBC + 16
    165  04ab					      REPEND
    166  04ac		       b2		      .byte.b	.TBC
    167  04ac				   .TBC       SET	.TBC + 16
    165  04ac					      REPEND
    166  04ad		       c2		      .byte.b	.TBC
    167  04ad				   .TBC       SET	.TBC + 16
    165  04ad					      REPEND
    166  04ae		       d2		      .byte.b	.TBC
    167  04ae				   .TBC       SET	.TBC + 16
    165  04ae					      REPEND
    166  04af		       e2		      .byte.b	.TBC
    167  04af				   .TBC       SET	.TBC + 16
    165  04af					      REPEND
    166  04b0		       f2		      .byte.b	.TBC
    167  04b0				   .TBC       SET	.TBC + 16
    168  04b1					      REPEND
    169  04b1
    170  04b1				   SynapsePattern
    171  04b1
    172  04b1		       c1		      .byte.b	%11000001
    173  04b2		       60		      .byte.b	%01100000
    174  04b3		       30		      .byte.b	%00110000
    175  04b4		       18		      .byte.b	%00011000
    176  04b5		       0c		      .byte.b	%00001100
    177  04b6		       06		      .byte.b	%00000110
    178  04b7		       83		      .byte.b	%10000011
    179  04b8		       c1		      .byte.b	%11000001
    180  04b9
    181  04b9		       83		      .byte.b	%10000011
    182  04ba		       06		      .byte.b	%00000110
    183  04bb		       0c		      .byte.b	%00001100
    184  04bc		       18		      .byte.b	%00011000
    185  04bd		       30		      .byte.b	%00110000
    186  04be		       60		      .byte.b	%01100000
    187  04bf		       c1		      .byte.b	%11000001
    188  04c0		       83		      .byte.b	%10000011
    189  04c1
    190  04c1
    191  04c1							;---------------------------------------------------------------------------------------------------
    192  04c1
      0  04c1					      DEF	CopySinglePiece
      1  04c1				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  04c1				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  04c1				   CopySinglePiece
      4  04c1				   TEMPORARY_VAR SET	Overlay
      5  04c1				   TEMPORARY_OFFSET SET	0
      6  04c1				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  04c1				   FUNCTION_NAME SET	CopySinglePiece
    194  04c1					      SUBROUTINE
    195  04c1
      0  04c1					      TIMING	COPYSINGLEPIECE, (2600)
      1  04c1		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    197  04c1
      0  04c1					      REFER	showMoveCaptures	;✅
      1  04c1					      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  04c1				   TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  04c1					      ENDIF
      0  04c1					      REFER	aiDrawEntireBoard	;✅
      1  04c1				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  04c1					      ENDIF
      0  04c1					      REFER	aiDrawPart2	;✅
      1  04c1				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  04c1					      ENDIF
      0  04c1					      REFER	aiMarchB	;✅
      1  04c1				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  04c1					      ENDIF
      0  04c1					      REFER	aiFlashComputerMove	;✅
      1  04c1				  -	      IF	VAREND_aiFlashComputerMove > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiFlashComputerMove
      3  04c1					      ENDIF
      0  04c1					      REFER	aiSelectDestinationSquare	;✅
      1  04c1				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  04c1					      ENDIF
      0  04c1					      REFER	aiMarchA2	;✅
      1  04c1				  -	      IF	VAREND_aiMarchA2 > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchA2
      3  04c1					      ENDIF
      0  04c1					      REFER	aiMarchB2	;✅
      1  04c1				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  04c1					      ENDIF
      0  04c1					      REFER	aiWriteStartPieceBlank	;✅
      1  04c1				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  04c1					      ENDIF
      0  04c1					      REFER	aiChoosePromotePiece	;✅
      1  04c1				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  04c1					      ENDIF
      0  04c1					      REFER	aiMarchToTargetB	;✅
      1  04c1				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  04c1					      ENDIF
      0  04c1					      REFER	aiPromotePawnStart	;✅
      1  04c1				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  04c1					      ENDIF
      0  04c1					      REFER	aiFinalFlash	;✅
      1  04c1				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  04c1					      ENDIF
    211  04c1
    212  04c1
      0  04c1					      VEND	CopySinglePiece
      1  04c1				  -	      IFNCONST	CopySinglePiece
      2  04c1				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  04c1				  -	      ERR
      4  04c1					      ENDIF
      5  04c1		       00 ac	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    214  04c1
    215  04c1							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    216  04c1							; ALSO CAN'T USE IN THIS ROUTINE
    217  04c1							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    218  04c1							; @2150 max
    219  04c1							; = 33 TIM64T
    220  04c1
      0  04c1					      CALL	CopySetup	;@2
      1  04c1				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  04c1				  -FNAME      SETSTR	CopySetup
      3  04c1				  -	      ECHO	""
      4  04c1				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  04c1				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  04c1				  -	      ERR
      7  04c1					      ENDIF
      8  04c1		       a9 84		      lda	#BANK_CopySetup
      9  04c3		       85 3f		      sta	SET_BANK
     10  04c5		       20 8a f8 	      jsr	CopySetup
    222  04c8
    223  04c8
      0  04c8					      DEF	InterceptMarkerCopy
      1  04c8				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  04c8				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  04c8				   InterceptMarkerCopy
      4  04c8				   TEMPORARY_VAR SET	Overlay
      5  04c8				   TEMPORARY_OFFSET SET	0
      6  04c8				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  04c8				   FUNCTION_NAME SET	InterceptMarkerCopy
    225  04c8					      SUBROUTINE
    226  04c8
      0  04c8					      REFER	CopySinglePiece	;✅
      1  04c8					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  04c8				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  04c8					      ENDIF
      0  04c8					      REFER	showPromoteOptions	;✅
      1  04c8				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  04c8					      ENDIF
      0  04c8					      REFER	showMoveOptions	;✅
      1  04c8				  -	      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  04c8					      ENDIF
      0  04c8					      VEND	InterceptMarkerCopy
      1  04c8				  -	      IFNCONST	InterceptMarkerCopy
      2  04c8				  -	      ECHO	"Incorrect VEND label", InterceptMarkerCopy
      3  04c8				  -	      ERR
      4  04c8					      ENDIF
      5  04c8		       00 ac	   VAREND_InterceptMarkerCopy =	TEMPORARY_VAR
    231  04c8
    232  04c8							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    233  04c8							; y = piece index
    234  04c8
    235  04c8		       a9 84		      lda	#BANK_PIECE_VECTOR_BANK
    236  04ca		       85 3f		      sta	SET_BANK	;@2
    237  04cc
    238  04cc		       b9 e3 f9 	      lda	PIECE_VECTOR_LO,y
    239  04cf		       85 a2		      sta	__psb
    240  04d1		       b9 73 fa 	      lda	PIECE_VECTOR_HI,y
    241  04d4		       85 a3		      sta	__psb+1
    242  04d6		       b9 03 fb 	      lda	PIECE_VECTOR_BANK,y
    243  04d9		       85 3f		      sta	SET_BANK	;@2
    244  04db
    245  04db		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    246  04dd		       b1 a2	   .copy      lda	(__psb),y
    247  04df		       99 a7 00 	      sta	__pieceShapeBuffer,y
    248  04e2		       88		      dey
    249  04e3		       10 f8		      bpl	.copy
    250  04e5
    251  04e5		       a5 80		      lda	squareToDraw
    252  04e7		       38		      sec
    253  04e8		       a2 0a		      ldx	#10
    254  04ea		       e9 0a	   .sub10     sbc	#10
    255  04ec		       ca		      dex
    256  04ed		       b0 fb		      bcs	.sub10
    257  04ef
    258  04ef		       69 08		      adc	#8
    259  04f1		       c9 04		      cmp	#4	; CS = right side of screen
    260  04f3
    261  04f3		       8a		      txa
    262  04f4		       09 80		      ora	#[SLOT2]
    263  04f6		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    264  04f8
    265  04f8		       20 3e f3 	      jsr	CopyPieceToRowBitmap	;@3
    266  04fb		       60		      rts
    267  04fc
    268  04fc
    269  04fc							;---------------------------------------------------------------------------------------------------
    270  04fc
    271  04fc				   P	      SET	0
    272  04fc					      MAC	ain
    273  04fc				   AI_{1}     SET	P
    274  04fc				   P	      SET	P+1
    275  04fc					      ENDM
    276  04fc
    277  04fc					      MAC	lo
    278  04fc					      .byte	<ai{1}
    279  04fc					      ENDM
    280  04fc
    281  04fc					      MAC	hi
    282  04fc					      .byte	>ai{1}
    283  04fc					      ENDM
    284  04fc
    285  04fc					      MAC	bk
    286  04fc					      .byte	BANK_ai{1}
    287  04fc					      ENDM
    288  04fc
    289  04fc
    290  04fc		       00 28	   ONCEPERFRAME =	40
    291  04fc
    292  04fc					      MAC	tabdef
    293  04fc
    294  04fc					      {1}	FlashComputerMove	; 0
    295  04fc					      {1}	BeginSelectMovePhase	; 1
    296  04fc					      {1}	SelectStartSquare	; 2
    297  04fc					      {1}	StartSquareSelected	; 3
    298  04fc					      {1}	DrawMoves	; 4
    299  04fc					      {1}	ShowMoveCaptures	; 5
    300  04fc					      {1}	SlowFlash	; 6
    301  04fc					      {1}	UnDrawTargetSquares	; 7
    302  04fc					      {1}	SelectDestinationSquare	; 8
    303  04fc					      {1}	Quiescent	; 9
    304  04fc					      {1}	ReselectDebounce	; 10
    305  04fc					      {1}	StartMoveGen	; 11
    306  04fc					      {1}	StepMoveGen	; 12
    307  04fc					      {1}	StartClearBoard	; 13
    308  04fc					      {1}	ClearEachRow	; 14
    309  04fc					      {1}	DrawEntireBoard	; 15
    310  04fc					      {1}	DrawPart2	; 16
    311  04fc					      {1}	DrawPart3	; 17
    312  04fc					      {1}	GenerateMoves	; 18
    313  04fc					      {1}	ComputerMove	; 19
    314  04fc					      {1}	MoveIsSelected	; 20
    315  04fc					      {1}	WriteStartPieceBlank	; 21
    316  04fc					      {1}	MarchToTargetA	; 22
    317  04fc					      {1}	MarchA2	; 23
    318  04fc					      {1}	MarchB	; 24
    319  04fc					      {1}	MarchToTargetB	; 25
    320  04fc					      {1}	MarchB2	; 26
    321  04fc					      {1}	FinalFlash	; 27
    322  04fc					      {1}	SpecialMoveFixup	; 28
    323  04fc					      {1}	InCheckBackup	; 29
    324  04fc					      {1}	InCheckDelay	; 30
    325  04fc					      {1}	PromotePawnStart	; 31
    326  04fc					      {1}	RollPromotionPiece	; 32
    327  04fc					      {1}	ChoosePromotePiece	; 33
    328  04fc					      {1}	ChooseDebounce	; 34
    329  04fc					      {1}	CheckMate	; 35
    330  04fc					      {1}	Draw	; 36
    331  04fc					      {1}	DelayAfterMove	; 37
    332  04fc					      {1}	DelayAfterMove2	; 38
    333  04fc					      {1}	DelayAfterPlaced	; 39
    334  04fc					      {1}	DelayAfterPlaced2	; 40
    335  04fc					      {1}	EPHandler	; 41
    336  04fc					      {1}	EPFlash	; 42
    337  04fc					      {1}	DebounceSelect	; 43
    338  04fc
    339  04fc					      ENDM		; {1} = macro to use
    340  04fc
      0  04fc					      TABDEF	AIN
      1  04fc
      0  04fc					      AIN	FlashComputerMove
      1  04fc				   AI_FlashComputerMove SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	BeginSelectMovePhase
      1  04fc				   AI_BeginSelectMovePhase SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SelectStartSquare
      1  04fc				   AI_SelectStartSquare SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StartSquareSelected
      1  04fc				   AI_StartSquareSelected SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawMoves
      1  04fc				   AI_DrawMoves SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ShowMoveCaptures
      1  04fc				   AI_ShowMoveCaptures SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SlowFlash
      1  04fc				   AI_SlowFlash SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	UnDrawTargetSquares
      1  04fc				   AI_UnDrawTargetSquares SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SelectDestinationSquare
      1  04fc				   AI_SelectDestinationSquare SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	Quiescent
      1  04fc				   AI_Quiescent SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ReselectDebounce
      1  04fc				   AI_ReselectDebounce SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StartMoveGen
      1  04fc				   AI_StartMoveGen SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StepMoveGen
      1  04fc				   AI_StepMoveGen SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StartClearBoard
      1  04fc				   AI_StartClearBoard SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ClearEachRow
      1  04fc				   AI_ClearEachRow SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawEntireBoard
      1  04fc				   AI_DrawEntireBoard SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawPart2
      1  04fc				   AI_DrawPart2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawPart3
      1  04fc				   AI_DrawPart3 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	GenerateMoves
      1  04fc				   AI_GenerateMoves SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ComputerMove
      1  04fc				   AI_ComputerMove SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MoveIsSelected
      1  04fc				   AI_MoveIsSelected SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	WriteStartPieceBlank
      1  04fc				   AI_WriteStartPieceBlank SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchToTargetA
      1  04fc				   AI_MarchToTargetA SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchA2
      1  04fc				   AI_MarchA2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchB
      1  04fc				   AI_MarchB  SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchToTargetB
      1  04fc				   AI_MarchToTargetB SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchB2
      1  04fc				   AI_MarchB2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	FinalFlash
      1  04fc				   AI_FinalFlash SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SpecialMoveFixup
      1  04fc				   AI_SpecialMoveFixup SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	InCheckBackup
      1  04fc				   AI_InCheckBackup SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	InCheckDelay
      1  04fc				   AI_InCheckDelay SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	PromotePawnStart
      1  04fc				   AI_PromotePawnStart SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	RollPromotionPiece
      1  04fc				   AI_RollPromotionPiece SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ChoosePromotePiece
      1  04fc				   AI_ChoosePromotePiece SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ChooseDebounce
      1  04fc				   AI_ChooseDebounce SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	CheckMate
      1  04fc				   AI_CheckMate SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	Draw
      1  04fc				   AI_Draw    SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterMove
      1  04fc				   AI_DelayAfterMove SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterMove2
      1  04fc				   AI_DelayAfterMove2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterPlaced
      1  04fc				   AI_DelayAfterPlaced SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterPlaced2
      1  04fc				   AI_DelayAfterPlaced2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	EPHandler
      1  04fc				   AI_EPHandler SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	EPFlash
      1  04fc				   AI_EPFlash SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DebounceSelect
      1  04fc				   AI_DebounceSelect SET	P
      2  04fc				   P	      SET	P+1
     46  04fc
    342  04fc
      0  04fc					      DEF	AiVectorLO
      1  04fc				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  04fc				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  04fc				   AiVectorLO
      4  04fc				   TEMPORARY_VAR SET	Overlay
      5  04fc				   TEMPORARY_OFFSET SET	0
      6  04fc				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  04fc				   FUNCTION_NAME SET	AiVectorLO
      0  04fc					      TABDEF	LO
      1  04fc
      0  04fc					      LO	FlashComputerMove
      1  04fc		       3c		      .byte.b	<aiFlashComputerMove
      0  04fd					      LO	BeginSelectMovePhase
      1  04fd		       1d		      .byte.b	<aiBeginSelectMovePhase
      0  04fe					      LO	SelectStartSquare
      1  04fe		       75		      .byte.b	<aiSelectStartSquare
      0  04ff					      LO	StartSquareSelected
      1  04ff		       b4		      .byte.b	<aiStartSquareSelected
      0  0500					      LO	DrawMoves
      1  0500		       dd		      .byte.b	<aiDrawMoves
      0  0501					      LO	ShowMoveCaptures
      1  0501		       d1		      .byte.b	<aiShowMoveCaptures
      0  0502					      LO	SlowFlash
      1  0502		       f7		      .byte.b	<aiSlowFlash
      0  0503					      LO	UnDrawTargetSquares
      1  0503		       a7		      .byte.b	<aiUnDrawTargetSquares
      0  0504					      LO	SelectDestinationSquare
      1  0504		       20		      .byte.b	<aiSelectDestinationSquare
      0  0505					      LO	Quiescent
      1  0505		       24		      .byte.b	<aiQuiescent
      0  0506					      LO	ReselectDebounce
      1  0506		       14		      .byte.b	<aiReselectDebounce
      0  0507					      LO	StartMoveGen
      1  0507		       00		      .byte.b	<aiStartMoveGen
      0  0508					      LO	StepMoveGen
      1  0508		       ad		      .byte.b	<aiStepMoveGen
      0  0509					      LO	StartClearBoard
      1  0509		       2a		      .byte.b	<aiStartClearBoard
      0  050a					      LO	ClearEachRow
      1  050a		       37		      .byte.b	<aiClearEachRow
      0  050b					      LO	DrawEntireBoard
      1  050b		       b9		      .byte.b	<aiDrawEntireBoard
      0  050c					      LO	DrawPart2
      1  050c		       ed		      .byte.b	<aiDrawPart2
      0  050d					      LO	DrawPart3
      1  050d		       f0		      .byte.b	<aiDrawPart3
      0  050e					      LO	GenerateMoves
      1  050e		       9a		      .byte.b	<aiGenerateMoves
      0  050f					      LO	ComputerMove
      1  050f		       00		      .byte.b	<aiComputerMove
      0  0510					      LO	MoveIsSelected
      1  0510		       44		      .byte.b	<aiMoveIsSelected
      0  0511					      LO	WriteStartPieceBlank
      1  0511		       cf		      .byte.b	<aiWriteStartPieceBlank
      0  0512					      LO	MarchToTargetA
      1  0512		       38		      .byte.b	<aiMarchToTargetA
      0  0513					      LO	MarchA2
      1  0513		       51		      .byte.b	<aiMarchA2
      0  0514					      LO	MarchB
      1  0514		       0a		      .byte.b	<aiMarchB
      0  0515					      LO	MarchToTargetB
      1  0515		       54		      .byte.b	<aiMarchToTargetB
      0  0516					      LO	MarchB2
      1  0516		       7e		      .byte.b	<aiMarchB2
      0  0517					      LO	FinalFlash
      1  0517		       92		      .byte.b	<aiFinalFlash
      0  0518					      LO	SpecialMoveFixup
      1  0518		       54		      .byte.b	<aiSpecialMoveFixup
      0  0519					      LO	InCheckBackup
      1  0519		       05		      .byte.b	<aiInCheckBackup
      0  051a					      LO	InCheckDelay
      1  051a		       10		      .byte.b	<aiInCheckDelay
      0  051b					      LO	PromotePawnStart
      1  051b		       76		      .byte.b	<aiPromotePawnStart
      0  051c					      LO	RollPromotionPiece
      1  051c		       81		      .byte.b	<aiRollPromotionPiece
      0  051d					      LO	ChoosePromotePiece
      1  051d		       d4		      .byte.b	<aiChoosePromotePiece
      0  051e					      LO	ChooseDebounce
      1  051e		       00		      .byte.b	<aiChooseDebounce
      0  051f					      LO	CheckMate
      1  051f		       1f		      .byte.b	<aiCheckMate
      0  0520					      LO	Draw
      1  0520		       1a		      .byte.b	<aiDraw
      0  0521					      LO	DelayAfterMove
      1  0521		       1d		      .byte.b	<aiDelayAfterMove
      0  0522					      LO	DelayAfterMove2
      1  0522		       26		      .byte.b	<aiDelayAfterMove2
      0  0523					      LO	DelayAfterPlaced
      1  0523		       2f		      .byte.b	<aiDelayAfterPlaced
      0  0524					      LO	DelayAfterPlaced2
      1  0524		       3f		      .byte.b	<aiDelayAfterPlaced2
      0  0525					      LO	EPHandler
      1  0525		       a2		      .byte.b	<aiEPHandler
      0  0526					      LO	EPFlash
      1  0526		       6c		      .byte.b	<aiEPFlash
      0  0527					      LO	DebounceSelect
      1  0527		       be		      .byte.b	<aiDebounceSelect
     46  0528
    345  0528
      0  0528					      DEF	AiVectorHI
      1  0528				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  0528				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  0528				   AiVectorHI
      4  0528				   TEMPORARY_VAR SET	Overlay
      5  0528				   TEMPORARY_OFFSET SET	0
      6  0528				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  0528				   FUNCTION_NAME SET	AiVectorHI
      0  0528					      TABDEF	HI
      1  0528
      0  0528					      HI	FlashComputerMove
      1  0528		       f4		      .byte.b	>aiFlashComputerMove
      0  0529					      HI	BeginSelectMovePhase
      1  0529		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  052a					      HI	SelectStartSquare
      1  052a		       f4		      .byte.b	>aiSelectStartSquare
      0  052b					      HI	StartSquareSelected
      1  052b		       f5		      .byte.b	>aiStartSquareSelected
      0  052c					      HI	DrawMoves
      1  052c		       f4		      .byte.b	>aiDrawMoves
      0  052d					      HI	ShowMoveCaptures
      1  052d		       f5		      .byte.b	>aiShowMoveCaptures
      0  052e					      HI	SlowFlash
      1  052e		       f5		      .byte.b	>aiSlowFlash
      0  052f					      HI	UnDrawTargetSquares
      1  052f		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  0530					      HI	SelectDestinationSquare
      1  0530		       f6		      .byte.b	>aiSelectDestinationSquare
      0  0531					      HI	Quiescent
      1  0531		       f6		      .byte.b	>aiQuiescent
      0  0532					      HI	ReselectDebounce
      1  0532		       f4		      .byte.b	>aiReselectDebounce
      0  0533					      HI	StartMoveGen
      1  0533		       f4		      .byte.b	>aiStartMoveGen
      0  0534					      HI	StepMoveGen
      1  0534		       f4		      .byte.b	>aiStepMoveGen
      0  0535					      HI	StartClearBoard
      1  0535		       f8		      .byte.b	>aiStartClearBoard
      0  0536					      HI	ClearEachRow
      1  0536		       f8		      .byte.b	>aiClearEachRow
      0  0537					      HI	DrawEntireBoard
      1  0537		       f5		      .byte.b	>aiDrawEntireBoard
      0  0538					      HI	DrawPart2
      1  0538		       f5		      .byte.b	>aiDrawPart2
      0  0539					      HI	DrawPart3
      1  0539		       f5		      .byte.b	>aiDrawPart3
      0  053a					      HI	GenerateMoves
      1  053a		       f4		      .byte.b	>aiGenerateMoves
      0  053b					      HI	ComputerMove
      1  053b		       f4		      .byte.b	>aiComputerMove
      0  053c					      HI	MoveIsSelected
      1  053c		       f8		      .byte.b	>aiMoveIsSelected
      0  053d					      HI	WriteStartPieceBlank
      1  053d		       f5		      .byte.b	>aiWriteStartPieceBlank
      0  053e					      HI	MarchToTargetA
      1  053e		       f5		      .byte.b	>aiMarchToTargetA
      0  053f					      HI	MarchA2
      1  053f		       f7		      .byte.b	>aiMarchA2
      0  0540					      HI	MarchB
      1  0540		       f6		      .byte.b	>aiMarchB
      0  0541					      HI	MarchToTargetB
      1  0541		       f4		      .byte.b	>aiMarchToTargetB
      0  0542					      HI	MarchB2
      1  0542		       f7		      .byte.b	>aiMarchB2
      0  0543					      HI	FinalFlash
      1  0543		       f5		      .byte.b	>aiFinalFlash
      0  0544					      HI	SpecialMoveFixup
      1  0544		       f5		      .byte.b	>aiSpecialMoveFixup
      0  0545					      HI	InCheckBackup
      1  0545		       f4		      .byte.b	>aiInCheckBackup
      0  0546					      HI	InCheckDelay
      1  0546		       f4		      .byte.b	>aiInCheckDelay
      0  0547					      HI	PromotePawnStart
      1  0547		       f4		      .byte.b	>aiPromotePawnStart
      0  0548					      HI	RollPromotionPiece
      1  0548		       f6		      .byte.b	>aiRollPromotionPiece
      0  0549					      HI	ChoosePromotePiece
      1  0549		       f6		      .byte.b	>aiChoosePromotePiece
      0  054a					      HI	ChooseDebounce
      1  054a		       f4		      .byte.b	>aiChooseDebounce
      0  054b					      HI	CheckMate
      1  054b		       f6		      .byte.b	>aiCheckMate
      0  054c					      HI	Draw
      1  054c		       f6		      .byte.b	>aiDraw
      0  054d					      HI	DelayAfterMove
      1  054d		       f4		      .byte.b	>aiDelayAfterMove
      0  054e					      HI	DelayAfterMove2
      1  054e		       f4		      .byte.b	>aiDelayAfterMove2
      0  054f					      HI	DelayAfterPlaced
      1  054f		       f4		      .byte.b	>aiDelayAfterPlaced
      0  0550					      HI	DelayAfterPlaced2
      1  0550		       f4		      .byte.b	>aiDelayAfterPlaced2
      0  0551					      HI	EPHandler
      1  0551		       f7		      .byte.b	>aiEPHandler
      0  0552					      HI	EPFlash
      1  0552		       f5		      .byte.b	>aiEPFlash
      0  0553					      HI	DebounceSelect
      1  0553		       f4		      .byte.b	>aiDebounceSelect
     46  0554
    348  0554
      0  0554					      DEF	AiVectorBANK
      1  0554				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  0554				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  0554				   AiVectorBANK
      4  0554				   TEMPORARY_VAR SET	Overlay
      5  0554				   TEMPORARY_OFFSET SET	0
      6  0554				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  0554				   FUNCTION_NAME SET	AiVectorBANK
      0  0554					      TABDEF	BK
      1  0554
      0  0554					      BK	FlashComputerMove
      1  0554		       4d		      .byte.b	BANK_aiFlashComputerMove
      0  0555					      BK	BeginSelectMovePhase
      1  0555		       4d		      .byte.b	BANK_aiBeginSelectMovePhase
      0  0556					      BK	SelectStartSquare
      1  0556		       4d		      .byte.b	BANK_aiSelectStartSquare
      0  0557					      BK	StartSquareSelected
      1  0557		       4e		      .byte.b	BANK_aiStartSquareSelected
      0  0558					      BK	DrawMoves
      1  0558		       4d		      .byte.b	BANK_aiDrawMoves
      0  0559					      BK	ShowMoveCaptures
      1  0559		       4d		      .byte.b	BANK_aiShowMoveCaptures
      0  055a					      BK	SlowFlash
      1  055a		       4d		      .byte.b	BANK_aiSlowFlash
      0  055b					      BK	UnDrawTargetSquares
      1  055b		       4d		      .byte.b	BANK_aiUnDrawTargetSquares
      0  055c					      BK	SelectDestinationSquare
      1  055c		       4d		      .byte.b	BANK_aiSelectDestinationSquare
      0  055d					      BK	Quiescent
      1  055d		       42		      .byte.b	BANK_aiQuiescent
      0  055e					      BK	ReselectDebounce
      1  055e		       4e		      .byte.b	BANK_aiReselectDebounce
      0  055f					      BK	StartMoveGen
      1  055f		       4d		      .byte.b	BANK_aiStartMoveGen
      0  0560					      BK	StepMoveGen
      1  0560		       4e		      .byte.b	BANK_aiStepMoveGen
      0  0561					      BK	StartClearBoard
      1  0561		       84		      .byte.b	BANK_aiStartClearBoard
      0  0562					      BK	ClearEachRow
      1  0562		       84		      .byte.b	BANK_aiClearEachRow
      0  0563					      BK	DrawEntireBoard
      1  0563		       42		      .byte.b	BANK_aiDrawEntireBoard
      0  0564					      BK	DrawPart2
      1  0564		       42		      .byte.b	BANK_aiDrawPart2
      0  0565					      BK	DrawPart3
      1  0565		       42		      .byte.b	BANK_aiDrawPart3
      0  0566					      BK	GenerateMoves
      1  0566		       4e		      .byte.b	BANK_aiGenerateMoves
      0  0567					      BK	ComputerMove
      1  0567		       59		      .byte.b	BANK_aiComputerMove
      0  0568					      BK	MoveIsSelected
      1  0568		       84		      .byte.b	BANK_aiMoveIsSelected
      0  0569					      BK	WriteStartPieceBlank
      1  0569		       4e		      .byte.b	BANK_aiWriteStartPieceBlank
      0  056a					      BK	MarchToTargetA
      1  056a		       4e		      .byte.b	BANK_aiMarchToTargetA
      0  056b					      BK	MarchA2
      1  056b		       4d		      .byte.b	BANK_aiMarchA2
      0  056c					      BK	MarchB
      1  056c		       42		      .byte.b	BANK_aiMarchB
      0  056d					      BK	MarchToTargetB
      1  056d		       4e		      .byte.b	BANK_aiMarchToTargetB
      0  056e					      BK	MarchB2
      1  056e		       4d		      .byte.b	BANK_aiMarchB2
      0  056f					      BK	FinalFlash
      1  056f		       4e		      .byte.b	BANK_aiFinalFlash
      0  0570					      BK	SpecialMoveFixup
      1  0570		       42		      .byte.b	BANK_aiSpecialMoveFixup
      0  0571					      BK	InCheckBackup
      1  0571		       4d		      .byte.b	BANK_aiInCheckBackup
      0  0572					      BK	InCheckDelay
      1  0572		       4d		      .byte.b	BANK_aiInCheckDelay
      0  0573					      BK	PromotePawnStart
      1  0573		       4e		      .byte.b	BANK_aiPromotePawnStart
      0  0574					      BK	RollPromotionPiece
      1  0574		       4d		      .byte.b	BANK_aiRollPromotionPiece
      0  0575					      BK	ChoosePromotePiece
      1  0575		       4d		      .byte.b	BANK_aiChoosePromotePiece
      0  0576					      BK	ChooseDebounce
      1  0576		       4e		      .byte.b	BANK_aiChooseDebounce
      0  0577					      BK	CheckMate
      1  0577		       42		      .byte.b	BANK_aiCheckMate
      0  0578					      BK	Draw
      1  0578		       42		      .byte.b	BANK_aiDraw
      0  0579					      BK	DelayAfterMove
      1  0579		       4e		      .byte.b	BANK_aiDelayAfterMove
      0  057a					      BK	DelayAfterMove2
      1  057a		       4e		      .byte.b	BANK_aiDelayAfterMove2
      0  057b					      BK	DelayAfterPlaced
      1  057b		       4e		      .byte.b	BANK_aiDelayAfterPlaced
      0  057c					      BK	DelayAfterPlaced2
      1  057c		       4e		      .byte.b	BANK_aiDelayAfterPlaced2
      0  057d					      BK	EPHandler
      1  057d		       4d		      .byte.b	BANK_aiEPHandler
      0  057e					      BK	EPFlash
      1  057e		       42		      .byte.b	BANK_aiEPFlash
      0  057f					      BK	DebounceSelect
      1  057f		       4d		      .byte.b	BANK_aiDebounceSelect
     46  0580
    351  0580
    352  0580
    353  0580							;---------------------------------------------------------------------------------------------------
    354  0580
      0  0580					      DEF	AiStateMachine
      1  0580				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0580				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0580				   AiStateMachine
      4  0580				   TEMPORARY_VAR SET	Overlay
      5  0580				   TEMPORARY_OFFSET SET	0
      6  0580				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0580				   FUNCTION_NAME SET	AiStateMachine
    356  0580					      SUBROUTINE
    357  0580
      0  0580					      REFER	StartupBankReset	;✅
      1  0580				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0580				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0580					      ENDIF
      0  0580					      VAR	__aiVec, 2
      1  0580		       00 a7	   __aiVec    =	TEMPORARY_VAR
      2  0580				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0580
      4  0580				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0580				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0580				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0580					      ENDIF
      8  0580				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0580				  -	      ECHO	"Temporary Variable", __aiVec, "overflow!"
     10  0580				  -	      ERR
     11  0580					      ENDIF
     12  0580					      LIST	ON
      0  0580					      VEND	AiStateMachine
      1  0580				  -	      IFNCONST	AiStateMachine
      2  0580				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  0580				  -	      ERR
      4  0580					      ENDIF
      5  0580		       00 a9	   VAREND_AiStateMachine =	TEMPORARY_VAR
    361  0580
    362  0580
    363  0580							; State machine vector setup - points to current routine to execute
    364  0580
    365  0580		       a6 8b		      ldx	aiState
    366  0582		       bd fc f0 	      lda	AiVectorLO,x
    367  0585		       85 a7		      sta	__aiVec
    368  0587		       bd 28 f1 	      lda	AiVectorHI,x
    369  058a		       85 a8		      sta	__aiVec+1
    370  058c
    371  058c		       bd 54 f1 	      lda	AiVectorBANK,x
    372  058f		       85 3f		      sta	SET_BANK
    373  0591		       6c a7 00 	      jmp	(__aiVec)	; NOTE: could branch back to squeeze cycles
    374  0594
    375  0594
    376  0594							;---------------------------------------------------------------------------------------------------
    377  0594
      0  0594					      DEF	GenerateAllMoves
      1  0594				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  0594				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  0594				   GenerateAllMoves
      4  0594				   TEMPORARY_VAR SET	Overlay
      5  0594				   TEMPORARY_OFFSET SET	0
      6  0594				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  0594				   FUNCTION_NAME SET	GenerateAllMoves
    379  0594					      SUBROUTINE
    380  0594
      0  0594					      REFER	ListPlayerMoves	;✅
      1  0594					      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0594				   TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0594					      ENDIF
      0  0594					      REFER	aiComputerMove	;✅
      1  0594				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  0594				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  0594					      ENDIF
      0  0594					      REFER	quiesce	;✅
      1  0594				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0594				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0594					      ENDIF
      0  0594					      REFER	negaMax	;✅
      1  0594				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0594				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0594					      ENDIF
    385  0594
      0  0594					      VAR	__vector, 2
      1  0594		       00 b5	   __vector   =	TEMPORARY_VAR
      2  0594				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0594
      4  0594				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0594					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0594				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0594					      ENDIF
      8  0594				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0594				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  0594				  -	      ERR
     11  0594					      ENDIF
     12  0594					      LIST	ON
      0  0594					      VAR	__pieceFilter, 1
      1  0594		       00 b7	   __pieceFilter =	TEMPORARY_VAR
      2  0594				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0594
      4  0594				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0594					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0594				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0594					      ENDIF
      8  0594				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0594				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  0594				  -	      ERR
     11  0594					      ENDIF
     12  0594					      LIST	ON
    388  0594
      0  0594					      VEND	GenerateAllMoves
      1  0594				  -	      IFNCONST	GenerateAllMoves
      2  0594				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  0594				  -	      ERR
      4  0594					      ENDIF
      5  0594		       00 b8	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    390  0594
    391  0594							; Do the move generation in two passes - pawns then pieces
    392  0594							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    393  0594
    394  0594							;{
    395  0594
    396  0594							; This MUST be called at the start of a new ply
    397  0594							; It initialises the movelist to empty
    398  0594							; x must be preserved
    399  0594
    400  0594		       a5 94		      lda	currentPly
    401  0596		       85 3e		      sta	SET_BANK_RAM	;@2
    402  0598
    403  0598							; note that 'alpha' and 'beta' are set externally!!
    404  0598
    405  0598		       a9 ff		      lda	#-1
      0  059a					      sta@PLY	moveIndex	; no valid moves
      1  059a		       8d cf fb 	      sta	[RAM]+moveIndex
      0  059d					      sta@PLY	bestMove
      1  059d		       8d d1 fb 	      sta	[RAM]+bestMove
    408  05a0
    409  05a0		       a5 93		      lda	enPassantPawn	; flag/square from last actual move made
      0  05a2					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  05a2		       8d ca fb 	      sta	[RAM]+enPassantSquare
    411  05a5
    412  05a5		       a5 a4		      lda	vkSquare
      0  05a7					      sta@PLY	virtualKingSquare
      1  05a7		       8d da fb 	      sta	[RAM]+virtualKingSquare
    414  05aa		       a5 a5		      lda	vkSquare+1
      0  05ac					      sta@PLY	virtualKingSquare+1	; traversal squares of king for castling
      1  05ac		       8d db fb 	      sta	[RAM]+virtualKingSquare+1
    416  05af
    417  05af							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    418  05af							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    419  05af							; start of each new ply.
    420  05af
    421  05af		       a5 8f		      lda	Evaluation
      0  05b1					      sta@PLY	savedEvaluation
      1  05b1		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    423  05b4		       a5 90		      lda	Evaluation+1
      0  05b6					      sta@PLY	savedEvaluation+1
      1  05b6		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    425  05b9							;}
    426  05b9
    427  05b9
    428  05b9
    429  05b9		       a9 08		      lda	#8	; pawns
    430  05bb		       85 b7		      sta	__pieceFilter
    431  05bd		       20 ce f1 	      jsr	MoveGenX
    432  05c0							;lda #99
    433  05c0							;sta currentSquare
    434  05c0		       a9 00		      lda	#0
    435  05c2		       85 b7		      sta	__pieceFilter
    436  05c4		       20 ce f1 	      jsr	MoveGenX
    437  05c7
    438  05c7		       a9 59		      lda	#BANK_Sort
    439  05c9		       85 3f		      sta	SET_BANK
    440  05cb		       4c 32 f6 	      jmp	Sort	;@1
    441  05ce
    442  05ce
    443  05ce
      0  05ce					      DEF	MoveGenX
      1  05ce				   SLOT_MoveGenX SET	_BANK_SLOT
      2  05ce				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  05ce				   MoveGenX
      4  05ce				   TEMPORARY_VAR SET	Overlay
      5  05ce				   TEMPORARY_OFFSET SET	0
      6  05ce				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  05ce				   FUNCTION_NAME SET	MoveGenX
    445  05ce					      SUBROUTINE
    446  05ce
    447  05ce		       a9 d2		      lda	#RAMBANK_BOARD
    448  05d0		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    449  05d2
    450  05d2		       a2 64		      ldx	#100
    451  05d4		       d0 02		      bne	.next
    452  05d6
      0  05d6					      DEF	MoveReturn
      1  05d6				   SLOT_MoveReturn SET	_BANK_SLOT
      2  05d6				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  05d6				   MoveReturn
      4  05d6				   TEMPORARY_VAR SET	Overlay
      5  05d6				   TEMPORARY_OFFSET SET	0
      6  05d6				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  05d6				   FUNCTION_NAME SET	MoveReturn
    454  05d6
    455  05d6		       a6 92		      ldx	currentSquare
    456  05d8		       ca	   .next      dex
    457  05d9		       e0 16		      cpx	#22
    458  05db		       90 2c		      bcc	.exit
    459  05dd
    460  05dd		       bd 79 fc 	      lda	Board,x
    461  05e0		       f0 f6		      beq	.next
    462  05e2		       c9 ff		      cmp	#-1
    463  05e4		       f0 f2		      beq	.next
    464  05e6		       45 95		      eor	sideToMove
    465  05e8		       30 ee		      bmi	.next
    466  05ea
    467  05ea		       86 92		      stx	currentSquare
    468  05ec
    469  05ec		       45 95		      eor	sideToMove
    470  05ee		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    471  05f0		       85 91		      sta	currentPiece
    472  05f2		       29 0f		      and	#PIECE_MASK
    473  05f4		       05 b7		      ora	__pieceFilter
    474  05f6		       a8		      tay
    475  05f7
    476  05f7		       b9 1e f2 	      lda	HandlerVectorHI,y
    477  05fa		       85 b6		      sta	__vector+1
    478  05fc		       b9 0e f2 	      lda	HandlerVectorLO,y
    479  05ff		       85 b5		      sta	__vector
    480  0601
    481  0601		       b9 2e f2 	      lda	HandlerVectorBANK,y
    482  0604		       85 3f		      sta	SET_BANK	;@1
    483  0606
    484  0606		       6c b5 00 	      jmp	(__vector)
    485  0609
    486  0609
    487  0609		       a9 59	   .exit      lda	#BANK_negaMax
    488  060b		       85 3f		      sta	SET_BANK
    489  060d		       60		      rts
    490  060e
    491  060e					      MAC	handlevec
    492  060e
    493  060e					      .byte	{1}MoveReturn
    494  060e					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
    495  060e					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
    496  060e					      .byte	{1}Handle_KNIGHT	; 3
    497  060e					      .byte	{1}Handle_BISHOP	; 4
    498  060e					      .byte	{1}Handle_ROOK	; 5
    499  060e					      .byte	{1}Handle_QUEEN	; 6
    500  060e					      .byte	{1}Handle_KING	; 7
    501  060e
    502  060e					      .byte	{1}MoveReturn
    503  060e					      .byte	{1}Handle_WHITE_PAWN	; 1
    504  060e					      .byte	{1}Handle_BLACK_PAWN	; 2
    505  060e					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
    506  060e					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
    507  060e					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
    508  060e					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
    509  060e					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
    510  060e					      ENDM
    511  060e
    512  060e
    513  060e							;    .byte 0	  ; dummy to prevent page cross access on index 0
    514  060e
      0  060e					      DEF	HandlerVectorLO
      1  060e				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  060e				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  060e				   HandlerVectorLO
      4  060e				   TEMPORARY_VAR SET	Overlay
      5  060e				   TEMPORARY_OFFSET SET	0
      6  060e				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  060e				   FUNCTION_NAME SET	HandlerVectorLO
      0  060e					      HANDLEVEC	<
      1  060e
      2  060e		       d6		      .byte.b	<MoveReturn
      3  060f		       d6		      .byte.b	<MoveReturn
      4  0610		       d6		      .byte.b	<MoveReturn
      5  0611		       a8		      .byte.b	<Handle_KNIGHT
      6  0612		       51		      .byte.b	<Handle_BISHOP
      7  0613		       00		      .byte.b	<Handle_ROOK
      8  0614		       7b		      .byte.b	<Handle_QUEEN
      9  0615		       6e		      .byte.b	<Handle_KING
     10  0616
     11  0616		       d6		      .byte.b	<MoveReturn
     12  0617		       29		      .byte.b	<Handle_WHITE_PAWN
     13  0618		       fd		      .byte.b	<Handle_BLACK_PAWN
     14  0619		       d6		      .byte.b	<MoveReturn
     15  061a		       d6		      .byte.b	<MoveReturn
     16  061b		       d6		      .byte.b	<MoveReturn
     17  061c		       d6		      .byte.b	<MoveReturn
     18  061d		       d6		      .byte.b	<MoveReturn
      0  061e					      DEF	HandlerVectorHI
      1  061e				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  061e				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  061e				   HandlerVectorHI
      4  061e				   TEMPORARY_VAR SET	Overlay
      5  061e				   TEMPORARY_OFFSET SET	0
      6  061e				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  061e				   FUNCTION_NAME SET	HandlerVectorHI
      0  061e					      HANDLEVEC	>
      1  061e
      2  061e		       f1		      .byte.b	>MoveReturn
      3  061f		       f1		      .byte.b	>MoveReturn
      4  0620		       f1		      .byte.b	>MoveReturn
      5  0621		       f5		      .byte.b	>Handle_KNIGHT
      6  0622		       f6		      .byte.b	>Handle_BISHOP
      7  0623		       f4		      .byte.b	>Handle_ROOK
      8  0624		       f4		      .byte.b	>Handle_QUEEN
      9  0625		       f5		      .byte.b	>Handle_KING
     10  0626
     11  0626		       f1		      .byte.b	>MoveReturn
     12  0627		       f4		      .byte.b	>Handle_WHITE_PAWN
     13  0628		       f4		      .byte.b	>Handle_BLACK_PAWN
     14  0629		       f1		      .byte.b	>MoveReturn
     15  062a		       f1		      .byte.b	>MoveReturn
     16  062b		       f1		      .byte.b	>MoveReturn
     17  062c		       f1		      .byte.b	>MoveReturn
     18  062d		       f1		      .byte.b	>MoveReturn
      0  062e					      DEF	HandlerVectorBANK
      1  062e				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  062e				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  062e				   HandlerVectorBANK
      4  062e				   TEMPORARY_VAR SET	Overlay
      5  062e				   TEMPORARY_OFFSET SET	0
      6  062e				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  062e				   FUNCTION_NAME SET	HandlerVectorBANK
      0  062e					      HANDLEVEC	BANK_
      1  062e
      2  062e		       01		      .byte.b	BANK_MoveReturn
      3  062f		       01		      .byte.b	BANK_MoveReturn
      4  0630		       01		      .byte.b	BANK_MoveReturn
      5  0631		       5a		      .byte.b	BANK_Handle_KNIGHT
      6  0632		       5a		      .byte.b	BANK_Handle_BISHOP
      7  0633		       5b		      .byte.b	BANK_Handle_ROOK
      8  0634		       5b		      .byte.b	BANK_Handle_QUEEN
      9  0635		       5b		      .byte.b	BANK_Handle_KING
     10  0636
     11  0636		       01		      .byte.b	BANK_MoveReturn
     12  0637		       5a		      .byte.b	BANK_Handle_WHITE_PAWN
     13  0638		       5a		      .byte.b	BANK_Handle_BLACK_PAWN
     14  0639		       01		      .byte.b	BANK_MoveReturn
     15  063a		       01		      .byte.b	BANK_MoveReturn
     16  063b		       01		      .byte.b	BANK_MoveReturn
     17  063c		       01		      .byte.b	BANK_MoveReturn
     18  063d		       01		      .byte.b	BANK_MoveReturn
    521  063e
    522  063e
    523  063e							;---------------------------------------------------------------------------------------------------
    524  063e
      0  063e					      DEF	ListPlayerMoves
      1  063e				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  063e				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  063e				   ListPlayerMoves
      4  063e				   TEMPORARY_VAR SET	Overlay
      5  063e				   TEMPORARY_OFFSET SET	0
      6  063e				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  063e				   FUNCTION_NAME SET	ListPlayerMoves
    526  063e					      SUBROUTINE
    527  063e
    528  063e							; Build a list of (mostly) valid player moves. The list of all moves is generated, and then
    529  063e							; these are each verified by making the move and listing all opponent moves. If the opponent
    530  063e							; can capture the king, the move is invalidated by setting its "from" square to zero.
    531  063e
    532  063e							; The movelist is built in the second ply so as not to stomp on the movelist from the computer
    533  063e							; on the previous response. This allows the player movelist to be generated BEFORE the
    534  063e							; computer's move has been visually shown on the screen.
    535  063e
    536  063e							; This in turn requires the minimum memory for PLY banks to be 3 (computer, player, response)
    537  063e
      0  063e					      COMMON_VARS
      1  063e
      0  063e					      VAR	__thinkbar, 1
      1  063e		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
      0  063e					      VAR	__toggle, 1
      1  063e		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
      4  063e
      0  063e					      VAR	__bestMove, 1
      1  063e		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
      0  063e					      VAR	__alpha, 2
      1  063e		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
      0  063e					      VAR	__beta, 2
      1  063e		       00 ac	   __beta     =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
      0  063e					      VAR	__negaMax, 2
      1  063e		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
      0  063e					      VAR	__value, 2
      1  063e		       00 b0	   __value    =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
     10  063e
      0  063e					      VAR	__quiesceCapOnly, 1
      1  063e		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
     12  063e
      0  063e					      VAR	__originalPiece, 1
      1  063e		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
      0  063e					      VAR	__capturedPiece, 1
      1  063e		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  063e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  063e
      4  063e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  063e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  063e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  063e					      ENDIF
      8  063e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  063e				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  063e				  -	      ERR
     11  063e					      ENDIF
     12  063e					      LIST	ON
     15  063e
      0  063e					      REFER	selectmove	;✅
      1  063e				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  063e				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  063e					      ENDIF
      0  063e					      REFER	StartupBankReset	;✅
      1  063e				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  063e				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  063e					      ENDIF
    541  063e
      0  063e					      VEND	ListPlayerMoves
      1  063e				  -	      IFNCONST	ListPlayerMoves
      2  063e				  -	      ECHO	"Incorrect VEND label", ListPlayerMoves
      3  063e				  -	      ERR
      4  063e					      ENDIF
      5  063e		       00 b5	   VAREND_ListPlayerMoves =	TEMPORARY_VAR
    543  063e
    544  063e
    545  063e		       a9 00		      lda	#0
    546  0640		       85 b2		      sta	__quiesceCapOnly	; gen ALL moves
    547  0642
    548  0642		       a9 89		      lda	#RAMBANK_PLY+1
    549  0644		       85 94		      sta	currentPly
    550  0646
    551  0646		       20 94 f1 	      jsr	GenerateAllMoves	;@this
    552  0649
      0  0649					      ldx@PLY	moveIndex
      1  0649		       ae cf f9 	      ldx	moveIndex
      0  064c				   .scan      stx@PLY	movePtr
      1  064c		       8e d0 fb 	      stx	[RAM]+movePtr
    555  064f
      0  064f					      CALL	MakeMove	;@1
      1  064f				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  064f				  -FNAME      SETSTR	MakeMove
      3  064f				  -	      ECHO	""
      4  064f				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  064f				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  064f				  -	      ERR
      7  064f					      ENDIF
      8  064f		       a9 59		      lda	#BANK_MakeMove
      9  0651		       85 3f		      sta	SET_BANK
     10  0653		       20 8b f4 	      jsr	MakeMove
    557  0656
    558  0656		       e6 94		      inc	currentPly
    559  0658		       20 94 f1 	      jsr	GenerateAllMoves	;@this
    560  065b
    561  065b		       c6 94		      dec	currentPly
    562  065d
    563  065d		       20 9b f2 	      jsr	unmakeMove	;@this
    564  0660
    565  0660		       a5 9f		      lda	flagCheck
    566  0662		       f0 08		      beq	.next
    567  0664
      0  0664					      ldx@PLY	movePtr
      1  0664		       ae d0 f9 	      ldx	movePtr
    569  0667		       a9 00		      lda	#0
      0  0669					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  0669		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    571  066c
      0  066c				   .next      ldx@PLY	movePtr
      1  066c		       ae d0 f9 	      ldx	movePtr
    573  066f		       ca		      dex
    574  0670		       10 da		      bpl	.scan
    575  0672
    576  0672		       60		      rts
    577  0673
    578  0673
    579  0673							;---------------------------------------------------------------------------------------------------
    580  0673
      0  0673					      DEF	AddMove
      1  0673				   SLOT_AddMove SET	_BANK_SLOT
      2  0673				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  0673				   AddMove
      4  0673				   TEMPORARY_VAR SET	Overlay
      5  0673				   TEMPORARY_OFFSET SET	0
      6  0673				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  0673				   FUNCTION_NAME SET	AddMove
    582  0673					      SUBROUTINE
    583  0673
      0  0673					      REFER	Handle_KING	;✅
      1  0673					      IF	VAREND_Handle_KING > TEMPORARY_VAR
      2  0673				   TEMPORARY_VAR SET	VAREND_Handle_KING
      3  0673					      ENDIF
      0  0673					      REFER	Handle_QUEEN	;✅
      1  0673				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  0673				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  0673					      ENDIF
      0  0673					      REFER	Handle_ROOK	;✅
      1  0673				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  0673				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  0673					      ENDIF
      0  0673					      REFER	Handle_BISHOP	;✅
      1  0673				  -	      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  0673				  -TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  0673					      ENDIF
      0  0673					      REFER	Handle_KNIGHT	;✅
      1  0673				  -	      IF	VAREND_Handle_KNIGHT > TEMPORARY_VAR
      2  0673				  -TEMPORARY_VAR SET	VAREND_Handle_KNIGHT
      3  0673					      ENDIF
      0  0673					      REFER	Handle_WHITE_PAWN	;✅
      1  0673				  -	      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  0673				  -TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  0673					      ENDIF
      0  0673					      REFER	Handle_BLACK_PAWN	;✅
      1  0673				  -	      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  0673				  -TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  0673					      ENDIF
    591  0673
      0  0673					      VEND	AddMove
      1  0673				  -	      IFNCONST	AddMove
      2  0673				  -	      ECHO	"Incorrect VEND label", AddMove
      3  0673				  -	      ERR
      4  0673					      ENDIF
      5  0673		       00 b8	   VAREND_AddMove =	TEMPORARY_VAR
    593  0673
    594  0673							; add square in y register to movelist as destination (X12 format)
    595  0673							; [y]		     to square (X12)
    596  0673							; currentSquare     from square (X12)
    597  0673							; currentPiece      piece.
    598  0673							;   ENPASSANT flag set if pawn double-moving off opening rank
    599  0673							; capture	     captured piece
    600  0673
    601  0673
    602  0673		       a5 9b		      lda	capture
    603  0675		       d0 04		      bne	.always
    604  0677		       a5 b2		      lda	__quiesceCapOnly
    605  0679		       d0 1c		      bne	.abort
    606  067b
    607  067b		       98	   .always    tya
    608  067c		       aa		      tax
    609  067d
      0  067d					      ldy@PLY	moveIndex
      1  067d		       ac cf f9 	      ldy	moveIndex
    611  0680		       c8		      iny
      0  0681					      sty@PLY	moveIndex
      1  0681		       8c cf fb 	      sty	[RAM]+moveIndex
    613  0684
      0  0684					      sta@PLY	MoveTo,y
      1  0684		       99 64 fa 	      sta	[RAM]+MoveTo,y
    615  0687		       a5 92		      lda	currentSquare
      0  0689					      sta@PLY	MoveFrom,y
      1  0689		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    617  068c		       a5 91		      lda	currentPiece
      0  068e					      sta@PLY	MovePiece,y
      1  068e		       99 00 fb 	      sta	[RAM]+MovePiece,y
    619  0691		       a5 9b		      lda	capture
      0  0693					      sta@PLY	MoveCapture,y
      1  0693		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    621  0696		       60		      rts
    622  0697
    623  0697		       98	   .abort     tya
    624  0698		       aa		      tax
    625  0699		       60		      rts
    626  069a
    627  069a
    628  069a
    629  069a							;---------------------------------------------------------------------------------------------------
    630  069a
      0  069a					      DEF	debug
      1  069a				   SLOT_debug SET	_BANK_SLOT
      2  069a				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  069a				   debug
      4  069a				   TEMPORARY_VAR SET	Overlay
      5  069a				   TEMPORARY_OFFSET SET	0
      6  069a				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  069a				   FUNCTION_NAME SET	debug
    632  069a					      SUBROUTINE
    633  069a		       60		      rts
    634  069b
    635  069b
    636  069b							;---------------------------------------------------------------------------------------------------
    637  069b
      0  069b					      DEF	unmakeMove
      1  069b				   SLOT_unmakeMove SET	_BANK_SLOT
      2  069b				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  069b				   unmakeMove
      4  069b				   TEMPORARY_VAR SET	Overlay
      5  069b				   TEMPORARY_OFFSET SET	0
      6  069b				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  069b				   FUNCTION_NAME SET	unmakeMove
    639  069b					      SUBROUTINE
    640  069b
      0  069b					      REFER	selectmove	;✅
      1  069b					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  069b				   TEMPORARY_VAR SET	VAREND_selectmove
      3  069b					      ENDIF
      0  069b					      REFER	ListPlayerMoves	;✅
      1  069b				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  069b				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  069b					      ENDIF
      0  069b					      REFER	quiesce	;✅
      1  069b				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  069b				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  069b					      ENDIF
      0  069b					      REFER	negaMax	;✅
      1  069b				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  069b				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  069b					      ENDIF
      0  069b					      VEND	unmakeMove
      1  069b				  -	      IFNCONST	unmakeMove
      2  069b				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  069b				  -	      ERR
      4  069b					      ENDIF
      5  069b		       00 b5	   VAREND_unmakeMove =	TEMPORARY_VAR
    646  069b
    647  069b							; restore the board evaluation to what it was at the start of this ply
    648  069b							; TODO: note: moved flag seems wrong on restoration??
    649  069b
    650  069b		       a5 94		      lda	currentPly
    651  069d		       85 3e		      sta	SET_BANK_RAM	;@2
    652  069f		       a2 d2		      ldx	#RAMBANK_BOARD
    653  06a1		       86 3e		      stx	SET_BANK_RAM	;@3
    654  06a3
      0  06a3					      lda@PLY	savedEvaluation
      1  06a3		       ad c8 f9 	      lda	savedEvaluation
    656  06a6		       85 8f		      sta	Evaluation
      0  06a8					      lda@PLY	savedEvaluation+1
      1  06a8		       ad c9 f9 	      lda	savedEvaluation+1
    658  06ab		       85 90		      sta	Evaluation+1
    659  06ad
      0  06ad					      lda@PLY	virtualKingSquare
      1  06ad		       ad da f9 	      lda	virtualKingSquare
    661  06b0		       85 a4		      sta	vkSquare
      0  06b2					      lda@PLY	virtualKingSquare+1
      1  06b2		       ad db f9 	      lda	virtualKingSquare+1
    663  06b5		       85 a5		      sta	vkSquare+1
    664  06b7
      0  06b7					      lda@PLY	enPassantSquare
      1  06b7		       ad ca f9 	      lda	enPassantSquare
    666  06ba		       85 93		      sta	enPassantPawn
    667  06bc
      0  06bc					      ldx@PLY	movePtr
      1  06bc		       ae d0 f9 	      ldx	movePtr
      0  06bf					      ldy@PLY	MoveFrom,x
      1  06bf		       bc 00 f8 	      ldy	MoveFrom,x
      0  06c2					      lda@PLY	restorePiece
      1  06c2		       ad d9 f9 	      lda	restorePiece
      0  06c5					      sta@RAM	Board,y
      1  06c5		       99 79 fe 	      sta	[RAM]+Board,y
    672  06c8
      0  06c8					      ldy@PLY	MoveTo,x
      1  06c8		       bc 64 f8 	      ldy	MoveTo,x
      0  06cb					      lda@PLY	capturedPiece
      1  06cb		       ad cb f9 	      lda	capturedPiece
      0  06ce					      sta@RAM	Board,y
      1  06ce		       99 79 fe 	      sta	[RAM]+Board,y
    676  06d1
    677  06d1
    678  06d1							; See if there are any 'secondary' pieces that moved
    679  06d1							; here we're dealing with reverting a castling or enPassant move
    680  06d1
      0  06d1					      lda@PLY	secondaryPiece
      1  06d1		       ad cc f9 	      lda	secondaryPiece
    682  06d4		       f0 10		      beq	.noSecondary
      0  06d6					      ldx@PLY	secondarySquare
      1  06d6		       ae cd f9 	      ldx	secondarySquare
      0  06d9					      sta@RAM	Board,x	; put piece back
      1  06d9		       9d 79 fe 	      sta	[RAM]+Board,x
      0  06dc					      ldy@PLY	secondaryBlank
      1  06dc		       ac ce f9 	      ldy	secondaryBlank
    686  06df		       f0 05		      beq	.noSecondary	; enpassant - no blanker square
    687  06e1		       a9 00		      lda	#0
      0  06e3					      sta@RAM	Board,y	; blank piece origin
      1  06e3		       99 79 fe 	      sta	[RAM]+Board,y
    689  06e6
      0  06e6				   .noSecondary SWAP
      1  06e6		       a5 95		      lda	sideToMove
      2  06e8		       49 c0		      eor	#SWAP_SIDE|HUMAN
      3  06ea		       85 95		      sta	sideToMove
      4  06ec
      5  06ec
    691  06ec		       60		      rts
    692  06ed
    693  06ed
    694  06ed							;---------------------------------------------------------------------------------------------------
    695  06ed
      0  06ed					      DEF	showMoveCaptures
      1  06ed				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  06ed				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  06ed				   showMoveCaptures
      4  06ed				   TEMPORARY_VAR SET	Overlay
      5  06ed				   TEMPORARY_OFFSET SET	0
      6  06ed				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  06ed				   FUNCTION_NAME SET	showMoveCaptures
    697  06ed					      SUBROUTINE
    698  06ed
      0  06ed					      REFER	aiShowMoveCaptures	;✅
      1  06ed					      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  06ed				   TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  06ed					      ENDIF
    700  06ed
      0  06ed					      VAR	__toSquareX12, 1
      1  06ed		       00 a9	   __toSquareX12 =	TEMPORARY_VAR
      2  06ed				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06ed
      4  06ed				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06ed				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06ed				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06ed					      ENDIF
      8  06ed				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  06ed				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  06ed				  -	      ERR
     11  06ed					      ENDIF
     12  06ed					      LIST	ON
      0  06ed					      VAR	__fromPiece, 1
      1  06ed		       00 aa	   __fromPiece =	TEMPORARY_VAR
      2  06ed				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06ed
      4  06ed				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06ed				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06ed				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06ed					      ENDIF
      8  06ed				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  06ed				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  06ed				  -	      ERR
     11  06ed					      ENDIF
     12  06ed					      LIST	ON
      0  06ed					      VAR	__aiMoveIndex, 1
      1  06ed		       00 ab	   __aiMoveIndex =	TEMPORARY_VAR
      2  06ed				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06ed
      4  06ed				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06ed				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06ed				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06ed					      ENDIF
      8  06ed				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  06ed				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  06ed				  -	      ERR
     11  06ed					      ENDIF
     12  06ed					      LIST	ON
    704  06ed
      0  06ed					      VEND	showMoveCaptures
      1  06ed				  -	      IFNCONST	showMoveCaptures
      2  06ed				  -	      ECHO	"Incorrect VEND label", showMoveCaptures
      3  06ed				  -	      ERR
      4  06ed					      ENDIF
      5  06ed		       00 ac	   VAREND_showMoveCaptures =	TEMPORARY_VAR
    706  06ed
    707  06ed							; place a marker on the board for any square matching the piece
    708  06ed							; EXCEPT for squares which are occupied (we'll flash those later)
    709  06ed							; x = movelist item # being checked
    710  06ed
    711  06ed
    712  06ed		       a6 8d	   .next      ldx	aiMoveIndex
    713  06ef		       86 ab		      stx	__aiMoveIndex
    714  06f1		       30 4a		      bmi	.skip	; no moves in list
    715  06f3
    716  06f3		       ad 84 02 	      lda	INTIM
    717  06f6		       c9 14		      cmp	#20
    718  06f8		       90 43		      bcc	.skip
    719  06fa
    720  06fa		       c6 8d		      dec	aiMoveIndex
    721  06fc
    722  06fc		       a9 89		      lda	#RAMBANK_PLY+1
    723  06fe		       85 3e		      sta	SET_BANK_RAM
      0  0700					      lda@PLY	MoveFrom,x
      1  0700		       bd 00 f8 	      lda	MoveFrom,x
    725  0703		       c5 85		      cmp	fromX12
    726  0705		       d0 e6		      bne	.next
    727  0707
      0  0707					      lda@PLY	MoveTo,x
      1  0707		       bd 64 f8 	      lda	MoveTo,x
    729  070a		       85 a9		      sta	__toSquareX12
    730  070c		       a8		      tay
    731  070d
    732  070d		       a9 d2		      lda	#RAMBANK_BOARD
    733  070f		       85 3e		      sta	SET_BANK_RAM	;@3
    734  0711		       b9 79 fc 	      lda	Board,y
    735  0714		       29 0f		      and	#PIECE_MASK
    736  0716		       f0 d5		      beq	.next
    737  0718
    738  0718							; There's something on the board at destination, so it's a capture
    739  0718							; Let's see if we are doing a pawn promote...
    740  0718
    741  0718		       a4 85		      ldy	fromX12
    742  071a
    743  071a		       a9 d2		      lda	#RAMBANK_BOARD
    744  071c		       85 3e		      sta	SET_BANK_RAM	;@3
    745  071e		       b9 79 fc 	      lda	Board,y
    746  0721		       85 aa		      sta	__fromPiece
    747  0723
    748  0723		       a9 89		      lda	#RAMBANK_PLY+1
    749  0725		       85 3e		      sta	SET_BANK_RAM
      0  0727					      lda@PLY	MovePiece,x
      1  0727		       bd 00 f9 	      lda	MovePiece,x
    751  072a		       45 aa		      eor	__fromPiece
    752  072c		       29 0f		      and	#PIECE_MASK
    753  072e		       f0 06		      beq	.legit	; from == to, so not a promote
    754  0730
    755  0730							; Have detected a promotion duplicate - skip all 3 of them
    756  0730							; TODO: this will need reworking once moves are sorted
    757  0730
    758  0730		       c6 8d		      dec	aiMoveIndex	; skip "KBRQ" promotes
    759  0732		       c6 8d		      dec	aiMoveIndex
    760  0734		       c6 8d		      dec	aiMoveIndex
    761  0736
    762  0736				   .legit
    763  0736
    764  0736							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
    765  0736
    766  0736		       a5 a9		      lda	__toSquareX12
    767  0738		       85 80		      sta	squareToDraw
    768  073a
    769  073a							; WARNING - local variables will not survive the following call...!
    770  073a		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    771  073d
    772  073d		       60	   .skip      rts
    773  073e
    774  073e
    775  073e							;---------------------------------------------------------------------------------------------------
    776  073e
      0  073e					      DEF	CopyPieceToRowBitmap
      1  073e				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  073e				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  073e				   CopyPieceToRowBitmap
      4  073e				   TEMPORARY_VAR SET	Overlay
      5  073e				   TEMPORARY_OFFSET SET	0
      6  073e				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  073e				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    778  073e					      SUBROUTINE
    779  073e
      0  073e					      REFER	InterceptMarkerCopy	;✅
      1  073e					      IF	VAREND_InterceptMarkerCopy > TEMPORARY_VAR
      2  073e				   TEMPORARY_VAR SET	VAREND_InterceptMarkerCopy
      3  073e					      ENDIF
    781  073e
      0  073e					      VEND	CopyPieceToRowBitmap
      1  073e				  -	      IFNCONST	CopyPieceToRowBitmap
      2  073e				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  073e				  -	      ERR
      4  073e					      ENDIF
      5  073e		       00 ac	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
    783  073e
    784  073e		       a0 11		      ldy	#17
    785  0740		       b0 30		      bcs	.rightSide
    786  0742
    787  0742		       b9 a7 00    .copyPiece lda	__pieceShapeBuffer,y
    788  0745		       f0 06		      beq	.blank1
    789  0747		       59 00 f8 	      eor	ChessBitmap,y
      0  074a					      sta@RAM	ChessBitmap,y
      1  074a		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    791  074d
    792  074d		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    793  0750		       f0 06		      beq	.blank2
    794  0752		       59 12 f8 	      eor	ChessBitmap+18,y
      0  0755					      sta@RAM	ChessBitmap+18,y
      1  0755		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    796  0758
    797  0758		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    798  075b		       f0 06		      beq	.blank3
    799  075d		       59 24 f8 	      eor	ChessBitmap+36,y
      0  0760					      sta@RAM	ChessBitmap+36,y
      1  0760		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    801  0763
    802  0763		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    803  0766		       f0 06		      beq	.blank4
    804  0768		       59 36 f8 	      eor	ChessBitmap+54,y
      0  076b					      sta@RAM	ChessBitmap+54,y
      1  076b		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    806  076e
    807  076e		       88	   .blank4    dey
    808  076f		       10 d1		      bpl	.copyPiece
    809  0771		       60		      rts
    810  0772
    811  0772				   .rightSide
    812  0772
    813  0772					      SUBROUTINE
    814  0772
    815  0772		       b9 a7 00    .copyPieceR lda	__pieceShapeBuffer,y
    816  0775		       f0 06		      beq	.blank1
    817  0777		       59 48 f8 	      eor	ChessBitmap+72,y
      0  077a					      sta@RAM	ChessBitmap+72,y
      1  077a		       99 48 fa 	      sta	[RAM]+ChessBitmap+72,y
    819  077d
    820  077d		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    821  0780		       f0 06		      beq	.blank2
    822  0782		       59 5a f8 	      eor	ChessBitmap+72+18,y
      0  0785					      sta@RAM	ChessBitmap+72+18,y
      1  0785		       99 5a fa 	      sta	[RAM]+ChessBitmap+72+18,y
    824  0788
    825  0788		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    826  078b		       f0 06		      beq	.blank3
    827  078d		       59 6c f8 	      eor	ChessBitmap+72+36,y
      0  0790					      sta@RAM	ChessBitmap+72+36,y
      1  0790		       99 6c fa 	      sta	[RAM]+ChessBitmap+72+36,y
    829  0793
    830  0793		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    831  0796		       f0 06		      beq	.blank4
    832  0798		       59 7e f8 	      eor	ChessBitmap+72+54,y
      0  079b					      sta@RAM	ChessBitmap+72+54,y
      1  079b		       99 7e fa 	      sta	[RAM]+ChessBitmap+72+54,y
    834  079e
    835  079e		       88	   .blank4    dey
    836  079f		       10 d1		      bpl	.copyPieceR
    837  07a1		       60		      rts
    838  07a2
    839  07a2
    840  07a2							;---------------------------------------------------------------------------------------------------
    841  07a2
      0  07a2					      DEF	EnPassantRemoveCapturedPawn
      1  07a2				   SLOT_EnPassantRemoveCapturedPawn SET	_BANK_SLOT
      2  07a2				   BANK_EnPassantRemoveCapturedPawn SET	SLOT_EnPassantRemoveCapturedPawn + _CURRENT_BANK
      3  07a2				   EnPassantRemoveCapturedPawn
      4  07a2				   TEMPORARY_VAR SET	Overlay
      5  07a2				   TEMPORARY_OFFSET SET	0
      6  07a2				   VAR_BOUNDARY_EnPassantRemoveCapturedPawn SET	TEMPORARY_OFFSET
      7  07a2				   FUNCTION_NAME SET	EnPassantRemoveCapturedPawn
    843  07a2					      SUBROUTINE
    844  07a2
      0  07a2					      REFER	aiSpecialMoveFixup
      1  07a2					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  07a2				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  07a2					      ENDIF
      0  07a2					      VEND	EnPassantRemoveCapturedPawn
      1  07a2				  -	      IFNCONST	EnPassantRemoveCapturedPawn
      2  07a2				  -	      ECHO	"Incorrect VEND label", EnPassantRemoveCapturedPawn
      3  07a2				  -	      ERR
      4  07a2					      ENDIF
      5  07a2		       00 b5	   VAREND_EnPassantRemoveCapturedPawn =	TEMPORARY_VAR
    847  07a2
    848  07a2		       a4 93		      ldy	enPassantPawn
    849  07a4		       f0 27		      beq	.exit
    850  07a6
    851  07a6
    852  07a6		       a9 d2		      lda	#RAMBANK_BOARD
    853  07a8		       85 3e		      sta	SET_BANK_RAM	;@3
    854  07aa
    855  07aa							; Account for the opponent pawn being removed
    856  07aa							; Effectively ADD the values to our current score
    857  07aa
    858  07aa		       a5 95		      lda	sideToMove
    859  07ac		       49 80		      eor	#128
    860  07ae		       29 80		      and	#128
    861  07b0		       09 01		      ora	#WP	; == BP in this usage
    862  07b2
    863  07b2		       a2 84		      ldx	#BANK_AddPiecePositionValue
    864  07b4		       86 3f		      stx	SET_BANK	;@2
    865  07b6		       20 52 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    866  07b9
    867  07b9		       a9 01		      lda	#WP	; == BP
    868  07bb		       a2 84		      ldx	#BANK_AddPieceMaterialValue
    869  07bd		       86 3f		      stx	SET_BANK	;@2
    870  07bf		       20 2f f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    871  07c2
    872  07c2		       a9 d2		      lda	#RAMBANK_BOARD
    873  07c4		       85 3e		      sta	SET_BANK_RAM	;@3
    874  07c6
    875  07c6		       a6 93		      ldx	enPassantPawn
    876  07c8		       a9 00		      lda	#0
      0  07ca					      sta@RAM	Board,x
      1  07ca		       9d 79 fe 	      sta	[RAM]+Board,x
    878  07cd
    879  07cd
    880  07cd		       60	   .exit      rts
    881  07ce
    882  07ce
    883  07ce							;---------------------------------------------------------------------------------------------------
    884  07ce
 FREE BYTES IN BANK_FIRST@0 BANK =  $2e
    885  07ce					      ECHO	"FREE BYTES IN BANK_FIRST@0 BANK = ", $F3FC - *
    886  07ce
    887  07ce
    888  07ce							; EOF
------- FILE ./chess.asm
    547  07ce
------- FILE @1 GENERIC #1.asm LEVEL 2 PASS 4
      0  07ce					      include	"@1 GENERIC #1.asm"
      1  07ce							; Chess
      2  07ce							; Copyright (c) 2019-2020 Andrew Davie
      3  07ce							; andrew@taswegian.com
      4  07ce
      0  07ce					      SLOT	1	; which bank this code switches to
      1  07ce				  -	      IF	(1 < 0) || (1 > 3)
      2  07ce				  -	      ECHO	"Illegal bank address/segment location", 1
      3  07ce				  -	      ERR
      4  07ce					      ENDIF
      5  07ce				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  07ce				   _BANK_SLOT SET	1 * 64
      0  07ce					      ROMBANK	ONE
      1  0a4c ????				      SEG	ONE
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   ONE_START  SET	*
      6  0800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0800				   ONE	      SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + 1024
      7  0800
      8  0800
      9  0800							;---------------------------------------------------------------------------------------------------
     10  0800							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     11  0800							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     12  0800							; bank finishes.  Just continue on from where it left off...
     13  0800							;---------------------------------------------------------------------------------------------------
     14  0800
      0  0800					      DEF	CartInit
      1  0800				   SLOT_CartInit SET	_BANK_SLOT
      2  0800				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0800				   CartInit
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	CartInit
     16  0800					      SUBROUTINE
     17  0800
      0  0800					      REFER	StartupBankReset	;✅
      1  0800				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0800				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0800					      ENDIF
     19  0800
      0  0800					      VEND	CartInit
      1  0800				  -	      IFNCONST	CartInit
      2  0800				  -	      ECHO	"Incorrect VEND label", CartInit
      3  0800				  -	      ERR
      4  0800					      ENDIF
      5  0800		       00 a7	   VAREND_CartInit =	TEMPORARY_VAR
     21  0800
     22  0800
     23  0800							; See if we can come up with something 'random' for startup
     24  0800
     25  0800		       ac 84 02 	      ldy	INTIM
     26  0803		       d0 02		      bne	.toR
     27  0805		       a0 9a		      ldy	#$9A
     28  0807		       84 81	   .toR       sty	rnd
     29  0809
     30  0809		       a9 1f		      lda	#31
     31  080b		       85 a1		      sta	randomness
     32  080d
     33  080d		       a9 00		      lda	#0
     34  080f		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     35  0812		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     36  0815		       85 6b		      sta	HMCLR
     37  0817
     38  0817		       85 5b		      sta	GRP0
     39  0819		       85 5c		      sta	GRP1
     40  081b		       85 5d		      sta	ENAM0
     41  081d		       85 5e		      sta	ENAM1
     42  081f		       85 5f		      sta	ENABL
     43  0821
     44  0821							; cleanup remains of title screen
     45  0821							;sta GRP0
     46  0821							;sta GRP1
     47  0821
     48  0821		       a9 07		      lda	#%111
     49  0823		       85 44		      sta	NUSIZ0
     50  0825		       85 45		      sta	NUSIZ1	; quad-width
     51  0827
     52  0827							;lda #%00000100
     53  0827							;sta CTRLPF
     54  0827		       a9 00		      lda	#BACKGCOL
     55  0829		       85 49		      sta	COLUBK
     56  082b
     57  082b
     58  082b		       a9 40		      lda	#WHITE|HUMAN
     59  082d		       85 95		      sta	sideToMove
     60  082f
     61  082f		       60		      rts
     62  0830
     63  0830
     64  0830							;---------------------------------------------------------------------------------------------------
     65  0830
      0  0830					      DEF	SetupBanks
      1  0830				   SLOT_SetupBanks SET	_BANK_SLOT
      2  0830				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  0830				   SetupBanks
      4  0830				   TEMPORARY_VAR SET	Overlay
      5  0830				   TEMPORARY_OFFSET SET	0
      6  0830				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  0830				   FUNCTION_NAME SET	SetupBanks
     67  0830					      SUBROUTINE
     68  0830
     69  0830							; Move a copy of the row bank template to the first 8 banks of RAM
     70  0830							; and then terminate the draw subroutine by substituting in a RTS on the last one
     71  0830
      0  0830					      REFER	StartupBankReset	;✅
      1  0830				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0830				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0830					      ENDIF
      0  0830					      VEND	SetupBanks
      1  0830				  -	      IFNCONST	SetupBanks
      2  0830				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  0830				  -	      ERR
      4  0830					      ENDIF
      5  0830		       00 a7	   VAREND_SetupBanks =	TEMPORARY_VAR
     74  0830
     75  0830							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     76  0830
     77  0830				   .ROWBANK   SET	0
     78  0830					      REPEAT	8
     79  0830		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     80  0832		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     81  0834		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     82  0834				   .ROWBANK   SET	.ROWBANK+1
     78  0834					      REPEND
     79  0837		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     80  0839		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     81  083b		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     82  083b				   .ROWBANK   SET	.ROWBANK+1
     78  083b					      REPEND
     79  083e		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     80  0840		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     81  0842		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     82  0842				   .ROWBANK   SET	.ROWBANK+1
     78  0842					      REPEND
     79  0845		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     80  0847		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     81  0849		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     82  0849				   .ROWBANK   SET	.ROWBANK+1
     78  0849					      REPEND
     79  084c		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     80  084e		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     81  0850		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     82  0850				   .ROWBANK   SET	.ROWBANK+1
     78  0850					      REPEND
     79  0853		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     80  0855		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     81  0857		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     82  0857				   .ROWBANK   SET	.ROWBANK+1
     78  0857					      REPEND
     79  085a		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     80  085c		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     81  085e		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     82  085e				   .ROWBANK   SET	.ROWBANK+1
     78  085e					      REPEND
     79  0861		       a2 83		      ldx	#BANK_SHADOW_ChessBitmap
     80  0863		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     81  0865		       20 79 f4 	      jsr	CopyShadowROMtoRAM
     82  0865				   .ROWBANK   SET	.ROWBANK+1
     83  0868					      REPEND
     84  0868
     85  0868
     86  0868							; Patch the final row's "loop" to a RTS
     87  0868
     88  0868		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
     89  086a		       86 3e		      stx	SET_BANK_RAM
     90  086c		       a9 60		      lda	#$60	; "rts"
      0  086e					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  086e		       8d 00 fb 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     92  0871
     93  0871
     94  0871
     95  0871							; copy the BOARD/MOVES bank
     96  0871
     97  0871		       a2 8c		      ldx	#SHADOW_BOARD
     98  0873		       a0 d2		      ldy	#RAMBANK_BOARD
     99  0875		       20 79 f4 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    100  0878
    101  0878
    102  0878							; copy the PLY banks
    103  0878							; If there's no content (only variable decs) then we don't really need to do this.
    104  0878
    105  0878							;.PLY SET 0
    106  0878							;    REPEAT PLY_BANKS
    107  0878
    108  0878							;		      ldx #SHADOW_PLY
    109  0878							;		      ldy #RAMBANK_PLY + .PLY
    110  0878							;jsr CopyShadowROMtoRAM
    111  0878							;.PLY SET .PLY + 1
    112  0878							;    REPEND
    113  0878
    114  0878							; copy the evaluation code/tables
    115  0878							; 3E+ moved from RAM to ROM
    116  0878
    117  0878							;		      ldx #[SLOT2] + SHADOW_EVAL
    118  0878							;		      ldy #[SLOT3] + EVAL
    119  0878							;		      jsr CopyShadowROMtoRAM
    120  0878
    121  0878
    122  0878							;		      ldy #RAMBANK_RAM_PIECELIST
    123  0878							;		      ldx #ROM_PIECELIST
    124  0878							;		      jsr CopyShadowROMtoRAM
    125  0878
    126  0878		       60		      rts
    127  0879
    128  0879
    129  0879							;---------------------------------------------------------------------------------------------------
    130  0879
      0  0879					      DEF	CopyShadowROMtoRAM
      1  0879				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  0879				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  0879				   CopyShadowROMtoRAM
      4  0879				   TEMPORARY_VAR SET	Overlay
      5  0879				   TEMPORARY_OFFSET SET	0
      6  0879				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  0879				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    132  0879					      SUBROUTINE
    133  0879
      0  0879					      REFER	SetupBanks	;✅
      1  0879				  -	      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  0879				  -TEMPORARY_VAR SET	VAREND_SetupBanks
      3  0879					      ENDIF
    135  0879
      0  0879					      VEND	CopyShadowROMtoRAM
      1  0879				  -	      IFNCONST	CopyShadowROMtoRAM
      2  0879				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  0879				  -	      ERR
      4  0879					      ENDIF
      5  0879		       00 a7	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    137  0879
    138  0879							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    139  0879							; used to setup callable RAM code from ROM templates
    140  0879
    141  0879							; x = source ROM bank
    142  0879							; y = destination RAM bank (preserved)
    143  0879
    144  0879		       86 3f		      stx	SET_BANK
    145  087b		       84 3e		      sty	SET_BANK_RAM
    146  087d
    147  087d		       a2 00		      ldx	#0
    148  087f		       bd 00 f8    .copyPage  lda	$F800,x
      0  0882					      sta@RAM	$FC00,x
      1  0882		       9d 00 fe 	      sta	[RAM]+$FC00,x
    150  0885		       bd 00 f9 	      lda	$F900,x
      0  0888					      sta@RAM	$FD00,x
      1  0888		       9d 00 ff 	      sta	[RAM]+$FD00,x
    152  088b		       ca		      dex
    153  088c		       d0 f1		      bne	.copyPage
    154  088e		       60		      rts
    155  088f
    156  088f
    157  088f							;---------------------------------------------------------------------------------------------------
    158  088f
      0  088f					      DEF	CallClear
      1  088f				   SLOT_CallClear SET	_BANK_SLOT
      2  088f				   BANK_CallClear SET	SLOT_CallClear + _CURRENT_BANK
      3  088f				   CallClear
      4  088f				   TEMPORARY_VAR SET	Overlay
      5  088f				   TEMPORARY_OFFSET SET	0
      6  088f				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      7  088f				   FUNCTION_NAME SET	CallClear
    160  088f					      SUBROUTINE
    161  088f
    162  088f				  -	      IF	0
    163  088f				  -	      REFER	aiClearEachRow	;TODO
    164  088f					      ENDIF
    165  088f
      0  088f					      VEND	CallClear
      1  088f				  -	      IFNCONST	CallClear
      2  088f				  -	      ECHO	"Incorrect VEND label", CallClear
      3  088f				  -	      ERR
      4  088f					      ENDIF
      5  088f		       00 a7	   VAREND_CallClear =	TEMPORARY_VAR
    167  088f
    168  088f				  -	      IF	0
    169  088f				  -			; No transient variable dependencies/calls
    170  088f				  -
    171  088f				  -	      sty	SET_BANK_RAM
    172  088f				  -	      jsr	ClearRowBitmap
    173  088f					      ENDIF
    174  088f		       60		      rts
    175  0890
    176  0890
    177  0890							;---------------------------------------------------------------------------------------------------
    178  0890
      0  0890					      DEF	InitialisePieceSquares
      1  0890				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  0890				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  0890				   InitialisePieceSquares
      4  0890				   TEMPORARY_VAR SET	Overlay
      5  0890				   TEMPORARY_OFFSET SET	0
      6  0890				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  0890				   FUNCTION_NAME SET	InitialisePieceSquares
    180  0890					      SUBROUTINE
    181  0890
      0  0890					      COMMON_VARS
      1  0890
      0  0890					      VAR	__thinkbar, 1
      1  0890		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      0  0890					      VAR	__toggle, 1
      1  0890		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      4  0890
      0  0890					      VAR	__bestMove, 1
      1  0890		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      0  0890					      VAR	__alpha, 2
      1  0890		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      0  0890					      VAR	__beta, 2
      1  0890		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      0  0890					      VAR	__negaMax, 2
      1  0890		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      0  0890					      VAR	__value, 2
      1  0890		       00 b0	   __value    =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
     10  0890
      0  0890					      VAR	__quiesceCapOnly, 1
      1  0890		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
     12  0890
      0  0890					      VAR	__originalPiece, 1
      1  0890		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      0  0890					      VAR	__capturedPiece, 1
      1  0890		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
     15  0890
      0  0890					      REFER	StartupBankReset	;✅
      1  0890				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0890				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0890					      ENDIF
    184  0890
      0  0890					      VAR	__initPiece, 1
      1  0890		       00 b5	   __initPiece =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      0  0890					      VAR	__initSquare, 1
      1  0890		       00 b6	   __initSquare =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      0  0890					      VAR	__initListPtr, 1
      1  0890		       00 b7	   __initListPtr =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
      0  0890					      VAR	__op, 1
      1  0890		       00 b8	   __op       =	TEMPORARY_VAR
      2  0890				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0890
      4  0890				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0890					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0890				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0890					      ENDIF
      8  0890				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0890				  -	      ECHO	"Temporary Variable", __op, "overflow!"
     10  0890				  -	      ERR
     11  0890					      ENDIF
     12  0890					      LIST	ON
    189  0890
      0  0890					      VEND	InitialisePieceSquares
      1  0890				  -	      IFNCONST	InitialisePieceSquares
      2  0890				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  0890				  -	      ERR
      4  0890					      ENDIF
      5  0890		       00 b9	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    191  0890
    192  0890		       a9 00		      lda	#0
    193  0892		       85 8f		      sta	Evaluation
    194  0894		       85 90		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    195  0896		       85 93		      sta	enPassantPawn	; no en-passant
    196  0898
    197  0898
      0  0898					      PHASE	AI_StartClearBoard
      1  0898		       a9 0d		      lda	#AI_StartClearBoard
      2  089a		       85 8b		      sta	aiState
    199  089c
    200  089c		       a2 00		      ldx	#0
    201  089e				   .fillPieceLists
    202  089e
    203  089e
    204  089e		       bd f0 f4 	      lda	InitPieceList,x	; colour/-1
    205  08a1		       f0 4c		      beq	.exit
    206  08a3		       85 b8		      sta	__op	; type
    207  08a5		       bc f1 f4 	      ldy	InitPieceList+1,x	; square
    208  08a8		       84 b6		      sty	__initSquare
    209  08aa
    210  08aa		       a9 d2		      lda	#RAMBANK_BOARD
    211  08ac		       85 3e		      sta	SET_BANK_RAM
    212  08ae		       a5 b8		      lda	__op
      0  08b0					      sta@RAM	Board,y
      1  08b0		       99 79 fe 	      sta	[RAM]+Board,y
    214  08b3		       10 0d		      bpl	.white
    215  08b5
      0  08b5					      NEGEVAL
      1  08b5
      2  08b5		       38		      sec
      3  08b6		       a9 00		      lda	#0
      4  08b8		       e5 8f		      sbc	Evaluation
      5  08ba		       85 8f		      sta	Evaluation
      6  08bc		       a9 00		      lda	#0
      7  08be		       e5 90		      sbc	Evaluation+1
      8  08c0		       85 90		      sta	Evaluation+1
    217  08c2				   .white
    218  08c2
    219  08c2		       86 b7		      stx	__initListPtr
    220  08c4
    221  08c4							; Add the material value of the piece to the evaluation
    222  08c4
    223  08c4		       a5 b8		      lda	__op
    224  08c6		       a2 84		      ldx	#BANK_AddPieceMaterialValue
    225  08c8		       86 3f		      stx	SET_BANK	;@2
    226  08ca		       20 2f f9 	      jsr	AddPieceMaterialValue
    227  08cd
    228  08cd
    229  08cd							; add the positional value of the piece to the evaluation
    230  08cd
    231  08cd		       a4 b6		      ldy	__initSquare
    232  08cf		       a5 b8		      lda	__op
    233  08d1		       a2 84		      ldx	#BANK_AddPiecePositionValue
    234  08d3		       86 3f		      stx	SET_BANK
    235  08d5		       20 52 f9 	      jsr	AddPiecePositionValue
    236  08d8
    237  08d8		       a5 b8		      lda	__op	; type/colour
    238  08da		       10 0d		      bpl	.white2
      0  08dc					      NEGEVAL
      1  08dc
      2  08dc		       38		      sec
      3  08dd		       a9 00		      lda	#0
      4  08df		       e5 8f		      sbc	Evaluation
      5  08e1		       85 8f		      sta	Evaluation
      6  08e3		       a9 00		      lda	#0
      7  08e5		       e5 90		      sbc	Evaluation+1
      8  08e7		       85 90		      sta	Evaluation+1
    240  08e9				   .white2
    241  08e9
    242  08e9		       a6 b7		      ldx	__initListPtr
    243  08eb		       e8		      inx
    244  08ec		       e8		      inx
    245  08ed		       10 af		      bpl	.fillPieceLists
    246  08ef
    247  08ef				   .exit
    248  08ef		       60		      rts
    249  08f0
    250  08f0
    251  08f0				   InitPieceList
    252  08f0
    253  08f0
    254  08f0					      IF	!TEST_POSITION
    255  08f0
    256  08f0		       06 19		      .byte.b	WHITE|Q, 25
    257  08f2		       04 18		      .byte.b	WHITE|B, 24
    258  08f4		       04 1b		      .byte.b	WHITE|B, 27
    259  08f6		       05 16		      .byte.b	WHITE|R, 22
    260  08f8		       05 1d		      .byte.b	WHITE|R, 29
    261  08fa		       03 17		      .byte.b	WHITE|N, 23
    262  08fc		       03 1c		      .byte.b	WHITE|N, 28
    263  08fe
    264  08fe		       01 23		      .byte.b	WHITE|WP, 35
    265  0900		       01 24		      .byte.b	WHITE|WP, 36
    266  0902		       01 22		      .byte.b	WHITE|WP, 34
    267  0904		       01 25		      .byte.b	WHITE|WP, 37
    268  0906		       01 21		      .byte.b	WHITE|WP, 33
    269  0908		       01 26		      .byte.b	WHITE|WP, 38
    270  090a		       01 20		      .byte.b	WHITE|WP, 32
    271  090c		       01 27		      .byte.b	WHITE|WP, 39
    272  090e
    273  090e		       07 1a		      .byte.b	WHITE|K, 26
    274  0910
    275  0910		       86 5f		      .byte.b	BLACK|Q, 95
    276  0912		       84 5e		      .byte.b	BLACK|B, 94
    277  0914		       84 61		      .byte.b	BLACK|B, 97
    278  0916		       85 5c		      .byte.b	BLACK|R, 92
    279  0918		       85 63		      .byte.b	BLACK|R, 99
    280  091a		       83 5d		      .byte.b	BLACK|N, 93
    281  091c		       83 62		      .byte.b	BLACK|N, 98
    282  091e
    283  091e		       82 55		      .byte.b	BLACK|BP, 85
    284  0920		       82 56		      .byte.b	BLACK|BP, 86
    285  0922		       82 54		      .byte.b	BLACK|BP, 84
    286  0924		       82 57		      .byte.b	BLACK|BP, 87
    287  0926		       82 53		      .byte.b	BLACK|BP, 83
    288  0928		       82 58		      .byte.b	BLACK|BP, 88
    289  092a		       82 52		      .byte.b	BLACK|BP, 82
    290  092c		       82 59		      .byte.b	BLACK|BP, 89
    291  092e
    292  092e		       87 60		      .byte.b	BLACK|K, 96
    293  0930
    294  0930		       00		      .byte.b	0	;end
    295  0931
    296  0931				  -	      ELSE		; test position...
    297  0931				  -
    298  0931				  -	      IF	0
    299  0931				  -			; make sure illegal moves leaving K in check are removed
    300  0931				  -
    301  0931				  -	      .byte	WHITE|N, 28
    302  0931				  -	      .byte	WHITE|K, 26
    303  0931				  -
    304  0931				  -	      .byte	BLACK|Q, 29
    305  0931				  -
    306  0931				  -	      .byte	0	;end
    307  0931				  -
    308  0931				  -	      ENDIF
    309  0931				  -
    310  0931				  -	      IF	0
    311  0931				  -
    312  0931				  -	      .byte	WHITE|K, 28
    313  0931				  -	      .byte	WHITE|WP, 37
    314  0931				  -	      .byte	WHITE|WP, 38
    315  0931				  -	      .byte	WHITE|WP, 53
    316  0931				  -	      .byte	WHITE|WP, 49
    317  0931				  -	      .byte	WHITE|WP, 32
    318  0931				  -	      .byte	WHITE|R, 27
    319  0931				  -	      .byte	WHITE|B, 46
    320  0931				  -	      .byte	WHITE|R, 54
    321  0931				  -
    322  0931				  -	      .byte	BLACK|BP, 56
    323  0931				  -	      .byte	BLACK|BP, 87
    324  0931				  -	      .byte	BLACK|BP, 88
    325  0931				  -	      .byte	BLACK|BP, 89
    326  0931				  -	      .byte	BLACK|BP, 84
    327  0931				  -	      .byte	BLACK|B, 66
    328  0931				  -	      .byte	BLACK|R, 69
    329  0931				  -	      .byte	BLACK|K, 98
    330  0931				  -
    331  0931				  -	      .byte	BLACK|R, 92
    332  0931				  -
    333  0931				  -
    334  0931				  -
    335  0931				  -	      ENDIF
    336  0931				  -
    337  0931				  -	      IF	TEST_POSITION & 0
    338  0931				  -			; Castling across/into check
    339  0931				  -			; pawn promotion
    340  0931				  -
    341  0931				  -	      .byte	WHITE|K, 26
    342  0931				  -	      .byte	WHITE|R, 29
    343  0931				  -	      .byte	BLACK|B, 45
    344  0931				  -	      .byte	WHITE|Q, 72
    345  0931				  -	      .byte	BLACK|N, 84
    346  0931				  -	      .byte	WHITE|WP,89
    347  0931				  -
    348  0931				  -	      ENDIF
    349  0931				  -
    350  0931				  -
    351  0931				  -
    352  0931				  -	      IF	TEST_POSITION & 0
    353  0931				  -			; En passant test
    354  0931				  -
    355  0931				  -	      .byte	BLACK|BP, 88
    356  0931				  -	      .byte	BLACK|BP, 86
    357  0931				  -
    358  0931				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    359  0931				  -	      .byte	WHITE|K, 52
    360  0931				  -
    361  0931				  -
    362  0931				  -	      ENDIF
    363  0931				  -
    364  0931				  -	      IF	TEST_POSITION & 0
    365  0931				  -			; En passant test (white)
    366  0931				  -
    367  0931				  -	      .byte	BLACK|BP|FLAG_MOVED, 53
    368  0931				  -
    369  0931				  -	      .byte	WHITE|WP, 34
    370  0931				  -	      .byte	WHITE|K, 52
    371  0931				  -
    372  0931				  -
    373  0931				  -	      .byte	BLACK|BP, 88
    374  0931				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    375  0931				  -
    376  0931				  -
    377  0931				  -	      ENDIF
    378  0931				  -
    379  0931				  -
    380  0931				  -	      IF	TEST_POSITION & 1
    381  0931				  -			; castle
    382  0931				  -
    383  0931				  -	      .byte	BLACK|R, 99
    384  0931				  -	      .byte	BLACK|K, 96
    385  0931				  -	      .byte	BLACK|BP, 89
    386  0931				  -
    387  0931				  -	      .byte	WHITE|WP, 37
    388  0931				  -	      .byte	WHITE|WP, 38
    389  0931				  -	      .byte	WHITE|WP, 39
    390  0931				  -	      .byte	WHITE|R,29
    391  0931				  -	      .byte	WHITE|K, 26
    392  0931				  -
    393  0931				  -	      ENDIF
    394  0931				  -
    395  0931				  -
    396  0931				  -
    397  0931				  -
    398  0931				  -	      IF	TEST_POSITION & 0
    399  0931				  -			; promote test
    400  0931				  -
    401  0931				  -	      .byte	BLACK|K, 22
    402  0931				  -	      .byte	BLACK|N, 96
    403  0931				  -
    404  0931				  -	      .byte	WHITE|WP, 87
    405  0931				  -	      .byte	WHITE|R,95
    406  0931				  -	      .byte	WHITE|R,94
    407  0931				  -	      .byte	WHITE|K, 52
    408  0931				  -
    409  0931				  -
    410  0931				  -	      ENDIF
    411  0931				  -
    412  0931				  -
    413  0931				  -
    414  0931				  -	      IF	0
    415  0931				  -
    416  0931				  -
    417  0931				  -			;.byte BLACK|R, 97
    418  0931				  -	      .byte	BLACK|K, 98
    419  0931				  -	      .byte	BLACK|BP, 87
    420  0931				  -	      .byte	BLACK|BP, 88
    421  0931				  -	      .byte	BLACK|BP, 89
    422  0931				  -			;    .byte BLACK|B, 76
    423  0931				  -
    424  0931				  -
    425  0931				  -	      .byte	WHITE|R,28
    426  0931				  -	      .byte	WHITE|Q,58
    427  0931				  -			;   .byte WHITE|N,65
    428  0931				  -	      ENDIF
    429  0931				  -
    430  0931				  -	      IF	0
    431  0931				  -			;.byte WHITE|WP, 56
    432  0931				  -
    433  0931				  -
    434  0931				  -	      .byte	BLACK|K, 98
    435  0931				  -
    436  0931				  -
    437  0931				  -	      .byte	WHITE|R,29
    438  0931				  -	      .byte	WHITE|Q,49
    439  0931				  -	      .byte	WHITE|N,65
    440  0931				  -	      ENDIF
    441  0931				  -	      .byte	0	;end
    442  0931				  -
    443  0931					      ENDIF
    444  0931
    445  0931
    446  0931							;---------------------------------------------------------------------------------------------------
    447  0931
    448  0931				  -	      IF	0
    449  0931				  -	      DEF	SAFE_BackupBitmaps
    450  0931				  -	      SUBROUTINE
    451  0931				  -
    452  0931				  -	      REFER	aiInCheckBackup
    453  0931				  -	      VEND	SAFE_BackupBitmaps
    454  0931				  -
    455  0931				  -	      sty	SET_BANK_RAM
    456  0931				  -	      jsr	SaveBitmap
    457  0931				  -	      rts
    458  0931					      ENDIF
    459  0931
    460  0931
    461  0931							;---------------------------------------------------------------------------------------------------
    462  0931
      0  0931					      DEF	AddMoveSimple
      1  0931				   SLOT_AddMoveSimple SET	_BANK_SLOT
      2  0931				   BANK_AddMoveSimple SET	SLOT_AddMoveSimple + _CURRENT_BANK
      3  0931				   AddMoveSimple
      4  0931				   TEMPORARY_VAR SET	Overlay
      5  0931				   TEMPORARY_OFFSET SET	0
      6  0931				   VAR_BOUNDARY_AddMoveSimple SET	TEMPORARY_OFFSET
      7  0931				   FUNCTION_NAME SET	AddMoveSimple
    464  0931					      SUBROUTINE
    465  0931
      0  0931					      VEND	AddMoveSimple
      1  0931				  -	      IFNCONST	AddMoveSimple
      2  0931				  -	      ECHO	"Incorrect VEND label", AddMoveSimple
      3  0931				  -	      ERR
      4  0931					      ENDIF
      5  0931		       00 a7	   VAREND_AddMoveSimple =	TEMPORARY_VAR
    467  0931
    468  0931							; add square in y register to movelist as destination (X12 format)
    469  0931							; [y]		     to square (X12)
    470  0931							; currentSquare     from square (X12)
    471  0931							; currentPiece      piece.
    472  0931							;   ENPASSANT flag set if pawn double-moving off opening rank
    473  0931							; capture	     captured piece
    474  0931
    475  0931		       a5 9b		      lda	capture
    476  0933		       d0 04		      bne	.always
    477  0935		       a5 b2		      lda	__quiesceCapOnly
    478  0937		       d0 1a		      bne	.abort
    479  0939
    480  0939		       98	   .always    tya
    481  093a
      0  093a					      ldy@PLY	moveIndex
      1  093a		       ac cf f9 	      ldy	moveIndex
    483  093d		       c8		      iny
      0  093e					      sty@PLY	moveIndex
      1  093e		       8c cf fb 	      sty	[RAM]+moveIndex
    485  0941
      0  0941					      sta@PLY	MoveTo,y
      1  0941		       99 64 fa 	      sta	[RAM]+MoveTo,y
    487  0944		       a5 92		      lda	currentSquare
      0  0946					      sta@PLY	MoveFrom,y
      1  0946		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    489  0949		       a5 91		      lda	currentPiece
      0  094b					      sta@PLY	MovePiece,y
      1  094b		       99 00 fb 	      sta	[RAM]+MovePiece,y
    491  094e		       a5 9b		      lda	capture
      0  0950					      sta@PLY	MoveCapture,y
      1  0950		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    493  0953
    494  0953		       60	   .abort     rts
    495  0954
    496  0954
    497  0954							;---------------------------------------------------------------------------------------------------
    498  0954
      0  0954					      DEF	aiSpecialMoveFixup
      1  0954				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  0954				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  0954				   aiSpecialMoveFixup
      4  0954				   TEMPORARY_VAR SET	Overlay
      5  0954				   TEMPORARY_OFFSET SET	0
      6  0954				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  0954				   FUNCTION_NAME SET	aiSpecialMoveFixup
    500  0954					      SUBROUTINE
    501  0954
      0  0954					      COMMON_VARS
      1  0954
      0  0954					      VAR	__thinkbar, 1
      1  0954		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
      0  0954					      VAR	__toggle, 1
      1  0954		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
      4  0954
      0  0954					      VAR	__bestMove, 1
      1  0954		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
      0  0954					      VAR	__alpha, 2
      1  0954		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
      0  0954					      VAR	__beta, 2
      1  0954		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
      0  0954					      VAR	__negaMax, 2
      1  0954		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
      0  0954					      VAR	__value, 2
      1  0954		       00 b0	   __value    =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
     10  0954
      0  0954					      VAR	__quiesceCapOnly, 1
      1  0954		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
     12  0954
      0  0954					      VAR	__originalPiece, 1
      1  0954		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
      0  0954					      VAR	__capturedPiece, 1
      1  0954		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0954				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0954
      4  0954				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0954				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0954				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0954					      ENDIF
      8  0954				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  0954				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  0954				  -	      ERR
     11  0954					      ENDIF
     12  0954					      LIST	ON
     15  0954
      0  0954					      REFER	AiStateMachine	;✅
      1  0954				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0954				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0954					      ENDIF
      0  0954					      VEND	aiSpecialMoveFixup
      1  0954				  -	      IFNCONST	aiSpecialMoveFixup
      2  0954				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  0954				  -	      ERR
      4  0954					      ENDIF
      5  0954		       00 b5	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    505  0954
    506  0954		       ad 84 02 	      lda	INTIM
    507  0957		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    508  0959		       b0 01		      bcs	.cont
    509  095b		       60		      rts
    510  095c
    511  095c
    512  095c				   .cont
    513  095c
      0  095c					      PHASE	AI_DelayAfterPlaced
      1  095c		       a9 27		      lda	#AI_DelayAfterPlaced
      2  095e		       85 8b		      sta	aiState
    515  0960
    516  0960
    517  0960							; Special move fixup
    518  0960
    519  0960		       a5 94		      lda	currentPly
    520  0962		       85 3e		      sta	SET_BANK_RAM
    521  0964
    522  0964		       20 95 f5 	      jsr	CastleFixupDraw
    523  0967
    524  0967		       a5 85		      lda	fromX12
    525  0969		       85 80		      sta	squareToDraw
    526  096b
    527  096b		       60		      rts
    528  096c
    529  096c
    530  096c							;---------------------------------------------------------------------------------------------------
    531  096c
    532  096c
    533  096c
      0  096c					      DEF	aiEPFlash
      1  096c				   SLOT_aiEPFlash SET	_BANK_SLOT
      2  096c				   BANK_aiEPFlash SET	SLOT_aiEPFlash + _CURRENT_BANK
      3  096c				   aiEPFlash
      4  096c				   TEMPORARY_VAR SET	Overlay
      5  096c				   TEMPORARY_OFFSET SET	0
      6  096c				   VAR_BOUNDARY_aiEPFlash SET	TEMPORARY_OFFSET
      7  096c				   FUNCTION_NAME SET	aiEPFlash
    535  096c					      SUBROUTINE
    536  096c
      0  096c					      REFER	AiStateMachine
      1  096c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  096c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  096c					      ENDIF
      0  096c					      VEND	aiEPFlash
      1  096c				  -	      IFNCONST	aiEPFlash
      2  096c				  -	      ECHO	"Incorrect VEND label", aiEPFlash
      3  096c				  -	      ERR
      4  096c					      ENDIF
      5  096c		       00 a9	   VAREND_aiEPFlash =	TEMPORARY_VAR
    539  096c
    540  096c		       a5 82		      lda	drawDelay
    541  096e		       f0 03		      beq	.deCount
    542  0970		       c6 82		      dec	drawDelay
    543  0972		       60		      rts
    544  0973
    545  0973		       a5 84	   .deCount   lda	drawCount
    546  0975		       f0 0e		      beq	.flashDone2
    547  0977		       c6 84		      dec	drawCount
    548  0979
    549  0979		       a9 0a		      lda	#10
    550  097b		       85 82		      sta	drawDelay	; "getting ready to move" flash
    551  097d
    552  097d		       a5 93		      lda	enPassantPawn
    553  097f		       85 80		      sta	squareToDraw
    554  0981
    555  0981							; WARNING - local variables will not survive the following call...!
    556  0981		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    557  0984		       60		      rts
    558  0985
    559  0985				   .flashDone2
    560  0985
    561  0985
    562  0985		       a9 00		      lda	#0	; on/off count
    563  0987		       85 84		      sta	drawCount	; flashing for piece about to move
    564  0989		       a9 00		      lda	#0
    565  098b		       85 82		      sta	drawDelay
    566  098d
    567  098d		       20 a2 f3 	      jsr	EnPassantRemoveCapturedPawn
    568  0990
    569  0990							;lda #100
    570  0990							;sta aiFlashDelay ;???
    571  0990
      0  0990					      PHASE	AI_FinalFlash
      1  0990		       a9 1b		      lda	#AI_FinalFlash
      2  0992		       85 8b		      sta	aiState
    573  0994		       60		      rts
    574  0995
    575  0995
    576  0995							;---------------------------------------------------------------------------------------------------
    577  0995
      0  0995					      DEF	CastleFixupDraw
      1  0995				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  0995				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  0995				   CastleFixupDraw
      4  0995				   TEMPORARY_VAR SET	Overlay
      5  0995				   TEMPORARY_OFFSET SET	0
      6  0995				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  0995				   FUNCTION_NAME SET	CastleFixupDraw
    579  0995					      SUBROUTINE
    580  0995
      0  0995					      REFER	aiSpecialMoveFixup	;✅
      1  0995					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0995				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0995					      ENDIF
      0  0995					      VEND	CastleFixupDraw
      1  0995				  -	      IFNCONST	CastleFixupDraw
      2  0995				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  0995				  -	      ERR
      4  0995					      ENDIF
      5  0995		       00 b5	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    583  0995
    584  0995							; guarantee flags for piece, post-move, are correct
    585  0995
    586  0995
    587  0995		       a9 d2		      lda	#RAMBANK_BOARD
    588  0997		       85 3e		      sta	SET_BANK_RAM	;@2
    589  0999
    590  0999		       a5 96		      lda	fromPiece
    591  099b		       29 df		      and	#~FLAG_ENPASSANT
    592  099d		       09 40		      ora	#FLAG_MOVED
    593  099f
    594  099f		       a4 85		      ldy	fromX12	; destinatino
      0  09a1					      sta@RAM	Board,y
      1  09a1		       99 79 fe 	      sta	[RAM]+Board,y
    596  09a4
    597  09a4
    598  09a4							; fixup any castling issues
    599  09a4							; at this point the king has finished his two-square march
    600  09a4							; based on the finish square, we determine which rook we're interacting with
    601  09a4							; and generate a 'move' for the rook to position on the other side of the king
    602  09a4
    603  09a4
    604  09a4					      IF	CASTLING_ENABLED
      0  09a4					      CALL	GenCastleMoveForRook	;@3
      1  09a4				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  09a4				  -FNAME      SETSTR	GenCastleMoveForRook
      3  09a4				  -	      ECHO	""
      4  09a4				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  09a4				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  09a4				  -	      ERR
      7  09a4					      ENDIF
      8  09a4		       a9 c9		      lda	#BANK_GenCastleMoveForRook
      9  09a6		       85 3f		      sta	SET_BANK
     10  09a8		       20 21 fc 	      jsr	GenCastleMoveForRook
    606  09ab		       b0 07		      bcs	.phase
    607  09ad					      ENDIF
    608  09ad
      0  09ad					      SWAP
      1  09ad		       a5 95		      lda	sideToMove
      2  09af		       49 c0		      eor	#SWAP_SIDE|HUMAN
      3  09b1		       85 95		      sta	sideToMove
      4  09b3
      5  09b3
    610  09b3		       60		      rts
    611  09b4
    612  09b4				   .phase
    613  09b4
    614  09b4							; in this siutation (castle, rook moving) we do not change sides yet!
    615  09b4
      0  09b4					      PHASE	AI_MoveIsSelected
      1  09b4		       a9 14		      lda	#AI_MoveIsSelected
      2  09b6		       85 8b		      sta	aiState
    617  09b8		       60		      rts
    618  09b9
    619  09b9
    620  09b9
    621  09b9							;---------------------------------------------------------------------------------------------------
    622  09b9
      0  09b9					      DEF	aiDrawEntireBoard
      1  09b9				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  09b9				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  09b9				   aiDrawEntireBoard
      4  09b9				   TEMPORARY_VAR SET	Overlay
      5  09b9				   TEMPORARY_OFFSET SET	0
      6  09b9				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  09b9				   FUNCTION_NAME SET	aiDrawEntireBoard
    624  09b9					      SUBROUTINE
    625  09b9
      0  09b9					      REFER	AiStateMachine	;✅
      1  09b9					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  09b9				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  09b9					      ENDIF
    627  09b9
      0  09b9					      VEND	aiDrawEntireBoard
      1  09b9				  -	      IFNCONST	aiDrawEntireBoard
      2  09b9				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  09b9				  -	      ERR
      4  09b9					      ENDIF
      5  09b9		       00 a9	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    629  09b9
    630  09b9
    631  09b9		       ad 84 02 	      lda	INTIM
    632  09bc		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    633  09be		       90 2c		      bcc	.exit
    634  09c0
    635  09c0							; We use [SLOT3] for accessing board
    636  09c0
    637  09c0		       a9 d2		      lda	#RAMBANK_BOARD
    638  09c2		       85 3e		      sta	SET_BANK_RAM
    639  09c4		       a4 80		      ldy	squareToDraw
    640  09c6		       b9 15 fc 	      lda	ValidSquare,y
    641  09c9		       30 1d		      bmi	.isablank2
    642  09cb
    643  09cb		       b9 79 fc 	      lda	Board,y
    644  09ce		       f0 13		      beq	.isablank
    645  09d0		       48		      pha
    646  09d1		       a9 00		      lda	#BLANK
      0  09d3					      sta@RAM	Board,y
      1  09d3		       99 79 fe 	      sta	[RAM]+Board,y
    648  09d6
    649  09d6							; WARNING - local variables will not survive the following call...!
    650  09d6		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    651  09d9
    652  09d9		       a9 d2		      lda	#RAMBANK_BOARD
    653  09db		       85 3e		      sta	SET_BANK_RAM
    654  09dd
    655  09dd		       a4 80		      ldy	squareToDraw
    656  09df		       68		      pla
      0  09e0					      sta@RAM	Board,y
      1  09e0		       99 79 fe 	      sta	[RAM]+Board,y
    658  09e3
      0  09e3				   .isablank  PHASE	AI_DrawPart2
      1  09e3		       a9 10		      lda	#AI_DrawPart2
      2  09e5		       85 8b		      sta	aiState
    660  09e7		       60		      rts
    661  09e8
      0  09e8				   .isablank2 PHASE	AI_DrawPart3
      1  09e8		       a9 11		      lda	#AI_DrawPart3
      2  09ea		       85 8b		      sta	aiState
    663  09ec		       60	   .exit      rts
    664  09ed
    665  09ed
    666  09ed							;---------------------------------------------------------------------------------------------------
    667  09ed
      0  09ed					      DEF	aiDrawPart2
      1  09ed				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  09ed				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  09ed				   aiDrawPart2
      4  09ed				   TEMPORARY_VAR SET	Overlay
      5  09ed				   TEMPORARY_OFFSET SET	0
      6  09ed				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  09ed				   FUNCTION_NAME SET	aiDrawPart2
    669  09ed					      SUBROUTINE
    670  09ed
      0  09ed					      REFER	AiStateMachine
      1  09ed					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  09ed				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  09ed					      ENDIF
      0  09ed					      VEND	aiDrawPart2
      1  09ed				  -	      IFNCONST	aiDrawPart2
      2  09ed				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  09ed				  -	      ERR
      4  09ed					      ENDIF
      5  09ed		       00 a9	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
    673  09ed
    674  09ed							; WARNING - local variables will not survive the following call...!
    675  09ed		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    676  09f0
      0  09f0					      DEF	aiDrawPart3
      1  09f0				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  09f0				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  09f0				   aiDrawPart3
      4  09f0				   TEMPORARY_VAR SET	Overlay
      5  09f0				   TEMPORARY_OFFSET SET	0
      6  09f0				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  09f0				   FUNCTION_NAME SET	aiDrawPart3
    678  09f0					      SUBROUTINE
    679  09f0
    680  09f0		       c6 80		      dec	squareToDraw
    681  09f2		       a5 80		      lda	squareToDraw
    682  09f4		       c9 16		      cmp	#22
    683  09f6		       90 05		      bcc	.comp
    684  09f8
      0  09f8					      PHASE	AI_DrawEntireBoard
      1  09f8		       a9 0f		      lda	#AI_DrawEntireBoard
      2  09fa		       85 8b		      sta	aiState
    686  09fc		       60		      rts
    687  09fd
    688  09fd				   .comp
    689  09fd
    690  09fd		       a9 ff		      lda	#-1
    691  09ff		       85 86		      sta	toX12	; becomes startup flash square
    692  0a01		       a9 24		      lda	#36	; becomes cursor position
    693  0a03		       85 87		      sta	originX12
    694  0a05
    695  0a05
      0  0a05					      PHASE	AI_GenerateMoves
      1  0a05		       a9 12		      lda	#AI_GenerateMoves
      2  0a07		       85 8b		      sta	aiState
    697  0a09		       60		      rts
    698  0a0a
    699  0a0a
    700  0a0a							;---------------------------------------------------------------------------------------------------
    701  0a0a
      0  0a0a					      DEF	aiMarchB
      1  0a0a				   SLOT_aiMarchB SET	_BANK_SLOT
      2  0a0a				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  0a0a				   aiMarchB
      4  0a0a				   TEMPORARY_VAR SET	Overlay
      5  0a0a				   TEMPORARY_OFFSET SET	0
      6  0a0a				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  0a0a				   FUNCTION_NAME SET	aiMarchB
    703  0a0a					      SUBROUTINE
    704  0a0a
      0  0a0a					      REFER	AiStateMachine
      1  0a0a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a0a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a0a					      ENDIF
      0  0a0a					      VEND	aiMarchB
      1  0a0a				  -	      IFNCONST	aiMarchB
      2  0a0a				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  0a0a				  -	      ERR
      4  0a0a					      ENDIF
      5  0a0a		       00 a9	   VAREND_aiMarchB =	TEMPORARY_VAR
    707  0a0a
    708  0a0a							; Draw the piece in the new square
    709  0a0a
    710  0a0a		       a5 85		      lda	fromX12
    711  0a0c		       85 80		      sta	squareToDraw
    712  0a0e
    713  0a0e							; WARNING - local variables will not survive the following call...!
    714  0a0e		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
    715  0a11
    716  0a11		       a9 02		      lda	#2	; snail trail delay
    717  0a13		       85 82		      sta	drawDelay
    718  0a15
      0  0a15					      PHASE	AI_MarchToTargetB
      1  0a15		       a9 19		      lda	#AI_MarchToTargetB
      2  0a17		       85 8b		      sta	aiState
    720  0a19		       60		      rts
    721  0a1a
    722  0a1a
    723  0a1a							;---------------------------------------------------------------------------------------------------
    724  0a1a
      0  0a1a					      DEF	aiDraw
      1  0a1a				   SLOT_aiDraw SET	_BANK_SLOT
      2  0a1a				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  0a1a				   aiDraw
      4  0a1a				   TEMPORARY_VAR SET	Overlay
      5  0a1a				   TEMPORARY_OFFSET SET	0
      6  0a1a				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  0a1a				   FUNCTION_NAME SET	aiDraw
    726  0a1a					      SUBROUTINE
    727  0a1a		       a9 c0		      lda	#$C0
    728  0a1c		       85 49		      sta	COLUBK
    729  0a1e		       60		      rts
    730  0a1f
    731  0a1f
    732  0a1f							;---------------------------------------------------------------------------------------------------
    733  0a1f
      0  0a1f					      DEF	aiCheckMate
      1  0a1f				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  0a1f				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  0a1f				   aiCheckMate
      4  0a1f				   TEMPORARY_VAR SET	Overlay
      5  0a1f				   TEMPORARY_OFFSET SET	0
      6  0a1f				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  0a1f				   FUNCTION_NAME SET	aiCheckMate
    735  0a1f					      SUBROUTINE
    736  0a1f		       a9 44		      lda	#$44
    737  0a21		       85 49		      sta	COLUBK
    738  0a23		       60		      rts
    739  0a24
    740  0a24
    741  0a24							;---------------------------------------------------------------------------------------------------
    742  0a24
      0  0a24					      DEF	aiQuiescent
      1  0a24				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  0a24				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  0a24				   aiQuiescent
      4  0a24				   TEMPORARY_VAR SET	Overlay
      5  0a24				   TEMPORARY_OFFSET SET	0
      6  0a24				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  0a24				   FUNCTION_NAME SET	aiQuiescent
    744  0a24					      SUBROUTINE
    745  0a24
      0  0a24					      REFER	AiStateMachine
      1  0a24					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a24				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a24					      ENDIF
      0  0a24					      VEND	aiQuiescent
      1  0a24				  -	      IFNCONST	aiQuiescent
      2  0a24				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  0a24				  -	      ERR
      4  0a24					      ENDIF
      5  0a24		       00 a9	   VAREND_aiQuiescent =	TEMPORARY_VAR
    748  0a24
    749  0a24							; Move has been selected
    750  0a24
    751  0a24		       a9 ff		      lda	#-1
    752  0a26		       85 88		      sta	cursorX12
    753  0a28
    754  0a28		       a5 85		      lda	fromX12
    755  0a2a		       85 87		      sta	originX12
      0  0a2c					      CALL	GetPiece	;@3		    ; from the movelist
      1  0a2c				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  0a2c				  -FNAME      SETSTR	GetPiece
      3  0a2c				  -	      ECHO	""
      4  0a2c				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0a2c				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0a2c				  -	      ERR
      7  0a2c					      ENDIF
      8  0a2c		       a9 c9		      lda	#BANK_GetPiece
      9  0a2e		       85 3f		      sta	SET_BANK
     10  0a30		       20 00 fc 	      jsr	GetPiece
    757  0a33
    758  0a33		       a4 85		      ldy	fromX12
    759  0a35		       a9 d2		      lda	#RAMBANK_BOARD
    760  0a37		       85 3e		      sta	SET_BANK_RAM	;@3
    761  0a39		       b9 79 fc 	      lda	Board,y
    762  0a3c		       45 96		      eor	fromPiece
    763  0a3e		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    764  0a40		       d0 05		      bne	.promote	; promote a pawn
    765  0a42
      0  0a42					      PHASE	AI_MoveIsSelected
      1  0a42		       a9 14		      lda	#AI_MoveIsSelected
      2  0a44		       85 8b		      sta	aiState
    767  0a46		       60		      rts
    768  0a47
      0  0a47				   .promote   PHASE	AI_PromotePawnStart
      1  0a47		       a9 1f		      lda	#AI_PromotePawnStart
      2  0a49		       85 8b		      sta	aiState
    770  0a4b		       60		      rts
    771  0a4c
    772  0a4c
    773  0a4c							;---------------------------------------------------------------------------------------------------
    774  0a4c
      0  0a4c					      CHECK_BANK_SIZE	"BANK_GENERIC@1#1"
      1  0a4c		       02 4c	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@1#1 (1K) SIZE =  $24c , FREE= $1b4
      2  0a4c					      ECHO	"BANK_GENERIC@1#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  0a4c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0a4c				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@1#1", " size=", * - ORIGIN
      5  0a4c				  -	      ERR
      6  0a4c					      ENDIF
    776  0a4c
    777  0a4c							;---------------------------------------------------------------------------------------------------
    778  0a4c							; EOF
------- FILE ./chess.asm
    549  0a4c
------- FILE @2 SCREEN RAM.asm LEVEL 2 PASS 4
      0  0a4c					      include	"@2 SCREEN RAM.asm"
      0  0a4c					      SLOT	2
      1  0a4c				  -	      IF	(2 < 0) || (2 > 3)
      2  0a4c				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0a4c				  -	      ERR
      4  0a4c					      ENDIF
      5  0a4c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0a4c				   _BANK_SLOT SET	2 * 64
      2  0a4c					      REPEAT	(CHESSBOARD_ROWS)
      0  0a4c					      RAMBANK	.DUMMY
      1  0a4c
      2 U0e00 ????				      SEG.U	RAM_.DUMMY
      3 U0000					      ORG	ORIGIN_RAM
      4 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0000				   _BANK_START SET	*
      6 U0000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0000				   RAMBANK_.DUMMY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0000				   _LAST_BANK SETSTR	.DUMMY
     10 U0000
      2 U0000					      REPEND
      0 U0000					      RAMBANK	.DUMMY
      1 U0000
      2 U0000					      SEG.U	RAM_.DUMMY
      3 U0200					      ORG	ORIGIN_RAM
      4 U0200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0200				   _BANK_START SET	*
      6 U0200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0200				   RAMBANK_.DUMMY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0200				   _LAST_BANK SETSTR	.DUMMY
     10 U0200
      2 U0200					      REPEND
      0 U0200					      RAMBANK	.DUMMY
      1 U0200
      2 U0200					      SEG.U	RAM_.DUMMY
      3 U0400					      ORG	ORIGIN_RAM
      4 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0400				   _BANK_START SET	*
      6 U0400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0400				   RAMBANK_.DUMMY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0400				   _LAST_BANK SETSTR	.DUMMY
     10 U0400
      2 U0400					      REPEND
      0 U0400					      RAMBANK	.DUMMY
      1 U0400
      2 U0400					      SEG.U	RAM_.DUMMY
      3 U0600					      ORG	ORIGIN_RAM
      4 U0600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0600				   _BANK_START SET	*
      6 U0600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0600				   RAMBANK_.DUMMY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0600				   _LAST_BANK SETSTR	.DUMMY
     10 U0600
      2 U0600					      REPEND
      0 U0600					      RAMBANK	.DUMMY
      1 U0600
      2 U0600					      SEG.U	RAM_.DUMMY
      3 U0800					      ORG	ORIGIN_RAM
      4 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0800				   _BANK_START SET	*
      6 U0800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0800				   RAMBANK_.DUMMY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0800				   _LAST_BANK SETSTR	.DUMMY
     10 U0800
      2 U0800					      REPEND
      0 U0800					      RAMBANK	.DUMMY
      1 U0800
      2 U0800					      SEG.U	RAM_.DUMMY
      3 U0a00					      ORG	ORIGIN_RAM
      4 U0a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0a00				   _BANK_START SET	*
      6 U0a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0a00				   RAMBANK_.DUMMY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0a00				   _LAST_BANK SETSTR	.DUMMY
     10 U0a00
      2 U0a00					      REPEND
      0 U0a00					      RAMBANK	.DUMMY
      1 U0a00
      2 U0a00					      SEG.U	RAM_.DUMMY
      3 U0c00					      ORG	ORIGIN_RAM
      4 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0c00				   _BANK_START SET	*
      6 U0c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0c00				   RAMBANK_.DUMMY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0c00				   _LAST_BANK SETSTR	.DUMMY
     10 U0c00
      2 U0c00					      REPEND
      0 U0c00					      RAMBANK	.DUMMY
      1 U0c00
      2 U0c00					      SEG.U	RAM_.DUMMY
      3 U0e00					      ORG	ORIGIN_RAM
      4 U0e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0e00				   _BANK_START SET	*
      6 U0e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0e00				   RAMBANK_.DUMMY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0e00				   _LAST_BANK SETSTR	.DUMMY
     10 U0e00
      4 U0e00					      REPEND
      5 U0e00
      6 U0e00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
      7 U0e00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
      8 U0e00							; The variable definitions are also in that ROM bank (even though they're RAM :)
      9 U0e00
     10 U0e00							; Now we have the actual graphics data for each of the rows.  This consists of an
     11 U0e00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
     12 U0e00							; character shapes are masked/copied. The depth of the character shapes may be
     13 U0e00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
     14 U0e00							; a multiple of 3, so that the RGB scanlines match at character joins.
     15 U0e00
     16 U0e00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
     17 U0e00							; accessed via the above labels but with the appropriate bank switched in.
     18 U0e00
      0 U0e00					      ROMBANK	BITMAP
      1  0da6 ????				      SEG	BITMAP
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   BITMAP_START SET	*
      6  0c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  0c00				   BITMAP     SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + 1024
     20  0c00
     21  0c00							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
     22  0c00
     23  0c00		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
     24  0c00
     25  0c00		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     26  0c00		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     27  0c00		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     28  0c00		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     29  0c00		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     30  0c00		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     31  0c00
     32  0c00							; Template bank for a SINGLE ROW of the chessboard display.
     33  0c00							; There are 8x of these.
     34  0c00							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     35  0c00							; The bank is copied from ROM into RAM at startup.
     36  0c00							; The draw switches between consecutive row banks, with the last returning
     37  0c00							; we effectively have 1K
     38  0c00							;---------------------------------------------------------------------------------------------------
     39  0c00
     40  0c00		       00 82	   COLOUR_LINE_1 =	$82
     41  0c00		       00 38	   COLOUR_LINE_2 =	$38
     42  0c00		       00 2a	   COLOUR_LINE_3 =	$2A
     43  0c00		       00 00	   BACKGCOL   =	$0
     44  0c00
     45  0c00				  -	      IF	0
     46  0c00				  -COLOUR_LINE_1 =	$84
     47  0c00				  -COLOUR_LINE_2 =	$38
     48  0c00				  -COLOUR_LINE_3 =	$2A
     49  0c00				  -BACKGCOL   =	$00
     50  0c00					      ENDIF
     51  0c00
     52  0c00		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     53  0c00
     54  0c00
      0  0c00					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      0  0c00					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  0c00					      LIST	ON
      0  0c00					      DEF	SHADOW_ChessBitmap
      1  0c00				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  0c00				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  0c00				   SHADOW_ChessBitmap
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	SHADOW_ChessBitmap
     56  0c00		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     57  0c18		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     58  0c30		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     59  0c48		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     60  0c60		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     61  0c78		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     62  0c90
      0  0c90					      ALLOCATE	BlankSprite, 8
      0  0c90					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0c90					      LIST	ON
      0  0c90					      DEF	BlankSprite
      1  0c90				   SLOT_BlankSprite SET	_BANK_SLOT
      2  0c90				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  0c90				   BlankSprite
      4  0c90				   TEMPORARY_VAR SET	Overlay
      5  0c90				   TEMPORARY_OFFSET SET	0
      6  0c90				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  0c90				   FUNCTION_NAME SET	BlankSprite
     64  0c90		       00 00 00 00*	      ds	8, 0
     65  0c98
      0  0c98					      ALLOCATE	SpriteBuffer, 8
      0  0c98					      OPTIONAL_PAGEBREAK	"Table", 8
     12  0c98					      LIST	ON
      0  0c98					      DEF	SpriteBuffer
      1  0c98				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  0c98				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  0c98				   SpriteBuffer
      4  0c98				   TEMPORARY_VAR SET	Overlay
      5  0c98				   TEMPORARY_OFFSET SET	0
      6  0c98				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  0c98				   FUNCTION_NAME SET	SpriteBuffer
     67  0c98				   SpriteBuffer2
     68  0c98		       f8		      .byte.b	%11111000
     69  0c99		       f8		      .byte.b	%11111000
     70  0c9a		       f8		      .byte.b	%11111000
     71  0c9b		       f8		      .byte.b	%11111000
     72  0c9c		       f8		      .byte.b	%11111000
     73  0c9d		       f8		      .byte.b	%11111000
     74  0c9e		       f8		      .byte.b	%11111000
     75  0c9f		       f8		      .byte.b	%11111000
     76  0ca0
     77  0ca0				  -	      IF	0
     78  0ca0				  -	      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
     79  0ca0				  -	      ds	ROW_BITMAP_SIZE, 0
     80  0ca0					      ENDIF
     81  0ca0
     82  0ca0							;---------------------------------------------------------------------------------------------------
     83  0ca0
     84  0d00		       00 00 00 00*	      ALIGN	256
     85  0d00					      SUBROUTINE
     86  0d00
      0  0d00					      REFER	StartupBankReset
      1  0d00				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0d00				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0d00					      ENDIF
     88  0d00				   __dummy
      0  0d00					      VEND	__dummy
      1  0d00				  -	      IFNCONST	__dummy
      2  0d00				  -	      ECHO	"Incorrect VEND label", __dummy
      3  0d00				  -	      ERR
      4  0d00					      ENDIF
      5  0d00		       00 a7	   VAREND___dummy =	TEMPORARY_VAR
     90  0d00
     91  0d00							; x = row # (and bank#)
     92  0d00
     93  0d00				   .endline
     94  0d00
     95  0d00							;@59
     96  0d00
     97  0d00							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
     98  0d00							; Note that the other 7 row banks are unmodified (keeping the 'inx')
     99  0d00				   SELFMOD_RTS_ON_LAST_ROW
    100  0d00
    101  0d00		       e8		      inx		; 2
    102  0d01		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
    103  0d03
      0  0d03					      DEF	DrawRow
      1  0d03				   SLOT_DrawRow SET	_BANK_SLOT
      2  0d03				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  0d03				   DrawRow
      4  0d03				   TEMPORARY_VAR SET	Overlay
      5  0d03				   TEMPORARY_OFFSET SET	0
      6  0d03				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  0d03				   FUNCTION_NAME SET	DrawRow
    105  0d03
    106  0d03							;@64
    107  0d03		       a0 07		      ldy	#7	; 2
    108  0d05		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
    109  0d07
    110  0d07							;@58...
    111  0d07
    112  0d07				   .l3
    113  0d07
    114  0d07		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
    115  0d0a		       85 5b		      sta	GRP0	; 3
    116  0d0c		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
    117  0d0f		       85 5c		      sta	GRP1	; 3
    118  0d11
    119  0d11							;@-4
    120  0d11
    121  0d11		       a9 82		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    122  0d13		       85 48		      sta	COLUPF	; 3 @1
    123  0d15
    124  0d15		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    125  0d18		       85 4d		      sta	PF0	; 3
    126  0d1a		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    127  0d1d		       85 4e		      sta	PF1	; 3
    128  0d1f		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    129  0d22		       85 4f		      sta	PF2	; 3 @22
    130  0d24
      0  0d24					      SLEEP	6	; 6 @28
      1  0d24				   .CYCLES    SET	6
      2  0d24
      3  0d24				  -	      IF	.CYCLES < 2
      4  0d24				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d24				  -	      ERR
      6  0d24					      ENDIF
      7  0d24
      8  0d24				  -	      IF	.CYCLES & 1
      9  0d24				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d24				  -	      nop	0
     11  0d24				  -	      ELSE
     12  0d24				  -	      bit	VSYNC
     13  0d24				  -	      ENDIF
     14  0d24				  -.CYCLES    SET	.CYCLES - 3
     15  0d24					      ENDIF
     16  0d24
     17  0d24					      REPEAT	.CYCLES / 2
     18  0d24		       ea		      nop
     17  0d24					      REPEND
     18  0d25		       ea		      nop
     17  0d25					      REPEND
     18  0d26		       ea		      nop
     19  0d27					      REPEND
    132  0d27
    133  0d27		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    134  0d2a		       85 4d		      sta	PF0	; 3
    135  0d2c		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    136  0d2f		       85 4e		      sta	PF1	; 3
    137  0d31		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    138  0d34		       8d 4f 00 	      sta.w	PF2	; 4 @50
    139  0d37
      0  0d37					      SLEEP	4	; 4
      1  0d37				   .CYCLES    SET	4
      2  0d37
      3  0d37				  -	      IF	.CYCLES < 2
      4  0d37				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d37				  -	      ERR
      6  0d37					      ENDIF
      7  0d37
      8  0d37				  -	      IF	.CYCLES & 1
      9  0d37				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d37				  -	      nop	0
     11  0d37				  -	      ELSE
     12  0d37				  -	      bit	VSYNC
     13  0d37				  -	      ENDIF
     14  0d37				  -.CYCLES    SET	.CYCLES - 3
     15  0d37					      ENDIF
     16  0d37
     17  0d37					      REPEAT	.CYCLES / 2
     18  0d37		       ea		      nop
     17  0d37					      REPEND
     18  0d38		       ea		      nop
     19  0d39					      REPEND
    141  0d39
    142  0d39		       88		      dey		; 2
    143  0d3a		       30 c4		      bmi	.endline	; 2 (3)
    144  0d3c
    145  0d3c							;@57
    146  0d3c				   .drawLine
    147  0d3c
      0  0d3c					      SLEEP	11
      1  0d3c				   .CYCLES    SET	11
      2  0d3c
      3  0d3c				  -	      IF	.CYCLES < 2
      4  0d3c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d3c				  -	      ERR
      6  0d3c					      ENDIF
      7  0d3c
      8  0d3c					      IF	.CYCLES & 1
      9  0d3c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d3c		       04 00		      nop	0
     11  0d3e				  -	      ELSE
     12  0d3e				  -	      bit	VSYNC
     13  0d3e					      ENDIF
     14  0d3e				   .CYCLES    SET	.CYCLES - 3
     15  0d3e					      ENDIF
     16  0d3e
     17  0d3e					      REPEAT	.CYCLES / 2
     18  0d3e		       ea		      nop
     17  0d3e					      REPEND
     18  0d3f		       ea		      nop
     17  0d3f					      REPEND
     18  0d40		       ea		      nop
     17  0d40					      REPEND
     18  0d41		       ea		      nop
     19  0d42					      REPEND
    149  0d42
    150  0d42				   .dl2
    151  0d42		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    152  0d45		       85 5b		      sta	GRP0	; 3
    153  0d47		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    154  0d4a		       85 5c		      sta	GRP1	; 3
    155  0d4c
    156  0d4c							;@7
    157  0d4c
    158  0d4c		       a9 38		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    159  0d4e		       85 48		      sta	COLUPF	; 3 @12
    160  0d50
    161  0d50		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    162  0d53		       85 4d		      sta	PF0	; 3
    163  0d55		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    164  0d58		       85 4e		      sta	PF1	; 3
    165  0d5a		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    166  0d5d		       85 4f		      sta	PF2	; 3 @33
    167  0d5f
      0  0d5f					      SLEEP	3	; 3 @36
      1  0d5f				   .CYCLES    SET	3
      2  0d5f
      3  0d5f				  -	      IF	.CYCLES < 2
      4  0d5f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d5f				  -	      ERR
      6  0d5f					      ENDIF
      7  0d5f
      8  0d5f					      IF	.CYCLES & 1
      9  0d5f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d5f		       04 00		      nop	0
     11  0d61				  -	      ELSE
     12  0d61				  -	      bit	VSYNC
     13  0d61					      ENDIF
     14  0d61				   .CYCLES    SET	.CYCLES - 3
     15  0d61					      ENDIF
     16  0d61
     17  0d61				  -	      REPEAT	.CYCLES / 2
     18  0d61				  -	      nop
     19  0d61					      REPEND
    169  0d61
    170  0d61		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    171  0d64		       85 4d		      sta	PF0	; 3
    172  0d66		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    173  0d69		       85 4e		      sta	PF1	; 3
    174  0d6b		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    175  0d6e		       85 4f		      sta	PF2	; 3 @57
    176  0d70
      0  0d70					      SLEEP	5
      1  0d70				   .CYCLES    SET	5
      2  0d70
      3  0d70				  -	      IF	.CYCLES < 2
      4  0d70				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d70				  -	      ERR
      6  0d70					      ENDIF
      7  0d70
      8  0d70					      IF	.CYCLES & 1
      9  0d70					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d70		       04 00		      nop	0
     11  0d72				  -	      ELSE
     12  0d72				  -	      bit	VSYNC
     13  0d72					      ENDIF
     14  0d72				   .CYCLES    SET	.CYCLES - 3
     15  0d72					      ENDIF
     16  0d72
     17  0d72					      REPEAT	.CYCLES / 2
     18  0d72		       ea		      nop
     19  0d73					      REPEND
    178  0d73
    179  0d73		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    180  0d76		       85 5b		      sta	GRP0	; 3
    181  0d78		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    182  0d7b		       85 5c		      sta	GRP1	; 3
    183  0d7d
    184  0d7d							;@0
    185  0d7d		       a9 2a		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    186  0d7f		       85 48		      sta	COLUPF	; 3 @5
    187  0d81
    188  0d81		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    189  0d84		       85 4d		      sta	PF0	; 3
    190  0d86		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    191  0d89		       85 4e		      sta	PF1	; 3
    192  0d8b		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    193  0d8e		       85 4f		      sta	PF2	; 3 @26
    194  0d90
      0  0d90					      SLEEP	8	; 6 @34
      1  0d90				   .CYCLES    SET	8
      2  0d90
      3  0d90				  -	      IF	.CYCLES < 2
      4  0d90				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d90				  -	      ERR
      6  0d90					      ENDIF
      7  0d90
      8  0d90				  -	      IF	.CYCLES & 1
      9  0d90				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d90				  -	      nop	0
     11  0d90				  -	      ELSE
     12  0d90				  -	      bit	VSYNC
     13  0d90				  -	      ENDIF
     14  0d90				  -.CYCLES    SET	.CYCLES - 3
     15  0d90					      ENDIF
     16  0d90
     17  0d90					      REPEAT	.CYCLES / 2
     18  0d90		       ea		      nop
     17  0d90					      REPEND
     18  0d91		       ea		      nop
     17  0d91					      REPEND
     18  0d92		       ea		      nop
     17  0d92					      REPEND
     18  0d93		       ea		      nop
     19  0d94					      REPEND
    196  0d94
    197  0d94		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    198  0d97		       85 4d		      sta	PF0	; 3
    199  0d99		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    200  0d9c		       85 4e		      sta	PF1	; 3
    201  0d9e		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    202  0da1		       85 4f		      sta	PF2	; 3 @55
    203  0da3
    204  0da3		       4c 07 f9 	      jmp	.l3	; 3 @58
    205  0da6
    206  0da6
    207  0da6
    208  0da6							;---------------------------------------------------------------------------------------------------
    209  0da6
      0  0da6					      CHECK_RAM_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  0da6		       01 a6	   .TEMP      =	* - _BANK_START
 ROM_SHADOW_SCREEN (512 byte) SIZE =  $1a6 , FREE= $5a
      2  0da6					      ECHO	"ROM_SHADOW_SCREEN", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  0da6				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  0da6				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SHADOW_SCREEN", " size=", * - ORIGIN
      5  0da6				  -	      ERR
      6  0da6					      ENDIF
    211  0da6
    212  0da6							;---------------------------------------------------------------------------------------------------
    213  0da6							;EOF
------- FILE ./chess.asm
------- FILE @2 PLY.asm LEVEL 2 PASS 4
      0  0da6					      include	"@2 PLY.asm"
      1  0da6							; Chess
      2  0da6							; Copyright (c) 2019-2020 Andrew Davie
      3  0da6							; andrew@taswegian.com
      4  0da6
      5  0da6
      6  0da6							;---------------------------------------------------------------------------------------------------
      7  0da6							; Define the RAM banks
      8  0da6							; A "PLY" bank represents all the data required on any single ply of the search tree.
      9  0da6							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     10  0da6							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     11  0da6							; they act as independant switchable banks usable for data on each ply during the search.
     12  0da6							; A ply will hold the move list for that position
     13  0da6
     14  0da6
      0  0da6					      SLOT	2
      1  0da6				  -	      IF	(2 < 0) || (2 > 3)
      2  0da6				  -	      ECHO	"Illegal bank address/segment location", 2
      3  0da6				  -	      ERR
      4  0da6					      ENDIF
      5  0da6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  0da6				   _BANK_SLOT SET	2 * 64
      0  0da6					      RAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  0da6
      2 U11dc ????				      SEG.U	RAM_PLY
      3 U1000					      ORG	ORIGIN_RAM
      4 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1000				   _BANK_START SET	*
      6 U1000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1000				   RAMBANK_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1000				   _LAST_BANK SETSTR	PLY
     10 U1000
     17 U1000
     18 U1000							;---------------------------------------------------------------------------------------------------
     19 U1000
     20 U1000		       00 64	   MAX_MOVES  =	100	; big is good
     21 U1000
      0 U1000					      VARIABLE	MoveFrom, MAX_MOVES
      0 U1000					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U1000					      LIST	ON
      2 U1000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0 U1064					      VARIABLE	MoveTo, MAX_MOVES
      0 U1064					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U1064					      LIST	ON
      2 U1064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0 U10c8					      VARIABLE	MovePiece, MAX_MOVES
      0 U10c8					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U1100					      LIST	ON
      2 U1100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0 U1164					      VARIABLE	MoveCapture, MAX_MOVES
      0 U1164					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12 U1164					      LIST	ON
      2 U1164		       00 00 00 00*MoveCapture ds	MAX_MOVES
     26 U11c8
     27 U11c8
     28 U11c8							;---------------------------------------------------------------------------------------------------
     29 U11c8
     30 U11c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     31 U11c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     32 U11c8
      0 U11c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0 U11c8					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U11c8					      LIST	ON
      2 U11c8		       00 00	   savedEvaluation ds	2
      0 U11ca					      VARIABLE	enPassantSquare, 1
      0 U11ca					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11ca					      LIST	ON
      2 U11ca		       00	   enPassantSquare ds	1
      0 U11cb					      VARIABLE	capturedPiece, 1
      0 U11cb					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11cb					      LIST	ON
      2 U11cb		       00	   capturedPiece ds	1
     36 U11cc							;VARIABLE originalPiece, 1
      0 U11cc					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0 U11cc					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11cc					      LIST	ON
      2 U11cc		       00	   secondaryPiece ds	1
      0 U11cd					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0 U11cd					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11cd					      LIST	ON
      2 U11cd		       00	   secondarySquare ds	1
      0 U11ce					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0 U11ce					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11ce					      LIST	ON
      2 U11ce		       00	   secondaryBlank ds	1
      0 U11cf					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0 U11cf					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11cf					      LIST	ON
      2 U11cf		       00	   moveIndex  ds	1
      0 U11d0					      VARIABLE	movePtr, 1
      0 U11d0					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11d0					      LIST	ON
      2 U11d0		       00	   movePtr    ds	1
      0 U11d1					      VARIABLE	bestMove, 1
      0 U11d1					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11d1					      LIST	ON
      2 U11d1		       00	   bestMove   ds	1
      0 U11d2					      VARIABLE	alpha, 2
      0 U11d2					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U11d2					      LIST	ON
      2 U11d2		       00 00	   alpha      ds	2
      0 U11d4					      VARIABLE	beta, 2
      0 U11d4					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U11d4					      LIST	ON
      2 U11d4		       00 00	   beta       ds	2
      0 U11d6					      VARIABLE	value, 2
      0 U11d6					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U11d6					      LIST	ON
      2 U11d6		       00 00	   value      ds	2
      0 U11d8					      VARIABLE	depthLeft, 1
      0 U11d8					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11d8					      LIST	ON
      2 U11d8		       00	   depthLeft  ds	1
      0 U11d9					      VARIABLE	restorePiece, 1
      0 U11d9					      OPTIONAL_PAGEBREAK	"Variable", 1
     12 U11d9					      LIST	ON
      2 U11d9		       00	   restorePiece ds	1
      0 U11da					      VARIABLE	virtualKingSquare, 2	; traversing squares for castle/check
      0 U11da					      OPTIONAL_PAGEBREAK	"Variable", 2
     12 U11da					      LIST	ON
      2 U11da		       00 00	   virtualKingSquare ds	2
     49 U11dc
     50 U11dc
      0 U11dc					      CHECK_RAM_BANK_SIZE	"SHADOW_PLY"
      1 U11dc		       01 dc	   .TEMP      =	* - _BANK_START
 SHADOW_PLY (512 byte) SIZE =  $1dc , FREE= $24
      2 U11dc					      ECHO	"SHADOW_PLY", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3 U11dc				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U11dc				  -	      ECHO	"BANK OVERFLOW @ ", "SHADOW_PLY", " size=", * - ORIGIN
      5 U11dc				  -	      ERR
      6 U11dc					      ENDIF
     52 U11dc
     53 U11dc					      REPEAT	PLY_BANKS-1
      0 U11dc					      RAMBANK	.DUMMY_PLY
      1 U11dc
      2 U2000 ????				      SEG.U	RAM_.DUMMY_PLY
      3 U1200					      ORG	ORIGIN_RAM
      4 U1200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1200				   _BANK_START SET	*
      6 U1200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1200				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1200
     53 U1200					      REPEND
      0 U1200					      RAMBANK	.DUMMY_PLY
      1 U1200
      2 U1200					      SEG.U	RAM_.DUMMY_PLY
      3 U1400					      ORG	ORIGIN_RAM
      4 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1400				   _BANK_START SET	*
      6 U1400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1400				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1400
     53 U1400					      REPEND
      0 U1400					      RAMBANK	.DUMMY_PLY
      1 U1400
      2 U1400					      SEG.U	RAM_.DUMMY_PLY
      3 U1600					      ORG	ORIGIN_RAM
      4 U1600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1600				   _BANK_START SET	*
      6 U1600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1600				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1600				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1600
     53 U1600					      REPEND
      0 U1600					      RAMBANK	.DUMMY_PLY
      1 U1600
      2 U1600					      SEG.U	RAM_.DUMMY_PLY
      3 U1800					      ORG	ORIGIN_RAM
      4 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1800				   _BANK_START SET	*
      6 U1800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1800				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1800
     53 U1800					      REPEND
      0 U1800					      RAMBANK	.DUMMY_PLY
      1 U1800
      2 U1800					      SEG.U	RAM_.DUMMY_PLY
      3 U1a00					      ORG	ORIGIN_RAM
      4 U1a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1a00				   _BANK_START SET	*
      6 U1a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1a00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1a00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1a00
     53 U1a00					      REPEND
      0 U1a00					      RAMBANK	.DUMMY_PLY
      1 U1a00
      2 U1a00					      SEG.U	RAM_.DUMMY_PLY
      3 U1c00					      ORG	ORIGIN_RAM
      4 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1c00				   _BANK_START SET	*
      6 U1c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1c00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1c00
     53 U1c00					      REPEND
      0 U1c00					      RAMBANK	.DUMMY_PLY
      1 U1c00
      2 U1c00					      SEG.U	RAM_.DUMMY_PLY
      3 U1e00					      ORG	ORIGIN_RAM
      4 U1e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1e00				   _BANK_START SET	*
      6 U1e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1e00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1e00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1e00
     53 U1e00					      REPEND
      0 U1e00					      RAMBANK	.DUMMY_PLY
      1 U1e00
      2 U1e00					      SEG.U	RAM_.DUMMY_PLY
      3 U2000					      ORG	ORIGIN_RAM
      4 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2000				   _BANK_START SET	*
      6 U2000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2000				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2000
     55 U2000					      REPEND
     56 U2000
     57 U2000
     58 U2000							;---------------------------------------------------------------------------------------------------
     59 U2000							; EOF
------- FILE ./chess.asm
------- FILE @2 GENERIC #3.asm LEVEL 2 PASS 4
      0 U2000					      include	"@2 GENERIC #3.asm"
      1 U2000
      0 U2000					      SLOT	2
      1 U2000				  -	      IF	(2 < 0) || (2 > 3)
      2 U2000				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U2000				  -	      ERR
      4 U2000					      ENDIF
      5 U2000				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U2000				   _BANK_SLOT SET	2 * 64
      0 U2000					      ROMBANK	GENERIC_BANK@2#1
      1  1393 ????				      SEG	GENERIC_BANK@2#1
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   GENERIC_BANK@2#1_START SET	*
      6  1000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1000				   GENERIC_BANK@2#1 SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + 1024
      4  1000
      5  1000							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
      6  1000
      7  1000				  -	      IF	0
      8  1000				  -	      IF	PLUSCART = YES
      9  1000				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     10  1000				  -	      .byte	"pluscart.firmaplus.de", #0
     11  1000				  -	      ENDIF
     12  1000					      ENDIF
     13  1000
     14  1000		       54 4a 33 45 STELLA_AUTODETECT dc	"TJ3E"	; 3E+ autodetect
     15  1004
     16  1004
     17  1004							;---------------------------------------------------------------------------------------------------
     18  1004
      0  1004					      DEF	tidySc
      1  1004				   SLOT_tidySc SET	_BANK_SLOT
      2  1004				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  1004				   tidySc
      4  1004				   TEMPORARY_VAR SET	Overlay
      5  1004				   TEMPORARY_OFFSET SET	0
      6  1004				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  1004				   FUNCTION_NAME SET	tidySc
     20  1004					      SUBROUTINE
     21  1004
      0  1004					      REFER	StartupBankReset	;✅
      1  1004				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1004				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1004					      ENDIF
      0  1004					      VEND	tidySc
      1  1004				  -	      IFNCONST	tidySc
      2  1004				  -	      ECHO	"Incorrect VEND label", tidySc
      3  1004				  -	      ERR
      4  1004					      ENDIF
      5  1004		       00 a7	   VAREND_tidySc =	TEMPORARY_VAR
     24  1004
     25  1004		       a9 00		      lda	#0
     26  1006		       85 4d		      sta	PF0
     27  1008		       85 4e		      sta	PF1
     28  100a		       85 4f		      sta	PF2
     29  100c		       85 5b		      sta	GRP0
     30  100e
     31  100e		       a9 42		      lda	#%01000010	; bit6 is not required
     32  1010							;sta VBLANK			  ; end of screen - enter blanking
     33  1010
     34  1010
     35  1010							; END OF VISIBLE SCREEN
     36  1010							; HERE'S SOME TIME TO DO STUFF
     37  1010
     38  1010		       a9 2e		      lda	#TIME_PART_2
     39  1012		       8d 96 02 	      sta	TIM64T
     40  1015		       60		      rts
     41  1016
     42  1016
     43  1016							;---------------------------------------------------------------------------------------------------
     44  1016
      0  1016					      DEF	longD
      1  1016				   SLOT_longD SET	_BANK_SLOT
      2  1016				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  1016				   longD
      4  1016				   TEMPORARY_VAR SET	Overlay
      5  1016				   TEMPORARY_OFFSET SET	0
      6  1016				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  1016				   FUNCTION_NAME SET	longD
     46  1016					      SUBROUTINE
     47  1016
      0  1016					      REFER	StartupBankReset	;✅
      1  1016				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1016				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1016					      ENDIF
      0  1016					      VEND	longD
      1  1016				  -	      IFNCONST	longD
      2  1016				  -	      ECHO	"Incorrect VEND label", longD
      3  1016				  -	      ERR
      4  1016					      ENDIF
      5  1016		       00 a7	   VAREND_longD =	TEMPORARY_VAR
     50  1016
     51  1016		       85 42		      sta	WSYNC
     52  1018
     53  1018		       20 29 f8 	      jsr	_rts
     54  101b		       20 29 f8 	      jsr	_rts
     55  101e		       20 29 f8 	      jsr	_rts
      0  1021					      SLEEP	7
      1  1021				   .CYCLES    SET	7
      2  1021
      3  1021				  -	      IF	.CYCLES < 2
      4  1021				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1021				  -	      ERR
      6  1021					      ENDIF
      7  1021
      8  1021					      IF	.CYCLES & 1
      9  1021					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1021		       04 00		      nop	0
     11  1023				  -	      ELSE
     12  1023				  -	      bit	VSYNC
     13  1023					      ENDIF
     14  1023				   .CYCLES    SET	.CYCLES - 3
     15  1023					      ENDIF
     16  1023
     17  1023					      REPEAT	.CYCLES / 2
     18  1023		       ea		      nop
     17  1023					      REPEND
     18  1024		       ea		      nop
     19  1025					      REPEND
     57  1025
     58  1025		       a2 00		      ldx	#0
     59  1027		       86 41		      stx	VBLANK
     60  1029		       60	   _rts       rts
     61  102a
     62  102a
     63  102a							;---------------------------------------------------------------------------------------------------
     64  102a
      0  102a					      DEF	aiStartClearBoard
      1  102a				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  102a				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  102a				   aiStartClearBoard
      4  102a				   TEMPORARY_VAR SET	Overlay
      5  102a				   TEMPORARY_OFFSET SET	0
      6  102a				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  102a				   FUNCTION_NAME SET	aiStartClearBoard
     66  102a					      SUBROUTINE
     67  102a
      0  102a					      REFER	AiStateMachine	;✅
      1  102a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  102a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  102a					      ENDIF
      0  102a					      VEND	aiStartClearBoard
      1  102a				  -	      IFNCONST	aiStartClearBoard
      2  102a				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  102a				  -	      ERR
      4  102a					      ENDIF
      5  102a		       00 a9	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
     70  102a
     71  102a		       a2 08		      ldx	#8
     72  102c		       86 84		      stx	drawCount	; = bank
     73  102e
     74  102e		       a9 ff		      lda	#-1
     75  1030		       85 88		      sta	cursorX12
     76  1032
      0  1032					      PHASE	AI_ClearEachRow
      1  1032		       a9 0e		      lda	#AI_ClearEachRow
      2  1034		       85 8b		      sta	aiState
     78  1036		       60		      rts
     79  1037
     80  1037
     81  1037							;---------------------------------------------------------------------------------------------------
     82  1037
      0  1037					      DEF	aiClearEachRow
      1  1037				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  1037				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  1037				   aiClearEachRow
      4  1037				   TEMPORARY_VAR SET	Overlay
      5  1037				   TEMPORARY_OFFSET SET	0
      6  1037				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  1037				   FUNCTION_NAME SET	aiClearEachRow
     84  1037					      SUBROUTINE
     85  1037
      0  1037					      REFER	AiStateMachine	;✅
      1  1037					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1037				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1037					      ENDIF
      0  1037					      VEND	aiClearEachRow
      1  1037				  -	      IFNCONST	aiClearEachRow
      2  1037				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  1037				  -	      ERR
      4  1037					      ENDIF
      5  1037		       00 a9	   VAREND_aiClearEachRow =	TEMPORARY_VAR
     88  1037
     89  1037		       c6 84		      dec	drawCount
     90  1039		       30 00		      bmi	.bitmapCleared
     91  103b							;TODOldy drawCount
     92  103b							;TODO jmp CallClear
     93  103b
     94  103b				   .bitmapCleared
     95  103b
     96  103b		       a9 63		      lda	#99
     97  103d		       85 80		      sta	squareToDraw
     98  103f
      0  103f					      PHASE	AI_DrawEntireBoard
      1  103f		       a9 0f		      lda	#AI_DrawEntireBoard
      2  1041		       85 8b		      sta	aiState
    100  1043		       60		      rts
    101  1044
    102  1044
    103  1044							;---------------------------------------------------------------------------------------------------
    104  1044
      0  1044					      DEF	aiMoveIsSelected
      1  1044				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  1044				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  1044				   aiMoveIsSelected
      4  1044				   TEMPORARY_VAR SET	Overlay
      5  1044				   TEMPORARY_OFFSET SET	0
      6  1044				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  1044				   FUNCTION_NAME SET	aiMoveIsSelected
    106  1044					      SUBROUTINE
    107  1044
      0  1044					      COMMON_VARS
      1  1044
      0  1044					      VAR	__thinkbar, 1
      1  1044		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
      0  1044					      VAR	__toggle, 1
      1  1044		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
      4  1044
      0  1044					      VAR	__bestMove, 1
      1  1044		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
      0  1044					      VAR	__alpha, 2
      1  1044		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
      0  1044					      VAR	__beta, 2
      1  1044		       00 ac	   __beta     =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
      0  1044					      VAR	__negaMax, 2
      1  1044		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
      0  1044					      VAR	__value, 2
      1  1044		       00 b0	   __value    =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
     10  1044
      0  1044					      VAR	__quiesceCapOnly, 1
      1  1044		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
     12  1044
      0  1044					      VAR	__originalPiece, 1
      1  1044		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
      0  1044					      VAR	__capturedPiece, 1
      1  1044		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  1044				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1044
      4  1044				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1044				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1044				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1044					      ENDIF
      8  1044				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1044				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  1044				  -	      ERR
     11  1044					      ENDIF
     12  1044					      LIST	ON
     15  1044
      0  1044					      REFER	AiStateMachine	;✅
      1  1044				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1044				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1044					      ENDIF
      0  1044					      VEND	aiMoveIsSelected
      1  1044				  -	      IFNCONST	aiMoveIsSelected
      2  1044				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  1044				  -	      ERR
      4  1044					      ENDIF
      5  1044		       00 b5	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    111  1044
    112  1044							; Both computer and human have now seleted a move, and converge here
    113  1044
    114  1044
    115  1044							; fromPiece	 piece doing the move
    116  1044							; fromX12	 current square X12
    117  1044							; originX12	 starting square X12
    118  1044							; toX12	 ending square X12
    119  1044
    120  1044		       20 6b f8 	      jsr	EnPassantFixupDraw
    121  1047
    122  1047							; get the piece types from the board
    123  1047
    124  1047		       a9 d2		      lda	#RAMBANK_BOARD
    125  1049		       85 3e		      sta	SET_BANK_RAM	;@3
    126  104b		       a4 87		      ldy	originX12
    127  104d		       b9 79 fc 	      lda	Board,y
    128  1050		       85 b3		      sta	__originalPiece
    129  1052		       a4 86		      ldy	toX12
    130  1054		       b9 79 fc 	      lda	Board,y
    131  1057		       85 b4		      sta	__capturedPiece
    132  1059
    133  1059
    134  1059		       20 e3 f8 	      jsr	AdjustMaterialPositionalValue	;@this
    135  105c
    136  105c		       a9 00		      lda	#0
    137  105e		       85 98		      sta	previousPiece
    138  1060		       85 82		      sta	drawDelay
    139  1062
    140  1062		       a9 0a		      lda	#10	; on/off count
    141  1064		       85 84		      sta	drawCount	; flashing for piece about to move
    142  1066
      0  1066					      PHASE	AI_WriteStartPieceBlank
      1  1066		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  1068		       85 8b		      sta	aiState
    144  106a		       60	   .idleErase rts
    145  106b
    146  106b
    147  106b							;---------------------------------------------------------------------------------------------------
    148  106b
      0  106b					      DEF	EnPassantFixupDraw
      1  106b				   SLOT_EnPassantFixupDraw SET	_BANK_SLOT
      2  106b				   BANK_EnPassantFixupDraw SET	SLOT_EnPassantFixupDraw + _CURRENT_BANK
      3  106b				   EnPassantFixupDraw
      4  106b				   TEMPORARY_VAR SET	Overlay
      5  106b				   TEMPORARY_OFFSET SET	0
      6  106b				   VAR_BOUNDARY_EnPassantFixupDraw SET	TEMPORARY_OFFSET
      7  106b				   FUNCTION_NAME SET	EnPassantFixupDraw
    150  106b					      SUBROUTINE
    151  106b
    152  106b							; {
    153  106b							; With en-passant flag, it is essentially dual-use.
    154  106b							; First, it marks if the move is *involved* somehow in an en-passant
    155  106b							; if the piece has MOVED already, then it's an en-passant capture
    156  106b							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    157  106b
    158  106b		       a2 00		      ldx	#0	; (probably) NO en-passant this time
    159  106d		       a5 96		      lda	fromPiece
    160  106f		       a8		      tay
    161  1070
    162  1070		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    163  1072		       c9 20		      cmp	#FLAG_ENPASSANT
    164  1074		       d0 13		      bne	.noep	; HAS moved, or not en-passant
    165  1076
    166  1076		       45 96		      eor	fromPiece	; clear FLAG_ENPASSANT
    167  1078		       85 96		      sta	fromPiece
    168  107a
    169  107a		       a6 86		      ldx	toX12	; this IS an en-passantable opening, so record the square
    170  107c		       86 93		      stx	enPassantPawn	; capturable square for en-passant move (or none)
    171  107e
    172  107e							; set the secondary piece movement info - this allows move/unmakemove to work for enpassant
    173  107e
    174  107e		       a9 00		      lda	#0
      0  1080					      sta@PLY	secondaryBlank
      1  1080		       8d ce fb 	      sta	[RAM]+secondaryBlank
      0  1083					      stx@PLY	secondarySquare
      1  1083		       8e cd fb 	      stx	[RAM]+secondarySquare
      0  1086					      sty@PLY	secondaryPiece
      1  1086		       8c cc fb 	      sty	[RAM]+secondaryPiece
    178  1089
    179  1089				   .noep
    180  1089							; }
    181  1089
    182  1089		       60		      rts
    183  108a
    184  108a							;---------------------------------------------------------------------------------------------------
    185  108a
      0  108a					      DEF	CopySetup
      1  108a				   SLOT_CopySetup SET	_BANK_SLOT
      2  108a				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  108a				   CopySetup
      4  108a				   TEMPORARY_VAR SET	Overlay
      5  108a				   TEMPORARY_OFFSET SET	0
      6  108a				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  108a				   FUNCTION_NAME SET	CopySetup
    187  108a					      SUBROUTINE
    188  108a
      0  108a					      REFER	CopySinglePiece	;✅
      1  108a					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  108a				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  108a					      ENDIF
    190  108a
      0  108a					      VAR	__tmp, 1
      1  108a		       00 ac	   __tmp      =	TEMPORARY_VAR
      2  108a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  108a
      4  108a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  108a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  108a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  108a					      ENDIF
      8  108a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  108a				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  108a				  -	      ERR
     11  108a					      ENDIF
     12  108a					      LIST	ON
      0  108a					      VAR	__shiftx, 1
      1  108a		       00 ad	   __shiftx   =	TEMPORARY_VAR
      2  108a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  108a
      4  108a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  108a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  108a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  108a					      ENDIF
      8  108a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  108a				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  108a				  -	      ERR
     11  108a					      ENDIF
     12  108a					      LIST	ON
      0  108a					      VAR	__pieceColour2, 1
      1  108a		       00 ae	   __pieceColour2 =	TEMPORARY_VAR
      2  108a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  108a
      4  108a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  108a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  108a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  108a					      ENDIF
      8  108a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  108a				  -	      ECHO	"Temporary Variable", __pieceColour2, "overflow!"
     10  108a				  -	      ERR
     11  108a					      ENDIF
     12  108a					      LIST	ON
    194  108a
      0  108a					      VEND	CopySetup
      1  108a				  -	      IFNCONST	CopySetup
      2  108a				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  108a				  -	      ERR
      4  108a					      ENDIF
      5  108a		       00 af	   VAREND_CopySetup =	TEMPORARY_VAR
    196  108a
    197  108a							; figure colouration of square
    198  108a
    199  108a		       a5 80		      lda	squareToDraw
    200  108c
    201  108c					      IF	DIAGNOSTICS
    202  108c							; Catch out-of-range piece square
    203  108c							; will not catch off left/right edge
    204  108c
    205  108c		       c9 64	   .fail      cmp	#100
    206  108e		       b0 fc		      bcs	.fail
    207  1090		       c9 16		      cmp	#22
    208  1092		       90 f8		      bcc	.fail
    209  1094					      ENDIF
    210  1094
    211  1094
    212  1094		       a2 0a		      ldx	#10
    213  1096		       38		      sec
    214  1097		       e9 0a	   .sub10     sbc	#10
    215  1099		       ca		      dex
    216  109a		       b0 fb		      bcs	.sub10
    217  109c		       69 08		      adc	#8
    218  109e		       85 ad		      sta	__shiftx
    219  10a0					      IF	DIAGNOSTICS
    220  10a0		       c9 08	   .fail2     cmp	#8
    221  10a2		       b0 fc		      bcs	.fail2
    222  10a4		       e0 08		      cpx	#8
    223  10a6		       b0 f8		      bcs	.fail2
    224  10a8					      ENDIF
    225  10a8		       86 ac		      stx	__tmp
    226  10aa		       65 ac		      adc	__tmp
    227  10ac
    228  10ac
    229  10ac		       29 01		      and	#1
    230  10ae							;eor #1
    231  10ae		       f0 02		      beq	.white
    232  10b0		       a9 24		      lda	#36
    233  10b2				   .white
    234  10b2		       85 ae		      sta	__pieceColour2	; actually SQUARE black/white
    235  10b4
    236  10b4							; PieceColour = 0 for white square, 36 for black square
    237  10b4
    238  10b4		       a9 d2		      lda	#RAMBANK_BOARD
    239  10b6		       85 3e		      sta	SET_BANK_RAM	;@3
    240  10b8
    241  10b8		       a4 80		      ldy	squareToDraw
    242  10ba		       b9 79 fc 	      lda	Board,y
    243  10bd							;and #$87
    244  10bd		       0a		      asl
    245  10be		       90 02		      bcc	.blackAdjust
    246  10c0		       09 10		      ora	#16	; switch white pieces
    247  10c2		       4a	   .blackAdjust lsr
    248  10c3		       29 0f		      and	#%1111
    249  10c5		       aa		      tax
    250  10c6
    251  10c6		       a5 ad		      lda	__shiftx
    252  10c8		       29 03		      and	#3	; shift position in P
    253  10ca
    254  10ca		       18		      clc
    255  10cb		       7d d3 f8 	      adc	PieceToShape,x
    256  10ce		       18		      clc
    257  10cf		       65 ae		      adc	__pieceColour2
    258  10d1		       a8		      tay
    259  10d2		       60		      rts
    260  10d3
    261  10d3				   PieceToShape
    262  10d3
    263  10d3		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    264  10d4		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    265  10d5		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    266  10d6		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    267  10d7		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    268  10d8		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    269  10d9		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    270  10da		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    271  10db
    272  10db		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    273  10dc		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    274  10dd		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    275  10de		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    276  10df		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    277  10e0		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    278  10e1		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    279  10e2		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    280  10e3
    281  10e3
    282  10e3							;---------------------------------------------------------------------------------------------------
    283  10e3
      0  10e3					      DEF	AdjustMaterialPositionalValue
      1  10e3				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  10e3				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  10e3				   AdjustMaterialPositionalValue
      4  10e3				   TEMPORARY_VAR SET	Overlay
      5  10e3				   TEMPORARY_OFFSET SET	0
      6  10e3				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  10e3				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    285  10e3					      SUBROUTINE
    286  10e3
    287  10e3							; A move is about to be made, so  adjust material and positional values based on from/to and
    288  10e3							; capture.
    289  10e3
    290  10e3							; First, nominate referencing subroutines so that local variables can be adjusted properly
    291  10e3
      0  10e3					      COMMON_VARS
      1  10e3
      0  10e3					      VAR	__thinkbar, 1
      1  10e3		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
      0  10e3					      VAR	__toggle, 1
      1  10e3		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
      4  10e3
      0  10e3					      VAR	__bestMove, 1
      1  10e3		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
      0  10e3					      VAR	__alpha, 2
      1  10e3		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
      0  10e3					      VAR	__beta, 2
      1  10e3		       00 ac	   __beta     =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
      0  10e3					      VAR	__negaMax, 2
      1  10e3		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
      0  10e3					      VAR	__value, 2
      1  10e3		       00 b0	   __value    =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
     10  10e3
      0  10e3					      VAR	__quiesceCapOnly, 1
      1  10e3		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
     12  10e3
      0  10e3					      VAR	__originalPiece, 1
      1  10e3		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
      0  10e3					      VAR	__capturedPiece, 1
      1  10e3		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  10e3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  10e3
      4  10e3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  10e3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  10e3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  10e3					      ENDIF
      8  10e3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  10e3				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  10e3				  -	      ERR
     11  10e3					      ENDIF
     12  10e3					      LIST	ON
     15  10e3
      0  10e3					      REFER	MakeMove	;✅
      1  10e3				  -	      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  10e3				  -TEMPORARY_VAR SET	VAREND_MakeMove
      3  10e3					      ENDIF
      0  10e3					      REFER	aiMoveIsSelected	;✅
      1  10e3				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  10e3				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  10e3					      ENDIF
      0  10e3					      VEND	AdjustMaterialPositionalValue
      1  10e3				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  10e3				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  10e3				  -	      ERR
      4  10e3					      ENDIF
      5  10e3		       00 b5	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    296  10e3
    297  10e3							; fromPiece	 piece doing the move (promoted type)
    298  10e3							; fromX12	 current square
    299  10e3							; originX12	 starting square
    300  10e3							; toX12	 ending square
    301  10e3
    302  10e3
    303  10e3							; {
    304  10e3							;   adjust the positional value  (originX12 --> fromX12)
    305  10e3
    306  10e3		       a4 86		      ldy	toX12	; already loaded
    307  10e5		       a5 96		      lda	fromPiece
    308  10e7		       20 52 f9 	      jsr	AddPiecePositionValue	; add pos value for new position
    309  10ea
    310  10ea
    311  10ea		       a5 b3		      lda	__originalPiece
    312  10ec		       45 96		      eor	fromPiece	; the new piece
    313  10ee		       29 0f		      and	#PIECE_MASK
    314  10f0		       f0 05		      beq	.same1	; unchanged, so skip
    315  10f2
    316  10f2		       a5 96		      lda	fromPiece	; new piece
    317  10f4		       20 2f f9 	      jsr	AddPieceMaterialValue
    318  10f7
    319  10f7				   .same1
    320  10f7
    321  10f7							; and now the 'subtracts'
    322  10f7
      0  10f7					      NEGEVAL
      1  10f7
      2  10f7		       38		      sec
      3  10f8		       a9 00		      lda	#0
      4  10fa		       e5 8f		      sbc	Evaluation
      5  10fc		       85 8f		      sta	Evaluation
      6  10fe		       a9 00		      lda	#0
      7  1100		       e5 90		      sbc	Evaluation+1
      8  1102		       85 90		      sta	Evaluation+1
    324  1104
    325  1104		       a4 87		      ldy	originX12
    326  1106		       a5 b3		      lda	__originalPiece
    327  1108		       20 52 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    328  110b
    329  110b
    330  110b		       a5 b3		      lda	__originalPiece
    331  110d		       45 96		      eor	fromPiece	; the new piece
    332  110f		       29 0f		      and	#PIECE_MASK
    333  1111		       f0 05		      beq	.same2	; unchanged, so skip
    334  1113
    335  1113		       a5 b3		      lda	__originalPiece
    336  1115		       20 2f f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    337  1118				   .same2
    338  1118
      0  1118					      NEGEVAL
      1  1118
      2  1118		       38		      sec
      3  1119		       a9 00		      lda	#0
      4  111b		       e5 8f		      sbc	Evaluation
      5  111d		       85 8f		      sta	Evaluation
      6  111f		       a9 00		      lda	#0
      7  1121		       e5 90		      sbc	Evaluation+1
      8  1123		       85 90		      sta	Evaluation+1
    340  1125
    341  1125							; If there's a capture, we adjust the material value
    342  1125
    343  1125							;		      lda __capturedPiece
    344  1125							;		      eor __originalPiece
    345  1125							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    346  1125
    347  1125
    348  1125		       a5 b4		      lda	__capturedPiece
    349  1127		       29 0f		      and	#PIECE_MASK
    350  1129		       f0 03		      beq	.noCapture
    351  112b		       20 2f f9 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    352  112e				   .noCapture
    353  112e
    354  112e							; }
    355  112e		       60		      rts
    356  112f
    357  112f
    358  112f							;---------------------------------------------------------------------------------------------------
    359  112f
      0  112f					      DEF	AddPieceMaterialValue
      1  112f				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  112f				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  112f				   AddPieceMaterialValue
      4  112f				   TEMPORARY_VAR SET	Overlay
      5  112f				   TEMPORARY_OFFSET SET	0
      6  112f				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  112f				   FUNCTION_NAME SET	AddPieceMaterialValue
    361  112f					      SUBROUTINE
    362  112f
      0  112f					      COMMON_VARS
      1  112f
      0  112f					      VAR	__thinkbar, 1
      1  112f		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
      0  112f					      VAR	__toggle, 1
      1  112f		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
      4  112f
      0  112f					      VAR	__bestMove, 1
      1  112f		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
      0  112f					      VAR	__alpha, 2
      1  112f		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
      0  112f					      VAR	__beta, 2
      1  112f		       00 ac	   __beta     =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
      0  112f					      VAR	__negaMax, 2
      1  112f		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
      0  112f					      VAR	__value, 2
      1  112f		       00 b0	   __value    =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
     10  112f
      0  112f					      VAR	__quiesceCapOnly, 1
      1  112f		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
     12  112f
      0  112f					      VAR	__originalPiece, 1
      1  112f		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
      0  112f					      VAR	__capturedPiece, 1
      1  112f		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  112f
      4  112f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  112f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  112f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  112f					      ENDIF
      8  112f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  112f				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  112f				  -	      ERR
     11  112f					      ENDIF
     12  112f					      LIST	ON
     15  112f
      0  112f					      REFER	InitialisePieceSquares	;✅
      1  112f					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  112f				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  112f					      ENDIF
      0  112f					      REFER	AdjustMaterialPositionalValue	;✅
      1  112f				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  112f				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  112f					      ENDIF
    366  112f							;REFER EnPassantRemovePiece ;✅
      0  112f					      VEND	AddPieceMaterialValue
      1  112f				  -	      IFNCONST	AddPieceMaterialValue
      2  112f				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  112f				  -	      ERR
      4  112f					      ENDIF
      5  112f		       00 b9	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
    368  112f
    369  112f							; Adjust the material score based on the piece
    370  112f							; a = piece type + flags
    371  112f
    372  112f		       29 0f		      and	#PIECE_MASK
    373  1131		       a8		      tay
    374  1132
    375  1132		       18		      clc
    376  1133		       b9 42 f9 	      lda	PieceValueLO,y
    377  1136		       65 8f		      adc	Evaluation
    378  1138		       85 8f		      sta	Evaluation
    379  113a		       b9 4a f9 	      lda	PieceValueHI,y
    380  113d		       65 90		      adc	Evaluation+1
    381  113f		       85 90		      sta	Evaluation+1
    382  1141		       60		      rts
    383  1142
    384  1142
    385  1142					      MAC	valuetable
    386  1142					      .byte	{1}0	; blank
    387  1142					      .byte	{1}100	; white P
    388  1142					      .byte	{1}100	; black P
    389  1142					      .byte	{1}320	; N
    390  1142					      .byte	{1}375	; B
    391  1142					      .byte	{1}575	; R
    392  1142					      .byte	{1}900	; Q
    393  1142					      .byte	{1}10000	; K
    394  1142					      ENDM
    395  1142
    396  1142				   PieceValueLO
      0  1142					      VALUETABLE	<
      1  1142		       00		      .byte.b	<0
      2  1143		       64		      .byte.b	<100
      3  1144		       64		      .byte.b	<100
      4  1145		       40		      .byte.b	<320
      5  1146		       77		      .byte.b	<375
      6  1147		       3f		      .byte.b	<575
      7  1148		       84		      .byte.b	<900
      8  1149		       10		      .byte.b	<10000
    398  114a
    399  114a				   PieceValueHI
      0  114a					      VALUETABLE	>
      1  114a		       00		      .byte.b	>0
      2  114b		       00		      .byte.b	>100
      3  114c		       00		      .byte.b	>100
      4  114d		       01		      .byte.b	>320
      5  114e		       01		      .byte.b	>375
      6  114f		       02		      .byte.b	>575
      7  1150		       03		      .byte.b	>900
      8  1151		       27		      .byte.b	>10000
    401  1152
    402  1152
    403  1152							;---------------------------------------------------------------------------------------------------
    404  1152
      0  1152					      DEF	AddPiecePositionValue
      1  1152				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  1152				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  1152				   AddPiecePositionValue
      4  1152				   TEMPORARY_VAR SET	Overlay
      5  1152				   TEMPORARY_OFFSET SET	0
      6  1152				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  1152				   FUNCTION_NAME SET	AddPiecePositionValue
    406  1152					      SUBROUTINE
    407  1152
      0  1152					      REFER	InitialisePieceSquares	;✅
      1  1152					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  1152				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  1152					      ENDIF
      0  1152					      REFER	AdjustMaterialPositionalValue	;✅
      1  1152				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  1152				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  1152					      ENDIF
    410  1152							;REFER EnPassantRemovePiece ;✅
      0  1152					      VAR	__valPtr, 2
      1  1152		       00 b9	   __valPtr   =	TEMPORARY_VAR
      2  1152				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  1152
      4  1152				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1152					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1152				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1152					      ENDIF
      8  1152				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  1152				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  1152				  -	      ERR
     11  1152					      ENDIF
     12  1152					      LIST	ON
      0  1152					      VEND	AddPiecePositionValue
      1  1152				  -	      IFNCONST	AddPiecePositionValue
      2  1152				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  1152				  -	      ERR
      4  1152					      ENDIF
      5  1152		       00 bb	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    413  1152
    414  1152
    415  1152							; adds value of square piece is on to the evaluation
    416  1152							; note to do the subtraction as -( -x + val) == x - val
    417  1152
    418  1152							; y = square
    419  1152							; a = piece type (+flags)
    420  1152
    421  1152
    422  1152
    423  1152		       c9 80		      cmp	#128	; black = CS
    424  1154		       29 0f		      and	#PIECE_MASK
    425  1156		       aa		      tax
    426  1157
    427  1157		       a9 cb		      lda	#EVAL
    428  1159		       85 3f		      sta	SET_BANK	;@3
    429  115b
    430  115b							; black pieces flip rows so we can use the same eval tables
    431  115b
    432  115b		       98		      tya
    433  115c		       90 03		      bcc	.white
    434  115e		       b9 7f f9 	      lda	FlipSquareIndex,y
    435  1161							;clc
    436  1161				   .white
    437  1161		       7d 00 fc 	      adc	PosValVecLO,x
    438  1164		       85 b9		      sta	__valPtr
    439  1166		       bd 08 fc 	      lda	PosValVecHI,x
    440  1169		       69 00		      adc	#0
    441  116b		       85 ba		      sta	__valPtr+1
    442  116d
    443  116d		       a0 00		      ldy	#0
    444  116f		       b1 b9		      lda	(__valPtr),y
    445  1171		       10 01		      bpl	.sum
    446  1173		       88		      dey
    447  1174
    448  1174		       18	   .sum       clc
    449  1175		       65 8f		      adc	Evaluation
    450  1177		       85 8f		      sta	Evaluation
    451  1179		       98		      tya
    452  117a		       65 90		      adc	Evaluation+1
    453  117c		       85 90		      sta	Evaluation+1
    454  117e		       60		      rts
    455  117f
    456  117f
    457  117f				   FlipSquareIndex
    458  117f
    459  117f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    460  1189		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    461  1193
    462  1193				   .SQBASE    SET	90-1
    463  1193					      REPEAT	8
    464  1193		       00 00		      .byte.b	0,0
    465  1193				   .SQX       SET	2
    466  1195					      REPEAT	8
    467  1195		       5b		      .byte.b	(.SQBASE+.SQX)
    468  1195				   .SQX       SET	.SQX + 1
    466  1195					      REPEND
    467  1196		       5c		      .byte.b	(.SQBASE+.SQX)
    468  1196				   .SQX       SET	.SQX + 1
    466  1196					      REPEND
    467  1197		       5d		      .byte.b	(.SQBASE+.SQX)
    468  1197				   .SQX       SET	.SQX + 1
    466  1197					      REPEND
    467  1198		       5e		      .byte.b	(.SQBASE+.SQX)
    468  1198				   .SQX       SET	.SQX + 1
    466  1198					      REPEND
    467  1199		       5f		      .byte.b	(.SQBASE+.SQX)
    468  1199				   .SQX       SET	.SQX + 1
    466  1199					      REPEND
    467  119a		       60		      .byte.b	(.SQBASE+.SQX)
    468  119a				   .SQX       SET	.SQX + 1
    466  119a					      REPEND
    467  119b		       61		      .byte.b	(.SQBASE+.SQX)
    468  119b				   .SQX       SET	.SQX + 1
    466  119b					      REPEND
    467  119c		       62		      .byte.b	(.SQBASE+.SQX)
    468  119c				   .SQX       SET	.SQX + 1
    469  119d					      REPEND
    470  119d				   .SQBASE    SET	.SQBASE - 10
    463  119d					      REPEND
    464  119d		       00 00		      .byte.b	0,0
    465  119d				   .SQX       SET	2
    466  119f					      REPEAT	8
    467  119f		       51		      .byte.b	(.SQBASE+.SQX)
    468  119f				   .SQX       SET	.SQX + 1
    466  119f					      REPEND
    467  11a0		       52		      .byte.b	(.SQBASE+.SQX)
    468  11a0				   .SQX       SET	.SQX + 1
    466  11a0					      REPEND
    467  11a1		       53		      .byte.b	(.SQBASE+.SQX)
    468  11a1				   .SQX       SET	.SQX + 1
    466  11a1					      REPEND
    467  11a2		       54		      .byte.b	(.SQBASE+.SQX)
    468  11a2				   .SQX       SET	.SQX + 1
    466  11a2					      REPEND
    467  11a3		       55		      .byte.b	(.SQBASE+.SQX)
    468  11a3				   .SQX       SET	.SQX + 1
    466  11a3					      REPEND
    467  11a4		       56		      .byte.b	(.SQBASE+.SQX)
    468  11a4				   .SQX       SET	.SQX + 1
    466  11a4					      REPEND
    467  11a5		       57		      .byte.b	(.SQBASE+.SQX)
    468  11a5				   .SQX       SET	.SQX + 1
    466  11a5					      REPEND
    467  11a6		       58		      .byte.b	(.SQBASE+.SQX)
    468  11a6				   .SQX       SET	.SQX + 1
    469  11a7					      REPEND
    470  11a7				   .SQBASE    SET	.SQBASE - 10
    463  11a7					      REPEND
    464  11a7		       00 00		      .byte.b	0,0
    465  11a7				   .SQX       SET	2
    466  11a9					      REPEAT	8
    467  11a9		       47		      .byte.b	(.SQBASE+.SQX)
    468  11a9				   .SQX       SET	.SQX + 1
    466  11a9					      REPEND
    467  11aa		       48		      .byte.b	(.SQBASE+.SQX)
    468  11aa				   .SQX       SET	.SQX + 1
    466  11aa					      REPEND
    467  11ab		       49		      .byte.b	(.SQBASE+.SQX)
    468  11ab				   .SQX       SET	.SQX + 1
    466  11ab					      REPEND
    467  11ac		       4a		      .byte.b	(.SQBASE+.SQX)
    468  11ac				   .SQX       SET	.SQX + 1
    466  11ac					      REPEND
    467  11ad		       4b		      .byte.b	(.SQBASE+.SQX)
    468  11ad				   .SQX       SET	.SQX + 1
    466  11ad					      REPEND
    467  11ae		       4c		      .byte.b	(.SQBASE+.SQX)
    468  11ae				   .SQX       SET	.SQX + 1
    466  11ae					      REPEND
    467  11af		       4d		      .byte.b	(.SQBASE+.SQX)
    468  11af				   .SQX       SET	.SQX + 1
    466  11af					      REPEND
    467  11b0		       4e		      .byte.b	(.SQBASE+.SQX)
    468  11b0				   .SQX       SET	.SQX + 1
    469  11b1					      REPEND
    470  11b1				   .SQBASE    SET	.SQBASE - 10
    463  11b1					      REPEND
    464  11b1		       00 00		      .byte.b	0,0
    465  11b1				   .SQX       SET	2
    466  11b3					      REPEAT	8
    467  11b3		       3d		      .byte.b	(.SQBASE+.SQX)
    468  11b3				   .SQX       SET	.SQX + 1
    466  11b3					      REPEND
    467  11b4		       3e		      .byte.b	(.SQBASE+.SQX)
    468  11b4				   .SQX       SET	.SQX + 1
    466  11b4					      REPEND
    467  11b5		       3f		      .byte.b	(.SQBASE+.SQX)
    468  11b5				   .SQX       SET	.SQX + 1
    466  11b5					      REPEND
    467  11b6		       40		      .byte.b	(.SQBASE+.SQX)
    468  11b6				   .SQX       SET	.SQX + 1
    466  11b6					      REPEND
    467  11b7		       41		      .byte.b	(.SQBASE+.SQX)
    468  11b7				   .SQX       SET	.SQX + 1
    466  11b7					      REPEND
    467  11b8		       42		      .byte.b	(.SQBASE+.SQX)
    468  11b8				   .SQX       SET	.SQX + 1
    466  11b8					      REPEND
    467  11b9		       43		      .byte.b	(.SQBASE+.SQX)
    468  11b9				   .SQX       SET	.SQX + 1
    466  11b9					      REPEND
    467  11ba		       44		      .byte.b	(.SQBASE+.SQX)
    468  11ba				   .SQX       SET	.SQX + 1
    469  11bb					      REPEND
    470  11bb				   .SQBASE    SET	.SQBASE - 10
    463  11bb					      REPEND
    464  11bb		       00 00		      .byte.b	0,0
    465  11bb				   .SQX       SET	2
    466  11bd					      REPEAT	8
    467  11bd		       33		      .byte.b	(.SQBASE+.SQX)
    468  11bd				   .SQX       SET	.SQX + 1
    466  11bd					      REPEND
    467  11be		       34		      .byte.b	(.SQBASE+.SQX)
    468  11be				   .SQX       SET	.SQX + 1
    466  11be					      REPEND
    467  11bf		       35		      .byte.b	(.SQBASE+.SQX)
    468  11bf				   .SQX       SET	.SQX + 1
    466  11bf					      REPEND
    467  11c0		       36		      .byte.b	(.SQBASE+.SQX)
    468  11c0				   .SQX       SET	.SQX + 1
    466  11c0					      REPEND
    467  11c1		       37		      .byte.b	(.SQBASE+.SQX)
    468  11c1				   .SQX       SET	.SQX + 1
    466  11c1					      REPEND
    467  11c2		       38		      .byte.b	(.SQBASE+.SQX)
    468  11c2				   .SQX       SET	.SQX + 1
    466  11c2					      REPEND
    467  11c3		       39		      .byte.b	(.SQBASE+.SQX)
    468  11c3				   .SQX       SET	.SQX + 1
    466  11c3					      REPEND
    467  11c4		       3a		      .byte.b	(.SQBASE+.SQX)
    468  11c4				   .SQX       SET	.SQX + 1
    469  11c5					      REPEND
    470  11c5				   .SQBASE    SET	.SQBASE - 10
    463  11c5					      REPEND
    464  11c5		       00 00		      .byte.b	0,0
    465  11c5				   .SQX       SET	2
    466  11c7					      REPEAT	8
    467  11c7		       29		      .byte.b	(.SQBASE+.SQX)
    468  11c7				   .SQX       SET	.SQX + 1
    466  11c7					      REPEND
    467  11c8		       2a		      .byte.b	(.SQBASE+.SQX)
    468  11c8				   .SQX       SET	.SQX + 1
    466  11c8					      REPEND
    467  11c9		       2b		      .byte.b	(.SQBASE+.SQX)
    468  11c9				   .SQX       SET	.SQX + 1
    466  11c9					      REPEND
    467  11ca		       2c		      .byte.b	(.SQBASE+.SQX)
    468  11ca				   .SQX       SET	.SQX + 1
    466  11ca					      REPEND
    467  11cb		       2d		      .byte.b	(.SQBASE+.SQX)
    468  11cb				   .SQX       SET	.SQX + 1
    466  11cb					      REPEND
    467  11cc		       2e		      .byte.b	(.SQBASE+.SQX)
    468  11cc				   .SQX       SET	.SQX + 1
    466  11cc					      REPEND
    467  11cd		       2f		      .byte.b	(.SQBASE+.SQX)
    468  11cd				   .SQX       SET	.SQX + 1
    466  11cd					      REPEND
    467  11ce		       30		      .byte.b	(.SQBASE+.SQX)
    468  11ce				   .SQX       SET	.SQX + 1
    469  11cf					      REPEND
    470  11cf				   .SQBASE    SET	.SQBASE - 10
    463  11cf					      REPEND
    464  11cf		       00 00		      .byte.b	0,0
    465  11cf				   .SQX       SET	2
    466  11d1					      REPEAT	8
    467  11d1		       1f		      .byte.b	(.SQBASE+.SQX)
    468  11d1				   .SQX       SET	.SQX + 1
    466  11d1					      REPEND
    467  11d2		       20		      .byte.b	(.SQBASE+.SQX)
    468  11d2				   .SQX       SET	.SQX + 1
    466  11d2					      REPEND
    467  11d3		       21		      .byte.b	(.SQBASE+.SQX)
    468  11d3				   .SQX       SET	.SQX + 1
    466  11d3					      REPEND
    467  11d4		       22		      .byte.b	(.SQBASE+.SQX)
    468  11d4				   .SQX       SET	.SQX + 1
    466  11d4					      REPEND
    467  11d5		       23		      .byte.b	(.SQBASE+.SQX)
    468  11d5				   .SQX       SET	.SQX + 1
    466  11d5					      REPEND
    467  11d6		       24		      .byte.b	(.SQBASE+.SQX)
    468  11d6				   .SQX       SET	.SQX + 1
    466  11d6					      REPEND
    467  11d7		       25		      .byte.b	(.SQBASE+.SQX)
    468  11d7				   .SQX       SET	.SQX + 1
    466  11d7					      REPEND
    467  11d8		       26		      .byte.b	(.SQBASE+.SQX)
    468  11d8				   .SQX       SET	.SQX + 1
    469  11d9					      REPEND
    470  11d9				   .SQBASE    SET	.SQBASE - 10
    463  11d9					      REPEND
    464  11d9		       00 00		      .byte.b	0,0
    465  11d9				   .SQX       SET	2
    466  11db					      REPEAT	8
    467  11db		       15		      .byte.b	(.SQBASE+.SQX)
    468  11db				   .SQX       SET	.SQX + 1
    466  11db					      REPEND
    467  11dc		       16		      .byte.b	(.SQBASE+.SQX)
    468  11dc				   .SQX       SET	.SQX + 1
    466  11dc					      REPEND
    467  11dd		       17		      .byte.b	(.SQBASE+.SQX)
    468  11dd				   .SQX       SET	.SQX + 1
    466  11dd					      REPEND
    467  11de		       18		      .byte.b	(.SQBASE+.SQX)
    468  11de				   .SQX       SET	.SQX + 1
    466  11de					      REPEND
    467  11df		       19		      .byte.b	(.SQBASE+.SQX)
    468  11df				   .SQX       SET	.SQX + 1
    466  11df					      REPEND
    467  11e0		       1a		      .byte.b	(.SQBASE+.SQX)
    468  11e0				   .SQX       SET	.SQX + 1
    466  11e0					      REPEND
    467  11e1		       1b		      .byte.b	(.SQBASE+.SQX)
    468  11e1				   .SQX       SET	.SQX + 1
    466  11e1					      REPEND
    467  11e2		       1c		      .byte.b	(.SQBASE+.SQX)
    468  11e2				   .SQX       SET	.SQX + 1
    469  11e3					      REPEND
    470  11e3				   .SQBASE    SET	.SQBASE - 10
    471  11e3					      REPEND
    472  11e3
    473  11e3
    474  11e3							;---------------------------------------------------------------------------------------------------
    475  11e3
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  11e3					      include	"piece_vectors.asm"
      1  11e3							; Created by ConvertChessPieces.py
      0  11e3					      DEF	PIECE_VECTOR_LO
      1  11e3				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  11e3				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  11e3				   PIECE_VECTOR_LO
      4  11e3				   TEMPORARY_VAR SET	Overlay
      5  11e3				   TEMPORARY_OFFSET SET	0
      6  11e3				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  11e3				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  11e3		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  11e4		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  11e5		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  11e6		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  11e7		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  11e8		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  11e9		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  11ea		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  11eb		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  11ec		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  11ed		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  11ee		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  11ef		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  11f0		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  11f1		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  11f2		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  11f3		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  11f4		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  11f5		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  11f6		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  11f7		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  11f8		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  11f9		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  11fa		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  11fb		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  11fc		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  11fd		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  11fe		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  11ff		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  1200		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  1201		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  1202		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  1203		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  1204		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  1205		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  1206		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  1207		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  1208		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  1209		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  120a		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  120b		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  120c		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  120d		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  120e		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  120f		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  1210		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  1211		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  1212		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  1213		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  1214		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  1215		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  1216		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  1217		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  1218		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  1219		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  121a		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  121b		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  121c		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  121d		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  121e		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  121f		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  1220		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  1221		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  1222		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  1223		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  1224		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  1225		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  1226		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  1227		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  1228		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  1229		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  122a		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  122b		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  122c		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  122d		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  122e		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  122f		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  1230		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  1231		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  1232		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  1233		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  1234		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  1235		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  1236		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  1237		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  1238		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  1239		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  123a		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  123b		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  123c		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  123d		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  123e		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  123f		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  1240		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  1241		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  1242		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  1243		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  1244		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  1245		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  1246		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  1247		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  1248		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  1249		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  124a		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  124b		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  124c		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  124d		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  124e		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  124f		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  1250		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  1251		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  1252		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  1253		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  1254		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  1255		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  1256		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  1257		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  1258		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  1259		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  125a		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  125b		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  125c		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  125d		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  125e		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  125f		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  1260		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  1261		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  1262		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  1263		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  1264		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  1265		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  1266		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  1267		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  1268		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  1269		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  126a		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  126b		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  126c		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  126d		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  126e		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  126f		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  1270		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  1271		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  1272		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  1273					      DEF	PIECE_VECTOR_HI
      1  1273				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  1273				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  1273				   PIECE_VECTOR_HI
      4  1273				   TEMPORARY_VAR SET	Overlay
      5  1273				   TEMPORARY_OFFSET SET	0
      6  1273				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  1273				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  1273		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  1274		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  1275		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  1276		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  1277		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  1278		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  1279		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  127a		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  127b		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  127c		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  127d		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  127e		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  127f		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  1280		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  1281		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  1282		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  1283		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  1284		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  1285		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  1286		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  1287		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  1288		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  1289		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  128a		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  128b		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  128c		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  128d		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  128e		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  128f		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  1290		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  1291		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  1292		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  1293		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  1294		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  1295		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  1296		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  1297		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  1298		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  1299		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  129a		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  129b		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  129c		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  129d		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  129e		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  129f		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  12a0		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  12a1		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  12a2		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  12a3		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  12a4		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  12a5		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  12a6		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  12a7		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  12a8		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  12a9		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  12aa		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  12ab		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  12ac		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  12ad		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  12ae		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  12af		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  12b0		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  12b1		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  12b2		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  12b3		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  12b4		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  12b5		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  12b6		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  12b7		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  12b8		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  12b9		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  12ba		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  12bb		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  12bc		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  12bd		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  12be		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  12bf		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  12c0		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  12c1		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  12c2		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  12c3		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  12c4		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  12c5		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  12c6		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  12c7		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  12c8		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  12c9		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  12ca		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  12cb		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  12cc		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  12cd		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  12ce		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  12cf		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  12d0		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  12d1		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  12d2		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  12d3		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  12d4		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  12d5		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  12d6		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  12d7		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  12d8		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  12d9		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  12da		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  12db		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  12dc		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  12dd		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  12de		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  12df		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  12e0		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  12e1		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  12e2		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  12e3		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  12e4		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  12e5		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  12e6		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  12e7		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  12e8		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  12e9		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  12ea		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  12eb		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  12ec		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  12ed		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  12ee		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  12ef		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  12f0		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  12f1		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  12f2		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  12f3		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  12f4		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  12f5		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  12f6		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  12f7		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  12f8		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  12f9		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  12fa		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  12fb		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  12fc		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  12fd		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  12fe		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  12ff		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  1300		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  1301		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  1302		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  1303					      DEF	PIECE_VECTOR_BANK
      1  1303				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  1303				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  1303				   PIECE_VECTOR_BANK
      4  1303				   TEMPORARY_VAR SET	Overlay
      5  1303				   TEMPORARY_OFFSET SET	0
      6  1303				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  1303				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  1303		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  1304		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  1305		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  1306		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  1307		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  1308		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  1309		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  130a		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  130b		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  130c		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  130d		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  130e		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  130f		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  1310		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  1311		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  1312		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  1313		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  1314		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  1315		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  1316		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  1317		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  1318		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  1319		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  131a		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  131b		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  131c		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  131d		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  131e		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  131f		       86		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  1320		       86		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  1321		       86		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  1322		       87		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  1323		       88		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  1324		       88		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  1325		       88		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  1326		       88		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  1327		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  1328		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  1329		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  132a		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  132b		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  132c		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  132d		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  132e		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  132f		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  1330		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  1331		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  1332		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  1333		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  1334		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  1335		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  1336		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  1337		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  1338		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  1339		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  133a		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  133b		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  133c		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  133d		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  133e		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  133f		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  1340		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  1341		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  1342		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  1343		       85		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  1344		       85		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  1345		       85		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  1346		       85		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  1347		       88		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  1348		       88		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  1349		       88		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  134a		       88		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  134b		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  134c		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  134d		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  134e		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  134f		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  1350		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  1351		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  1352		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  1353		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  1354		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  1355		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  1356		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  1357		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  1358		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  1359		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  135a		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  135b		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  135c		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  135d		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  135e		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  135f		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  1360		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  1361		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  1362		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  1363		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  1364		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  1365		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  1366		       96		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  1367		       88		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  1368		       88		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  1369		       88		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  136a		       88		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  136b		       85		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  136c		       85		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  136d		       85		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  136e		       85		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  136f		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  1370		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  1371		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  1372		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  1373		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  1374		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  1375		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  1376		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  1377		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  1378		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  1379		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  137a		       97		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  137b		       86		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  137c		       86		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  137d		       86		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  137e		       86		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  137f		       86		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  1380		       86		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  1381		       86		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  1382		       86		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  1383		       86		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  1384		       87		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  1385		       87		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  1386		       87		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  1387		       87		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  1388		       87		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  1389		       87		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  138a		       87		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  138b		       87		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  138c		       87		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  138d		       87		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  138e		       87		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  138f		       85		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  1390		       85		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  1391		       85		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  1392		       85		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  1393
    438  1393							; piece index equates...
    439  1393		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  1393		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  1393		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  1393		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  1393		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  1393		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  1393		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  1393		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  1393		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  1393		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  1393		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  1393		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  1393		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  1393		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  1393		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  1393		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  1393		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  1393		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  1393		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  1393		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  1393		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  1393		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  1393		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  1393		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  1393		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  1393		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  1393		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  1393		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  1393		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  1393		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  1393		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  1393		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  1393		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  1393		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  1393		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  1393		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  1393		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  1393		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  1393		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  1393		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  1393		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  1393		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  1393		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  1393		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  1393		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  1393		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  1393		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  1393		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  1393		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  1393		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  1393		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  1393		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  1393		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  1393		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  1393		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  1393		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  1393		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  1393		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  1393		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  1393		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  1393		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  1393		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  1393		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  1393		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  1393		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  1393		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  1393		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  1393		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  1393		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  1393		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  1393		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  1393		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  1393		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  1393		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  1393		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  1393		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  1393		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  1393		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  1393		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  1393		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  1393		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  1393		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  1393		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  1393		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  1393		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  1393		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  1393		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  1393		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  1393		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  1393		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  1393		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  1393		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  1393		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  1393		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  1393		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  1393		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  1393		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  1393		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  1393		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  1393		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  1393		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  1393		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  1393		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  1393		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  1393		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  1393		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  1393		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  1393		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  1393		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  1393		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  1393		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  1393		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  1393		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  1393		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  1393		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  1393		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  1393		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  1393		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  1393		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  1393		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  1393		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  1393		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  1393		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  1393		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  1393		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  1393		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  1393		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  1393		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  1393		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  1393		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  1393		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  1393		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  1393		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  1393		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  1393		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  1393		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  1393		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  1393		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  1393		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  1393		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  1393		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  1393		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  1393		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  1393		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE @2 GENERIC #3.asm
    477  1393
    478  1393
    479  1393							;---------------------------------------------------------------------------------------------------
    480  1393
      0  1393					      CHECK_BANK_SIZE	"BANK_GENERIC@2#1"
      1  1393		       03 93	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2#1 (1K) SIZE =  $393 , FREE= $6d
      2  1393					      ECHO	"BANK_GENERIC@2#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1393				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1393				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2#1", " size=", * - ORIGIN
      5  1393				  -	      ERR
      6  1393					      ENDIF
    482  1393
    483  1393							;---------------------------------------------------------------------------------------------------
    484  1393							;EOF
------- FILE ./chess.asm
------- FILE @2 GFX1.asm LEVEL 2 PASS 4
      0  1393					      include	"@2 GFX1.asm"
      0  1393					      SLOT	2
      1  1393				  -	      IF	(2 < 0) || (2 > 3)
      2  1393				  -	      ECHO	"Illegal bank address/segment location", 2
      3  1393				  -	      ERR
      4  1393					      ENDIF
      5  1393				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  1393				   _BANK_SLOT SET	2 * 64
      0  1393					      ROMBANK	GFX1
      1  17d8 ????				      SEG	GFX1
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   GFX1_START SET	*
      6  1400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1400				   GFX1       SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + 1024
      3  1400
      4  1400
      5  1400							;---------------------------------------------------------------------------------------------------
      6  1400
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  1400					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  1400					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  1400					      LIST	ON
      0  1400					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  1400				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  1400				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  1400				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  1400		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  1448					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  1448					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  1448					      LIST	ON
      0  1448					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  1448				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  1448				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  1448				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  1448				   TEMPORARY_VAR SET	Overlay
      5  1448				   TEMPORARY_OFFSET SET	0
      6  1448				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  1448				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  1448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1460		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  1490					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  1490					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  1490					      LIST	ON
      0  1490					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  1490				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  1490				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  1490				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  1490				   TEMPORARY_VAR SET	Overlay
      5  1490				   TEMPORARY_OFFSET SET	0
      6  1490				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  1490				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  1490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  14a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  14c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  14d8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  14d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  1500					      LIST	ON
      0  1500					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  1500				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  1500				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  1500				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  1500				   TEMPORARY_VAR SET	Overlay
      5  1500				   TEMPORARY_OFFSET SET	0
      6  1500				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  1500				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  1500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1530		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  1548					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  1548					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  1548					      LIST	ON
      0  1548					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  1548				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  1548				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  1548				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  1548				   TEMPORARY_VAR SET	Overlay
      5  1548				   TEMPORARY_OFFSET SET	0
      6  1548				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  1548				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  1548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  1560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  1590					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  1590					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  1590					      LIST	ON
      0  1590					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  1590				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  1590				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  1590				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  1590				   TEMPORARY_VAR SET	Overlay
      5  1590				   TEMPORARY_OFFSET SET	0
      6  1590				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  1590				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  1590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  15a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  15c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  15d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  15d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  1600					      LIST	ON
      0  1600					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  1600				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  1600				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  1600				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  1600				   TEMPORARY_VAR SET	Overlay
      5  1600				   TEMPORARY_OFFSET SET	0
      6  1600				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  1600				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  1600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  1630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  1648					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  1648					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  1648					      LIST	ON
      0  1648					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  1648				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  1648				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  1648				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  1648				   TEMPORARY_VAR SET	Overlay
      5  1648				   TEMPORARY_OFFSET SET	0
      6  1648				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  1648				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  1648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE @2 GFX1.asm
     15  1690
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  1690					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  1690					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  1690					      LIST	ON
      0  1690					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  1690				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  1690				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  1690				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  1690				   TEMPORARY_VAR SET	Overlay
      5  1690				   TEMPORARY_OFFSET SET	0
      6  1690				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  1690				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  1690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  16a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  16c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  16d8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  16d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  1700					      LIST	ON
      0  1700					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  1700				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  1700				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  1700				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  1700				   TEMPORARY_VAR SET	Overlay
      5  1700				   TEMPORARY_OFFSET SET	0
      6  1700				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  1700				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  1700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1718		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  1748					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  1748					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  1748					      LIST	ON
      0  1748					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  1748				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  1748				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  1748				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  1748				   TEMPORARY_VAR SET	Overlay
      5  1748				   TEMPORARY_OFFSET SET	0
      6  1748				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  1748				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  1748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1778		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  1790					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  1790					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  1790					      LIST	ON
      0  1790					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  1790				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  1790				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  1790				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  1790				   TEMPORARY_VAR SET	Overlay
      5  1790				   TEMPORARY_OFFSET SET	0
      6  1790				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  1790				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  1790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  17a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  17c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX1.asm
     20  17d8
     21  17d8
     22  17d8							;---------------------------------------------------------------------------------------------------
     23  17d8
      0  17d8					      CHECK_BANK_SIZE	"BANK_GFX1"
      1  17d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX1 (1K) SIZE =  $3d8 , FREE= $28
      2  17d8					      ECHO	"BANK_GFX1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  17d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  17d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX1", " size=", * - ORIGIN
      5  17d8				  -	      ERR
      6  17d8					      ENDIF
     25  17d8
     26  17d8							;---------------------------------------------------------------------------------------------------
     27  17d8							;EOF
------- FILE ./chess.asm
------- FILE @2 GFX2.asm LEVEL 2 PASS 4
      0  17d8					      include	"@2 GFX2.asm"
      0  17d8					      SLOT	2
      1  17d8				  -	      IF	(2 < 0) || (2 > 3)
      2  17d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  17d8				  -	      ERR
      4  17d8					      ENDIF
      5  17d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  17d8				   _BANK_SLOT SET	2 * 64
      0  17d8					      ROMBANK	GFX2
      1  1bd8 ????				      SEG	GFX2
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   GFX2_START SET	*
      6  1800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1800				   GFX2       SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + 1024
      3  1800
      4  1800							;---------------------------------------------------------------------------------------------------
      5  1800
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  1800					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  1800					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  1800					      LIST	ON
      0  1800					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  1800				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  1800				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  1800				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  1800		       00 40 e0 e0*	      .byte.b	$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  1818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  1848					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  1848					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  1848					      LIST	ON
      0  1848					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  1848				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  1848				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  1848				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  1848				   TEMPORARY_VAR SET	Overlay
      5  1848				   TEMPORARY_OFFSET SET	0
      6  1848				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  1848				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  1848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1860		       00 10 38 38*	      .byte.b	$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  1878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX2.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  1890					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  1890					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  1890					      LIST	ON
      0  1890					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  1890				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  1890				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  1890				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  1890				   TEMPORARY_VAR SET	Overlay
      5  1890				   TEMPORARY_OFFSET SET	0
      6  1890				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  1890				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  1890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  18a8		       00 00 01 01*	      .byte.b	$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  18c0		       00 01 03 03*	      .byte.b	$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE @2 GFX2.asm
      9  18d8
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  18d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  18d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  1900					      LIST	ON
      0  1900					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  1900				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  1900				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  1900				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  1900				   TEMPORARY_VAR SET	Overlay
      5  1900				   TEMPORARY_OFFSET SET	0
      6  1900				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  1900				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  1900		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  1918		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  1948					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  1948					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  1948					      LIST	ON
      0  1948					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  1948				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  1948				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  1948				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  1948				   TEMPORARY_VAR SET	Overlay
      5  1948				   TEMPORARY_OFFSET SET	0
      6  1948				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  1948				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  1948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1960		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  1978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  1990					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  1990					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  1990					      LIST	ON
      0  1990					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  1990				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  1990				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  1990				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  1990				   TEMPORARY_VAR SET	Overlay
      5  1990				   TEMPORARY_OFFSET SET	0
      6  1990				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  1990				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  1990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  19a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  19c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE @2 GFX2.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  19d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  19d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  1a00					      LIST	ON
      0  1a00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  1a00				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  1a00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  1a00				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  1a00				   TEMPORARY_VAR SET	Overlay
      5  1a00				   TEMPORARY_OFFSET SET	0
      6  1a00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  1a00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  1a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE @2 GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  1a48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  1a48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  1a48					      LIST	ON
      0  1a48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  1a48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  1a48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  1a48				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  1a48				   TEMPORARY_VAR SET	Overlay
      5  1a48				   TEMPORARY_OFFSET SET	0
      6  1a48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  1a48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  1a48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  1a60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  1a90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  1a90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  1a90					      LIST	ON
      0  1a90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  1a90				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  1a90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  1a90				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  1a90				   TEMPORARY_VAR SET	Overlay
      5  1a90				   TEMPORARY_OFFSET SET	0
      6  1a90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  1a90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  1a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1aa8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  1ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  1ad8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  1ad8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  1b00					      LIST	ON
      0  1b00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  1b00				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  1b00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  1b00				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  1b00				   TEMPORARY_VAR SET	Overlay
      5  1b00				   TEMPORARY_OFFSET SET	0
      6  1b00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  1b00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  1b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  1b30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE @2 GFX2.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  1b48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  1b48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  1b48					      LIST	ON
      0  1b48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  1b48				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  1b48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  1b48				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  1b48				   TEMPORARY_VAR SET	Overlay
      5  1b48				   TEMPORARY_OFFSET SET	0
      6  1b48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  1b48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  1b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1b78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE @2 GFX2.asm
     18  1b90
     19  1b90
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  1b90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  1b90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  1b90					      LIST	ON
      0  1b90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  1b90				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  1b90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  1b90				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  1b90				   TEMPORARY_VAR SET	Overlay
      5  1b90				   TEMPORARY_OFFSET SET	0
      6  1b90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  1b90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  1b90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ba8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX2.asm
     21  1bd8
     22  1bd8
     23  1bd8							;---------------------------------------------------------------------------------------------------
     24  1bd8
      0  1bd8					      CHECK_BANK_SIZE	"BANK_GFX2"
      1  1bd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX2 (1K) SIZE =  $3d8 , FREE= $28
      2  1bd8					      ECHO	"BANK_GFX2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1bd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX2", " size=", * - ORIGIN
      5  1bd8				  -	      ERR
      6  1bd8					      ENDIF
     26  1bd8
     27  1bd8							;---------------------------------------------------------------------------------------------------
     28  1bd8							;EOF
------- FILE ./chess.asm
------- FILE @2 GFX3.asm LEVEL 2 PASS 4
      0  1bd8					      include	"@2 GFX3.asm"
      0  1bd8					      SLOT	2
      1  1bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  1bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  1bd8				  -	      ERR
      4  1bd8					      ENDIF
      5  1bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  1bd8				   _BANK_SLOT SET	2 * 64
      0  1bd8					      ROMBANK	GFX3
      1  1fd8 ????				      SEG	GFX3
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   GFX3_START SET	*
      6  1c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  1c00				   GFX3       SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  1c00
      4  1c00							;---------------------------------------------------------------------------------------------------
      5  1c00
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  1c00					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  1c00					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  1c00					      LIST	ON
      0  1c00					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  1c00				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  1c00				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  1c00				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  1c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1c18		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
      7  1c48
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  1c48					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  1c48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  1c48					      LIST	ON
      0  1c48					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  1c48				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  1c48				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  1c48				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  1c48				   TEMPORARY_VAR SET	Overlay
      5  1c48				   TEMPORARY_OFFSET SET	0
      6  1c48				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  1c48				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  1c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1c60		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1c78		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  1c90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  1c90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  1c90					      LIST	ON
      0  1c90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  1c90				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  1c90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  1c90				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  1c90				   TEMPORARY_VAR SET	Overlay
      5  1c90				   TEMPORARY_OFFSET SET	0
      6  1c90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  1c90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  1c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1cc0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
     10  1cd8
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  1cd8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  1cd8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  1d00					      LIST	ON
      0  1d00					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  1d00				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  1d00				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  1d00				   BLACK_KING_on_BLACK_SQUARE_0
      4  1d00				   TEMPORARY_VAR SET	Overlay
      5  1d00				   TEMPORARY_OFFSET SET	0
      6  1d00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  1d00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  1d00		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1d18		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  1d48					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  1d48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  1d48					      LIST	ON
      0  1d48					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  1d48				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  1d48				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  1d48				   BLACK_KING_on_BLACK_SQUARE_1
      4  1d48				   TEMPORARY_VAR SET	Overlay
      5  1d48				   TEMPORARY_OFFSET SET	0
      6  1d48				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  1d48				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  1d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1d60		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  1d90					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  1d90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  1d90					      LIST	ON
      0  1d90					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  1d90				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  1d90				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  1d90				   BLACK_KING_on_BLACK_SQUARE_2
      4  1d90				   TEMPORARY_VAR SET	Overlay
      5  1d90				   TEMPORARY_OFFSET SET	0
      6  1d90				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  1d90				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  1d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1da8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1dc0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  1dd8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  1dd8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  1e00					      LIST	ON
      0  1e00					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  1e00				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  1e00				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  1e00				   BLACK_KING_on_BLACK_SQUARE_3
      4  1e00				   TEMPORARY_VAR SET	Overlay
      5  1e00				   TEMPORARY_OFFSET SET	0
      6  1e00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  1e00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  1e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1e30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
     15  1e48
     16  1e48
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  1e48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  1e48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  1e48					      LIST	ON
      0  1e48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  1e48				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  1e48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  1e48				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  1e48				   TEMPORARY_VAR SET	Overlay
      5  1e48				   TEMPORARY_OFFSET SET	0
      6  1e48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  1e48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  1e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1e78		       00 20 70 70*	      .byte.b	$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE @2 GFX3.asm
     18  1e90
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  1e90					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  1e90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  1e90					      LIST	ON
      0  1e90					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  1e90				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  1e90				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  1e90				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  1e90				   TEMPORARY_VAR SET	Overlay
      5  1e90				   TEMPORARY_OFFSET SET	0
      6  1e90				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  1e90				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  1e90		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  1ed8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  1ed8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  1f00					      LIST	ON
      0  1f00					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  1f00				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  1f00				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  1f00				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  1f00				   TEMPORARY_VAR SET	Overlay
      5  1f00				   TEMPORARY_OFFSET SET	0
      6  1f00				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  1f00				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  1f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f18		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  1f48					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  1f48					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  1f48					      LIST	ON
      0  1f48					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  1f48				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  1f48				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  1f48				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  1f48				   TEMPORARY_VAR SET	Overlay
      5  1f48				   TEMPORARY_OFFSET SET	0
      6  1f48				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  1f48				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  1f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1f78		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  1f90					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  1f90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  1f90					      LIST	ON
      0  1f90					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  1f90				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  1f90				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  1f90				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  1f90				   TEMPORARY_VAR SET	Overlay
      5  1f90				   TEMPORARY_OFFSET SET	0
      6  1f90				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  1f90				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  1f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1fc0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX3.asm
     23  1fd8
     24  1fd8							;---------------------------------------------------------------------------------------------------
     25  1fd8
      0  1fd8					      CHECK_BANK_SIZE	"BANK_GFX3"
      1  1fd8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX3 (1K) SIZE =  $3d8 , FREE= $28
      2  1fd8					      ECHO	"BANK_GFX3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  1fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1fd8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX3", " size=", * - ORIGIN
      5  1fd8				  -	      ERR
      6  1fd8					      ENDIF
     27  1fd8
     28  1fd8							;---------------------------------------------------------------------------------------------------
     29  1fd8							;EOF
------- FILE ./chess.asm
------- FILE @2 GFX4.asm LEVEL 2 PASS 4
      0  1fd8					      include	"@2 GFX4.asm"
      0  1fd8					      SLOT	2
      1  1fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  1fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  1fd8				  -	      ERR
      4  1fd8					      ENDIF
      5  1fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  1fd8				   _BANK_SLOT SET	2 * 64
      0  1fd8					      ROMBANK	GFX4
      1  23d8 ????				      SEG	GFX4
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   GFX4_START SET	*
      6  2000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2000				   GFX4       SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + 1024
      3  2000
      4  2000							;---------------------------------------------------------------------------------------------------
      5  2000
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2000					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  2000					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  2000					      LIST	ON
      0  2000					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  2000				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2000				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2000				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  2000		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  2018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2048					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  2048					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  2048					      LIST	ON
      0  2048					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  2048				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2048				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2048				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  2048				   TEMPORARY_VAR SET	Overlay
      5  2048				   TEMPORARY_OFFSET SET	0
      6  2048				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2048				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  2048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2060		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  2078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2090					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  2090					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  2090					      LIST	ON
      0  2090					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  2090				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2090				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2090				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  2090				   TEMPORARY_VAR SET	Overlay
      5  2090				   TEMPORARY_OFFSET SET	0
      6  2090				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2090				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  2090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  20a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  20c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  20d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  20d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  2100					      LIST	ON
      0  2100					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  2100				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2100				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2100				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  2100				   TEMPORARY_VAR SET	Overlay
      5  2100				   TEMPORARY_OFFSET SET	0
      6  2100				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2100				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  2100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2130		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
     10  2148
     11  2148
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2148					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  2148					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  2148					      LIST	ON
      0  2148					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  2148				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2148				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2148				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  2148				   TEMPORARY_VAR SET	Overlay
      5  2148				   TEMPORARY_OFFSET SET	0
      6  2148				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2148				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  2148		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  2160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2190					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  2190					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  2190					      LIST	ON
      0  2190					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  2190				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2190				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2190				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  2190				   TEMPORARY_VAR SET	Overlay
      5  2190				   TEMPORARY_OFFSET SET	0
      6  2190				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2190				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  2190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  21a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  21c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  21d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  21d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  2200					      LIST	ON
      0  2200					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  2200				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2200				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2200				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  2200				   TEMPORARY_VAR SET	Overlay
      5  2200				   TEMPORARY_OFFSET SET	0
      6  2200				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2200				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  2200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  2230		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2248					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  2248					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  2248					      LIST	ON
      0  2248					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  2248				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2248				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2248				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  2248				   TEMPORARY_VAR SET	Overlay
      5  2248				   TEMPORARY_OFFSET SET	0
      6  2248				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2248				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  2248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2278		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2290					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  2290					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  2290					      LIST	ON
      0  2290					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  2290				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2290				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2290				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  2290				   TEMPORARY_VAR SET	Overlay
      5  2290				   TEMPORARY_OFFSET SET	0
      6  2290				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2290				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  2290		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  22a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  22c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  22d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  22d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  2300					      LIST	ON
      0  2300					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  2300				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2300				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2300				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  2300				   TEMPORARY_VAR SET	Overlay
      5  2300				   TEMPORARY_OFFSET SET	0
      6  2300				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2300				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  2300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2318		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2348					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  2348					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  2348					      LIST	ON
      0  2348					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  2348				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2348				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2348				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  2348				   TEMPORARY_VAR SET	Overlay
      5  2348				   TEMPORARY_OFFSET SET	0
      6  2348				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2348				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  2348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2378		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2390					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  2390					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  2390					      LIST	ON
      0  2390					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  2390				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2390				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2390				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  2390				   TEMPORARY_VAR SET	Overlay
      5  2390				   TEMPORARY_OFFSET SET	0
      6  2390				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2390				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  2390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  23a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  23c0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GFX4.asm
     20  23d8
     21  23d8
     22  23d8							;---------------------------------------------------------------------------------------------------
     23  23d8
      0  23d8					      CHECK_BANK_SIZE	"BANK_GFX4"
      1  23d8		       03 d8	   .TEMP      =	* - _BANK_START
 BANK_GFX4 (1K) SIZE =  $3d8 , FREE= $28
      2  23d8					      ECHO	"BANK_GFX4", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  23d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  23d8				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GFX4", " size=", * - ORIGIN
      5  23d8				  -	      ERR
      6  23d8					      ENDIF
     25  23d8
     26  23d8							;---------------------------------------------------------------------------------------------------
     27  23d8							;EOF
------- FILE ./chess.asm
    557  23d8
------- FILE @3 GENERIC #2.asm LEVEL 2 PASS 4
      0  23d8					      include	"@3 GENERIC #2.asm"
      1  23d8							; Chess
      2  23d8							; Copyright (c) 2019-2020 Andrew Davie
      3  23d8							; andrew@taswegian.com
      4  23d8
      0  23d8					      SLOT	3	; this code assembles for bank #1
      1  23d8				  -	      IF	(3 < 0) || (3 > 3)
      2  23d8				  -	      ECHO	"Illegal bank address/segment location", 3
      3  23d8				  -	      ERR
      4  23d8					      ENDIF
      5  23d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  23d8				   _BANK_SLOT SET	3 * 64
      0  23d8					      ROMBANK	THREE
      1  2467 ????				      SEG	THREE
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   THREE_START SET	*
      6  2400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2400				   THREE      SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + 1024
      7  2400
      8  2400							;---------------------------------------------------------------------------------------------------
      9  2400
      0  2400					      DEF	GetPiece
      1  2400				   SLOT_GetPiece SET	_BANK_SLOT
      2  2400				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  2400				   GetPiece
      4  2400				   TEMPORARY_VAR SET	Overlay
      5  2400				   TEMPORARY_OFFSET SET	0
      6  2400				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  2400				   FUNCTION_NAME SET	GetPiece
     11  2400					      SUBROUTINE
     12  2400
      0  2400					      REFER	aiSelectDestinationSquare	;✅
      1  2400					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  2400				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  2400					      ENDIF
      0  2400					      REFER	aiQuiescent	;✅
      1  2400				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  2400				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  2400					      ENDIF
      0  2400					      VEND	GetPiece
      1  2400				  -	      IFNCONST	GetPiece
      2  2400				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  2400				  -	      ERR
      4  2400					      ENDIF
      5  2400		       00 a9	   VAREND_GetPiece =	TEMPORARY_VAR
     16  2400
     17  2400							; Retrieve the piece+flags from the movelist, given from/to squares
     18  2400							; Required as moves have different flags but same origin squares (e.g., castling)
     19  2400
     20  2400		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
     21  2402							;lda currentPly
     22  2402		       85 3e		      sta	SET_BANK_RAM	;@2
     23  2404
     24  2404							; returns piece in A+fromPiece
     25  2404							; or Y=-1 if not found
     26  2404
     27  2404							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     28  2404							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     29  2404							; This fixes the move with/without castle flag
     30  2404
     31  2404
      0  2404					      ldy@PLY	moveIndex
      1  2404		       ac cf f9 	      ldy	moveIndex
     33  2407		       30 11		      bmi	.fail	; shouldn't happen
     34  2409
     35  2409		       a5 85	   .scan      lda	fromX12
      0  240b					      cmp@PLY	MoveFrom,y
      1  240b		       d9 00 f8 	      cmp	MoveFrom,y
     37  240e		       d0 07		      bne	.next
     38  2410		       a5 86		      lda	toX12
      0  2412					      cmp@PLY	MoveTo,y
      1  2412		       d9 64 f8 	      cmp	MoveTo,y
     40  2415		       f0 04		      beq	.found
     41  2417		       88	   .next      dey
     42  2418		       10 ef		      bpl	.scan
     43  241a		       60	   .fail      rts
     44  241b
      0  241b				   .found     lda@PLY	MovePiece,y
      1  241b		       b9 00 f9 	      lda	MovePiece,y
     46  241e		       85 96		      sta	fromPiece
     47  2420
     48  2420		       60		      rts
     49  2421
     50  2421
     51  2421							;---------------------------------------------------------------------------------------------------
     52  2421
     53  2421							;     DEF GenCastleMoveForRook_ENPASSANT
     54  2421							;     SUBROUTINE
     55  2421
     56  2421							;	   REFER MakeMove ;✅
     57  2421							;	   REFER CastleFixupDraw_ENPASSANT ;✅
     58  2421							;	   VEND GenCastleMoveForRook_ENPASSANT
     59  2421
     60  2421							;	   rts ;tmp
     61  2421							;	   jsr debug ;tmp
     62  2421
     63  2421							;     ; Like castling, this generates the acutal extra-move for the en-passant
     64  2421
     65  2421
     66  2421							;     ; Check to see if we are doing an actual en-passant capture...
     67  2421
     68  2421							;     ; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
     69  2421							;     ;  as the en-passant will fail if the taking piece does not have this flag set correctly
     70  2421
     71  2421
     72  2421
     73  2421							;     ; {
     74  2421							;     ; With en-passant flag, it is essentially dual-use.
     75  2421							;     ; First, it marks if the move is *involved* somehow in an en-passant
     76  2421							;     ; if the piece has MOVED already, then it's an en-passant capture
     77  2421							;     ; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
     78  2421
     79  2421							;		       ldy enPassantPawn	       ; save from previous side move
     80  2421
     81  2421							;		       ldx #0			       ; (probably) NO en-passant this time
     82  2421							;		       lda fromPiece
     83  2421							;		       and #FLAG_ENPASSANT|FLAG_MOVED
     84  2421							;		       cmp #FLAG_ENPASSANT
     85  2421							;		       bne .noep		       ; HAS moved, or not en-passant
     86  2421
     87  2421							;		       eor fromPiece		       ; clear FLAG_ENPASSANT
     88  2421							;		       sta fromPiece
     89  2421
     90  2421							;		       ldx toX12		       ; this IS an en-passantable opening, so record the square
     91  2421							; .noep	       stx enPassantPawn	       ; capturable square for en-passant move (or none)
     92  2421
     93  2421							;     ; }
     94  2421
     95  2421							;		       clc
     96  2421
     97  2421							;		       lda fromPiece
     98  2421							;		       and #FLAG_ENPASSANT
     99  2421							;		       beq .notEnPassant	       ; not an en-passant, or it's enpassant by a MOVED piece
    100  2421
    101  2421
    102  2421							;     ; at this point the attacking pawn has finished moving to the "take" square
    103  2421							;     ; the loser-pawn is marked with enPassantPawn
    104  2421							;     ; we want to generate a 'blank' move to take the pawn
    105  2421
    106  2421							;		       lda originX12		       ; we need a blank square to move FROM
    107  2421							;		       sta fromX12		       ; use the square the attacker pawn just left
    108  2421
    109  2421							;     ; calculate the captured pawn's square based on move colour
    110  2421
    111  2421							;		       lda #-10
    112  2421							;		       ldx fromPiece
    113  2421							;		       bpl .white
    114  2421							;		       lda #10
    115  2421							; .white
    116  2421							;		       clc
    117  2421							;		       adc fromX12		       ; attacker destination square
    118  2421							;		       sta toX12		       ; now we have the captured pawn square!
    119  2421							;		       sta@PLY secondarySquare	       ; square to which we RESTORE the captured pawn on unmakemove
    120  2421
    121  2421							;		       sta@PLY secondaryBlank
    122  2421							;		       lda fromPiece
    123  2421							;		       eor #$80 		       ; opponent pawn
    124  2421							;		       sta@PLY secondaryPiece	       ; a capture!
    125  2421
    126  2421
    127  2421							;		       sec			       ; double-move, so don't change sides
    128  2421							; .notEnPassant       rts
    129  2421
    130  2421
    131  2421							;---------------------------------------------------------------------------------------------------
    132  2421
      0  2421					      DEF	GenCastleMoveForRook
      1  2421				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  2421				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  2421				   GenCastleMoveForRook
      4  2421				   TEMPORARY_VAR SET	Overlay
      5  2421				   TEMPORARY_OFFSET SET	0
      6  2421				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  2421				   FUNCTION_NAME SET	GenCastleMoveForRook
    134  2421					      SUBROUTINE
    135  2421
      0  2421					      REFER	MakeMove	;✅
      1  2421					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  2421				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  2421					      ENDIF
      0  2421					      REFER	CastleFixupDraw	;✅
      1  2421				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  2421				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  2421					      ENDIF
      0  2421					      VEND	GenCastleMoveForRook
      1  2421				  -	      IFNCONST	GenCastleMoveForRook
      2  2421				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  2421				  -	      ERR
      4  2421					      ENDIF
      5  2421		       00 b5	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    139  2421
    140  2421							; Generate secondary move for the rook, involved in a castling move
    141  2421							; Returns:
    142  2421							;   CC --> not a castle/secondary
    143  2421							;   CS --> secondary move valid
    144  2421
    145  2421
    146  2421		       18		      clc
    147  2422
    148  2422		       a5 96		      lda	fromPiece
    149  2424		       29 10		      and	#FLAG_CASTLE
    150  2426		       f0 2e		      beq	.exit	; NOT involved in castle!
    151  2428
    152  2428		       20 9a f2 	      jsr	debug	;tmp
    153  242b		       a2 04		      ldx	#4
    154  242d		       a5 86		      lda	toX12	; *destination*
    155  242f		       18	   .findCast  clc
    156  2430		       ca		      dex
    157  2431		       30 23		      bmi	.exit
    158  2433		       dd 57 fc 	      cmp	KSquare,x
    159  2436		       d0 f7		      bne	.findCast
    160  2438
    161  2438		       bd 5f fc 	      lda	RSquareEnd,x
    162  243b		       85 86		      sta	toX12
      0  243d					      sta@PLY	secondaryBlank
      1  243d		       8d ce fb 	      sta	[RAM]+secondaryBlank
    164  2440		       bc 5b fc 	      ldy	RSquareStart,x
    165  2443		       84 85		      sty	fromX12
    166  2445		       84 87		      sty	originX12
      0  2447					      sty@PLY	secondarySquare
      1  2447		       8c cd fb 	      sty	[RAM]+secondarySquare
    168  244a
    169  244a		       a5 96		      lda	fromPiece
    170  244c		       29 80		      and	#128	; colour bit
    171  244e		       09 05		      ora	#ROOK	; preserve colour
    172  2450		       85 96		      sta	fromPiece
      0  2452					      sta@PLY	secondaryPiece
      1  2452		       8d cc fb 	      sta	[RAM]+secondaryPiece
    174  2455
    175  2455		       38		      sec
    176  2456		       60	   .exit      rts
    177  2457
    178  2457
    179  2457		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    180  245b		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    181  245f		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    182  2463		       19 1b 5f 61 virtualSquare1 .byte.b	25,27,95,97
    183  2467							;virtualSquare2      .byte 26,26,96,96
    184  2467
    185  2467							;---------------------------------------------------------------------------------------------------
    186  2467
    187  2467							; DEF GenEnPassantMove
    188  2467							; SUBROUTINE
    189  2467
    190  2467							;     REFER EnPassantCheck
    191  2467							;     REFER MakeMove
    192  2467							;     VEND GenEnPassantMove
    193  2467
    194  2467
    195  2467							;		   rts
    196  2467
    197  2467
    198  2467
    199  2467							;---------------------------------------------------------------------------------------------------
    200  2467
      0  2467					      CHECK_BANK_SIZE	"BANK_3"
      1  2467		       00 67	   .TEMP      =	* - _BANK_START
 BANK_3 (1K) SIZE =  $67 , FREE= $399
      2  2467					      ECHO	"BANK_3", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2467				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2467				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_3", " size=", * - ORIGIN
      5  2467				  -	      ERR
      6  2467					      ENDIF
    202  2467
    203  2467							;---------------------------------------------------------------------------------------------------
    204  2467							; EOF
------- FILE ./chess.asm
------- FILE @3 SCREEN ROM.asm LEVEL 2 PASS 4
      0  2467					      include	"@3 SCREEN ROM.asm"
      1  2467
      0  2467					      SLOT	3
      1  2467				  -	      IF	(3 < 0) || (3 > 3)
      2  2467				  -	      ECHO	"Illegal bank address/segment location", 3
      3  2467				  -	      ERR
      4  2467					      ENDIF
      5  2467				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  2467				   _BANK_SLOT SET	3 * 64
      0  2467					      ROMBANK	ROM_SCREEN
      1  285c ????				      SEG	ROM_SCREEN
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   ROM_SCREEN_START SET	*
      6  2800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2800				   ROM_SCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + 1024
      4  2800
      5  2800							;---------------------------------------------------------------------------------------------------
      6  2800
      0  2800					      DEF	ClearRowBitmap
      1  2800				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  2800				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  2800				   ClearRowBitmap
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	ClearRowBitmap
      8  2800					      SUBROUTINE
      9  2800
      0  2800					      REFER	CallClear	;✅
      1  2800				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  2800				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  2800					      ENDIF
      0  2800					      VEND	ClearRowBitmap
      1  2800				  -	      IFNCONST	ClearRowBitmap
      2  2800				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  2800				  -	      ERR
      4  2800					      ENDIF
      5  2800		       00 a7	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     12  2800
     13  2800							; No transient variable dependencies/calls
     14  2800
     15  2800		       a9 00		      lda	#0
     16  2802		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  2804				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  2804		       99 ff f9 	      sta	[RAM]+ChessBitmap-1,y
     18  2807		       88		      dey
     19  2808		       d0 fa		      bne	.clearRow
     20  280a		       60		      rts
     21  280b
     22  280b
     23  280b							;---------------------------------------------------------------------------------------------------
     24  280b
     25  280b					      IF	1
      0  280b					      DEF	WriteBlank
      1  280b				   SLOT_WriteBlank SET	_BANK_SLOT
      2  280b				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  280b				   WriteBlank
      4  280b				   TEMPORARY_VAR SET	Overlay
      5  280b				   TEMPORARY_OFFSET SET	0
      6  280b				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  280b				   FUNCTION_NAME SET	WriteBlank
     27  280b					      SUBROUTINE
     28  280b
      0  280b					      REFER	StartupBankReset	;✅
      1  280b				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  280b				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  280b					      ENDIF
      0  280b					      VEND	WriteBlank
      1  280b				  -	      IFNCONST	WriteBlank
      2  280b				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  280b				  -	      ERR
      4  280b					      ENDIF
      5  280b		       00 a7	   VAREND_WriteBlank =	TEMPORARY_VAR
     31  280b
     32  280b		       a9 90		      lda	#<BlankSprite
      0  280d					      sta@RAM	SMSPRITE0_0+1
      1  280d		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  2810					      sta@RAM	SMSPRITE8_0+1
      1  2810		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  2813					      sta@RAM	SMSPRITE16_0+1
      1  2813		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
      0  2816					      sta@RAM	SMSPRITE0_1+1
      1  2816		       8d 48 fb 	      sta	[RAM]+SMSPRITE0_1+1
      0  2819					      sta@RAM	SMSPRITE8_1+1
      1  2819		       8d 79 fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  281c					      sta@RAM	SMSPRITE16_1+1
      1  281c		       8d 0d fb 	      sta	[RAM]+SMSPRITE16_1+1
     39  281f
     40  281f		       a9 f8		      lda	#>BlankSprite
      0  2821					      sta@RAM	SMSPRITE0_0+2
      1  2821		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  2824					      sta@RAM	SMSPRITE8_0+2
      1  2824		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  2827					      sta@RAM	SMSPRITE16_0+2
      1  2827		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
      0  282a					      sta@RAM	SMSPRITE0_1+2
      1  282a		       8d 49 fb 	      sta	[RAM]+SMSPRITE0_1+2
      0  282d					      sta@RAM	SMSPRITE8_1+2
      1  282d		       8d 7a fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  2830					      sta@RAM	SMSPRITE16_1+2
      1  2830		       8d 0e fb 	      sta	[RAM]+SMSPRITE16_1+2
     47  2833
     48  2833		       60		      rts
     49  2834					      ENDIF
     50  2834
     51  2834							;---------------------------------------------------------------------------------------------------
     52  2834
     53  2834					      IF	1
      0  2834					      DEF	WriteCursor
      1  2834				   SLOT_WriteCursor SET	_BANK_SLOT
      2  2834				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  2834				   WriteCursor
      4  2834				   TEMPORARY_VAR SET	Overlay
      5  2834				   TEMPORARY_OFFSET SET	0
      6  2834				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  2834				   FUNCTION_NAME SET	WriteCursor
     55  2834					      SUBROUTINE
     56  2834
      0  2834					      REFER	StartupBankReset	;✅
      1  2834				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  2834				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  2834					      ENDIF
      0  2834					      VEND	WriteCursor
      1  2834				  -	      IFNCONST	WriteCursor
      2  2834				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  2834				  -	      ERR
      4  2834					      ENDIF
      5  2834		       00 a7	   VAREND_WriteCursor =	TEMPORARY_VAR
     59  2834
     60  2834		       38		      sec
     61  2835		       a5 88		      lda	cursorX12
     62  2837		       30 22		      bmi	.exit
     63  2839		       a2 0a		      ldx	#10
     64  283b		       e9 0a	   .sub10     sbc	#10
     65  283d		       ca		      dex
     66  283e		       b0 fb		      bcs	.sub10
     67  2840
     68  2840		       8a		      txa
     69  2841		       69 80		      adc	#SLOT_DrawRow	;cc implied
     70  2843		       85 3e		      sta	SET_BANK_RAM
     71  2845
     72  2845		       a9 98		      lda	#<SpriteBuffer
      0  2847					      sta@RAM	SMSPRITE0_0+1
      1  2847		       8d 43 fb 	      sta	[RAM]+SMSPRITE0_0+1
      0  284a					      sta@RAM	SMSPRITE8_0+1
      1  284a		       8d 74 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  284d					      sta@RAM	SMSPRITE16_0+1
      1  284d		       8d 08 fb 	      sta	[RAM]+SMSPRITE16_0+1
     76  2850		       a9 f8		      lda	#>SpriteBuffer
      0  2852					      sta@RAM	SMSPRITE0_0+2
      1  2852		       8d 44 fb 	      sta	[RAM]+SMSPRITE0_0+2
      0  2855					      sta@RAM	SMSPRITE8_0+2
      1  2855		       8d 75 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  2858					      sta@RAM	SMSPRITE16_0+2
      1  2858		       8d 09 fb 	      sta	[RAM]+SMSPRITE16_0+2
     80  285b
     81  285b		       60	   .exit      rts
     82  285c					      ENDIF
     83  285c
     84  285c
     85  285c							;---------------------------------------------------------------------------------------------------
     86  285c
     87  285c				  -	      IF	0
     88  285c				  -	      DEF	SaveBitmap
     89  285c				  -	      SUBROUTINE
     90  285c				  -
     91  285c				  -	      REFER	SAFE_BackupBitmaps	;✅
     92  285c				  -	      VEND	SaveBitmap
     93  285c				  -
     94  285c				  -	      ldy	#71
     95  285c				  -.fromTo    lda	ChessBitmap,y
     96  285c				  -	      sta@RAM	BackupBitmap,y
     97  285c				  -	      lda	ChessBitmap+72,y
     98  285c				  -	      sta@RAM	BackupBitmap+72,y
     99  285c				  -	      dey
    100  285c				  -	      bpl	.fromTo
    101  285c				  -	      rts
    102  285c					      ENDIF
    103  285c
    104  285c							;---------------------------------------------------------------------------------------------------
    105  285c
    106  285c				  -	      IF	0
    107  285c				  -
    108  285c				  -	      DEF	RestoreBitmap
    109  285c				  -	      SUBROUTINE
    110  285c				  -
    111  285c				  -	      VEND	RestoreBitmap
    112  285c				  -
    113  285c				  -	      ldy	#71
    114  285c				  -.fromTo    lda	BackupBitmap,y
    115  285c				  -	      sta@RAM	ChessBitmap,y
    116  285c				  -	      lda	BackupBitmap+72,y
    117  285c				  -	      sta@RAM	ChessBitmap+72,y
    118  285c				  -	      dey
    119  285c				  -	      bpl	.fromTo
    120  285c				  -	      rts
    121  285c					      ENDIF
    122  285c
    123  285c							;---------------------------------------------------------------------------------------------------
    124  285c
    125  285c				  -	      IF	0
    126  285c				  -
    127  285c				  -	      DEF	CopyTextToRowBitmap
    128  285c				  -	      SUBROUTINE
    129  285c				  -
    130  285c				  -	      VEND	CopyTextToRowBitmap
    131  285c				  -
    132  285c				  -			; An OR-draw, used for placing matricies/text onscreen
    133  285c				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    134  285c				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    135  285c				  -			; in original state once text disappears
    136  285c				  -
    137  285c				  -	      ldy	#71
    138  285c				  -	      bcs	.rightSide
    139  285c				  -
    140  285c				  -.copy      lda	__pieceShapeBuffer,y
    141  285c				  -	      ora	ChessBitmap,y
    142  285c				  -	      sta@RAM	ChessBitmap,y
    143  285c				  -	      dey
    144  285c				  -	      bpl	.copy
    145  285c				  -
    146  285c				  -	      rts
    147  285c				  -
    148  285c				  -.rightSide
    149  285c				  -
    150  285c				  -	      SUBROUTINE
    151  285c				  -
    152  285c				  -.copy      lda	__pieceShapeBuffer,y
    153  285c				  -	      ora	ChessBitmap+72,y
    154  285c				  -	      sta@RAM	ChessBitmap+72,y
    155  285c				  -	      dey
    156  285c				  -	      bpl	.copy
    157  285c				  -
    158  285c				  -	      rts
    159  285c				  -
    160  285c					      ENDIF
    161  285c
    162  285c							;---------------------------------------------------------------------------------------------------
    163  285c
      0  285c					      CHECK_RAM_BANK_SIZE	"ROM_SCREEN@3"
      1  285c		       00 5c	   .TEMP      =	* - _BANK_START
 ROM_SCREEN@3 (512 byte) SIZE =  $5c , FREE= $1a4
      2  285c					      ECHO	"ROM_SCREEN@3", "(512 byte) SIZE = ", .TEMP, ", FREE=", _RAM_BANK_SIZE - .TEMP
      3  285c				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  285c				  -	      ECHO	"BANK OVERFLOW @ ", "ROM_SCREEN@3", " size=", * - ORIGIN
      5  285c				  -	      ERR
      6  285c					      ENDIF
    165  285c
    166  285c							;---------------------------------------------------------------------------------------------------
    167  285c							;EOF
------- FILE ./chess.asm
------- FILE @3 EVALUATE.asm LEVEL 2 PASS 4
      0  285c					      include	"@3 EVALUATE.asm"
      1  285c
      0  285c					      SLOT	3
      1  285c				  -	      IF	(3 < 0) || (3 > 3)
      2  285c				  -	      ECHO	"Illegal bank address/segment location", 3
      3  285c				  -	      ERR
      4  285c					      ENDIF
      5  285c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  285c				   _BANK_SLOT SET	3 * 64
      3  285c
      4  285c
      0  285c					      RAMBANK	BANK_EVAL
      1  285c
      2 U2200 ????				      SEG.U	RAM_BANK_EVAL
      3 U2200					      ORG	ORIGIN_RAM
      4 U2200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2200				   _BANK_START SET	*
      6 U2200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2200				   RAMBANK_BANK_EVAL SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2200				   _LAST_BANK SETSTR	BANK_EVAL
     10 U2200
      0 U2200					      ROMBANK	EVAL
      1  2e40 ????				      SEG	EVAL
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   EVAL_START SET	*
      6  2c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  2c00				   EVAL       SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + 1024
      7  2c00
      8  2c00
      9  2c00							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     10  2c00
     11  2c00
     12  2c00							;ds 22
     13  2c00
     14  2c00							;---------------------------------------------------------------------------------------------------
     15  2c00							; Vectors to the position value tables for each piece
     16  2c00
     17  2c00							;---------------------------------------------------------------------------------------------------
     18  2c00							; Vectors to the position value tables for each piece
     19  2c00
     20  2c00					      MAC	posval
     21  2c00					      .byte	0
     22  2c00					      .byte	{1}(PositionalValue_PAWN - 22)
     23  2c00					      .byte	{1}(PositionalValue_PAWN - 22)
     24  2c00					      .byte	{1}(PositionalValue_KNIGHT - 22)
     25  2c00					      .byte	{1}(PositionalValue_BISHOP - 22)
     26  2c00					      .byte	{1}(PositionalValue_ROOK - 22)
     27  2c00					      .byte	{1}(PositionalValue_QUEEN - 22)
     28  2c00					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
     29  2c00					      ENDM
     30  2c00
      0  2c00					      ALLOCATE	PosValVecLO, 8
      0  2c00					      OPTIONAL_PAGEBREAK	"Table", 8
     12  2c00					      LIST	ON
      0  2c00					      DEF	PosValVecLO
      1  2c00				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  2c00				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  2c00				   PosValVecLO
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	PosValVecLO
      0  2c00					      POSVAL	<
      1  2c00		       00		      .byte.b	0
      2  2c01		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      3  2c02		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      4  2c03		       4a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  2c04		       9a		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  2c05		       ea		      .byte.b	<(PositionalValue_ROOK - 22)
      7  2c06		       3a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  2c07		       8a		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  2c08					      ALLOCATE	PosValVecHI, 8
      0  2c08					      OPTIONAL_PAGEBREAK	"Table", 8
     12  2c08					      LIST	ON
      0  2c08					      DEF	PosValVecHI
      1  2c08				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  2c08				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  2c08				   PosValVecHI
      4  2c08				   TEMPORARY_VAR SET	Overlay
      5  2c08				   TEMPORARY_OFFSET SET	0
      6  2c08				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  2c08				   FUNCTION_NAME SET	PosValVecHI
      0  2c08					      POSVAL	>
      1  2c08		       00		      .byte.b	0
      2  2c09		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      3  2c0a		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      4  2c0b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  2c0c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  2c0d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  2c0e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  2c0f		       fd		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
     35  2c10
     36  2c10
     37  2c10					      MAC	eval8
     38  2c10					      IF	({1} > 127) || ({1} < -128)
     39  2c10					      ECHO	"Erroneous position value", {1}
     40  2c10					      ERR
     41  2c10					      ENDIF
     42  2c10					      .byte	{1}
     43  2c10					      ENDM
     44  2c10
     45  2c10
     46  2c10					      MAC	pval
     47  2c10					      EVAL8	{1}
     48  2c10					      EVAL8	{2}
     49  2c10					      EVAL8	{3}
     50  2c10					      EVAL8	{4}
     51  2c10					      EVAL8	{5}
     52  2c10					      EVAL8	{6}
     53  2c10					      EVAL8	{7}
     54  2c10					      EVAL8	{8}
     55  2c10					      EVAL8	0
     56  2c10					      EVAL8	0
     57  2c10					      ENDM		;{ 10 entries }
     58  2c10
     59  2c10
     60  2c10							;---------------------------------------------------------------------------------------------------
     61  2c10
     62  2c10				   PositionalValue_PAWN
     63  2c10
      0  2c10					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  2c10					      EVAL8	0
      1  2c10				  -	      IF	(0 > 127) || (0 < -128)
      2  2c10				  -	      ECHO	"Erroneous position value", 0
      3  2c10				  -	      ERR
      4  2c10					      ENDIF
      5  2c10		       00		      .byte.b	0
      0  2c11					      EVAL8	0
      1  2c11				  -	      IF	(0 > 127) || (0 < -128)
      2  2c11				  -	      ECHO	"Erroneous position value", 0
      3  2c11				  -	      ERR
      4  2c11					      ENDIF
      5  2c11		       00		      .byte.b	0
      0  2c12					      EVAL8	0
      1  2c12				  -	      IF	(0 > 127) || (0 < -128)
      2  2c12				  -	      ECHO	"Erroneous position value", 0
      3  2c12				  -	      ERR
      4  2c12					      ENDIF
      5  2c12		       00		      .byte.b	0
      0  2c13					      EVAL8	0
      1  2c13				  -	      IF	(0 > 127) || (0 < -128)
      2  2c13				  -	      ECHO	"Erroneous position value", 0
      3  2c13				  -	      ERR
      4  2c13					      ENDIF
      5  2c13		       00		      .byte.b	0
      0  2c14					      EVAL8	0
      1  2c14				  -	      IF	(0 > 127) || (0 < -128)
      2  2c14				  -	      ECHO	"Erroneous position value", 0
      3  2c14				  -	      ERR
      4  2c14					      ENDIF
      5  2c14		       00		      .byte.b	0
      0  2c15					      EVAL8	0
      1  2c15				  -	      IF	(0 > 127) || (0 < -128)
      2  2c15				  -	      ECHO	"Erroneous position value", 0
      3  2c15				  -	      ERR
      4  2c15					      ENDIF
      5  2c15		       00		      .byte.b	0
      0  2c16					      EVAL8	0
      1  2c16				  -	      IF	(0 > 127) || (0 < -128)
      2  2c16				  -	      ECHO	"Erroneous position value", 0
      3  2c16				  -	      ERR
      4  2c16					      ENDIF
      5  2c16		       00		      .byte.b	0
      0  2c17					      EVAL8	0
      1  2c17				  -	      IF	(0 > 127) || (0 < -128)
      2  2c17				  -	      ECHO	"Erroneous position value", 0
      3  2c17				  -	      ERR
      4  2c17					      ENDIF
      5  2c17		       00		      .byte.b	0
      0  2c18					      EVAL8	0
      1  2c18				  -	      IF	(0 > 127) || (0 < -128)
      2  2c18				  -	      ECHO	"Erroneous position value", 0
      3  2c18				  -	      ERR
      4  2c18					      ENDIF
      5  2c18		       00		      .byte.b	0
      0  2c19					      EVAL8	0
      1  2c19				  -	      IF	(0 > 127) || (0 < -128)
      2  2c19				  -	      ECHO	"Erroneous position value", 0
      3  2c19				  -	      ERR
      4  2c19					      ENDIF
      5  2c19		       00		      .byte.b	0
      0  2c1a					      PVAL	15, 20, 0, -10, -10, 0, 20, 15
      0  2c1a					      EVAL8	15
      1  2c1a				  -	      IF	(15 > 127) || (15 < -128)
      2  2c1a				  -	      ECHO	"Erroneous position value", 15
      3  2c1a				  -	      ERR
      4  2c1a					      ENDIF
      5  2c1a		       0f		      .byte.b	15
      0  2c1b					      EVAL8	20
      1  2c1b				  -	      IF	(20 > 127) || (20 < -128)
      2  2c1b				  -	      ECHO	"Erroneous position value", 20
      3  2c1b				  -	      ERR
      4  2c1b					      ENDIF
      5  2c1b		       14		      .byte.b	20
      0  2c1c					      EVAL8	0
      1  2c1c				  -	      IF	(0 > 127) || (0 < -128)
      2  2c1c				  -	      ECHO	"Erroneous position value", 0
      3  2c1c				  -	      ERR
      4  2c1c					      ENDIF
      5  2c1c		       00		      .byte.b	0
      0  2c1d					      EVAL8	-10
      1  2c1d				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2c1d				  -	      ECHO	"Erroneous position value", -10
      3  2c1d				  -	      ERR
      4  2c1d					      ENDIF
      5  2c1d		       f6		      .byte.b	-10
      0  2c1e					      EVAL8	-10
      1  2c1e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2c1e				  -	      ECHO	"Erroneous position value", -10
      3  2c1e				  -	      ERR
      4  2c1e					      ENDIF
      5  2c1e		       f6		      .byte.b	-10
      0  2c1f					      EVAL8	0
      1  2c1f				  -	      IF	(0 > 127) || (0 < -128)
      2  2c1f				  -	      ECHO	"Erroneous position value", 0
      3  2c1f				  -	      ERR
      4  2c1f					      ENDIF
      5  2c1f		       00		      .byte.b	0
      0  2c20					      EVAL8	20
      1  2c20				  -	      IF	(20 > 127) || (20 < -128)
      2  2c20				  -	      ECHO	"Erroneous position value", 20
      3  2c20				  -	      ERR
      4  2c20					      ENDIF
      5  2c20		       14		      .byte.b	20
      0  2c21					      EVAL8	15
      1  2c21				  -	      IF	(15 > 127) || (15 < -128)
      2  2c21				  -	      ECHO	"Erroneous position value", 15
      3  2c21				  -	      ERR
      4  2c21					      ENDIF
      5  2c21		       0f		      .byte.b	15
      0  2c22					      EVAL8	0
      1  2c22				  -	      IF	(0 > 127) || (0 < -128)
      2  2c22				  -	      ECHO	"Erroneous position value", 0
      3  2c22				  -	      ERR
      4  2c22					      ENDIF
      5  2c22		       00		      .byte.b	0
      0  2c23					      EVAL8	0
      1  2c23				  -	      IF	(0 > 127) || (0 < -128)
      2  2c23				  -	      ECHO	"Erroneous position value", 0
      3  2c23				  -	      ERR
      4  2c23					      ENDIF
      5  2c23		       00		      .byte.b	0
      0  2c24					      PVAL	5, -5, 20, 0, 0, 20, -5, 5
      0  2c24					      EVAL8	5
      1  2c24				  -	      IF	(5 > 127) || (5 < -128)
      2  2c24				  -	      ECHO	"Erroneous position value", 5
      3  2c24				  -	      ERR
      4  2c24					      ENDIF
      5  2c24		       05		      .byte.b	5
      0  2c25					      EVAL8	-5
      1  2c25				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2c25				  -	      ECHO	"Erroneous position value", -5
      3  2c25				  -	      ERR
      4  2c25					      ENDIF
      5  2c25		       fb		      .byte.b	-5
      0  2c26					      EVAL8	20
      1  2c26				  -	      IF	(20 > 127) || (20 < -128)
      2  2c26				  -	      ECHO	"Erroneous position value", 20
      3  2c26				  -	      ERR
      4  2c26					      ENDIF
      5  2c26		       14		      .byte.b	20
      0  2c27					      EVAL8	0
      1  2c27				  -	      IF	(0 > 127) || (0 < -128)
      2  2c27				  -	      ECHO	"Erroneous position value", 0
      3  2c27				  -	      ERR
      4  2c27					      ENDIF
      5  2c27		       00		      .byte.b	0
      0  2c28					      EVAL8	0
      1  2c28				  -	      IF	(0 > 127) || (0 < -128)
      2  2c28				  -	      ECHO	"Erroneous position value", 0
      3  2c28				  -	      ERR
      4  2c28					      ENDIF
      5  2c28		       00		      .byte.b	0
      0  2c29					      EVAL8	20
      1  2c29				  -	      IF	(20 > 127) || (20 < -128)
      2  2c29				  -	      ECHO	"Erroneous position value", 20
      3  2c29				  -	      ERR
      4  2c29					      ENDIF
      5  2c29		       14		      .byte.b	20
      0  2c2a					      EVAL8	-5
      1  2c2a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2c2a				  -	      ECHO	"Erroneous position value", -5
      3  2c2a				  -	      ERR
      4  2c2a					      ENDIF
      5  2c2a		       fb		      .byte.b	-5
      0  2c2b					      EVAL8	5
      1  2c2b				  -	      IF	(5 > 127) || (5 < -128)
      2  2c2b				  -	      ECHO	"Erroneous position value", 5
      3  2c2b				  -	      ERR
      4  2c2b					      ENDIF
      5  2c2b		       05		      .byte.b	5
      0  2c2c					      EVAL8	0
      1  2c2c				  -	      IF	(0 > 127) || (0 < -128)
      2  2c2c				  -	      ECHO	"Erroneous position value", 0
      3  2c2c				  -	      ERR
      4  2c2c					      ENDIF
      5  2c2c		       00		      .byte.b	0
      0  2c2d					      EVAL8	0
      1  2c2d				  -	      IF	(0 > 127) || (0 < -128)
      2  2c2d				  -	      ECHO	"Erroneous position value", 0
      3  2c2d				  -	      ERR
      4  2c2d					      ENDIF
      5  2c2d		       00		      .byte.b	0
      0  2c2e					      PVAL	5, 5, 10, 20, 40, 20, 5, 5
      0  2c2e					      EVAL8	5
      1  2c2e				  -	      IF	(5 > 127) || (5 < -128)
      2  2c2e				  -	      ECHO	"Erroneous position value", 5
      3  2c2e				  -	      ERR
      4  2c2e					      ENDIF
      5  2c2e		       05		      .byte.b	5
      0  2c2f					      EVAL8	5
      1  2c2f				  -	      IF	(5 > 127) || (5 < -128)
      2  2c2f				  -	      ECHO	"Erroneous position value", 5
      3  2c2f				  -	      ERR
      4  2c2f					      ENDIF
      5  2c2f		       05		      .byte.b	5
      0  2c30					      EVAL8	10
      1  2c30				  -	      IF	(10 > 127) || (10 < -128)
      2  2c30				  -	      ECHO	"Erroneous position value", 10
      3  2c30				  -	      ERR
      4  2c30					      ENDIF
      5  2c30		       0a		      .byte.b	10
      0  2c31					      EVAL8	20
      1  2c31				  -	      IF	(20 > 127) || (20 < -128)
      2  2c31				  -	      ECHO	"Erroneous position value", 20
      3  2c31				  -	      ERR
      4  2c31					      ENDIF
      5  2c31		       14		      .byte.b	20
      0  2c32					      EVAL8	40
      1  2c32				  -	      IF	(40 > 127) || (40 < -128)
      2  2c32				  -	      ECHO	"Erroneous position value", 40
      3  2c32				  -	      ERR
      4  2c32					      ENDIF
      5  2c32		       28		      .byte.b	40
      0  2c33					      EVAL8	20
      1  2c33				  -	      IF	(20 > 127) || (20 < -128)
      2  2c33				  -	      ECHO	"Erroneous position value", 20
      3  2c33				  -	      ERR
      4  2c33					      ENDIF
      5  2c33		       14		      .byte.b	20
      0  2c34					      EVAL8	5
      1  2c34				  -	      IF	(5 > 127) || (5 < -128)
      2  2c34				  -	      ECHO	"Erroneous position value", 5
      3  2c34				  -	      ERR
      4  2c34					      ENDIF
      5  2c34		       05		      .byte.b	5
      0  2c35					      EVAL8	5
      1  2c35				  -	      IF	(5 > 127) || (5 < -128)
      2  2c35				  -	      ECHO	"Erroneous position value", 5
      3  2c35				  -	      ERR
      4  2c35					      ENDIF
      5  2c35		       05		      .byte.b	5
      0  2c36					      EVAL8	0
      1  2c36				  -	      IF	(0 > 127) || (0 < -128)
      2  2c36				  -	      ECHO	"Erroneous position value", 0
      3  2c36				  -	      ERR
      4  2c36					      ENDIF
      5  2c36		       00		      .byte.b	0
      0  2c37					      EVAL8	0
      1  2c37				  -	      IF	(0 > 127) || (0 < -128)
      2  2c37				  -	      ECHO	"Erroneous position value", 0
      3  2c37				  -	      ERR
      4  2c37					      ENDIF
      5  2c37		       00		      .byte.b	0
      0  2c38					      PVAL	15, 15, 20, 40, 50, 20, 15, 15
      0  2c38					      EVAL8	15
      1  2c38				  -	      IF	(15 > 127) || (15 < -128)
      2  2c38				  -	      ECHO	"Erroneous position value", 15
      3  2c38				  -	      ERR
      4  2c38					      ENDIF
      5  2c38		       0f		      .byte.b	15
      0  2c39					      EVAL8	15
      1  2c39				  -	      IF	(15 > 127) || (15 < -128)
      2  2c39				  -	      ECHO	"Erroneous position value", 15
      3  2c39				  -	      ERR
      4  2c39					      ENDIF
      5  2c39		       0f		      .byte.b	15
      0  2c3a					      EVAL8	20
      1  2c3a				  -	      IF	(20 > 127) || (20 < -128)
      2  2c3a				  -	      ECHO	"Erroneous position value", 20
      3  2c3a				  -	      ERR
      4  2c3a					      ENDIF
      5  2c3a		       14		      .byte.b	20
      0  2c3b					      EVAL8	40
      1  2c3b				  -	      IF	(40 > 127) || (40 < -128)
      2  2c3b				  -	      ECHO	"Erroneous position value", 40
      3  2c3b				  -	      ERR
      4  2c3b					      ENDIF
      5  2c3b		       28		      .byte.b	40
      0  2c3c					      EVAL8	50
      1  2c3c				  -	      IF	(50 > 127) || (50 < -128)
      2  2c3c				  -	      ECHO	"Erroneous position value", 50
      3  2c3c				  -	      ERR
      4  2c3c					      ENDIF
      5  2c3c		       32		      .byte.b	50
      0  2c3d					      EVAL8	20
      1  2c3d				  -	      IF	(20 > 127) || (20 < -128)
      2  2c3d				  -	      ECHO	"Erroneous position value", 20
      3  2c3d				  -	      ERR
      4  2c3d					      ENDIF
      5  2c3d		       14		      .byte.b	20
      0  2c3e					      EVAL8	15
      1  2c3e				  -	      IF	(15 > 127) || (15 < -128)
      2  2c3e				  -	      ECHO	"Erroneous position value", 15
      3  2c3e				  -	      ERR
      4  2c3e					      ENDIF
      5  2c3e		       0f		      .byte.b	15
      0  2c3f					      EVAL8	15
      1  2c3f				  -	      IF	(15 > 127) || (15 < -128)
      2  2c3f				  -	      ECHO	"Erroneous position value", 15
      3  2c3f				  -	      ERR
      4  2c3f					      ENDIF
      5  2c3f		       0f		      .byte.b	15
      0  2c40					      EVAL8	0
      1  2c40				  -	      IF	(0 > 127) || (0 < -128)
      2  2c40				  -	      ECHO	"Erroneous position value", 0
      3  2c40				  -	      ERR
      4  2c40					      ENDIF
      5  2c40		       00		      .byte.b	0
      0  2c41					      EVAL8	0
      1  2c41				  -	      IF	(0 > 127) || (0 < -128)
      2  2c41				  -	      ECHO	"Erroneous position value", 0
      3  2c41				  -	      ERR
      4  2c41					      ENDIF
      5  2c41		       00		      .byte.b	0
      0  2c42					      PVAL	60, 60, 80, 80, 80, 80, 60, 60
      0  2c42					      EVAL8	60
      1  2c42				  -	      IF	(60 > 127) || (60 < -128)
      2  2c42				  -	      ECHO	"Erroneous position value", 60
      3  2c42				  -	      ERR
      4  2c42					      ENDIF
      5  2c42		       3c		      .byte.b	60
      0  2c43					      EVAL8	60
      1  2c43				  -	      IF	(60 > 127) || (60 < -128)
      2  2c43				  -	      ECHO	"Erroneous position value", 60
      3  2c43				  -	      ERR
      4  2c43					      ENDIF
      5  2c43		       3c		      .byte.b	60
      0  2c44					      EVAL8	80
      1  2c44				  -	      IF	(80 > 127) || (80 < -128)
      2  2c44				  -	      ECHO	"Erroneous position value", 80
      3  2c44				  -	      ERR
      4  2c44					      ENDIF
      5  2c44		       50		      .byte.b	80
      0  2c45					      EVAL8	80
      1  2c45				  -	      IF	(80 > 127) || (80 < -128)
      2  2c45				  -	      ECHO	"Erroneous position value", 80
      3  2c45				  -	      ERR
      4  2c45					      ENDIF
      5  2c45		       50		      .byte.b	80
      0  2c46					      EVAL8	80
      1  2c46				  -	      IF	(80 > 127) || (80 < -128)
      2  2c46				  -	      ECHO	"Erroneous position value", 80
      3  2c46				  -	      ERR
      4  2c46					      ENDIF
      5  2c46		       50		      .byte.b	80
      0  2c47					      EVAL8	80
      1  2c47				  -	      IF	(80 > 127) || (80 < -128)
      2  2c47				  -	      ECHO	"Erroneous position value", 80
      3  2c47				  -	      ERR
      4  2c47					      ENDIF
      5  2c47		       50		      .byte.b	80
      0  2c48					      EVAL8	60
      1  2c48				  -	      IF	(60 > 127) || (60 < -128)
      2  2c48				  -	      ECHO	"Erroneous position value", 60
      3  2c48				  -	      ERR
      4  2c48					      ENDIF
      5  2c48		       3c		      .byte.b	60
      0  2c49					      EVAL8	60
      1  2c49				  -	      IF	(60 > 127) || (60 < -128)
      2  2c49				  -	      ECHO	"Erroneous position value", 60
      3  2c49				  -	      ERR
      4  2c49					      ENDIF
      5  2c49		       3c		      .byte.b	60
      0  2c4a					      EVAL8	0
      1  2c4a				  -	      IF	(0 > 127) || (0 < -128)
      2  2c4a				  -	      ECHO	"Erroneous position value", 0
      3  2c4a				  -	      ERR
      4  2c4a					      ENDIF
      5  2c4a		       00		      .byte.b	0
      0  2c4b					      EVAL8	0
      1  2c4b				  -	      IF	(0 > 127) || (0 < -128)
      2  2c4b				  -	      ECHO	"Erroneous position value", 0
      3  2c4b				  -	      ERR
      4  2c4b					      ENDIF
      5  2c4b		       00		      .byte.b	0
      0  2c4c					      PVAL	100, 100, 120, 120, 120, 120, 100, 100
      0  2c4c					      EVAL8	100
      1  2c4c				  -	      IF	(100 > 127) || (100 < -128)
      2  2c4c				  -	      ECHO	"Erroneous position value", 100
      3  2c4c				  -	      ERR
      4  2c4c					      ENDIF
      5  2c4c		       64		      .byte.b	100
      0  2c4d					      EVAL8	100
      1  2c4d				  -	      IF	(100 > 127) || (100 < -128)
      2  2c4d				  -	      ECHO	"Erroneous position value", 100
      3  2c4d				  -	      ERR
      4  2c4d					      ENDIF
      5  2c4d		       64		      .byte.b	100
      0  2c4e					      EVAL8	120
      1  2c4e				  -	      IF	(120 > 127) || (120 < -128)
      2  2c4e				  -	      ECHO	"Erroneous position value", 120
      3  2c4e				  -	      ERR
      4  2c4e					      ENDIF
      5  2c4e		       78		      .byte.b	120
      0  2c4f					      EVAL8	120
      1  2c4f				  -	      IF	(120 > 127) || (120 < -128)
      2  2c4f				  -	      ECHO	"Erroneous position value", 120
      3  2c4f				  -	      ERR
      4  2c4f					      ENDIF
      5  2c4f		       78		      .byte.b	120
      0  2c50					      EVAL8	120
      1  2c50				  -	      IF	(120 > 127) || (120 < -128)
      2  2c50				  -	      ECHO	"Erroneous position value", 120
      3  2c50				  -	      ERR
      4  2c50					      ENDIF
      5  2c50		       78		      .byte.b	120
      0  2c51					      EVAL8	120
      1  2c51				  -	      IF	(120 > 127) || (120 < -128)
      2  2c51				  -	      ECHO	"Erroneous position value", 120
      3  2c51				  -	      ERR
      4  2c51					      ENDIF
      5  2c51		       78		      .byte.b	120
      0  2c52					      EVAL8	100
      1  2c52				  -	      IF	(100 > 127) || (100 < -128)
      2  2c52				  -	      ECHO	"Erroneous position value", 100
      3  2c52				  -	      ERR
      4  2c52					      ENDIF
      5  2c52		       64		      .byte.b	100
      0  2c53					      EVAL8	100
      1  2c53				  -	      IF	(100 > 127) || (100 < -128)
      2  2c53				  -	      ECHO	"Erroneous position value", 100
      3  2c53				  -	      ERR
      4  2c53					      ENDIF
      5  2c53		       64		      .byte.b	100
      0  2c54					      EVAL8	0
      1  2c54				  -	      IF	(0 > 127) || (0 < -128)
      2  2c54				  -	      ECHO	"Erroneous position value", 0
      3  2c54				  -	      ERR
      4  2c54					      ENDIF
      5  2c54		       00		      .byte.b	0
      0  2c55					      EVAL8	0
      1  2c55				  -	      IF	(0 > 127) || (0 < -128)
      2  2c55				  -	      ECHO	"Erroneous position value", 0
      3  2c55				  -	      ERR
      4  2c55					      ENDIF
      5  2c55		       00		      .byte.b	0
      0  2c56					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  2c56					      EVAL8	0
      1  2c56				  -	      IF	(0 > 127) || (0 < -128)
      2  2c56				  -	      ECHO	"Erroneous position value", 0
      3  2c56				  -	      ERR
      4  2c56					      ENDIF
      5  2c56		       00		      .byte.b	0
      0  2c57					      EVAL8	0
      1  2c57				  -	      IF	(0 > 127) || (0 < -128)
      2  2c57				  -	      ECHO	"Erroneous position value", 0
      3  2c57				  -	      ERR
      4  2c57					      ENDIF
      5  2c57		       00		      .byte.b	0
      0  2c58					      EVAL8	0
      1  2c58				  -	      IF	(0 > 127) || (0 < -128)
      2  2c58				  -	      ECHO	"Erroneous position value", 0
      3  2c58				  -	      ERR
      4  2c58					      ENDIF
      5  2c58		       00		      .byte.b	0
      0  2c59					      EVAL8	0
      1  2c59				  -	      IF	(0 > 127) || (0 < -128)
      2  2c59				  -	      ECHO	"Erroneous position value", 0
      3  2c59				  -	      ERR
      4  2c59					      ENDIF
      5  2c59		       00		      .byte.b	0
      0  2c5a					      EVAL8	0
      1  2c5a				  -	      IF	(0 > 127) || (0 < -128)
      2  2c5a				  -	      ECHO	"Erroneous position value", 0
      3  2c5a				  -	      ERR
      4  2c5a					      ENDIF
      5  2c5a		       00		      .byte.b	0
      0  2c5b					      EVAL8	0
      1  2c5b				  -	      IF	(0 > 127) || (0 < -128)
      2  2c5b				  -	      ECHO	"Erroneous position value", 0
      3  2c5b				  -	      ERR
      4  2c5b					      ENDIF
      5  2c5b		       00		      .byte.b	0
      0  2c5c					      EVAL8	0
      1  2c5c				  -	      IF	(0 > 127) || (0 < -128)
      2  2c5c				  -	      ECHO	"Erroneous position value", 0
      3  2c5c				  -	      ERR
      4  2c5c					      ENDIF
      5  2c5c		       00		      .byte.b	0
      0  2c5d					      EVAL8	0
      1  2c5d				  -	      IF	(0 > 127) || (0 < -128)
      2  2c5d				  -	      ECHO	"Erroneous position value", 0
      3  2c5d				  -	      ERR
      4  2c5d					      ENDIF
      5  2c5d		       00		      .byte.b	0
      0  2c5e					      EVAL8	0
      1  2c5e				  -	      IF	(0 > 127) || (0 < -128)
      2  2c5e				  -	      ECHO	"Erroneous position value", 0
      3  2c5e				  -	      ERR
      4  2c5e					      ENDIF
      5  2c5e		       00		      .byte.b	0
      0  2c5f					      EVAL8	0
      1  2c5f				  -	      IF	(0 > 127) || (0 < -128)
      2  2c5f				  -	      ECHO	"Erroneous position value", 0
      3  2c5f				  -	      ERR
      4  2c5f					      ENDIF
      5  2c5f		       00		      .byte.b	0
     72  2c60
     73  2c60							;---------------------------------------------------------------------------------------------------
     74  2c60
     75  2c60				   PositionalValue_KNIGHT
     76  2c60
      0  2c60					      PVAL	-50, -30, -30, -30, -30, -30, -22, -50
      0  2c60					      EVAL8	-50
      1  2c60				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2c60				  -	      ECHO	"Erroneous position value", -50
      3  2c60				  -	      ERR
      4  2c60					      ENDIF
      5  2c60		       ce		      .byte.b	-50
      0  2c61					      EVAL8	-30
      1  2c61				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2c61				  -	      ECHO	"Erroneous position value", -30
      3  2c61				  -	      ERR
      4  2c61					      ENDIF
      5  2c61		       e2		      .byte.b	-30
      0  2c62					      EVAL8	-30
      1  2c62				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2c62				  -	      ECHO	"Erroneous position value", -30
      3  2c62				  -	      ERR
      4  2c62					      ENDIF
      5  2c62		       e2		      .byte.b	-30
      0  2c63					      EVAL8	-30
      1  2c63				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2c63				  -	      ECHO	"Erroneous position value", -30
      3  2c63				  -	      ERR
      4  2c63					      ENDIF
      5  2c63		       e2		      .byte.b	-30
      0  2c64					      EVAL8	-30
      1  2c64				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2c64				  -	      ECHO	"Erroneous position value", -30
      3  2c64				  -	      ERR
      4  2c64					      ENDIF
      5  2c64		       e2		      .byte.b	-30
      0  2c65					      EVAL8	-30
      1  2c65				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2c65				  -	      ECHO	"Erroneous position value", -30
      3  2c65				  -	      ERR
      4  2c65					      ENDIF
      5  2c65		       e2		      .byte.b	-30
      0  2c66					      EVAL8	-22
      1  2c66				  -	      IF	(-22 > 127) || (-22 < -128)
      2  2c66				  -	      ECHO	"Erroneous position value", -22
      3  2c66				  -	      ERR
      4  2c66					      ENDIF
      5  2c66		       ea		      .byte.b	-22
      0  2c67					      EVAL8	-50
      1  2c67				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2c67				  -	      ECHO	"Erroneous position value", -50
      3  2c67				  -	      ERR
      4  2c67					      ENDIF
      5  2c67		       ce		      .byte.b	-50
      0  2c68					      EVAL8	0
      1  2c68				  -	      IF	(0 > 127) || (0 < -128)
      2  2c68				  -	      ECHO	"Erroneous position value", 0
      3  2c68				  -	      ERR
      4  2c68					      ENDIF
      5  2c68		       00		      .byte.b	0
      0  2c69					      EVAL8	0
      1  2c69				  -	      IF	(0 > 127) || (0 < -128)
      2  2c69				  -	      ECHO	"Erroneous position value", 0
      3  2c69				  -	      ERR
      4  2c69					      ENDIF
      5  2c69		       00		      .byte.b	0
      0  2c6a					      PVAL	-40, -20, 0, -5, -25, 0, -20, -40
      0  2c6a					      EVAL8	-40
      1  2c6a				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2c6a				  -	      ECHO	"Erroneous position value", -40
      3  2c6a				  -	      ERR
      4  2c6a					      ENDIF
      5  2c6a		       d8		      .byte.b	-40
      0  2c6b					      EVAL8	-20
      1  2c6b				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2c6b				  -	      ECHO	"Erroneous position value", -20
      3  2c6b				  -	      ERR
      4  2c6b					      ENDIF
      5  2c6b		       ec		      .byte.b	-20
      0  2c6c					      EVAL8	0
      1  2c6c				  -	      IF	(0 > 127) || (0 < -128)
      2  2c6c				  -	      ECHO	"Erroneous position value", 0
      3  2c6c				  -	      ERR
      4  2c6c					      ENDIF
      5  2c6c		       00		      .byte.b	0
      0  2c6d					      EVAL8	-5
      1  2c6d				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2c6d				  -	      ECHO	"Erroneous position value", -5
      3  2c6d				  -	      ERR
      4  2c6d					      ENDIF
      5  2c6d		       fb		      .byte.b	-5
      0  2c6e					      EVAL8	-25
      1  2c6e				  -	      IF	(-25 > 127) || (-25 < -128)
      2  2c6e				  -	      ECHO	"Erroneous position value", -25
      3  2c6e				  -	      ERR
      4  2c6e					      ENDIF
      5  2c6e		       e7		      .byte.b	-25
      0  2c6f					      EVAL8	0
      1  2c6f				  -	      IF	(0 > 127) || (0 < -128)
      2  2c6f				  -	      ECHO	"Erroneous position value", 0
      3  2c6f				  -	      ERR
      4  2c6f					      ENDIF
      5  2c6f		       00		      .byte.b	0
      0  2c70					      EVAL8	-20
      1  2c70				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2c70				  -	      ECHO	"Erroneous position value", -20
      3  2c70				  -	      ERR
      4  2c70					      ENDIF
      5  2c70		       ec		      .byte.b	-20
      0  2c71					      EVAL8	-40
      1  2c71				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2c71				  -	      ECHO	"Erroneous position value", -40
      3  2c71				  -	      ERR
      4  2c71					      ENDIF
      5  2c71		       d8		      .byte.b	-40
      0  2c72					      EVAL8	0
      1  2c72				  -	      IF	(0 > 127) || (0 < -128)
      2  2c72				  -	      ECHO	"Erroneous position value", 0
      3  2c72				  -	      ERR
      4  2c72					      ENDIF
      5  2c72		       00		      .byte.b	0
      0  2c73					      EVAL8	0
      1  2c73				  -	      IF	(0 > 127) || (0 < -128)
      2  2c73				  -	      ECHO	"Erroneous position value", 0
      3  2c73				  -	      ERR
      4  2c73					      ENDIF
      5  2c73		       00		      .byte.b	0
      0  2c74					      PVAL	-30, 0, 18, 15, 15, 18, 0, -30
      0  2c74					      EVAL8	-30
      1  2c74				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2c74				  -	      ECHO	"Erroneous position value", -30
      3  2c74				  -	      ERR
      4  2c74					      ENDIF
      5  2c74		       e2		      .byte.b	-30
      0  2c75					      EVAL8	0
      1  2c75				  -	      IF	(0 > 127) || (0 < -128)
      2  2c75				  -	      ECHO	"Erroneous position value", 0
      3  2c75				  -	      ERR
      4  2c75					      ENDIF
      5  2c75		       00		      .byte.b	0
      0  2c76					      EVAL8	18
      1  2c76				  -	      IF	(18 > 127) || (18 < -128)
      2  2c76				  -	      ECHO	"Erroneous position value", 18
      3  2c76				  -	      ERR
      4  2c76					      ENDIF
      5  2c76		       12		      .byte.b	18
      0  2c77					      EVAL8	15
      1  2c77				  -	      IF	(15 > 127) || (15 < -128)
      2  2c77				  -	      ECHO	"Erroneous position value", 15
      3  2c77				  -	      ERR
      4  2c77					      ENDIF
      5  2c77		       0f		      .byte.b	15
      0  2c78					      EVAL8	15
      1  2c78				  -	      IF	(15 > 127) || (15 < -128)
      2  2c78				  -	      ECHO	"Erroneous position value", 15
      3  2c78				  -	      ERR
      4  2c78					      ENDIF
      5  2c78		       0f		      .byte.b	15
      0  2c79					      EVAL8	18
      1  2c79				  -	      IF	(18 > 127) || (18 < -128)
      2  2c79				  -	      ECHO	"Erroneous position value", 18
      3  2c79				  -	      ERR
      4  2c79					      ENDIF
      5  2c79		       12		      .byte.b	18
      0  2c7a					      EVAL8	0
      1  2c7a				  -	      IF	(0 > 127) || (0 < -128)
      2  2c7a				  -	      ECHO	"Erroneous position value", 0
      3  2c7a				  -	      ERR
      4  2c7a					      ENDIF
      5  2c7a		       00		      .byte.b	0
      0  2c7b					      EVAL8	-30
      1  2c7b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2c7b				  -	      ECHO	"Erroneous position value", -30
      3  2c7b				  -	      ERR
      4  2c7b					      ENDIF
      5  2c7b		       e2		      .byte.b	-30
      0  2c7c					      EVAL8	0
      1  2c7c				  -	      IF	(0 > 127) || (0 < -128)
      2  2c7c				  -	      ECHO	"Erroneous position value", 0
      3  2c7c				  -	      ERR
      4  2c7c					      ENDIF
      5  2c7c		       00		      .byte.b	0
      0  2c7d					      EVAL8	0
      1  2c7d				  -	      IF	(0 > 127) || (0 < -128)
      2  2c7d				  -	      ECHO	"Erroneous position value", 0
      3  2c7d				  -	      ERR
      4  2c7d					      ENDIF
      5  2c7d		       00		      .byte.b	0
      0  2c7e					      PVAL	-40, 0, 15, 30, 30, 15, 0, -40
      0  2c7e					      EVAL8	-40
      1  2c7e				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2c7e				  -	      ECHO	"Erroneous position value", -40
      3  2c7e				  -	      ERR
      4  2c7e					      ENDIF
      5  2c7e		       d8		      .byte.b	-40
      0  2c7f					      EVAL8	0
      1  2c7f				  -	      IF	(0 > 127) || (0 < -128)
      2  2c7f				  -	      ECHO	"Erroneous position value", 0
      3  2c7f				  -	      ERR
      4  2c7f					      ENDIF
      5  2c7f		       00		      .byte.b	0
      0  2c80					      EVAL8	15
      1  2c80				  -	      IF	(15 > 127) || (15 < -128)
      2  2c80				  -	      ECHO	"Erroneous position value", 15
      3  2c80				  -	      ERR
      4  2c80					      ENDIF
      5  2c80		       0f		      .byte.b	15
      0  2c81					      EVAL8	30
      1  2c81				  -	      IF	(30 > 127) || (30 < -128)
      2  2c81				  -	      ECHO	"Erroneous position value", 30
      3  2c81				  -	      ERR
      4  2c81					      ENDIF
      5  2c81		       1e		      .byte.b	30
      0  2c82					      EVAL8	30
      1  2c82				  -	      IF	(30 > 127) || (30 < -128)
      2  2c82				  -	      ECHO	"Erroneous position value", 30
      3  2c82				  -	      ERR
      4  2c82					      ENDIF
      5  2c82		       1e		      .byte.b	30
      0  2c83					      EVAL8	15
      1  2c83				  -	      IF	(15 > 127) || (15 < -128)
      2  2c83				  -	      ECHO	"Erroneous position value", 15
      3  2c83				  -	      ERR
      4  2c83					      ENDIF
      5  2c83		       0f		      .byte.b	15
      0  2c84					      EVAL8	0
      1  2c84				  -	      IF	(0 > 127) || (0 < -128)
      2  2c84				  -	      ECHO	"Erroneous position value", 0
      3  2c84				  -	      ERR
      4  2c84					      ENDIF
      5  2c84		       00		      .byte.b	0
      0  2c85					      EVAL8	-40
      1  2c85				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2c85				  -	      ECHO	"Erroneous position value", -40
      3  2c85				  -	      ERR
      4  2c85					      ENDIF
      5  2c85		       d8		      .byte.b	-40
      0  2c86					      EVAL8	0
      1  2c86				  -	      IF	(0 > 127) || (0 < -128)
      2  2c86				  -	      ECHO	"Erroneous position value", 0
      3  2c86				  -	      ERR
      4  2c86					      ENDIF
      5  2c86		       00		      .byte.b	0
      0  2c87					      EVAL8	0
      1  2c87				  -	      IF	(0 > 127) || (0 < -128)
      2  2c87				  -	      ECHO	"Erroneous position value", 0
      3  2c87				  -	      ERR
      4  2c87					      ENDIF
      5  2c87		       00		      .byte.b	0
      0  2c88					      PVAL	-40, 5, 15, 30, 30, 15, 5, -40
      0  2c88					      EVAL8	-40
      1  2c88				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2c88				  -	      ECHO	"Erroneous position value", -40
      3  2c88				  -	      ERR
      4  2c88					      ENDIF
      5  2c88		       d8		      .byte.b	-40
      0  2c89					      EVAL8	5
      1  2c89				  -	      IF	(5 > 127) || (5 < -128)
      2  2c89				  -	      ECHO	"Erroneous position value", 5
      3  2c89				  -	      ERR
      4  2c89					      ENDIF
      5  2c89		       05		      .byte.b	5
      0  2c8a					      EVAL8	15
      1  2c8a				  -	      IF	(15 > 127) || (15 < -128)
      2  2c8a				  -	      ECHO	"Erroneous position value", 15
      3  2c8a				  -	      ERR
      4  2c8a					      ENDIF
      5  2c8a		       0f		      .byte.b	15
      0  2c8b					      EVAL8	30
      1  2c8b				  -	      IF	(30 > 127) || (30 < -128)
      2  2c8b				  -	      ECHO	"Erroneous position value", 30
      3  2c8b				  -	      ERR
      4  2c8b					      ENDIF
      5  2c8b		       1e		      .byte.b	30
      0  2c8c					      EVAL8	30
      1  2c8c				  -	      IF	(30 > 127) || (30 < -128)
      2  2c8c				  -	      ECHO	"Erroneous position value", 30
      3  2c8c				  -	      ERR
      4  2c8c					      ENDIF
      5  2c8c		       1e		      .byte.b	30
      0  2c8d					      EVAL8	15
      1  2c8d				  -	      IF	(15 > 127) || (15 < -128)
      2  2c8d				  -	      ECHO	"Erroneous position value", 15
      3  2c8d				  -	      ERR
      4  2c8d					      ENDIF
      5  2c8d		       0f		      .byte.b	15
      0  2c8e					      EVAL8	5
      1  2c8e				  -	      IF	(5 > 127) || (5 < -128)
      2  2c8e				  -	      ECHO	"Erroneous position value", 5
      3  2c8e				  -	      ERR
      4  2c8e					      ENDIF
      5  2c8e		       05		      .byte.b	5
      0  2c8f					      EVAL8	-40
      1  2c8f				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2c8f				  -	      ECHO	"Erroneous position value", -40
      3  2c8f				  -	      ERR
      4  2c8f					      ENDIF
      5  2c8f		       d8		      .byte.b	-40
      0  2c90					      EVAL8	0
      1  2c90				  -	      IF	(0 > 127) || (0 < -128)
      2  2c90				  -	      ECHO	"Erroneous position value", 0
      3  2c90				  -	      ERR
      4  2c90					      ENDIF
      5  2c90		       00		      .byte.b	0
      0  2c91					      EVAL8	0
      1  2c91				  -	      IF	(0 > 127) || (0 < -128)
      2  2c91				  -	      ECHO	"Erroneous position value", 0
      3  2c91				  -	      ERR
      4  2c91					      ENDIF
      5  2c91		       00		      .byte.b	0
      0  2c92					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      0  2c92					      EVAL8	-30
      1  2c92				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2c92				  -	      ECHO	"Erroneous position value", -30
      3  2c92				  -	      ERR
      4  2c92					      ENDIF
      5  2c92		       e2		      .byte.b	-30
      0  2c93					      EVAL8	0
      1  2c93				  -	      IF	(0 > 127) || (0 < -128)
      2  2c93				  -	      ECHO	"Erroneous position value", 0
      3  2c93				  -	      ERR
      4  2c93					      ENDIF
      5  2c93		       00		      .byte.b	0
      0  2c94					      EVAL8	10
      1  2c94				  -	      IF	(10 > 127) || (10 < -128)
      2  2c94				  -	      ECHO	"Erroneous position value", 10
      3  2c94				  -	      ERR
      4  2c94					      ENDIF
      5  2c94		       0a		      .byte.b	10
      0  2c95					      EVAL8	15
      1  2c95				  -	      IF	(15 > 127) || (15 < -128)
      2  2c95				  -	      ECHO	"Erroneous position value", 15
      3  2c95				  -	      ERR
      4  2c95					      ENDIF
      5  2c95		       0f		      .byte.b	15
      0  2c96					      EVAL8	15
      1  2c96				  -	      IF	(15 > 127) || (15 < -128)
      2  2c96				  -	      ECHO	"Erroneous position value", 15
      3  2c96				  -	      ERR
      4  2c96					      ENDIF
      5  2c96		       0f		      .byte.b	15
      0  2c97					      EVAL8	10
      1  2c97				  -	      IF	(10 > 127) || (10 < -128)
      2  2c97				  -	      ECHO	"Erroneous position value", 10
      3  2c97				  -	      ERR
      4  2c97					      ENDIF
      5  2c97		       0a		      .byte.b	10
      0  2c98					      EVAL8	0
      1  2c98				  -	      IF	(0 > 127) || (0 < -128)
      2  2c98				  -	      ECHO	"Erroneous position value", 0
      3  2c98				  -	      ERR
      4  2c98					      ENDIF
      5  2c98		       00		      .byte.b	0
      0  2c99					      EVAL8	-30
      1  2c99				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2c99				  -	      ECHO	"Erroneous position value", -30
      3  2c99				  -	      ERR
      4  2c99					      ENDIF
      5  2c99		       e2		      .byte.b	-30
      0  2c9a					      EVAL8	0
      1  2c9a				  -	      IF	(0 > 127) || (0 < -128)
      2  2c9a				  -	      ECHO	"Erroneous position value", 0
      3  2c9a				  -	      ERR
      4  2c9a					      ENDIF
      5  2c9a		       00		      .byte.b	0
      0  2c9b					      EVAL8	0
      1  2c9b				  -	      IF	(0 > 127) || (0 < -128)
      2  2c9b				  -	      ECHO	"Erroneous position value", 0
      3  2c9b				  -	      ERR
      4  2c9b					      ENDIF
      5  2c9b		       00		      .byte.b	0
      0  2c9c					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      0  2c9c					      EVAL8	-40
      1  2c9c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2c9c				  -	      ECHO	"Erroneous position value", -40
      3  2c9c				  -	      ERR
      4  2c9c					      ENDIF
      5  2c9c		       d8		      .byte.b	-40
      0  2c9d					      EVAL8	-20
      1  2c9d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2c9d				  -	      ECHO	"Erroneous position value", -20
      3  2c9d				  -	      ERR
      4  2c9d					      ENDIF
      5  2c9d		       ec		      .byte.b	-20
      0  2c9e					      EVAL8	30
      1  2c9e				  -	      IF	(30 > 127) || (30 < -128)
      2  2c9e				  -	      ECHO	"Erroneous position value", 30
      3  2c9e				  -	      ERR
      4  2c9e					      ENDIF
      5  2c9e		       1e		      .byte.b	30
      0  2c9f					      EVAL8	0
      1  2c9f				  -	      IF	(0 > 127) || (0 < -128)
      2  2c9f				  -	      ECHO	"Erroneous position value", 0
      3  2c9f				  -	      ERR
      4  2c9f					      ENDIF
      5  2c9f		       00		      .byte.b	0
      0  2ca0					      EVAL8	0
      1  2ca0				  -	      IF	(0 > 127) || (0 < -128)
      2  2ca0				  -	      ECHO	"Erroneous position value", 0
      3  2ca0				  -	      ERR
      4  2ca0					      ENDIF
      5  2ca0		       00		      .byte.b	0
      0  2ca1					      EVAL8	30
      1  2ca1				  -	      IF	(30 > 127) || (30 < -128)
      2  2ca1				  -	      ECHO	"Erroneous position value", 30
      3  2ca1				  -	      ERR
      4  2ca1					      ENDIF
      5  2ca1		       1e		      .byte.b	30
      0  2ca2					      EVAL8	-20
      1  2ca2				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2ca2				  -	      ECHO	"Erroneous position value", -20
      3  2ca2				  -	      ERR
      4  2ca2					      ENDIF
      5  2ca2		       ec		      .byte.b	-20
      0  2ca3					      EVAL8	-40
      1  2ca3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2ca3				  -	      ECHO	"Erroneous position value", -40
      3  2ca3				  -	      ERR
      4  2ca3					      ENDIF
      5  2ca3		       d8		      .byte.b	-40
      0  2ca4					      EVAL8	0
      1  2ca4				  -	      IF	(0 > 127) || (0 < -128)
      2  2ca4				  -	      ECHO	"Erroneous position value", 0
      3  2ca4				  -	      ERR
      4  2ca4					      ENDIF
      5  2ca4		       00		      .byte.b	0
      0  2ca5					      EVAL8	0
      1  2ca5				  -	      IF	(0 > 127) || (0 < -128)
      2  2ca5				  -	      ECHO	"Erroneous position value", 0
      3  2ca5				  -	      ERR
      4  2ca5					      ENDIF
      5  2ca5		       00		      .byte.b	0
      0  2ca6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      0  2ca6					      EVAL8	-50
      1  2ca6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2ca6				  -	      ECHO	"Erroneous position value", -50
      3  2ca6				  -	      ERR
      4  2ca6					      ENDIF
      5  2ca6		       ce		      .byte.b	-50
      0  2ca7					      EVAL8	-20
      1  2ca7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2ca7				  -	      ECHO	"Erroneous position value", -20
      3  2ca7				  -	      ERR
      4  2ca7					      ENDIF
      5  2ca7		       ec		      .byte.b	-20
      0  2ca8					      EVAL8	-30
      1  2ca8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2ca8				  -	      ECHO	"Erroneous position value", -30
      3  2ca8				  -	      ERR
      4  2ca8					      ENDIF
      5  2ca8		       e2		      .byte.b	-30
      0  2ca9					      EVAL8	-30
      1  2ca9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2ca9				  -	      ECHO	"Erroneous position value", -30
      3  2ca9				  -	      ERR
      4  2ca9					      ENDIF
      5  2ca9		       e2		      .byte.b	-30
      0  2caa					      EVAL8	-30
      1  2caa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2caa				  -	      ECHO	"Erroneous position value", -30
      3  2caa				  -	      ERR
      4  2caa					      ENDIF
      5  2caa		       e2		      .byte.b	-30
      0  2cab					      EVAL8	-30
      1  2cab				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2cab				  -	      ECHO	"Erroneous position value", -30
      3  2cab				  -	      ERR
      4  2cab					      ENDIF
      5  2cab		       e2		      .byte.b	-30
      0  2cac					      EVAL8	-20
      1  2cac				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2cac				  -	      ECHO	"Erroneous position value", -20
      3  2cac				  -	      ERR
      4  2cac					      ENDIF
      5  2cac		       ec		      .byte.b	-20
      0  2cad					      EVAL8	-50
      1  2cad				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2cad				  -	      ECHO	"Erroneous position value", -50
      3  2cad				  -	      ERR
      4  2cad					      ENDIF
      5  2cad		       ce		      .byte.b	-50
      0  2cae					      EVAL8	0
      1  2cae				  -	      IF	(0 > 127) || (0 < -128)
      2  2cae				  -	      ECHO	"Erroneous position value", 0
      3  2cae				  -	      ERR
      4  2cae					      ENDIF
      5  2cae		       00		      .byte.b	0
      0  2caf					      EVAL8	0
      1  2caf				  -	      IF	(0 > 127) || (0 < -128)
      2  2caf				  -	      ECHO	"Erroneous position value", 0
      3  2caf				  -	      ERR
      4  2caf					      ENDIF
      5  2caf		       00		      .byte.b	0
     85  2cb0
     86  2cb0
     87  2cb0							;---------------------------------------------------------------------------------------------------
     88  2cb0
     89  2cb0				   PositionalValue_BISHOP
     90  2cb0
      0  2cb0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      0  2cb0					      EVAL8	-20
      1  2cb0				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2cb0				  -	      ECHO	"Erroneous position value", -20
      3  2cb0				  -	      ERR
      4  2cb0					      ENDIF
      5  2cb0		       ec		      .byte.b	-20
      0  2cb1					      EVAL8	-10
      1  2cb1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cb1				  -	      ECHO	"Erroneous position value", -10
      3  2cb1				  -	      ERR
      4  2cb1					      ENDIF
      5  2cb1		       f6		      .byte.b	-10
      0  2cb2					      EVAL8	-50
      1  2cb2				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2cb2				  -	      ECHO	"Erroneous position value", -50
      3  2cb2				  -	      ERR
      4  2cb2					      ENDIF
      5  2cb2		       ce		      .byte.b	-50
      0  2cb3					      EVAL8	-10
      1  2cb3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cb3				  -	      ECHO	"Erroneous position value", -10
      3  2cb3				  -	      ERR
      4  2cb3					      ENDIF
      5  2cb3		       f6		      .byte.b	-10
      0  2cb4					      EVAL8	-10
      1  2cb4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cb4				  -	      ECHO	"Erroneous position value", -10
      3  2cb4				  -	      ERR
      4  2cb4					      ENDIF
      5  2cb4		       f6		      .byte.b	-10
      0  2cb5					      EVAL8	-50
      1  2cb5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2cb5				  -	      ECHO	"Erroneous position value", -50
      3  2cb5				  -	      ERR
      4  2cb5					      ENDIF
      5  2cb5		       ce		      .byte.b	-50
      0  2cb6					      EVAL8	-10
      1  2cb6				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cb6				  -	      ECHO	"Erroneous position value", -10
      3  2cb6				  -	      ERR
      4  2cb6					      ENDIF
      5  2cb6		       f6		      .byte.b	-10
      0  2cb7					      EVAL8	-20
      1  2cb7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2cb7				  -	      ECHO	"Erroneous position value", -20
      3  2cb7				  -	      ERR
      4  2cb7					      ENDIF
      5  2cb7		       ec		      .byte.b	-20
      0  2cb8					      EVAL8	0
      1  2cb8				  -	      IF	(0 > 127) || (0 < -128)
      2  2cb8				  -	      ECHO	"Erroneous position value", 0
      3  2cb8				  -	      ERR
      4  2cb8					      ENDIF
      5  2cb8		       00		      .byte.b	0
      0  2cb9					      EVAL8	0
      1  2cb9				  -	      IF	(0 > 127) || (0 < -128)
      2  2cb9				  -	      ECHO	"Erroneous position value", 0
      3  2cb9				  -	      ERR
      4  2cb9					      ENDIF
      5  2cb9		       00		      .byte.b	0
      0  2cba					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      0  2cba					      EVAL8	-10
      1  2cba				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cba				  -	      ECHO	"Erroneous position value", -10
      3  2cba				  -	      ERR
      4  2cba					      ENDIF
      5  2cba		       f6		      .byte.b	-10
      0  2cbb					      EVAL8	5
      1  2cbb				  -	      IF	(5 > 127) || (5 < -128)
      2  2cbb				  -	      ECHO	"Erroneous position value", 5
      3  2cbb				  -	      ERR
      4  2cbb					      ENDIF
      5  2cbb		       05		      .byte.b	5
      0  2cbc					      EVAL8	0
      1  2cbc				  -	      IF	(0 > 127) || (0 < -128)
      2  2cbc				  -	      ECHO	"Erroneous position value", 0
      3  2cbc				  -	      ERR
      4  2cbc					      ENDIF
      5  2cbc		       00		      .byte.b	0
      0  2cbd					      EVAL8	0
      1  2cbd				  -	      IF	(0 > 127) || (0 < -128)
      2  2cbd				  -	      ECHO	"Erroneous position value", 0
      3  2cbd				  -	      ERR
      4  2cbd					      ENDIF
      5  2cbd		       00		      .byte.b	0
      0  2cbe					      EVAL8	0
      1  2cbe				  -	      IF	(0 > 127) || (0 < -128)
      2  2cbe				  -	      ECHO	"Erroneous position value", 0
      3  2cbe				  -	      ERR
      4  2cbe					      ENDIF
      5  2cbe		       00		      .byte.b	0
      0  2cbf					      EVAL8	0
      1  2cbf				  -	      IF	(0 > 127) || (0 < -128)
      2  2cbf				  -	      ECHO	"Erroneous position value", 0
      3  2cbf				  -	      ERR
      4  2cbf					      ENDIF
      5  2cbf		       00		      .byte.b	0
      0  2cc0					      EVAL8	5
      1  2cc0				  -	      IF	(5 > 127) || (5 < -128)
      2  2cc0				  -	      ECHO	"Erroneous position value", 5
      3  2cc0				  -	      ERR
      4  2cc0					      ENDIF
      5  2cc0		       05		      .byte.b	5
      0  2cc1					      EVAL8	-10
      1  2cc1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cc1				  -	      ECHO	"Erroneous position value", -10
      3  2cc1				  -	      ERR
      4  2cc1					      ENDIF
      5  2cc1		       f6		      .byte.b	-10
      0  2cc2					      EVAL8	0
      1  2cc2				  -	      IF	(0 > 127) || (0 < -128)
      2  2cc2				  -	      ECHO	"Erroneous position value", 0
      3  2cc2				  -	      ERR
      4  2cc2					      ENDIF
      5  2cc2		       00		      .byte.b	0
      0  2cc3					      EVAL8	0
      1  2cc3				  -	      IF	(0 > 127) || (0 < -128)
      2  2cc3				  -	      ECHO	"Erroneous position value", 0
      3  2cc3				  -	      ERR
      4  2cc3					      ENDIF
      5  2cc3		       00		      .byte.b	0
      0  2cc4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      0  2cc4					      EVAL8	-10
      1  2cc4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cc4				  -	      ECHO	"Erroneous position value", -10
      3  2cc4				  -	      ERR
      4  2cc4					      ENDIF
      5  2cc4		       f6		      .byte.b	-10
      0  2cc5					      EVAL8	10
      1  2cc5				  -	      IF	(10 > 127) || (10 < -128)
      2  2cc5				  -	      ECHO	"Erroneous position value", 10
      3  2cc5				  -	      ERR
      4  2cc5					      ENDIF
      5  2cc5		       0a		      .byte.b	10
      0  2cc6					      EVAL8	10
      1  2cc6				  -	      IF	(10 > 127) || (10 < -128)
      2  2cc6				  -	      ECHO	"Erroneous position value", 10
      3  2cc6				  -	      ERR
      4  2cc6					      ENDIF
      5  2cc6		       0a		      .byte.b	10
      0  2cc7					      EVAL8	10
      1  2cc7				  -	      IF	(10 > 127) || (10 < -128)
      2  2cc7				  -	      ECHO	"Erroneous position value", 10
      3  2cc7				  -	      ERR
      4  2cc7					      ENDIF
      5  2cc7		       0a		      .byte.b	10
      0  2cc8					      EVAL8	10
      1  2cc8				  -	      IF	(10 > 127) || (10 < -128)
      2  2cc8				  -	      ECHO	"Erroneous position value", 10
      3  2cc8				  -	      ERR
      4  2cc8					      ENDIF
      5  2cc8		       0a		      .byte.b	10
      0  2cc9					      EVAL8	10
      1  2cc9				  -	      IF	(10 > 127) || (10 < -128)
      2  2cc9				  -	      ECHO	"Erroneous position value", 10
      3  2cc9				  -	      ERR
      4  2cc9					      ENDIF
      5  2cc9		       0a		      .byte.b	10
      0  2cca					      EVAL8	10
      1  2cca				  -	      IF	(10 > 127) || (10 < -128)
      2  2cca				  -	      ECHO	"Erroneous position value", 10
      3  2cca				  -	      ERR
      4  2cca					      ENDIF
      5  2cca		       0a		      .byte.b	10
      0  2ccb					      EVAL8	-10
      1  2ccb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2ccb				  -	      ECHO	"Erroneous position value", -10
      3  2ccb				  -	      ERR
      4  2ccb					      ENDIF
      5  2ccb		       f6		      .byte.b	-10
      0  2ccc					      EVAL8	0
      1  2ccc				  -	      IF	(0 > 127) || (0 < -128)
      2  2ccc				  -	      ECHO	"Erroneous position value", 0
      3  2ccc				  -	      ERR
      4  2ccc					      ENDIF
      5  2ccc		       00		      .byte.b	0
      0  2ccd					      EVAL8	0
      1  2ccd				  -	      IF	(0 > 127) || (0 < -128)
      2  2ccd				  -	      ECHO	"Erroneous position value", 0
      3  2ccd				  -	      ERR
      4  2ccd					      ENDIF
      5  2ccd		       00		      .byte.b	0
      0  2cce					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      0  2cce					      EVAL8	-10
      1  2cce				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cce				  -	      ECHO	"Erroneous position value", -10
      3  2cce				  -	      ERR
      4  2cce					      ENDIF
      5  2cce		       f6		      .byte.b	-10
      0  2ccf					      EVAL8	0
      1  2ccf				  -	      IF	(0 > 127) || (0 < -128)
      2  2ccf				  -	      ECHO	"Erroneous position value", 0
      3  2ccf				  -	      ERR
      4  2ccf					      ENDIF
      5  2ccf		       00		      .byte.b	0
      0  2cd0					      EVAL8	10
      1  2cd0				  -	      IF	(10 > 127) || (10 < -128)
      2  2cd0				  -	      ECHO	"Erroneous position value", 10
      3  2cd0				  -	      ERR
      4  2cd0					      ENDIF
      5  2cd0		       0a		      .byte.b	10
      0  2cd1					      EVAL8	20
      1  2cd1				  -	      IF	(20 > 127) || (20 < -128)
      2  2cd1				  -	      ECHO	"Erroneous position value", 20
      3  2cd1				  -	      ERR
      4  2cd1					      ENDIF
      5  2cd1		       14		      .byte.b	20
      0  2cd2					      EVAL8	20
      1  2cd2				  -	      IF	(20 > 127) || (20 < -128)
      2  2cd2				  -	      ECHO	"Erroneous position value", 20
      3  2cd2				  -	      ERR
      4  2cd2					      ENDIF
      5  2cd2		       14		      .byte.b	20
      0  2cd3					      EVAL8	10
      1  2cd3				  -	      IF	(10 > 127) || (10 < -128)
      2  2cd3				  -	      ECHO	"Erroneous position value", 10
      3  2cd3				  -	      ERR
      4  2cd3					      ENDIF
      5  2cd3		       0a		      .byte.b	10
      0  2cd4					      EVAL8	0
      1  2cd4				  -	      IF	(0 > 127) || (0 < -128)
      2  2cd4				  -	      ECHO	"Erroneous position value", 0
      3  2cd4				  -	      ERR
      4  2cd4					      ENDIF
      5  2cd4		       00		      .byte.b	0
      0  2cd5					      EVAL8	-10
      1  2cd5				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cd5				  -	      ECHO	"Erroneous position value", -10
      3  2cd5				  -	      ERR
      4  2cd5					      ENDIF
      5  2cd5		       f6		      .byte.b	-10
      0  2cd6					      EVAL8	0
      1  2cd6				  -	      IF	(0 > 127) || (0 < -128)
      2  2cd6				  -	      ECHO	"Erroneous position value", 0
      3  2cd6				  -	      ERR
      4  2cd6					      ENDIF
      5  2cd6		       00		      .byte.b	0
      0  2cd7					      EVAL8	0
      1  2cd7				  -	      IF	(0 > 127) || (0 < -128)
      2  2cd7				  -	      ECHO	"Erroneous position value", 0
      3  2cd7				  -	      ERR
      4  2cd7					      ENDIF
      5  2cd7		       00		      .byte.b	0
      0  2cd8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      0  2cd8					      EVAL8	-10
      1  2cd8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cd8				  -	      ECHO	"Erroneous position value", -10
      3  2cd8				  -	      ERR
      4  2cd8					      ENDIF
      5  2cd8		       f6		      .byte.b	-10
      0  2cd9					      EVAL8	5
      1  2cd9				  -	      IF	(5 > 127) || (5 < -128)
      2  2cd9				  -	      ECHO	"Erroneous position value", 5
      3  2cd9				  -	      ERR
      4  2cd9					      ENDIF
      5  2cd9		       05		      .byte.b	5
      0  2cda					      EVAL8	5
      1  2cda				  -	      IF	(5 > 127) || (5 < -128)
      2  2cda				  -	      ECHO	"Erroneous position value", 5
      3  2cda				  -	      ERR
      4  2cda					      ENDIF
      5  2cda		       05		      .byte.b	5
      0  2cdb					      EVAL8	20
      1  2cdb				  -	      IF	(20 > 127) || (20 < -128)
      2  2cdb				  -	      ECHO	"Erroneous position value", 20
      3  2cdb				  -	      ERR
      4  2cdb					      ENDIF
      5  2cdb		       14		      .byte.b	20
      0  2cdc					      EVAL8	20
      1  2cdc				  -	      IF	(20 > 127) || (20 < -128)
      2  2cdc				  -	      ECHO	"Erroneous position value", 20
      3  2cdc				  -	      ERR
      4  2cdc					      ENDIF
      5  2cdc		       14		      .byte.b	20
      0  2cdd					      EVAL8	5
      1  2cdd				  -	      IF	(5 > 127) || (5 < -128)
      2  2cdd				  -	      ECHO	"Erroneous position value", 5
      3  2cdd				  -	      ERR
      4  2cdd					      ENDIF
      5  2cdd		       05		      .byte.b	5
      0  2cde					      EVAL8	5
      1  2cde				  -	      IF	(5 > 127) || (5 < -128)
      2  2cde				  -	      ECHO	"Erroneous position value", 5
      3  2cde				  -	      ERR
      4  2cde					      ENDIF
      5  2cde		       05		      .byte.b	5
      0  2cdf					      EVAL8	-10
      1  2cdf				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cdf				  -	      ECHO	"Erroneous position value", -10
      3  2cdf				  -	      ERR
      4  2cdf					      ENDIF
      5  2cdf		       f6		      .byte.b	-10
      0  2ce0					      EVAL8	0
      1  2ce0				  -	      IF	(0 > 127) || (0 < -128)
      2  2ce0				  -	      ECHO	"Erroneous position value", 0
      3  2ce0				  -	      ERR
      4  2ce0					      ENDIF
      5  2ce0		       00		      .byte.b	0
      0  2ce1					      EVAL8	0
      1  2ce1				  -	      IF	(0 > 127) || (0 < -128)
      2  2ce1				  -	      ECHO	"Erroneous position value", 0
      3  2ce1				  -	      ERR
      4  2ce1					      ENDIF
      5  2ce1		       00		      .byte.b	0
      0  2ce2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      0  2ce2					      EVAL8	-10
      1  2ce2				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2ce2				  -	      ECHO	"Erroneous position value", -10
      3  2ce2				  -	      ERR
      4  2ce2					      ENDIF
      5  2ce2		       f6		      .byte.b	-10
      0  2ce3					      EVAL8	0
      1  2ce3				  -	      IF	(0 > 127) || (0 < -128)
      2  2ce3				  -	      ECHO	"Erroneous position value", 0
      3  2ce3				  -	      ERR
      4  2ce3					      ENDIF
      5  2ce3		       00		      .byte.b	0
      0  2ce4					      EVAL8	5
      1  2ce4				  -	      IF	(5 > 127) || (5 < -128)
      2  2ce4				  -	      ECHO	"Erroneous position value", 5
      3  2ce4				  -	      ERR
      4  2ce4					      ENDIF
      5  2ce4		       05		      .byte.b	5
      0  2ce5					      EVAL8	10
      1  2ce5				  -	      IF	(10 > 127) || (10 < -128)
      2  2ce5				  -	      ECHO	"Erroneous position value", 10
      3  2ce5				  -	      ERR
      4  2ce5					      ENDIF
      5  2ce5		       0a		      .byte.b	10
      0  2ce6					      EVAL8	10
      1  2ce6				  -	      IF	(10 > 127) || (10 < -128)
      2  2ce6				  -	      ECHO	"Erroneous position value", 10
      3  2ce6				  -	      ERR
      4  2ce6					      ENDIF
      5  2ce6		       0a		      .byte.b	10
      0  2ce7					      EVAL8	5
      1  2ce7				  -	      IF	(5 > 127) || (5 < -128)
      2  2ce7				  -	      ECHO	"Erroneous position value", 5
      3  2ce7				  -	      ERR
      4  2ce7					      ENDIF
      5  2ce7		       05		      .byte.b	5
      0  2ce8					      EVAL8	0
      1  2ce8				  -	      IF	(0 > 127) || (0 < -128)
      2  2ce8				  -	      ECHO	"Erroneous position value", 0
      3  2ce8				  -	      ERR
      4  2ce8					      ENDIF
      5  2ce8		       00		      .byte.b	0
      0  2ce9					      EVAL8	-10
      1  2ce9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2ce9				  -	      ECHO	"Erroneous position value", -10
      3  2ce9				  -	      ERR
      4  2ce9					      ENDIF
      5  2ce9		       f6		      .byte.b	-10
      0  2cea					      EVAL8	0
      1  2cea				  -	      IF	(0 > 127) || (0 < -128)
      2  2cea				  -	      ECHO	"Erroneous position value", 0
      3  2cea				  -	      ERR
      4  2cea					      ENDIF
      5  2cea		       00		      .byte.b	0
      0  2ceb					      EVAL8	0
      1  2ceb				  -	      IF	(0 > 127) || (0 < -128)
      2  2ceb				  -	      ECHO	"Erroneous position value", 0
      3  2ceb				  -	      ERR
      4  2ceb					      ENDIF
      5  2ceb		       00		      .byte.b	0
      0  2cec					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  2cec					      EVAL8	-10
      1  2cec				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cec				  -	      ECHO	"Erroneous position value", -10
      3  2cec				  -	      ERR
      4  2cec					      ENDIF
      5  2cec		       f6		      .byte.b	-10
      0  2ced					      EVAL8	0
      1  2ced				  -	      IF	(0 > 127) || (0 < -128)
      2  2ced				  -	      ECHO	"Erroneous position value", 0
      3  2ced				  -	      ERR
      4  2ced					      ENDIF
      5  2ced		       00		      .byte.b	0
      0  2cee					      EVAL8	0
      1  2cee				  -	      IF	(0 > 127) || (0 < -128)
      2  2cee				  -	      ECHO	"Erroneous position value", 0
      3  2cee				  -	      ERR
      4  2cee					      ENDIF
      5  2cee		       00		      .byte.b	0
      0  2cef					      EVAL8	0
      1  2cef				  -	      IF	(0 > 127) || (0 < -128)
      2  2cef				  -	      ECHO	"Erroneous position value", 0
      3  2cef				  -	      ERR
      4  2cef					      ENDIF
      5  2cef		       00		      .byte.b	0
      0  2cf0					      EVAL8	0
      1  2cf0				  -	      IF	(0 > 127) || (0 < -128)
      2  2cf0				  -	      ECHO	"Erroneous position value", 0
      3  2cf0				  -	      ERR
      4  2cf0					      ENDIF
      5  2cf0		       00		      .byte.b	0
      0  2cf1					      EVAL8	0
      1  2cf1				  -	      IF	(0 > 127) || (0 < -128)
      2  2cf1				  -	      ECHO	"Erroneous position value", 0
      3  2cf1				  -	      ERR
      4  2cf1					      ENDIF
      5  2cf1		       00		      .byte.b	0
      0  2cf2					      EVAL8	0
      1  2cf2				  -	      IF	(0 > 127) || (0 < -128)
      2  2cf2				  -	      ECHO	"Erroneous position value", 0
      3  2cf2				  -	      ERR
      4  2cf2					      ENDIF
      5  2cf2		       00		      .byte.b	0
      0  2cf3					      EVAL8	-10
      1  2cf3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cf3				  -	      ECHO	"Erroneous position value", -10
      3  2cf3				  -	      ERR
      4  2cf3					      ENDIF
      5  2cf3		       f6		      .byte.b	-10
      0  2cf4					      EVAL8	0
      1  2cf4				  -	      IF	(0 > 127) || (0 < -128)
      2  2cf4				  -	      ECHO	"Erroneous position value", 0
      3  2cf4				  -	      ERR
      4  2cf4					      ENDIF
      5  2cf4		       00		      .byte.b	0
      0  2cf5					      EVAL8	0
      1  2cf5				  -	      IF	(0 > 127) || (0 < -128)
      2  2cf5				  -	      ECHO	"Erroneous position value", 0
      3  2cf5				  -	      ERR
      4  2cf5					      ENDIF
      5  2cf5		       00		      .byte.b	0
      0  2cf6					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      0  2cf6					      EVAL8	-20
      1  2cf6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2cf6				  -	      ECHO	"Erroneous position value", -20
      3  2cf6				  -	      ERR
      4  2cf6					      ENDIF
      5  2cf6		       ec		      .byte.b	-20
      0  2cf7					      EVAL8	-10
      1  2cf7				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cf7				  -	      ECHO	"Erroneous position value", -10
      3  2cf7				  -	      ERR
      4  2cf7					      ENDIF
      5  2cf7		       f6		      .byte.b	-10
      0  2cf8					      EVAL8	-10
      1  2cf8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cf8				  -	      ECHO	"Erroneous position value", -10
      3  2cf8				  -	      ERR
      4  2cf8					      ENDIF
      5  2cf8		       f6		      .byte.b	-10
      0  2cf9					      EVAL8	-10
      1  2cf9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cf9				  -	      ECHO	"Erroneous position value", -10
      3  2cf9				  -	      ERR
      4  2cf9					      ENDIF
      5  2cf9		       f6		      .byte.b	-10
      0  2cfa					      EVAL8	-10
      1  2cfa				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cfa				  -	      ECHO	"Erroneous position value", -10
      3  2cfa				  -	      ERR
      4  2cfa					      ENDIF
      5  2cfa		       f6		      .byte.b	-10
      0  2cfb					      EVAL8	-10
      1  2cfb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cfb				  -	      ECHO	"Erroneous position value", -10
      3  2cfb				  -	      ERR
      4  2cfb					      ENDIF
      5  2cfb		       f6		      .byte.b	-10
      0  2cfc					      EVAL8	-10
      1  2cfc				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2cfc				  -	      ECHO	"Erroneous position value", -10
      3  2cfc				  -	      ERR
      4  2cfc					      ENDIF
      5  2cfc		       f6		      .byte.b	-10
      0  2cfd					      EVAL8	-20
      1  2cfd				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2cfd				  -	      ECHO	"Erroneous position value", -20
      3  2cfd				  -	      ERR
      4  2cfd					      ENDIF
      5  2cfd		       ec		      .byte.b	-20
      0  2cfe					      EVAL8	0
      1  2cfe				  -	      IF	(0 > 127) || (0 < -128)
      2  2cfe				  -	      ECHO	"Erroneous position value", 0
      3  2cfe				  -	      ERR
      4  2cfe					      ENDIF
      5  2cfe		       00		      .byte.b	0
      0  2cff					      EVAL8	0
      1  2cff				  -	      IF	(0 > 127) || (0 < -128)
      2  2cff				  -	      ECHO	"Erroneous position value", 0
      3  2cff				  -	      ERR
      4  2cff					      ENDIF
      5  2cff		       00		      .byte.b	0
     99  2d00
    100  2d00
    101  2d00							;---------------------------------------------------------------------------------------------------
    102  2d00
    103  2d00				   PositionalValue_ROOK
    104  2d00
      0  2d00					      PVAL	-25, -20, 10, 0, 55, 0, -20, -25
      0  2d00					      EVAL8	-25
      1  2d00				  -	      IF	(-25 > 127) || (-25 < -128)
      2  2d00				  -	      ECHO	"Erroneous position value", -25
      3  2d00				  -	      ERR
      4  2d00					      ENDIF
      5  2d00		       e7		      .byte.b	-25
      0  2d01					      EVAL8	-20
      1  2d01				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2d01				  -	      ECHO	"Erroneous position value", -20
      3  2d01				  -	      ERR
      4  2d01					      ENDIF
      5  2d01		       ec		      .byte.b	-20
      0  2d02					      EVAL8	10
      1  2d02				  -	      IF	(10 > 127) || (10 < -128)
      2  2d02				  -	      ECHO	"Erroneous position value", 10
      3  2d02				  -	      ERR
      4  2d02					      ENDIF
      5  2d02		       0a		      .byte.b	10
      0  2d03					      EVAL8	0
      1  2d03				  -	      IF	(0 > 127) || (0 < -128)
      2  2d03				  -	      ECHO	"Erroneous position value", 0
      3  2d03				  -	      ERR
      4  2d03					      ENDIF
      5  2d03		       00		      .byte.b	0
      0  2d04					      EVAL8	55
      1  2d04				  -	      IF	(55 > 127) || (55 < -128)
      2  2d04				  -	      ECHO	"Erroneous position value", 55
      3  2d04				  -	      ERR
      4  2d04					      ENDIF
      5  2d04		       37		      .byte.b	55
      0  2d05					      EVAL8	0
      1  2d05				  -	      IF	(0 > 127) || (0 < -128)
      2  2d05				  -	      ECHO	"Erroneous position value", 0
      3  2d05				  -	      ERR
      4  2d05					      ENDIF
      5  2d05		       00		      .byte.b	0
      0  2d06					      EVAL8	-20
      1  2d06				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2d06				  -	      ECHO	"Erroneous position value", -20
      3  2d06				  -	      ERR
      4  2d06					      ENDIF
      5  2d06		       ec		      .byte.b	-20
      0  2d07					      EVAL8	-25
      1  2d07				  -	      IF	(-25 > 127) || (-25 < -128)
      2  2d07				  -	      ECHO	"Erroneous position value", -25
      3  2d07				  -	      ERR
      4  2d07					      ENDIF
      5  2d07		       e7		      .byte.b	-25
      0  2d08					      EVAL8	0
      1  2d08				  -	      IF	(0 > 127) || (0 < -128)
      2  2d08				  -	      ECHO	"Erroneous position value", 0
      3  2d08				  -	      ERR
      4  2d08					      ENDIF
      5  2d08		       00		      .byte.b	0
      0  2d09					      EVAL8	0
      1  2d09				  -	      IF	(0 > 127) || (0 < -128)
      2  2d09				  -	      ECHO	"Erroneous position value", 0
      3  2d09				  -	      ERR
      4  2d09					      ENDIF
      5  2d09		       00		      .byte.b	0
      0  2d0a					      PVAL	-120, 0, 0, 0, 0, 0, 0, -128
      0  2d0a					      EVAL8	-120
      1  2d0a				  -	      IF	(-120 > 127) || (-120 < -128)
      2  2d0a				  -	      ECHO	"Erroneous position value", -120
      3  2d0a				  -	      ERR
      4  2d0a					      ENDIF
      5  2d0a		       88		      .byte.b	-120
      0  2d0b					      EVAL8	0
      1  2d0b				  -	      IF	(0 > 127) || (0 < -128)
      2  2d0b				  -	      ECHO	"Erroneous position value", 0
      3  2d0b				  -	      ERR
      4  2d0b					      ENDIF
      5  2d0b		       00		      .byte.b	0
      0  2d0c					      EVAL8	0
      1  2d0c				  -	      IF	(0 > 127) || (0 < -128)
      2  2d0c				  -	      ECHO	"Erroneous position value", 0
      3  2d0c				  -	      ERR
      4  2d0c					      ENDIF
      5  2d0c		       00		      .byte.b	0
      0  2d0d					      EVAL8	0
      1  2d0d				  -	      IF	(0 > 127) || (0 < -128)
      2  2d0d				  -	      ECHO	"Erroneous position value", 0
      3  2d0d				  -	      ERR
      4  2d0d					      ENDIF
      5  2d0d		       00		      .byte.b	0
      0  2d0e					      EVAL8	0
      1  2d0e				  -	      IF	(0 > 127) || (0 < -128)
      2  2d0e				  -	      ECHO	"Erroneous position value", 0
      3  2d0e				  -	      ERR
      4  2d0e					      ENDIF
      5  2d0e		       00		      .byte.b	0
      0  2d0f					      EVAL8	0
      1  2d0f				  -	      IF	(0 > 127) || (0 < -128)
      2  2d0f				  -	      ECHO	"Erroneous position value", 0
      3  2d0f				  -	      ERR
      4  2d0f					      ENDIF
      5  2d0f		       00		      .byte.b	0
      0  2d10					      EVAL8	0
      1  2d10				  -	      IF	(0 > 127) || (0 < -128)
      2  2d10				  -	      ECHO	"Erroneous position value", 0
      3  2d10				  -	      ERR
      4  2d10					      ENDIF
      5  2d10		       00		      .byte.b	0
      0  2d11					      EVAL8	-128
      1  2d11				  -	      IF	(-128 > 127) || (-128 < -128)
      2  2d11				  -	      ECHO	"Erroneous position value", -128
      3  2d11				  -	      ERR
      4  2d11					      ENDIF
      5  2d11		       80		      .byte.b	-128
      0  2d12					      EVAL8	0
      1  2d12				  -	      IF	(0 > 127) || (0 < -128)
      2  2d12				  -	      ECHO	"Erroneous position value", 0
      3  2d12				  -	      ERR
      4  2d12					      ENDIF
      5  2d12		       00		      .byte.b	0
      0  2d13					      EVAL8	0
      1  2d13				  -	      IF	(0 > 127) || (0 < -128)
      2  2d13				  -	      ECHO	"Erroneous position value", 0
      3  2d13				  -	      ERR
      4  2d13					      ENDIF
      5  2d13		       00		      .byte.b	0
      0  2d14					      PVAL	-128, 0, 0, 0, 0, 0, 0, -100
      0  2d14					      EVAL8	-128
      1  2d14				  -	      IF	(-128 > 127) || (-128 < -128)
      2  2d14				  -	      ECHO	"Erroneous position value", -128
      3  2d14				  -	      ERR
      4  2d14					      ENDIF
      5  2d14		       80		      .byte.b	-128
      0  2d15					      EVAL8	0
      1  2d15				  -	      IF	(0 > 127) || (0 < -128)
      2  2d15				  -	      ECHO	"Erroneous position value", 0
      3  2d15				  -	      ERR
      4  2d15					      ENDIF
      5  2d15		       00		      .byte.b	0
      0  2d16					      EVAL8	0
      1  2d16				  -	      IF	(0 > 127) || (0 < -128)
      2  2d16				  -	      ECHO	"Erroneous position value", 0
      3  2d16				  -	      ERR
      4  2d16					      ENDIF
      5  2d16		       00		      .byte.b	0
      0  2d17					      EVAL8	0
      1  2d17				  -	      IF	(0 > 127) || (0 < -128)
      2  2d17				  -	      ECHO	"Erroneous position value", 0
      3  2d17				  -	      ERR
      4  2d17					      ENDIF
      5  2d17		       00		      .byte.b	0
      0  2d18					      EVAL8	0
      1  2d18				  -	      IF	(0 > 127) || (0 < -128)
      2  2d18				  -	      ECHO	"Erroneous position value", 0
      3  2d18				  -	      ERR
      4  2d18					      ENDIF
      5  2d18		       00		      .byte.b	0
      0  2d19					      EVAL8	0
      1  2d19				  -	      IF	(0 > 127) || (0 < -128)
      2  2d19				  -	      ECHO	"Erroneous position value", 0
      3  2d19				  -	      ERR
      4  2d19					      ENDIF
      5  2d19		       00		      .byte.b	0
      0  2d1a					      EVAL8	0
      1  2d1a				  -	      IF	(0 > 127) || (0 < -128)
      2  2d1a				  -	      ECHO	"Erroneous position value", 0
      3  2d1a				  -	      ERR
      4  2d1a					      ENDIF
      5  2d1a		       00		      .byte.b	0
      0  2d1b					      EVAL8	-100
      1  2d1b				  -	      IF	(-100 > 127) || (-100 < -128)
      2  2d1b				  -	      ECHO	"Erroneous position value", -100
      3  2d1b				  -	      ERR
      4  2d1b					      ENDIF
      5  2d1b		       9c		      .byte.b	-100
      0  2d1c					      EVAL8	0
      1  2d1c				  -	      IF	(0 > 127) || (0 < -128)
      2  2d1c				  -	      ECHO	"Erroneous position value", 0
      3  2d1c				  -	      ERR
      4  2d1c					      ENDIF
      5  2d1c		       00		      .byte.b	0
      0  2d1d					      EVAL8	0
      1  2d1d				  -	      IF	(0 > 127) || (0 < -128)
      2  2d1d				  -	      ECHO	"Erroneous position value", 0
      3  2d1d				  -	      ERR
      4  2d1d					      ENDIF
      5  2d1d		       00		      .byte.b	0
      0  2d1e					      PVAL	-100, 0, 0, 0, 0, 0, 0, -100
      0  2d1e					      EVAL8	-100
      1  2d1e				  -	      IF	(-100 > 127) || (-100 < -128)
      2  2d1e				  -	      ECHO	"Erroneous position value", -100
      3  2d1e				  -	      ERR
      4  2d1e					      ENDIF
      5  2d1e		       9c		      .byte.b	-100
      0  2d1f					      EVAL8	0
      1  2d1f				  -	      IF	(0 > 127) || (0 < -128)
      2  2d1f				  -	      ECHO	"Erroneous position value", 0
      3  2d1f				  -	      ERR
      4  2d1f					      ENDIF
      5  2d1f		       00		      .byte.b	0
      0  2d20					      EVAL8	0
      1  2d20				  -	      IF	(0 > 127) || (0 < -128)
      2  2d20				  -	      ECHO	"Erroneous position value", 0
      3  2d20				  -	      ERR
      4  2d20					      ENDIF
      5  2d20		       00		      .byte.b	0
      0  2d21					      EVAL8	0
      1  2d21				  -	      IF	(0 > 127) || (0 < -128)
      2  2d21				  -	      ECHO	"Erroneous position value", 0
      3  2d21				  -	      ERR
      4  2d21					      ENDIF
      5  2d21		       00		      .byte.b	0
      0  2d22					      EVAL8	0
      1  2d22				  -	      IF	(0 > 127) || (0 < -128)
      2  2d22				  -	      ECHO	"Erroneous position value", 0
      3  2d22				  -	      ERR
      4  2d22					      ENDIF
      5  2d22		       00		      .byte.b	0
      0  2d23					      EVAL8	0
      1  2d23				  -	      IF	(0 > 127) || (0 < -128)
      2  2d23				  -	      ECHO	"Erroneous position value", 0
      3  2d23				  -	      ERR
      4  2d23					      ENDIF
      5  2d23		       00		      .byte.b	0
      0  2d24					      EVAL8	0
      1  2d24				  -	      IF	(0 > 127) || (0 < -128)
      2  2d24				  -	      ECHO	"Erroneous position value", 0
      3  2d24				  -	      ERR
      4  2d24					      ENDIF
      5  2d24		       00		      .byte.b	0
      0  2d25					      EVAL8	-100
      1  2d25				  -	      IF	(-100 > 127) || (-100 < -128)
      2  2d25				  -	      ECHO	"Erroneous position value", -100
      3  2d25				  -	      ERR
      4  2d25					      ENDIF
      5  2d25		       9c		      .byte.b	-100
      0  2d26					      EVAL8	0
      1  2d26				  -	      IF	(0 > 127) || (0 < -128)
      2  2d26				  -	      ECHO	"Erroneous position value", 0
      3  2d26				  -	      ERR
      4  2d26					      ENDIF
      5  2d26		       00		      .byte.b	0
      0  2d27					      EVAL8	0
      1  2d27				  -	      IF	(0 > 127) || (0 < -128)
      2  2d27				  -	      ECHO	"Erroneous position value", 0
      3  2d27				  -	      ERR
      4  2d27					      ENDIF
      5  2d27		       00		      .byte.b	0
      0  2d28					      PVAL	-50, 0, 0, 0, 0, 0, 0, -50
      0  2d28					      EVAL8	-50
      1  2d28				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2d28				  -	      ECHO	"Erroneous position value", -50
      3  2d28				  -	      ERR
      4  2d28					      ENDIF
      5  2d28		       ce		      .byte.b	-50
      0  2d29					      EVAL8	0
      1  2d29				  -	      IF	(0 > 127) || (0 < -128)
      2  2d29				  -	      ECHO	"Erroneous position value", 0
      3  2d29				  -	      ERR
      4  2d29					      ENDIF
      5  2d29		       00		      .byte.b	0
      0  2d2a					      EVAL8	0
      1  2d2a				  -	      IF	(0 > 127) || (0 < -128)
      2  2d2a				  -	      ECHO	"Erroneous position value", 0
      3  2d2a				  -	      ERR
      4  2d2a					      ENDIF
      5  2d2a		       00		      .byte.b	0
      0  2d2b					      EVAL8	0
      1  2d2b				  -	      IF	(0 > 127) || (0 < -128)
      2  2d2b				  -	      ECHO	"Erroneous position value", 0
      3  2d2b				  -	      ERR
      4  2d2b					      ENDIF
      5  2d2b		       00		      .byte.b	0
      0  2d2c					      EVAL8	0
      1  2d2c				  -	      IF	(0 > 127) || (0 < -128)
      2  2d2c				  -	      ECHO	"Erroneous position value", 0
      3  2d2c				  -	      ERR
      4  2d2c					      ENDIF
      5  2d2c		       00		      .byte.b	0
      0  2d2d					      EVAL8	0
      1  2d2d				  -	      IF	(0 > 127) || (0 < -128)
      2  2d2d				  -	      ECHO	"Erroneous position value", 0
      3  2d2d				  -	      ERR
      4  2d2d					      ENDIF
      5  2d2d		       00		      .byte.b	0
      0  2d2e					      EVAL8	0
      1  2d2e				  -	      IF	(0 > 127) || (0 < -128)
      2  2d2e				  -	      ECHO	"Erroneous position value", 0
      3  2d2e				  -	      ERR
      4  2d2e					      ENDIF
      5  2d2e		       00		      .byte.b	0
      0  2d2f					      EVAL8	-50
      1  2d2f				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2d2f				  -	      ECHO	"Erroneous position value", -50
      3  2d2f				  -	      ERR
      4  2d2f					      ENDIF
      5  2d2f		       ce		      .byte.b	-50
      0  2d30					      EVAL8	0
      1  2d30				  -	      IF	(0 > 127) || (0 < -128)
      2  2d30				  -	      ECHO	"Erroneous position value", 0
      3  2d30				  -	      ERR
      4  2d30					      ENDIF
      5  2d30		       00		      .byte.b	0
      0  2d31					      EVAL8	0
      1  2d31				  -	      IF	(0 > 127) || (0 < -128)
      2  2d31				  -	      ECHO	"Erroneous position value", 0
      3  2d31				  -	      ERR
      4  2d31					      ENDIF
      5  2d31		       00		      .byte.b	0
      0  2d32					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      0  2d32					      EVAL8	-5
      1  2d32				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2d32				  -	      ECHO	"Erroneous position value", -5
      3  2d32				  -	      ERR
      4  2d32					      ENDIF
      5  2d32		       fb		      .byte.b	-5
      0  2d33					      EVAL8	0
      1  2d33				  -	      IF	(0 > 127) || (0 < -128)
      2  2d33				  -	      ECHO	"Erroneous position value", 0
      3  2d33				  -	      ERR
      4  2d33					      ENDIF
      5  2d33		       00		      .byte.b	0
      0  2d34					      EVAL8	30
      1  2d34				  -	      IF	(30 > 127) || (30 < -128)
      2  2d34				  -	      ECHO	"Erroneous position value", 30
      3  2d34				  -	      ERR
      4  2d34					      ENDIF
      5  2d34		       1e		      .byte.b	30
      0  2d35					      EVAL8	30
      1  2d35				  -	      IF	(30 > 127) || (30 < -128)
      2  2d35				  -	      ECHO	"Erroneous position value", 30
      3  2d35				  -	      ERR
      4  2d35					      ENDIF
      5  2d35		       1e		      .byte.b	30
      0  2d36					      EVAL8	30
      1  2d36				  -	      IF	(30 > 127) || (30 < -128)
      2  2d36				  -	      ECHO	"Erroneous position value", 30
      3  2d36				  -	      ERR
      4  2d36					      ENDIF
      5  2d36		       1e		      .byte.b	30
      0  2d37					      EVAL8	30
      1  2d37				  -	      IF	(30 > 127) || (30 < -128)
      2  2d37				  -	      ECHO	"Erroneous position value", 30
      3  2d37				  -	      ERR
      4  2d37					      ENDIF
      5  2d37		       1e		      .byte.b	30
      0  2d38					      EVAL8	0
      1  2d38				  -	      IF	(0 > 127) || (0 < -128)
      2  2d38				  -	      ECHO	"Erroneous position value", 0
      3  2d38				  -	      ERR
      4  2d38					      ENDIF
      5  2d38		       00		      .byte.b	0
      0  2d39					      EVAL8	-5
      1  2d39				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2d39				  -	      ECHO	"Erroneous position value", -5
      3  2d39				  -	      ERR
      4  2d39					      ENDIF
      5  2d39		       fb		      .byte.b	-5
      0  2d3a					      EVAL8	0
      1  2d3a				  -	      IF	(0 > 127) || (0 < -128)
      2  2d3a				  -	      ECHO	"Erroneous position value", 0
      3  2d3a				  -	      ERR
      4  2d3a					      ENDIF
      5  2d3a		       00		      .byte.b	0
      0  2d3b					      EVAL8	0
      1  2d3b				  -	      IF	(0 > 127) || (0 < -128)
      2  2d3b				  -	      ECHO	"Erroneous position value", 0
      3  2d3b				  -	      ERR
      4  2d3b					      ENDIF
      5  2d3b		       00		      .byte.b	0
      0  2d3c					      PVAL	55, 80, 90, 90, 90, 90, 80, 55
      0  2d3c					      EVAL8	55
      1  2d3c				  -	      IF	(55 > 127) || (55 < -128)
      2  2d3c				  -	      ECHO	"Erroneous position value", 55
      3  2d3c				  -	      ERR
      4  2d3c					      ENDIF
      5  2d3c		       37		      .byte.b	55
      0  2d3d					      EVAL8	80
      1  2d3d				  -	      IF	(80 > 127) || (80 < -128)
      2  2d3d				  -	      ECHO	"Erroneous position value", 80
      3  2d3d				  -	      ERR
      4  2d3d					      ENDIF
      5  2d3d		       50		      .byte.b	80
      0  2d3e					      EVAL8	90
      1  2d3e				  -	      IF	(90 > 127) || (90 < -128)
      2  2d3e				  -	      ECHO	"Erroneous position value", 90
      3  2d3e				  -	      ERR
      4  2d3e					      ENDIF
      5  2d3e		       5a		      .byte.b	90
      0  2d3f					      EVAL8	90
      1  2d3f				  -	      IF	(90 > 127) || (90 < -128)
      2  2d3f				  -	      ECHO	"Erroneous position value", 90
      3  2d3f				  -	      ERR
      4  2d3f					      ENDIF
      5  2d3f		       5a		      .byte.b	90
      0  2d40					      EVAL8	90
      1  2d40				  -	      IF	(90 > 127) || (90 < -128)
      2  2d40				  -	      ECHO	"Erroneous position value", 90
      3  2d40				  -	      ERR
      4  2d40					      ENDIF
      5  2d40		       5a		      .byte.b	90
      0  2d41					      EVAL8	90
      1  2d41				  -	      IF	(90 > 127) || (90 < -128)
      2  2d41				  -	      ECHO	"Erroneous position value", 90
      3  2d41				  -	      ERR
      4  2d41					      ENDIF
      5  2d41		       5a		      .byte.b	90
      0  2d42					      EVAL8	80
      1  2d42				  -	      IF	(80 > 127) || (80 < -128)
      2  2d42				  -	      ECHO	"Erroneous position value", 80
      3  2d42				  -	      ERR
      4  2d42					      ENDIF
      5  2d42		       50		      .byte.b	80
      0  2d43					      EVAL8	55
      1  2d43				  -	      IF	(55 > 127) || (55 < -128)
      2  2d43				  -	      ECHO	"Erroneous position value", 55
      3  2d43				  -	      ERR
      4  2d43					      ENDIF
      5  2d43		       37		      .byte.b	55
      0  2d44					      EVAL8	0
      1  2d44				  -	      IF	(0 > 127) || (0 < -128)
      2  2d44				  -	      ECHO	"Erroneous position value", 0
      3  2d44				  -	      ERR
      4  2d44					      ENDIF
      5  2d44		       00		      .byte.b	0
      0  2d45					      EVAL8	0
      1  2d45				  -	      IF	(0 > 127) || (0 < -128)
      2  2d45				  -	      ECHO	"Erroneous position value", 0
      3  2d45				  -	      ERR
      4  2d45					      ENDIF
      5  2d45		       00		      .byte.b	0
      0  2d46					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  2d46					      EVAL8	0
      1  2d46				  -	      IF	(0 > 127) || (0 < -128)
      2  2d46				  -	      ECHO	"Erroneous position value", 0
      3  2d46				  -	      ERR
      4  2d46					      ENDIF
      5  2d46		       00		      .byte.b	0
      0  2d47					      EVAL8	0
      1  2d47				  -	      IF	(0 > 127) || (0 < -128)
      2  2d47				  -	      ECHO	"Erroneous position value", 0
      3  2d47				  -	      ERR
      4  2d47					      ENDIF
      5  2d47		       00		      .byte.b	0
      0  2d48					      EVAL8	0
      1  2d48				  -	      IF	(0 > 127) || (0 < -128)
      2  2d48				  -	      ECHO	"Erroneous position value", 0
      3  2d48				  -	      ERR
      4  2d48					      ENDIF
      5  2d48		       00		      .byte.b	0
      0  2d49					      EVAL8	0
      1  2d49				  -	      IF	(0 > 127) || (0 < -128)
      2  2d49				  -	      ECHO	"Erroneous position value", 0
      3  2d49				  -	      ERR
      4  2d49					      ENDIF
      5  2d49		       00		      .byte.b	0
      0  2d4a					      EVAL8	0
      1  2d4a				  -	      IF	(0 > 127) || (0 < -128)
      2  2d4a				  -	      ECHO	"Erroneous position value", 0
      3  2d4a				  -	      ERR
      4  2d4a					      ENDIF
      5  2d4a		       00		      .byte.b	0
      0  2d4b					      EVAL8	0
      1  2d4b				  -	      IF	(0 > 127) || (0 < -128)
      2  2d4b				  -	      ECHO	"Erroneous position value", 0
      3  2d4b				  -	      ERR
      4  2d4b					      ENDIF
      5  2d4b		       00		      .byte.b	0
      0  2d4c					      EVAL8	0
      1  2d4c				  -	      IF	(0 > 127) || (0 < -128)
      2  2d4c				  -	      ECHO	"Erroneous position value", 0
      3  2d4c				  -	      ERR
      4  2d4c					      ENDIF
      5  2d4c		       00		      .byte.b	0
      0  2d4d					      EVAL8	0
      1  2d4d				  -	      IF	(0 > 127) || (0 < -128)
      2  2d4d				  -	      ECHO	"Erroneous position value", 0
      3  2d4d				  -	      ERR
      4  2d4d					      ENDIF
      5  2d4d		       00		      .byte.b	0
      0  2d4e					      EVAL8	0
      1  2d4e				  -	      IF	(0 > 127) || (0 < -128)
      2  2d4e				  -	      ECHO	"Erroneous position value", 0
      3  2d4e				  -	      ERR
      4  2d4e					      ENDIF
      5  2d4e		       00		      .byte.b	0
      0  2d4f					      EVAL8	0
      1  2d4f				  -	      IF	(0 > 127) || (0 < -128)
      2  2d4f				  -	      ECHO	"Erroneous position value", 0
      3  2d4f				  -	      ERR
      4  2d4f					      ENDIF
      5  2d4f		       00		      .byte.b	0
    113  2d50
    114  2d50
    115  2d50							;---------------------------------------------------------------------------------------------------
    116  2d50
    117  2d50				   PositionalValue_QUEEN
    118  2d50
      0  2d50					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      0  2d50					      EVAL8	-20
      1  2d50				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2d50				  -	      ECHO	"Erroneous position value", -20
      3  2d50				  -	      ERR
      4  2d50					      ENDIF
      5  2d50		       ec		      .byte.b	-20
      0  2d51					      EVAL8	-10
      1  2d51				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d51				  -	      ECHO	"Erroneous position value", -10
      3  2d51				  -	      ERR
      4  2d51					      ENDIF
      5  2d51		       f6		      .byte.b	-10
      0  2d52					      EVAL8	-5
      1  2d52				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2d52				  -	      ECHO	"Erroneous position value", -5
      3  2d52				  -	      ERR
      4  2d52					      ENDIF
      5  2d52		       fb		      .byte.b	-5
      0  2d53					      EVAL8	-5
      1  2d53				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2d53				  -	      ECHO	"Erroneous position value", -5
      3  2d53				  -	      ERR
      4  2d53					      ENDIF
      5  2d53		       fb		      .byte.b	-5
      0  2d54					      EVAL8	-5
      1  2d54				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2d54				  -	      ECHO	"Erroneous position value", -5
      3  2d54				  -	      ERR
      4  2d54					      ENDIF
      5  2d54		       fb		      .byte.b	-5
      0  2d55					      EVAL8	-10
      1  2d55				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d55				  -	      ECHO	"Erroneous position value", -10
      3  2d55				  -	      ERR
      4  2d55					      ENDIF
      5  2d55		       f6		      .byte.b	-10
      0  2d56					      EVAL8	-10
      1  2d56				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d56				  -	      ECHO	"Erroneous position value", -10
      3  2d56				  -	      ERR
      4  2d56					      ENDIF
      5  2d56		       f6		      .byte.b	-10
      0  2d57					      EVAL8	-20
      1  2d57				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2d57				  -	      ECHO	"Erroneous position value", -20
      3  2d57				  -	      ERR
      4  2d57					      ENDIF
      5  2d57		       ec		      .byte.b	-20
      0  2d58					      EVAL8	0
      1  2d58				  -	      IF	(0 > 127) || (0 < -128)
      2  2d58				  -	      ECHO	"Erroneous position value", 0
      3  2d58				  -	      ERR
      4  2d58					      ENDIF
      5  2d58		       00		      .byte.b	0
      0  2d59					      EVAL8	0
      1  2d59				  -	      IF	(0 > 127) || (0 < -128)
      2  2d59				  -	      ECHO	"Erroneous position value", 0
      3  2d59				  -	      ERR
      4  2d59					      ENDIF
      5  2d59		       00		      .byte.b	0
      0  2d5a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      0  2d5a					      EVAL8	-10
      1  2d5a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d5a				  -	      ECHO	"Erroneous position value", -10
      3  2d5a				  -	      ERR
      4  2d5a					      ENDIF
      5  2d5a		       f6		      .byte.b	-10
      0  2d5b					      EVAL8	0
      1  2d5b				  -	      IF	(0 > 127) || (0 < -128)
      2  2d5b				  -	      ECHO	"Erroneous position value", 0
      3  2d5b				  -	      ERR
      4  2d5b					      ENDIF
      5  2d5b		       00		      .byte.b	0
      0  2d5c					      EVAL8	5
      1  2d5c				  -	      IF	(5 > 127) || (5 < -128)
      2  2d5c				  -	      ECHO	"Erroneous position value", 5
      3  2d5c				  -	      ERR
      4  2d5c					      ENDIF
      5  2d5c		       05		      .byte.b	5
      0  2d5d					      EVAL8	0
      1  2d5d				  -	      IF	(0 > 127) || (0 < -128)
      2  2d5d				  -	      ECHO	"Erroneous position value", 0
      3  2d5d				  -	      ERR
      4  2d5d					      ENDIF
      5  2d5d		       00		      .byte.b	0
      0  2d5e					      EVAL8	0
      1  2d5e				  -	      IF	(0 > 127) || (0 < -128)
      2  2d5e				  -	      ECHO	"Erroneous position value", 0
      3  2d5e				  -	      ERR
      4  2d5e					      ENDIF
      5  2d5e		       00		      .byte.b	0
      0  2d5f					      EVAL8	0
      1  2d5f				  -	      IF	(0 > 127) || (0 < -128)
      2  2d5f				  -	      ECHO	"Erroneous position value", 0
      3  2d5f				  -	      ERR
      4  2d5f					      ENDIF
      5  2d5f		       00		      .byte.b	0
      0  2d60					      EVAL8	0
      1  2d60				  -	      IF	(0 > 127) || (0 < -128)
      2  2d60				  -	      ECHO	"Erroneous position value", 0
      3  2d60				  -	      ERR
      4  2d60					      ENDIF
      5  2d60		       00		      .byte.b	0
      0  2d61					      EVAL8	-10
      1  2d61				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d61				  -	      ECHO	"Erroneous position value", -10
      3  2d61				  -	      ERR
      4  2d61					      ENDIF
      5  2d61		       f6		      .byte.b	-10
      0  2d62					      EVAL8	0
      1  2d62				  -	      IF	(0 > 127) || (0 < -128)
      2  2d62				  -	      ECHO	"Erroneous position value", 0
      3  2d62				  -	      ERR
      4  2d62					      ENDIF
      5  2d62		       00		      .byte.b	0
      0  2d63					      EVAL8	0
      1  2d63				  -	      IF	(0 > 127) || (0 < -128)
      2  2d63				  -	      ECHO	"Erroneous position value", 0
      3  2d63				  -	      ERR
      4  2d63					      ENDIF
      5  2d63		       00		      .byte.b	0
      0  2d64					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      0  2d64					      EVAL8	-10
      1  2d64				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d64				  -	      ECHO	"Erroneous position value", -10
      3  2d64				  -	      ERR
      4  2d64					      ENDIF
      5  2d64		       f6		      .byte.b	-10
      0  2d65					      EVAL8	5
      1  2d65				  -	      IF	(5 > 127) || (5 < -128)
      2  2d65				  -	      ECHO	"Erroneous position value", 5
      3  2d65				  -	      ERR
      4  2d65					      ENDIF
      5  2d65		       05		      .byte.b	5
      0  2d66					      EVAL8	5
      1  2d66				  -	      IF	(5 > 127) || (5 < -128)
      2  2d66				  -	      ECHO	"Erroneous position value", 5
      3  2d66				  -	      ERR
      4  2d66					      ENDIF
      5  2d66		       05		      .byte.b	5
      0  2d67					      EVAL8	5
      1  2d67				  -	      IF	(5 > 127) || (5 < -128)
      2  2d67				  -	      ECHO	"Erroneous position value", 5
      3  2d67				  -	      ERR
      4  2d67					      ENDIF
      5  2d67		       05		      .byte.b	5
      0  2d68					      EVAL8	5
      1  2d68				  -	      IF	(5 > 127) || (5 < -128)
      2  2d68				  -	      ECHO	"Erroneous position value", 5
      3  2d68				  -	      ERR
      4  2d68					      ENDIF
      5  2d68		       05		      .byte.b	5
      0  2d69					      EVAL8	25
      1  2d69				  -	      IF	(25 > 127) || (25 < -128)
      2  2d69				  -	      ECHO	"Erroneous position value", 25
      3  2d69				  -	      ERR
      4  2d69					      ENDIF
      5  2d69		       19		      .byte.b	25
      0  2d6a					      EVAL8	0
      1  2d6a				  -	      IF	(0 > 127) || (0 < -128)
      2  2d6a				  -	      ECHO	"Erroneous position value", 0
      3  2d6a				  -	      ERR
      4  2d6a					      ENDIF
      5  2d6a		       00		      .byte.b	0
      0  2d6b					      EVAL8	-10
      1  2d6b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d6b				  -	      ECHO	"Erroneous position value", -10
      3  2d6b				  -	      ERR
      4  2d6b					      ENDIF
      5  2d6b		       f6		      .byte.b	-10
      0  2d6c					      EVAL8	0
      1  2d6c				  -	      IF	(0 > 127) || (0 < -128)
      2  2d6c				  -	      ECHO	"Erroneous position value", 0
      3  2d6c				  -	      ERR
      4  2d6c					      ENDIF
      5  2d6c		       00		      .byte.b	0
      0  2d6d					      EVAL8	0
      1  2d6d				  -	      IF	(0 > 127) || (0 < -128)
      2  2d6d				  -	      ECHO	"Erroneous position value", 0
      3  2d6d				  -	      ERR
      4  2d6d					      ENDIF
      5  2d6d		       00		      .byte.b	0
      0  2d6e					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      0  2d6e					      EVAL8	-10
      1  2d6e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d6e				  -	      ECHO	"Erroneous position value", -10
      3  2d6e				  -	      ERR
      4  2d6e					      ENDIF
      5  2d6e		       f6		      .byte.b	-10
      0  2d6f					      EVAL8	0
      1  2d6f				  -	      IF	(0 > 127) || (0 < -128)
      2  2d6f				  -	      ECHO	"Erroneous position value", 0
      3  2d6f				  -	      ERR
      4  2d6f					      ENDIF
      5  2d6f		       00		      .byte.b	0
      0  2d70					      EVAL8	5
      1  2d70				  -	      IF	(5 > 127) || (5 < -128)
      2  2d70				  -	      ECHO	"Erroneous position value", 5
      3  2d70				  -	      ERR
      4  2d70					      ENDIF
      5  2d70		       05		      .byte.b	5
      0  2d71					      EVAL8	25
      1  2d71				  -	      IF	(25 > 127) || (25 < -128)
      2  2d71				  -	      ECHO	"Erroneous position value", 25
      3  2d71				  -	      ERR
      4  2d71					      ENDIF
      5  2d71		       19		      .byte.b	25
      0  2d72					      EVAL8	25
      1  2d72				  -	      IF	(25 > 127) || (25 < -128)
      2  2d72				  -	      ECHO	"Erroneous position value", 25
      3  2d72				  -	      ERR
      4  2d72					      ENDIF
      5  2d72		       19		      .byte.b	25
      0  2d73					      EVAL8	25
      1  2d73				  -	      IF	(25 > 127) || (25 < -128)
      2  2d73				  -	      ECHO	"Erroneous position value", 25
      3  2d73				  -	      ERR
      4  2d73					      ENDIF
      5  2d73		       19		      .byte.b	25
      0  2d74					      EVAL8	0
      1  2d74				  -	      IF	(0 > 127) || (0 < -128)
      2  2d74				  -	      ECHO	"Erroneous position value", 0
      3  2d74				  -	      ERR
      4  2d74					      ENDIF
      5  2d74		       00		      .byte.b	0
      0  2d75					      EVAL8	-10
      1  2d75				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d75				  -	      ECHO	"Erroneous position value", -10
      3  2d75				  -	      ERR
      4  2d75					      ENDIF
      5  2d75		       f6		      .byte.b	-10
      0  2d76					      EVAL8	0
      1  2d76				  -	      IF	(0 > 127) || (0 < -128)
      2  2d76				  -	      ECHO	"Erroneous position value", 0
      3  2d76				  -	      ERR
      4  2d76					      ENDIF
      5  2d76		       00		      .byte.b	0
      0  2d77					      EVAL8	0
      1  2d77				  -	      IF	(0 > 127) || (0 < -128)
      2  2d77				  -	      ECHO	"Erroneous position value", 0
      3  2d77				  -	      ERR
      4  2d77					      ENDIF
      5  2d77		       00		      .byte.b	0
      0  2d78					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      0  2d78					      EVAL8	-5
      1  2d78				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2d78				  -	      ECHO	"Erroneous position value", -5
      3  2d78				  -	      ERR
      4  2d78					      ENDIF
      5  2d78		       fb		      .byte.b	-5
      0  2d79					      EVAL8	0
      1  2d79				  -	      IF	(0 > 127) || (0 < -128)
      2  2d79				  -	      ECHO	"Erroneous position value", 0
      3  2d79				  -	      ERR
      4  2d79					      ENDIF
      5  2d79		       00		      .byte.b	0
      0  2d7a					      EVAL8	15
      1  2d7a				  -	      IF	(15 > 127) || (15 < -128)
      2  2d7a				  -	      ECHO	"Erroneous position value", 15
      3  2d7a				  -	      ERR
      4  2d7a					      ENDIF
      5  2d7a		       0f		      .byte.b	15
      0  2d7b					      EVAL8	55
      1  2d7b				  -	      IF	(55 > 127) || (55 < -128)
      2  2d7b				  -	      ECHO	"Erroneous position value", 55
      3  2d7b				  -	      ERR
      4  2d7b					      ENDIF
      5  2d7b		       37		      .byte.b	55
      0  2d7c					      EVAL8	55
      1  2d7c				  -	      IF	(55 > 127) || (55 < -128)
      2  2d7c				  -	      ECHO	"Erroneous position value", 55
      3  2d7c				  -	      ERR
      4  2d7c					      ENDIF
      5  2d7c		       37		      .byte.b	55
      0  2d7d					      EVAL8	55
      1  2d7d				  -	      IF	(55 > 127) || (55 < -128)
      2  2d7d				  -	      ECHO	"Erroneous position value", 55
      3  2d7d				  -	      ERR
      4  2d7d					      ENDIF
      5  2d7d		       37		      .byte.b	55
      0  2d7e					      EVAL8	0
      1  2d7e				  -	      IF	(0 > 127) || (0 < -128)
      2  2d7e				  -	      ECHO	"Erroneous position value", 0
      3  2d7e				  -	      ERR
      4  2d7e					      ENDIF
      5  2d7e		       00		      .byte.b	0
      0  2d7f					      EVAL8	-5
      1  2d7f				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2d7f				  -	      ECHO	"Erroneous position value", -5
      3  2d7f				  -	      ERR
      4  2d7f					      ENDIF
      5  2d7f		       fb		      .byte.b	-5
      0  2d80					      EVAL8	0
      1  2d80				  -	      IF	(0 > 127) || (0 < -128)
      2  2d80				  -	      ECHO	"Erroneous position value", 0
      3  2d80				  -	      ERR
      4  2d80					      ENDIF
      5  2d80		       00		      .byte.b	0
      0  2d81					      EVAL8	0
      1  2d81				  -	      IF	(0 > 127) || (0 < -128)
      2  2d81				  -	      ECHO	"Erroneous position value", 0
      3  2d81				  -	      ERR
      4  2d81					      ENDIF
      5  2d81		       00		      .byte.b	0
      0  2d82					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      0  2d82					      EVAL8	-10
      1  2d82				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d82				  -	      ECHO	"Erroneous position value", -10
      3  2d82				  -	      ERR
      4  2d82					      ENDIF
      5  2d82		       f6		      .byte.b	-10
      0  2d83					      EVAL8	0
      1  2d83				  -	      IF	(0 > 127) || (0 < -128)
      2  2d83				  -	      ECHO	"Erroneous position value", 0
      3  2d83				  -	      ERR
      4  2d83					      ENDIF
      5  2d83		       00		      .byte.b	0
      0  2d84					      EVAL8	25
      1  2d84				  -	      IF	(25 > 127) || (25 < -128)
      2  2d84				  -	      ECHO	"Erroneous position value", 25
      3  2d84				  -	      ERR
      4  2d84					      ENDIF
      5  2d84		       19		      .byte.b	25
      0  2d85					      EVAL8	75
      1  2d85				  -	      IF	(75 > 127) || (75 < -128)
      2  2d85				  -	      ECHO	"Erroneous position value", 75
      3  2d85				  -	      ERR
      4  2d85					      ENDIF
      5  2d85		       4b		      .byte.b	75
      0  2d86					      EVAL8	75
      1  2d86				  -	      IF	(75 > 127) || (75 < -128)
      2  2d86				  -	      ECHO	"Erroneous position value", 75
      3  2d86				  -	      ERR
      4  2d86					      ENDIF
      5  2d86		       4b		      .byte.b	75
      0  2d87					      EVAL8	75
      1  2d87				  -	      IF	(75 > 127) || (75 < -128)
      2  2d87				  -	      ECHO	"Erroneous position value", 75
      3  2d87				  -	      ERR
      4  2d87					      ENDIF
      5  2d87		       4b		      .byte.b	75
      0  2d88					      EVAL8	0
      1  2d88				  -	      IF	(0 > 127) || (0 < -128)
      2  2d88				  -	      ECHO	"Erroneous position value", 0
      3  2d88				  -	      ERR
      4  2d88					      ENDIF
      5  2d88		       00		      .byte.b	0
      0  2d89					      EVAL8	-10
      1  2d89				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d89				  -	      ECHO	"Erroneous position value", -10
      3  2d89				  -	      ERR
      4  2d89					      ENDIF
      5  2d89		       f6		      .byte.b	-10
      0  2d8a					      EVAL8	0
      1  2d8a				  -	      IF	(0 > 127) || (0 < -128)
      2  2d8a				  -	      ECHO	"Erroneous position value", 0
      3  2d8a				  -	      ERR
      4  2d8a					      ENDIF
      5  2d8a		       00		      .byte.b	0
      0  2d8b					      EVAL8	0
      1  2d8b				  -	      IF	(0 > 127) || (0 < -128)
      2  2d8b				  -	      ECHO	"Erroneous position value", 0
      3  2d8b				  -	      ERR
      4  2d8b					      ENDIF
      5  2d8b		       00		      .byte.b	0
      0  2d8c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  2d8c					      EVAL8	-10
      1  2d8c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d8c				  -	      ECHO	"Erroneous position value", -10
      3  2d8c				  -	      ERR
      4  2d8c					      ENDIF
      5  2d8c		       f6		      .byte.b	-10
      0  2d8d					      EVAL8	0
      1  2d8d				  -	      IF	(0 > 127) || (0 < -128)
      2  2d8d				  -	      ECHO	"Erroneous position value", 0
      3  2d8d				  -	      ERR
      4  2d8d					      ENDIF
      5  2d8d		       00		      .byte.b	0
      0  2d8e					      EVAL8	0
      1  2d8e				  -	      IF	(0 > 127) || (0 < -128)
      2  2d8e				  -	      ECHO	"Erroneous position value", 0
      3  2d8e				  -	      ERR
      4  2d8e					      ENDIF
      5  2d8e		       00		      .byte.b	0
      0  2d8f					      EVAL8	0
      1  2d8f				  -	      IF	(0 > 127) || (0 < -128)
      2  2d8f				  -	      ECHO	"Erroneous position value", 0
      3  2d8f				  -	      ERR
      4  2d8f					      ENDIF
      5  2d8f		       00		      .byte.b	0
      0  2d90					      EVAL8	0
      1  2d90				  -	      IF	(0 > 127) || (0 < -128)
      2  2d90				  -	      ECHO	"Erroneous position value", 0
      3  2d90				  -	      ERR
      4  2d90					      ENDIF
      5  2d90		       00		      .byte.b	0
      0  2d91					      EVAL8	0
      1  2d91				  -	      IF	(0 > 127) || (0 < -128)
      2  2d91				  -	      ECHO	"Erroneous position value", 0
      3  2d91				  -	      ERR
      4  2d91					      ENDIF
      5  2d91		       00		      .byte.b	0
      0  2d92					      EVAL8	0
      1  2d92				  -	      IF	(0 > 127) || (0 < -128)
      2  2d92				  -	      ECHO	"Erroneous position value", 0
      3  2d92				  -	      ERR
      4  2d92					      ENDIF
      5  2d92		       00		      .byte.b	0
      0  2d93					      EVAL8	-10
      1  2d93				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d93				  -	      ECHO	"Erroneous position value", -10
      3  2d93				  -	      ERR
      4  2d93					      ENDIF
      5  2d93		       f6		      .byte.b	-10
      0  2d94					      EVAL8	0
      1  2d94				  -	      IF	(0 > 127) || (0 < -128)
      2  2d94				  -	      ECHO	"Erroneous position value", 0
      3  2d94				  -	      ERR
      4  2d94					      ENDIF
      5  2d94		       00		      .byte.b	0
      0  2d95					      EVAL8	0
      1  2d95				  -	      IF	(0 > 127) || (0 < -128)
      2  2d95				  -	      ECHO	"Erroneous position value", 0
      3  2d95				  -	      ERR
      4  2d95					      ENDIF
      5  2d95		       00		      .byte.b	0
      0  2d96					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      0  2d96					      EVAL8	-20
      1  2d96				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2d96				  -	      ECHO	"Erroneous position value", -20
      3  2d96				  -	      ERR
      4  2d96					      ENDIF
      5  2d96		       ec		      .byte.b	-20
      0  2d97					      EVAL8	-10
      1  2d97				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d97				  -	      ECHO	"Erroneous position value", -10
      3  2d97				  -	      ERR
      4  2d97					      ENDIF
      5  2d97		       f6		      .byte.b	-10
      0  2d98					      EVAL8	-10
      1  2d98				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d98				  -	      ECHO	"Erroneous position value", -10
      3  2d98				  -	      ERR
      4  2d98					      ENDIF
      5  2d98		       f6		      .byte.b	-10
      0  2d99					      EVAL8	-5
      1  2d99				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2d99				  -	      ECHO	"Erroneous position value", -5
      3  2d99				  -	      ERR
      4  2d99					      ENDIF
      5  2d99		       fb		      .byte.b	-5
      0  2d9a					      EVAL8	-5
      1  2d9a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  2d9a				  -	      ECHO	"Erroneous position value", -5
      3  2d9a				  -	      ERR
      4  2d9a					      ENDIF
      5  2d9a		       fb		      .byte.b	-5
      0  2d9b					      EVAL8	-10
      1  2d9b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d9b				  -	      ECHO	"Erroneous position value", -10
      3  2d9b				  -	      ERR
      4  2d9b					      ENDIF
      5  2d9b		       f6		      .byte.b	-10
      0  2d9c					      EVAL8	-10
      1  2d9c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2d9c				  -	      ECHO	"Erroneous position value", -10
      3  2d9c				  -	      ERR
      4  2d9c					      ENDIF
      5  2d9c		       f6		      .byte.b	-10
      0  2d9d					      EVAL8	-20
      1  2d9d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2d9d				  -	      ECHO	"Erroneous position value", -20
      3  2d9d				  -	      ERR
      4  2d9d					      ENDIF
      5  2d9d		       ec		      .byte.b	-20
      0  2d9e					      EVAL8	0
      1  2d9e				  -	      IF	(0 > 127) || (0 < -128)
      2  2d9e				  -	      ECHO	"Erroneous position value", 0
      3  2d9e				  -	      ERR
      4  2d9e					      ENDIF
      5  2d9e		       00		      .byte.b	0
      0  2d9f					      EVAL8	0
      1  2d9f				  -	      IF	(0 > 127) || (0 < -128)
      2  2d9f				  -	      ECHO	"Erroneous position value", 0
      3  2d9f				  -	      ERR
      4  2d9f					      ENDIF
      5  2d9f		       00		      .byte.b	0
    127  2da0
    128  2da0
    129  2da0							;---------------------------------------------------------------------------------------------------
    130  2da0
    131  2da0				   PositionalValue_KING_MIDGAME
    132  2da0
      0  2da0					      PVAL	0, 0, 40, -120, -60, -120, 70, 0
      0  2da0					      EVAL8	0
      1  2da0				  -	      IF	(0 > 127) || (0 < -128)
      2  2da0				  -	      ECHO	"Erroneous position value", 0
      3  2da0				  -	      ERR
      4  2da0					      ENDIF
      5  2da0		       00		      .byte.b	0
      0  2da1					      EVAL8	0
      1  2da1				  -	      IF	(0 > 127) || (0 < -128)
      2  2da1				  -	      ECHO	"Erroneous position value", 0
      3  2da1				  -	      ERR
      4  2da1					      ENDIF
      5  2da1		       00		      .byte.b	0
      0  2da2					      EVAL8	40
      1  2da2				  -	      IF	(40 > 127) || (40 < -128)
      2  2da2				  -	      ECHO	"Erroneous position value", 40
      3  2da2				  -	      ERR
      4  2da2					      ENDIF
      5  2da2		       28		      .byte.b	40
      0  2da3					      EVAL8	-120
      1  2da3				  -	      IF	(-120 > 127) || (-120 < -128)
      2  2da3				  -	      ECHO	"Erroneous position value", -120
      3  2da3				  -	      ERR
      4  2da3					      ENDIF
      5  2da3		       88		      .byte.b	-120
      0  2da4					      EVAL8	-60
      1  2da4				  -	      IF	(-60 > 127) || (-60 < -128)
      2  2da4				  -	      ECHO	"Erroneous position value", -60
      3  2da4				  -	      ERR
      4  2da4					      ENDIF
      5  2da4		       c4		      .byte.b	-60
      0  2da5					      EVAL8	-120
      1  2da5				  -	      IF	(-120 > 127) || (-120 < -128)
      2  2da5				  -	      ECHO	"Erroneous position value", -120
      3  2da5				  -	      ERR
      4  2da5					      ENDIF
      5  2da5		       88		      .byte.b	-120
      0  2da6					      EVAL8	70
      1  2da6				  -	      IF	(70 > 127) || (70 < -128)
      2  2da6				  -	      ECHO	"Erroneous position value", 70
      3  2da6				  -	      ERR
      4  2da6					      ENDIF
      5  2da6		       46		      .byte.b	70
      0  2da7					      EVAL8	0
      1  2da7				  -	      IF	(0 > 127) || (0 < -128)
      2  2da7				  -	      ECHO	"Erroneous position value", 0
      3  2da7				  -	      ERR
      4  2da7					      ENDIF
      5  2da7		       00		      .byte.b	0
      0  2da8					      EVAL8	0
      1  2da8				  -	      IF	(0 > 127) || (0 < -128)
      2  2da8				  -	      ECHO	"Erroneous position value", 0
      3  2da8				  -	      ERR
      4  2da8					      ENDIF
      5  2da8		       00		      .byte.b	0
      0  2da9					      EVAL8	0
      1  2da9				  -	      IF	(0 > 127) || (0 < -128)
      2  2da9				  -	      ECHO	"Erroneous position value", 0
      3  2da9				  -	      ERR
      4  2da9					      ENDIF
      5  2da9		       00		      .byte.b	0
      0  2daa					      PVAL	0, 0, -80, -80, -70, -70, 0, 0
      0  2daa					      EVAL8	0
      1  2daa				  -	      IF	(0 > 127) || (0 < -128)
      2  2daa				  -	      ECHO	"Erroneous position value", 0
      3  2daa				  -	      ERR
      4  2daa					      ENDIF
      5  2daa		       00		      .byte.b	0
      0  2dab					      EVAL8	0
      1  2dab				  -	      IF	(0 > 127) || (0 < -128)
      2  2dab				  -	      ECHO	"Erroneous position value", 0
      3  2dab				  -	      ERR
      4  2dab					      ENDIF
      5  2dab		       00		      .byte.b	0
      0  2dac					      EVAL8	-80
      1  2dac				  -	      IF	(-80 > 127) || (-80 < -128)
      2  2dac				  -	      ECHO	"Erroneous position value", -80
      3  2dac				  -	      ERR
      4  2dac					      ENDIF
      5  2dac		       b0		      .byte.b	-80
      0  2dad					      EVAL8	-80
      1  2dad				  -	      IF	(-80 > 127) || (-80 < -128)
      2  2dad				  -	      ECHO	"Erroneous position value", -80
      3  2dad				  -	      ERR
      4  2dad					      ENDIF
      5  2dad		       b0		      .byte.b	-80
      0  2dae					      EVAL8	-70
      1  2dae				  -	      IF	(-70 > 127) || (-70 < -128)
      2  2dae				  -	      ECHO	"Erroneous position value", -70
      3  2dae				  -	      ERR
      4  2dae					      ENDIF
      5  2dae		       ba		      .byte.b	-70
      0  2daf					      EVAL8	-70
      1  2daf				  -	      IF	(-70 > 127) || (-70 < -128)
      2  2daf				  -	      ECHO	"Erroneous position value", -70
      3  2daf				  -	      ERR
      4  2daf					      ENDIF
      5  2daf		       ba		      .byte.b	-70
      0  2db0					      EVAL8	0
      1  2db0				  -	      IF	(0 > 127) || (0 < -128)
      2  2db0				  -	      ECHO	"Erroneous position value", 0
      3  2db0				  -	      ERR
      4  2db0					      ENDIF
      5  2db0		       00		      .byte.b	0
      0  2db1					      EVAL8	0
      1  2db1				  -	      IF	(0 > 127) || (0 < -128)
      2  2db1				  -	      ECHO	"Erroneous position value", 0
      3  2db1				  -	      ERR
      4  2db1					      ENDIF
      5  2db1		       00		      .byte.b	0
      0  2db2					      EVAL8	0
      1  2db2				  -	      IF	(0 > 127) || (0 < -128)
      2  2db2				  -	      ECHO	"Erroneous position value", 0
      3  2db2				  -	      ERR
      4  2db2					      ENDIF
      5  2db2		       00		      .byte.b	0
      0  2db3					      EVAL8	0
      1  2db3				  -	      IF	(0 > 127) || (0 < -128)
      2  2db3				  -	      ECHO	"Erroneous position value", 0
      3  2db3				  -	      ERR
      4  2db3					      ENDIF
      5  2db3		       00		      .byte.b	0
      0  2db4					      PVAL	-10, -20, -20, -50, -60, -60, -20, -10
      0  2db4					      EVAL8	-10
      1  2db4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2db4				  -	      ECHO	"Erroneous position value", -10
      3  2db4				  -	      ERR
      4  2db4					      ENDIF
      5  2db4		       f6		      .byte.b	-10
      0  2db5					      EVAL8	-20
      1  2db5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2db5				  -	      ECHO	"Erroneous position value", -20
      3  2db5				  -	      ERR
      4  2db5					      ENDIF
      5  2db5		       ec		      .byte.b	-20
      0  2db6					      EVAL8	-20
      1  2db6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2db6				  -	      ECHO	"Erroneous position value", -20
      3  2db6				  -	      ERR
      4  2db6					      ENDIF
      5  2db6		       ec		      .byte.b	-20
      0  2db7					      EVAL8	-50
      1  2db7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2db7				  -	      ECHO	"Erroneous position value", -50
      3  2db7				  -	      ERR
      4  2db7					      ENDIF
      5  2db7		       ce		      .byte.b	-50
      0  2db8					      EVAL8	-60
      1  2db8				  -	      IF	(-60 > 127) || (-60 < -128)
      2  2db8				  -	      ECHO	"Erroneous position value", -60
      3  2db8				  -	      ERR
      4  2db8					      ENDIF
      5  2db8		       c4		      .byte.b	-60
      0  2db9					      EVAL8	-60
      1  2db9				  -	      IF	(-60 > 127) || (-60 < -128)
      2  2db9				  -	      ECHO	"Erroneous position value", -60
      3  2db9				  -	      ERR
      4  2db9					      ENDIF
      5  2db9		       c4		      .byte.b	-60
      0  2dba					      EVAL8	-20
      1  2dba				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2dba				  -	      ECHO	"Erroneous position value", -20
      3  2dba				  -	      ERR
      4  2dba					      ENDIF
      5  2dba		       ec		      .byte.b	-20
      0  2dbb					      EVAL8	-10
      1  2dbb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2dbb				  -	      ECHO	"Erroneous position value", -10
      3  2dbb				  -	      ERR
      4  2dbb					      ENDIF
      5  2dbb		       f6		      .byte.b	-10
      0  2dbc					      EVAL8	0
      1  2dbc				  -	      IF	(0 > 127) || (0 < -128)
      2  2dbc				  -	      ECHO	"Erroneous position value", 0
      3  2dbc				  -	      ERR
      4  2dbc					      ENDIF
      5  2dbc		       00		      .byte.b	0
      0  2dbd					      EVAL8	0
      1  2dbd				  -	      IF	(0 > 127) || (0 < -128)
      2  2dbd				  -	      ECHO	"Erroneous position value", 0
      3  2dbd				  -	      ERR
      4  2dbd					      ENDIF
      5  2dbd		       00		      .byte.b	0
      0  2dbe					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      0  2dbe					      EVAL8	-20
      1  2dbe				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2dbe				  -	      ECHO	"Erroneous position value", -20
      3  2dbe				  -	      ERR
      4  2dbe					      ENDIF
      5  2dbe		       ec		      .byte.b	-20
      0  2dbf					      EVAL8	-30
      1  2dbf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dbf				  -	      ECHO	"Erroneous position value", -30
      3  2dbf				  -	      ERR
      4  2dbf					      ENDIF
      5  2dbf		       e2		      .byte.b	-30
      0  2dc0					      EVAL8	-30
      1  2dc0				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dc0				  -	      ECHO	"Erroneous position value", -30
      3  2dc0				  -	      ERR
      4  2dc0					      ENDIF
      5  2dc0		       e2		      .byte.b	-30
      0  2dc1					      EVAL8	-40
      1  2dc1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dc1				  -	      ECHO	"Erroneous position value", -40
      3  2dc1				  -	      ERR
      4  2dc1					      ENDIF
      5  2dc1		       d8		      .byte.b	-40
      0  2dc2					      EVAL8	-40
      1  2dc2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dc2				  -	      ECHO	"Erroneous position value", -40
      3  2dc2				  -	      ERR
      4  2dc2					      ENDIF
      5  2dc2		       d8		      .byte.b	-40
      0  2dc3					      EVAL8	-30
      1  2dc3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dc3				  -	      ECHO	"Erroneous position value", -30
      3  2dc3				  -	      ERR
      4  2dc3					      ENDIF
      5  2dc3		       e2		      .byte.b	-30
      0  2dc4					      EVAL8	-30
      1  2dc4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dc4				  -	      ECHO	"Erroneous position value", -30
      3  2dc4				  -	      ERR
      4  2dc4					      ENDIF
      5  2dc4		       e2		      .byte.b	-30
      0  2dc5					      EVAL8	-20
      1  2dc5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2dc5				  -	      ECHO	"Erroneous position value", -20
      3  2dc5				  -	      ERR
      4  2dc5					      ENDIF
      5  2dc5		       ec		      .byte.b	-20
      0  2dc6					      EVAL8	0
      1  2dc6				  -	      IF	(0 > 127) || (0 < -128)
      2  2dc6				  -	      ECHO	"Erroneous position value", 0
      3  2dc6				  -	      ERR
      4  2dc6					      ENDIF
      5  2dc6		       00		      .byte.b	0
      0  2dc7					      EVAL8	0
      1  2dc7				  -	      IF	(0 > 127) || (0 < -128)
      2  2dc7				  -	      ECHO	"Erroneous position value", 0
      3  2dc7				  -	      ERR
      4  2dc7					      ENDIF
      5  2dc7		       00		      .byte.b	0
      0  2dc8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  2dc8					      EVAL8	-30
      1  2dc8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dc8				  -	      ECHO	"Erroneous position value", -30
      3  2dc8				  -	      ERR
      4  2dc8					      ENDIF
      5  2dc8		       e2		      .byte.b	-30
      0  2dc9					      EVAL8	-40
      1  2dc9				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dc9				  -	      ECHO	"Erroneous position value", -40
      3  2dc9				  -	      ERR
      4  2dc9					      ENDIF
      5  2dc9		       d8		      .byte.b	-40
      0  2dca					      EVAL8	-40
      1  2dca				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dca				  -	      ECHO	"Erroneous position value", -40
      3  2dca				  -	      ERR
      4  2dca					      ENDIF
      5  2dca		       d8		      .byte.b	-40
      0  2dcb					      EVAL8	-50
      1  2dcb				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2dcb				  -	      ECHO	"Erroneous position value", -50
      3  2dcb				  -	      ERR
      4  2dcb					      ENDIF
      5  2dcb		       ce		      .byte.b	-50
      0  2dcc					      EVAL8	-50
      1  2dcc				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2dcc				  -	      ECHO	"Erroneous position value", -50
      3  2dcc				  -	      ERR
      4  2dcc					      ENDIF
      5  2dcc		       ce		      .byte.b	-50
      0  2dcd					      EVAL8	-40
      1  2dcd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dcd				  -	      ECHO	"Erroneous position value", -40
      3  2dcd				  -	      ERR
      4  2dcd					      ENDIF
      5  2dcd		       d8		      .byte.b	-40
      0  2dce					      EVAL8	-40
      1  2dce				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dce				  -	      ECHO	"Erroneous position value", -40
      3  2dce				  -	      ERR
      4  2dce					      ENDIF
      5  2dce		       d8		      .byte.b	-40
      0  2dcf					      EVAL8	-30
      1  2dcf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dcf				  -	      ECHO	"Erroneous position value", -30
      3  2dcf				  -	      ERR
      4  2dcf					      ENDIF
      5  2dcf		       e2		      .byte.b	-30
      0  2dd0					      EVAL8	0
      1  2dd0				  -	      IF	(0 > 127) || (0 < -128)
      2  2dd0				  -	      ECHO	"Erroneous position value", 0
      3  2dd0				  -	      ERR
      4  2dd0					      ENDIF
      5  2dd0		       00		      .byte.b	0
      0  2dd1					      EVAL8	0
      1  2dd1				  -	      IF	(0 > 127) || (0 < -128)
      2  2dd1				  -	      ECHO	"Erroneous position value", 0
      3  2dd1				  -	      ERR
      4  2dd1					      ENDIF
      5  2dd1		       00		      .byte.b	0
      0  2dd2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  2dd2					      EVAL8	-30
      1  2dd2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dd2				  -	      ECHO	"Erroneous position value", -30
      3  2dd2				  -	      ERR
      4  2dd2					      ENDIF
      5  2dd2		       e2		      .byte.b	-30
      0  2dd3					      EVAL8	-40
      1  2dd3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dd3				  -	      ECHO	"Erroneous position value", -40
      3  2dd3				  -	      ERR
      4  2dd3					      ENDIF
      5  2dd3		       d8		      .byte.b	-40
      0  2dd4					      EVAL8	-40
      1  2dd4				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dd4				  -	      ECHO	"Erroneous position value", -40
      3  2dd4				  -	      ERR
      4  2dd4					      ENDIF
      5  2dd4		       d8		      .byte.b	-40
      0  2dd5					      EVAL8	-50
      1  2dd5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2dd5				  -	      ECHO	"Erroneous position value", -50
      3  2dd5				  -	      ERR
      4  2dd5					      ENDIF
      5  2dd5		       ce		      .byte.b	-50
      0  2dd6					      EVAL8	-50
      1  2dd6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2dd6				  -	      ECHO	"Erroneous position value", -50
      3  2dd6				  -	      ERR
      4  2dd6					      ENDIF
      5  2dd6		       ce		      .byte.b	-50
      0  2dd7					      EVAL8	-40
      1  2dd7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dd7				  -	      ECHO	"Erroneous position value", -40
      3  2dd7				  -	      ERR
      4  2dd7					      ENDIF
      5  2dd7		       d8		      .byte.b	-40
      0  2dd8					      EVAL8	-40
      1  2dd8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dd8				  -	      ECHO	"Erroneous position value", -40
      3  2dd8				  -	      ERR
      4  2dd8					      ENDIF
      5  2dd8		       d8		      .byte.b	-40
      0  2dd9					      EVAL8	-30
      1  2dd9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dd9				  -	      ECHO	"Erroneous position value", -30
      3  2dd9				  -	      ERR
      4  2dd9					      ENDIF
      5  2dd9		       e2		      .byte.b	-30
      0  2dda					      EVAL8	0
      1  2dda				  -	      IF	(0 > 127) || (0 < -128)
      2  2dda				  -	      ECHO	"Erroneous position value", 0
      3  2dda				  -	      ERR
      4  2dda					      ENDIF
      5  2dda		       00		      .byte.b	0
      0  2ddb					      EVAL8	0
      1  2ddb				  -	      IF	(0 > 127) || (0 < -128)
      2  2ddb				  -	      ECHO	"Erroneous position value", 0
      3  2ddb				  -	      ERR
      4  2ddb					      ENDIF
      5  2ddb		       00		      .byte.b	0
      0  2ddc					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  2ddc					      EVAL8	-30
      1  2ddc				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2ddc				  -	      ECHO	"Erroneous position value", -30
      3  2ddc				  -	      ERR
      4  2ddc					      ENDIF
      5  2ddc		       e2		      .byte.b	-30
      0  2ddd					      EVAL8	-40
      1  2ddd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2ddd				  -	      ECHO	"Erroneous position value", -40
      3  2ddd				  -	      ERR
      4  2ddd					      ENDIF
      5  2ddd		       d8		      .byte.b	-40
      0  2dde					      EVAL8	-40
      1  2dde				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dde				  -	      ECHO	"Erroneous position value", -40
      3  2dde				  -	      ERR
      4  2dde					      ENDIF
      5  2dde		       d8		      .byte.b	-40
      0  2ddf					      EVAL8	-50
      1  2ddf				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2ddf				  -	      ECHO	"Erroneous position value", -50
      3  2ddf				  -	      ERR
      4  2ddf					      ENDIF
      5  2ddf		       ce		      .byte.b	-50
      0  2de0					      EVAL8	-50
      1  2de0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2de0				  -	      ECHO	"Erroneous position value", -50
      3  2de0				  -	      ERR
      4  2de0					      ENDIF
      5  2de0		       ce		      .byte.b	-50
      0  2de1					      EVAL8	-40
      1  2de1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2de1				  -	      ECHO	"Erroneous position value", -40
      3  2de1				  -	      ERR
      4  2de1					      ENDIF
      5  2de1		       d8		      .byte.b	-40
      0  2de2					      EVAL8	-40
      1  2de2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2de2				  -	      ECHO	"Erroneous position value", -40
      3  2de2				  -	      ERR
      4  2de2					      ENDIF
      5  2de2		       d8		      .byte.b	-40
      0  2de3					      EVAL8	-30
      1  2de3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2de3				  -	      ECHO	"Erroneous position value", -30
      3  2de3				  -	      ERR
      4  2de3					      ENDIF
      5  2de3		       e2		      .byte.b	-30
      0  2de4					      EVAL8	0
      1  2de4				  -	      IF	(0 > 127) || (0 < -128)
      2  2de4				  -	      ECHO	"Erroneous position value", 0
      3  2de4				  -	      ERR
      4  2de4					      ENDIF
      5  2de4		       00		      .byte.b	0
      0  2de5					      EVAL8	0
      1  2de5				  -	      IF	(0 > 127) || (0 < -128)
      2  2de5				  -	      ECHO	"Erroneous position value", 0
      3  2de5				  -	      ERR
      4  2de5					      ENDIF
      5  2de5		       00		      .byte.b	0
      0  2de6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  2de6					      EVAL8	-30
      1  2de6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2de6				  -	      ECHO	"Erroneous position value", -30
      3  2de6				  -	      ERR
      4  2de6					      ENDIF
      5  2de6		       e2		      .byte.b	-30
      0  2de7					      EVAL8	-40
      1  2de7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2de7				  -	      ECHO	"Erroneous position value", -40
      3  2de7				  -	      ERR
      4  2de7					      ENDIF
      5  2de7		       d8		      .byte.b	-40
      0  2de8					      EVAL8	-40
      1  2de8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2de8				  -	      ECHO	"Erroneous position value", -40
      3  2de8				  -	      ERR
      4  2de8					      ENDIF
      5  2de8		       d8		      .byte.b	-40
      0  2de9					      EVAL8	-50
      1  2de9				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2de9				  -	      ECHO	"Erroneous position value", -50
      3  2de9				  -	      ERR
      4  2de9					      ENDIF
      5  2de9		       ce		      .byte.b	-50
      0  2dea					      EVAL8	-50
      1  2dea				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2dea				  -	      ECHO	"Erroneous position value", -50
      3  2dea				  -	      ERR
      4  2dea					      ENDIF
      5  2dea		       ce		      .byte.b	-50
      0  2deb					      EVAL8	-40
      1  2deb				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2deb				  -	      ECHO	"Erroneous position value", -40
      3  2deb				  -	      ERR
      4  2deb					      ENDIF
      5  2deb		       d8		      .byte.b	-40
      0  2dec					      EVAL8	-40
      1  2dec				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2dec				  -	      ECHO	"Erroneous position value", -40
      3  2dec				  -	      ERR
      4  2dec					      ENDIF
      5  2dec		       d8		      .byte.b	-40
      0  2ded					      EVAL8	-30
      1  2ded				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2ded				  -	      ECHO	"Erroneous position value", -30
      3  2ded				  -	      ERR
      4  2ded					      ENDIF
      5  2ded		       e2		      .byte.b	-30
      0  2dee					      EVAL8	0
      1  2dee				  -	      IF	(0 > 127) || (0 < -128)
      2  2dee				  -	      ECHO	"Erroneous position value", 0
      3  2dee				  -	      ERR
      4  2dee					      ENDIF
      5  2dee		       00		      .byte.b	0
      0  2def					      EVAL8	0
      1  2def				  -	      IF	(0 > 127) || (0 < -128)
      2  2def				  -	      ECHO	"Erroneous position value", 0
      3  2def				  -	      ERR
      4  2def					      ENDIF
      5  2def		       00		      .byte.b	0
    141  2df0
    142  2df0
    143  2df0							;---------------------------------------------------------------------------------------------------
    144  2df0
    145  2df0				   PositionalValue_KING_ENDGAME
    146  2df0
      0  2df0					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      0  2df0					      EVAL8	-50
      1  2df0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2df0				  -	      ECHO	"Erroneous position value", -50
      3  2df0				  -	      ERR
      4  2df0					      ENDIF
      5  2df0		       ce		      .byte.b	-50
      0  2df1					      EVAL8	-30
      1  2df1				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2df1				  -	      ECHO	"Erroneous position value", -30
      3  2df1				  -	      ERR
      4  2df1					      ENDIF
      5  2df1		       e2		      .byte.b	-30
      0  2df2					      EVAL8	-30
      1  2df2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2df2				  -	      ECHO	"Erroneous position value", -30
      3  2df2				  -	      ERR
      4  2df2					      ENDIF
      5  2df2		       e2		      .byte.b	-30
      0  2df3					      EVAL8	-30
      1  2df3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2df3				  -	      ECHO	"Erroneous position value", -30
      3  2df3				  -	      ERR
      4  2df3					      ENDIF
      5  2df3		       e2		      .byte.b	-30
      0  2df4					      EVAL8	-30
      1  2df4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2df4				  -	      ECHO	"Erroneous position value", -30
      3  2df4				  -	      ERR
      4  2df4					      ENDIF
      5  2df4		       e2		      .byte.b	-30
      0  2df5					      EVAL8	-30
      1  2df5				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2df5				  -	      ECHO	"Erroneous position value", -30
      3  2df5				  -	      ERR
      4  2df5					      ENDIF
      5  2df5		       e2		      .byte.b	-30
      0  2df6					      EVAL8	-30
      1  2df6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2df6				  -	      ECHO	"Erroneous position value", -30
      3  2df6				  -	      ERR
      4  2df6					      ENDIF
      5  2df6		       e2		      .byte.b	-30
      0  2df7					      EVAL8	-50
      1  2df7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2df7				  -	      ECHO	"Erroneous position value", -50
      3  2df7				  -	      ERR
      4  2df7					      ENDIF
      5  2df7		       ce		      .byte.b	-50
      0  2df8					      EVAL8	0
      1  2df8				  -	      IF	(0 > 127) || (0 < -128)
      2  2df8				  -	      ECHO	"Erroneous position value", 0
      3  2df8				  -	      ERR
      4  2df8					      ENDIF
      5  2df8		       00		      .byte.b	0
      0  2df9					      EVAL8	0
      1  2df9				  -	      IF	(0 > 127) || (0 < -128)
      2  2df9				  -	      ECHO	"Erroneous position value", 0
      3  2df9				  -	      ERR
      4  2df9					      ENDIF
      5  2df9		       00		      .byte.b	0
      0  2dfa					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      0  2dfa					      EVAL8	-30
      1  2dfa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dfa				  -	      ECHO	"Erroneous position value", -30
      3  2dfa				  -	      ERR
      4  2dfa					      ENDIF
      5  2dfa		       e2		      .byte.b	-30
      0  2dfb					      EVAL8	-30
      1  2dfb				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2dfb				  -	      ECHO	"Erroneous position value", -30
      3  2dfb				  -	      ERR
      4  2dfb					      ENDIF
      5  2dfb		       e2		      .byte.b	-30
      0  2dfc					      EVAL8	0
      1  2dfc				  -	      IF	(0 > 127) || (0 < -128)
      2  2dfc				  -	      ECHO	"Erroneous position value", 0
      3  2dfc				  -	      ERR
      4  2dfc					      ENDIF
      5  2dfc		       00		      .byte.b	0
      0  2dfd					      EVAL8	0
      1  2dfd				  -	      IF	(0 > 127) || (0 < -128)
      2  2dfd				  -	      ECHO	"Erroneous position value", 0
      3  2dfd				  -	      ERR
      4  2dfd					      ENDIF
      5  2dfd		       00		      .byte.b	0
      0  2dfe					      EVAL8	0
      1  2dfe				  -	      IF	(0 > 127) || (0 < -128)
      2  2dfe				  -	      ECHO	"Erroneous position value", 0
      3  2dfe				  -	      ERR
      4  2dfe					      ENDIF
      5  2dfe		       00		      .byte.b	0
      0  2dff					      EVAL8	0
      1  2dff				  -	      IF	(0 > 127) || (0 < -128)
      2  2dff				  -	      ECHO	"Erroneous position value", 0
      3  2dff				  -	      ERR
      4  2dff					      ENDIF
      5  2dff		       00		      .byte.b	0
      0  2e00					      EVAL8	-30
      1  2e00				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e00				  -	      ECHO	"Erroneous position value", -30
      3  2e00				  -	      ERR
      4  2e00					      ENDIF
      5  2e00		       e2		      .byte.b	-30
      0  2e01					      EVAL8	-30
      1  2e01				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e01				  -	      ECHO	"Erroneous position value", -30
      3  2e01				  -	      ERR
      4  2e01					      ENDIF
      5  2e01		       e2		      .byte.b	-30
      0  2e02					      EVAL8	0
      1  2e02				  -	      IF	(0 > 127) || (0 < -128)
      2  2e02				  -	      ECHO	"Erroneous position value", 0
      3  2e02				  -	      ERR
      4  2e02					      ENDIF
      5  2e02		       00		      .byte.b	0
      0  2e03					      EVAL8	0
      1  2e03				  -	      IF	(0 > 127) || (0 < -128)
      2  2e03				  -	      ECHO	"Erroneous position value", 0
      3  2e03				  -	      ERR
      4  2e03					      ENDIF
      5  2e03		       00		      .byte.b	0
      0  2e04					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  2e04					      EVAL8	-30
      1  2e04				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e04				  -	      ECHO	"Erroneous position value", -30
      3  2e04				  -	      ERR
      4  2e04					      ENDIF
      5  2e04		       e2		      .byte.b	-30
      0  2e05					      EVAL8	-10
      1  2e05				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e05				  -	      ECHO	"Erroneous position value", -10
      3  2e05				  -	      ERR
      4  2e05					      ENDIF
      5  2e05		       f6		      .byte.b	-10
      0  2e06					      EVAL8	20
      1  2e06				  -	      IF	(20 > 127) || (20 < -128)
      2  2e06				  -	      ECHO	"Erroneous position value", 20
      3  2e06				  -	      ERR
      4  2e06					      ENDIF
      5  2e06		       14		      .byte.b	20
      0  2e07					      EVAL8	30
      1  2e07				  -	      IF	(30 > 127) || (30 < -128)
      2  2e07				  -	      ECHO	"Erroneous position value", 30
      3  2e07				  -	      ERR
      4  2e07					      ENDIF
      5  2e07		       1e		      .byte.b	30
      0  2e08					      EVAL8	30
      1  2e08				  -	      IF	(30 > 127) || (30 < -128)
      2  2e08				  -	      ECHO	"Erroneous position value", 30
      3  2e08				  -	      ERR
      4  2e08					      ENDIF
      5  2e08		       1e		      .byte.b	30
      0  2e09					      EVAL8	20
      1  2e09				  -	      IF	(20 > 127) || (20 < -128)
      2  2e09				  -	      ECHO	"Erroneous position value", 20
      3  2e09				  -	      ERR
      4  2e09					      ENDIF
      5  2e09		       14		      .byte.b	20
      0  2e0a					      EVAL8	-10
      1  2e0a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e0a				  -	      ECHO	"Erroneous position value", -10
      3  2e0a				  -	      ERR
      4  2e0a					      ENDIF
      5  2e0a		       f6		      .byte.b	-10
      0  2e0b					      EVAL8	-30
      1  2e0b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e0b				  -	      ECHO	"Erroneous position value", -30
      3  2e0b				  -	      ERR
      4  2e0b					      ENDIF
      5  2e0b		       e2		      .byte.b	-30
      0  2e0c					      EVAL8	0
      1  2e0c				  -	      IF	(0 > 127) || (0 < -128)
      2  2e0c				  -	      ECHO	"Erroneous position value", 0
      3  2e0c				  -	      ERR
      4  2e0c					      ENDIF
      5  2e0c		       00		      .byte.b	0
      0  2e0d					      EVAL8	0
      1  2e0d				  -	      IF	(0 > 127) || (0 < -128)
      2  2e0d				  -	      ECHO	"Erroneous position value", 0
      3  2e0d				  -	      ERR
      4  2e0d					      ENDIF
      5  2e0d		       00		      .byte.b	0
      0  2e0e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  2e0e					      EVAL8	-30
      1  2e0e				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e0e				  -	      ECHO	"Erroneous position value", -30
      3  2e0e				  -	      ERR
      4  2e0e					      ENDIF
      5  2e0e		       e2		      .byte.b	-30
      0  2e0f					      EVAL8	-10
      1  2e0f				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e0f				  -	      ECHO	"Erroneous position value", -10
      3  2e0f				  -	      ERR
      4  2e0f					      ENDIF
      5  2e0f		       f6		      .byte.b	-10
      0  2e10					      EVAL8	30
      1  2e10				  -	      IF	(30 > 127) || (30 < -128)
      2  2e10				  -	      ECHO	"Erroneous position value", 30
      3  2e10				  -	      ERR
      4  2e10					      ENDIF
      5  2e10		       1e		      .byte.b	30
      0  2e11					      EVAL8	40
      1  2e11				  -	      IF	(40 > 127) || (40 < -128)
      2  2e11				  -	      ECHO	"Erroneous position value", 40
      3  2e11				  -	      ERR
      4  2e11					      ENDIF
      5  2e11		       28		      .byte.b	40
      0  2e12					      EVAL8	40
      1  2e12				  -	      IF	(40 > 127) || (40 < -128)
      2  2e12				  -	      ECHO	"Erroneous position value", 40
      3  2e12				  -	      ERR
      4  2e12					      ENDIF
      5  2e12		       28		      .byte.b	40
      0  2e13					      EVAL8	30
      1  2e13				  -	      IF	(30 > 127) || (30 < -128)
      2  2e13				  -	      ECHO	"Erroneous position value", 30
      3  2e13				  -	      ERR
      4  2e13					      ENDIF
      5  2e13		       1e		      .byte.b	30
      0  2e14					      EVAL8	-10
      1  2e14				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e14				  -	      ECHO	"Erroneous position value", -10
      3  2e14				  -	      ERR
      4  2e14					      ENDIF
      5  2e14		       f6		      .byte.b	-10
      0  2e15					      EVAL8	-30
      1  2e15				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e15				  -	      ECHO	"Erroneous position value", -30
      3  2e15				  -	      ERR
      4  2e15					      ENDIF
      5  2e15		       e2		      .byte.b	-30
      0  2e16					      EVAL8	0
      1  2e16				  -	      IF	(0 > 127) || (0 < -128)
      2  2e16				  -	      ECHO	"Erroneous position value", 0
      3  2e16				  -	      ERR
      4  2e16					      ENDIF
      5  2e16		       00		      .byte.b	0
      0  2e17					      EVAL8	0
      1  2e17				  -	      IF	(0 > 127) || (0 < -128)
      2  2e17				  -	      ECHO	"Erroneous position value", 0
      3  2e17				  -	      ERR
      4  2e17					      ENDIF
      5  2e17		       00		      .byte.b	0
      0  2e18					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  2e18					      EVAL8	-30
      1  2e18				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e18				  -	      ECHO	"Erroneous position value", -30
      3  2e18				  -	      ERR
      4  2e18					      ENDIF
      5  2e18		       e2		      .byte.b	-30
      0  2e19					      EVAL8	-10
      1  2e19				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e19				  -	      ECHO	"Erroneous position value", -10
      3  2e19				  -	      ERR
      4  2e19					      ENDIF
      5  2e19		       f6		      .byte.b	-10
      0  2e1a					      EVAL8	30
      1  2e1a				  -	      IF	(30 > 127) || (30 < -128)
      2  2e1a				  -	      ECHO	"Erroneous position value", 30
      3  2e1a				  -	      ERR
      4  2e1a					      ENDIF
      5  2e1a		       1e		      .byte.b	30
      0  2e1b					      EVAL8	40
      1  2e1b				  -	      IF	(40 > 127) || (40 < -128)
      2  2e1b				  -	      ECHO	"Erroneous position value", 40
      3  2e1b				  -	      ERR
      4  2e1b					      ENDIF
      5  2e1b		       28		      .byte.b	40
      0  2e1c					      EVAL8	40
      1  2e1c				  -	      IF	(40 > 127) || (40 < -128)
      2  2e1c				  -	      ECHO	"Erroneous position value", 40
      3  2e1c				  -	      ERR
      4  2e1c					      ENDIF
      5  2e1c		       28		      .byte.b	40
      0  2e1d					      EVAL8	30
      1  2e1d				  -	      IF	(30 > 127) || (30 < -128)
      2  2e1d				  -	      ECHO	"Erroneous position value", 30
      3  2e1d				  -	      ERR
      4  2e1d					      ENDIF
      5  2e1d		       1e		      .byte.b	30
      0  2e1e					      EVAL8	-10
      1  2e1e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e1e				  -	      ECHO	"Erroneous position value", -10
      3  2e1e				  -	      ERR
      4  2e1e					      ENDIF
      5  2e1e		       f6		      .byte.b	-10
      0  2e1f					      EVAL8	-30
      1  2e1f				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e1f				  -	      ECHO	"Erroneous position value", -30
      3  2e1f				  -	      ERR
      4  2e1f					      ENDIF
      5  2e1f		       e2		      .byte.b	-30
      0  2e20					      EVAL8	0
      1  2e20				  -	      IF	(0 > 127) || (0 < -128)
      2  2e20				  -	      ECHO	"Erroneous position value", 0
      3  2e20				  -	      ERR
      4  2e20					      ENDIF
      5  2e20		       00		      .byte.b	0
      0  2e21					      EVAL8	0
      1  2e21				  -	      IF	(0 > 127) || (0 < -128)
      2  2e21				  -	      ECHO	"Erroneous position value", 0
      3  2e21				  -	      ERR
      4  2e21					      ENDIF
      5  2e21		       00		      .byte.b	0
      0  2e22					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  2e22					      EVAL8	-30
      1  2e22				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e22				  -	      ECHO	"Erroneous position value", -30
      3  2e22				  -	      ERR
      4  2e22					      ENDIF
      5  2e22		       e2		      .byte.b	-30
      0  2e23					      EVAL8	-10
      1  2e23				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e23				  -	      ECHO	"Erroneous position value", -10
      3  2e23				  -	      ERR
      4  2e23					      ENDIF
      5  2e23		       f6		      .byte.b	-10
      0  2e24					      EVAL8	20
      1  2e24				  -	      IF	(20 > 127) || (20 < -128)
      2  2e24				  -	      ECHO	"Erroneous position value", 20
      3  2e24				  -	      ERR
      4  2e24					      ENDIF
      5  2e24		       14		      .byte.b	20
      0  2e25					      EVAL8	30
      1  2e25				  -	      IF	(30 > 127) || (30 < -128)
      2  2e25				  -	      ECHO	"Erroneous position value", 30
      3  2e25				  -	      ERR
      4  2e25					      ENDIF
      5  2e25		       1e		      .byte.b	30
      0  2e26					      EVAL8	30
      1  2e26				  -	      IF	(30 > 127) || (30 < -128)
      2  2e26				  -	      ECHO	"Erroneous position value", 30
      3  2e26				  -	      ERR
      4  2e26					      ENDIF
      5  2e26		       1e		      .byte.b	30
      0  2e27					      EVAL8	20
      1  2e27				  -	      IF	(20 > 127) || (20 < -128)
      2  2e27				  -	      ECHO	"Erroneous position value", 20
      3  2e27				  -	      ERR
      4  2e27					      ENDIF
      5  2e27		       14		      .byte.b	20
      0  2e28					      EVAL8	-10
      1  2e28				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e28				  -	      ECHO	"Erroneous position value", -10
      3  2e28				  -	      ERR
      4  2e28					      ENDIF
      5  2e28		       f6		      .byte.b	-10
      0  2e29					      EVAL8	-30
      1  2e29				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e29				  -	      ECHO	"Erroneous position value", -30
      3  2e29				  -	      ERR
      4  2e29					      ENDIF
      5  2e29		       e2		      .byte.b	-30
      0  2e2a					      EVAL8	0
      1  2e2a				  -	      IF	(0 > 127) || (0 < -128)
      2  2e2a				  -	      ECHO	"Erroneous position value", 0
      3  2e2a				  -	      ERR
      4  2e2a					      ENDIF
      5  2e2a		       00		      .byte.b	0
      0  2e2b					      EVAL8	0
      1  2e2b				  -	      IF	(0 > 127) || (0 < -128)
      2  2e2b				  -	      ECHO	"Erroneous position value", 0
      3  2e2b				  -	      ERR
      4  2e2b					      ENDIF
      5  2e2b		       00		      .byte.b	0
      0  2e2c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      0  2e2c					      EVAL8	-30
      1  2e2c				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e2c				  -	      ECHO	"Erroneous position value", -30
      3  2e2c				  -	      ERR
      4  2e2c					      ENDIF
      5  2e2c		       e2		      .byte.b	-30
      0  2e2d					      EVAL8	-20
      1  2e2d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2e2d				  -	      ECHO	"Erroneous position value", -20
      3  2e2d				  -	      ERR
      4  2e2d					      ENDIF
      5  2e2d		       ec		      .byte.b	-20
      0  2e2e					      EVAL8	-10
      1  2e2e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e2e				  -	      ECHO	"Erroneous position value", -10
      3  2e2e				  -	      ERR
      4  2e2e					      ENDIF
      5  2e2e		       f6		      .byte.b	-10
      0  2e2f					      EVAL8	0
      1  2e2f				  -	      IF	(0 > 127) || (0 < -128)
      2  2e2f				  -	      ECHO	"Erroneous position value", 0
      3  2e2f				  -	      ERR
      4  2e2f					      ENDIF
      5  2e2f		       00		      .byte.b	0
      0  2e30					      EVAL8	0
      1  2e30				  -	      IF	(0 > 127) || (0 < -128)
      2  2e30				  -	      ECHO	"Erroneous position value", 0
      3  2e30				  -	      ERR
      4  2e30					      ENDIF
      5  2e30		       00		      .byte.b	0
      0  2e31					      EVAL8	-10
      1  2e31				  -	      IF	(-10 > 127) || (-10 < -128)
      2  2e31				  -	      ECHO	"Erroneous position value", -10
      3  2e31				  -	      ERR
      4  2e31					      ENDIF
      5  2e31		       f6		      .byte.b	-10
      0  2e32					      EVAL8	-20
      1  2e32				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2e32				  -	      ECHO	"Erroneous position value", -20
      3  2e32				  -	      ERR
      4  2e32					      ENDIF
      5  2e32		       ec		      .byte.b	-20
      0  2e33					      EVAL8	-30
      1  2e33				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e33				  -	      ECHO	"Erroneous position value", -30
      3  2e33				  -	      ERR
      4  2e33					      ENDIF
      5  2e33		       e2		      .byte.b	-30
      0  2e34					      EVAL8	0
      1  2e34				  -	      IF	(0 > 127) || (0 < -128)
      2  2e34				  -	      ECHO	"Erroneous position value", 0
      3  2e34				  -	      ERR
      4  2e34					      ENDIF
      5  2e34		       00		      .byte.b	0
      0  2e35					      EVAL8	0
      1  2e35				  -	      IF	(0 > 127) || (0 < -128)
      2  2e35				  -	      ECHO	"Erroneous position value", 0
      3  2e35				  -	      ERR
      4  2e35					      ENDIF
      5  2e35		       00		      .byte.b	0
      0  2e36					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      0  2e36					      EVAL8	-50
      1  2e36				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2e36				  -	      ECHO	"Erroneous position value", -50
      3  2e36				  -	      ERR
      4  2e36					      ENDIF
      5  2e36		       ce		      .byte.b	-50
      0  2e37					      EVAL8	-40
      1  2e37				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2e37				  -	      ECHO	"Erroneous position value", -40
      3  2e37				  -	      ERR
      4  2e37					      ENDIF
      5  2e37		       d8		      .byte.b	-40
      0  2e38					      EVAL8	-30
      1  2e38				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e38				  -	      ECHO	"Erroneous position value", -30
      3  2e38				  -	      ERR
      4  2e38					      ENDIF
      5  2e38		       e2		      .byte.b	-30
      0  2e39					      EVAL8	-20
      1  2e39				  -	      IF	(-20 > 127) || (-20 < -128)
      2  2e39				  -	      ECHO	"Erroneous position value", -20
      3  2e39				  -	      ERR
      4  2e39					      ENDIF
      5  2e39		       ec		      .byte.b	-20
      0  2e3a					      EVAL8	- 20
      1  2e3a				  -	      IF	(- 20 > 127) || (- 20 < -128)
      2  2e3a				  -	      ECHO	"Erroneous position value", - 20
      3  2e3a				  -	      ERR
      4  2e3a					      ENDIF
      5  2e3a		       ec		      .byte.b	- 20
      0  2e3b					      EVAL8	-30
      1  2e3b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  2e3b				  -	      ECHO	"Erroneous position value", -30
      3  2e3b				  -	      ERR
      4  2e3b					      ENDIF
      5  2e3b		       e2		      .byte.b	-30
      0  2e3c					      EVAL8	-40
      1  2e3c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  2e3c				  -	      ECHO	"Erroneous position value", -40
      3  2e3c				  -	      ERR
      4  2e3c					      ENDIF
      5  2e3c		       d8		      .byte.b	-40
      0  2e3d					      EVAL8	-50
      1  2e3d				  -	      IF	(-50 > 127) || (-50 < -128)
      2  2e3d				  -	      ECHO	"Erroneous position value", -50
      3  2e3d				  -	      ERR
      4  2e3d					      ENDIF
      5  2e3d		       ce		      .byte.b	-50
      0  2e3e					      EVAL8	0
      1  2e3e				  -	      IF	(0 > 127) || (0 < -128)
      2  2e3e				  -	      ECHO	"Erroneous position value", 0
      3  2e3e				  -	      ERR
      4  2e3e					      ENDIF
      5  2e3e		       00		      .byte.b	0
      0  2e3f					      EVAL8	0
      1  2e3f				  -	      IF	(0 > 127) || (0 < -128)
      2  2e3f				  -	      ECHO	"Erroneous position value", 0
      3  2e3f				  -	      ERR
      4  2e3f					      ENDIF
      5  2e3f		       00		      .byte.b	0
    155  2e40
    156  2e40
    157  2e40
      0  2e40					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  2e40		       02 40	   .TEMP      =	* - _BANK_START
 BANK_EVAL (1K) SIZE =  $240 , FREE= $1c0
      2  2e40					      ECHO	"BANK_EVAL", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  2e40				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2e40				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_EVAL", " size=", * - ORIGIN
      5  2e40				  -	      ERR
      6  2e40					      ENDIF
    159  2e40
    160  2e40							;---------------------------------------------------------------------------------------------------
    161  2e40							; EOF
------- FILE ./chess.asm
    561  2e40
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0  2e40					      include	"SHADOW_BOARD.asm"
      1  2e40							; Copyright (C)2020 Andrew Davie
      2  2e40
      3  2e40
      4  2e40							;---------------------------------------------------------------------------------------------------
      0  2e40					      SLOT	3
      1  2e40				  -	      IF	(3 < 0) || (3 > 3)
      2  2e40				  -	      ECHO	"Illegal bank address/segment location", 3
      3  2e40				  -	      ERR
      4  2e40					      ENDIF
      5  2e40				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      6  2e40				   _BANK_SLOT SET	3 * 64
      0  2e40					      RAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1  2e40
      2 U2400 ????				      SEG.U	RAM_BOARD
      3 U2400					      ORG	ORIGIN_RAM
      4 U2400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2400				   _BANK_START SET	*
      6 U2400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2400				   RAMBANK_BOARD SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2400				   _LAST_BANK SETSTR	BOARD
     10 U2400
      7 U2400
      8 U2400		       fc 15	   ValidSquare =	ShadowValidSquare + $400
      9 U2400		       fc 79	   Board      =	ShadowBoard + $400
     10 U2400
      0 U2400					      SLOT	2
      1 U2400				  -	      IF	(2 < 0) || (2 > 3)
      2 U2400				  -	      ECHO	"Illegal bank address/segment location", 2
      3 U2400				  -	      ERR
      4 U2400					      ENDIF
      5 U2400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6 U2400				   _BANK_SLOT SET	2 * 64
      0 U2400					      ROMBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  30dd ????				      SEG	SHADOW_BOARD
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   SHADOW_BOARD_START SET	*
      6  3000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3000				   SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + 1024
     13  3000
     14  3000							; Board is a 10 x 12 object which simplifies the generation of moves
     15  3000							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     16  3000							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     17  3000
     18  3000							;     X12 numbering
     19  3000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     20  3000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     21  3000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     22  3000							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     23  3000							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     24  3000							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     25  3000							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     26  3000							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     27  3000							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     28  3000							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     29  3000							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     30  3000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     31  3000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     32  3000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     33  3000							;	0   1	2   3	4   5	6   7	8   9
     34  3000							;		A   B	C   D	E   F	G   H
     35  3000
     36  3000							;     HEX X12
     37  3000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     38  3000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     39  3000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     40  3000							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     41  3000							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     42  3000							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     43  3000							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     44  3000							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     45  3000							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     46  3000							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     47  3000							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     48  3000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     49  3000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     50  3000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     51  3000							;	0   1	2   3	4   5	6   7	8   9
     52  3000							;		A   B	C   D	E   F	G   H
     53  3000
     54  3000
     55  3000							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     56  3000							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     57  3000							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     58  3000							; be re-used for something else - we just need to guarantee there are 21 of them there
     59  3000
      0  3000					      ALLOCATE	Valid, 120 + 80 + 21
      0  3000					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 21
     12  3000					      LIST	ON
      0  3000					      DEF	Valid
      1  3000				   SLOT_Valid SET	_BANK_SLOT
      2  3000				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  3000				   Valid
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	Valid
     61  3000		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     62  3015							; Note, we will never index INTO the above bytes - x will always be >= 21
     63  3015							; We just need to make sure that the actual indexing will not have an address before
     64  3015							; the index of outside the page.
     65  3015
      0  3015					      DEF	ShadowValidSquare
      1  3015				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  3015				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  3015				   ShadowValidSquare
      4  3015				   TEMPORARY_VAR SET	Overlay
      5  3015				   TEMPORARY_OFFSET SET	0
      6  3015				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  3015				   FUNCTION_NAME SET	ShadowValidSquare
     67  3015
     68  3015
     69  3015							; Use this table to
     70  3015							;   a) Determine if a square is valid (-1 = NO)
     71  3015							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     72  3015							;	if a white pawn on square "x" can move "up" the board.
     73  3015
     74  3015		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     75  301f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     76  3029		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     77  3033		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     78  303d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     79  3047		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     80  3051		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     81  305b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     82  3065		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     83  306f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     84  3079
      0  3079					      DEF	ShadowBoard
      1  3079				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  3079				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  3079				   ShadowBoard
      4  3079				   TEMPORARY_VAR SET	Overlay
      5  3079				   TEMPORARY_OFFSET SET	0
      6  3079				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  3079				   FUNCTION_NAME SET	ShadowBoard
     86  3079
     87  3079							; A 10X10... we should never write using invalid square
     88  3079							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     89  3079							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     90  3079
     91  3079		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     92  3083		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     93  308d
     94  308d					      REPEAT	8
     95  308d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  308d					      REPEND
     95  3097		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  3097					      REPEND
     95  30a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  30a1					      REPEND
     95  30ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  30ab					      REPEND
     95  30b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  30b5					      REPEND
     95  30bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  30bf					      REPEND
     95  30c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     94  30c9					      REPEND
     95  30d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
     96  30dd					      REPEND
     97  30dd
     98  30dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
     99  30dd
    100  30dd
    101  30dd							;---------------------------------------------------------------------------------------------------
    102  30dd							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#1.asm LEVEL 2 PASS 4
      0  30dd					      include	"BANK_StateMachine@1#1.asm"
      0  30dd					      SLOT	1
      1  30dd				  -	      IF	(1 < 0) || (1 > 3)
      2  30dd				  -	      ECHO	"Illegal bank address/segment location", 1
      3  30dd				  -	      ERR
      4  30dd					      ENDIF
      5  30dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  30dd				   _BANK_SLOT SET	1 * 64
      0  30dd					      ROMBANK	STATEMACHINE
      1  37d1 ????				      SEG	STATEMACHINE
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   STATEMACHINE_START SET	*
      6  3400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3400				   STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + 1024
      3  3400
      4  3400
      5  3400							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      6  3400
      7  3400
      8  3400		       00 10	   CURSOR_MOVE_SPEED =	16
      9  3400		       00 14	   CAP_SPEED  =	20
     10  3400		       00 28	   HOLD_DELAY =	40
     11  3400
     12  3400
     13  3400							;---------------------------------------------------------------------------------------------------
     14  3400
     15  3400
     16  3400							;---------------------------------------------------------------------------------------------------
     17  3400
      0  3400					      DEF	aiStartMoveGen
      1  3400				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  3400				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  3400				   aiStartMoveGen
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	aiStartMoveGen
     19  3400					      SUBROUTINE
     20  3400
      0  3400					      REFER	AiStateMachine
      1  3400					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3400				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3400					      ENDIF
      0  3400					      VEND	aiStartMoveGen
      1  3400				  -	      IFNCONST	aiStartMoveGen
      2  3400				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  3400				  -	      ERR
      4  3400					      ENDIF
      5  3400		       00 a9	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
     23  3400
     24  3400							; To assist with castling, generate the moves for the opponent, giving us effectively
     25  3400							; a list of squares that are being attacked. The castling can't happen if the king is
     26  3400							; in check or if the squares it would have to move over are in check
     27  3400
     28  3400							; we don't need to worry about this if K has moved, or relevant R has moved or if
     29  3400							; the squares between are occupied. We can tell THAT by examining the movelist to see
     30  3400							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     31  3400
     32  3400							;inc currentPly
     33  3400							;jsr InitialiseMoveGeneration
     34  3400
      0  3400					      PHASE	AI_StepMoveGen
      1  3400		       a9 0c		      lda	#AI_StepMoveGen
      2  3402		       85 8b		      sta	aiState
     36  3404		       60		      rts
     37  3405
     38  3405
     39  3405							;---------------------------------------------------------------------------------------------------
     40  3405
      0  3405					      DEF	aiInCheckBackup
      1  3405				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  3405				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  3405				   aiInCheckBackup
      4  3405				   TEMPORARY_VAR SET	Overlay
      5  3405				   TEMPORARY_OFFSET SET	0
      6  3405				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  3405				   FUNCTION_NAME SET	aiInCheckBackup
     42  3405					      SUBROUTINE
     43  3405
      0  3405					      REFER	AiStateMachine
      1  3405					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3405				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3405					      ENDIF
      0  3405					      VEND	aiInCheckBackup
      1  3405				  -	      IFNCONST	aiInCheckBackup
      2  3405				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  3405				  -	      ERR
      4  3405					      ENDIF
      5  3405		       00 a9	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
     46  3405
     47  3405							; We're about to draw some large text on the screen
     48  3405							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     49  3405
     50  3405		       c6 84		      dec	drawCount
     51  3407		       30 02		      bmi	.exit	; done all rows
     52  3409		       a4 84		      ldy	drawCount
     53  340b				  -	      IF	0
     54  340b				  -	      jmp	SAFE_BackupBitmaps
     55  340b					      ENDIF
     56  340b
      0  340b				   .exit      PHASE	AI_InCheckDelay
      1  340b		       a9 1e		      lda	#AI_InCheckDelay
      2  340d		       85 8b		      sta	aiState
     58  340f		       60		      rts
     59  3410
     60  3410
     61  3410							;---------------------------------------------------------------------------------------------------
     62  3410
      0  3410					      DEF	aiInCheckDelay
      1  3410				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  3410				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  3410				   aiInCheckDelay
      4  3410				   TEMPORARY_VAR SET	Overlay
      5  3410				   TEMPORARY_OFFSET SET	0
      6  3410				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  3410				   FUNCTION_NAME SET	aiInCheckDelay
     64  3410					      SUBROUTINE
     65  3410
      0  3410					      REFER	AiStateMachine
      1  3410					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3410				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3410					      ENDIF
      0  3410					      VEND	aiInCheckDelay
      1  3410				  -	      IFNCONST	aiInCheckDelay
      2  3410				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  3410				  -	      ERR
      4  3410					      ENDIF
      5  3410		       00 a9	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
     68  3410
     69  3410		       c6 89		      dec	mdelay
     70  3412		       d0 08		      bne	.exit
     71  3414
     72  3414		       a9 00		      lda	#0
     73  3416		       85 49		      sta	COLUBK
     74  3418
      0  3418					      PHASE	AI_BeginSelectMovePhase
      1  3418		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  341a		       85 8b		      sta	aiState
     76  341c		       60	   .exit      rts
     77  341d
     78  341d
     79  341d							;---------------------------------------------------------------------------------------------------
     80  341d
      0  341d					      DEF	aiBeginSelectMovePhase
      1  341d				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  341d				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  341d				   aiBeginSelectMovePhase
      4  341d				   TEMPORARY_VAR SET	Overlay
      5  341d				   TEMPORARY_OFFSET SET	0
      6  341d				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  341d				   FUNCTION_NAME SET	aiBeginSelectMovePhase
     82  341d					      SUBROUTINE
     83  341d
      0  341d					      REFER	AiStateMachine
      1  341d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  341d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  341d					      ENDIF
      0  341d					      VEND	aiBeginSelectMovePhase
      1  341d				  -	      IFNCONST	aiBeginSelectMovePhase
      2  341d				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  341d				  -	      ERR
      4  341d					      ENDIF
      5  341d		       00 a9	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
     86  341d
     87  341d
     88  341d		       a9 04		      lda	#$4
     89  341f		       85 46		      sta	COLUP0
     90  3421		       a2 04		      ldx	#%100
     91  3423		       86 4a		      stx	CTRLPF	; under
     92  3425
     93  3425		       a9 00		      lda	#0
     94  3427		       85 89		      sta	mdelay	;?
     95  3429		       85 8e		      sta	aiFlashPhase	; odd/even for flashing pieces
     96  342b
     97  342b		       a9 28		      lda	#CAP_SPEED*2
     98  342d		       85 8c		      sta	aiFlashDelay
     99  342f
    100  342f		       a9 ff		      lda	#-1
    101  3431		       85 85		      sta	fromX12
    102  3433		       85 86		      sta	toX12
    103  3435
    104  3435		       46 a1		      lsr	randomness
    105  3437
    106  3437
      0  3437					      PHASE	AI_FlashComputerMove
      1  3437		       a9 00		      lda	#AI_FlashComputerMove
      2  3439		       85 8b		      sta	aiState
    108  343b		       60		      rts
    109  343c
    110  343c							;---------------------------------------------------------------------------------------------------
    111  343c
      0  343c					      DEF	aiFlashComputerMove
      1  343c				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  343c				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  343c				   aiFlashComputerMove
      4  343c				   TEMPORARY_VAR SET	Overlay
      5  343c				   TEMPORARY_OFFSET SET	0
      6  343c				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  343c				   FUNCTION_NAME SET	aiFlashComputerMove
    113  343c					      SUBROUTINE
    114  343c
      0  343c					      REFER	AiStateMachine
      1  343c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  343c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  343c					      ENDIF
      0  343c					      VEND	aiFlashComputerMove
      1  343c				  -	      IFNCONST	aiFlashComputerMove
      2  343c				  -	      ECHO	"Incorrect VEND label", aiFlashComputerMove
      3  343c				  -	      ERR
      4  343c					      ENDIF
      5  343c		       00 a9	   VAREND_aiFlashComputerMove =	TEMPORARY_VAR
    117  343c
    118  343c		       a5 80		      lda	squareToDraw
    119  343e		       30 30		      bmi	.initial2	; startup - no computer move to show
    120  3440
    121  3440		       a5 8e		      lda	aiFlashPhase
    122  3442		       4a		      lsr
    123  3443		       b0 0c		      bcs	.noSwapside	; only check for SELECT/exit if piece is drawn
    124  3445
    125  3445		       ad 82 02 	      lda	SWCHB
    126  3448		       29 02		      and	#SELECT_SWITCH
    127  344a		       d0 05		      bne	.noSwapside
    128  344c
      0  344c					      PHASE	AI_DebounceSelect
      1  344c		       a9 2b		      lda	#AI_DebounceSelect
      2  344e		       85 8b		      sta	aiState
    130  3450		       60		      rts
    131  3451				   .noSwapside
    132  3451
    133  3451							; "squareToDraw" is the piece that should flash while human waits
    134  3451
    135  3451		       ad 80 02 	      lda	SWCHA
    136  3454		       29 f0		      and	#$F0	; UDLR bits
    137  3456		       c9 f0		      cmp	#$F0	; all NOT pressed
    138  3458		       f0 08		      beq	.nodir
    139  345a
    140  345a							; direction has been pressed, so transition out of flashing
    141  345a
    142  345a		       a9 01		      lda	#1
    143  345c		       85 8c		      sta	aiFlashDelay
    144  345e		       25 8e		      and	aiFlashPhase
    145  3460		       f0 0e		      beq	.initial
    146  3462
    147  3462		       c6 8c	   .nodir     dec	aiFlashDelay
    148  3464		       d0 0e		      bne	.exit	; don't flash
    149  3466		       a9 28		      lda	#CAP_SPEED*2
    150  3468		       85 8c		      sta	aiFlashDelay
    151  346a
    152  346a		       e6 8e		      inc	aiFlashPhase
    153  346c
    154  346c							; WARNING - local variables will not survive the following call...!
    155  346c		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    156  346f		       60		      rts
    157  3470
    158  3470				   .initial
    159  3470
    160  3470							;SWAP
      0  3470				   .initial2  PHASE	AI_SelectStartSquare
      1  3470		       a9 02		      lda	#AI_SelectStartSquare
      2  3472		       85 8b		      sta	aiState
    162  3474
    163  3474		       60	   .exit      rts
    164  3475
    165  3475
    166  3475							;---------------------------------------------------------------------------------------------------
    167  3475
      0  3475					      DEF	aiSelectStartSquare
      1  3475				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  3475				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  3475				   aiSelectStartSquare
      4  3475				   TEMPORARY_VAR SET	Overlay
      5  3475				   TEMPORARY_OFFSET SET	0
      6  3475				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  3475				   FUNCTION_NAME SET	aiSelectStartSquare
    169  3475					      SUBROUTINE
    170  3475
      0  3475					      REFER	AiStateMachine
      1  3475					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3475				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3475					      ENDIF
      0  3475					      VEND	aiSelectStartSquare
      1  3475				  -	      IFNCONST	aiSelectStartSquare
      2  3475				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  3475				  -	      ERR
      4  3475					      ENDIF
      5  3475		       00 a9	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    173  3475
      0  3475					      NEXT_RANDOM
      1  3475		       a5 81		      lda	rnd
      2  3477		       4a		      lsr
      3  3478		       90 02		      bcc	.skipEOR
      4  347a		       49 fe		      eor	#RND_EOR_VAL
      5  347c		       85 81	   .skipEOR   sta	rnd
    175  347e
    176  347e		       ad 82 02 	      lda	SWCHB
    177  3481		       29 02		      and	#SELECT_SWITCH
    178  3483		       f0 34		      beq	.swapside
    179  3485
      0  3485					      CALL	moveCursor	;@2
      1  3485				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  3485				  -FNAME      SETSTR	moveCursor
      3  3485				  -	      ECHO	""
      4  3485				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  3485				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  3485				  -	      ERR
      7  3485					      ENDIF
      8  3485		       a9 98		      lda	#BANK_moveCursor
      9  3487		       85 3f		      sta	SET_BANK
     10  3489		       20 00 f8 	      jsr	moveCursor
    181  348c
    182  348c							; Search the player's movelist for the square, so we can set cursor colour
    183  348c
    184  348c		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
    185  348e		       85 3e		      sta	SET_BANK_RAM	;@2
    186  3490
    187  3490		       a5 88		      lda	cursorX12
    188  3492		       85 85		      sta	fromX12
    189  3494
      0  3494					      ldy@PLY	moveIndex
      1  3494		       ac cf f9 	      ldy	moveIndex
    191  3497		       30 0d		      bmi	.done
    192  3499
    193  3499		       d9 00 f8    .scan      cmp	MoveFrom,y
    194  349c		       f0 03		      beq	.scanned
    195  349e		       88		      dey
    196  349f		       10 f8		      bpl	.scan
    197  34a1
      0  34a1				   .scanned   lda@PLY	MovePiece,y
      1  34a1		       b9 00 f9 	      lda	MovePiece,y
    199  34a4		       85 96		      sta	fromPiece
    200  34a6
    201  34a6		       c6 8a	   .done      dec	ccur	; pulse colour for valid squares
      0  34a8					      CALL	setCursorColours
      1  34a8				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  34a8				  -FNAME      SETSTR	setCursorColours
      3  34a8				  -	      ECHO	""
      4  34a8				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  34a8				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  34a8				  -	      ERR
      7  34a8					      ENDIF
      8  34a8		       a9 98		      lda	#BANK_setCursorColours
      9  34aa		       85 3f		      sta	SET_BANK
     10  34ac		       20 4a f8 	      jsr	setCursorColours
    203  34af
    204  34af		       98		      tya
    205  34b0		       05 4c		      ora	INPT4
    206  34b2		       30 04		      bmi	.exit	; illegal square or no button press
    207  34b4
      0  34b4					      PHASE	AI_StartSquareSelected
      1  34b4		       a9 03		      lda	#AI_StartSquareSelected
      2  34b6		       85 8b		      sta	aiState
    209  34b8
    210  34b8		       60	   .exit      rts
    211  34b9
    212  34b9
    213  34b9
    214  34b9				   .swapside
    215  34b9
      0  34b9					      PHASE	AI_DebounceSelect
      1  34b9		       a9 2b		      lda	#AI_DebounceSelect
      2  34bb		       85 8b		      sta	aiState
    217  34bd		       60		      rts
    218  34be
    219  34be							;---------------------------------------------------------------------------------------------------
    220  34be
      0  34be					      DEF	aiDebounceSelect
      1  34be				   SLOT_aiDebounceSelect SET	_BANK_SLOT
      2  34be				   BANK_aiDebounceSelect SET	SLOT_aiDebounceSelect + _CURRENT_BANK
      3  34be				   aiDebounceSelect
      4  34be				   TEMPORARY_VAR SET	Overlay
      5  34be				   TEMPORARY_OFFSET SET	0
      6  34be				   VAR_BOUNDARY_aiDebounceSelect SET	TEMPORARY_OFFSET
      7  34be				   FUNCTION_NAME SET	aiDebounceSelect
    222  34be					      SUBROUTINE
    223  34be
    224  34be		       ad 82 02 	      lda	SWCHB
    225  34c1		       29 02		      and	#SELECT_SWITCH
    226  34c3		       f0 17		      beq	.exit	; SELECT still pressed
    227  34c5
    228  34c5		       a5 95		      lda	sideToMove
    229  34c7		       49 40		      eor	#HUMAN
    230  34c9		       85 95		      sta	sideToMove
    231  34cb
      0  34cb					      NEGEVAL
      1  34cb
      2  34cb		       38		      sec
      3  34cc		       a9 00		      lda	#0
      4  34ce		       e5 8f		      sbc	Evaluation
      5  34d0		       85 8f		      sta	Evaluation
      6  34d2		       a9 00		      lda	#0
      7  34d4		       e5 90		      sbc	Evaluation+1
      8  34d6		       85 90		      sta	Evaluation+1
    233  34d8
      0  34d8					      PHASE	AI_ComputerMove
      1  34d8		       a9 13		      lda	#AI_ComputerMove
      2  34da		       85 8b		      sta	aiState
    235  34dc		       60	   .exit      rts
    236  34dd
    237  34dd
    238  34dd							;---------------------------------------------------------------------------------------------------
    239  34dd
      0  34dd					      DEF	aiDrawMoves
      1  34dd				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  34dd				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  34dd				   aiDrawMoves
      4  34dd				   TEMPORARY_VAR SET	Overlay
      5  34dd				   TEMPORARY_OFFSET SET	0
      6  34dd				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  34dd				   FUNCTION_NAME SET	aiDrawMoves
    241  34dd					      SUBROUTINE
    242  34dd
      0  34dd					      REFER	AiStateMachine
      1  34dd					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  34dd				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  34dd					      ENDIF
      0  34dd					      VEND	aiDrawMoves
      1  34dd				  -	      IFNCONST	aiDrawMoves
      2  34dd				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  34dd				  -	      ERR
      4  34dd					      ENDIF
      5  34dd		       00 a9	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    245  34dd
    246  34dd		       c6 8a		      dec	ccur
      0  34df					      CALL	setCursorColours
      1  34df				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  34df				  -FNAME      SETSTR	setCursorColours
      3  34df				  -	      ECHO	""
      4  34df				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  34df				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  34df				  -	      ERR
      7  34df					      ENDIF
      8  34df		       a9 98		      lda	#BANK_setCursorColours
      9  34e1		       85 3f		      sta	SET_BANK
     10  34e3		       20 4a f8 	      jsr	setCursorColours
    248  34e6
    249  34e6		       c6 89		      dec	mdelay
    250  34e8		       d0 25		      bne	.exit
    251  34ea		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    252  34ec		       85 89		      sta	mdelay	; once triggered, runs always
    253  34ee
    254  34ee		       a5 8d		      lda	aiMoveIndex
    255  34f0		       10 09		      bpl	.valid
    256  34f2
    257  34f2		       a9 89		      lda	#RAMBANK_PLY+1
    258  34f4		       85 3e		      sta	SET_BANK_RAM	;@2
      0  34f6					      lda@PLY	moveIndex
      1  34f6		       ad cf f9 	      lda	moveIndex
    260  34f9		       85 8d		      sta	aiMoveIndex
    261  34fb				   .valid
    262  34fb
    263  34fb		       20 1c f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    264  34fe		       a5 8d		      lda	aiMoveIndex
    265  3500		       10 19		      bpl	.unsure	; still drawing in this phase
    266  3502
    267  3502		       a9 14		      lda	#CAP_SPEED
    268  3504		       85 89		      sta	mdelay
    269  3506
    270  3506		       a9 00		      lda	#0
    271  3508		       85 8e		      sta	aiFlashPhase	; controls odd/even exit of flashing
    272  350a
      0  350a					      PHASE	AI_ShowMoveCaptures
      1  350a		       a9 05		      lda	#AI_ShowMoveCaptures
      2  350c		       85 8b		      sta	aiState
    274  350e		       60		      rts
    275  350f
    276  350f				   .exit
    277  350f
    278  350f							; Initial piece selection has happened, but the button hasn't been released yet
    279  350f							; AND we're still in the waiting phase to see if the button was held long enough for move show
    280  350f
    281  350f		       a5 4c		      lda	INPT4
    282  3511		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    283  3513
    284  3513							; Aha! Button released, so we know the selected piece and can start flashing it
    285  3513							; and allowing movement of the selector to a destination square...
    286  3513
    287  3513		       a9 18		      lda	#6*4
    288  3515		       85 8a		      sta	ccur	; bright green square for selection
    289  3517
      0  3517					      PHASE	AI_SelectDestinationSquare
      1  3517		       a9 08		      lda	#AI_SelectDestinationSquare
      2  3519		       85 8b		      sta	aiState
    291  351b
    292  351b		       60	   .unsure    rts
    293  351c
    294  351c
    295  351c							;---------------------------------------------------------------------------------------------------
    296  351c
      0  351c					      DEF	showMoveOptions
      1  351c				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  351c				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  351c				   showMoveOptions
      4  351c				   TEMPORARY_VAR SET	Overlay
      5  351c				   TEMPORARY_OFFSET SET	0
      6  351c				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  351c				   FUNCTION_NAME SET	showMoveOptions
    298  351c					      SUBROUTINE
    299  351c
      0  351c					      REFER	aiDrawMoves
      1  351c					      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  351c				   TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  351c					      ENDIF
      0  351c					      REFER	aiUnDrawTargetSquares
      1  351c				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  351c				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  351c					      ENDIF
    302  351c
      0  351c					      VAR	__saveIdx, 1
      1  351c		       00 a9	   __saveIdx  =	TEMPORARY_VAR
      2  351c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  351c
      4  351c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  351c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  351c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  351c					      ENDIF
      8  351c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  351c				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  351c				  -	      ERR
     11  351c					      ENDIF
     12  351c					      LIST	ON
      0  351c					      VAR	__piece, 1
      1  351c		       00 aa	   __piece    =	TEMPORARY_VAR
      2  351c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  351c
      4  351c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  351c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  351c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  351c					      ENDIF
      8  351c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  351c				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  351c				  -	      ERR
     11  351c					      ENDIF
     12  351c					      LIST	ON
    305  351c
      0  351c					      VEND	showMoveOptions
      1  351c				  -	      IFNCONST	showMoveOptions
      2  351c				  -	      ECHO	"Incorrect VEND label", showMoveOptions
      3  351c				  -	      ERR
      4  351c					      ENDIF
      5  351c		       00 ab	   VAREND_showMoveOptions =	TEMPORARY_VAR
    307  351c
    308  351c							; place a marker on the board for any square matching the piece
    309  351c							; EXCEPT for squares which are occupied (we'll flash those later)
    310  351c
    311  351c		       a6 8d	   .next      ldx	aiMoveIndex
    312  351e		       86 a9		      stx	__saveIdx
    313  3520		       30 4c		      bmi	.skip
    314  3522
    315  3522		       ad 84 02 	      lda	INTIM
    316  3525		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    317  3527		       90 45		      bcc	.skip
    318  3529
    319  3529		       c6 8d		      dec	aiMoveIndex
    320  352b
    321  352b		       a9 89		      lda	#RAMBANK_PLY+1
    322  352d		       85 3e		      sta	SET_BANK_RAM	;@2
    323  352f
      0  352f					      lda@PLY	MoveFrom,x
      1  352f		       bd 00 f8 	      lda	MoveFrom,x
    325  3532		       c5 85		      cmp	fromX12
    326  3534		       d0 e6		      bne	.next
    327  3536
      0  3536					      lda@PLY	MoveTo,x
      1  3536		       bd 64 f8 	      lda	MoveTo,x
    329  3539		       85 80		      sta	squareToDraw
    330  353b
      0  353b					      lda@PLY	MovePiece,x
      1  353b		       bd 00 f9 	      lda	MovePiece,x
    332  353e		       85 aa		      sta	__piece
    333  3540
    334  3540							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    335  3540							; TODO this could/will fail on sorted lists. MMh.
    336  3540
    337  3540		       ca		      dex
    338  3541		       30 16		      bmi	.prom
    339  3543
      0  3543					      lda@PLY	MoveTo,x
      1  3543		       bd 64 f8 	      lda	MoveTo,x
    341  3546		       c5 80		      cmp	squareToDraw
    342  3548		       d0 0f		      bne	.prom
    343  354a
      0  354a					      lda@PLY	MovePiece,x
      1  354a		       bd 00 f9 	      lda	MovePiece,x
    345  354d		       45 aa		      eor	__piece
    346  354f		       29 0f		      and	#PIECE_MASK
    347  3551		       f0 06		      beq	.prom	; same piece type so not a promote
    348  3553
    349  3553		       c6 8d		      dec	aiMoveIndex
    350  3555		       c6 8d		      dec	aiMoveIndex
    351  3557		       c6 8d		      dec	aiMoveIndex
    352  3559				   .prom
    353  3559
    354  3559		       a4 80		      ldy	squareToDraw
    355  355b
    356  355b		       a9 d2		      lda	#RAMBANK_BOARD
    357  355d		       85 3e		      sta	SET_BANK_RAM	;@3
    358  355f		       b9 79 fc 	      lda	Board,y
    359  3562		       29 0f		      and	#PIECE_MASK
    360  3564		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    361  3566
    362  3566
    363  3566							;lda INTIM
    364  3566							;cmp #SPEEDOF_COPYSINGLEPIECE
    365  3566							;bcc .skip
    366  3566
    367  3566							;lda aiMoveIndex
    368  3566							;sta __saveIdx
    369  3566
    370  3566							; Draw the marker..."?
    371  3566							; WARNING - local variables will not survive the following call...!
    372  3566
    373  3566		       a0 1c		      ldy	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    374  3568		       20 73 f5 	      jsr	CopySetupForMarker	;@this
    375  356b		       4c c8 f0 	      jmp	InterceptMarkerCopy	;@0
    376  356e
    377  356e
    378  356e
    379  356e		       a5 a9	   .skip      lda	__saveIdx
    380  3570		       85 8d		      sta	aiMoveIndex
    381  3572		       60		      rts
    382  3573
    383  3573
    384  3573							;---------------------------------------------------------------------------------------------------
    385  3573
      0  3573					      DEF	CopySetupForMarker
      1  3573				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  3573				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  3573				   CopySetupForMarker
      4  3573				   TEMPORARY_VAR SET	Overlay
      5  3573				   TEMPORARY_OFFSET SET	0
      6  3573				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  3573				   FUNCTION_NAME SET	CopySetupForMarker
    387  3573					      SUBROUTINE
    388  3573
      0  3573					      REFER	showMoveOptions
      1  3573					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  3573				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  3573					      ENDIF
      0  3573					      REFER	showPromoteOptions
      1  3573				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  3573				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  3573					      ENDIF
    391  3573
      0  3573					      VAR	__pieceColour2b, 1
      1  3573		       00 ab	   __pieceColour2b =	TEMPORARY_VAR
      2  3573				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3573
      4  3573				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3573				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3573				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3573					      ENDIF
      8  3573				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3573				  -	      ECHO	"Temporary Variable", __pieceColour2b, "overflow!"
     10  3573				  -	      ERR
     11  3573					      ENDIF
     12  3573					      LIST	ON
      0  3573					      VAR	__tmpb, 1
      1  3573		       00 ac	   __tmpb     =	TEMPORARY_VAR
      2  3573				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3573
      4  3573				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3573				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3573				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3573					      ENDIF
      8  3573				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3573				  -	      ECHO	"Temporary Variable", __tmpb, "overflow!"
     10  3573				  -	      ERR
     11  3573					      ENDIF
     12  3573					      LIST	ON
      0  3573					      VAR	__shiftxb, 1
      1  3573		       00 ad	   __shiftxb  =	TEMPORARY_VAR
      2  3573				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3573
      4  3573				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3573				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3573				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3573					      ENDIF
      8  3573				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3573				  -	      ECHO	"Temporary Variable", __shiftxb, "overflow!"
     10  3573				  -	      ERR
     11  3573					      ENDIF
     12  3573					      LIST	ON
    395  3573
      0  3573					      VEND	CopySetupForMarker
      1  3573				  -	      IFNCONST	CopySetupForMarker
      2  3573				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  3573				  -	      ERR
      4  3573					      ENDIF
      5  3573		       00 ae	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    397  3573
    398  3573
    399  3573							; y = base shape
    400  3573							; figure colouration of square
    401  3573
    402  3573		       a5 80		      lda	squareToDraw
    403  3575
    404  3575		       a2 0a		      ldx	#10
    405  3577		       38		      sec
    406  3578		       e9 0a	   .sub10     sbc	#10
    407  357a		       ca		      dex
    408  357b		       b0 fb		      bcs	.sub10
    409  357d		       69 08		      adc	#8
    410  357f		       85 ad		      sta	__shiftxb
    411  3581		       86 ac		      stx	__tmpb
    412  3583		       65 ac		      adc	__tmpb
    413  3585
    414  3585
    415  3585		       29 01		      and	#1
    416  3587							;eor #1
    417  3587		       f0 02		      beq	.white
    418  3589		       a9 24		      lda	#36
    419  358b				   .white
    420  358b		       85 ab		      sta	__pieceColour2b	; actually SQUARE black/white
    421  358d
    422  358d		       a5 95		      lda	sideToMove
    423  358f		       0a		      asl
    424  3590		       90 02		      bcc	.blackAdjust
    425  3592		       09 10		      ora	#16	; switch white pieces
    426  3594		       4a	   .blackAdjust lsr
    427  3595		       29 0f		      and	#%1111
    428  3597		       aa		      tax
    429  3598
    430  3598		       a5 ad		      lda	__shiftxb
    431  359a		       29 03		      and	#3	; shift position in P
    432  359c		       85 ad		      sta	__shiftxb
    433  359e
    434  359e		       98		      tya
    435  359f		       18		      clc
    436  35a0		       65 ad		      adc	__shiftxb
    437  35a2		       18		      clc
    438  35a3		       65 ab		      adc	__pieceColour2b
    439  35a5		       a8		      tay
    440  35a6		       60		      rts
    441  35a7
    442  35a7
    443  35a7							;---------------------------------------------------------------------------------------------------
    444  35a7
      0  35a7					      DEF	aiUnDrawTargetSquares
      1  35a7				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  35a7				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  35a7				   aiUnDrawTargetSquares
      4  35a7				   TEMPORARY_VAR SET	Overlay
      5  35a7				   TEMPORARY_OFFSET SET	0
      6  35a7				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  35a7				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    446  35a7					      SUBROUTINE
    447  35a7
      0  35a7					      REFER	AiStateMachine
      1  35a7					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  35a7				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  35a7					      ENDIF
      0  35a7					      VEND	aiUnDrawTargetSquares
      1  35a7				  -	      IFNCONST	aiUnDrawTargetSquares
      2  35a7				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  35a7				  -	      ERR
      4  35a7					      ENDIF
      5  35a7		       00 a9	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    450  35a7
    451  35a7
    452  35a7		       c6 8a		      dec	ccur
      0  35a9					      CALL	setCursorColours
      1  35a9				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  35a9				  -FNAME      SETSTR	setCursorColours
      3  35a9				  -	      ECHO	""
      4  35a9				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  35a9				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  35a9				  -	      ERR
      7  35a9					      ENDIF
      8  35a9		       a9 98		      lda	#BANK_setCursorColours
      9  35ab		       85 3f		      sta	SET_BANK
     10  35ad		       20 4a f8 	      jsr	setCursorColours
    454  35b0
    455  35b0		       c6 89		      dec	mdelay
    456  35b2		       d0 1c		      bne	.exit
    457  35b4		       a9 01		      lda	#1
    458  35b6		       85 89		      sta	mdelay	; once triggered, runs always
    459  35b8
    460  35b8		       a5 8d		      lda	aiMoveIndex
    461  35ba		       10 09		      bpl	.valid
    462  35bc
    463  35bc		       a9 89		      lda	#RAMBANK_PLY+1
    464  35be		       85 3e		      sta	SET_BANK_RAM	;@2
      0  35c0					      lda@PLY	moveIndex
      1  35c0		       ad cf f9 	      lda	moveIndex
    466  35c3		       85 8d		      sta	aiMoveIndex
    467  35c5				   .valid
    468  35c5
    469  35c5		       20 1c f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    470  35c8		       a5 8d		      lda	aiMoveIndex
    471  35ca		       10 04		      bpl	.exit	; still drawing in this phase
    472  35cc
      0  35cc					      PHASE	AI_SelectStartSquare
      1  35cc		       a9 02		      lda	#AI_SelectStartSquare
      2  35ce		       85 8b		      sta	aiState
    474  35d0
    475  35d0		       60	   .exit      rts
    476  35d1
    477  35d1
    478  35d1							;---------------------------------------------------------------------------------------------------
    479  35d1
    480  35d1
      0  35d1					      DEF	aiShowMoveCaptures
      1  35d1				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  35d1				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  35d1				   aiShowMoveCaptures
      4  35d1				   TEMPORARY_VAR SET	Overlay
      5  35d1				   TEMPORARY_OFFSET SET	0
      6  35d1				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  35d1				   FUNCTION_NAME SET	aiShowMoveCaptures
    482  35d1					      SUBROUTINE
    483  35d1
      0  35d1					      REFER	AiStateMachine
      1  35d1					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  35d1				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  35d1					      ENDIF
      0  35d1					      VEND	aiShowMoveCaptures
      1  35d1				  -	      IFNCONST	aiShowMoveCaptures
      2  35d1				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  35d1				  -	      ERR
      4  35d1					      ENDIF
      5  35d1		       00 a9	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    486  35d1
    487  35d1							; draw/undraw ALL captured pieces
    488  35d1							; we should do this an even number of times so that pieces don't disappEOR
    489  35d1
    490  35d1		       c6 8a		      dec	ccur
      0  35d3					      CALL	setCursorColours
      1  35d3				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  35d3				  -FNAME      SETSTR	setCursorColours
      3  35d3				  -	      ECHO	""
      4  35d3				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  35d3				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  35d3				  -	      ERR
      7  35d3					      ENDIF
      8  35d3		       a9 98		      lda	#BANK_setCursorColours
      9  35d5		       85 3f		      sta	SET_BANK
     10  35d7		       20 4a f8 	      jsr	setCursorColours
    492  35da
    493  35da		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    494  35dc
    495  35dc		       a5 8d		      lda	aiMoveIndex
    496  35de		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    497  35e0		       a9 89		      lda	#RAMBANK_PLY+1
    498  35e2		       85 3e		      sta	SET_BANK_RAM	;@2
      0  35e4					      lda@PLY	moveIndex
      1  35e4		       ad cf f9 	      lda	moveIndex
    500  35e7		       85 8d		      sta	aiMoveIndex
    501  35e9				   .valid
    502  35e9
    503  35e9							;lda #BANK_showMoveCaptures
    504  35e9							;sta SET_BANK;@0
    505  35e9
    506  35e9		       20 ed f2 	      jsr	showMoveCaptures	;@0
    507  35ec		       a5 8d		      lda	aiMoveIndex
    508  35ee		       10 06		      bpl	.exit
    509  35f0
    510  35f0		       e6 8e		      inc	aiFlashPhase
    511  35f2
      0  35f2					      PHASE	AI_SlowFlash
      1  35f2		       a9 06		      lda	#AI_SlowFlash
      2  35f4		       85 8b		      sta	aiState
    513  35f6
    514  35f6		       60	   .exit      rts
    515  35f7
    516  35f7
    517  35f7							;---------------------------------------------------------------------------------------------------
    518  35f7
      0  35f7					      DEF	aiSlowFlash
      1  35f7				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  35f7				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  35f7				   aiSlowFlash
      4  35f7				   TEMPORARY_VAR SET	Overlay
      5  35f7				   TEMPORARY_OFFSET SET	0
      6  35f7				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  35f7				   FUNCTION_NAME SET	aiSlowFlash
    520  35f7					      SUBROUTINE
    521  35f7
      0  35f7					      REFER	AiStateMachine
      1  35f7					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  35f7				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  35f7					      ENDIF
      0  35f7					      VEND	aiSlowFlash
      1  35f7				  -	      IFNCONST	aiSlowFlash
      2  35f7				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  35f7				  -	      ERR
      4  35f7					      ENDIF
      5  35f7		       00 a9	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    524  35f7
    525  35f7							; Joystick button is held down, so we're displaying the available moves
    526  35f7							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    527  35f7
    528  35f7		       c6 8a		      dec	ccur
      0  35f9					      CALL	setCursorColours
      1  35f9				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  35f9				  -FNAME      SETSTR	setCursorColours
      3  35f9				  -	      ECHO	""
      4  35f9				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  35f9				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  35f9				  -	      ERR
      7  35f9					      ENDIF
      8  35f9		       a9 98		      lda	#BANK_setCursorColours
      9  35fb		       85 3f		      sta	SET_BANK
     10  35fd		       20 4a f8 	      jsr	setCursorColours
    530  3600
    531  3600		       a5 8e		      lda	aiFlashPhase
    532  3602		       29 01		      and	#1
    533  3604		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    534  3606
    535  3606		       a5 4c		      lda	INPT4
    536  3608		       30 0d		      bmi	.butpress	; exit on button release
    537  360a
    538  360a				   .notEven
    539  360a
    540  360a							; Wait for delay to expire then back and flash 'em again
    541  360a
    542  360a		       c6 89		      dec	mdelay
    543  360c		       10 08		      bpl	.slowWait
    544  360e
    545  360e		       a9 14		      lda	#CAP_SPEED
    546  3610		       85 89		      sta	mdelay
    547  3612
      0  3612					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  3612		       a9 05		      lda	#AI_ShowMoveCaptures
      2  3614		       85 8b		      sta	aiState
    549  3616
    550  3616		       60	   .slowWait  rts
    551  3617
    552  3617
    553  3617		       a9 01	   .butpress  lda	#1
    554  3619		       85 89		      sta	mdelay
    555  361b
      0  361b					      PHASE	AI_UnDrawTargetSquares
      1  361b		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  361d		       85 8b		      sta	aiState
    557  361f		       60		      rts
    558  3620
    559  3620
    560  3620							;---------------------------------------------------------------------------------------------------
    561  3620
      0  3620					      DEF	aiSelectDestinationSquare
      1  3620				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  3620				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  3620				   aiSelectDestinationSquare
      4  3620				   TEMPORARY_VAR SET	Overlay
      5  3620				   TEMPORARY_OFFSET SET	0
      6  3620				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  3620				   FUNCTION_NAME SET	aiSelectDestinationSquare
    563  3620					      SUBROUTINE
    564  3620
      0  3620					      REFER	AiStateMachine
      1  3620					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3620				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3620					      ENDIF
      0  3620					      VEND	aiSelectDestinationSquare
      1  3620				  -	      IFNCONST	aiSelectDestinationSquare
      2  3620				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  3620				  -	      ERR
      4  3620					      ENDIF
      5  3620		       00 a9	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    567  3620
    568  3620							; Piece is selected and now we're looking for a button press on a destination square
    569  3620							; we flash the piece on-and-off while we're doing that
    570  3620							; Flash the selected piece
    571  3620
    572  3620		       ad 84 02 	      lda	INTIM
    573  3623		       c9 28		      cmp	#ONCEPERFRAME
    574  3625		       90 0e		      bcc	.exit
    575  3627
    576  3627
    577  3627		       c6 8c		      dec	aiFlashDelay
    578  3629		       d0 0a		      bne	.exit	; don't flash
    579  362b		       a9 14		      lda	#CAP_SPEED
    580  362d		       85 8c		      sta	aiFlashDelay
    581  362f
    582  362f		       e6 8e		      inc	aiFlashPhase
    583  3631
    584  3631							; WARNING - local variables will not survive the following call...!
    585  3631		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    586  3634		       60		      rts
    587  3635
    588  3635				   .exit
      0  3635					      CALL	moveCursor	;@2
      1  3635				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  3635				  -FNAME      SETSTR	moveCursor
      3  3635				  -	      ECHO	""
      4  3635				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  3635				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  3635				  -	      ERR
      7  3635					      ENDIF
      8  3635		       a9 98		      lda	#BANK_moveCursor
      9  3637		       85 3f		      sta	SET_BANK
     10  3639		       20 00 f8 	      jsr	moveCursor
    590  363c
    591  363c		       ad 84 02 	      lda	INTIM
    592  363f		       c9 14		      cmp	#20
    593  3641		       90 3d		      bcc	.noButton
    594  3643
    595  3643
    596  3643		       a4 88		      ldy	cursorX12
    597  3645		       84 86		      sty	toX12
    598  3647
      0  3647					      CALL	GetPiece	;@3
      1  3647				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  3647				  -FNAME      SETSTR	GetPiece
      3  3647				  -	      ECHO	""
      4  3647				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  3647				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  3647				  -	      ERR
      7  3647					      ENDIF
      8  3647		       a9 c9		      lda	#BANK_GetPiece
      9  3649		       85 3f		      sta	SET_BANK
     10  364b		       20 00 fc 	      jsr	GetPiece
      0  364e					      CALL	setCursorColours
      1  364e				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  364e				  -FNAME      SETSTR	setCursorColours
      3  364e				  -	      ECHO	""
      4  364e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  364e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  364e				  -	      ERR
      7  364e					      ENDIF
      8  364e		       a9 98		      lda	#BANK_setCursorColours
      9  3650		       85 3f		      sta	SET_BANK
     10  3652		       20 4a f8 	      jsr	setCursorColours
    601  3655
    602  3655
    603  3655							; y = valid square
    604  3655
    605  3655		       a5 4c		      lda	INPT4
    606  3657		       30 27		      bmi	.noButton
    607  3659
    608  3659		       a5 86		      lda	toX12
    609  365b		       c5 85		      cmp	fromX12
    610  365d		       f0 0d		      beq	.cancel
    611  365f
    612  365f		       c0 ff		      cpy	#-1
    613  3661		       f0 1d		      beq	.noButton	; not a valid square
    614  3663
    615  3663		       a5 8e		      lda	aiFlashPhase
    616  3665		       29 01		      and	#1
    617  3667		       f0 13		      beq	.done
    618  3669		       85 8c		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    619  366b		       60		      rts
    620  366c
    621  366c				   .cancel
    622  366c
    623  366c		       a5 8e		      lda	aiFlashPhase
    624  366e		       29 01		      and	#1
    625  3670		       f0 05		      beq	.doCancel
    626  3672
    627  3672							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    628  3672
    629  3672		       a9 01		      lda	#1
    630  3674		       85 8c		      sta	aiFlashDelay
    631  3676		       60		      rts
    632  3677
    633  3677
      0  3677				   .doCancel  PHASE	AI_ReselectDebounce
      1  3677		       a9 0a		      lda	#AI_ReselectDebounce
      2  3679		       85 8b		      sta	aiState
    635  367b		       60		      rts
    636  367c
      0  367c				   .done      PHASE	AI_Quiescent	; destination selected!
      1  367c		       a9 09		      lda	#AI_Quiescent
      2  367e		       85 8b		      sta	aiState
    638  3680		       60	   .noButton  rts
    639  3681
    640  3681
    641  3681
    642  3681
    643  3681
    644  3681							;---------------------------------------------------------------------------------------------------
    645  3681
      0  3681					      DEF	aiRollPromotionPiece
      1  3681				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  3681				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  3681				   aiRollPromotionPiece
      4  3681				   TEMPORARY_VAR SET	Overlay
      5  3681				   TEMPORARY_OFFSET SET	0
      6  3681				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  3681				   FUNCTION_NAME SET	aiRollPromotionPiece
    647  3681					      SUBROUTINE
    648  3681
      0  3681					      REFER	AiStateMachine
      1  3681					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3681				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3681					      ENDIF
      0  3681					      VEND	aiRollPromotionPiece
      1  3681				  -	      IFNCONST	aiRollPromotionPiece
      2  3681				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  3681				  -	      ERR
      4  3681					      ENDIF
      5  3681		       00 a9	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    651  3681
    652  3681							; Flash the '?' and wait for an UDLR move
    653  3681
    654  3681		       ad 84 02 	      lda	INTIM
    655  3684		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    656  3686		       90 2b		      bcc	.exit
    657  3688
    658  3688		       ad 80 02 	      lda	SWCHA
    659  368b		       29 f0		      and	#$F0
    660  368d		       c9 f0		      cmp	#$F0
    661  368f		       f0 0a		      beq	.nojoy
    662  3691
    663  3691		       a9 00		      lda	#0
    664  3693		       85 8c		      sta	aiFlashDelay
    665  3695
    666  3695		       a5 8e		      lda	aiFlashPhase
    667  3697		       29 01		      and	#1
    668  3699		       f0 19		      beq	.even
    669  369b
    670  369b		       a5 8c	   .nojoy     lda	aiFlashDelay
    671  369d		       f0 03		      beq	.do
    672  369f		       c6 8c		      dec	aiFlashDelay
    673  36a1		       60		      rts
    674  36a2
    675  36a2				   .do
    676  36a2		       a9 1e		      lda	#30
    677  36a4		       85 8c		      sta	aiFlashDelay	; speed of "?" flashing
    678  36a6
    679  36a6
    680  36a6		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    681  36a8		       a5 95		      lda	sideToMove
    682  36aa		       10 02		      bpl	.wtm
    683  36ac		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    684  36ae				   .wtm
    685  36ae		       20 c8 f6 	      jsr	showPromoteOptions	; draw the "?"
    686  36b1
    687  36b1		       e6 8e		      inc	aiFlashPhase
    688  36b3
    689  36b3		       60	   .exit      rts
    690  36b4
    691  36b4
    692  36b4		       a9 03	   .even      lda	#3	; QUEEN
    693  36b6		       85 96		      sta	fromPiece	; cycles as index to NBRQ
    694  36b8
    695  36b8							;inc aiFlashPhase
    696  36b8
    697  36b8		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    698  36ba		       a5 95		      lda	sideToMove
    699  36bc		       10 02		      bpl	.blackStuff
    700  36be		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    701  36c0				   .blackStuff
    702  36c0
    703  36c0		       20 c8 f6 	      jsr	showPromoteOptions	; draw the initial Q
    704  36c3
      0  36c3					      PHASE	AI_ChooseDebounce
      1  36c3		       a9 22		      lda	#AI_ChooseDebounce
      2  36c5		       85 8b		      sta	aiState
    706  36c7		       60		      rts
    707  36c8
    708  36c8
    709  36c8							;---------------------------------------------------------------------------------------------------
    710  36c8
      0  36c8					      DEF	showPromoteOptions
      1  36c8				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  36c8				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  36c8				   showPromoteOptions
      4  36c8				   TEMPORARY_VAR SET	Overlay
      5  36c8				   TEMPORARY_OFFSET SET	0
      6  36c8				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  36c8				   FUNCTION_NAME SET	showPromoteOptions
    712  36c8					      SUBROUTINE
    713  36c8
      0  36c8					      REFER	aiRollPromotionPiece	;✅
      1  36c8					      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  36c8				   TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  36c8					      ENDIF
      0  36c8					      REFER	aiChoosePromotePiece	;✅
      1  36c8				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  36c8				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  36c8					      ENDIF
      0  36c8					      VEND	showPromoteOptions
      1  36c8				  -	      IFNCONST	showPromoteOptions
      2  36c8				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  36c8				  -	      ERR
      4  36c8					      ENDIF
      5  36c8		       00 a9	   VAREND_showPromoteOptions =	TEMPORARY_VAR
    717  36c8
    718  36c8							; X = character shape # (?/N/B/R/Q)
    719  36c8
    720  36c8		       a4 86		      ldy	toX12
    721  36ca		       84 80		      sty	squareToDraw
    722  36cc
    723  36cc		       8a		      txa
    724  36cd		       a8		      tay
    725  36ce
    726  36ce		       20 73 f5 	      jsr	CopySetupForMarker	;@this
    727  36d1		       4c c8 f0 	      jmp	InterceptMarkerCopy	;@0
    728  36d4
    729  36d4
    730  36d4							;---------------------------------------------------------------------------------------------------
    731  36d4
      0  36d4					      DEF	aiChoosePromotePiece
      1  36d4				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  36d4				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  36d4				   aiChoosePromotePiece
      4  36d4				   TEMPORARY_VAR SET	Overlay
      5  36d4				   TEMPORARY_OFFSET SET	0
      6  36d4				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  36d4				   FUNCTION_NAME SET	aiChoosePromotePiece
    733  36d4					      SUBROUTINE
    734  36d4
      0  36d4					      REFER	AiStateMachine
      1  36d4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  36d4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  36d4					      ENDIF
      0  36d4					      VEND	aiChoosePromotePiece
      1  36d4				  -	      IFNCONST	aiChoosePromotePiece
      2  36d4				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  36d4				  -	      ERR
      4  36d4					      ENDIF
      5  36d4		       00 a9	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
    737  36d4
    738  36d4							; Question-mark phase has exited via joystick direction
    739  36d4							; Now we cycle through the selectable pieces
    740  36d4
    741  36d4		       ad 84 02 	      lda	INTIM
    742  36d7		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    743  36d9		       90 4e		      bcc	.exit
    744  36db
    745  36db		       a5 4c		      lda	INPT4
    746  36dd		       30 0a		      bmi	.nobut	; no press
    747  36df
    748  36df							; button pressed but make sure phase is correct for exit
    749  36df
    750  36df		       a9 01		      lda	#1
    751  36e1		       85 8c		      sta	aiFlashDelay	; force quick rehash to this if phase incorrect
    752  36e3
    753  36e3		       a5 8e		      lda	aiFlashPhase
    754  36e5		       29 01		      and	#1
    755  36e7		       f0 41		      beq	.chosen	; button pressed --> selection made
    756  36e9				   .nobut
    757  36e9
    758  36e9		       ad 80 02 	      lda	SWCHA
    759  36ec		       29 f0		      and	#$F0
    760  36ee		       c9 f0		      cmp	#$F0
    761  36f0		       f0 04		      beq	.nodir	; no direction pressed
    762  36f2
    763  36f2
    764  36f2		       a9 01		      lda	#1
    765  36f4		       85 8c		      sta	aiFlashDelay
    766  36f6
    767  36f6
    768  36f6		       c6 8c	   .nodir     dec	aiFlashDelay
    769  36f8		       d0 2f		      bne	.exit
    770  36fa
    771  36fa		       a9 1e		      lda	#30
    772  36fc		       85 8c		      sta	aiFlashDelay
    773  36fe
    774  36fe		       a5 8e		      lda	aiFlashPhase
    775  3700		       4a		      lsr
    776  3701		       b0 1c		      bcs	.odd	; must wait until piece undrawn
    777  3703
    778  3703		       ad 80 02 	      lda	SWCHA
    779  3706		       29 f0		      and	#$F0
    780  3708		       c9 f0		      cmp	#$F0
    781  370a		       f0 13		      beq	.odd	; no direction pressed
    782  370c
    783  370c		       4a		      lsr
    784  370d		       4a		      lsr
    785  370e		       4a		      lsr
    786  370f		       4a		      lsr
    787  3710		       a8		      tay
    788  3711
    789  3711
    790  3711							; cycle to the next promotable piece (N/B/R/Q)
    791  3711							; TODO; use joy table for mod instead of just incrementing all the time
    792  3711
    793  3711		       18		      clc
    794  3712		       a5 96		      lda	fromPiece
    795  3714		       79 5d f8 	      adc	JoyCombined,y
    796  3717		       29 03		      and	#3
    797  3719		       85 96		      sta	fromPiece
    798  371b
      0  371b					      PHASE	AI_ChooseDebounce	; after draw, wait for release
      1  371b		       a9 22		      lda	#AI_ChooseDebounce
      2  371d		       85 8b		      sta	aiState
    800  371f
    801  371f				   .odd
    802  371f
    803  371f				   .force
    804  371f		       e6 8e		      inc	aiFlashPhase	; on/off toggle
    805  3721
    806  3721		       a4 96		      ldy	fromPiece
    807  3723		       be 49 f7 	      ldx	promotePiece,y
    808  3726		       20 c8 f6 	      jsr	showPromoteOptions	;@this
    809  3729
    810  3729		       60	   .exit      rts
    811  372a
    812  372a
    813  372a
    814  372a
    815  372a
    816  372a
    817  372a				   .chosen
    818  372a		       a5 96		      lda	fromPiece
    819  372c		       29 0f		      and	#PIECE_MASK
    820  372e		       aa		      tax
    821  372f
    822  372f		       bd 4d f7 	      lda	promoteType,x
    823  3732		       85 96		      sta	fromPiece
    824  3734
    825  3734		       a4 86		      ldy	toX12
    826  3736		       a9 d2		      lda	#RAMBANK_BOARD
    827  3738		       85 3e		      sta	SET_BANK_RAM	;@3
    828  373a		       b9 79 fc 	      lda	Board,y
    829  373d		       29 0f		      and	#PIECE_MASK
    830  373f		       f0 03		      beq	.nothing
    831  3741
    832  3741		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
    833  3744
      0  3744				   .nothing   PHASE	AI_MoveIsSelected
      1  3744		       a9 14		      lda	#AI_MoveIsSelected
      2  3746		       85 8b		      sta	aiState
    835  3748		       60		      rts
    836  3749
      0  3749					      ALLOCATE	promotePiece, 4
      0  3749					      OPTIONAL_PAGEBREAK	"Table", 4
     12  3749					      LIST	ON
      0  3749					      DEF	promotePiece
      1  3749				   SLOT_promotePiece SET	_BANK_SLOT
      2  3749				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  3749				   promotePiece
      4  3749				   TEMPORARY_VAR SET	Overlay
      5  3749				   TEMPORARY_OFFSET SET	0
      6  3749				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  3749				   FUNCTION_NAME SET	promotePiece
    838  3749		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    839  374a		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    840  374b		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    841  374c		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    842  374d
      0  374d					      ALLOCATE	promoteType,4
      0  374d					      OPTIONAL_PAGEBREAK	"Table", 4
     12  374d					      LIST	ON
      0  374d					      DEF	promoteType
      1  374d				   SLOT_promoteType SET	_BANK_SLOT
      2  374d				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  374d				   promoteType
      4  374d				   TEMPORARY_VAR SET	Overlay
      5  374d				   TEMPORARY_OFFSET SET	0
      6  374d				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  374d				   FUNCTION_NAME SET	promoteType
    844  374d		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    845  3751
    846  3751
    847  3751							;---------------------------------------------------------------------------------------------------
    848  3751
      0  3751					      DEF	aiMarchA2
      1  3751				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  3751				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  3751				   aiMarchA2
      4  3751				   TEMPORARY_VAR SET	Overlay
      5  3751				   TEMPORARY_OFFSET SET	0
      6  3751				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  3751				   FUNCTION_NAME SET	aiMarchA2
    850  3751					      SUBROUTINE
    851  3751
      0  3751					      REFER	AiStateMachine
      1  3751					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3751				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3751					      ENDIF
      0  3751					      VEND	aiMarchA2
      1  3751				  -	      IFNCONST	aiMarchA2
      2  3751				  -	      ECHO	"Incorrect VEND label", aiMarchA2
      3  3751				  -	      ERR
      4  3751					      ENDIF
      5  3751		       00 a9	   VAREND_aiMarchA2 =	TEMPORARY_VAR
    854  3751
    855  3751							; erase object in new sqare --> blank
    856  3751
    857  3751		       a4 85		      ldy	fromX12
    858  3753		       84 80		      sty	squareToDraw
    859  3755
    860  3755		       a9 d2		      lda	#RAMBANK_BOARD
    861  3757		       85 3e		      sta	SET_BANK_RAM	;@3
    862  3759		       b9 79 fc 	      lda	Board,y
    863  375c		       f0 03		      beq	.skipbl
    864  375e
    865  375e							; WARNING - local variables will not survive the following call...!
    866  375e		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    867  3761
    868  3761				   .skipbl
    869  3761		       a4 85		      ldy	fromX12
    870  3763		       84 aa		      sty	__boardIndex
    871  3765
    872  3765		       a9 d2		      lda	#RAMBANK_BOARD
    873  3767		       85 3e		      sta	SET_BANK_RAM	;@3
    874  3769		       b9 79 fc 	      lda	Board,y
    875  376c		       85 97		      sta	lastPiece	; what we are overwriting
    876  376e		       a5 96		      lda	fromPiece
    877  3770		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    878  3772		       29 df		      and	#~FLAG_ENPASSANT
    879  3774		       a4 aa		      ldy	__boardIndex
      0  3776					      sta@RAM	Board,y	; and what's actually moving there
      1  3776		       99 79 fe 	      sta	[RAM]+Board,y
    881  3779
    882  3779
      0  3779					      PHASE	AI_MarchB
      1  3779		       a9 18		      lda	#AI_MarchB
      2  377b		       85 8b		      sta	aiState
    884  377d		       60		      rts
    885  377e
    886  377e
    887  377e							;---------------------------------------------------------------------------------------------------
    888  377e
      0  377e					      DEF	aiMarchB2
      1  377e				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  377e				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  377e				   aiMarchB2
      4  377e				   TEMPORARY_VAR SET	Overlay
      5  377e				   TEMPORARY_OFFSET SET	0
      6  377e				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  377e				   FUNCTION_NAME SET	aiMarchB2
    890  377e					      SUBROUTINE
    891  377e
      0  377e					      REFER	AiStateMachine
      1  377e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  377e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  377e					      ENDIF
      0  377e					      VEND	aiMarchB2
      1  377e				  -	      IFNCONST	aiMarchB2
      2  377e				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  377e				  -	      ERR
      4  377e					      ENDIF
      5  377e		       00 a9	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    894  377e
    895  377e		       a4 83		      ldy	lastSquareX12
    896  3780		       84 80		      sty	squareToDraw
    897  3782
    898  3782		       a9 d2		      lda	#RAMBANK_BOARD
    899  3784		       85 3e		      sta	SET_BANK_RAM	;@3
    900  3786		       b9 79 fc 	      lda	Board,y
    901  3789		       f0 03		      beq	.skipbl2
    902  378b
    903  378b							; WARNING - local variables will not survive the following call...!
    904  378b		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    905  378e				   .skipbl2
    906  378e
    907  378e		       a5 85		      lda	fromX12
    908  3790		       c5 86		      cmp	toX12
    909  3792		       f0 09		      beq	xhalt
    910  3794
    911  3794		       a9 02		      lda	#2	;??? inter-move segment speed (can be 0)
    912  3796		       85 82		      sta	drawDelay
      0  3798					      PHASE	AI_MarchToTargetA
      1  3798		       a9 16		      lda	#AI_MarchToTargetA
      2  379a		       85 8b		      sta	aiState
    914  379c
    915  379c		       60		      rts
    916  379d
      0  379d				   xhalt      PHASE	AI_EPHandler
      1  379d		       a9 29		      lda	#AI_EPHandler
      2  379f		       85 8b		      sta	aiState
    918  37a1		       60		      rts
    919  37a2
    920  37a2
    921  37a2							;---------------------------------------------------------------------------------------------------
    922  37a2
      0  37a2					      DEF	aiEPHandler
      1  37a2				   SLOT_aiEPHandler SET	_BANK_SLOT
      2  37a2				   BANK_aiEPHandler SET	SLOT_aiEPHandler + _CURRENT_BANK
      3  37a2				   aiEPHandler
      4  37a2				   TEMPORARY_VAR SET	Overlay
      5  37a2				   TEMPORARY_OFFSET SET	0
      6  37a2				   VAR_BOUNDARY_aiEPHandler SET	TEMPORARY_OFFSET
      7  37a2				   FUNCTION_NAME SET	aiEPHandler
    924  37a2					      SUBROUTINE
    925  37a2
    926  37a2							;CALL EnPassantFixupDraw	  ; set enPassantPawn
    927  37a2
    928  37a2
    929  37a2		       a5 96		      lda	fromPiece
    930  37a4		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    931  37a6		       c9 60		      cmp	#FLAG_ENPASSANT|FLAG_MOVED
    932  37a8		       d0 1a		      bne	.exit
    933  37aa
    934  37aa							; we have deteced a piece DOING an en passant capture
    935  37aa							; so do the actual removal of the captured pawn...
    936  37aa							; calculate the captured pawn's square based on piece colour
    937  37aa
    938  37aa		       a9 f6		      lda	#-10
    939  37ac		       a6 96		      ldx	fromPiece
    940  37ae		       10 02		      bpl	.white
    941  37b0		       a9 0a		      lda	#10
    942  37b2				   .white
    943  37b2		       18		      clc
    944  37b3		       65 85		      adc	fromX12	; attacker destination square
    945  37b5		       85 93		      sta	enPassantPawn	; now this is the pawn to ERASE
    946  37b7
    947  37b7		       a9 05		      lda	#5	; on/off count (leave undrawn)
    948  37b9		       85 84		      sta	drawCount	; flashing for piece about to move
    949  37bb		       a9 00		      lda	#0
    950  37bd		       85 82		      sta	drawDelay
    951  37bf
      0  37bf					      PHASE	AI_EPFlash
      1  37bf		       a9 2a		      lda	#AI_EPFlash
      2  37c1		       85 8b		      sta	aiState
    953  37c3		       60		      rts
    954  37c4
    955  37c4
    956  37c4				   .exit
    957  37c4
    958  37c4		       a9 04		      lda	#4	; on/off count (leave undrawn)
    959  37c6		       85 84		      sta	drawCount	; flashing for piece about to move
    960  37c8		       a9 00		      lda	#0
    961  37ca		       85 82		      sta	drawDelay
    962  37cc
      0  37cc					      PHASE	AI_FinalFlash
      1  37cc		       a9 1b		      lda	#AI_FinalFlash
      2  37ce		       85 8b		      sta	aiState
    964  37d0		       60		      rts
    965  37d1
    966  37d1
    967  37d1							;---------------------------------------------------------------------------------------------------
    968  37d1
    969  37d1
    970  37d1							;---------------------------------------------------------------------------------------------------
    971  37d1
      0  37d1					      CHECK_BANK_SIZE	"BANK_StateMachine@1#1"
      1  37d1		       03 d1	   .TEMP      =	* - _BANK_START
 BANK_StateMachine@1#1 (1K) SIZE =  $3d1 , FREE= $2f
      2  37d1					      ECHO	"BANK_StateMachine@1#1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  37d1				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d1				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine@1#1", " size=", * - ORIGIN
      5  37d1				  -	      ERR
      6  37d1					      ENDIF
    973  37d1
    974  37d1
    975  37d1							;---------------------------------------------------------------------------------------------------
    976  37d1
    977  37d1							; EOF
------- FILE ./chess.asm
------- FILE BANK_StateMachine@1#2.asm LEVEL 2 PASS 4
      0  37d1					      include	"BANK_StateMachine@1#2.asm"
      0  37d1					      SLOT	1
      1  37d1				  -	      IF	(1 < 0) || (1 > 3)
      2  37d1				  -	      ECHO	"Illegal bank address/segment location", 1
      3  37d1				  -	      ERR
      4  37d1					      ENDIF
      5  37d1				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  37d1				   _BANK_SLOT SET	1 * 64
      0  37d1					      ROMBANK	STATEMACHINE2
      1  39f4 ????				      SEG	STATEMACHINE2
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   STATEMACHINE2_START SET	*
      6  3800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3800				   STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + 1024
      3  3800
      4  3800
      5  3800							;---------------------------------------------------------------------------------------------------
      6  3800
      0  3800					      DEF	aiChooseDebounce
      1  3800				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  3800				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  3800				   aiChooseDebounce
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	aiChooseDebounce
      8  3800					      SUBROUTINE
      9  3800
      0  3800					      REFER	AiStateMachine
      1  3800					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3800				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3800					      ENDIF
      0  3800					      VEND	aiChooseDebounce
      1  3800				  -	      IFNCONST	aiChooseDebounce
      2  3800				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  3800				  -	      ERR
      4  3800					      ENDIF
      5  3800		       00 a9	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
     12  3800
     13  3800							; We've changed promotion piece, and drawn it
     14  3800							; wait for joystick to be released before continuing
     15  3800
     16  3800		       ad 80 02 	      lda	SWCHA
     17  3803		       29 f0		      and	#$F0
     18  3805		       c9 f0		      cmp	#$F0
     19  3807		       d0 0a		      bne	.exit	; wait while joystick still pressed
     20  3809
     21  3809		       a9 01		      lda	#1
     22  380b		       85 8c		      sta	aiFlashDelay
     23  380d		       85 8e		      sta	aiFlashPhase
     24  380f
      0  380f					      PHASE	AI_ChoosePromotePiece
      1  380f		       a9 21		      lda	#AI_ChoosePromotePiece
      2  3811		       85 8b		      sta	aiState
     26  3813		       60	   .exit      rts
     27  3814
     28  3814
     29  3814							;---------------------------------------------------------------------------------------------------
     30  3814
      0  3814					      DEF	aiReselectDebounce
      1  3814				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  3814				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  3814				   aiReselectDebounce
      4  3814				   TEMPORARY_VAR SET	Overlay
      5  3814				   TEMPORARY_OFFSET SET	0
      6  3814				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  3814				   FUNCTION_NAME SET	aiReselectDebounce
     32  3814					      SUBROUTINE
     33  3814
      0  3814					      REFER	AiStateMachine
      1  3814					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3814				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3814					      ENDIF
      0  3814					      VEND	aiReselectDebounce
      1  3814				  -	      IFNCONST	aiReselectDebounce
      2  3814				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  3814				  -	      ERR
      4  3814					      ENDIF
      5  3814		       00 a9	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
     36  3814
     37  3814							; We've just cancelled the move. Wait for the button to be released
     38  3814							; and then go back to selecting a piece to move
     39  3814
     40  3814		       a5 4c		      lda	INPT4
     41  3816		       10 04		      bpl	.exit	; button still pressed, so wait
     42  3818
      0  3818					      PHASE	AI_SelectStartSquare
      1  3818		       a9 02		      lda	#AI_SelectStartSquare
      2  381a		       85 8b		      sta	aiState
     44  381c		       60	   .exit      rts
     45  381d
     46  381d
     47  381d							;---------------------------------------------------------------------------------------------------
     48  381d
      0  381d					      DEF	aiDelayAfterMove
      1  381d				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  381d				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  381d				   aiDelayAfterMove
      4  381d				   TEMPORARY_VAR SET	Overlay
      5  381d				   TEMPORARY_OFFSET SET	0
      6  381d				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  381d				   FUNCTION_NAME SET	aiDelayAfterMove
     50  381d					      SUBROUTINE
     51  381d
      0  381d					      REFER	AiStateMachine
      1  381d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  381d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  381d					      ENDIF
      0  381d					      VEND	aiDelayAfterMove
      1  381d				  -	      IFNCONST	aiDelayAfterMove
      2  381d				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  381d				  -	      ERR
      4  381d					      ENDIF
      5  381d		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
     54  381d
     55  381d		       a9 32		      lda	#50
     56  381f		       85 8c		      sta	aiFlashDelay
      0  3821					      PHASE	AI_DelayAfterMove2
      1  3821		       a9 26		      lda	#AI_DelayAfterMove2
      2  3823		       85 8b		      sta	aiState
     58  3825		       60	   .exit      rts
     59  3826
     60  3826
     61  3826							;---------------------------------------------------------------------------------------------------
     62  3826
      0  3826					      DEF	aiDelayAfterMove2
      1  3826				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  3826				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  3826				   aiDelayAfterMove2
      4  3826				   TEMPORARY_VAR SET	Overlay
      5  3826				   TEMPORARY_OFFSET SET	0
      6  3826				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  3826				   FUNCTION_NAME SET	aiDelayAfterMove2
     64  3826					      SUBROUTINE
     65  3826
      0  3826					      REFER	AiStateMachine
      1  3826					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3826				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3826					      ENDIF
      0  3826					      VEND	aiDelayAfterMove
      1  3826				  -	      IFNCONST	aiDelayAfterMove
      2  3826				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  3826				  -	      ERR
      4  3826					      ENDIF
      5  3826		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
     68  3826
     69  3826		       c6 8c		      dec	aiFlashDelay
     70  3828		       d0 04		      bne	.exit
      0  382a					      PHASE	AI_MoveIsSelected
      1  382a		       a9 14		      lda	#AI_MoveIsSelected
      2  382c		       85 8b		      sta	aiState
     72  382e		       60	   .exit      rts
     73  382f
     74  382f
     75  382f							;---------------------------------------------------------------------------------------------------
     76  382f
      0  382f					      DEF	aiDelayAfterPlaced
      1  382f				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  382f				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  382f				   aiDelayAfterPlaced
      4  382f				   TEMPORARY_VAR SET	Overlay
      5  382f				   TEMPORARY_OFFSET SET	0
      6  382f				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  382f				   FUNCTION_NAME SET	aiDelayAfterPlaced
     78  382f					      SUBROUTINE
     79  382f
      0  382f					      REFER	AiStateMachine
      1  382f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  382f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  382f					      ENDIF
      0  382f					      VEND	aiDelayAfterPlaced
      1  382f				  -	      IFNCONST	aiDelayAfterPlaced
      2  382f				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  382f				  -	      ERR
      4  382f					      ENDIF
      5  382f		       00 a9	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
     82  382f
     83  382f		       a2 4b		      ldx	#75	; delay after human move
     84  3831		       a5 95		      lda	sideToMove
     85  3833		       0a		      asl
     86  3834		       30 02		      bmi	.human
     87  3836		       a2 01		      ldx	#1	; delay after computer move
     88  3838		       86 8c	   .human     stx	aiFlashDelay
     89  383a
      0  383a					      PHASE	AI_DelayAfterPlaced2
      1  383a		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  383c		       85 8b		      sta	aiState
     91  383e		       60		      rts
     92  383f
     93  383f
     94  383f							;---------------------------------------------------------------------------------------------------
     95  383f
      0  383f					      DEF	aiDelayAfterPlaced2
      1  383f				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  383f				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  383f				   aiDelayAfterPlaced2
      4  383f				   TEMPORARY_VAR SET	Overlay
      5  383f				   TEMPORARY_OFFSET SET	0
      6  383f				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  383f				   FUNCTION_NAME SET	aiDelayAfterPlaced2
     97  383f					      SUBROUTINE
     98  383f
      0  383f					      REFER	AiStateMachine
      1  383f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  383f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  383f					      ENDIF
      0  383f					      VEND	aiDelayAfterPlaced2
      1  383f				  -	      IFNCONST	aiDelayAfterPlaced2
      2  383f				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced2
      3  383f				  -	      ERR
      4  383f					      ENDIF
      5  383f		       00 a9	   VAREND_aiDelayAfterPlaced2 =	TEMPORARY_VAR
    101  383f
    102  383f
    103  383f		       ad 82 02 	      lda	SWCHB
    104  3842		       29 02		      and	#SELECT_SWITCH
    105  3844		       d0 05		      bne	.noSwapside
    106  3846
      0  3846					      PHASE	AI_DebounceSelect
      1  3846		       a9 2b		      lda	#AI_DebounceSelect
      2  3848		       85 8b		      sta	aiState
    108  384a		       60		      rts
    109  384b				   .noSwapside
    110  384b
    111  384b
    112  384b		       c6 8c		      dec	aiFlashDelay
    113  384d		       d0 04		      bne	.exit
    114  384f
    115  384f							;SWAP
    116  384f
      0  384f					      PHASE	AI_GenerateMoves
      1  384f		       a9 12		      lda	#AI_GenerateMoves
      2  3851		       85 8b		      sta	aiState
    118  3853		       60	   .exit      rts
    119  3854
    120  3854
    121  3854							;---------------------------------------------------------------------------------------------------
    122  3854
      0  3854					      DEF	aiMarchToTargetB
      1  3854				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  3854				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  3854				   aiMarchToTargetB
      4  3854				   TEMPORARY_VAR SET	Overlay
      5  3854				   TEMPORARY_OFFSET SET	0
      6  3854				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  3854				   FUNCTION_NAME SET	aiMarchToTargetB
    124  3854					      SUBROUTINE
    125  3854
      0  3854					      REFER	AiStateMachine
      1  3854					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3854				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3854					      ENDIF
      0  3854					      VEND	aiMarchToTargetB
      1  3854				  -	      IFNCONST	aiMarchToTargetB
      2  3854				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  3854				  -	      ERR
      4  3854					      ENDIF
      5  3854		       00 a9	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    128  3854
    129  3854							; now we want to undraw the piece in the old square
    130  3854
    131  3854		       a5 82		      lda	drawDelay
    132  3856		       f0 03		      beq	.stepOne
    133  3858		       c6 82		      dec	drawDelay
    134  385a		       60		      rts
    135  385b
    136  385b				   .stepOne
    137  385b		       a5 83		      lda	lastSquareX12
    138  385d		       85 80		      sta	squareToDraw
    139  385f
    140  385f							; WARNING - local variables will not survive the following call...!
    141  385f		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    142  3862
    143  3862		       a4 83		      ldy	lastSquareX12
    144  3864		       a5 98		      lda	previousPiece
    145  3866
    146  3866		       a2 d2		      ldx	#RAMBANK_BOARD
    147  3868		       86 3e		      stx	SET_BANK_RAM	;@3
      0  386a					      sta@RAM	Board,y	; and what's actually moving there
      1  386a		       99 79 fe 	      sta	[RAM]+Board,y
    149  386d
    150  386d		       a5 97		      lda	lastPiece
    151  386f		       85 98		      sta	previousPiece
    152  3871
      0  3871					      PHASE	AI_MarchB2
      1  3871		       a9 1a		      lda	#AI_MarchB2
      2  3873		       85 8b		      sta	aiState
    154  3875		       60		      rts
    155  3876
    156  3876
    157  3876							;---------------------------------------------------------------------------------------------------
    158  3876
      0  3876					      DEF	aiPromotePawnStart
      1  3876				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  3876				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  3876				   aiPromotePawnStart
      4  3876				   TEMPORARY_VAR SET	Overlay
      5  3876				   TEMPORARY_OFFSET SET	0
      6  3876				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  3876				   FUNCTION_NAME SET	aiPromotePawnStart
    160  3876					      SUBROUTINE
    161  3876
      0  3876					      REFER	AiStateMachine
      1  3876					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3876				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3876					      ENDIF
      0  3876					      VEND	aiPromotePawnStart
      1  3876				  -	      IFNCONST	aiPromotePawnStart
      2  3876				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  3876				  -	      ERR
      4  3876					      ENDIF
      5  3876		       00 a9	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    164  3876
    165  3876
    166  3876		       ad 84 02 	      lda	INTIM
    167  3879		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    168  387b		       90 1c		      bcc	.exit
    169  387d
    170  387d		       a9 00		      lda	#0
    171  387f		       85 8e		      sta	aiFlashPhase
    172  3881		       85 8c		      sta	aiFlashDelay
    173  3883
    174  3883		       a4 86		      ldy	toX12
    175  3885		       84 80		      sty	squareToDraw
    176  3887
    177  3887		       a9 d2		      lda	#RAMBANK_BOARD
    178  3889		       85 3e		      sta	SET_BANK_RAM	;@3
    179  388b		       b9 79 fc 	      lda	Board,y
    180  388e		       29 0f		      and	#PIECE_MASK
    181  3890		       f0 03		      beq	.empty
    182  3892
    183  3892							; WARNING - local variables will not survive the following call...!
    184  3892		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    185  3895
      0  3895				   .empty     PHASE	AI_RollPromotionPiece
      1  3895		       a9 20		      lda	#AI_RollPromotionPiece
      2  3897		       85 8b		      sta	aiState
    187  3899		       60	   .exit      rts
    188  389a
    189  389a
    190  389a							;---------------------------------------------------------------------------------------------------
    191  389a
      0  389a					      DEF	aiGenerateMoves
      1  389a				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  389a				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  389a				   aiGenerateMoves
      4  389a				   TEMPORARY_VAR SET	Overlay
      5  389a				   TEMPORARY_OFFSET SET	0
      6  389a				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  389a				   FUNCTION_NAME SET	aiGenerateMoves
    193  389a					      SUBROUTINE
    194  389a
      0  389a					      REFER	AiStateMachine
      1  389a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  389a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  389a					      ENDIF
      0  389a					      VEND	aiGenerateMoves
      1  389a				  -	      IFNCONST	aiGenerateMoves
      2  389a				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  389a				  -	      ERR
      4  389a					      ENDIF
      5  389a		       00 a9	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    197  389a
    198  389a		       a5 86		      lda	toX12
    199  389c		       85 80		      sta	squareToDraw	; for showing move (display square)
    200  389e
    201  389e		       a5 95		      lda	sideToMove
    202  38a0		       0a		      asl
    203  38a1		       30 05		      bmi	.player
    204  38a3
    205  38a3
      0  38a3				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  38a3		       a9 13		      lda	#AI_ComputerMove
      2  38a5		       85 8b		      sta	aiState
    207  38a7		       60		      rts
    208  38a8
    209  38a8
      0  38a8				   .player    PHASE	AI_StartMoveGen
      1  38a8		       a9 0b		      lda	#AI_StartMoveGen
      2  38aa		       85 8b		      sta	aiState
    211  38ac		       60		      rts
    212  38ad
    213  38ad
    214  38ad							;---------------------------------------------------------------------------------------------------
    215  38ad
      0  38ad					      DEF	aiStepMoveGen
      1  38ad				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  38ad				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  38ad				   aiStepMoveGen
      4  38ad				   TEMPORARY_VAR SET	Overlay
      5  38ad				   TEMPORARY_OFFSET SET	0
      6  38ad				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  38ad				   FUNCTION_NAME SET	aiStepMoveGen
    217  38ad					      SUBROUTINE
    218  38ad
      0  38ad					      REFER	AiStateMachine
      1  38ad					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  38ad				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  38ad					      ENDIF
      0  38ad					      VEND	aiStepMoveGen
      1  38ad				  -	      IFNCONST	aiStepMoveGen
      2  38ad				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  38ad				  -	      ERR
      4  38ad					      ENDIF
      5  38ad		       00 a9	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    221  38ad
    222  38ad		       a5 87		      lda	originX12	; location of cursor (show move)
    223  38af		       85 88		      sta	cursorX12
      0  38b1					      PHASE	AI_BeginSelectMovePhase
      1  38b1		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  38b3		       85 8b		      sta	aiState
    225  38b5		       60		      rts
    226  38b6
    227  38b6
    228  38b6							;---------------------------------------------------------------------------------------------------
    229  38b6
    230  3900		       00 00 00 00*	      align	256	; TODO?
      0  3900					      DEF	PositionSprites
      1  3900				   SLOT_PositionSprites SET	_BANK_SLOT
      2  3900				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  3900				   PositionSprites
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	PositionSprites
    232  3900					      SUBROUTINE
    233  3900
      0  3900					      REFER	StartupBankReset
      1  3900				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  3900				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  3900					      ENDIF
      0  3900					      VEND	PositionSprites
      1  3900				  -	      IFNCONST	PositionSprites
      2  3900				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  3900				  -	      ERR
      4  3900					      ENDIF
      5  3900		       00 a7	   VAREND_PositionSprites =	TEMPORARY_VAR
    236  3900
    237  3900
    238  3900		       a5 88		      lda	cursorX12
    239  3902		       38		      sec
    240  3903		       e9 0a	   .sub10     sbc	#10
    241  3905		       b0 fc		      bcs	.sub10
    242  3907		       69 08		      adc	#8
    243  3909		       a8		      tay
    244  390a
    245  390a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    246  390c
    247  390c		       b9 30 f5 	      lda	colToPixel,y
    248  390f
    249  390f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    250  3910		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    251  3912		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    252  3914
    253  3914		       a8		      tay
    254  3915		       b9 30 f4 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    255  3918		       85 60		      sta	HMP0
    256  391a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    257  391c
    258  391c		       85 42		      sta	WSYNC
    259  391e		       85 6a		      sta	HMOVE
    260  3920
    261  3920		       60		      rts
    262  3921
    263  3921							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    264  3921							; fine adjustment value. This table is on a page boundary to guarantee the processor
    265  3921							; will cross a page boundary and waste a cycle in order to be at the precise position
    266  3921							; for a RESP0,x write
    267  3921
    268  3921				   fineAdjustBegin
    269  3921
    270  3921		       70		      DC.B	%01110000	; Left 7
    271  3922		       60		      DC.B	%01100000	; Left 6
    272  3923		       50		      DC.B	%01010000	; Left 5
    273  3924		       40		      DC.B	%01000000	; Left 4
    274  3925		       30		      DC.B	%00110000	; Left 3
    275  3926		       20		      DC.B	%00100000	; Left 2
    276  3927		       10		      DC.B	%00010000	; Left 1
    277  3928		       00		      DC.B	%00000000	; No movement.
    278  3929		       f0		      DC.B	%11110000	; Right 1
    279  392a		       e0		      DC.B	%11100000	; Right 2
    280  392b		       d0		      DC.B	%11010000	; Right 3
    281  392c		       c0		      DC.B	%11000000	; Right 4
    282  392d		       b0		      DC.B	%10110000	; Right 5
    283  392e		       a0		      DC.B	%10100000	; Right 6
    284  392f		       90		      DC.B	%10010000	; Right 7
    285  3930
    286  3930		       f4 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    287  3930
    288  3930
      0  3930					      ALLOCATE	colToPixel, 8
      0  3930					      OPTIONAL_PAGEBREAK	"Table", 8
     12  3930					      LIST	ON
      0  3930					      DEF	colToPixel
      1  3930				   SLOT_colToPixel SET	_BANK_SLOT
      2  3930				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  3930				   colToPixel
      4  3930				   TEMPORARY_VAR SET	Overlay
      5  3930				   TEMPORARY_OFFSET SET	0
      6  3930				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  3930				   FUNCTION_NAME SET	colToPixel
    290  3930		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    291  3938
    292  3938
    293  3938							;---------------------------------------------------------------------------------------------------
    294  3938
      0  3938					      DEF	aiMarchToTargetA
      1  3938				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  3938				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  3938				   aiMarchToTargetA
      4  3938				   TEMPORARY_VAR SET	Overlay
      5  3938				   TEMPORARY_OFFSET SET	0
      6  3938				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  3938				   FUNCTION_NAME SET	aiMarchToTargetA
    296  3938					      SUBROUTINE
    297  3938
      0  3938					      REFER	AiStateMachine
      1  3938					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3938				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3938					      ENDIF
    299  3938
      0  3938					      VAR	__fromRow, 1
      1  3938		       00 a9	   __fromRow  =	TEMPORARY_VAR
      2  3938				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3938
      4  3938				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3938				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3938				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3938					      ENDIF
      8  3938				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3938				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  3938				  -	      ERR
     11  3938					      ENDIF
     12  3938					      LIST	ON
      0  3938					      VAR	__boardIndex, 1
      1  3938		       00 aa	   __boardIndex =	TEMPORARY_VAR
      2  3938				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3938
      4  3938				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3938				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3938				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3938					      ENDIF
      8  3938				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3938				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  3938				  -	      ERR
     11  3938					      ENDIF
     12  3938					      LIST	ON
      0  3938					      VAR	__fromCol, 1
      1  3938		       00 ab	   __fromCol  =	TEMPORARY_VAR
      2  3938				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3938
      4  3938				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3938				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3938				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3938					      ENDIF
      8  3938				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3938				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  3938				  -	      ERR
     11  3938					      ENDIF
     12  3938					      LIST	ON
      0  3938					      VAR	__toCol, 1
      1  3938		       00 ac	   __toCol    =	TEMPORARY_VAR
      2  3938				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3938
      4  3938				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3938				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3938				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3938					      ENDIF
      8  3938				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3938				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  3938				  -	      ERR
     11  3938					      ENDIF
     12  3938					      LIST	ON
    304  3938
      0  3938					      VEND	aiMarchToTargetA
      1  3938				  -	      IFNCONST	aiMarchToTargetA
      2  3938				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  3938				  -	      ERR
      4  3938					      ENDIF
      5  3938		       00 ad	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
    306  3938
    307  3938
    308  3938		       a5 82		      lda	drawDelay
    309  393a		       f0 03		      beq	.nodelay
    310  393c		       c6 82		      dec	drawDelay
    311  393e		       60		      rts
    312  393f				   .nodelay
    313  393f
    314  393f							; Now we calculate move to new square
    315  393f
    316  393f		       a5 85		      lda	fromX12
    317  3941		       c5 86		      cmp	toX12
    318  3943		       f0 44		      beq	.unmovedx
    319  3945		       85 83		      sta	lastSquareX12
    320  3947
    321  3947		       38		      sec
    322  3948		       a2 fd		      ldx	#-3
    323  394a		       e9 0a	   .sub10     sbc	#10
    324  394c		       e8		      inx
    325  394d		       b0 fb		      bcs	.sub10
    326  394f		       69 08		      adc	#8
    327  3951		       85 ab		      sta	__fromCol
    328  3953		       86 a9		      stx	__fromRow
    329  3955
    330  3955		       a5 86		      lda	toX12
    331  3957		       38		      sec
    332  3958		       a2 fd		      ldx	#-3
    333  395a		       e9 0a	   .sub10b    sbc	#10
    334  395c		       e8		      inx
    335  395d		       b0 fb		      bcs	.sub10b
    336  395f		       69 08		      adc	#8
    337  3961		       85 ac		      sta	__toCol
    338  3963
    339  3963
    340  3963		       e4 a9		      cpx	__fromRow
    341  3965		       f0 13		      beq	.rowDone
    342  3967
    343  3967		       b0 0a		      bcs	.incRow
    344  3969
    345  3969		       38		      sec
    346  396a		       a5 85		      lda	fromX12
    347  396c		       e9 0a		      sbc	#10
    348  396e		       85 85		      sta	fromX12
    349  3970		       4c 7a f5 	      jmp	.rowDone
    350  3973
    351  3973		       18	   .incRow    clc
    352  3974		       a5 85		      lda	fromX12
    353  3976		       69 0a		      adc	#10
    354  3978		       85 85		      sta	fromX12
    355  397a
    356  397a				   .rowDone
    357  397a
    358  397a		       a5 ac		      lda	__toCol
    359  397c		       c5 ab		      cmp	__fromCol
    360  397e		       f0 09		      beq	.colDone
    361  3980
    362  3980		       b0 05		      bcs	.incCol
    363  3982
    364  3982		       c6 85		      dec	fromX12
    365  3984		       4c 89 f5 	      jmp	.colDone
    366  3987
    367  3987		       e6 85	   .incCol    inc	fromX12
    368  3989				   .colDone
    369  3989				   .unmovedx
    370  3989
    371  3989		       a5 87		      lda	originX12
    372  398b		       85 88		      sta	cursorX12
    373  398d
      0  398d					      PHASE	AI_MarchA2
      1  398d		       a9 17		      lda	#AI_MarchA2
      2  398f		       85 8b		      sta	aiState
    375  3991		       60		      rts
    376  3992
    377  3992
    378  3992							;---------------------------------------------------------------------------------------------------
    379  3992
      0  3992					      DEF	aiFinalFlash
      1  3992				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  3992				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  3992				   aiFinalFlash
      4  3992				   TEMPORARY_VAR SET	Overlay
      5  3992				   TEMPORARY_OFFSET SET	0
      6  3992				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  3992				   FUNCTION_NAME SET	aiFinalFlash
    381  3992					      SUBROUTINE
    382  3992
      0  3992					      REFER	AiStateMachine
      1  3992					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3992				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3992					      ENDIF
      0  3992					      VEND	aiFinalFlash
      1  3992				  -	      IFNCONST	aiFinalFlash
      2  3992				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  3992				  -	      ERR
      4  3992					      ENDIF
      5  3992		       00 a9	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    385  3992
    386  3992							; Piece has finished the animated move and is now in destination square.
    387  3992							; Flash the piece
    388  3992
    389  3992
    390  3992							; TODO: if en-passant, we can remove the piece being taken
    391  3992							; check movePiece for enPassant flag set (x)
    392  3992
    393  3992
    394  3992		       a5 82		      lda	drawDelay
    395  3994		       f0 03		      beq	.deCount
    396  3996		       c6 82		      dec	drawDelay
    397  3998		       60		      rts
    398  3999
    399  3999		       a5 84	   .deCount   lda	drawCount
    400  399b		       f0 0e		      beq	.flashDone2
    401  399d		       c6 84		      dec	drawCount
    402  399f
    403  399f		       a9 0a		      lda	#10
    404  39a1		       85 82		      sta	drawDelay	; "getting ready to move" flash
    405  39a3
    406  39a3		       a5 85		      lda	fromX12
    407  39a5		       85 80		      sta	squareToDraw
    408  39a7
    409  39a7							; WARNING - local variables will not survive the following call...!
    410  39a7		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    411  39aa		       60		      rts
    412  39ab
    413  39ab				   .flashDone2
    414  39ab
    415  39ab		       a9 64		      lda	#100
    416  39ad		       85 8c		      sta	aiFlashDelay
    417  39af
      0  39af					      PHASE	AI_SpecialMoveFixup
      1  39af		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  39b1		       85 8b		      sta	aiState
    419  39b3		       60		      rts
    420  39b4
    421  39b4
    422  39b4							;---------------------------------------------------------------------------------------------------
    423  39b4
      0  39b4					      DEF	aiStartSquareSelected
      1  39b4				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  39b4				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  39b4				   aiStartSquareSelected
      4  39b4				   TEMPORARY_VAR SET	Overlay
      5  39b4				   TEMPORARY_OFFSET SET	0
      6  39b4				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  39b4				   FUNCTION_NAME SET	aiStartSquareSelected
    425  39b4					      SUBROUTINE
    426  39b4
      0  39b4					      REFER	AiStateMachine
      1  39b4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  39b4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  39b4					      ENDIF
      0  39b4					      VEND	aiStartSquareSelected
      1  39b4				  -	      IFNCONST	aiStartSquareSelected
      2  39b4				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  39b4				  -	      ERR
      4  39b4					      ENDIF
      5  39b4		       00 a9	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    429  39b4
    430  39b4
    431  39b4							; Mark all the valid moves for the selected piece on the board
    432  39b4							; and then start pulsing the piece
    433  39b4							; AND start choosing for selection of TO square
    434  39b4
    435  39b4							; Iterate the movelist and for all from squares which = drawPieceNumber
    436  39b4							; then draw a BLANK at that square
    437  39b4							; do 1 by one, when none found then increment state
    438  39b4
    439  39b4		       a5 88		      lda	cursorX12
    440  39b6		       85 80		      sta	squareToDraw
    441  39b8
    442  39b8		       a9 0a		      lda	#10
    443  39ba		       85 8c		      sta	aiFlashDelay
    444  39bc
    445  39bc		       a9 00		      lda	#0
    446  39be		       85 86		      sta	toX12	;aiToSquareX12
    447  39c0		       85 8e		      sta	aiFlashPhase	; for debounce exit timing
    448  39c2
    449  39c2		       a9 ff		      lda	#-1
    450  39c4		       85 8d		      sta	aiMoveIndex
    451  39c6
    452  39c6		       a9 28		      lda	#HOLD_DELAY
    453  39c8		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    454  39ca
      0  39ca					      PHASE	AI_DrawMoves
      1  39ca		       a9 04		      lda	#AI_DrawMoves
      2  39cc		       85 8b		      sta	aiState
    456  39ce		       60		      rts
    457  39cf
    458  39cf
    459  39cf							;---------------------------------------------------------------------------------------------------
    460  39cf
      0  39cf					      DEF	aiWriteStartPieceBlank
      1  39cf				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  39cf				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  39cf				   aiWriteStartPieceBlank
      4  39cf				   TEMPORARY_VAR SET	Overlay
      5  39cf				   TEMPORARY_OFFSET SET	0
      6  39cf				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  39cf				   FUNCTION_NAME SET	aiWriteStartPieceBlank
    462  39cf					      SUBROUTINE
    463  39cf
      0  39cf					      REFER	AiStateMachine
      1  39cf					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  39cf				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  39cf					      ENDIF
      0  39cf					      VEND	aiWriteStartPieceBlank
      1  39cf				  -	      IFNCONST	aiWriteStartPieceBlank
      2  39cf				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  39cf				  -	      ERR
      4  39cf					      ENDIF
      5  39cf		       00 a9	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    466  39cf
    467  39cf							; Flash the piece in-place preparatory to moving it.
    468  39cf							; drawDelay = flash speed
    469  39cf							; drawCount = # of flashes
    470  39cf
    471  39cf
    472  39cf		       a9 04		      lda	#%100
    473  39d1		       85 4a		      sta	CTRLPF
    474  39d3		       a9 04		      lda	#4
    475  39d5		       85 46		      sta	COLUP0
    476  39d7
    477  39d7
    478  39d7		       a5 82		      lda	drawDelay
    479  39d9		       f0 03		      beq	deCount
    480  39db		       c6 82		      dec	drawDelay
    481  39dd		       60		      rts
    482  39de				   deCount
    483  39de
    484  39de		       a5 84		      lda	drawCount
    485  39e0		       f0 0d		      beq	flashDone
    486  39e2		       c6 84		      dec	drawCount
    487  39e4
    488  39e4		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    489  39e6		       85 82		      sta	drawDelay	; "getting ready to move" flash
    490  39e8
    491  39e8		       a5 85		      lda	fromX12
    492  39ea		       85 80		      sta	squareToDraw
    493  39ec
    494  39ec							; WARNING - local variables will not survive the following call...!
    495  39ec		       4c c1 f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
    496  39ef
    497  39ef				   flashDone
    498  39ef
    499  39ef							;lda #2
    500  39ef							;sta drawDelay
      0  39ef					      PHASE	AI_MarchToTargetA
      1  39ef		       a9 16		      lda	#AI_MarchToTargetA
      2  39f1		       85 8b		      sta	aiState
    502  39f3		       60		      rts
    503  39f4
    504  39f4
    505  39f4							;---------------------------------------------------------------------------------------------------
    506  39f4
      0  39f4					      CHECK_BANK_SIZE	"BANK_StateMachine2"
      1  39f4		       01 f4	   .TEMP      =	* - _BANK_START
 BANK_StateMachine2 (1K) SIZE =  $1f4 , FREE= $20c
      2  39f4					      ECHO	"BANK_StateMachine2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  39f4				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  39f4				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_StateMachine2", " size=", * - ORIGIN
      5  39f4				  -	      ERR
      6  39f4					      ENDIF
    508  39f4
    509  39f4							;---------------------------------------------------------------------------------------------------
    510  39f4
    511  39f4							; EOF
------- FILE ./chess.asm
------- FILE piece_graphics.asm LEVEL 2 PASS 4
      0  39f4					      include	"piece_graphics.asm"
      1  39f4							; Import the graphics definitions generated by ConvertChessPieces.py
      2  39f4
      0  39f4					      SLOT	2
      1  39f4				  -	      IF	(2 < 0) || (2 > 3)
      2  39f4				  -	      ECHO	"Illegal bank address/segment location", 2
      3  39f4				  -	      ERR
      4  39f4					      ENDIF
      5  39f4				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  39f4				   _BANK_SLOT SET	2 * 64
      0  39f4					      ROMBANK	PIECES_0
      1  3fd8 ????				      SEG	PIECES_0
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECES_0_START SET	*
      6  3c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  3c00				   PIECES_0   SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + 1024
      5  3c00
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  3c00					      LIST	ON
      0  3c00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  3c00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3c00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3c00				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  3c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  3c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  3c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  3c48					      LIST	ON
      0  3c48					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  3c48				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3c48				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3c48				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  3c90					      LIST	ON
      0  3c90					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  3c90				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3c90				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3c90				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  3d00					      LIST	ON
      0  3d00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  3d00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3d00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3d00				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  3d48					      LIST	ON
      0  3d48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  3d48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3d48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3d48				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  3d48		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  3d90					      LIST	ON
      0  3d90					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  3d90				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3d90				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3d90				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  3d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  3e00				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3e00				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3e00				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e30		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  3e48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3e48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3e48				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  3e90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3e90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3e90				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  3e90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ea8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  3f00				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3f00				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3f00				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  3f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  3f48				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3f48				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3f48				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  3f90					      LIST	ON
      0  3f90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  3f90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3f90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3f90				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  3fd8					      CHECK_BANK_SIZE	"PIECES_0 (1K)"
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_0 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  3fd8					      ECHO	"PIECES_0 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_0 (1K)", " size=", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
     19  3fd8
      0  3fd8					      SLOT	2
      1  3fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  3fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  3fd8				  -	      ERR
      4  3fd8					      ENDIF
      5  3fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  3fd8				   _BANK_SLOT SET	2 * 64
      0  3fd8					      ROMBANK	PIECES_1
      1  43d8 ????				      SEG	PIECES_1
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECES_1_START SET	*
      6  4000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4000				   PIECES_1   SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  4000					      LIST	ON
      0  4000					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  4000				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4000				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4000				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  4000		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  4018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4048					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  4048					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  4048					      LIST	ON
      0  4048					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  4048				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4048				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4048				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  4048				   TEMPORARY_VAR SET	Overlay
      5  4048				   TEMPORARY_OFFSET SET	0
      6  4048				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4048				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  4048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4060		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  4078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4090					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  4090					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  4090					      LIST	ON
      0  4090					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  4090				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4090				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4090				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  4090				   TEMPORARY_VAR SET	Overlay
      5  4090				   TEMPORARY_OFFSET SET	0
      6  4090				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4090				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  4090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  40a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  40c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  40d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  40d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  4100					      LIST	ON
      0  4100					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  4100				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4100				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4100				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  4100				   TEMPORARY_VAR SET	Overlay
      5  4100				   TEMPORARY_OFFSET SET	0
      6  4100				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4100				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  4100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4130		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4148					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  4148					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  4148					      LIST	ON
      0  4148					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  4148				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4148				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4148				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  4148				   TEMPORARY_VAR SET	Overlay
      5  4148				   TEMPORARY_OFFSET SET	0
      6  4148				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4148				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  4148		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4160		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4190					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  4190					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  4190					      LIST	ON
      0  4190					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  4190				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4190				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4190				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  4190				   TEMPORARY_VAR SET	Overlay
      5  4190				   TEMPORARY_OFFSET SET	0
      6  4190				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4190				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  4190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  41a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  41c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  41d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  41d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  4200					      LIST	ON
      0  4200					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  4200				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4200				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4200				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  4200				   TEMPORARY_VAR SET	Overlay
      5  4200				   TEMPORARY_OFFSET SET	0
      6  4200				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4200				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  4200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4218		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4230		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4248					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  4248					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  4248					      LIST	ON
      0  4248					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  4248				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4248				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4248				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  4248				   TEMPORARY_VAR SET	Overlay
      5  4248				   TEMPORARY_OFFSET SET	0
      6  4248				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4248				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  4248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4278		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4290					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  4290					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  4290					      LIST	ON
      0  4290					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  4290				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4290				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4290				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  4290				   TEMPORARY_VAR SET	Overlay
      5  4290				   TEMPORARY_OFFSET SET	0
      6  4290				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4290				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  4290		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  42a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  42c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  42d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  42d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  4300					      LIST	ON
      0  4300					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  4300				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4300				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4300				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  4300				   TEMPORARY_VAR SET	Overlay
      5  4300				   TEMPORARY_OFFSET SET	0
      6  4300				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4300				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  4300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4318		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4348					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  4348					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  4348					      LIST	ON
      0  4348					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  4348				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4348				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4348				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  4348				   TEMPORARY_VAR SET	Overlay
      5  4348				   TEMPORARY_OFFSET SET	0
      6  4348				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4348				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  4348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4360		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4378		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4390					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  4390					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  4390					      LIST	ON
      0  4390					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  4390				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4390				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4390				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  4390				   TEMPORARY_VAR SET	Overlay
      5  4390				   TEMPORARY_OFFSET SET	0
      6  4390				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4390				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  4390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  43a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  43c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  43d8					      CHECK_BANK_SIZE	"PIECES_1 (1K)"
      1  43d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_1 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  43d8					      ECHO	"PIECES_1 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  43d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  43d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_1 (1K)", " size=", * - ORIGIN
      5  43d8				  -	      ERR
      6  43d8					      ENDIF
      0  43d8					      SLOT	2
      1  43d8				  -	      IF	(2 < 0) || (2 > 3)
      2  43d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  43d8				  -	      ERR
      4  43d8					      ENDIF
      5  43d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  43d8				   _BANK_SLOT SET	2 * 64
      0  43d8					      ROMBANK	PIECES_2
      1  47d8 ????				      SEG	PIECES_2
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   PIECES_2_START SET	*
      6  4400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4400				   PIECES_2   SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4400					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  4400					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  4400					      LIST	ON
      0  4400					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  4400				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4400				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4400				   WHITE_KING_on_WHITE_SQUARE_0
      4  4400				   TEMPORARY_VAR SET	Overlay
      5  4400				   TEMPORARY_OFFSET SET	0
      6  4400				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4400				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  4400		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  4418		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4448					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  4448					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  4448					      LIST	ON
      0  4448					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  4448				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4448				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4448				   WHITE_KING_on_WHITE_SQUARE_1
      4  4448				   TEMPORARY_VAR SET	Overlay
      5  4448				   TEMPORARY_OFFSET SET	0
      6  4448				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4448				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  4448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4460		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  4478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4490					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  4490					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  4490					      LIST	ON
      0  4490					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  4490				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4490				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4490				   WHITE_KING_on_WHITE_SQUARE_2
      4  4490				   TEMPORARY_VAR SET	Overlay
      5  4490				   TEMPORARY_OFFSET SET	0
      6  4490				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4490				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  4490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  44a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  44c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  44d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  44d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  4500					      LIST	ON
      0  4500					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  4500				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4500				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4500				   WHITE_KING_on_WHITE_SQUARE_3
      4  4500				   TEMPORARY_VAR SET	Overlay
      5  4500				   TEMPORARY_OFFSET SET	0
      6  4500				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4500				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  4500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4530		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4548					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  4548					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  4548					      LIST	ON
      0  4548					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  4548				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4548				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4548				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  4548				   TEMPORARY_VAR SET	Overlay
      5  4548				   TEMPORARY_OFFSET SET	0
      6  4548				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4548				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  4548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4590					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  4590					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  4590					      LIST	ON
      0  4590					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  4590				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4590				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4590				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  4590				   TEMPORARY_VAR SET	Overlay
      5  4590				   TEMPORARY_OFFSET SET	0
      6  4590				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4590				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  4590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  45a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  45c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  45d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  45d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  4600					      LIST	ON
      0  4600					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  4600				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4600				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4600				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  4600				   TEMPORARY_VAR SET	Overlay
      5  4600				   TEMPORARY_OFFSET SET	0
      6  4600				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4600				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  4600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4648					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  4648					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  4648					      LIST	ON
      0  4648					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  4648				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4648				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4648				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  4648				   TEMPORARY_VAR SET	Overlay
      5  4648				   TEMPORARY_OFFSET SET	0
      6  4648				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4648				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  4648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4690					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  4690					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  4690					      LIST	ON
      0  4690					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  4690				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4690				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4690				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  4690				   TEMPORARY_VAR SET	Overlay
      5  4690				   TEMPORARY_OFFSET SET	0
      6  4690				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4690				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  4690		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  46a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  46c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  46d8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  46d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  4700					      LIST	ON
      0  4700					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  4700				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4700				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4700				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  4700				   TEMPORARY_VAR SET	Overlay
      5  4700				   TEMPORARY_OFFSET SET	0
      6  4700				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4700				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  4700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4718		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  4730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4748					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  4748					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  4748					      LIST	ON
      0  4748					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  4748				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4748				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4748				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  4748				   TEMPORARY_VAR SET	Overlay
      5  4748				   TEMPORARY_OFFSET SET	0
      6  4748				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4748				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  4748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4760		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  4778		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4790					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  4790					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  4790					      LIST	ON
      0  4790					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  4790				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4790				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4790				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  4790				   TEMPORARY_VAR SET	Overlay
      5  4790				   TEMPORARY_OFFSET SET	0
      6  4790				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4790				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  4790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  47a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  47c0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
      0  47d8					      CHECK_BANK_SIZE	"PIECES_2 (1K)"
      1  47d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_2 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  47d8					      ECHO	"PIECES_2 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  47d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  47d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_2 (1K)", " size=", * - ORIGIN
      5  47d8				  -	      ERR
      6  47d8					      ENDIF
      0  47d8					      SLOT	2
      1  47d8				  -	      IF	(2 < 0) || (2 > 3)
      2  47d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  47d8				  -	      ERR
      4  47d8					      ENDIF
      5  47d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  47d8				   _BANK_SLOT SET	2 * 64
      0  47d8					      ROMBANK	PIECES_3
      1  4bd8 ????				      SEG	PIECES_3
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   PIECES_3_START SET	*
      6  4800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4800				   PIECES_3   SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  4800					      LIST	ON
      0  4800					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  4800				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4800				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4800				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  4800		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  4818		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  4830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4848					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  4848					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  4848					      LIST	ON
      0  4848					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  4848				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4848				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4848				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  4848				   TEMPORARY_VAR SET	Overlay
      5  4848				   TEMPORARY_OFFSET SET	0
      6  4848				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4848				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  4848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4860		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  4878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4890					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  4890					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  4890					      LIST	ON
      0  4890					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  4890				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4890				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4890				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  4890				   TEMPORARY_VAR SET	Overlay
      5  4890				   TEMPORARY_OFFSET SET	0
      6  4890				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4890				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  4890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  48a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  48c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  48d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  48d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  4900					      LIST	ON
      0  4900					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  4900				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4900				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4900				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  4900				   TEMPORARY_VAR SET	Overlay
      5  4900				   TEMPORARY_OFFSET SET	0
      6  4900				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4900				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  4900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4930		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4948					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  4948					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  4948					      LIST	ON
      0  4948					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  4948				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4948				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4948				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  4948				   TEMPORARY_VAR SET	Overlay
      5  4948				   TEMPORARY_OFFSET SET	0
      6  4948				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4948				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  4948		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  4960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  4978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4990					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  4990					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  4990					      LIST	ON
      0  4990					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  4990				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4990				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4990				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  4990				   TEMPORARY_VAR SET	Overlay
      5  4990				   TEMPORARY_OFFSET SET	0
      6  4990				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4990				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  4990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  49a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  49c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  49d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  49d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  4a00					      LIST	ON
      0  4a00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  4a00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4a00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4a00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  4a00				   TEMPORARY_VAR SET	Overlay
      5  4a00				   TEMPORARY_OFFSET SET	0
      6  4a00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4a00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  4a30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4a48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  4a48					      LIST	ON
      0  4a48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  4a48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4a48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4a48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  4a48				   TEMPORARY_VAR SET	Overlay
      5  4a48				   TEMPORARY_OFFSET SET	0
      6  4a48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4a48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4a90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  4a90					      LIST	ON
      0  4a90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  4a90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4a90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4a90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  4a90				   TEMPORARY_VAR SET	Overlay
      5  4a90				   TEMPORARY_OFFSET SET	0
      6  4a90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4a90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  4a90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  4aa8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  4ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ad8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  4b00					      LIST	ON
      0  4b00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  4b00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4b00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4b00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  4b00				   TEMPORARY_VAR SET	Overlay
      5  4b00				   TEMPORARY_OFFSET SET	0
      6  4b00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4b00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  4b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4b48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  4b48					      LIST	ON
      0  4b48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  4b48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4b48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4b48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  4b48				   TEMPORARY_VAR SET	Overlay
      5  4b48				   TEMPORARY_OFFSET SET	0
      6  4b48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4b48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  4b78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4b90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  4b90					      LIST	ON
      0  4b90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  4b90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4b90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4b90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  4b90				   TEMPORARY_VAR SET	Overlay
      5  4b90				   TEMPORARY_OFFSET SET	0
      6  4b90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4b90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4bc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  4bd8					      CHECK_BANK_SIZE	"PIECES_3 (1K)"
      1  4bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_3 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  4bd8					      ECHO	"PIECES_3 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_3 (1K)", " size=", * - ORIGIN
      5  4bd8				  -	      ERR
      6  4bd8					      ENDIF
      0  4bd8					      SLOT	2
      1  4bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4bd8				  -	      ERR
      4  4bd8					      ENDIF
      5  4bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4bd8				   _BANK_SLOT SET	2 * 64
      0  4bd8					      ROMBANK	PIECE_4
      1  4fd8 ????				      SEG	PIECE_4
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   PIECE_4_START SET	*
      6  4c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  4c00				   PIECE_4    SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  4c00					      LIST	ON
      0  4c00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  4c00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4c00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4c00				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  4c00		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  4c18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  4c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4c48					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  4c48					      LIST	ON
      0  4c48					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  4c48				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4c48				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4c48				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  4c48				   TEMPORARY_VAR SET	Overlay
      5  4c48				   TEMPORARY_OFFSET SET	0
      6  4c48				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4c48				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  4c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4c90					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  4c90					      LIST	ON
      0  4c90					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  4c90				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4c90				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4c90				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  4c90				   TEMPORARY_VAR SET	Overlay
      5  4c90				   TEMPORARY_OFFSET SET	0
      6  4c90				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4c90				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  4cc0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4cd8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  4d00					      LIST	ON
      0  4d00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  4d00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4d00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4d00				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  4d00				   TEMPORARY_VAR SET	Overlay
      5  4d00				   TEMPORARY_OFFSET SET	0
      6  4d00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4d00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  4d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4d48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  4d48					      LIST	ON
      0  4d48					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  4d48				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4d48				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4d48				   WHITE_KING_on_BLACK_SQUARE_0
      4  4d48				   TEMPORARY_VAR SET	Overlay
      5  4d48				   TEMPORARY_OFFSET SET	0
      6  4d48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4d48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  4d48		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  4d60		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  4d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4d90					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  4d90					      LIST	ON
      0  4d90					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  4d90				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4d90				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4d90				   WHITE_KING_on_BLACK_SQUARE_1
      4  4d90				   TEMPORARY_VAR SET	Overlay
      5  4d90				   TEMPORARY_OFFSET SET	0
      6  4d90				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4d90				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  4d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4da8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  4dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4dd8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  4e00					      LIST	ON
      0  4e00					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  4e00				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4e00				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4e00				   WHITE_KING_on_BLACK_SQUARE_2
      4  4e00				   TEMPORARY_VAR SET	Overlay
      5  4e00				   TEMPORARY_OFFSET SET	0
      6  4e00				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4e00				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  4e30		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4e48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  4e48					      LIST	ON
      0  4e48					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  4e48				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4e48				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4e48				   WHITE_KING_on_BLACK_SQUARE_3
      4  4e48				   TEMPORARY_VAR SET	Overlay
      5  4e48				   TEMPORARY_OFFSET SET	0
      6  4e48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4e48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  4e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e78		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4e90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  4e90					      LIST	ON
      0  4e90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  4e90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4e90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4e90				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  4e90				   TEMPORARY_VAR SET	Overlay
      5  4e90				   TEMPORARY_OFFSET SET	0
      6  4e90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4e90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  4ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  4ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ed8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  4f00					      LIST	ON
      0  4f00					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  4f00				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4f00				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4f00				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  4f00				   TEMPORARY_VAR SET	Overlay
      5  4f00				   TEMPORARY_OFFSET SET	0
      6  4f00				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4f00				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  4f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4f48					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  4f48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  4f48					      LIST	ON
      0  4f48					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  4f48				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4f48				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4f48				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  4f48				   TEMPORARY_VAR SET	Overlay
      5  4f48				   TEMPORARY_OFFSET SET	0
      6  4f48				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4f48				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  4f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  4f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4f90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  4f90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  4f90					      LIST	ON
      0  4f90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  4f90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4f90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4f90				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  4f90				   TEMPORARY_VAR SET	Overlay
      5  4f90				   TEMPORARY_OFFSET SET	0
      6  4f90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4f90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  4f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
      0  4fd8					      CHECK_BANK_SIZE	"PIECES_4 (1K)"
      1  4fd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_4 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  4fd8					      ECHO	"PIECES_4 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  4fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4fd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_4 (1K)", " size=", * - ORIGIN
      5  4fd8				  -	      ERR
      6  4fd8					      ENDIF
      0  4fd8					      SLOT	2
      1  4fd8				  -	      IF	(2 < 0) || (2 > 3)
      2  4fd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  4fd8				  -	      ERR
      4  4fd8					      ENDIF
      5  4fd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  4fd8				   _BANK_SLOT SET	2 * 64
      0  4fd8					      ROMBANK	PIECE_5
      1  53d8 ????				      SEG	PIECE_5
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   PIECE_5_START SET	*
      6  5000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5000				   PIECE_5    SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5000					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  5000					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  5000					      LIST	ON
      0  5000					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  5000				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5000				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5000				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  5000		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$00,$e0,$00,$40,$00,$00,$e0,$40,$00,$e0,$40,$40,$00	;PF0
      4  5018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5048					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  5048					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  5048					      LIST	ON
      0  5048					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  5048				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5048				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5048				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  5048				   TEMPORARY_VAR SET	Overlay
      5  5048				   TEMPORARY_OFFSET SET	0
      6  5048				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5048				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  5048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5060		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$00,$38,$00,$10,$00,$00,$38,$10,$00,$38,$10,$10,$00	;PF1
      5  5078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5090					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  5090					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  5090					      LIST	ON
      0  5090					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  5090				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5090				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5090				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  5090				   TEMPORARY_VAR SET	Overlay
      5  5090				   TEMPORARY_OFFSET SET	0
      6  5090				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5090				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  5090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  50a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  50c0		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$00,$03,$00,$01,$00,$00,$03,$01,$00,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  50d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  50d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  5100					      LIST	ON
      0  5100					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  5100				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5100				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5100				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  5100				   TEMPORARY_VAR SET	Overlay
      5  5100				   TEMPORARY_OFFSET SET	0
      6  5100				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5100				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  5100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5130		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$00,$70,$00,$20,$00,$00,$70,$20,$00,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5148					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  5148					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  5148					      LIST	ON
      0  5148					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  5148				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5148				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5148				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  5148				   TEMPORARY_VAR SET	Overlay
      5  5148				   TEMPORARY_OFFSET SET	0
      6  5148				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5148				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  5148		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  5160		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  5178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5190					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  5190					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  5190					      LIST	ON
      0  5190					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  5190				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5190				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5190				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  5190				   TEMPORARY_VAR SET	Overlay
      5  5190				   TEMPORARY_OFFSET SET	0
      6  5190				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5190				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  5190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  51a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  51c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  51d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  51d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  5200					      LIST	ON
      0  5200					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  5200				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5200				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5200				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  5200				   TEMPORARY_VAR SET	Overlay
      5  5200				   TEMPORARY_OFFSET SET	0
      6  5200				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5200				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  5200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5218		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  5230		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5248					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  5248					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  5248					      LIST	ON
      0  5248					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  5248				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5248				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5248				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  5248				   TEMPORARY_VAR SET	Overlay
      5  5248				   TEMPORARY_OFFSET SET	0
      6  5248				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5248				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  5248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5278		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5290					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  5290					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  5290					      LIST	ON
      0  5290					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  5290				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5290				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5290				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  5290				   TEMPORARY_VAR SET	Overlay
      5  5290				   TEMPORARY_OFFSET SET	0
      6  5290				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5290				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  5290		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  52a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  52c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  52d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  52d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  5300					      LIST	ON
      0  5300					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  5300				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5300				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5300				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  5300				   TEMPORARY_VAR SET	Overlay
      5  5300				   TEMPORARY_OFFSET SET	0
      6  5300				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5300				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  5300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5318		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  5330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5348					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  5348					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  5348					      LIST	ON
      0  5348					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  5348				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5348				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5348				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  5348				   TEMPORARY_VAR SET	Overlay
      5  5348				   TEMPORARY_OFFSET SET	0
      6  5348				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5348				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  5348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5360		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  5378		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5390					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  5390					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  5390					      LIST	ON
      0  5390					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  5390				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5390				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5390				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  5390				   TEMPORARY_VAR SET	Overlay
      5  5390				   TEMPORARY_OFFSET SET	0
      6  5390				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5390				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  5390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  53a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  53d8					      CHECK_BANK_SIZE	"PIECES_5 (1K)"
      1  53d8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECES_5 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  53d8					      ECHO	"PIECES_5 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  53d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  53d8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_5 (1K)", " size=", * - ORIGIN
      5  53d8				  -	      ERR
      6  53d8					      ENDIF
      0  53d8					      SLOT	2
      1  53d8				  -	      IF	(2 < 0) || (2 > 3)
      2  53d8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  53d8				  -	      ERR
      4  53d8					      ENDIF
      5  53d8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  53d8				   _BANK_SLOT SET	2 * 64
      0  53d8					      ROMBANK	PIECE_6
      1  5790 ????				      SEG	PIECE_6
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   PIECE_6_START SET	*
      6  5400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5400				   PIECE_6    SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  5400					      LIST	ON
      0  5400					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  5400				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5400				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5400				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  5400		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  5418		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  5448					      LIST	ON
      0  5448					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  5448				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5448				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5448				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  5490					      LIST	ON
      0  5490					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  5490				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5490				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5490				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  54c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  5500					      LIST	ON
      0  5500					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  5500				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5500				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  5500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  5548					      LIST	ON
      0  5548					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  5548				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5548				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5548				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  5548		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  5560		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  5590					      LIST	ON
      0  5590					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  5590				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5590				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5590				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  55c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  5600					      LIST	ON
      0  5600					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  5600				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5600				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5600				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  5630		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  5648					      LIST	ON
      0  5648					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  5648				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5648				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5648				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  5690					      LIST	ON
      0  5690					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  5690				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5690				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5690				   BLACK_KING_on_WHITE_SQUARE_0
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  5690		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  56a8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  5700					      LIST	ON
      0  5700					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  5700				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5700				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5700				   BLACK_KING_on_WHITE_SQUARE_1
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  5730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  5748					      LIST	ON
      0  5748					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  5748				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5748				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5748				   BLACK_KING_on_WHITE_SQUARE_2
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  5778		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
      0  5790					      CHECK_BANK_SIZE	"PIECES_6 (1K)"
      1  5790		       03 90	   .TEMP      =	* - _BANK_START
 PIECES_6 (1K) (1K) SIZE =  $390 , FREE= $70
      2  5790					      ECHO	"PIECES_6 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5790				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5790				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_6 (1K)", " size=", * - ORIGIN
      5  5790				  -	      ERR
      6  5790					      ENDIF
      0  5790					      SLOT	2
      1  5790				  -	      IF	(2 < 0) || (2 > 3)
      2  5790				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5790				  -	      ERR
      4  5790					      ENDIF
      5  5790				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5790				   _BANK_SLOT SET	2 * 64
      0  5790					      ROMBANK	PIECE_7
      1  5bd8 ????				      SEG	PIECE_7
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   PIECE_7_START SET	*
      6  5800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5800				   PIECE_7    SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5800					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  5800					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  5800					      LIST	ON
      0  5800					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  5800				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5800				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5800				   BLACK_KING_on_WHITE_SQUARE_3
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  5800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5830		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5848					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  5848					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  5848					      LIST	ON
      0  5848					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  5848				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5848				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5848				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  5848				   TEMPORARY_VAR SET	Overlay
      5  5848				   TEMPORARY_OFFSET SET	0
      6  5848				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5848				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  5848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5890					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  5890					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  5890					      LIST	ON
      0  5890					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  5890				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5890				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5890				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  5890				   TEMPORARY_VAR SET	Overlay
      5  5890				   TEMPORARY_OFFSET SET	0
      6  5890				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5890				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  5890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  58a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  58c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  58d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  58d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  5900					      LIST	ON
      0  5900					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  5900				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5900				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5900				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  5900				   TEMPORARY_VAR SET	Overlay
      5  5900				   TEMPORARY_OFFSET SET	0
      6  5900				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5900				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  5900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5948					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  5948					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  5948					      LIST	ON
      0  5948					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  5948				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5948				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5948				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  5948				   TEMPORARY_VAR SET	Overlay
      5  5948				   TEMPORARY_OFFSET SET	0
      6  5948				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5948				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  5948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5990					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  5990					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  5990					      LIST	ON
      0  5990					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  5990				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5990				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5990				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  5990				   TEMPORARY_VAR SET	Overlay
      5  5990				   TEMPORARY_OFFSET SET	0
      6  5990				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5990				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  5990		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$00,$e0,$00,$40,$00,$00,$00,$00,$40,$00,$00,$00,$00	;PF0
      4  59a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  59c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  59d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  59d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  5a00					      LIST	ON
      0  5a00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  5a00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5a00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5a00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  5a00				   TEMPORARY_VAR SET	Overlay
      5  5a00				   TEMPORARY_OFFSET SET	0
      6  5a00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5a00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  5a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a18		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$00,$38,$00,$10,$00,$00,$00,$00,$10,$00,$00,$00,$00	;PF1
      5  5a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5a48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  5a48					      LIST	ON
      0  5a48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  5a48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5a48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5a48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  5a48				   TEMPORARY_VAR SET	Overlay
      5  5a48				   TEMPORARY_OFFSET SET	0
      6  5a48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5a48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a78		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$00,$03,$00,$01,$00,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5a90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  5a90					      LIST	ON
      0  5a90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  5a90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5a90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5a90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  5a90				   TEMPORARY_VAR SET	Overlay
      5  5a90				   TEMPORARY_OFFSET SET	0
      6  5a90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  5a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$00,$70,$00,$20,$00,$00,$00,$00,$20,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5ad8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  5b00					      LIST	ON
      0  5b00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  5b00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5b00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5b00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  5b00				   TEMPORARY_VAR SET	Overlay
      5  5b00				   TEMPORARY_OFFSET SET	0
      6  5b00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5b00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  5b00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  5b18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5b48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  5b48					      LIST	ON
      0  5b48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  5b48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5b48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5b48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  5b48				   TEMPORARY_VAR SET	Overlay
      5  5b48				   TEMPORARY_OFFSET SET	0
      6  5b48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5b48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  5b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  5b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5b90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  5b90					      LIST	ON
      0  5b90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  5b90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5b90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5b90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  5b90				   TEMPORARY_VAR SET	Overlay
      5  5b90				   TEMPORARY_OFFSET SET	0
      6  5b90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5b90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5bc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  5bd8					      CHECK_BANK_SIZE	"PIECE_7 (1K)"
      1  5bd8		       03 d8	   .TEMP      =	* - _BANK_START
 PIECE_7 (1K) (1K) SIZE =  $3d8 , FREE= $28
      2  5bd8					      ECHO	"PIECE_7 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5bd8				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_7 (1K)", " size=", * - ORIGIN
      5  5bd8				  -	      ERR
      6  5bd8					      ENDIF
      0  5bd8					      SLOT	2
      1  5bd8				  -	      IF	(2 < 0) || (2 > 3)
      2  5bd8				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5bd8				  -	      ERR
      4  5bd8					      ENDIF
      5  5bd8				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5bd8				   _BANK_SLOT SET	2 * 64
      0  5bd8					      ROMBANK	PIECE_8
      1  5c48 ????				      SEG	PIECE_8
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   PIECE_8_START SET	*
      6  5c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  5c00				   PIECE_8    SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + 1024
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5c00					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  5c00					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  5c00					      LIST	ON
      0  5c00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  5c00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5c00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5c00				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  5c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
    127  5c48
      0  5c48					      CHECK_BANK_SIZE	"PIECES_8 (1K)"
      1  5c48		       00 48	   .TEMP      =	* - _BANK_START
 PIECES_8 (1K) (1K) SIZE =  $48 , FREE= $3b8
      2  5c48					      ECHO	"PIECES_8 (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  5c48				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5c48				  -	      ECHO	"BANK OVERFLOW @ ", "PIECES_8 (1K)", " size=", * - ORIGIN
      5  5c48				  -	      ERR
      6  5c48					      ENDIF
    129  5c48
    130  5c48							;    ROMBANK PIECES_5
    131  5c48
    132  5c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    133  5c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    134  5c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    135  5c48							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    136  5c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    137  5c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    138  5c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    139  5c48							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    140  5c48
    141  5c48
    142  5c48				  -	      IF	0
    143  5c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    144  5c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    145  5c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    146  5c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    147  5c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    148  5c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    149  5c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    150  5c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    151  5c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    152  5c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    153  5c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    154  5c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    155  5c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    156  5c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    157  5c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    158  5c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    159  5c48					      ENDIF
    160  5c48
    161  5c48							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    162  5c48
    163  5c48				  -	      IF	0
    164  5c48				  -	      ROMBANK	PIECES_6
    165  5c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    166  5c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    167  5c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    168  5c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    169  5c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    170  5c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    171  5c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    172  5c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    173  5c48				  -
    174  5c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    175  5c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    176  5c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    177  5c48				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    178  5c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    179  5c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    180  5c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    181  5c48				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    182  5c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    183  5c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    184  5c48				  -
    185  5c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    186  5c48				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    187  5c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    188  5c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    189  5c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    190  5c48				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    191  5c48				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    192  5c48				  -
    193  5c48				  -
    194  5c48				  -	      ROMBANK	PIECES_7
    195  5c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    196  5c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    197  5c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    198  5c48				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    199  5c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    200  5c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    201  5c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    202  5c48				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    203  5c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    204  5c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    205  5c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    206  5c48				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    207  5c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    208  5c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    209  5c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    210  5c48				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    211  5c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    212  5c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    213  5c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    214  5c48				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    215  5c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    216  5c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    217  5c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    218  5c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    219  5c48				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    220  5c48				  -
    221  5c48				  -
    222  5c48				  -	      ROMBANK	PIECES_8
    223  5c48				  -
    224  5c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    225  5c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    226  5c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    227  5c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    228  5c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    229  5c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    230  5c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    231  5c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    232  5c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    233  5c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    234  5c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    235  5c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    236  5c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    237  5c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    238  5c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    239  5c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    240  5c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    241  5c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    242  5c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    243  5c48				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    244  5c48				  -
    245  5c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    246  5c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    247  5c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    248  5c48				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    249  5c48				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    250  5c48				  -
    251  5c48					      ENDIF
    252  5c48
    253  5c48							;    ROMBANK PIECES_9
    254  5c48
    255  5c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    256  5c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    257  5c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    258  5c48							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    259  5c48							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    260  5c48
    261  5c48				  -	      IF	0
    262  5c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    263  5c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    264  5c48				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    265  5c48					      ENDIF
    266  5c48
    267  5c48							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    268  5c48
    269  5c48				  -	      IF	0
    270  5c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    271  5c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    272  5c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    273  5c48				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    274  5c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    275  5c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    276  5c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    277  5c48				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    278  5c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    279  5c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    280  5c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    281  5c48				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    282  5c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    283  5c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    284  5c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    285  5c48				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    286  5c48					      ENDIF
------- FILE ./chess.asm
------- FILE BANK_GENERIC@2#2.asm LEVEL 2 PASS 4
      0  5c48					      include	"BANK_GENERIC@2#2.asm"
      1  5c48
      0  5c48					      SLOT	2
      1  5c48				  -	      IF	(2 < 0) || (2 > 3)
      2  5c48				  -	      ECHO	"Illegal bank address/segment location", 2
      3  5c48				  -	      ERR
      4  5c48					      ENDIF
      5  5c48				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  5c48				   _BANK_SLOT SET	2 * 64
      0  5c48					      ROMBANK	GENERIC_BANK@2#2
      1  607d ????				      SEG	GENERIC_BANK@2#2
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   GENERIC_BANK@2#2_START SET	*
      6  6000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6000				   GENERIC_BANK@2#2 SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + 1024
      4  6000
      5  6000
      6  6000							;---------------------------------------------------------------------------------------------------
      7  6000
      8  6000
      0  6000					      DEF	moveCursor
      1  6000				   SLOT_moveCursor SET	_BANK_SLOT
      2  6000				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  6000				   moveCursor
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	moveCursor
     10  6000					      SUBROUTINE
     11  6000
      0  6000					      REFER	aiSelectStartSquare
      1  6000					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  6000				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  6000					      ENDIF
      0  6000					      REFER	aiSelectDestinationSquare
      1  6000				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  6000				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  6000					      ENDIF
     14  6000
      0  6000					      VAR	__newCursor, 1
      1  6000		       00 a9	   __newCursor =	TEMPORARY_VAR
      2  6000				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6000
      4  6000				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6000				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6000				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6000					      ENDIF
      8  6000				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6000				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  6000				  -	      ERR
     11  6000					      ENDIF
     12  6000					      LIST	ON
     16  6000
      0  6000					      VEND	moveCursor
      1  6000				  -	      IFNCONST	moveCursor
      2  6000				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  6000				  -	      ERR
      4  6000					      ENDIF
      5  6000		       00 aa	   VAREND_moveCursor =	TEMPORARY_VAR
     18  6000
     19  6000							; Part (a) move cursor around the board waiting for joystick press
     20  6000
     21  6000		       a2 00		      ldx	#0	; delay
     22  6002
     23  6002		       ad 80 02 	      lda	SWCHA
     24  6005		       4a		      lsr
     25  6006		       4a		      lsr
     26  6007		       4a		      lsr
     27  6008		       4a		      lsr
     28  6009		       a8		      tay
     29  600a
     30  600a		       c9 0f		      cmp	#15
     31  600c		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
     32  600e
     33  600e		       c6 89		      dec	mdelay
     34  6010		       10 1f		      bpl	.delaym
     35  6012
     36  6012		       18		      clc
     37  6013		       a5 88		      lda	cursorX12
     38  6015		       79 6d f8 	      adc	JoyMoveCursor,y
     39  6018		       85 a9		      sta	__newCursor
     40  601a		       a8		      tay
     41  601b
     42  601b		       a9 d2		      lda	#RAMBANK_BOARD
     43  601d		       85 3e		      sta	SET_BANK_RAM	;@3
     44  601f		       b9 15 fc 	      lda	ValidSquare,y
     45  6022		       c9 ff		      cmp	#-1
     46  6024		       f0 04		      beq	.invalid
     47  6026		       a5 a9		      lda	__newCursor
     48  6028		       85 88		      sta	cursorX12
     49  602a				   .invalid
     50  602a
     51  602a		       a2 10		      ldx	#CURSOR_MOVE_SPEED
     52  602c		       86 89	   .cursor    stx	mdelay
     53  602e		       20 32 f8 	      jsr	setCursorPriority
     54  6031		       60	   .delaym    rts
     55  6032
     56  6032
     57  6032							;---------------------------------------------------------------------------------------------------
     58  6032
      0  6032					      DEF	setCursorPriority
      1  6032				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  6032				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  6032				   setCursorPriority
      4  6032				   TEMPORARY_VAR SET	Overlay
      5  6032				   TEMPORARY_OFFSET SET	0
      6  6032				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  6032				   FUNCTION_NAME SET	setCursorPriority
     60  6032					      SUBROUTINE
     61  6032
      0  6032					      REFER	moveCursor
      1  6032					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  6032				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  6032					      ENDIF
      0  6032					      VEND	setCursorPriority
      1  6032				  -	      IFNCONST	setCursorPriority
      2  6032				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  6032				  -	      ERR
      4  6032					      ENDIF
      5  6032		       00 aa	   VAREND_setCursorPriority =	TEMPORARY_VAR
     64  6032
     65  6032		       98		      tya
     66  6033		       48		      pha
     67  6034
     68  6034		       a2 04		      ldx	#%100
     69  6036
     70  6036		       a4 88		      ldy	cursorX12
     71  6038		       30 0b		      bmi	.under
     72  603a
     73  603a		       a9 d2		      lda	#RAMBANK_BOARD
     74  603c		       85 3e		      sta	SET_BANK_RAM	;@3
     75  603e		       b9 79 fc 	      lda	Board,y
     76  6041		       d0 02		      bne	.under
     77  6043		       a2 00		      ldx	#0
     78  6045		       86 4a	   .under     stx	CTRLPF	; UNDER
     79  6047
     80  6047		       68		      pla
     81  6048		       a8		      tay
     82  6049		       60		      rts
     83  604a
     84  604a
     85  604a							;---------------------------------------------------------------------------------------------------
     86  604a
      0  604a					      DEF	setCursorColours
      1  604a				   SLOT_setCursorColours SET	_BANK_SLOT
      2  604a				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  604a				   setCursorColours
      4  604a				   TEMPORARY_VAR SET	Overlay
      5  604a				   TEMPORARY_OFFSET SET	0
      6  604a				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  604a				   FUNCTION_NAME SET	setCursorColours
     88  604a					      SUBROUTINE
     89  604a
      0  604a					      REFER	aiSelectStartSquare
      1  604a					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  604a				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  604a					      ENDIF
      0  604a					      REFER	aiDrawMoves
      1  604a				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  604a				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  604a					      ENDIF
      0  604a					      REFER	aiUnDrawTargetSquares
      1  604a				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  604a				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  604a					      ENDIF
      0  604a					      REFER	aiShowMoveCaptures
      1  604a				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  604a				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  604a					      ENDIF
      0  604a					      REFER	aiSlowFlash
      1  604a				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  604a				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  604a					      ENDIF
      0  604a					      REFER	aiSelectDestinationSquare
      1  604a				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  604a				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  604a					      ENDIF
      0  604a					      VEND	setCursorColours
      1  604a				  -	      IFNCONST	setCursorColours
      2  604a				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  604a				  -	      ERR
      4  604a					      ENDIF
      5  604a		       00 a9	   VAREND_setCursorColours =	TEMPORARY_VAR
     97  604a
     98  604a							; pass y=-1 if move is NOT in the movelist
     99  604a							; preserve y
    100  604a
    101  604a		       a9 42		      lda	#$42
    102  604c
    103  604c		       c0 ff		      cpy	#-1
    104  604e		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    105  6050
    106  6050		       a5 8a		      lda	ccur
    107  6052		       4a		      lsr
    108  6053		       4a		      lsr
    109  6054		       4a		      lsr
    110  6055		       29 06		      and	#6
    111  6057		       18		      clc
    112  6058		       69 d0		      adc	#$D0	;COLOUR_LINE_1
    113  605a
    114  605a		       85 46	   .writeCursorCol sta	COLUP0
    115  605c		       60		      rts
    116  605d
    117  605d
    118  605d							;---------------------------------------------------------------------------------------------------
    119  605d
    120  605d							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    121  605d							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    122  605d
      0  605d					      ALLOCATE	JoyCombined, 16
      0  605d					      OPTIONAL_PAGEBREAK	"Table", 16
     12  605d					      LIST	ON
      0  605d					      DEF	JoyCombined
      1  605d				   SLOT_JoyCombined SET	_BANK_SLOT
      2  605d				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  605d				   JoyCombined
      4  605d				   TEMPORARY_VAR SET	Overlay
      5  605d				   TEMPORARY_OFFSET SET	0
      6  605d				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  605d				   FUNCTION_NAME SET	JoyCombined
    124  605d		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    125  606d
      0  606d					      ALLOCATE	JoyMoveCursor, 16
      0  606d					      OPTIONAL_PAGEBREAK	"Table", 16
     12  606d					      LIST	ON
      0  606d					      DEF	JoyMoveCursor
      1  606d				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  606d				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  606d				   JoyMoveCursor
      4  606d				   TEMPORARY_VAR SET	Overlay
      5  606d				   TEMPORARY_OFFSET SET	0
      6  606d				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  606d				   FUNCTION_NAME SET	JoyMoveCursor
    127  606d		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    128  607d
    129  607d
    130  607d							;---------------------------------------------------------------------------------------------------
    131  607d
      0  607d					      CHECK_BANK_SIZE	"BANK_GENERIC@2#2"
      1  607d		       00 7d	   .TEMP      =	* - _BANK_START
 BANK_GENERIC@2#2 (1K) SIZE =  $7d , FREE= $383
      2  607d					      ECHO	"BANK_GENERIC@2#2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  607d				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  607d				  -	      ECHO	"BANK OVERFLOW @ ", "BANK_GENERIC@2#2", " size=", * - ORIGIN
      5  607d				  -	      ERR
      6  607d					      ENDIF
    133  607d
    134  607d							;---------------------------------------------------------------------------------------------------
    135  607d							;EOF
------- FILE ./chess.asm
------- FILE NEGAMAX@1.asm LEVEL 2 PASS 4
      0  607d					      include	"NEGAMAX@1.asm"
      1  607d							; Chess
      2  607d							; Copyright (c) 2019-2020 Andrew Davie
      3  607d							; andrew@taswegian.com
      4  607d
      0  607d					      SLOT	1
      1  607d				  -	      IF	(1 < 0) || (1 > 3)
      2  607d				  -	      ECHO	"Illegal bank address/segment location", 1
      3  607d				  -	      ERR
      4  607d					      ENDIF
      5  607d				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  607d				   _BANK_SLOT SET	1 * 64
      0  607d					      ROMBANK	NEGAMAX
      1  678a ????				      SEG	NEGAMAX
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   NEGAMAX_START SET	*
      6  6400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6400				   NEGAMAX    SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + 1024
      7  6400
      8  6400							;---------------------------------------------------------------------------------------------------
      9  6400
      0  6400					      DEF	aiComputerMove
      1  6400				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  6400				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  6400				   aiComputerMove
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	aiComputerMove
     11  6400					      SUBROUTINE
     12  6400
      0  6400					      REFER	AiStateMachine	;✅
      1  6400					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  6400				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  6400					      ENDIF
      0  6400					      VEND	aiComputerMove
      1  6400				  -	      IFNCONST	aiComputerMove
      2  6400				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  6400				  -	      ERR
      4  6400					      ENDIF
      5  6400		       00 a9	   VAREND_aiComputerMove =	TEMPORARY_VAR
     15  6400
     16  6400							; Computer is about to select a move
     17  6400
     18  6400
     19  6400		       a9 88		      lda	#RAMBANK_PLY
     20  6402		       85 94		      sta	currentPly
     21  6404		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     22  6406
     23  6406		       a9 01		      lda	#1
     24  6408		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
     25  640a
     26  640a		       20 3a f4 	      jsr	selectmove	;@this
     27  640d
     28  640d		       a9 00		      lda	#0
     29  640f		       85 4a		      sta	CTRLPF	; clear mirroring
     30  6411		       85 4e		      sta	PF1
     31  6413		       85 4f		      sta	PF2
     32  6415
     33  6415							; correct ply is already switched
     34  6415
      0  6415					      lda@PLY	bestMove
      1  6415		       ad d1 f9 	      lda	bestMove
     36  6418		       10 17		      bpl	.notComputer
     37  641a
     38  641a							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     39  641a
      0  641a					      SWAP
      1  641a		       a5 95		      lda	sideToMove
      2  641c		       49 c0		      eor	#SWAP_SIDE|HUMAN
      3  641e		       85 95		      sta	sideToMove
      4  6420
      5  6420
     41  6420		       20 94 f1 	      jsr	GenerateAllMoves	;@0
     42  6423		       a5 9f		      lda	flagCheck
     43  6425		       f0 05		      beq	.gameDrawn
     44  6427
      0  6427					      PHASE	AI_CheckMate
      1  6427		       a9 23		      lda	#AI_CheckMate
      2  6429		       85 8b		      sta	aiState
     46  642b		       60		      rts
     47  642c
     48  642c
      0  642c				   .gameDrawn PHASE	AI_Draw
      1  642c		       a9 24		      lda	#AI_Draw
      2  642e		       85 8b		      sta	aiState
     50  6430		       60		      rts
     51  6431
     52  6431				   .notComputer
     53  6431
     54  6431
     55  6431		       a9 ff		      lda	#-1
     56  6433		       85 88		      sta	cursorX12
     57  6435
      0  6435					      PHASE	AI_DelayAfterMove
      1  6435		       a9 25		      lda	#AI_DelayAfterMove
      2  6437		       85 8b		      sta	aiState
     59  6439		       60	   .halted    rts
     60  643a
     61  643a
     62  643a							;---------------------------------------------------------------------------------------------------
     63  643a
      0  643a					      DEF	selectmove
      1  643a				   SLOT_selectmove SET	_BANK_SLOT
      2  643a				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  643a				   selectmove
      4  643a				   TEMPORARY_VAR SET	Overlay
      5  643a				   TEMPORARY_OFFSET SET	0
      6  643a				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  643a				   FUNCTION_NAME SET	selectmove
     65  643a					      SUBROUTINE
     66  643a
      0  643a					      COMMON_VARS
      1  643a
      0  643a					      VAR	__thinkbar, 1
      1  643a		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
      0  643a					      VAR	__toggle, 1
      1  643a		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
      4  643a
      0  643a					      VAR	__bestMove, 1
      1  643a		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
      0  643a					      VAR	__alpha, 2
      1  643a		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
      0  643a					      VAR	__beta, 2
      1  643a		       00 ac	   __beta     =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
      0  643a					      VAR	__negaMax, 2
      1  643a		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
      0  643a					      VAR	__value, 2
      1  643a		       00 b0	   __value    =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
     10  643a
      0  643a					      VAR	__quiesceCapOnly, 1
      1  643a		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
     12  643a
      0  643a					      VAR	__originalPiece, 1
      1  643a		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
      0  643a					      VAR	__capturedPiece, 1
      1  643a		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  643a				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  643a
      4  643a				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  643a				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  643a				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  643a					      ENDIF
      8  643a				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  643a				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  643a				  -	      ERR
     11  643a					      ENDIF
     12  643a					      LIST	ON
     15  643a
      0  643a					      REFER	aiComputerMove	;✅
      1  643a				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  643a				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  643a					      ENDIF
      0  643a					      VEND	selectmove
      1  643a				  -	      IFNCONST	selectmove
      2  643a				  -	      ECHO	"Incorrect VEND label", selectmove
      3  643a				  -	      ERR
      4  643a					      ENDIF
      5  643a		       00 b5	   VAREND_selectmove =	TEMPORARY_VAR
     70  643a
     71  643a
     72  643a							; RAM bank already switched in!!!
     73  643a							; returns with RAM bank switched
     74  643a
     75  643a
     76  643a					      IF	DIAGNOSTICS
     77  643a
     78  643a		       a9 00		      lda	#0
     79  643c		       85 9c		      sta	positionCount
     80  643e		       85 9d		      sta	positionCount+1
     81  6440		       85 9e		      sta	positionCount+2
     82  6442							;sta maxPly
     83  6442					      ENDIF
     84  6442
     85  6442		       a9 00		      lda	#<INFINITY
     86  6444		       85 ac		      sta	__beta
     87  6446		       a9 70		      lda	#>INFINITY
     88  6448		       85 ad		      sta	__beta+1
     89  644a
     90  644a		       a9 00		      lda	#<-INFINITY
     91  644c		       85 aa		      sta	__alpha
     92  644e		       a9 90		      lda	#>-INFINITY
     93  6450		       85 ab		      sta	__alpha+1	; player tries to maximise
     94  6452
     95  6452		       a2 03		      ldx	#SEARCH_DEPTH
     96  6454		       a9 00		      lda	#0	; no captured piece
     97  6456		       85 b2		      sta	__quiesceCapOnly	; ALL moves to be generated
     98  6458
     99  6458		       20 29 f5 	      jsr	negaMax
    100  645b
    101  645b		       a5 94		      lda	currentPly
    102  645d		       85 3e		      sta	SET_BANK_RAM	;tmp?
    103  645f
      0  645f					      ldx@PLY	bestMove
      1  645f		       ae d1 f9 	      ldx	bestMove
    105  6462		       30 26		      bmi	.nomove
    106  6464
    107  6464							; Generate player's moves in reply
    108  6464							; Make the computer move, list player moves (PLY+1), unmake computer move
    109  6464
      0  6464					      stx@PLY	movePtr
      1  6464		       8e d0 fb 	      stx	[RAM]+movePtr
    111  6467		       20 8b f4 	      jsr	MakeMove	;@this
    112  646a		       20 3e f2 	      jsr	ListPlayerMoves	;@0
    113  646d
    114  646d		       c6 94		      dec	currentPly
    115  646f		       20 9b f2 	      jsr	unmakeMove	;@0
    116  6472
    117  6472							; Grab the computer move details for the UI animation
    118  6472
    119  6472		       a9 88		      lda	#RAMBANK_PLY
    120  6474		       85 3e		      sta	SET_BANK_RAM
    121  6476
      0  6476					      ldx@PLY	bestMove
      1  6476		       ae d1 f9 	      ldx	bestMove
      0  6479					      lda@PLY	MoveTo,x
      1  6479		       bd 64 f8 	      lda	MoveTo,x
    124  647c		       85 86		      sta	toX12
      0  647e					      lda@PLY	MoveFrom,x
      1  647e		       bd 00 f8 	      lda	MoveFrom,x
    126  6481		       85 87		      sta	originX12
    127  6483		       85 85		      sta	fromX12
      0  6485					      lda@PLY	MovePiece,x
      1  6485		       bd 00 f9 	      lda	MovePiece,x
    129  6488		       85 96		      sta	fromPiece
    130  648a
    131  648a				   .nomove
    132  648a		       60		      rts
    133  648b
    134  648b
    135  648b							;---------------------------------------------------------------------------------------------------
    136  648b
      0  648b					      DEF	MakeMove
      1  648b				   SLOT_MakeMove SET	_BANK_SLOT
      2  648b				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  648b				   MakeMove
      4  648b				   TEMPORARY_VAR SET	Overlay
      5  648b				   TEMPORARY_OFFSET SET	0
      6  648b				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  648b				   FUNCTION_NAME SET	MakeMove
    138  648b					      SUBROUTINE
    139  648b
      0  648b					      COMMON_VARS
      1  648b
      0  648b					      VAR	__thinkbar, 1
      1  648b		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
      0  648b					      VAR	__toggle, 1
      1  648b		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
      4  648b
      0  648b					      VAR	__bestMove, 1
      1  648b		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
      0  648b					      VAR	__alpha, 2
      1  648b		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
      0  648b					      VAR	__beta, 2
      1  648b		       00 ac	   __beta     =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
      0  648b					      VAR	__negaMax, 2
      1  648b		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
      0  648b					      VAR	__value, 2
      1  648b		       00 b0	   __value    =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
     10  648b
      0  648b					      VAR	__quiesceCapOnly, 1
      1  648b		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
     12  648b
      0  648b					      VAR	__originalPiece, 1
      1  648b		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
      0  648b					      VAR	__capturedPiece, 1
      1  648b		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  648b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  648b
      4  648b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  648b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  648b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  648b					      ENDIF
      8  648b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  648b				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  648b				  -	      ERR
     11  648b					      ENDIF
     12  648b					      LIST	ON
     15  648b
      0  648b					      REFER	selectmove	;✅
      1  648b				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  648b				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  648b					      ENDIF
      0  648b					      REFER	ListPlayerMoves	;✅
      1  648b				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  648b				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  648b					      ENDIF
      0  648b					      REFER	quiesce	;✅
      1  648b				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  648b				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  648b					      ENDIF
      0  648b					      REFER	negaMax	;✅
      1  648b				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  648b				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  648b					      ENDIF
      0  648b					      VEND	MakeMove
      1  648b				  -	      IFNCONST	MakeMove
      2  648b				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  648b				  -	      ERR
      4  648b					      ENDIF
      5  648b		       00 b5	   VAREND_MakeMove =	TEMPORARY_VAR
    146  648b
    147  648b							; Do a move without any GUI stuff
    148  648b							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    149  648b							; and all relevant flags in original state. This is NOT used for the visible move on the
    150  648b							; screen.
    151  648b
    152  648b
    153  648b							; fromPiece	 piece doing the move
    154  648b							; fromX12	 current square X12
    155  648b							; originX12	 starting square X12
    156  648b							; toX12	 ending square X12
    157  648b
    158  648b							; BANK:SLOT2 = currentPly
    159  648b
    160  648b
    161  648b							; There are potentially "two" moves, with the following
    162  648b							; a) Castling, moving both rook and king
    163  648b							; b) en-Passant, capturing pawn on "odd" square
    164  648b							; These both set "secondary" movers which are used for restoring during unmakeMove
    165  648b
    166  648b		       a0 d2		      ldy	#RAMBANK_BOARD
    167  648d		       84 3e		      sty	SET_BANK_RAM	;@3
    168  648f
      0  648f					      ldx@PLY	movePtr
      1  648f		       ae d0 f9 	      ldx	movePtr
      0  6492					      ldy@PLY	MoveFrom,x
      1  6492		       bc 00 f8 	      ldy	MoveFrom,x
    171  6495		       84 85		      sty	fromX12
    172  6497		       84 87		      sty	originX12
    173  6499
      0  6499					      lda@RAM	Board,y
      1  6499		       b9 79 fc 	      lda	Board,y
    175  649c		       85 b3		      sta	__originalPiece
      0  649e					      sta@PLY	restorePiece
      1  649e		       8d d9 fb 	      sta	[RAM]+restorePiece
    177  64a1
    178  64a1		       a9 00		      lda	#0
      0  64a3					      sta@RAM	Board,y
      1  64a3		       99 79 fe 	      sta	[RAM]+Board,y
      0  64a6					      sta@PLY	secondaryPiece
      1  64a6		       8d cc fb 	      sta	[RAM]+secondaryPiece
    181  64a9
    182  64a9		       85 a4		      sta	vkSquare
    183  64ab		       85 a5		      sta	vkSquare+1
    184  64ad
      0  64ad					      ldy@PLY	MoveTo,x
      1  64ad		       bc 64 f8 	      ldy	MoveTo,x
    186  64b0		       84 86		      sty	toX12
    187  64b2
      0  64b2					      lda@RAM	Board,y
      1  64b2		       b9 79 fc 	      lda	Board,y
    189  64b5		       85 b4		      sta	__capturedPiece
      0  64b7					      sta@PLY	capturedPiece
      1  64b7		       8d cb fb 	      sta	[RAM]+capturedPiece
    191  64ba
      0  64ba					      lda@PLY	MovePiece,x
      1  64ba		       bd 00 f9 	      lda	MovePiece,x
    193  64bd		       85 96		      sta	fromPiece
    194  64bf
    195  64bf		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
    196  64c1		       09 40		      ora	#FLAG_MOVED
      0  64c3					      sta@RAM	Board,y
      1  64c3		       99 79 fe 	      sta	[RAM]+Board,y
    198  64c6
    199  64c6
      0  64c6				   .move      CALL	AdjustMaterialPositionalValue	;@2
      1  64c6				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  64c6				  -FNAME      SETSTR	AdjustMaterialPositionalValue
      3  64c6				  -	      ECHO	""
      4  64c6				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  64c6				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  64c6				  -	      ERR
      7  64c6					      ENDIF
      8  64c6		       a9 84		      lda	#BANK_AdjustMaterialPositionalValue
      9  64c8		       85 3f		      sta	SET_BANK
     10  64ca		       20 e3 f8 	      jsr	AdjustMaterialPositionalValue
    201  64cd
    202  64cd
    203  64cd					      IF	CASTLING_ENABLED
    204  64cd
    205  64cd							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    206  64cd							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    207  64cd							; redo the moving code (for the rook, this time).
    208  64cd
    209  64cd							; Set the squares that need to be checked for "virtual check" - preventing the king
    210  64cd							; from castling from/across check.
    211  64cd
    212  64cd		       a5 96		      lda	fromPiece
    213  64cf		       29 17		      and	#FLAG_CASTLE|KING
    214  64d1		       c9 17		      cmp	#FLAG_CASTLE|KING
    215  64d3		       d0 13		      bne	.exit	; NOT involved in castle!
    216  64d5
    217  64d5							; Must be a king, castling. Calculate the virtual squares which need to be checked for
    218  64d5							; invalid castling. Prevents moving in/across check.
    219  64d5
    220  64d5		       18		      clc
    221  64d6		       a5 87		      lda	originX12
    222  64d8		       85 a5		      sta	vkSquare+1	; king origin
    223  64da		       65 86		      adc	toX12
    224  64dc		       4a		      lsr
    225  64dd		       85 a4		      sta	vkSquare	; intermediate square
    226  64df
    227  64df
    228  64df							; Now generate a new move for the rook
    229  64df
      0  64df					      CALL	GenCastleMoveForRook	;@3
      1  64df				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  64df				  -FNAME      SETSTR	GenCastleMoveForRook
      3  64df				  -	      ECHO	""
      4  64df				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  64df				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  64df				  -	      ERR
      7  64df					      ENDIF
      8  64df		       a9 c9		      lda	#BANK_GenCastleMoveForRook
      9  64e1		       85 3f		      sta	SET_BANK
     10  64e3		       20 21 fc 	      jsr	GenCastleMoveForRook
    231  64e6		       b0 de		      bcs	.move	; move the rook!
    232  64e8
    233  64e8				   .exit
    234  64e8					      ENDIF
    235  64e8
    236  64e8
    237  64e8					      IF	ENPASSANT_ENABLED
    238  64e8
      0  64e8					      CALL	EnPassantFixupDraw	; generate enPassantPawn value
      1  64e8				  -	      IF	SLOT_EnPassantFixupDraw == _BANK_SLOT
      2  64e8				  -FNAME      SETSTR	EnPassantFixupDraw
      3  64e8				  -	      ECHO	""
      4  64e8				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  64e8				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  64e8				  -	      ERR
      7  64e8					      ENDIF
      8  64e8		       a9 84		      lda	#BANK_EnPassantFixupDraw
      9  64ea		       85 3f		      sta	SET_BANK
     10  64ec		       20 6b f8 	      jsr	EnPassantFixupDraw
    240  64ef							;CALL EnPassantRemoveCapturedPawn
    241  64ef
    242  64ef					      ENDIF
    243  64ef
    244  64ef
    245  64ef
    246  64ef							; Swap over sides
    247  64ef
      0  64ef					      NEGEVAL
      1  64ef
      2  64ef		       38		      sec
      3  64f0		       a9 00		      lda	#0
      4  64f2		       e5 8f		      sbc	Evaluation
      5  64f4		       85 8f		      sta	Evaluation
      6  64f6		       a9 00		      lda	#0
      7  64f8		       e5 90		      sbc	Evaluation+1
      8  64fa		       85 90		      sta	Evaluation+1
      0  64fc					      SWAP
      1  64fc		       a5 95		      lda	sideToMove
      2  64fe		       49 c0		      eor	#SWAP_SIDE|HUMAN
      3  6500		       85 95		      sta	sideToMove
      4  6502
      5  6502
    250  6502
    251  6502		       a5 94		      lda	currentPly
    252  6504		       85 3e		      sta	SET_BANK_RAM
    253  6506		       60		      rts
    254  6507
    255  6507
    256  6507							;---------------------------------------------------------------------------------------------------
    257  6507
    258  6507							;function negaMax(node, depth, α, β, color) is
    259  6507							;    if depth = 0 or node is a terminal node then
    260  6507							;	  return color × the heuristic value of node
    261  6507
    262  6507							;    childNodes := generateMoves(node)
    263  6507							;    childNodes := orderMoves(childNodes)
    264  6507							;    value := −∞
    265  6507							;    foreach child in childNodes do
    266  6507							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    267  6507							;	  α := max(α, value)
    268  6507							;	  if α ≥ β then
    269  6507							;	      break (* cut-off *)
    270  6507							;    return value
    271  6507							;(* Initial call for Player A's root node *)
    272  6507							;negaMax(rootNode, depth, −∞, +∞, 1)
    273  6507
    274  6507
    275  6507					      SUBROUTINE
    276  6507
    277  6507		       a9 ff	   .doQ       lda	#-1
    278  6509		       85 b2		      sta	__quiesceCapOnly
    279  650b		       20 a3 f6 	      jsr	quiesce
    280  650e		       e6 b2		      inc	__quiesceCapOnly
    281  6510		       60		      rts
    282  6511
    283  6511
      0  6511				   .exit      lda@PLY	value
      1  6511		       ad d6 f9 	      lda	value
    285  6514		       85 ae		      sta	__negaMax
      0  6516					      lda@PLY	value+1
      1  6516		       ad d7 f9 	      lda	value+1
    287  6519		       85 af		      sta	__negaMax+1
    288  651b		       60		      rts
    289  651c
    290  651c
    291  651c				   .terminal
    292  651c
    293  651c					      IF	QUIESCE_EXTRA_DEPTH > 0
    294  651c		       c9 00		      cmp	#0	; captured piece
    295  651e		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
    296  6520					      ENDIF
    297  6520
    298  6520
    299  6520		       a5 8f		      lda	Evaluation
    300  6522		       85 ae		      sta	__negaMax
    301  6524		       a5 90		      lda	Evaluation+1
    302  6526		       85 af		      sta	__negaMax+1
    303  6528
    304  6528		       60	   .inCheck2  rts
    305  6529
    306  6529
    307  6529
      0  6529					      DEF	negaMax
      1  6529				   SLOT_negaMax SET	_BANK_SLOT
      2  6529				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  6529				   negaMax
      4  6529				   TEMPORARY_VAR SET	Overlay
      5  6529				   TEMPORARY_OFFSET SET	0
      6  6529				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  6529				   FUNCTION_NAME SET	negaMax
    309  6529
    310  6529							; PARAMS depth-1, -beta, -alpha
    311  6529							; pased through temporary variables (__alpha, __beta) and X reg
    312  6529
    313  6529							; pass...
    314  6529							; x = depthleft
    315  6529							; a = captured piece
    316  6529							; SET_BANK_RAM      --> current ply
    317  6529							; __alpha[2] = param alpha
    318  6529							; __beta[2] = param beta
    319  6529
    320  6529
      0  6529					      COMMON_VARS
      1  6529
      0  6529					      VAR	__thinkbar, 1
      1  6529		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
      0  6529					      VAR	__toggle, 1
      1  6529		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
      4  6529
      0  6529					      VAR	__bestMove, 1
      1  6529		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
      0  6529					      VAR	__alpha, 2
      1  6529		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
      0  6529					      VAR	__beta, 2
      1  6529		       00 ac	   __beta     =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
      0  6529					      VAR	__negaMax, 2
      1  6529		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
      0  6529					      VAR	__value, 2
      1  6529		       00 b0	   __value    =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
     10  6529
      0  6529					      VAR	__quiesceCapOnly, 1
      1  6529		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
     12  6529
      0  6529					      VAR	__originalPiece, 1
      1  6529		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
      0  6529					      VAR	__capturedPiece, 1
      1  6529		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  6529				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6529
      4  6529				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6529				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6529				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6529					      ENDIF
      8  6529				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6529				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  6529				  -	      ERR
     11  6529					      ENDIF
     12  6529					      LIST	ON
     15  6529
      0  6529					      REFER	selectmove	;✅
      1  6529				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  6529				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  6529					      ENDIF
      0  6529					      VEND	negaMax
      1  6529				  -	      IFNCONST	negaMax
      2  6529				  -	      ECHO	"Incorrect VEND label", negaMax
      3  6529				  -	      ERR
      4  6529					      ENDIF
      5  6529		       00 b5	   VAREND_negaMax =	TEMPORARY_VAR
    324  6529
    325  6529		       48		      pha
    326  652a
    327  652a		       20 77 f0 	      jsr	ThinkBar	;@0
    328  652d
    329  652d		       a5 94		      lda	currentPly
    330  652f		       85 3e		      sta	SET_BANK_RAM	;@2
    331  6531
    332  6531		       68		      pla
    333  6532		       ca		      dex
    334  6533		       30 e7		      bmi	.terminal
      0  6535					      stx@PLY	depthLeft
      1  6535		       8e d8 fb 	      stx	[RAM]+depthLeft
    336  6538
    337  6538
    338  6538							; Allow the player to force computer to select a move. Press the SELECT switch
    339  6538
      0  6538					      lda@PLY	bestMove
      1  6538		       ad d1 f9 	      lda	bestMove
    341  653b		       30 07		      bmi	.noCheat	; can't force if no move chosen!
    342  653d		       ad 82 02 	      lda	SWCHB
    343  6540		       29 02		      and	#SELECT_SWITCH
    344  6542		       f0 cd		      beq	.exit	; SELECT abort
    345  6544				   .noCheat
    346  6544
    347  6544
      0  6544					      NEXT_RANDOM
      1  6544		       a5 81		      lda	rnd
      2  6546		       4a		      lsr
      3  6547		       90 02		      bcc	.skipEOR
      4  6549		       49 fe		      eor	#RND_EOR_VAL
      5  654b		       85 81	   .skipEOR   sta	rnd
    349  654d		       25 a1		      and	randomness
    350  654f		       65 8f		      adc	Evaluation
    351  6551		       85 8f		      sta	Evaluation	; since it's random we don't care about HI
    352  6553							;bcc .evOK
    353  6553							;inc Evaluation+1
    354  6553				   .evOK
    355  6553
    356  6553
    357  6553
    358  6553							;lda #2
    359  6553							;sta COLUPF			  ; grey thinkbars
    360  6553
    361  6553		       a5 aa		      lda	__alpha
      0  6555					      sta@PLY	alpha
      1  6555		       8d d2 fb 	      sta	[RAM]+alpha
    363  6558		       a5 ab		      lda	__alpha+1
      0  655a					      sta@PLY	alpha+1
      1  655a		       8d d3 fb 	      sta	[RAM]+alpha+1
    365  655d
    366  655d		       a5 ac		      lda	__beta
      0  655f					      sta@PLY	beta
      1  655f		       8d d4 fb 	      sta	[RAM]+beta
    368  6562		       a5 ad		      lda	__beta+1
      0  6564					      sta@PLY	beta+1
      1  6564		       8d d5 fb 	      sta	[RAM]+beta+1
    370  6567
    371  6567
    372  6567		       20 94 f1 	      jsr	GenerateAllMoves	;@0
    373  656a
    374  656a		       a5 9f		      lda	flagCheck
    375  656c		       d0 ba		      bne	.inCheck2	; OTHER guy in check
    376  656e
    377  656e		       a9 00		      lda	#<-INFINITY
      0  6570					      sta@PLY	value
      1  6570		       8d d6 fb 	      sta	[RAM]+value
    379  6573		       a9 90		      lda	#>-INFINITY
      0  6575					      sta@PLY	value+1
      1  6575		       8d d7 fb 	      sta	[RAM]+value+1
    381  6578
      0  6578					      ldx@PLY	moveIndex
      1  6578		       ae cf f9 	      ldx	moveIndex
    383  657b		       10 03		      bpl	.forChild
    384  657d		       4c 11 f5 	      jmp	.exit
    385  6580
      0  6580				   .forChild  stx@PLY	movePtr
      1  6580		       8e d0 fb 	      stx	[RAM]+movePtr
    387  6583
    388  6583		       20 8b f4 	      jsr	MakeMove	;@this
    389  6586
    390  6586
    391  6586							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    392  6586
    393  6586							; PARAMS depth-1, -beta, -alpha
    394  6586							; pased through temporary variables (__alpha, __beta) and X reg
    395  6586
    396  6586		       38		      sec
    397  6587		       a9 00		      lda	#0
      0  6589					      sbc@PLY	beta
      1  6589		       ed d4 f9 	      sbc	beta
    399  658c		       85 aa		      sta	__alpha
    400  658e		       a9 00		      lda	#0
      0  6590					      sbc@PLY	beta+1
      1  6590		       ed d5 f9 	      sbc	beta+1
    402  6593		       85 ab		      sta	__alpha+1
    403  6595
    404  6595		       38		      sec
    405  6596		       a9 00		      lda	#0
      0  6598					      sbc@PLY	alpha
      1  6598		       ed d2 f9 	      sbc	alpha
    407  659b		       85 ac		      sta	__beta
    408  659d		       a9 00		      lda	#0
      0  659f					      sbc@PLY	alpha+1
      1  659f		       ed d3 f9 	      sbc	alpha+1
    410  65a2		       85 ad		      sta	__beta+1
    411  65a4
    412  65a4
      0  65a4					      ldx@PLY	depthLeft
      1  65a4		       ae d8 f9 	      ldx	depthLeft
      0  65a7					      lda@PLY	capturedPiece
      1  65a7		       ad cb f9 	      lda	capturedPiece
    415  65aa
    416  65aa		       e6 94		      inc	currentPly
    417  65ac		       a4 94		      ldy	currentPly
    418  65ae		       84 3e		      sty	SET_BANK_RAM	; self-switch
    419  65b0
    420  65b0		       20 29 f5 	      jsr	negaMax	;@this
    421  65b3
    422  65b3		       c6 94		      dec	currentPly
    423  65b5		       a5 94		      lda	currentPly
    424  65b7		       85 3e		      sta	SET_BANK_RAM
    425  65b9
    426  65b9		       20 9b f2 	      jsr	unmakeMove	;@0
    427  65bc
    428  65bc		       38		      sec
    429  65bd		       a9 00		      lda	#0
    430  65bf		       e5 ae		      sbc	__negaMax
    431  65c1		       85 ae		      sta	__negaMax
    432  65c3		       a9 00		      lda	#0
    433  65c5		       e5 af		      sbc	__negaMax+1
    434  65c7		       85 af		      sta	__negaMax+1	; -negaMax(...)
    435  65c9
    436  65c9					      IF	1
    437  65c9		       a5 9f		      lda	flagCheck
    438  65cb		       f0 06		      beq	.notCheck
    439  65cd
    440  65cd							; at this point we've determined that the move was illegal, because the next ply detected
    441  65cd							; a king capture. So, the move should be totally discounted
    442  65cd
    443  65cd		       a9 00		      lda	#0
    444  65cf		       85 9f		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    445  65d1		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    446  65d3					      ENDIF
    447  65d3
    448  65d3		       38	   .notCheck  sec
      0  65d4					      lda@PLY	value
      1  65d4		       ad d6 f9 	      lda	value
    450  65d7		       e5 ae		      sbc	__negaMax
      0  65d9					      lda@PLY	value+1
      1  65d9		       ad d7 f9 	      lda	value+1
    452  65dc		       e5 af		      sbc	__negaMax+1
    453  65de		       50 02		      bvc	.lab0
    454  65e0		       49 80		      eor	#$80
    455  65e2		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    456  65e4
    457  65e4							; so, negaMax > value!
    458  65e4
    459  65e4		       a5 ae		      lda	__negaMax
      0  65e6					      sta@PLY	value
      1  65e6		       8d d6 fb 	      sta	[RAM]+value
    461  65e9		       a5 af		      lda	__negaMax+1
      0  65eb					      sta@PLY	value+1	; max(value, -negaMax)
      1  65eb		       8d d7 fb 	      sta	[RAM]+value+1
    463  65ee
      0  65ee					      lda@PLY	movePtr
      1  65ee		       ad d0 f9 	      lda	movePtr
      0  65f1					      sta@PLY	bestMove
      1  65f1		       8d d1 fb 	      sta	[RAM]+bestMove
    466  65f4				   .lt0
    467  65f4
    468  65f4							;	  α := max(α, value)
    469  65f4
    470  65f4		       38		      sec
      0  65f5					      lda@PLY	value
      1  65f5		       ad d6 f9 	      lda	value
      0  65f8					      sbc@PLY	alpha
      1  65f8		       ed d2 f9 	      sbc	alpha
      0  65fb					      lda@PLY	value+1
      1  65fb		       ad d7 f9 	      lda	value+1
      0  65fe					      sbc@PLY	alpha+1
      1  65fe		       ed d3 f9 	      sbc	alpha+1
    475  6601		       50 02		      bvc	.lab1
    476  6603		       49 80		      eor	#$80
    477  6605		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    478  6607
      0  6607					      lda@PLY	value
      1  6607		       ad d6 f9 	      lda	value
      0  660a					      sta@PLY	alpha
      1  660a		       8d d2 fb 	      sta	[RAM]+alpha
      0  660d					      lda@PLY	value+1
      1  660d		       ad d7 f9 	      lda	value+1
      0  6610					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  6610		       8d d3 fb 	      sta	[RAM]+alpha+1
    483  6613
    484  6613				   .lt1
    485  6613
    486  6613							;	  if α ≥ β then
    487  6613							;	      break (* cut-off *)
    488  6613
    489  6613		       38		      sec
      0  6614					      lda@PLY	alpha
      1  6614		       ad d2 f9 	      lda	alpha
      0  6617					      sbc@PLY	beta
      1  6617		       ed d4 f9 	      sbc	beta
      0  661a					      lda@PLY	alpha+1
      1  661a		       ad d3 f9 	      lda	alpha+1
      0  661d					      sbc@PLY	beta+1
      1  661d		       ed d5 f9 	      sbc	beta+1
    494  6620		       50 02		      bvc	.lab2
    495  6622		       49 80		      eor	#$80
    496  6624		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    497  6626
    498  6626
      0  6626				   .nextMove  ldx@PLY	movePtr
      1  6626		       ae d0 f9 	      ldx	movePtr
    500  6629		       ca	   .nextX     dex
    501  662a		       30 03		      bmi	.retrn
    502  662c		       4c 80 f5 	      jmp	.forChild
    503  662f
    504  662f		       4c 11 f5    .retrn     jmp	.exit
    505  6632
    506  6632							;---------------------------------------------------------------------------------------------------
    507  6632
    508  6632					      MAC	xchg
    509  6632					      lda@PLY	{1},x
    510  6632					      pha		;sta __xchg
    511  6632					      lda@PLY	{1},y
    512  6632					      sta@PLY	{1},x
    513  6632					      pla		;lda __xchg
    514  6632					      sta@PLY	{1},y
    515  6632					      ENDM		;{name}
    516  6632
    517  6632
      0  6632					      DEF	Sort
      1  6632				   SLOT_Sort  SET	_BANK_SLOT
      2  6632				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  6632				   Sort
      4  6632				   TEMPORARY_VAR SET	Overlay
      5  6632				   TEMPORARY_OFFSET SET	0
      6  6632				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  6632				   FUNCTION_NAME SET	Sort
    519  6632					      SUBROUTINE
    520  6632
      0  6632					      REFER	GenerateAllMoves
      1  6632					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6632				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6632					      ENDIF
      0  6632					      VAR	__xchg, 1
      1  6632		       00 b8	   __xchg     =	TEMPORARY_VAR
      2  6632				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6632
      4  6632				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6632				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6632				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6632					      ENDIF
      8  6632				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6632				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  6632				  -	      ERR
     11  6632					      ENDIF
     12  6632					      LIST	ON
      0  6632					      VEND	Sort
      1  6632				  -	      IFNCONST	Sort
      2  6632				  -	      ECHO	"Incorrect VEND label", Sort
      3  6632				  -	      ERR
      4  6632					      ENDIF
      5  6632		       00 b9	   VAREND_Sort =	TEMPORARY_VAR
    524  6632
    525  6632		       a5 b2		      lda	__quiesceCapOnly
    526  6634		       d0 4a		      bne	.exit	; only caps present so already sorted!
    527  6636
      0  6636					      ldx@PLY	moveIndex
      1  6636		       ae cf f9 	      ldx	moveIndex
      0  6639					      ldy@PLY	moveIndex
      1  6639		       ac cf f9 	      ldy	moveIndex
    530  663c		       c8		      iny		; this is OK - swaps "1st" with itself if it's a capture
    531  663d
    532  663d		       88	   .next      dey
    533  663e		       30 40		      bmi	.exit
    534  6640
      0  6640					      lda@PLY	MoveCapture,y
      1  6640		       b9 64 f9 	      lda	MoveCapture,y
    536  6643		       f0 f8		      beq	.next
    537  6645
      0  6645					      XCHG	MoveFrom
      0  6645					      lda@PLY	MoveFrom,x
      1  6645		       bd 00 f8 	      lda	MoveFrom,x
      2  6648		       48		      pha
      0  6649					      lda@PLY	MoveFrom,y
      1  6649		       b9 00 f8 	      lda	MoveFrom,y
      0  664c					      sta@PLY	MoveFrom,x
      1  664c		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  664f		       68		      pla
      0  6650					      sta@PLY	MoveFrom,y
      1  6650		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  6653					      XCHG	MoveTo
      0  6653					      lda@PLY	MoveTo,x
      1  6653		       bd 64 f8 	      lda	MoveTo,x
      2  6656		       48		      pha
      0  6657					      lda@PLY	MoveTo,y
      1  6657		       b9 64 f8 	      lda	MoveTo,y
      0  665a					      sta@PLY	MoveTo,x
      1  665a		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  665d		       68		      pla
      0  665e					      sta@PLY	MoveTo,y
      1  665e		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  6661					      XCHG	MovePiece
      0  6661					      lda@PLY	MovePiece,x
      1  6661		       bd 00 f9 	      lda	MovePiece,x
      2  6664		       48		      pha
      0  6665					      lda@PLY	MovePiece,y
      1  6665		       b9 00 f9 	      lda	MovePiece,y
      0  6668					      sta@PLY	MovePiece,x
      1  6668		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  666b		       68		      pla
      0  666c					      sta@PLY	MovePiece,y
      1  666c		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  666f					      XCHG	MoveCapture
      0  666f					      lda@PLY	MoveCapture,x
      1  666f		       bd 64 f9 	      lda	MoveCapture,x
      2  6672		       48		      pha
      0  6673					      lda@PLY	MoveCapture,y
      1  6673		       b9 64 f9 	      lda	MoveCapture,y
      0  6676					      sta@PLY	MoveCapture,x
      1  6676		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  6679		       68		      pla
      0  667a					      sta@PLY	MoveCapture,y
      1  667a		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    542  667d
    543  667d		       ca		      dex
    544  667e		       10 bd		      bpl	.next
    545  6680
    546  6680				   .exit
    547  6680
    548  6680
    549  6680
    550  6680
    551  6680							; Scan for capture of king
    552  6680							; Also scan for virtual king captures (squares involved in castling)
    553  6680
      0  6680					      ldx@PLY	moveIndex
      1  6680		       ae cf f9 	      ldx	moveIndex
    555  6683		       30 19		      bmi	.notCheck	; OK if no captures in quiesce!
    556  6685
      0  6685				   .scanCheck lda@PLY	MoveCapture,x
      1  6685		       bd 64 f9 	      lda	MoveCapture,x
    558  6688		       29 0f		      and	#PIECE_MASK
    559  668a		       c9 07		      cmp	#KING
    560  668c		       f0 12		      beq	.check
    561  668e
    562  668e							; If the squares the king is crossing for castling are capturable, then that's an illegal
    563  668e							; castle move and it's treated as if the king were in check.
    564  668e
      0  668e					      lda@PLY	MoveTo,x
      1  668e		       bd 64 f8 	      lda	MoveTo,x
      0  6691					      cmp@PLY	virtualKingSquare
      1  6691		       cd da f9 	      cmp	virtualKingSquare
    567  6694		       f0 0a		      beq	.check
      0  6696					      cmp@PLY	virtualKingSquare+1
      1  6696		       cd db f9 	      cmp	virtualKingSquare+1
    569  6699		       f0 05		      beq	.check
    570  669b
    571  669b		       ca	   .nextScan  dex
    572  669c		       10 e7		      bpl	.scanCheck
    573  669e
    574  669e		       a9 00	   .notCheck  lda	#0
    575  66a0		       85 9f	   .check     sta	flagCheck
    576  66a2		       60		      rts
    577  66a3
    578  66a3
    579  66a3							;---------------------------------------------------------------------------------------------------
    580  66a3							; QUIESCE!
    581  66a3
    582  66a3							;int Quiesce( int alpha, int beta ) {
    583  66a3							;    int stand_pat = Evaluate();
    584  66a3							;    if( stand_pat >= beta )
    585  66a3							;	  return beta;
    586  66a3							;    if( alpha < stand_pat )
    587  66a3							;	  alpha = stand_pat;
    588  66a3
    589  66a3							;    until( every_capture_has_been_examined )	{
    590  66a3							;	  MakeCapture();
    591  66a3							;	  score = -Quiesce( -beta, -alpha );
    592  66a3							;	  TakeBackMove();
    593  66a3
    594  66a3							;	  if( score >= beta )
    595  66a3							;	      return beta;
    596  66a3							;	  if( score > alpha )
    597  66a3							;	     alpha = score;
    598  66a3							;    }
    599  66a3							;    return alpha;
    600  66a3							;}
    601  66a3
    602  66a3
    603  66a3							;---------------------------------------------------------------------------------------------------
    604  66a3
      0  66a3					      DEF	quiesce
      1  66a3				   SLOT_quiesce SET	_BANK_SLOT
      2  66a3				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  66a3				   quiesce
      4  66a3				   TEMPORARY_VAR SET	Overlay
      5  66a3				   TEMPORARY_OFFSET SET	0
      6  66a3				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  66a3				   FUNCTION_NAME SET	quiesce
    606  66a3					      SUBROUTINE
    607  66a3
    608  66a3							; pass...
    609  66a3							; x = depthleft
    610  66a3							; SET_BANK_RAM      --> current ply
    611  66a3							; __alpha[2] = param alpha
    612  66a3							; __beta[2] = param beta
    613  66a3
    614  66a3
      0  66a3					      COMMON_VARS
      1  66a3
      0  66a3					      VAR	__thinkbar, 1
      1  66a3		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
      0  66a3					      VAR	__toggle, 1
      1  66a3		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
      4  66a3
      0  66a3					      VAR	__bestMove, 1
      1  66a3		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
      0  66a3					      VAR	__alpha, 2
      1  66a3		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
      0  66a3					      VAR	__beta, 2
      1  66a3		       00 ac	   __beta     =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
      0  66a3					      VAR	__negaMax, 2
      1  66a3		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
      0  66a3					      VAR	__value, 2
      1  66a3		       00 b0	   __value    =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
     10  66a3
      0  66a3					      VAR	__quiesceCapOnly, 1
      1  66a3		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
     12  66a3
      0  66a3					      VAR	__originalPiece, 1
      1  66a3		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
      0  66a3					      VAR	__capturedPiece, 1
      1  66a3		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  66a3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  66a3
      4  66a3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  66a3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  66a3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  66a3					      ENDIF
      8  66a3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  66a3				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  66a3				  -	      ERR
     11  66a3					      ENDIF
     12  66a3					      LIST	ON
     15  66a3
      0  66a3					      REFER	negaMax
      1  66a3				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  66a3				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  66a3					      ENDIF
      0  66a3					      VEND	quiesce
      1  66a3				  -	      IFNCONST	quiesce
      2  66a3				  -	      ECHO	"Incorrect VEND label", quiesce
      3  66a3				  -	      ERR
      4  66a3					      ENDIF
      5  66a3		       00 b5	   VAREND_quiesce =	TEMPORARY_VAR
    618  66a3
    619  66a3		       a5 94		      lda	currentPly
    620  66a5		       c9 90		      cmp	#RAMBANK_PLY + PLY_BANKS -1
    621  66a7		       b0 28		      bcs	.retBeta
    622  66a9							;sta SET_BANK_RAM ;tmp
    623  66a9
    624  66a9
    625  66a9		       20 77 f0 	      jsr	ThinkBar	;@0
    626  66ac
    627  66ac		       a5 ac		      lda	__beta
      0  66ae					      sta@PLY	beta
      1  66ae		       8d d4 fb 	      sta	[RAM]+beta
    629  66b1		       a5 ad		      lda	__beta+1
      0  66b3					      sta@PLY	beta+1
      1  66b3		       8d d5 fb 	      sta	[RAM]+beta+1
    631  66b6
    632  66b6		       a5 aa		      lda	__alpha
      0  66b8					      sta@PLY	alpha
      1  66b8		       8d d2 fb 	      sta	[RAM]+alpha
    634  66bb		       a5 ab		      lda	__alpha+1
      0  66bd					      sta@PLY	alpha+1
      1  66bd		       8d d3 fb 	      sta	[RAM]+alpha+1
    636  66c0
    637  66c0
    638  66c0							;    int stand_pat = Evaluate();
    639  66c0							;    if( stand_pat >= beta )
    640  66c0							;	  return beta;
    641  66c0
    642  66c0		       38		      sec
    643  66c1		       a5 8f		      lda	Evaluation
      0  66c3					      sbc@PLY	beta
      1  66c3		       ed d4 f9 	      sbc	beta
    645  66c6		       a5 90		      lda	Evaluation+1
      0  66c8					      sbc@PLY	beta+1
      1  66c8		       ed d5 f9 	      sbc	beta+1
    647  66cb		       50 02		      bvc	.spat0
    648  66cd		       49 80		      eor	#$80
    649  66cf		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    650  66d1
    651  66d1		       ad d4 f9    .retBeta   lda	beta
    652  66d4		       85 ae		      sta	__negaMax
    653  66d6		       ad d5 f9 	      lda	beta+1
    654  66d9		       85 af		      sta	__negaMax+1
    655  66db
    656  66db		       60	   .abort     rts
    657  66dc
    658  66dc				   .norb
    659  66dc
    660  66dc
    661  66dc							;    if( alpha < stand_pat )
    662  66dc							;	  alpha = stand_pat;
    663  66dc
    664  66dc		       38		      sec
    665  66dd		       ad d2 f9 	      lda	alpha
    666  66e0		       e5 8f		      sbc	Evaluation
    667  66e2		       ad d3 f9 	      lda	alpha+1
    668  66e5		       e5 90		      sbc	Evaluation+1
    669  66e7		       50 02		      bvc	.spat1
    670  66e9		       49 80		      eor	#$80
    671  66eb		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    672  66ed
    673  66ed							; alpha < stand_pat
    674  66ed
    675  66ed		       a5 8f		      lda	Evaluation
      0  66ef					      sta@PLY	alpha
      1  66ef		       8d d2 fb 	      sta	[RAM]+alpha
    677  66f2		       a5 90		      lda	Evaluation+1
      0  66f4					      sta@PLY	alpha+1
      1  66f4		       8d d3 fb 	      sta	[RAM]+alpha+1
    679  66f7
    680  66f7				   .alpha
    681  66f7		       20 94 f1 	      jsr	GenerateAllMoves
    682  66fa		       a5 9f		      lda	flagCheck
    683  66fc		       d0 dd		      bne	.abort	; pure abort
    684  66fe
      0  66fe					      ldx@PLY	moveIndex
      1  66fe		       ae cf f9 	      ldx	moveIndex
    686  6701		       30 76		      bmi	.exit
    687  6703
      0  6703				   .forChild  stx@PLY	movePtr
      1  6703		       8e d0 fb 	      stx	[RAM]+movePtr
    689  6706
    690  6706							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    691  6706
    692  6706		       20 8b f4 	      jsr	MakeMove	;@this
    693  6709
    694  6709		       38		      sec
    695  670a		       a9 00		      lda	#0
      0  670c					      sbc@PLY	beta
      1  670c		       ed d4 f9 	      sbc	beta
    697  670f		       85 aa		      sta	__alpha
    698  6711		       a9 00		      lda	#0
      0  6713					      sbc@PLY	beta+1
      1  6713		       ed d5 f9 	      sbc	beta+1
    700  6716		       85 ab		      sta	__alpha+1
    701  6718
    702  6718		       38		      sec
    703  6719		       a9 00		      lda	#0
      0  671b					      sbc@PLY	alpha
      1  671b		       ed d2 f9 	      sbc	alpha
    705  671e		       85 ac		      sta	__beta
    706  6720		       a9 00		      lda	#0
      0  6722					      sbc@PLY	alpha+1
      1  6722		       ed d3 f9 	      sbc	alpha+1
    708  6725		       85 ad		      sta	__beta+1
    709  6727
    710  6727		       e6 94		      inc	currentPly
    711  6729		       a5 94		      lda	currentPly
    712  672b		       85 3e		      sta	SET_BANK_RAM	; self-switch
    713  672d
    714  672d		       20 a3 f6 	      jsr	quiesce	;@this
    715  6730
    716  6730		       c6 94		      dec	currentPly
    717  6732
    718  6732		       20 9b f2 	      jsr	unmakeMove	;@0
    719  6735
    720  6735		       a5 9f		      lda	flagCheck	; don't consider moves which leave us in check
    721  6737		       d0 4b		      bne	.inCheck
    722  6739
    723  6739		       38		      sec
    724  673a							;lda #0			 ; already 0
    725  673a		       e5 ae		      sbc	__negaMax
    726  673c		       85 ae		      sta	__negaMax
    727  673e		       a9 00		      lda	#0
    728  6740		       e5 af		      sbc	__negaMax+1
    729  6742		       85 af		      sta	__negaMax+1	; -negaMax(...)
    730  6744
    731  6744
    732  6744
    733  6744							;	  if( score >= beta )
    734  6744							;	      return beta;
    735  6744
    736  6744
    737  6744		       38		      sec
    738  6745		       a5 ae		      lda	__negaMax
      0  6747					      sbc@PLY	beta
      1  6747		       ed d4 f9 	      sbc	beta
    740  674a		       a5 af		      lda	__negaMax+1
      0  674c					      sbc@PLY	beta+1
      1  674c		       ed d5 f9 	      sbc	beta+1
    742  674f		       50 02		      bvc	.lab0
    743  6751		       49 80		      eor	#$80
    744  6753		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    745  6755		       4c d1 f6 	      jmp	.retBeta
    746  6758				   .nrb2
    747  6758
    748  6758							;	  if( score > alpha )
    749  6758							;	     alpha = score;
    750  6758							;    }
    751  6758
    752  6758		       38		      sec
      0  6759					      lda@PLY	alpha
      1  6759		       ad d2 f9 	      lda	alpha
    754  675c		       e5 ae		      sbc	__negaMax
      0  675e					      lda@PLY	alpha+1
      1  675e		       ad d3 f9 	      lda	alpha+1
    756  6761		       e5 af		      sbc	__negaMax+1
    757  6763		       50 02		      bvc	.lab2
    758  6765		       49 80		      eor	#$80
    759  6767		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    760  6769
    761  6769							; score > alpha
    762  6769
    763  6769		       a5 ae		      lda	__negaMax
      0  676b					      sta@PLY	alpha
      1  676b		       8d d2 fb 	      sta	[RAM]+alpha
    765  676e		       a5 af		      lda	__negaMax+1
      0  6770					      sta@PLY	alpha+1
      1  6770		       8d d3 fb 	      sta	[RAM]+alpha+1
    767  6773
      0  6773				   .nextMove  ldx@PLY	movePtr
      1  6773		       ae d0 f9 	      ldx	movePtr
    769  6776		       ca		      dex
    770  6777		       10 8a		      bpl	.forChild
    771  6779
    772  6779							;    return alpha;
    773  6779
    774  6779				   .exit
      0  6779					      lda@PLY	alpha
      1  6779		       ad d2 f9 	      lda	alpha
    776  677c		       85 ae		      sta	__negaMax
      0  677e					      lda@PLY	alpha+1
      1  677e		       ad d3 f9 	      lda	alpha+1
    778  6781		       85 af		      sta	__negaMax+1
    779  6783		       60		      rts
    780  6784
    781  6784		       a9 00	   .inCheck   lda	#0
    782  6786		       85 9f		      sta	flagCheck
    783  6788		       f0 e9		      beq	.nextMove
    784  678a
    785  678a
    786  678a							;---------------------------------------------------------------------------------------------------
    787  678a
      0  678a					      CHECK_BANK_SIZE	"NEGAMAX"
      1  678a		       03 8a	   .TEMP      =	* - _BANK_START
 NEGAMAX (1K) SIZE =  $38a , FREE= $76
      2  678a					      ECHO	"NEGAMAX", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  678a				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  678a				  -	      ECHO	"BANK OVERFLOW @ ", "NEGAMAX", " size=", * - ORIGIN
      5  678a				  -	      ERR
      6  678a					      ENDIF
    789  678a
    790  678a							;---------------------------------------------------------------------------------------------------
    791  678a							; EOF
------- FILE ./chess.asm
    568  678a
    569  678a
------- FILE PIECE_HANDLER@1#1.asm LEVEL 2 PASS 4
      0  678a					      include	"PIECE_HANDLER@1#1.asm"
      0  678a					      SLOT	1
      1  678a				  -	      IF	(1 < 0) || (1 > 3)
      2  678a				  -	      ECHO	"Illegal bank address/segment location", 1
      3  678a				  -	      ERR
      4  678a					      ENDIF
      5  678a				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  678a				   _BANK_SLOT SET	1 * 64
      0  678a					      ROMBANK	PIECE_HANDLER_1
      1  6acc ????				      SEG	PIECE_HANDLER_1
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   PIECE_HANDLER_1_START SET	*
      6  6800				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6800				   PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + 1024
      3  6800
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  6800					      include	"PIECE_PAWN.asm"
      1  6800							; Copyright (C)2020 Andrew Davie
      2  6800							; Pawn move handlers
      3  6800
      4  6800							;---------------------------------------------------------------------------------------------------
      5  6800							; WHITE PAWN
      6  6800							;---------------------------------------------------------------------------------------------------
      7  6800
      8  6800		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  6800		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  6800
     11  6800							;---------------------------------------------------------------------------------------------------
     12  6800
     13  6800					      MAC	en_passant
     14  6800					      SUBROUTINE
     15  6800							; {1} = _LEFT or _RIGHT
     16  6800
     17  6800					      ldx	currentSquare
     18  6800					      ldy	ValidSquare+{1},x
     19  6800					      cpy	enPassantPawn
     20  6800					      bne	.invalid
     21  6800					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  6800					      lda	Board,y
     23  6800					      bne	.invalid
     24  6800					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  6800				   .invalid
     26  6800					      ENDM
     27  6800
     28  6800							;---------------------------------------------------------------------------------------------------
     29  6800
     30  6800					      MAC	promote_pawn
     31  6800							;SUBROUTINE
     32  6800
     33  6800							;{1} = BLACK or WHITE
     34  6800
     35  6800
     36  6800					      sty	__temp
     37  6800					      lda	#{1}|QUEEN
     38  6800					      sta	currentPiece
     39  6800					      jsr	AddMove
     40  6800
     41  6800					      lda	#{1}|ROOK
     42  6800					      sta	currentPiece
     43  6800					      ldy	__temp
     44  6800					      jsr	AddMove
     45  6800
     46  6800					      lda	#{1}|BISHOP
     47  6800					      sta	currentPiece
     48  6800					      ldy	__temp
     49  6800					      jsr	AddMove
     50  6800
     51  6800					      lda	#{1}|KNIGHT
     52  6800					      sta	currentPiece
     53  6800					      ldy	__temp
     54  6800					      jsr	AddMove
     55  6800
     56  6800					      IF	{1} = WHITE
     57  6800					      lda	#WHITE|WP
     58  6800					      ENDIF
     59  6800					      IF	{1} = BLACK
     60  6800					      lda	#BLACK|BP
     61  6800					      ENDIF
     62  6800					      sta	currentPiece
     63  6800					      ENDM
     64  6800
     65  6800							;---------------------------------------------------------------------------------------------------
     66  6800
     67  6800					      MAC	move_or_promote_pawn
     68  6800							;SUBROUTINE
     69  6800							; {1} = BLACK or WHITE
     70  6800
     71  6800					      IF	{1} = WHITE
     72  6800					      cpy	#90	; last rank?
     73  6800					      bcc	.standard
     74  6800					      jsr	PromoteWhitePawn
     75  6800					      jmp	.pMoved
     76  6800					      ENDIF
     77  6800
     78  6800					      IF	{1} = BLACK
     79  6800					      cpy	#30	; last rank?
     80  6800					      bcs	.standard
     81  6800					      jsr	PromoteBlackPawn
     82  6800					      jmp	.pMoved
     83  6800					      ENDIF
     84  6800
     85  6800				   .standard  jsr	AddMove	; add +1UP move
     86  6800				   .pMoved
     87  6800
     88  6800					      ENDM
     89  6800
     90  6800							;---------------------------------------------------------------------------------------------------
     91  6800
     92  6800					      MAC	take
     93  6800							;SUBROUTINE
     94  6800							; {1} = capture square offset
     95  6800
     96  6800					      ldx	currentSquare
     97  6800					      ldy	ValidSquare+{1},x
     98  6800					      bmi	.invalid2
     99  6800					      lda	Board,y
    100  6800					      beq	.invalid2	; square empty
    101  6800					      sta	capture
    102  6800					      eor	currentPiece
    103  6800					      bpl	.invalid	; same colour
    104  6800
    105  6800					      MOVE_OR_PROMOTE_PAWN	{2}
    106  6800
    107  6800					      jmp	.invalid2
    108  6800				   .invalid   inc	protecting
    109  6800				   .invalid2
    110  6800					      ENDM
    111  6800
    112  6800							;---------------------------------------------------------------------------------------------------
    113  6800
      0  6800					      DEF	PromoteWhitePawn
      1  6800				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  6800				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  6800				   PromoteWhitePawn
      4  6800				   TEMPORARY_VAR SET	Overlay
      5  6800				   TEMPORARY_OFFSET SET	0
      6  6800				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  6800				   FUNCTION_NAME SET	PromoteWhitePawn
    115  6800					      SUBROUTINE
    116  6800
      0  6800					      REFER	Handle_WHITE_PAWN
      1  6800					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  6800				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  6800					      ENDIF
      0  6800					      VAR	__temp, 1
      1  6800		       00 b8	   __temp     =	TEMPORARY_VAR
      2  6800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6800
      4  6800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6800					      ENDIF
      8  6800				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6800				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  6800				  -	      ERR
     11  6800					      ENDIF
     12  6800					      LIST	ON
      0  6800					      VEND	PromoteWhitePawn
      1  6800				  -	      IFNCONST	PromoteWhitePawn
      2  6800				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  6800				  -	      ERR
      4  6800					      ENDIF
      5  6800		       00 b9	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  6800
      0  6800					      PROMOTE_PAWN	WHITE
      1  6800
      2  6800
      3  6800
      4  6800
      5  6800
      6  6800		       84 b8		      sty	__temp
      7  6802		       a9 06		      lda	#WHITE|QUEEN
      8  6804		       85 91		      sta	currentPiece
      9  6806		       20 73 f2 	      jsr	AddMove
     10  6809
     11  6809		       a9 05		      lda	#WHITE|ROOK
     12  680b		       85 91		      sta	currentPiece
     13  680d		       a4 b8		      ldy	__temp
     14  680f		       20 73 f2 	      jsr	AddMove
     15  6812
     16  6812		       a9 04		      lda	#WHITE|BISHOP
     17  6814		       85 91		      sta	currentPiece
     18  6816		       a4 b8		      ldy	__temp
     19  6818		       20 73 f2 	      jsr	AddMove
     20  681b
     21  681b		       a9 03		      lda	#WHITE|KNIGHT
     22  681d		       85 91		      sta	currentPiece
     23  681f		       a4 b8		      ldy	__temp
     24  6821		       20 73 f2 	      jsr	AddMove
     25  6824
     26  6824					      IF	WHITE = WHITE
     27  6824		       a9 01		      lda	#WHITE|WP
     28  6826					      ENDIF
     29  6826				  -	      IF	WHITE = BLACK
     30  6826				  -	      lda	#BLACK|BP
     31  6826					      ENDIF
     32  6826		       85 91		      sta	currentPiece
    122  6828		       60		      rts
    123  6829
    124  6829							;---------------------------------------------------------------------------------------------------
    125  6829
      0  6829					      DEF	Handle_WHITE_PAWN
      1  6829				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  6829				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  6829				   Handle_WHITE_PAWN
      4  6829				   TEMPORARY_VAR SET	Overlay
      5  6829				   TEMPORARY_OFFSET SET	0
      6  6829				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  6829				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  6829					      SUBROUTINE
    128  6829
      0  6829					      REFER	GenerateAllMoves
      1  6829					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6829				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6829					      ENDIF
      0  6829					      VEND	Handle_WHITE_PAWN
      1  6829				  -	      IFNCONST	Handle_WHITE_PAWN
      2  6829				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  6829				  -	      ERR
      4  6829					      ENDIF
      5  6829		       00 b8	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  6829
    132  6829		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  682c		       b9 79 fc 	      lda	Board,y
    134  682f		       d0 26		      bne	.pMoved	; occupied
    135  6831		       85 9b		      sta	capture
    136  6833
    137  6833							; we may need to promote the pawn
    138  6833							; All possibilites (Q/R/B/N) are added as individual moves
    139  6833
      0  6833					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  6833
      2  6833
      3  6833
      4  6833					      IF	WHITE = WHITE
      5  6833		       c0 5a		      cpy	#90
      6  6835		       90 06		      bcc	.standard
      7  6837		       20 00 f4 	      jsr	PromoteWhitePawn
      8  683a		       4c 40 f4 	      jmp	.pMoved
      9  683d					      ENDIF
     10  683d
     11  683d				  -	      IF	WHITE = BLACK
     12  683d				  -	      cpy	#30
     13  683d				  -	      bcs	.standard
     14  683d				  -	      jsr	PromoteBlackPawn
     15  683d				  -	      jmp	.pMoved
     16  683d					      ENDIF
     17  683d
     18  683d		       20 73 f2    .standard  jsr	AddMove
     19  6840				   .pMoved
     20  6840
    141  6840
    142  6840							; the +2 move off the home rank...
    143  6840
    144  6840		       a6 92		      ldx	currentSquare
    145  6842		       e0 28		      cpx	#WHITE_HOME_ROW
    146  6844		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  6846		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  6849		       b9 79 fc 	      lda	Board,y
    149  684c		       d0 09		      bne	.pMoved	; destination square occupied
    150  684e
    151  684e		       a5 91		      lda	currentPiece
    152  6850		       09 20		      ora	#FLAG_ENPASSANT
    153  6852		       85 91		      sta	currentPiece	; GENERATE en-passant opportunity
    154  6854
    155  6854		       20 73 f2 	      jsr	AddMove	; add the +2UP move off home row
    156  6857
    157  6857				   .pMoved
    158  6857
    159  6857							; regular captures...
    160  6857
      0  6857					      TAKE	_UP+_LEFT, WHITE
      1  6857
      2  6857
      3  6857
      4  6857		       a6 92		      ldx	currentSquare
      5  6859		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  685c		       30 1d		      bmi	.invalid2
      7  685e		       b9 79 fc 	      lda	Board,y
      8  6861		       f0 18		      beq	.invalid2
      9  6863		       85 9b		      sta	capture
     10  6865		       45 91		      eor	currentPiece
     11  6867		       10 10		      bpl	.invalid
     12  6869
      0  6869					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  6869
      2  6869
      3  6869
      4  6869					      IF	WHITE = WHITE
      5  6869		       c0 5a		      cpy	#90
      6  686b		       90 06		      bcc	.standard
      7  686d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  6870		       4c 76 f4 	      jmp	.pMoved
      9  6873					      ENDIF
     10  6873
     11  6873				  -	      IF	WHITE = BLACK
     12  6873				  -	      cpy	#30
     13  6873				  -	      bcs	.standard
     14  6873				  -	      jsr	PromoteBlackPawn
     15  6873				  -	      jmp	.pMoved
     16  6873					      ENDIF
     17  6873
     18  6873		       20 73 f2    .standard  jsr	AddMove
     19  6876				   .pMoved
     20  6876
     14  6876
     15  6876		       4c 7b f4 	      jmp	.invalid2
     16  6879		       e6 a0	   .invalid   inc	protecting
     17  687b				   .invalid2
      0  687b					      TAKE	_UP+_RIGHT, WHITE
      1  687b
      2  687b
      3  687b
      4  687b		       a6 92		      ldx	currentSquare
      5  687d		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  6880		       30 1d		      bmi	.invalid2
      7  6882		       b9 79 fc 	      lda	Board,y
      8  6885		       f0 18		      beq	.invalid2
      9  6887		       85 9b		      sta	capture
     10  6889		       45 91		      eor	currentPiece
     11  688b		       10 10		      bpl	.invalid
     12  688d
      0  688d					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  688d
      2  688d
      3  688d
      4  688d					      IF	WHITE = WHITE
      5  688d		       c0 5a		      cpy	#90
      6  688f		       90 06		      bcc	.standard
      7  6891		       20 00 f4 	      jsr	PromoteWhitePawn
      8  6894		       4c 9a f4 	      jmp	.pMoved
      9  6897					      ENDIF
     10  6897
     11  6897				  -	      IF	WHITE = BLACK
     12  6897				  -	      cpy	#30
     13  6897				  -	      bcs	.standard
     14  6897				  -	      jsr	PromoteBlackPawn
     15  6897				  -	      jmp	.pMoved
     16  6897					      ENDIF
     17  6897
     18  6897		       20 73 f2    .standard  jsr	AddMove
     19  689a				   .pMoved
     20  689a
     14  689a
     15  689a		       4c 9f f4 	      jmp	.invalid2
     16  689d		       e6 a0	   .invalid   inc	protecting
     17  689f				   .invalid2
    163  689f
    164  689f
    165  689f					      IF	ENPASSANT_ENABLED
    166  689f							; en-passant captures...
    167  689f
    168  689f		       a5 93		      lda	enPassantPawn
    169  68a1		       f0 2e		      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  68a3
    171  68a3		       a5 91		      lda	currentPiece
    172  68a5		       09 20		      ora	#FLAG_ENPASSANT
    173  68a7		       85 91		      sta	currentPiece	; CONSUME en-passant opportunity
    174  68a9
      0  68a9					      EN_PASSANT	_LEFT, _UP
      1  68a9					      SUBROUTINE
      2  68a9
      3  68a9
      4  68a9		       a6 92		      ldx	currentSquare
      5  68ab		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  68ae		       c4 93		      cpy	enPassantPawn
      7  68b0		       d0 0b		      bne	.invalid
      8  68b2		       bc 1e fc 	      ldy	ValidSquare+_LEFT+_UP,x
      9  68b5		       b9 79 fc 	      lda	Board,y
     10  68b8		       d0 03		      bne	.invalid
     11  68ba		       20 73 f2 	      jsr	AddMove
     12  68bd				   .invalid
      0  68bd					      EN_PASSANT	_RIGHT, _UP
      1  68bd					      SUBROUTINE
      2  68bd
      3  68bd
      4  68bd		       a6 92		      ldx	currentSquare
      5  68bf		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  68c2		       c4 93		      cpy	enPassantPawn
      7  68c4		       d0 0b		      bne	.invalid
      8  68c6		       bc 20 fc 	      ldy	ValidSquare+_RIGHT+_UP,x
      9  68c9		       b9 79 fc 	      lda	Board,y
     10  68cc		       d0 03		      bne	.invalid
     11  68ce		       20 73 f2 	      jsr	AddMove
     12  68d1				   .invalid
    177  68d1
    178  68d1				   .noEnPassant
    179  68d1					      ENDIF
    180  68d1
    181  68d1		       4c d6 f1 	      jmp	MoveReturn
    182  68d4
    183  68d4
    184  68d4							;---------------------------------------------------------------------------------------------------
    185  68d4							; BLACK PAWN
    186  68d4							;---------------------------------------------------------------------------------------------------
    187  68d4
      0  68d4					      DEF	PromoteBlackPawn
      1  68d4				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  68d4				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  68d4				   PromoteBlackPawn
      4  68d4				   TEMPORARY_VAR SET	Overlay
      5  68d4				   TEMPORARY_OFFSET SET	0
      6  68d4				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  68d4				   FUNCTION_NAME SET	PromoteBlackPawn
    189  68d4					      SUBROUTINE
    190  68d4
      0  68d4					      REFER	Handle_BLACK_PAWN
      1  68d4					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  68d4				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  68d4					      ENDIF
      0  68d4					      VAR	__temp, 1
      1  68d4		       00 b8	   __temp     =	TEMPORARY_VAR
      2  68d4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  68d4
      4  68d4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  68d4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  68d4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  68d4					      ENDIF
      8  68d4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  68d4				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  68d4				  -	      ERR
     11  68d4					      ENDIF
     12  68d4					      LIST	ON
      0  68d4					      VEND	PromoteBlackPawn
      1  68d4				  -	      IFNCONST	PromoteBlackPawn
      2  68d4				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  68d4				  -	      ERR
      4  68d4					      ENDIF
      5  68d4		       00 b9	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  68d4
      0  68d4					      PROMOTE_PAWN	BLACK
      1  68d4
      2  68d4
      3  68d4
      4  68d4
      5  68d4
      6  68d4		       84 b8		      sty	__temp
      7  68d6		       a9 86		      lda	#BLACK|QUEEN
      8  68d8		       85 91		      sta	currentPiece
      9  68da		       20 73 f2 	      jsr	AddMove
     10  68dd
     11  68dd		       a9 85		      lda	#BLACK|ROOK
     12  68df		       85 91		      sta	currentPiece
     13  68e1		       a4 b8		      ldy	__temp
     14  68e3		       20 73 f2 	      jsr	AddMove
     15  68e6
     16  68e6		       a9 84		      lda	#BLACK|BISHOP
     17  68e8		       85 91		      sta	currentPiece
     18  68ea		       a4 b8		      ldy	__temp
     19  68ec		       20 73 f2 	      jsr	AddMove
     20  68ef
     21  68ef		       a9 83		      lda	#BLACK|KNIGHT
     22  68f1		       85 91		      sta	currentPiece
     23  68f3		       a4 b8		      ldy	__temp
     24  68f5		       20 73 f2 	      jsr	AddMove
     25  68f8
     26  68f8				  -	      IF	BLACK = WHITE
     27  68f8				  -	      lda	#WHITE|WP
     28  68f8					      ENDIF
     29  68f8					      IF	BLACK = BLACK
     30  68f8		       a9 82		      lda	#BLACK|BP
     31  68fa					      ENDIF
     32  68fa		       85 91		      sta	currentPiece
    196  68fc		       60		      rts
    197  68fd
      0  68fd					      DEF	Handle_BLACK_PAWN
      1  68fd				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  68fd				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  68fd				   Handle_BLACK_PAWN
      4  68fd				   TEMPORARY_VAR SET	Overlay
      5  68fd				   TEMPORARY_OFFSET SET	0
      6  68fd				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  68fd				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  68fd					      SUBROUTINE
    200  68fd
      0  68fd					      REFER	GenerateAllMoves
      1  68fd					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  68fd				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  68fd					      ENDIF
      0  68fd					      VEND	Handle_BLACK_PAWN
      1  68fd				  -	      IFNCONST	Handle_BLACK_PAWN
      2  68fd				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  68fd				  -	      ERR
      4  68fd					      ENDIF
      5  68fd		       00 b8	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  68fd
    204  68fd		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  6900		       b9 79 fc 	      lda	Board,y
    206  6903		       d0 26		      bne	.pMoved	; occupied
    207  6905		       85 9b		      sta	capture
    208  6907
    209  6907							; we may need to promote the pawn
    210  6907							; All possibilites (Q/R/B/N) are added as individual moves
    211  6907
      0  6907					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  6907
      2  6907
      3  6907
      4  6907				  -	      IF	BLACK = WHITE
      5  6907				  -	      cpy	#90
      6  6907				  -	      bcc	.standard
      7  6907				  -	      jsr	PromoteWhitePawn
      8  6907				  -	      jmp	.pMoved
      9  6907					      ENDIF
     10  6907
     11  6907					      IF	BLACK = BLACK
     12  6907		       c0 1e		      cpy	#30
     13  6909		       b0 06		      bcs	.standard
     14  690b		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  690e		       4c 14 f5 	      jmp	.pMoved
     16  6911					      ENDIF
     17  6911
     18  6911		       20 73 f2    .standard  jsr	AddMove
     19  6914				   .pMoved
     20  6914
    213  6914
    214  6914							; the +2 move off the home rank...
    215  6914
    216  6914		       a6 92		      ldx	currentSquare
    217  6916		       e0 52		      cpx	#BLACK_HOME_ROW
    218  6918		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  691a
    220  691a
    221  691a		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  691d		       b9 79 fc 	      lda	Board,y
    223  6920		       d0 09		      bne	.pMoved	; destination square occupied
    224  6922
    225  6922		       a5 91		      lda	currentPiece
    226  6924		       09 20		      ora	#FLAG_ENPASSANT
    227  6926		       85 91		      sta	currentPiece	; CAN en-passant
    228  6928
    229  6928		       20 73 f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  692b
    231  692b				   .pMoved
    232  692b
    233  692b							; regular captures... (with promotion)
    234  692b
      0  692b					      TAKE	_DOWN+_LEFT, BLACK
      1  692b
      2  692b
      3  692b
      4  692b		       a6 92		      ldx	currentSquare
      5  692d		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  6930		       30 1d		      bmi	.invalid2
      7  6932		       b9 79 fc 	      lda	Board,y
      8  6935		       f0 18		      beq	.invalid2
      9  6937		       85 9b		      sta	capture
     10  6939		       45 91		      eor	currentPiece
     11  693b		       10 10		      bpl	.invalid
     12  693d
      0  693d					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  693d
      2  693d
      3  693d
      4  693d				  -	      IF	BLACK = WHITE
      5  693d				  -	      cpy	#90
      6  693d				  -	      bcc	.standard
      7  693d				  -	      jsr	PromoteWhitePawn
      8  693d				  -	      jmp	.pMoved
      9  693d					      ENDIF
     10  693d
     11  693d					      IF	BLACK = BLACK
     12  693d		       c0 1e		      cpy	#30
     13  693f		       b0 06		      bcs	.standard
     14  6941		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  6944		       4c 4a f5 	      jmp	.pMoved
     16  6947					      ENDIF
     17  6947
     18  6947		       20 73 f2    .standard  jsr	AddMove
     19  694a				   .pMoved
     20  694a
     14  694a
     15  694a		       4c 4f f5 	      jmp	.invalid2
     16  694d		       e6 a0	   .invalid   inc	protecting
     17  694f				   .invalid2
      0  694f					      TAKE	_DOWN+_RIGHT, BLACK
      1  694f
      2  694f
      3  694f
      4  694f		       a6 92		      ldx	currentSquare
      5  6951		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  6954		       30 1d		      bmi	.invalid2
      7  6956		       b9 79 fc 	      lda	Board,y
      8  6959		       f0 18		      beq	.invalid2
      9  695b		       85 9b		      sta	capture
     10  695d		       45 91		      eor	currentPiece
     11  695f		       10 10		      bpl	.invalid
     12  6961
      0  6961					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  6961
      2  6961
      3  6961
      4  6961				  -	      IF	BLACK = WHITE
      5  6961				  -	      cpy	#90
      6  6961				  -	      bcc	.standard
      7  6961				  -	      jsr	PromoteWhitePawn
      8  6961				  -	      jmp	.pMoved
      9  6961					      ENDIF
     10  6961
     11  6961					      IF	BLACK = BLACK
     12  6961		       c0 1e		      cpy	#30
     13  6963		       b0 06		      bcs	.standard
     14  6965		       20 d4 f4 	      jsr	PromoteBlackPawn
     15  6968		       4c 6e f5 	      jmp	.pMoved
     16  696b					      ENDIF
     17  696b
     18  696b		       20 73 f2    .standard  jsr	AddMove
     19  696e				   .pMoved
     20  696e
     14  696e
     15  696e		       4c 73 f5 	      jmp	.invalid2
     16  6971		       e6 a0	   .invalid   inc	protecting
     17  6973				   .invalid2
    237  6973
    238  6973
    239  6973					      IF	ENPASSANT_ENABLED
    240  6973							; en-passant captures...
    241  6973
    242  6973		       a5 93		      lda	enPassantPawn
    243  6975		       f0 2e		      beq	.noEnPassant	; was last move en-passantable?
    244  6977
    245  6977		       a5 91		      lda	currentPiece
    246  6979		       09 20		      ora	#FLAG_ENPASSANT
    247  697b		       85 91		      sta	currentPiece	; any en-passant move added will have flag set
    248  697d
      0  697d					      EN_PASSANT	_LEFT, _DOWN
      1  697d					      SUBROUTINE
      2  697d
      3  697d
      4  697d		       a6 92		      ldx	currentSquare
      5  697f		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  6982		       c4 93		      cpy	enPassantPawn
      7  6984		       d0 0b		      bne	.invalid
      8  6986		       bc 0a fc 	      ldy	ValidSquare+_LEFT+_DOWN,x
      9  6989		       b9 79 fc 	      lda	Board,y
     10  698c		       d0 03		      bne	.invalid
     11  698e		       20 73 f2 	      jsr	AddMove
     12  6991				   .invalid
      0  6991					      EN_PASSANT	_RIGHT, _DOWN
      1  6991					      SUBROUTINE
      2  6991
      3  6991
      4  6991		       a6 92		      ldx	currentSquare
      5  6993		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  6996		       c4 93		      cpy	enPassantPawn
      7  6998		       d0 0b		      bne	.invalid
      8  699a		       bc 0c fc 	      ldy	ValidSquare+_RIGHT+_DOWN,x
      9  699d		       b9 79 fc 	      lda	Board,y
     10  69a0		       d0 03		      bne	.invalid
     11  69a2		       20 73 f2 	      jsr	AddMove
     12  69a5				   .invalid
    251  69a5
    252  69a5				   .noEnPassant
    253  69a5					      ENDIF
    254  69a5
    255  69a5		       4c d6 f1 	      jmp	MoveReturn
    256  69a8
    257  69a8							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  69a8					      include	"PIECE_KNIGHT.asm"
      1  69a8							; Copyright (C)2020 Andrew Davie
      2  69a8							; Knight move handler
      3  69a8
      4  69a8							;---------------------------------------------------------------------------------------------------
      5  69a8							; KNIGHT
      6  69a8							;---------------------------------------------------------------------------------------------------
      7  69a8
      0  69a8					      DEF	Handle_KNIGHT
      1  69a8				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  69a8				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  69a8				   Handle_KNIGHT
      4  69a8				   TEMPORARY_VAR SET	Overlay
      5  69a8				   TEMPORARY_OFFSET SET	0
      6  69a8				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  69a8				   FUNCTION_NAME SET	Handle_KNIGHT
      9  69a8					      SUBROUTINE
     10  69a8
      0  69a8					      REFER	GenerateAllMoves	;✅
      1  69a8					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  69a8				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  69a8					      ENDIF
      0  69a8					      VEND	Handle_KNIGHT
      1  69a8				  -	      IFNCONST	Handle_KNIGHT
      2  69a8				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  69a8				  -	      ERR
      4  69a8					      ENDIF
      5  69a8		       00 b8	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  69a8
     14  69a8							; x = currentSquare (square the piece is on)
     15  69a8							; currentPiece (with flags/colour attached)
     16  69a8
      0  69a8					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  69a8					      SUBROUTINE
      2  69a8		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  69ab		       30 0e		      bmi	.invalid
      4  69ad		       b9 79 fc 	      lda	Board,y
      5  69b0		       85 9b		      sta	capture
      6  69b2		       f0 04		      beq	.squareEmpty
      7  69b4		       45 91		      eor	currentPiece
      8  69b6		       10 03		      bpl	.invalid
      9  69b8		       20 73 f2    .squareEmpty jsr	AddMove
     10  69bb				   .invalid
      0  69bb					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  69bb		       a6 92		      ldx	currentSquare
      0  69bd					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  69bd					      SUBROUTINE
      2  69bd		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  69c0		       30 0e		      bmi	.invalid
      4  69c2		       b9 79 fc 	      lda	Board,y
      5  69c5		       85 9b		      sta	capture
      6  69c7		       f0 04		      beq	.squareEmpty
      7  69c9		       45 91		      eor	currentPiece
      8  69cb		       10 03		      bpl	.invalid
      9  69cd		       20 73 f2    .squareEmpty jsr	AddMove
     10  69d0				   .invalid
      0  69d0					      MOVE_TO_X	_UP+_UP+_LEFT
      1  69d0		       a6 92		      ldx	currentSquare
      0  69d2					      MOVE_TO	_UP+_UP+_LEFT
      1  69d2					      SUBROUTINE
      2  69d2		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  69d5		       30 0e		      bmi	.invalid
      4  69d7		       b9 79 fc 	      lda	Board,y
      5  69da		       85 9b		      sta	capture
      6  69dc		       f0 04		      beq	.squareEmpty
      7  69de		       45 91		      eor	currentPiece
      8  69e0		       10 03		      bpl	.invalid
      9  69e2		       20 73 f2    .squareEmpty jsr	AddMove
     10  69e5				   .invalid
      0  69e5					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  69e5		       a6 92		      ldx	currentSquare
      0  69e7					      MOVE_TO	_UP+_UP+_RIGHT
      1  69e7					      SUBROUTINE
      2  69e7		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  69ea		       30 0e		      bmi	.invalid
      4  69ec		       b9 79 fc 	      lda	Board,y
      5  69ef		       85 9b		      sta	capture
      6  69f1		       f0 04		      beq	.squareEmpty
      7  69f3		       45 91		      eor	currentPiece
      8  69f5		       10 03		      bpl	.invalid
      9  69f7		       20 73 f2    .squareEmpty jsr	AddMove
     10  69fa				   .invalid
     21  69fa
      0  69fa					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  69fa		       a6 92		      ldx	currentSquare
      0  69fc					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  69fc					      SUBROUTINE
      2  69fc		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  69ff		       30 0e		      bmi	.invalid
      4  6a01		       b9 79 fc 	      lda	Board,y
      5  6a04		       85 9b		      sta	capture
      6  6a06		       f0 04		      beq	.squareEmpty
      7  6a08		       45 91		      eor	currentPiece
      8  6a0a		       10 03		      bpl	.invalid
      9  6a0c		       20 73 f2    .squareEmpty jsr	AddMove
     10  6a0f				   .invalid
      0  6a0f					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  6a0f		       a6 92		      ldx	currentSquare
      0  6a11					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  6a11					      SUBROUTINE
      2  6a11		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  6a14		       30 0e		      bmi	.invalid
      4  6a16		       b9 79 fc 	      lda	Board,y
      5  6a19		       85 9b		      sta	capture
      6  6a1b		       f0 04		      beq	.squareEmpty
      7  6a1d		       45 91		      eor	currentPiece
      8  6a1f		       10 03		      bpl	.invalid
      9  6a21		       20 73 f2    .squareEmpty jsr	AddMove
     10  6a24				   .invalid
      0  6a24					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  6a24		       a6 92		      ldx	currentSquare
      0  6a26					      MOVE_TO	_UP+_LEFT+_LEFT
      1  6a26					      SUBROUTINE
      2  6a26		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  6a29		       30 0e		      bmi	.invalid
      4  6a2b		       b9 79 fc 	      lda	Board,y
      5  6a2e		       85 9b		      sta	capture
      6  6a30		       f0 04		      beq	.squareEmpty
      7  6a32		       45 91		      eor	currentPiece
      8  6a34		       10 03		      bpl	.invalid
      9  6a36		       20 73 f2    .squareEmpty jsr	AddMove
     10  6a39				   .invalid
      0  6a39					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  6a39		       a6 92		      ldx	currentSquare
      0  6a3b					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  6a3b					      SUBROUTINE
      2  6a3b		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  6a3e		       30 0e		      bmi	.invalid
      4  6a40		       b9 79 fc 	      lda	Board,y
      5  6a43		       85 9b		      sta	capture
      6  6a45		       f0 04		      beq	.squareEmpty
      7  6a47		       45 91		      eor	currentPiece
      8  6a49		       10 03		      bpl	.invalid
      9  6a4b		       20 73 f2    .squareEmpty jsr	AddMove
     10  6a4e				   .invalid
     26  6a4e
     27  6a4e		       4c d6 f1 	      jmp	MoveReturn
     28  6a51
     29  6a51							; EOF
------- FILE PIECE_HANDLER@1#1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  6a51					      include	"PIECE_BISHOP.asm"
      1  6a51							; Copyright (C)2020 Andrew Davie
      2  6a51
      3  6a51							;---------------------------------------------------------------------------------------------------
      4  6a51							; BISHOP
      5  6a51							;---------------------------------------------------------------------------------------------------
      6  6a51
      0  6a51					      DEF	Handle_BISHOP
      1  6a51				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  6a51				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  6a51				   Handle_BISHOP
      4  6a51				   TEMPORARY_VAR SET	Overlay
      5  6a51				   TEMPORARY_OFFSET SET	0
      6  6a51				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  6a51				   FUNCTION_NAME SET	Handle_BISHOP
      8  6a51					      SUBROUTINE
      9  6a51
      0  6a51					      REFER	GenerateAllMoves	;✅
      1  6a51					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6a51				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6a51					      ENDIF
      0  6a51					      VEND	Handle_BISHOP
      1  6a51				  -	      IFNCONST	Handle_BISHOP
      2  6a51				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  6a51				  -	      ERR
      4  6a51					      ENDIF
      5  6a51		       00 b8	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  6a51
     13  6a51							; x = currentSquare (square the piece is on)
     14  6a51							; currentPiece (with flags/colour attached)
     15  6a51
      0  6a51					      MOVE_TOWARDS	_DOWN+_LEFT
      1  6a51					      SUBROUTINE
      2  6a51
      3  6a51
      4  6a51
      5  6a51		       a9 00		      lda	#0
      6  6a53		       85 9b		      sta	capture
      7  6a55
      8  6a55		       a6 92		      ldx	currentSquare
      9  6a57		       d0 03		      bne	.project
     10  6a59
     11  6a59		       20 73 f2    .empty     jsr	AddMove
     12  6a5c		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6a5f		       30 0e		      bmi	.invalid
     14  6a61		       b9 79 fc 	      lda	Board,y
     15  6a64		       f0 f3		      beq	.empty
     16  6a66		       85 9b		      sta	capture
     17  6a68		       45 91		      eor	currentPiece
     18  6a6a		       10 03		      bpl	.invalid
     19  6a6c		       20 73 f2 	      jsr	AddMove
     20  6a6f
     21  6a6f				   .invalid
      0  6a6f					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  6a6f					      SUBROUTINE
      2  6a6f
      3  6a6f
      4  6a6f
      5  6a6f		       a9 00		      lda	#0
      6  6a71		       85 9b		      sta	capture
      7  6a73
      8  6a73		       a6 92		      ldx	currentSquare
      9  6a75		       d0 03		      bne	.project
     10  6a77
     11  6a77		       20 73 f2    .empty     jsr	AddMove
     12  6a7a		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  6a7d		       30 0e		      bmi	.invalid
     14  6a7f		       b9 79 fc 	      lda	Board,y
     15  6a82		       f0 f3		      beq	.empty
     16  6a84		       85 9b		      sta	capture
     17  6a86		       45 91		      eor	currentPiece
     18  6a88		       10 03		      bpl	.invalid
     19  6a8a		       20 73 f2 	      jsr	AddMove
     20  6a8d
     21  6a8d				   .invalid
      0  6a8d					      MOVE_TOWARDS	_UP+_LEFT
      1  6a8d					      SUBROUTINE
      2  6a8d
      3  6a8d
      4  6a8d
      5  6a8d		       a9 00		      lda	#0
      6  6a8f		       85 9b		      sta	capture
      7  6a91
      8  6a91		       a6 92		      ldx	currentSquare
      9  6a93		       d0 03		      bne	.project
     10  6a95
     11  6a95		       20 73 f2    .empty     jsr	AddMove
     12  6a98		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  6a9b		       30 0e		      bmi	.invalid
     14  6a9d		       b9 79 fc 	      lda	Board,y
     15  6aa0		       f0 f3		      beq	.empty
     16  6aa2		       85 9b		      sta	capture
     17  6aa4		       45 91		      eor	currentPiece
     18  6aa6		       10 03		      bpl	.invalid
     19  6aa8		       20 73 f2 	      jsr	AddMove
     20  6aab
     21  6aab				   .invalid
      0  6aab					      MOVE_TOWARDS	_UP+_RIGHT
      1  6aab					      SUBROUTINE
      2  6aab
      3  6aab
      4  6aab
      5  6aab		       a9 00		      lda	#0
      6  6aad		       85 9b		      sta	capture
      7  6aaf
      8  6aaf		       a6 92		      ldx	currentSquare
      9  6ab1		       d0 03		      bne	.project
     10  6ab3
     11  6ab3		       20 73 f2    .empty     jsr	AddMove
     12  6ab6		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6ab9		       30 0e		      bmi	.invalid
     14  6abb		       b9 79 fc 	      lda	Board,y
     15  6abe		       f0 f3		      beq	.empty
     16  6ac0		       85 9b		      sta	capture
     17  6ac2		       45 91		      eor	currentPiece
     18  6ac4		       10 03		      bpl	.invalid
     19  6ac6		       20 73 f2 	      jsr	AddMove
     20  6ac9
     21  6ac9				   .invalid
     20  6ac9
     21  6ac9		       4c d6 f1 	      jmp	MoveReturn
     22  6acc
     23  6acc							;---------------------------------------------------------------------------------------------------
     24  6acc							; EOF
------- FILE PIECE_HANDLER@1#1.asm
      7  6acc
      8  6acc							;---------------------------------------------------------------------------------------------------
      9  6acc
      0  6acc					      CHECK_BANK_SIZE	"PIECE_HANDLER_1"
      1  6acc		       02 cc	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_1 (1K) SIZE =  $2cc , FREE= $134
      2  6acc					      ECHO	"PIECE_HANDLER_1", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6acc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6acc				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_1", " size=", * - ORIGIN
      5  6acc				  -	      ERR
      6  6acc					      ENDIF
     11  6acc
     12  6acc							;---------------------------------------------------------------------------------------------------
     13  6acc							; EOF
------- FILE ./chess.asm
------- FILE PIECE_HANDLER@1#2.asm LEVEL 2 PASS 4
      0  6acc					      include	"PIECE_HANDLER@1#2.asm"
      0  6acc					      SLOT	1
      1  6acc				  -	      IF	(1 < 0) || (1 > 3)
      2  6acc				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6acc				  -	      ERR
      4  6acc					      ENDIF
      5  6acc				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6acc				   _BANK_SLOT SET	1 * 64
      0  6acc					      ROMBANK	PIECE_HANDLER_2
      1  6e5c ????				      SEG	PIECE_HANDLER_2
      2  6c00					      ORG	_ORIGIN
      3  6c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  6c00				   _BANK_START SET	*
      5  6c00				   PIECE_HANDLER_2_START SET	*
      6  6c00				   _CURRENT_BANK SET	_ORIGIN/1024
      7  6c00				   PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  6c00				   _ORIGIN    SET	_ORIGIN + 1024
      3  6c00
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  6c00					      include	"PIECE_ROOK.asm"
      1  6c00							; Copyright (C)2020 Andrew Davie
      2  6c00							; Rook move handler
      3  6c00
      4  6c00							;---------------------------------------------------------------------------------------------------
      5  6c00							; ROOK
      6  6c00							;---------------------------------------------------------------------------------------------------
      7  6c00
      0  6c00					      DEF	Handle_ROOK
      1  6c00				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  6c00				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  6c00				   Handle_ROOK
      4  6c00				   TEMPORARY_VAR SET	Overlay
      5  6c00				   TEMPORARY_OFFSET SET	0
      6  6c00				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  6c00				   FUNCTION_NAME SET	Handle_ROOK
      9  6c00					      SUBROUTINE
     10  6c00
      0  6c00					      REFER	GenerateAllMoves	;✅
      1  6c00					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6c00				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6c00					      ENDIF
      0  6c00					      VEND	Handle_ROOK
      1  6c00				  -	      IFNCONST	Handle_ROOK
      2  6c00				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  6c00				  -	      ERR
      4  6c00					      ENDIF
      5  6c00		       00 b8	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  6c00
     14  6c00							; Pass...
     15  6c00							; x = currentSquare (square the piece is on)
     16  6c00							; currentPiece (with flags/colour attached)
     17  6c00
     18  6c00
      0  6c00					      MOVE_TOWARDS	_DOWN
      1  6c00					      SUBROUTINE
      2  6c00
      3  6c00
      4  6c00
      5  6c00		       a9 00		      lda	#0
      6  6c02		       85 9b		      sta	capture
      7  6c04
      8  6c04		       a6 92		      ldx	currentSquare
      9  6c06		       d0 03		      bne	.project
     10  6c08
     11  6c08		       20 73 f2    .empty     jsr	AddMove
     12  6c0b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  6c0e		       30 0e		      bmi	.invalid
     14  6c10		       b9 79 fc 	      lda	Board,y
     15  6c13		       f0 f3		      beq	.empty
     16  6c15		       85 9b		      sta	capture
     17  6c17		       45 91		      eor	currentPiece
     18  6c19		       10 03		      bpl	.invalid
     19  6c1b		       20 73 f2 	      jsr	AddMove
     20  6c1e
     21  6c1e				   .invalid
      0  6c1e					      MOVE_TOWARDS	_RIGHT
      1  6c1e					      SUBROUTINE
      2  6c1e
      3  6c1e
      4  6c1e
      5  6c1e		       a9 00		      lda	#0
      6  6c20		       85 9b		      sta	capture
      7  6c22
      8  6c22		       a6 92		      ldx	currentSquare
      9  6c24		       d0 03		      bne	.project
     10  6c26
     11  6c26		       20 73 f2    .empty     jsr	AddMove
     12  6c29		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  6c2c		       30 0e		      bmi	.invalid
     14  6c2e		       b9 79 fc 	      lda	Board,y
     15  6c31		       f0 f3		      beq	.empty
     16  6c33		       85 9b		      sta	capture
     17  6c35		       45 91		      eor	currentPiece
     18  6c37		       10 03		      bpl	.invalid
     19  6c39		       20 73 f2 	      jsr	AddMove
     20  6c3c
     21  6c3c				   .invalid
      0  6c3c					      MOVE_TOWARDS	_UP
      1  6c3c					      SUBROUTINE
      2  6c3c
      3  6c3c
      4  6c3c
      5  6c3c		       a9 00		      lda	#0
      6  6c3e		       85 9b		      sta	capture
      7  6c40
      8  6c40		       a6 92		      ldx	currentSquare
      9  6c42		       d0 03		      bne	.project
     10  6c44
     11  6c44		       20 73 f2    .empty     jsr	AddMove
     12  6c47		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  6c4a		       30 0e		      bmi	.invalid
     14  6c4c		       b9 79 fc 	      lda	Board,y
     15  6c4f		       f0 f3		      beq	.empty
     16  6c51		       85 9b		      sta	capture
     17  6c53		       45 91		      eor	currentPiece
     18  6c55		       10 03		      bpl	.invalid
     19  6c57		       20 73 f2 	      jsr	AddMove
     20  6c5a
     21  6c5a				   .invalid
      0  6c5a					      MOVE_TOWARDS	_LEFT
      1  6c5a					      SUBROUTINE
      2  6c5a
      3  6c5a
      4  6c5a
      5  6c5a		       a9 00		      lda	#0
      6  6c5c		       85 9b		      sta	capture
      7  6c5e
      8  6c5e		       a6 92		      ldx	currentSquare
      9  6c60		       d0 03		      bne	.project
     10  6c62
     11  6c62		       20 73 f2    .empty     jsr	AddMove
     12  6c65		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  6c68		       30 0e		      bmi	.invalid
     14  6c6a		       b9 79 fc 	      lda	Board,y
     15  6c6d		       f0 f3		      beq	.empty
     16  6c6f		       85 9b		      sta	capture
     17  6c71		       45 91		      eor	currentPiece
     18  6c73		       10 03		      bpl	.invalid
     19  6c75		       20 73 f2 	      jsr	AddMove
     20  6c78
     21  6c78				   .invalid
     23  6c78
     24  6c78		       4c d6 f1 	      jmp	MoveReturn
     25  6c7b
     26  6c7b							;---------------------------------------------------------------------------------------------------
     27  6c7b							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  6c7b					      include	"PIECE_QUEEN.asm"
      1  6c7b							; Copyright (C)2020 Andrew Davie
      2  6c7b
      3  6c7b							;---------------------------------------------------------------------------------------------------
      4  6c7b							; QUEEN
      5  6c7b							;---------------------------------------------------------------------------------------------------
      6  6c7b
      0  6c7b					      DEF	Handle_QUEEN
      1  6c7b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  6c7b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  6c7b				   Handle_QUEEN
      4  6c7b				   TEMPORARY_VAR SET	Overlay
      5  6c7b				   TEMPORARY_OFFSET SET	0
      6  6c7b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  6c7b				   FUNCTION_NAME SET	Handle_QUEEN
      8  6c7b					      SUBROUTINE
      9  6c7b
      0  6c7b					      REFER	GenerateAllMoves	;✅
      1  6c7b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6c7b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6c7b					      ENDIF
      0  6c7b					      VEND	Handle_QUEEN
      1  6c7b				  -	      IFNCONST	Handle_QUEEN
      2  6c7b				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  6c7b				  -	      ERR
      4  6c7b					      ENDIF
      5  6c7b		       00 b8	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  6c7b
     13  6c7b							; Pass...
     14  6c7b							; x = currentSquare (square the piece is on)
     15  6c7b							; currentPiece (with flags/colour attached)
     16  6c7b
      0  6c7b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  6c7b					      SUBROUTINE
      2  6c7b
      3  6c7b
      4  6c7b
      5  6c7b		       a9 00		      lda	#0
      6  6c7d		       85 9b		      sta	capture
      7  6c7f
      8  6c7f		       a6 92		      ldx	currentSquare
      9  6c81		       d0 03		      bne	.project
     10  6c83
     11  6c83		       20 73 f2    .empty     jsr	AddMove
     12  6c86		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6c89		       30 0e		      bmi	.invalid
     14  6c8b		       b9 79 fc 	      lda	Board,y
     15  6c8e		       f0 f3		      beq	.empty
     16  6c90		       85 9b		      sta	capture
     17  6c92		       45 91		      eor	currentPiece
     18  6c94		       10 03		      bpl	.invalid
     19  6c96		       20 73 f2 	      jsr	AddMove
     20  6c99
     21  6c99				   .invalid
      0  6c99					      MOVE_TOWARDS	_DOWN
      1  6c99					      SUBROUTINE
      2  6c99
      3  6c99
      4  6c99
      5  6c99		       a9 00		      lda	#0
      6  6c9b		       85 9b		      sta	capture
      7  6c9d
      8  6c9d		       a6 92		      ldx	currentSquare
      9  6c9f		       d0 03		      bne	.project
     10  6ca1
     11  6ca1		       20 73 f2    .empty     jsr	AddMove
     12  6ca4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  6ca7		       30 0e		      bmi	.invalid
     14  6ca9		       b9 79 fc 	      lda	Board,y
     15  6cac		       f0 f3		      beq	.empty
     16  6cae		       85 9b		      sta	capture
     17  6cb0		       45 91		      eor	currentPiece
     18  6cb2		       10 03		      bpl	.invalid
     19  6cb4		       20 73 f2 	      jsr	AddMove
     20  6cb7
     21  6cb7				   .invalid
      0  6cb7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  6cb7					      SUBROUTINE
      2  6cb7
      3  6cb7
      4  6cb7
      5  6cb7		       a9 00		      lda	#0
      6  6cb9		       85 9b		      sta	capture
      7  6cbb
      8  6cbb		       a6 92		      ldx	currentSquare
      9  6cbd		       d0 03		      bne	.project
     10  6cbf
     11  6cbf		       20 73 f2    .empty     jsr	AddMove
     12  6cc2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  6cc5		       30 0e		      bmi	.invalid
     14  6cc7		       b9 79 fc 	      lda	Board,y
     15  6cca		       f0 f3		      beq	.empty
     16  6ccc		       85 9b		      sta	capture
     17  6cce		       45 91		      eor	currentPiece
     18  6cd0		       10 03		      bpl	.invalid
     19  6cd2		       20 73 f2 	      jsr	AddMove
     20  6cd5
     21  6cd5				   .invalid
      0  6cd5					      MOVE_TOWARDS	_RIGHT
      1  6cd5					      SUBROUTINE
      2  6cd5
      3  6cd5
      4  6cd5
      5  6cd5		       a9 00		      lda	#0
      6  6cd7		       85 9b		      sta	capture
      7  6cd9
      8  6cd9		       a6 92		      ldx	currentSquare
      9  6cdb		       d0 03		      bne	.project
     10  6cdd
     11  6cdd		       20 73 f2    .empty     jsr	AddMove
     12  6ce0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  6ce3		       30 0e		      bmi	.invalid
     14  6ce5		       b9 79 fc 	      lda	Board,y
     15  6ce8		       f0 f3		      beq	.empty
     16  6cea		       85 9b		      sta	capture
     17  6cec		       45 91		      eor	currentPiece
     18  6cee		       10 03		      bpl	.invalid
     19  6cf0		       20 73 f2 	      jsr	AddMove
     20  6cf3
     21  6cf3				   .invalid
      0  6cf3					      MOVE_TOWARDS	_UP+_RIGHT
      1  6cf3					      SUBROUTINE
      2  6cf3
      3  6cf3
      4  6cf3
      5  6cf3		       a9 00		      lda	#0
      6  6cf5		       85 9b		      sta	capture
      7  6cf7
      8  6cf7		       a6 92		      ldx	currentSquare
      9  6cf9		       d0 03		      bne	.project
     10  6cfb
     11  6cfb		       20 73 f2    .empty     jsr	AddMove
     12  6cfe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6d01		       30 0e		      bmi	.invalid
     14  6d03		       b9 79 fc 	      lda	Board,y
     15  6d06		       f0 f3		      beq	.empty
     16  6d08		       85 9b		      sta	capture
     17  6d0a		       45 91		      eor	currentPiece
     18  6d0c		       10 03		      bpl	.invalid
     19  6d0e		       20 73 f2 	      jsr	AddMove
     20  6d11
     21  6d11				   .invalid
      0  6d11					      MOVE_TOWARDS	_UP
      1  6d11					      SUBROUTINE
      2  6d11
      3  6d11
      4  6d11
      5  6d11		       a9 00		      lda	#0
      6  6d13		       85 9b		      sta	capture
      7  6d15
      8  6d15		       a6 92		      ldx	currentSquare
      9  6d17		       d0 03		      bne	.project
     10  6d19
     11  6d19		       20 73 f2    .empty     jsr	AddMove
     12  6d1c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  6d1f		       30 0e		      bmi	.invalid
     14  6d21		       b9 79 fc 	      lda	Board,y
     15  6d24		       f0 f3		      beq	.empty
     16  6d26		       85 9b		      sta	capture
     17  6d28		       45 91		      eor	currentPiece
     18  6d2a		       10 03		      bpl	.invalid
     19  6d2c		       20 73 f2 	      jsr	AddMove
     20  6d2f
     21  6d2f				   .invalid
      0  6d2f					      MOVE_TOWARDS	_UP+_LEFT
      1  6d2f					      SUBROUTINE
      2  6d2f
      3  6d2f
      4  6d2f
      5  6d2f		       a9 00		      lda	#0
      6  6d31		       85 9b		      sta	capture
      7  6d33
      8  6d33		       a6 92		      ldx	currentSquare
      9  6d35		       d0 03		      bne	.project
     10  6d37
     11  6d37		       20 73 f2    .empty     jsr	AddMove
     12  6d3a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  6d3d		       30 0e		      bmi	.invalid
     14  6d3f		       b9 79 fc 	      lda	Board,y
     15  6d42		       f0 f3		      beq	.empty
     16  6d44		       85 9b		      sta	capture
     17  6d46		       45 91		      eor	currentPiece
     18  6d48		       10 03		      bpl	.invalid
     19  6d4a		       20 73 f2 	      jsr	AddMove
     20  6d4d
     21  6d4d				   .invalid
      0  6d4d					      MOVE_TOWARDS	_LEFT
      1  6d4d					      SUBROUTINE
      2  6d4d
      3  6d4d
      4  6d4d
      5  6d4d		       a9 00		      lda	#0
      6  6d4f		       85 9b		      sta	capture
      7  6d51
      8  6d51		       a6 92		      ldx	currentSquare
      9  6d53		       d0 03		      bne	.project
     10  6d55
     11  6d55		       20 73 f2    .empty     jsr	AddMove
     12  6d58		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  6d5b		       30 0e		      bmi	.invalid
     14  6d5d		       b9 79 fc 	      lda	Board,y
     15  6d60		       f0 f3		      beq	.empty
     16  6d62		       85 9b		      sta	capture
     17  6d64		       45 91		      eor	currentPiece
     18  6d66		       10 03		      bpl	.invalid
     19  6d68		       20 73 f2 	      jsr	AddMove
     20  6d6b
     21  6d6b				   .invalid
     25  6d6b
     26  6d6b		       4c d6 f1 	      jmp	MoveReturn
     27  6d6e
     28  6d6e							; EOF
------- FILE PIECE_HANDLER@1#2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  6d6e					      include	"PIECE_KING.asm"
      1  6d6e							; Copyright (C)2020 Andrew Davie
      2  6d6e
      3  6d6e							;---------------------------------------------------------------------------------------------------
      4  6d6e							; KING
      5  6d6e							; This is the move handler for a KING
      6  6d6e							; "Check" is detected in the next ply of the search.
      7  6d6e
      8  6d6e
      9  6d6e							;---------------------------------------------------------------------------------------------------
     10  6d6e
     11  6d6e							; MACRO - Castling
     12  6d6e
     13  6d6e		       00 03	   KINGSIDE   =	3
     14  6d6e		       ff ff ff fc QUEENSIDE  =	-4
     15  6d6e
     16  6d6e					      MAC	castle
     17  6d6e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  6d6e
     19  6d6e					      ldx	currentSquare
     20  6d6e					      lda	Board+{1},x	; kingside/queenside R position
     21  6d6e					      and	#PIECE_MASK|FLAG_MOVED
     22  6d6e					      cmp	#ROOK
     23  6d6e					      bne	.noCastle	; not a R that hasn't moved
     24  6d6e
     25  6d6e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  6d6e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  6d6e
     28  6d6e					      IF	{1} = QUEENSIDE
     29  6d6e					      lda	Board-3,x	; N pos
     30  6d6e					      ora	Board-2,x	; B pos
     31  6d6e					      ora	Board-1,x	; Q pos
     32  6d6e					      bne	.noCastle	; not vacant?
     33  6d6e
     34  6d6e					      ENDIF
     35  6d6e
     36  6d6e					      IF	{1} = KINGSIDE
     37  6d6e					      lda	Board+2,x	; N pos
     38  6d6e					      ora	Board+1,x	; B pos
     39  6d6e					      bne	.noCastle	; not vacant?
     40  6d6e					      ENDIF
     41  6d6e
     42  6d6e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  6d6e
     44  6d6e							; FINALLY -- king can castle
     45  6d6e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  6d6e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  6d6e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  6d6e
     49  6d6e					      lda	currentPiece
     50  6d6e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  6d6e					      sta	currentPiece
     52  6d6e
     53  6d6e					      IF	{1} = KINGSIDE
     54  6d6e					      ldy	ValidSquare+2,x
     55  6d6e					      ENDIF
     56  6d6e
     57  6d6e					      IF	{1} = QUEENSIDE
     58  6d6e					      ldy	ValidSquare-2,x
     59  6d6e					      ENDIF
     60  6d6e
     61  6d6e
     62  6d6e					      jsr	AddMove	; 57
     63  6d6e				   .noCastle
     64  6d6e					      ENDM
     65  6d6e
     66  6d6e
     67  6d6e							;---------------------------------------------------------------------------------------------------
     68  6d6e
      0  6d6e					      DEF	Handle_KING
      1  6d6e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  6d6e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  6d6e				   Handle_KING
      4  6d6e				   TEMPORARY_VAR SET	Overlay
      5  6d6e				   TEMPORARY_OFFSET SET	0
      6  6d6e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  6d6e				   FUNCTION_NAME SET	Handle_KING
     70  6d6e					      SUBROUTINE
     71  6d6e
      0  6d6e					      REFER	GenerateAllMoves	;✅
      1  6d6e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6d6e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6d6e					      ENDIF
      0  6d6e					      VEND	Handle_KING
      1  6d6e				  -	      IFNCONST	Handle_KING
      2  6d6e				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  6d6e				  -	      ERR
      4  6d6e					      ENDIF
      5  6d6e		       00 b8	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  6d6e
     75  6d6e							; x = currentSquare (square the KING is on)
     76  6d6e							; currentPiece (KING of course, but with flags/colour attached)
     77  6d6e
      0  6d6e					      MOVE_TO	_DOWN+_LEFT
      1  6d6e					      SUBROUTINE
      2  6d6e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  6d71		       30 0e		      bmi	.invalid
      4  6d73		       b9 79 fc 	      lda	Board,y
      5  6d76		       85 9b		      sta	capture
      6  6d78		       f0 04		      beq	.squareEmpty
      7  6d7a		       45 91		      eor	currentPiece
      8  6d7c		       10 03		      bpl	.invalid
      9  6d7e		       20 73 f2    .squareEmpty jsr	AddMove
     10  6d81				   .invalid
      0  6d81					      MOVE_TO_X	_DOWN
      1  6d81		       a6 92		      ldx	currentSquare
      0  6d83					      MOVE_TO	_DOWN
      1  6d83					      SUBROUTINE
      2  6d83		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      3  6d86		       30 0e		      bmi	.invalid
      4  6d88		       b9 79 fc 	      lda	Board,y
      5  6d8b		       85 9b		      sta	capture
      6  6d8d		       f0 04		      beq	.squareEmpty
      7  6d8f		       45 91		      eor	currentPiece
      8  6d91		       10 03		      bpl	.invalid
      9  6d93		       20 73 f2    .squareEmpty jsr	AddMove
     10  6d96				   .invalid
      0  6d96					      MOVE_TO_X	_DOWN+_RIGHT
      1  6d96		       a6 92		      ldx	currentSquare
      0  6d98					      MOVE_TO	_DOWN+_RIGHT
      1  6d98					      SUBROUTINE
      2  6d98		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  6d9b		       30 0e		      bmi	.invalid
      4  6d9d		       b9 79 fc 	      lda	Board,y
      5  6da0		       85 9b		      sta	capture
      6  6da2		       f0 04		      beq	.squareEmpty
      7  6da4		       45 91		      eor	currentPiece
      8  6da6		       10 03		      bpl	.invalid
      9  6da8		       20 73 f2    .squareEmpty jsr	AddMove
     10  6dab				   .invalid
      0  6dab					      MOVE_TO_X	_RIGHT
      1  6dab		       a6 92		      ldx	currentSquare
      0  6dad					      MOVE_TO	_RIGHT
      1  6dad					      SUBROUTINE
      2  6dad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      3  6db0		       30 0e		      bmi	.invalid
      4  6db2		       b9 79 fc 	      lda	Board,y
      5  6db5		       85 9b		      sta	capture
      6  6db7		       f0 04		      beq	.squareEmpty
      7  6db9		       45 91		      eor	currentPiece
      8  6dbb		       10 03		      bpl	.invalid
      9  6dbd		       20 73 f2    .squareEmpty jsr	AddMove
     10  6dc0				   .invalid
      0  6dc0					      MOVE_TO_X	_UP+_RIGHT
      1  6dc0		       a6 92		      ldx	currentSquare
      0  6dc2					      MOVE_TO	_UP+_RIGHT
      1  6dc2					      SUBROUTINE
      2  6dc2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  6dc5		       30 0e		      bmi	.invalid
      4  6dc7		       b9 79 fc 	      lda	Board,y
      5  6dca		       85 9b		      sta	capture
      6  6dcc		       f0 04		      beq	.squareEmpty
      7  6dce		       45 91		      eor	currentPiece
      8  6dd0		       10 03		      bpl	.invalid
      9  6dd2		       20 73 f2    .squareEmpty jsr	AddMove
     10  6dd5				   .invalid
      0  6dd5					      MOVE_TO_X	_UP
      1  6dd5		       a6 92		      ldx	currentSquare
      0  6dd7					      MOVE_TO	_UP
      1  6dd7					      SUBROUTINE
      2  6dd7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      3  6dda		       30 0e		      bmi	.invalid
      4  6ddc		       b9 79 fc 	      lda	Board,y
      5  6ddf		       85 9b		      sta	capture
      6  6de1		       f0 04		      beq	.squareEmpty
      7  6de3		       45 91		      eor	currentPiece
      8  6de5		       10 03		      bpl	.invalid
      9  6de7		       20 73 f2    .squareEmpty jsr	AddMove
     10  6dea				   .invalid
      0  6dea					      MOVE_TO_X	_UP+_LEFT
      1  6dea		       a6 92		      ldx	currentSquare
      0  6dec					      MOVE_TO	_UP+_LEFT
      1  6dec					      SUBROUTINE
      2  6dec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      3  6def		       30 0e		      bmi	.invalid
      4  6df1		       b9 79 fc 	      lda	Board,y
      5  6df4		       85 9b		      sta	capture
      6  6df6		       f0 04		      beq	.squareEmpty
      7  6df8		       45 91		      eor	currentPiece
      8  6dfa		       10 03		      bpl	.invalid
      9  6dfc		       20 73 f2    .squareEmpty jsr	AddMove
     10  6dff				   .invalid
      0  6dff					      MOVE_TO_X	_LEFT
      1  6dff		       a6 92		      ldx	currentSquare
      0  6e01					      MOVE_TO	_LEFT
      1  6e01					      SUBROUTINE
      2  6e01		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      3  6e04		       30 0e		      bmi	.invalid
      4  6e06		       b9 79 fc 	      lda	Board,y
      5  6e09		       85 9b		      sta	capture
      6  6e0b		       f0 04		      beq	.squareEmpty
      7  6e0d		       45 91		      eor	currentPiece
      8  6e0f		       10 03		      bpl	.invalid
      9  6e11		       20 73 f2    .squareEmpty jsr	AddMove
     10  6e14				   .invalid
     86  6e14
     87  6e14					      IF	CASTLING_ENABLED
     88  6e14
     89  6e14		       24 91		      bit	currentPiece
     90  6e16		       70 41		      bvs	.exit	; king has moved, so no castling
     91  6e18
      0  6e18					      CASTLE	KINGSIDE
      1  6e18
      2  6e18
      3  6e18		       a6 92		      ldx	currentSquare
      4  6e1a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  6e1d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  6e1f		       c9 05		      cmp	#ROOK
      7  6e21		       d0 14		      bne	.noCastle
      8  6e23
      9  6e23
     10  6e23
     11  6e23
     12  6e23				  -	      IF	KINGSIDE = QUEENSIDE
     13  6e23				  -	      lda	Board-3,x
     14  6e23				  -	      ora	Board-2,x
     15  6e23				  -	      ora	Board-1,x
     16  6e23				  -	      bne	.noCastle
     17  6e23				  -
     18  6e23					      ENDIF
     19  6e23
     20  6e23					      IF	KINGSIDE = KINGSIDE
     21  6e23		       bd 7b fc 	      lda	Board+2,x
     22  6e26		       1d 7a fc 	      ora	Board+1,x
     23  6e29		       d0 0c		      bne	.noCastle
     24  6e2b					      ENDIF
     25  6e2b
     26  6e2b
     27  6e2b
     28  6e2b
     29  6e2b
     30  6e2b
     31  6e2b
     32  6e2b
     33  6e2b		       a5 91		      lda	currentPiece
     34  6e2d		       09 10		      ora	#FLAG_CASTLE
     35  6e2f		       85 91		      sta	currentPiece
     36  6e31
     37  6e31					      IF	KINGSIDE = KINGSIDE
     38  6e31		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  6e34					      ENDIF
     40  6e34
     41  6e34				  -	      IF	KINGSIDE = QUEENSIDE
     42  6e34				  -	      ldy	ValidSquare-2,x
     43  6e34					      ENDIF
     44  6e34
     45  6e34
     46  6e34		       20 73 f2 	      jsr	AddMove
     47  6e37				   .noCastle
      0  6e37					      CASTLE	QUEENSIDE
      1  6e37
      2  6e37
      3  6e37		       a6 92		      ldx	currentSquare
      4  6e39		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  6e3c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  6e3e		       c9 05		      cmp	#ROOK
      7  6e40		       d0 17		      bne	.noCastle
      8  6e42
      9  6e42
     10  6e42
     11  6e42
     12  6e42					      IF	QUEENSIDE = QUEENSIDE
     13  6e42		       bd 76 fc 	      lda	Board-3,x
     14  6e45		       1d 77 fc 	      ora	Board-2,x
     15  6e48		       1d 78 fc 	      ora	Board-1,x
     16  6e4b		       d0 0c		      bne	.noCastle
     17  6e4d
     18  6e4d					      ENDIF
     19  6e4d
     20  6e4d				  -	      IF	QUEENSIDE = KINGSIDE
     21  6e4d				  -	      lda	Board+2,x
     22  6e4d				  -	      ora	Board+1,x
     23  6e4d				  -	      bne	.noCastle
     24  6e4d					      ENDIF
     25  6e4d
     26  6e4d
     27  6e4d
     28  6e4d
     29  6e4d
     30  6e4d
     31  6e4d
     32  6e4d
     33  6e4d		       a5 91		      lda	currentPiece
     34  6e4f		       09 10		      ora	#FLAG_CASTLE
     35  6e51		       85 91		      sta	currentPiece
     36  6e53
     37  6e53				  -	      IF	QUEENSIDE = KINGSIDE
     38  6e53				  -	      ldy	ValidSquare+2,x
     39  6e53					      ENDIF
     40  6e53
     41  6e53					      IF	QUEENSIDE = QUEENSIDE
     42  6e53		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  6e56					      ENDIF
     44  6e56
     45  6e56
     46  6e56		       20 73 f2 	      jsr	AddMove
     47  6e59				   .noCastle
     94  6e59
     95  6e59					      ENDIF
     96  6e59
     97  6e59		       4c d6 f1    .exit      jmp	MoveReturn
     98  6e5c
     99  6e5c							;---------------------------------------------------------------------------------------------------
    100  6e5c							; EOF
------- FILE PIECE_HANDLER@1#2.asm
      7  6e5c
      8  6e5c							;---------------------------------------------------------------------------------------------------
      9  6e5c
      0  6e5c					      CHECK_BANK_SIZE	"PIECE_HANDLER_2"
      1  6e5c		       02 5c	   .TEMP      =	* - _BANK_START
 PIECE_HANDLER_2 (1K) SIZE =  $25c , FREE= $1a4
      2  6e5c					      ECHO	"PIECE_HANDLER_2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  6e5c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6e5c				  -	      ECHO	"BANK OVERFLOW @ ", "PIECE_HANDLER_2", " size=", * - ORIGIN
      5  6e5c				  -	      ERR
      6  6e5c					      ENDIF
     11  6e5c
     12  6e5c							;---------------------------------------------------------------------------------------------------
     13  6e5c							; EOF
------- FILE ./chess.asm
    572  6e5c
------- FILE TitleScreen.asm LEVEL 2 PASS 4
      0  6e5c					      include	"TitleScreen.asm"
      0  6e5c					      SLOT	1
      1  6e5c				  -	      IF	(1 < 0) || (1 > 3)
      2  6e5c				  -	      ECHO	"Illegal bank address/segment location", 1
      3  6e5c				  -	      ERR
      4  6e5c					      ENDIF
      5  6e5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      6  6e5c				   _BANK_SLOT SET	1 * 64
      0  6e5c					      ROMBANK	TITLESCREEN
      1  72b0 ????				      SEG	TITLESCREEN
      2  7000					      ORG	_ORIGIN
      3  7000					      RORG	_BANK_ADDRESS_ORIGIN
      4  7000				   _BANK_START SET	*
      5  7000				   TITLESCREEN_START SET	*
      6  7000				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7000				   TITLESCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  7000				   _ORIGIN    SET	_ORIGIN + 1024
      3  7000
      4  7000				   OverscanTime2
      5  7000		       27 1a		      .byte.b	39, 26
      6  7002		       10 20		      .byte.b	16, 32
      7  7004
      8  7004							;colvec
      9  7004							;    .word colr_ntsc2, colr_pal
     10  7004
     11  7004
     12  7004		       2a 32	   VBlankTime .byte.b	42,50
     13  7006
      0  7006					      DEF	TitleScreen
      1  7006				   SLOT_TitleScreen SET	_BANK_SLOT
      2  7006				   BANK_TitleScreen SET	SLOT_TitleScreen + _CURRENT_BANK
      3  7006				   TitleScreen
      4  7006				   TEMPORARY_VAR SET	Overlay
      5  7006				   TEMPORARY_OFFSET SET	0
      6  7006				   VAR_BOUNDARY_TitleScreen SET	TEMPORARY_OFFSET
      7  7006				   FUNCTION_NAME SET	TitleScreen
     15  7006					      SUBROUTINE
     16  7006
      0  7006					      VAR	__colour_table, 2
      1  7006		       00 a7	   __colour_table =	TEMPORARY_VAR
      2  7006				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7006
      4  7006				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7006				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7006				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7006					      ENDIF
      8  7006				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7006				  -	      ECHO	"Temporary Variable", __colour_table, "overflow!"
     10  7006				  -	      ERR
     11  7006					      ENDIF
     12  7006					      LIST	ON
     18  7006
     19  7006							; Start of new frame
     20  7006
     21  7006							; Start of vertical blank processing
     22  7006
     23  7006				   TitleSequence
     24  7006
     25  7006
     26  7006		       a9 9d		      lda	#BANK_TitleData
     27  7008		       85 3f		      sta	SET_BANK
     28  700a
     29  700a
     30  700a		       a9 00		      lda	#%00000000
     31  700c		       85 4a		      sta	CTRLPF
     32  700e
     33  700e		       a9 c0		      lda	#$C0
     34  7010		       85 49		      sta	COLUBK
     35  7012
     36  7012		       a2 00		      ldx	#0	;Platform
     37  7014		       a9 00		      lda	#<colr_ntsc2	;colvec,x
     38  7016		       85 a7		      sta	__colour_table
     39  7018		       a9 f5		      lda	#>colr_ntsc2	;colvec+1,x
     40  701a		       85 a8		      sta	__colour_table+1
     41  701c
     42  701c							;		  sta rndHi
     43  701c							;		  sta rnd
     44  701c
     45  701c
     46  701c				  -	      IF	0
     47  701c				  -	      lda	#0
     48  701c				  -	      sta	digit
     49  701c				  -	      lda	#$10
     50  701c				  -	      sta	digit+1
     51  701c				  -	      lda	#$20
     52  701c				  -	      sta	digit+2
     53  701c					      ENDIF
     54  701c
     55  701c
     56  701c
     57  701c
     58  701c							;RESYNC
     59  701c
     60  701c				   RestartFrame0
     61  701c
     62  701c				  -	      IF	0
     63  701c				  -	      ldx	#2
     64  701c				  -rollcols   clc
     65  701c				  -	      lda	digit+2
     66  701c				  -	      adc	#$10
     67  701c				  -	      sta	digit+2
     68  701c				  -	      bcc	finxc
     69  701c				  -	      dex
     70  701c				  -	      bpl	rollcols
     71  701c				  -finxc
     72  701c					      ENDIF
     73  701c
      0  701c					      DEF	RestartFrame
      1  701c				   SLOT_RestartFrame SET	_BANK_SLOT
      2  701c				   BANK_RestartFrame SET	SLOT_RestartFrame + _CURRENT_BANK
      3  701c				   RestartFrame
      4  701c				   TEMPORARY_VAR SET	Overlay
      5  701c				   TEMPORARY_OFFSET SET	0
      6  701c				   VAR_BOUNDARY_RestartFrame SET	TEMPORARY_OFFSET
      7  701c				   FUNCTION_NAME SET	RestartFrame
     75  701c		       a9 00		      LDA	#0
     76  701e		       a9 0e		      lda	#%1110	; VSYNC ON
     77  7020		       85 42	   .loopVSync2 sta	WSYNC
     78  7022		       85 40		      sta	VSYNC
     79  7024		       4a		      lsr
     80  7025		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     81  7027
     82  7027							;------------------------------------------------------------------
     83  7027
     84  7027		       a2 00		      ldx	#0	;Platform
     85  7029		       bc 04 f4 	      ldy	VBlankTime,x
     86  702c		       8c 96 02 	      sty	TIM64T
     87  702f
     88  702f
     89  702f				  -	      IF	0
     90  702f				  -	      lda	SWCHB
     91  702f				  -	      rol
     92  702f				  -	      rol
     93  702f				  -	      rol
     94  702f				  -	      and	#%11
     95  702f				  -	      eor	#PAL
     96  702f				  -	      cmp	#0	;Platform
     97  702f				  -	      beq	platOK
     98  702f				  -			;sta Platform
     99  702f				  -	      jmp	TitleSequence
    100  702f				  -platOK
    101  702f					      ENDIF
    102  702f
    103  702f		       e6 81	   k2	      inc	rnd
    104  7031		       f0 fc		      beq	k2
    105  7033
    106  7033
    107  7033		       85 42	   VerticalBlank sta	WSYNC
    108  7035		       ad 84 02 	      lda	INTIM
    109  7038		       d0 f9		      bne	VerticalBlank
    110  703a		       85 41		      sta	VBLANK
    111  703c
    112  703c		       a9 00		      lda	#$0
    113  703e		       85 49		      sta	COLUBK
    114  7040
    115  7040							;------------------------------------------------------------------
    116  7040
    117  7040							; Do X scanlines of color-changing (our picture)
    118  7040
    119  7040		       a0 c9		      ldy	#67*3	; this counts our scanline number
    120  7042				   SokoLogo
    121  7042
    122  7042
    123  7042		       a9 24		      lda	#$24
    124  7044
    125  7044		       85 42		      sta	WSYNC
    126  7046		       85 48		      sta	COLUPF	; 3
    127  7048
    128  7048		       b9 00 f8 	      lda	COL_0,y	; 5
    129  704b		       85 4d		      sta	PF0	; 3   @11
    130  704d		       b9 cc f8 	      lda	COL_1,y	; 5
    131  7050		       85 4e		      sta	PF1	; 3   @19
    132  7052		       b9 98 f9 	      lda	COL_2,y	; 5
    133  7055		       85 4f		      sta	PF2	; 3   @27
    134  7057
    135  7057		       b9 00 f8 	      lda	COL_0,y	; 5
    136  705a		       0a		      asl
    137  705b		       0a		      asl
    138  705c		       0a		      asl
    139  705d		       0a		      asl
    140  705e		       85 4d		      sta	PF0	; 3   @35
    141  7060							;		  SLEEP 2      ; @37
    142  7060		       b9 64 fa 	      lda	COL_3,y	; 5
    143  7063		       85 4e		      sta	PF1	; 3   @45
    144  7065							;		  SLEEP 3      ; @45
    145  7065		       b9 30 fb 	      lda	COL_4,y	; 5
    146  7068		       85 4f		      sta	PF2	; 3
    147  706a
    148  706a		       88		      dey
    149  706b
    150  706b		       a9 68		      lda	#$68
    151  706d
    152  706d		       85 42		      sta	WSYNC
    153  706f		       85 48		      sta	COLUPF	; 3
    154  7071
    155  7071		       b9 00 f8 	      lda	COL_0,y	; 5
    156  7074		       85 4d		      sta	PF0	; 3   @11
    157  7076		       b9 cc f8 	      lda	COL_1,y	; 5
    158  7079		       85 4e		      sta	PF1	; 3   @19
    159  707b		       b9 98 f9 	      lda	COL_2,y	; 5
    160  707e		       85 4f		      sta	PF2	; 3   @27
    161  7080
    162  7080		       b9 00 f8 	      lda	COL_0,y	; 5
    163  7083		       0a		      asl
    164  7084		       0a		      asl
    165  7085		       0a		      asl
    166  7086		       0a		      asl
    167  7087		       85 4d		      sta	PF0	; 3   @35
    168  7089							;		  SLEEP 2      ; @37
    169  7089		       b9 64 fa 	      lda	COL_3,y	; 5
    170  708c		       85 4e		      sta	PF1	; 3   @45
    171  708e							;		  SLEEP 3      ; @45
    172  708e		       b9 30 fb 	      lda	COL_4,y	; 5
    173  7091		       85 4f		      sta	PF2	; 3
    174  7093
    175  7093		       88		      dey
    176  7094
    177  7094
    178  7094		       a9 d6		      lda	#$D6
    179  7096
    180  7096		       85 42		      sta	WSYNC
    181  7098		       85 48		      sta	COLUPF	; 3
    182  709a
    183  709a		       b9 00 f8 	      lda	COL_0,y	; 5
    184  709d		       85 4d		      sta	PF0	; 3   @11
    185  709f		       b9 cc f8 	      lda	COL_1,y	; 5
    186  70a2		       85 4e		      sta	PF1	; 3   @19
    187  70a4		       b9 98 f9 	      lda	COL_2,y	; 5
    188  70a7		       85 4f		      sta	PF2	; 3   @27
    189  70a9
    190  70a9		       b9 00 f8 	      lda	COL_0,y	; 5
    191  70ac		       0a		      asl
    192  70ad		       0a		      asl
    193  70ae		       0a		      asl
    194  70af		       0a		      asl
    195  70b0		       85 4d		      sta	PF0	; 3   @35
    196  70b2							;		  SLEEP 2      ; @37
    197  70b2		       b9 64 fa 	      lda	COL_3,y	; 5
    198  70b5		       85 4e		      sta	PF1	; 3   @45
    199  70b7							;		  SLEEP 3      ; @45
    200  70b7		       b9 30 fb 	      lda	COL_4,y	; 5
    201  70ba		       85 4f		      sta	PF2	; 3
    202  70bc
    203  70bc
    204  70bc
    205  70bc		       88		      dey		; 2
    206  70bd		       d0 83		      bne	SokoLogo	; 2(3)
    207  70bf
    208  70bf							;lda #0
    209  70bf							;sta PF0
    210  70bf							;sta PF1
    211  70bf							;sta PF2
    212  70bf
    213  70bf		       a2 00		      ldx	#0	;Platform
    214  70c1		       86 4d		      stx	PF0
    215  70c3		       86 4e		      stx	PF1
    216  70c5		       86 4f		      stx	PF2
    217  70c7
    218  70c7		       85 42		      sta	WSYNC
    219  70c9		       85 42		      sta	WSYNC
    220  70cb		       85 42		      sta	WSYNC
    221  70cd		       85 42		      sta	WSYNC
    222  70cf
    223  70cf		       86 49		      stx	COLUBK
    224  70d1		       bd 00 f4 	      lda	OverscanTime2,x
    225  70d4		       8d 96 02 	      sta	TIM64T
    226  70d7
    227  70d7				  -	      IF	0
    228  70d7				  -	      sta	WSYNC
    229  70d7				  -	      sta	WSYNC
    230  70d7				  -	      sta	WSYNC
    231  70d7				  -	      sta	WSYNC
    232  70d7				  -	      sta	WSYNC
    233  70d7				  -	      SLEEP	8
    234  70d7				  -	      jsr	SokoScreen
    235  70d7				  -
    236  70d7				  -	      lda	#0
    237  70d7				  -	      sta	BoardScrollX
    238  70d7				  -	      sta	BoardScrollY
    239  70d7					      ENDIF
    240  70d7
    241  70d7							;		ldy #63
    242  70d7							;bot2		 sta WSYNC
    243  70d7							;		dey
    244  70d7							;		bpl bot2
    245  70d7
    246  70d7							;--------------------------------------------------------------------------
    247  70d7
    248  70d7		       a9 00		      lda	#0
    249  70d9		       85 4d		      sta	PF0
    250  70db		       85 4e		      sta	PF1
    251  70dd		       85 4f		      sta	PF2
    252  70df
    253  70df
      0  70df					      NEXT_RANDOM
      1  70df		       a5 81		      lda	rnd
      2  70e1		       4a		      lsr
      3  70e2		       90 02		      bcc	.skipEOR
      4  70e4		       49 fe		      eor	#RND_EOR_VAL
      5  70e6		       85 81	   .skipEOR   sta	rnd
    255  70e8
    256  70e8							; D1 VBLANK turns off beam
    257  70e8							; It needs to be turned on 37 scanlines later
    258  70e8
    259  70e8				   oscan
    260  70e8		       ad 84 02 	      lda	INTIM
    261  70eb		       d0 fb		      bne	oscan
    262  70ed
    263  70ed		       a9 42		      lda	#%01000010	; bit6 is not required
    264  70ef		       85 41		      sta	VBLANK	; end of screen - enter blanking
    265  70f1
    266  70f1				  -	      IF	0
    267  70f1				  -	      inc	rnd
    268  70f1				  -	      bne	rdd
    269  70f1				  -	      inc	rndHi
    270  70f1				  -rdd
    271  70f1				  -
    272  70f1				  -	      dec	digitick
    273  70f1				  -	      bpl	ret2
    274  70f1				  -	      lda	#40
    275  70f1				  -	      sta	digitick
    276  70f1				  -
    277  70f1				  -	      jsr	Random
    278  70f1				  -	      and	#3
    279  70f1				  -	      beq	ret2
    280  70f1				  -	      tax
    281  70f1				  -	      jsr	Random
    282  70f1				  -	      and	#$F0
    283  70f1				  -	      sta	digit-1,x
    284  70f1				  -	      jmp	RestartFrame0
    285  70f1				  -
    286  70f1				  -ret2
    287  70f1					      ENDIF
    288  70f1
    289  70f1
    290  70f1		       a5 4c		      lda	INPT4
    291  70f3		       10 03		      bpl	ret
    292  70f5
    293  70f5		       4c 1c f4 	      jmp	RestartFrame
    294  70f8
    295  70f8				   ret
    296  70f8		       60		      rts
    297  70f9
    298  70f9
    299  70f9
    300  70f9					      MAC	lumtable
    301  70f9							; {4} MIN LUM 1
    302  70f9							; {5} MIN LUM 2
    303  70f9							; {6} MIN LUM 3
    304  70f9
    305  70f9				   .LUM1      SET	{4}*256
    306  70f9				   .LUM2      SET	{5}*256
    307  70f9				   .LUM3      SET	{6}*256
    308  70f9
    309  70f9				   .STEP1     =	(256*({7}-{4}))/72
    310  70f9				   .STEP2     =	(256*({8}-{5}))/72
    311  70f9				   .STEP3     =	(256*({9}-{6}))/72
    312  70f9
    313  70f9					      REPEAT	72
    314  70f9					      .byte	{1}+(.LUM1/256)
    315  70f9					      .byte	{2}+(.LUM2/256)
    316  70f9					      .byte	{3}+(.LUM3/256)
    317  70f9
    318  70f9							;    ECHO {1}+(.LUM1/256)
    319  70f9							;    ECHO {2}+(.LUM1/256)
    320  70f9							;    ECHO {3}+(.LUM1/256)
    321  70f9
    322  70f9				   .LUM1      SET	.LUM1 + .STEP1
    323  70f9				   .LUM2      SET	.LUM2 + .STEP2
    324  70f9				   .LUM3      SET	.LUM3 + .STEP3
    325  70f9					      REPEND
    326  70f9					      ENDM		;{1}{2}{3} base colours
    327  70f9
    328  70f9							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    329  70f9							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    330  70f9
    331  7100		       00 00 00 00*	      align	256
    332  7100							;    ECHO "NTSC LUMS"
    333  7100				   colr_ntsc2
      0  7100					      LUMTABLE	$90,$10,$20,$4,$6,$8,$4,$6,$8
      1  7100
      2  7100
      3  7100
      4  7100
      5  7100				   .LUM1      SET	$4*256
      6  7100				   .LUM2      SET	$6*256
      7  7100				   .LUM3      SET	$8*256
      8  7100
      9  7100		       00 00	   .STEP1     =	(256*($4-$4))/72
     10  7100		       00 00	   .STEP2     =	(256*($6-$6))/72
     11  7100		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  7100
     13  7100					      REPEAT	72
     14  7100		       94		      .byte.b	$90+(.LUM1/256)
     15  7101		       16		      .byte.b	$10+(.LUM2/256)
     16  7102		       28		      .byte.b	$20+(.LUM3/256)
     17  7103
     18  7103
     19  7103
     20  7103
     21  7103
     22  7103				   .LUM1      SET	.LUM1 + .STEP1
     23  7103				   .LUM2      SET	.LUM2 + .STEP2
     24  7103				   .LUM3      SET	.LUM3 + .STEP3
     13  7103					      REPEND
     14  7103		       94		      .byte.b	$90+(.LUM1/256)
     15  7104		       16		      .byte.b	$10+(.LUM2/256)
     16  7105		       28		      .byte.b	$20+(.LUM3/256)
     17  7106
     18  7106
     19  7106
     20  7106
     21  7106
     22  7106				   .LUM1      SET	.LUM1 + .STEP1
     23  7106				   .LUM2      SET	.LUM2 + .STEP2
     24  7106				   .LUM3      SET	.LUM3 + .STEP3
     13  7106					      REPEND
     14  7106		       94		      .byte.b	$90+(.LUM1/256)
     15  7107		       16		      .byte.b	$10+(.LUM2/256)
     16  7108		       28		      .byte.b	$20+(.LUM3/256)
     17  7109
     18  7109
     19  7109
     20  7109
     21  7109
     22  7109				   .LUM1      SET	.LUM1 + .STEP1
     23  7109				   .LUM2      SET	.LUM2 + .STEP2
     24  7109				   .LUM3      SET	.LUM3 + .STEP3
     13  7109					      REPEND
     14  7109		       94		      .byte.b	$90+(.LUM1/256)
     15  710a		       16		      .byte.b	$10+(.LUM2/256)
     16  710b		       28		      .byte.b	$20+(.LUM3/256)
     17  710c
     18  710c
     19  710c
     20  710c
     21  710c
     22  710c				   .LUM1      SET	.LUM1 + .STEP1
     23  710c				   .LUM2      SET	.LUM2 + .STEP2
     24  710c				   .LUM3      SET	.LUM3 + .STEP3
     13  710c					      REPEND
     14  710c		       94		      .byte.b	$90+(.LUM1/256)
     15  710d		       16		      .byte.b	$10+(.LUM2/256)
     16  710e		       28		      .byte.b	$20+(.LUM3/256)
     17  710f
     18  710f
     19  710f
     20  710f
     21  710f
     22  710f				   .LUM1      SET	.LUM1 + .STEP1
     23  710f				   .LUM2      SET	.LUM2 + .STEP2
     24  710f				   .LUM3      SET	.LUM3 + .STEP3
     13  710f					      REPEND
     14  710f		       94		      .byte.b	$90+(.LUM1/256)
     15  7110		       16		      .byte.b	$10+(.LUM2/256)
     16  7111		       28		      .byte.b	$20+(.LUM3/256)
     17  7112
     18  7112
     19  7112
     20  7112
     21  7112
     22  7112				   .LUM1      SET	.LUM1 + .STEP1
     23  7112				   .LUM2      SET	.LUM2 + .STEP2
     24  7112				   .LUM3      SET	.LUM3 + .STEP3
     13  7112					      REPEND
     14  7112		       94		      .byte.b	$90+(.LUM1/256)
     15  7113		       16		      .byte.b	$10+(.LUM2/256)
     16  7114		       28		      .byte.b	$20+(.LUM3/256)
     17  7115
     18  7115
     19  7115
     20  7115
     21  7115
     22  7115				   .LUM1      SET	.LUM1 + .STEP1
     23  7115				   .LUM2      SET	.LUM2 + .STEP2
     24  7115				   .LUM3      SET	.LUM3 + .STEP3
     13  7115					      REPEND
     14  7115		       94		      .byte.b	$90+(.LUM1/256)
     15  7116		       16		      .byte.b	$10+(.LUM2/256)
     16  7117		       28		      .byte.b	$20+(.LUM3/256)
     17  7118
     18  7118
     19  7118
     20  7118
     21  7118
     22  7118				   .LUM1      SET	.LUM1 + .STEP1
     23  7118				   .LUM2      SET	.LUM2 + .STEP2
     24  7118				   .LUM3      SET	.LUM3 + .STEP3
     13  7118					      REPEND
     14  7118		       94		      .byte.b	$90+(.LUM1/256)
     15  7119		       16		      .byte.b	$10+(.LUM2/256)
     16  711a		       28		      .byte.b	$20+(.LUM3/256)
     17  711b
     18  711b
     19  711b
     20  711b
     21  711b
     22  711b				   .LUM1      SET	.LUM1 + .STEP1
     23  711b				   .LUM2      SET	.LUM2 + .STEP2
     24  711b				   .LUM3      SET	.LUM3 + .STEP3
     13  711b					      REPEND
     14  711b		       94		      .byte.b	$90+(.LUM1/256)
     15  711c		       16		      .byte.b	$10+(.LUM2/256)
     16  711d		       28		      .byte.b	$20+(.LUM3/256)
     17  711e
     18  711e
     19  711e
     20  711e
     21  711e
     22  711e				   .LUM1      SET	.LUM1 + .STEP1
     23  711e				   .LUM2      SET	.LUM2 + .STEP2
     24  711e				   .LUM3      SET	.LUM3 + .STEP3
     13  711e					      REPEND
     14  711e		       94		      .byte.b	$90+(.LUM1/256)
     15  711f		       16		      .byte.b	$10+(.LUM2/256)
     16  7120		       28		      .byte.b	$20+(.LUM3/256)
     17  7121
     18  7121
     19  7121
     20  7121
     21  7121
     22  7121				   .LUM1      SET	.LUM1 + .STEP1
     23  7121				   .LUM2      SET	.LUM2 + .STEP2
     24  7121				   .LUM3      SET	.LUM3 + .STEP3
     13  7121					      REPEND
     14  7121		       94		      .byte.b	$90+(.LUM1/256)
     15  7122		       16		      .byte.b	$10+(.LUM2/256)
     16  7123		       28		      .byte.b	$20+(.LUM3/256)
     17  7124
     18  7124
     19  7124
     20  7124
     21  7124
     22  7124				   .LUM1      SET	.LUM1 + .STEP1
     23  7124				   .LUM2      SET	.LUM2 + .STEP2
     24  7124				   .LUM3      SET	.LUM3 + .STEP3
     13  7124					      REPEND
     14  7124		       94		      .byte.b	$90+(.LUM1/256)
     15  7125		       16		      .byte.b	$10+(.LUM2/256)
     16  7126		       28		      .byte.b	$20+(.LUM3/256)
     17  7127
     18  7127
     19  7127
     20  7127
     21  7127
     22  7127				   .LUM1      SET	.LUM1 + .STEP1
     23  7127				   .LUM2      SET	.LUM2 + .STEP2
     24  7127				   .LUM3      SET	.LUM3 + .STEP3
     13  7127					      REPEND
     14  7127		       94		      .byte.b	$90+(.LUM1/256)
     15  7128		       16		      .byte.b	$10+(.LUM2/256)
     16  7129		       28		      .byte.b	$20+(.LUM3/256)
     17  712a
     18  712a
     19  712a
     20  712a
     21  712a
     22  712a				   .LUM1      SET	.LUM1 + .STEP1
     23  712a				   .LUM2      SET	.LUM2 + .STEP2
     24  712a				   .LUM3      SET	.LUM3 + .STEP3
     13  712a					      REPEND
     14  712a		       94		      .byte.b	$90+(.LUM1/256)
     15  712b		       16		      .byte.b	$10+(.LUM2/256)
     16  712c		       28		      .byte.b	$20+(.LUM3/256)
     17  712d
     18  712d
     19  712d
     20  712d
     21  712d
     22  712d				   .LUM1      SET	.LUM1 + .STEP1
     23  712d				   .LUM2      SET	.LUM2 + .STEP2
     24  712d				   .LUM3      SET	.LUM3 + .STEP3
     13  712d					      REPEND
     14  712d		       94		      .byte.b	$90+(.LUM1/256)
     15  712e		       16		      .byte.b	$10+(.LUM2/256)
     16  712f		       28		      .byte.b	$20+(.LUM3/256)
     17  7130
     18  7130
     19  7130
     20  7130
     21  7130
     22  7130				   .LUM1      SET	.LUM1 + .STEP1
     23  7130				   .LUM2      SET	.LUM2 + .STEP2
     24  7130				   .LUM3      SET	.LUM3 + .STEP3
     13  7130					      REPEND
     14  7130		       94		      .byte.b	$90+(.LUM1/256)
     15  7131		       16		      .byte.b	$10+(.LUM2/256)
     16  7132		       28		      .byte.b	$20+(.LUM3/256)
     17  7133
     18  7133
     19  7133
     20  7133
     21  7133
     22  7133				   .LUM1      SET	.LUM1 + .STEP1
     23  7133				   .LUM2      SET	.LUM2 + .STEP2
     24  7133				   .LUM3      SET	.LUM3 + .STEP3
     13  7133					      REPEND
     14  7133		       94		      .byte.b	$90+(.LUM1/256)
     15  7134		       16		      .byte.b	$10+(.LUM2/256)
     16  7135		       28		      .byte.b	$20+(.LUM3/256)
     17  7136
     18  7136
     19  7136
     20  7136
     21  7136
     22  7136				   .LUM1      SET	.LUM1 + .STEP1
     23  7136				   .LUM2      SET	.LUM2 + .STEP2
     24  7136				   .LUM3      SET	.LUM3 + .STEP3
     13  7136					      REPEND
     14  7136		       94		      .byte.b	$90+(.LUM1/256)
     15  7137		       16		      .byte.b	$10+(.LUM2/256)
     16  7138		       28		      .byte.b	$20+(.LUM3/256)
     17  7139
     18  7139
     19  7139
     20  7139
     21  7139
     22  7139				   .LUM1      SET	.LUM1 + .STEP1
     23  7139				   .LUM2      SET	.LUM2 + .STEP2
     24  7139				   .LUM3      SET	.LUM3 + .STEP3
     13  7139					      REPEND
     14  7139		       94		      .byte.b	$90+(.LUM1/256)
     15  713a		       16		      .byte.b	$10+(.LUM2/256)
     16  713b		       28		      .byte.b	$20+(.LUM3/256)
     17  713c
     18  713c
     19  713c
     20  713c
     21  713c
     22  713c				   .LUM1      SET	.LUM1 + .STEP1
     23  713c				   .LUM2      SET	.LUM2 + .STEP2
     24  713c				   .LUM3      SET	.LUM3 + .STEP3
     13  713c					      REPEND
     14  713c		       94		      .byte.b	$90+(.LUM1/256)
     15  713d		       16		      .byte.b	$10+(.LUM2/256)
     16  713e		       28		      .byte.b	$20+(.LUM3/256)
     17  713f
     18  713f
     19  713f
     20  713f
     21  713f
     22  713f				   .LUM1      SET	.LUM1 + .STEP1
     23  713f				   .LUM2      SET	.LUM2 + .STEP2
     24  713f				   .LUM3      SET	.LUM3 + .STEP3
     13  713f					      REPEND
     14  713f		       94		      .byte.b	$90+(.LUM1/256)
     15  7140		       16		      .byte.b	$10+(.LUM2/256)
     16  7141		       28		      .byte.b	$20+(.LUM3/256)
     17  7142
     18  7142
     19  7142
     20  7142
     21  7142
     22  7142				   .LUM1      SET	.LUM1 + .STEP1
     23  7142				   .LUM2      SET	.LUM2 + .STEP2
     24  7142				   .LUM3      SET	.LUM3 + .STEP3
     13  7142					      REPEND
     14  7142		       94		      .byte.b	$90+(.LUM1/256)
     15  7143		       16		      .byte.b	$10+(.LUM2/256)
     16  7144		       28		      .byte.b	$20+(.LUM3/256)
     17  7145
     18  7145
     19  7145
     20  7145
     21  7145
     22  7145				   .LUM1      SET	.LUM1 + .STEP1
     23  7145				   .LUM2      SET	.LUM2 + .STEP2
     24  7145				   .LUM3      SET	.LUM3 + .STEP3
     13  7145					      REPEND
     14  7145		       94		      .byte.b	$90+(.LUM1/256)
     15  7146		       16		      .byte.b	$10+(.LUM2/256)
     16  7147		       28		      .byte.b	$20+(.LUM3/256)
     17  7148
     18  7148
     19  7148
     20  7148
     21  7148
     22  7148				   .LUM1      SET	.LUM1 + .STEP1
     23  7148				   .LUM2      SET	.LUM2 + .STEP2
     24  7148				   .LUM3      SET	.LUM3 + .STEP3
     13  7148					      REPEND
     14  7148		       94		      .byte.b	$90+(.LUM1/256)
     15  7149		       16		      .byte.b	$10+(.LUM2/256)
     16  714a		       28		      .byte.b	$20+(.LUM3/256)
     17  714b
     18  714b
     19  714b
     20  714b
     21  714b
     22  714b				   .LUM1      SET	.LUM1 + .STEP1
     23  714b				   .LUM2      SET	.LUM2 + .STEP2
     24  714b				   .LUM3      SET	.LUM3 + .STEP3
     13  714b					      REPEND
     14  714b		       94		      .byte.b	$90+(.LUM1/256)
     15  714c		       16		      .byte.b	$10+(.LUM2/256)
     16  714d		       28		      .byte.b	$20+(.LUM3/256)
     17  714e
     18  714e
     19  714e
     20  714e
     21  714e
     22  714e				   .LUM1      SET	.LUM1 + .STEP1
     23  714e				   .LUM2      SET	.LUM2 + .STEP2
     24  714e				   .LUM3      SET	.LUM3 + .STEP3
     13  714e					      REPEND
     14  714e		       94		      .byte.b	$90+(.LUM1/256)
     15  714f		       16		      .byte.b	$10+(.LUM2/256)
     16  7150		       28		      .byte.b	$20+(.LUM3/256)
     17  7151
     18  7151
     19  7151
     20  7151
     21  7151
     22  7151				   .LUM1      SET	.LUM1 + .STEP1
     23  7151				   .LUM2      SET	.LUM2 + .STEP2
     24  7151				   .LUM3      SET	.LUM3 + .STEP3
     13  7151					      REPEND
     14  7151		       94		      .byte.b	$90+(.LUM1/256)
     15  7152		       16		      .byte.b	$10+(.LUM2/256)
     16  7153		       28		      .byte.b	$20+(.LUM3/256)
     17  7154
     18  7154
     19  7154
     20  7154
     21  7154
     22  7154				   .LUM1      SET	.LUM1 + .STEP1
     23  7154				   .LUM2      SET	.LUM2 + .STEP2
     24  7154				   .LUM3      SET	.LUM3 + .STEP3
     13  7154					      REPEND
     14  7154		       94		      .byte.b	$90+(.LUM1/256)
     15  7155		       16		      .byte.b	$10+(.LUM2/256)
     16  7156		       28		      .byte.b	$20+(.LUM3/256)
     17  7157
     18  7157
     19  7157
     20  7157
     21  7157
     22  7157				   .LUM1      SET	.LUM1 + .STEP1
     23  7157				   .LUM2      SET	.LUM2 + .STEP2
     24  7157				   .LUM3      SET	.LUM3 + .STEP3
     13  7157					      REPEND
     14  7157		       94		      .byte.b	$90+(.LUM1/256)
     15  7158		       16		      .byte.b	$10+(.LUM2/256)
     16  7159		       28		      .byte.b	$20+(.LUM3/256)
     17  715a
     18  715a
     19  715a
     20  715a
     21  715a
     22  715a				   .LUM1      SET	.LUM1 + .STEP1
     23  715a				   .LUM2      SET	.LUM2 + .STEP2
     24  715a				   .LUM3      SET	.LUM3 + .STEP3
     13  715a					      REPEND
     14  715a		       94		      .byte.b	$90+(.LUM1/256)
     15  715b		       16		      .byte.b	$10+(.LUM2/256)
     16  715c		       28		      .byte.b	$20+(.LUM3/256)
     17  715d
     18  715d
     19  715d
     20  715d
     21  715d
     22  715d				   .LUM1      SET	.LUM1 + .STEP1
     23  715d				   .LUM2      SET	.LUM2 + .STEP2
     24  715d				   .LUM3      SET	.LUM3 + .STEP3
     13  715d					      REPEND
     14  715d		       94		      .byte.b	$90+(.LUM1/256)
     15  715e		       16		      .byte.b	$10+(.LUM2/256)
     16  715f		       28		      .byte.b	$20+(.LUM3/256)
     17  7160
     18  7160
     19  7160
     20  7160
     21  7160
     22  7160				   .LUM1      SET	.LUM1 + .STEP1
     23  7160				   .LUM2      SET	.LUM2 + .STEP2
     24  7160				   .LUM3      SET	.LUM3 + .STEP3
     13  7160					      REPEND
     14  7160		       94		      .byte.b	$90+(.LUM1/256)
     15  7161		       16		      .byte.b	$10+(.LUM2/256)
     16  7162		       28		      .byte.b	$20+(.LUM3/256)
     17  7163
     18  7163
     19  7163
     20  7163
     21  7163
     22  7163				   .LUM1      SET	.LUM1 + .STEP1
     23  7163				   .LUM2      SET	.LUM2 + .STEP2
     24  7163				   .LUM3      SET	.LUM3 + .STEP3
     13  7163					      REPEND
     14  7163		       94		      .byte.b	$90+(.LUM1/256)
     15  7164		       16		      .byte.b	$10+(.LUM2/256)
     16  7165		       28		      .byte.b	$20+(.LUM3/256)
     17  7166
     18  7166
     19  7166
     20  7166
     21  7166
     22  7166				   .LUM1      SET	.LUM1 + .STEP1
     23  7166				   .LUM2      SET	.LUM2 + .STEP2
     24  7166				   .LUM3      SET	.LUM3 + .STEP3
     13  7166					      REPEND
     14  7166		       94		      .byte.b	$90+(.LUM1/256)
     15  7167		       16		      .byte.b	$10+(.LUM2/256)
     16  7168		       28		      .byte.b	$20+(.LUM3/256)
     17  7169
     18  7169
     19  7169
     20  7169
     21  7169
     22  7169				   .LUM1      SET	.LUM1 + .STEP1
     23  7169				   .LUM2      SET	.LUM2 + .STEP2
     24  7169				   .LUM3      SET	.LUM3 + .STEP3
     13  7169					      REPEND
     14  7169		       94		      .byte.b	$90+(.LUM1/256)
     15  716a		       16		      .byte.b	$10+(.LUM2/256)
     16  716b		       28		      .byte.b	$20+(.LUM3/256)
     17  716c
     18  716c
     19  716c
     20  716c
     21  716c
     22  716c				   .LUM1      SET	.LUM1 + .STEP1
     23  716c				   .LUM2      SET	.LUM2 + .STEP2
     24  716c				   .LUM3      SET	.LUM3 + .STEP3
     13  716c					      REPEND
     14  716c		       94		      .byte.b	$90+(.LUM1/256)
     15  716d		       16		      .byte.b	$10+(.LUM2/256)
     16  716e		       28		      .byte.b	$20+(.LUM3/256)
     17  716f
     18  716f
     19  716f
     20  716f
     21  716f
     22  716f				   .LUM1      SET	.LUM1 + .STEP1
     23  716f				   .LUM2      SET	.LUM2 + .STEP2
     24  716f				   .LUM3      SET	.LUM3 + .STEP3
     13  716f					      REPEND
     14  716f		       94		      .byte.b	$90+(.LUM1/256)
     15  7170		       16		      .byte.b	$10+(.LUM2/256)
     16  7171		       28		      .byte.b	$20+(.LUM3/256)
     17  7172
     18  7172
     19  7172
     20  7172
     21  7172
     22  7172				   .LUM1      SET	.LUM1 + .STEP1
     23  7172				   .LUM2      SET	.LUM2 + .STEP2
     24  7172				   .LUM3      SET	.LUM3 + .STEP3
     13  7172					      REPEND
     14  7172		       94		      .byte.b	$90+(.LUM1/256)
     15  7173		       16		      .byte.b	$10+(.LUM2/256)
     16  7174		       28		      .byte.b	$20+(.LUM3/256)
     17  7175
     18  7175
     19  7175
     20  7175
     21  7175
     22  7175				   .LUM1      SET	.LUM1 + .STEP1
     23  7175				   .LUM2      SET	.LUM2 + .STEP2
     24  7175				   .LUM3      SET	.LUM3 + .STEP3
     13  7175					      REPEND
     14  7175		       94		      .byte.b	$90+(.LUM1/256)
     15  7176		       16		      .byte.b	$10+(.LUM2/256)
     16  7177		       28		      .byte.b	$20+(.LUM3/256)
     17  7178
     18  7178
     19  7178
     20  7178
     21  7178
     22  7178				   .LUM1      SET	.LUM1 + .STEP1
     23  7178				   .LUM2      SET	.LUM2 + .STEP2
     24  7178				   .LUM3      SET	.LUM3 + .STEP3
     13  7178					      REPEND
     14  7178		       94		      .byte.b	$90+(.LUM1/256)
     15  7179		       16		      .byte.b	$10+(.LUM2/256)
     16  717a		       28		      .byte.b	$20+(.LUM3/256)
     17  717b
     18  717b
     19  717b
     20  717b
     21  717b
     22  717b				   .LUM1      SET	.LUM1 + .STEP1
     23  717b				   .LUM2      SET	.LUM2 + .STEP2
     24  717b				   .LUM3      SET	.LUM3 + .STEP3
     13  717b					      REPEND
     14  717b		       94		      .byte.b	$90+(.LUM1/256)
     15  717c		       16		      .byte.b	$10+(.LUM2/256)
     16  717d		       28		      .byte.b	$20+(.LUM3/256)
     17  717e
     18  717e
     19  717e
     20  717e
     21  717e
     22  717e				   .LUM1      SET	.LUM1 + .STEP1
     23  717e				   .LUM2      SET	.LUM2 + .STEP2
     24  717e				   .LUM3      SET	.LUM3 + .STEP3
     13  717e					      REPEND
     14  717e		       94		      .byte.b	$90+(.LUM1/256)
     15  717f		       16		      .byte.b	$10+(.LUM2/256)
     16  7180		       28		      .byte.b	$20+(.LUM3/256)
     17  7181
     18  7181
     19  7181
     20  7181
     21  7181
     22  7181				   .LUM1      SET	.LUM1 + .STEP1
     23  7181				   .LUM2      SET	.LUM2 + .STEP2
     24  7181				   .LUM3      SET	.LUM3 + .STEP3
     13  7181					      REPEND
     14  7181		       94		      .byte.b	$90+(.LUM1/256)
     15  7182		       16		      .byte.b	$10+(.LUM2/256)
     16  7183		       28		      .byte.b	$20+(.LUM3/256)
     17  7184
     18  7184
     19  7184
     20  7184
     21  7184
     22  7184				   .LUM1      SET	.LUM1 + .STEP1
     23  7184				   .LUM2      SET	.LUM2 + .STEP2
     24  7184				   .LUM3      SET	.LUM3 + .STEP3
     13  7184					      REPEND
     14  7184		       94		      .byte.b	$90+(.LUM1/256)
     15  7185		       16		      .byte.b	$10+(.LUM2/256)
     16  7186		       28		      .byte.b	$20+(.LUM3/256)
     17  7187
     18  7187
     19  7187
     20  7187
     21  7187
     22  7187				   .LUM1      SET	.LUM1 + .STEP1
     23  7187				   .LUM2      SET	.LUM2 + .STEP2
     24  7187				   .LUM3      SET	.LUM3 + .STEP3
     13  7187					      REPEND
     14  7187		       94		      .byte.b	$90+(.LUM1/256)
     15  7188		       16		      .byte.b	$10+(.LUM2/256)
     16  7189		       28		      .byte.b	$20+(.LUM3/256)
     17  718a
     18  718a
     19  718a
     20  718a
     21  718a
     22  718a				   .LUM1      SET	.LUM1 + .STEP1
     23  718a				   .LUM2      SET	.LUM2 + .STEP2
     24  718a				   .LUM3      SET	.LUM3 + .STEP3
     13  718a					      REPEND
     14  718a		       94		      .byte.b	$90+(.LUM1/256)
     15  718b		       16		      .byte.b	$10+(.LUM2/256)
     16  718c		       28		      .byte.b	$20+(.LUM3/256)
     17  718d
     18  718d
     19  718d
     20  718d
     21  718d
     22  718d				   .LUM1      SET	.LUM1 + .STEP1
     23  718d				   .LUM2      SET	.LUM2 + .STEP2
     24  718d				   .LUM3      SET	.LUM3 + .STEP3
     13  718d					      REPEND
     14  718d		       94		      .byte.b	$90+(.LUM1/256)
     15  718e		       16		      .byte.b	$10+(.LUM2/256)
     16  718f		       28		      .byte.b	$20+(.LUM3/256)
     17  7190
     18  7190
     19  7190
     20  7190
     21  7190
     22  7190				   .LUM1      SET	.LUM1 + .STEP1
     23  7190				   .LUM2      SET	.LUM2 + .STEP2
     24  7190				   .LUM3      SET	.LUM3 + .STEP3
     13  7190					      REPEND
     14  7190		       94		      .byte.b	$90+(.LUM1/256)
     15  7191		       16		      .byte.b	$10+(.LUM2/256)
     16  7192		       28		      .byte.b	$20+(.LUM3/256)
     17  7193
     18  7193
     19  7193
     20  7193
     21  7193
     22  7193				   .LUM1      SET	.LUM1 + .STEP1
     23  7193				   .LUM2      SET	.LUM2 + .STEP2
     24  7193				   .LUM3      SET	.LUM3 + .STEP3
     13  7193					      REPEND
     14  7193		       94		      .byte.b	$90+(.LUM1/256)
     15  7194		       16		      .byte.b	$10+(.LUM2/256)
     16  7195		       28		      .byte.b	$20+(.LUM3/256)
     17  7196
     18  7196
     19  7196
     20  7196
     21  7196
     22  7196				   .LUM1      SET	.LUM1 + .STEP1
     23  7196				   .LUM2      SET	.LUM2 + .STEP2
     24  7196				   .LUM3      SET	.LUM3 + .STEP3
     13  7196					      REPEND
     14  7196		       94		      .byte.b	$90+(.LUM1/256)
     15  7197		       16		      .byte.b	$10+(.LUM2/256)
     16  7198		       28		      .byte.b	$20+(.LUM3/256)
     17  7199
     18  7199
     19  7199
     20  7199
     21  7199
     22  7199				   .LUM1      SET	.LUM1 + .STEP1
     23  7199				   .LUM2      SET	.LUM2 + .STEP2
     24  7199				   .LUM3      SET	.LUM3 + .STEP3
     13  7199					      REPEND
     14  7199		       94		      .byte.b	$90+(.LUM1/256)
     15  719a		       16		      .byte.b	$10+(.LUM2/256)
     16  719b		       28		      .byte.b	$20+(.LUM3/256)
     17  719c
     18  719c
     19  719c
     20  719c
     21  719c
     22  719c				   .LUM1      SET	.LUM1 + .STEP1
     23  719c				   .LUM2      SET	.LUM2 + .STEP2
     24  719c				   .LUM3      SET	.LUM3 + .STEP3
     13  719c					      REPEND
     14  719c		       94		      .byte.b	$90+(.LUM1/256)
     15  719d		       16		      .byte.b	$10+(.LUM2/256)
     16  719e		       28		      .byte.b	$20+(.LUM3/256)
     17  719f
     18  719f
     19  719f
     20  719f
     21  719f
     22  719f				   .LUM1      SET	.LUM1 + .STEP1
     23  719f				   .LUM2      SET	.LUM2 + .STEP2
     24  719f				   .LUM3      SET	.LUM3 + .STEP3
     13  719f					      REPEND
     14  719f		       94		      .byte.b	$90+(.LUM1/256)
     15  71a0		       16		      .byte.b	$10+(.LUM2/256)
     16  71a1		       28		      .byte.b	$20+(.LUM3/256)
     17  71a2
     18  71a2
     19  71a2
     20  71a2
     21  71a2
     22  71a2				   .LUM1      SET	.LUM1 + .STEP1
     23  71a2				   .LUM2      SET	.LUM2 + .STEP2
     24  71a2				   .LUM3      SET	.LUM3 + .STEP3
     13  71a2					      REPEND
     14  71a2		       94		      .byte.b	$90+(.LUM1/256)
     15  71a3		       16		      .byte.b	$10+(.LUM2/256)
     16  71a4		       28		      .byte.b	$20+(.LUM3/256)
     17  71a5
     18  71a5
     19  71a5
     20  71a5
     21  71a5
     22  71a5				   .LUM1      SET	.LUM1 + .STEP1
     23  71a5				   .LUM2      SET	.LUM2 + .STEP2
     24  71a5				   .LUM3      SET	.LUM3 + .STEP3
     13  71a5					      REPEND
     14  71a5		       94		      .byte.b	$90+(.LUM1/256)
     15  71a6		       16		      .byte.b	$10+(.LUM2/256)
     16  71a7		       28		      .byte.b	$20+(.LUM3/256)
     17  71a8
     18  71a8
     19  71a8
     20  71a8
     21  71a8
     22  71a8				   .LUM1      SET	.LUM1 + .STEP1
     23  71a8				   .LUM2      SET	.LUM2 + .STEP2
     24  71a8				   .LUM3      SET	.LUM3 + .STEP3
     13  71a8					      REPEND
     14  71a8		       94		      .byte.b	$90+(.LUM1/256)
     15  71a9		       16		      .byte.b	$10+(.LUM2/256)
     16  71aa		       28		      .byte.b	$20+(.LUM3/256)
     17  71ab
     18  71ab
     19  71ab
     20  71ab
     21  71ab
     22  71ab				   .LUM1      SET	.LUM1 + .STEP1
     23  71ab				   .LUM2      SET	.LUM2 + .STEP2
     24  71ab				   .LUM3      SET	.LUM3 + .STEP3
     13  71ab					      REPEND
     14  71ab		       94		      .byte.b	$90+(.LUM1/256)
     15  71ac		       16		      .byte.b	$10+(.LUM2/256)
     16  71ad		       28		      .byte.b	$20+(.LUM3/256)
     17  71ae
     18  71ae
     19  71ae
     20  71ae
     21  71ae
     22  71ae				   .LUM1      SET	.LUM1 + .STEP1
     23  71ae				   .LUM2      SET	.LUM2 + .STEP2
     24  71ae				   .LUM3      SET	.LUM3 + .STEP3
     13  71ae					      REPEND
     14  71ae		       94		      .byte.b	$90+(.LUM1/256)
     15  71af		       16		      .byte.b	$10+(.LUM2/256)
     16  71b0		       28		      .byte.b	$20+(.LUM3/256)
     17  71b1
     18  71b1
     19  71b1
     20  71b1
     21  71b1
     22  71b1				   .LUM1      SET	.LUM1 + .STEP1
     23  71b1				   .LUM2      SET	.LUM2 + .STEP2
     24  71b1				   .LUM3      SET	.LUM3 + .STEP3
     13  71b1					      REPEND
     14  71b1		       94		      .byte.b	$90+(.LUM1/256)
     15  71b2		       16		      .byte.b	$10+(.LUM2/256)
     16  71b3		       28		      .byte.b	$20+(.LUM3/256)
     17  71b4
     18  71b4
     19  71b4
     20  71b4
     21  71b4
     22  71b4				   .LUM1      SET	.LUM1 + .STEP1
     23  71b4				   .LUM2      SET	.LUM2 + .STEP2
     24  71b4				   .LUM3      SET	.LUM3 + .STEP3
     13  71b4					      REPEND
     14  71b4		       94		      .byte.b	$90+(.LUM1/256)
     15  71b5		       16		      .byte.b	$10+(.LUM2/256)
     16  71b6		       28		      .byte.b	$20+(.LUM3/256)
     17  71b7
     18  71b7
     19  71b7
     20  71b7
     21  71b7
     22  71b7				   .LUM1      SET	.LUM1 + .STEP1
     23  71b7				   .LUM2      SET	.LUM2 + .STEP2
     24  71b7				   .LUM3      SET	.LUM3 + .STEP3
     13  71b7					      REPEND
     14  71b7		       94		      .byte.b	$90+(.LUM1/256)
     15  71b8		       16		      .byte.b	$10+(.LUM2/256)
     16  71b9		       28		      .byte.b	$20+(.LUM3/256)
     17  71ba
     18  71ba
     19  71ba
     20  71ba
     21  71ba
     22  71ba				   .LUM1      SET	.LUM1 + .STEP1
     23  71ba				   .LUM2      SET	.LUM2 + .STEP2
     24  71ba				   .LUM3      SET	.LUM3 + .STEP3
     13  71ba					      REPEND
     14  71ba		       94		      .byte.b	$90+(.LUM1/256)
     15  71bb		       16		      .byte.b	$10+(.LUM2/256)
     16  71bc		       28		      .byte.b	$20+(.LUM3/256)
     17  71bd
     18  71bd
     19  71bd
     20  71bd
     21  71bd
     22  71bd				   .LUM1      SET	.LUM1 + .STEP1
     23  71bd				   .LUM2      SET	.LUM2 + .STEP2
     24  71bd				   .LUM3      SET	.LUM3 + .STEP3
     13  71bd					      REPEND
     14  71bd		       94		      .byte.b	$90+(.LUM1/256)
     15  71be		       16		      .byte.b	$10+(.LUM2/256)
     16  71bf		       28		      .byte.b	$20+(.LUM3/256)
     17  71c0
     18  71c0
     19  71c0
     20  71c0
     21  71c0
     22  71c0				   .LUM1      SET	.LUM1 + .STEP1
     23  71c0				   .LUM2      SET	.LUM2 + .STEP2
     24  71c0				   .LUM3      SET	.LUM3 + .STEP3
     13  71c0					      REPEND
     14  71c0		       94		      .byte.b	$90+(.LUM1/256)
     15  71c1		       16		      .byte.b	$10+(.LUM2/256)
     16  71c2		       28		      .byte.b	$20+(.LUM3/256)
     17  71c3
     18  71c3
     19  71c3
     20  71c3
     21  71c3
     22  71c3				   .LUM1      SET	.LUM1 + .STEP1
     23  71c3				   .LUM2      SET	.LUM2 + .STEP2
     24  71c3				   .LUM3      SET	.LUM3 + .STEP3
     13  71c3					      REPEND
     14  71c3		       94		      .byte.b	$90+(.LUM1/256)
     15  71c4		       16		      .byte.b	$10+(.LUM2/256)
     16  71c5		       28		      .byte.b	$20+(.LUM3/256)
     17  71c6
     18  71c6
     19  71c6
     20  71c6
     21  71c6
     22  71c6				   .LUM1      SET	.LUM1 + .STEP1
     23  71c6				   .LUM2      SET	.LUM2 + .STEP2
     24  71c6				   .LUM3      SET	.LUM3 + .STEP3
     13  71c6					      REPEND
     14  71c6		       94		      .byte.b	$90+(.LUM1/256)
     15  71c7		       16		      .byte.b	$10+(.LUM2/256)
     16  71c8		       28		      .byte.b	$20+(.LUM3/256)
     17  71c9
     18  71c9
     19  71c9
     20  71c9
     21  71c9
     22  71c9				   .LUM1      SET	.LUM1 + .STEP1
     23  71c9				   .LUM2      SET	.LUM2 + .STEP2
     24  71c9				   .LUM3      SET	.LUM3 + .STEP3
     13  71c9					      REPEND
     14  71c9		       94		      .byte.b	$90+(.LUM1/256)
     15  71ca		       16		      .byte.b	$10+(.LUM2/256)
     16  71cb		       28		      .byte.b	$20+(.LUM3/256)
     17  71cc
     18  71cc
     19  71cc
     20  71cc
     21  71cc
     22  71cc				   .LUM1      SET	.LUM1 + .STEP1
     23  71cc				   .LUM2      SET	.LUM2 + .STEP2
     24  71cc				   .LUM3      SET	.LUM3 + .STEP3
     13  71cc					      REPEND
     14  71cc		       94		      .byte.b	$90+(.LUM1/256)
     15  71cd		       16		      .byte.b	$10+(.LUM2/256)
     16  71ce		       28		      .byte.b	$20+(.LUM3/256)
     17  71cf
     18  71cf
     19  71cf
     20  71cf
     21  71cf
     22  71cf				   .LUM1      SET	.LUM1 + .STEP1
     23  71cf				   .LUM2      SET	.LUM2 + .STEP2
     24  71cf				   .LUM3      SET	.LUM3 + .STEP3
     13  71cf					      REPEND
     14  71cf		       94		      .byte.b	$90+(.LUM1/256)
     15  71d0		       16		      .byte.b	$10+(.LUM2/256)
     16  71d1		       28		      .byte.b	$20+(.LUM3/256)
     17  71d2
     18  71d2
     19  71d2
     20  71d2
     21  71d2
     22  71d2				   .LUM1      SET	.LUM1 + .STEP1
     23  71d2				   .LUM2      SET	.LUM2 + .STEP2
     24  71d2				   .LUM3      SET	.LUM3 + .STEP3
     13  71d2					      REPEND
     14  71d2		       94		      .byte.b	$90+(.LUM1/256)
     15  71d3		       16		      .byte.b	$10+(.LUM2/256)
     16  71d4		       28		      .byte.b	$20+(.LUM3/256)
     17  71d5
     18  71d5
     19  71d5
     20  71d5
     21  71d5
     22  71d5				   .LUM1      SET	.LUM1 + .STEP1
     23  71d5				   .LUM2      SET	.LUM2 + .STEP2
     24  71d5				   .LUM3      SET	.LUM3 + .STEP3
     13  71d5					      REPEND
     14  71d5		       94		      .byte.b	$90+(.LUM1/256)
     15  71d6		       16		      .byte.b	$10+(.LUM2/256)
     16  71d7		       28		      .byte.b	$20+(.LUM3/256)
     17  71d8
     18  71d8
     19  71d8
     20  71d8
     21  71d8
     22  71d8				   .LUM1      SET	.LUM1 + .STEP1
     23  71d8				   .LUM2      SET	.LUM2 + .STEP2
     24  71d8				   .LUM3      SET	.LUM3 + .STEP3
     25  71d8					      REPEND
    335  71d8							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    336  71d8
    337  71d8							;    ECHO "PAL LUMS"
    338  71d8							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
      0  71d8				   colr_pal   LUMTABLE	$60, $80, $10, $6,$4,$8,$6,$4,$8
      1  71d8
      2  71d8
      3  71d8
      4  71d8
      5  71d8				   .LUM1      SET	$6*256
      6  71d8				   .LUM2      SET	$4*256
      7  71d8				   .LUM3      SET	$8*256
      8  71d8
      9  71d8		       00 00	   .STEP1     =	(256*($6-$6))/72
     10  71d8		       00 00	   .STEP2     =	(256*($4-$4))/72
     11  71d8		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  71d8
     13  71d8					      REPEAT	72
     14  71d8		       66		      .byte.b	$60+(.LUM1/256)
     15  71d9		       84		      .byte.b	$80+(.LUM2/256)
     16  71da		       18		      .byte.b	$10+(.LUM3/256)
     17  71db
     18  71db
     19  71db
     20  71db
     21  71db
     22  71db				   .LUM1      SET	.LUM1 + .STEP1
     23  71db				   .LUM2      SET	.LUM2 + .STEP2
     24  71db				   .LUM3      SET	.LUM3 + .STEP3
     13  71db					      REPEND
     14  71db		       66		      .byte.b	$60+(.LUM1/256)
     15  71dc		       84		      .byte.b	$80+(.LUM2/256)
     16  71dd		       18		      .byte.b	$10+(.LUM3/256)
     17  71de
     18  71de
     19  71de
     20  71de
     21  71de
     22  71de				   .LUM1      SET	.LUM1 + .STEP1
     23  71de				   .LUM2      SET	.LUM2 + .STEP2
     24  71de				   .LUM3      SET	.LUM3 + .STEP3
     13  71de					      REPEND
     14  71de		       66		      .byte.b	$60+(.LUM1/256)
     15  71df		       84		      .byte.b	$80+(.LUM2/256)
     16  71e0		       18		      .byte.b	$10+(.LUM3/256)
     17  71e1
     18  71e1
     19  71e1
     20  71e1
     21  71e1
     22  71e1				   .LUM1      SET	.LUM1 + .STEP1
     23  71e1				   .LUM2      SET	.LUM2 + .STEP2
     24  71e1				   .LUM3      SET	.LUM3 + .STEP3
     13  71e1					      REPEND
     14  71e1		       66		      .byte.b	$60+(.LUM1/256)
     15  71e2		       84		      .byte.b	$80+(.LUM2/256)
     16  71e3		       18		      .byte.b	$10+(.LUM3/256)
     17  71e4
     18  71e4
     19  71e4
     20  71e4
     21  71e4
     22  71e4				   .LUM1      SET	.LUM1 + .STEP1
     23  71e4				   .LUM2      SET	.LUM2 + .STEP2
     24  71e4				   .LUM3      SET	.LUM3 + .STEP3
     13  71e4					      REPEND
     14  71e4		       66		      .byte.b	$60+(.LUM1/256)
     15  71e5		       84		      .byte.b	$80+(.LUM2/256)
     16  71e6		       18		      .byte.b	$10+(.LUM3/256)
     17  71e7
     18  71e7
     19  71e7
     20  71e7
     21  71e7
     22  71e7				   .LUM1      SET	.LUM1 + .STEP1
     23  71e7				   .LUM2      SET	.LUM2 + .STEP2
     24  71e7				   .LUM3      SET	.LUM3 + .STEP3
     13  71e7					      REPEND
     14  71e7		       66		      .byte.b	$60+(.LUM1/256)
     15  71e8		       84		      .byte.b	$80+(.LUM2/256)
     16  71e9		       18		      .byte.b	$10+(.LUM3/256)
     17  71ea
     18  71ea
     19  71ea
     20  71ea
     21  71ea
     22  71ea				   .LUM1      SET	.LUM1 + .STEP1
     23  71ea				   .LUM2      SET	.LUM2 + .STEP2
     24  71ea				   .LUM3      SET	.LUM3 + .STEP3
     13  71ea					      REPEND
     14  71ea		       66		      .byte.b	$60+(.LUM1/256)
     15  71eb		       84		      .byte.b	$80+(.LUM2/256)
     16  71ec		       18		      .byte.b	$10+(.LUM3/256)
     17  71ed
     18  71ed
     19  71ed
     20  71ed
     21  71ed
     22  71ed				   .LUM1      SET	.LUM1 + .STEP1
     23  71ed				   .LUM2      SET	.LUM2 + .STEP2
     24  71ed				   .LUM3      SET	.LUM3 + .STEP3
     13  71ed					      REPEND
     14  71ed		       66		      .byte.b	$60+(.LUM1/256)
     15  71ee		       84		      .byte.b	$80+(.LUM2/256)
     16  71ef		       18		      .byte.b	$10+(.LUM3/256)
     17  71f0
     18  71f0
     19  71f0
     20  71f0
     21  71f0
     22  71f0				   .LUM1      SET	.LUM1 + .STEP1
     23  71f0				   .LUM2      SET	.LUM2 + .STEP2
     24  71f0				   .LUM3      SET	.LUM3 + .STEP3
     13  71f0					      REPEND
     14  71f0		       66		      .byte.b	$60+(.LUM1/256)
     15  71f1		       84		      .byte.b	$80+(.LUM2/256)
     16  71f2		       18		      .byte.b	$10+(.LUM3/256)
     17  71f3
     18  71f3
     19  71f3
     20  71f3
     21  71f3
     22  71f3				   .LUM1      SET	.LUM1 + .STEP1
     23  71f3				   .LUM2      SET	.LUM2 + .STEP2
     24  71f3				   .LUM3      SET	.LUM3 + .STEP3
     13  71f3					      REPEND
     14  71f3		       66		      .byte.b	$60+(.LUM1/256)
     15  71f4		       84		      .byte.b	$80+(.LUM2/256)
     16  71f5		       18		      .byte.b	$10+(.LUM3/256)
     17  71f6
     18  71f6
     19  71f6
     20  71f6
     21  71f6
     22  71f6				   .LUM1      SET	.LUM1 + .STEP1
     23  71f6				   .LUM2      SET	.LUM2 + .STEP2
     24  71f6				   .LUM3      SET	.LUM3 + .STEP3
     13  71f6					      REPEND
     14  71f6		       66		      .byte.b	$60+(.LUM1/256)
     15  71f7		       84		      .byte.b	$80+(.LUM2/256)
     16  71f8		       18		      .byte.b	$10+(.LUM3/256)
     17  71f9
     18  71f9
     19  71f9
     20  71f9
     21  71f9
     22  71f9				   .LUM1      SET	.LUM1 + .STEP1
     23  71f9				   .LUM2      SET	.LUM2 + .STEP2
     24  71f9				   .LUM3      SET	.LUM3 + .STEP3
     13  71f9					      REPEND
     14  71f9		       66		      .byte.b	$60+(.LUM1/256)
     15  71fa		       84		      .byte.b	$80+(.LUM2/256)
     16  71fb		       18		      .byte.b	$10+(.LUM3/256)
     17  71fc
     18  71fc
     19  71fc
     20  71fc
     21  71fc
     22  71fc				   .LUM1      SET	.LUM1 + .STEP1
     23  71fc				   .LUM2      SET	.LUM2 + .STEP2
     24  71fc				   .LUM3      SET	.LUM3 + .STEP3
     13  71fc					      REPEND
     14  71fc		       66		      .byte.b	$60+(.LUM1/256)
     15  71fd		       84		      .byte.b	$80+(.LUM2/256)
     16  71fe		       18		      .byte.b	$10+(.LUM3/256)
     17  71ff
     18  71ff
     19  71ff
     20  71ff
     21  71ff
     22  71ff				   .LUM1      SET	.LUM1 + .STEP1
     23  71ff				   .LUM2      SET	.LUM2 + .STEP2
     24  71ff				   .LUM3      SET	.LUM3 + .STEP3
     13  71ff					      REPEND
     14  71ff		       66		      .byte.b	$60+(.LUM1/256)
     15  7200		       84		      .byte.b	$80+(.LUM2/256)
     16  7201		       18		      .byte.b	$10+(.LUM3/256)
     17  7202
     18  7202
     19  7202
     20  7202
     21  7202
     22  7202				   .LUM1      SET	.LUM1 + .STEP1
     23  7202				   .LUM2      SET	.LUM2 + .STEP2
     24  7202				   .LUM3      SET	.LUM3 + .STEP3
     13  7202					      REPEND
     14  7202		       66		      .byte.b	$60+(.LUM1/256)
     15  7203		       84		      .byte.b	$80+(.LUM2/256)
     16  7204		       18		      .byte.b	$10+(.LUM3/256)
     17  7205
     18  7205
     19  7205
     20  7205
     21  7205
     22  7205				   .LUM1      SET	.LUM1 + .STEP1
     23  7205				   .LUM2      SET	.LUM2 + .STEP2
     24  7205				   .LUM3      SET	.LUM3 + .STEP3
     13  7205					      REPEND
     14  7205		       66		      .byte.b	$60+(.LUM1/256)
     15  7206		       84		      .byte.b	$80+(.LUM2/256)
     16  7207		       18		      .byte.b	$10+(.LUM3/256)
     17  7208
     18  7208
     19  7208
     20  7208
     21  7208
     22  7208				   .LUM1      SET	.LUM1 + .STEP1
     23  7208				   .LUM2      SET	.LUM2 + .STEP2
     24  7208				   .LUM3      SET	.LUM3 + .STEP3
     13  7208					      REPEND
     14  7208		       66		      .byte.b	$60+(.LUM1/256)
     15  7209		       84		      .byte.b	$80+(.LUM2/256)
     16  720a		       18		      .byte.b	$10+(.LUM3/256)
     17  720b
     18  720b
     19  720b
     20  720b
     21  720b
     22  720b				   .LUM1      SET	.LUM1 + .STEP1
     23  720b				   .LUM2      SET	.LUM2 + .STEP2
     24  720b				   .LUM3      SET	.LUM3 + .STEP3
     13  720b					      REPEND
     14  720b		       66		      .byte.b	$60+(.LUM1/256)
     15  720c		       84		      .byte.b	$80+(.LUM2/256)
     16  720d		       18		      .byte.b	$10+(.LUM3/256)
     17  720e
     18  720e
     19  720e
     20  720e
     21  720e
     22  720e				   .LUM1      SET	.LUM1 + .STEP1
     23  720e				   .LUM2      SET	.LUM2 + .STEP2
     24  720e				   .LUM3      SET	.LUM3 + .STEP3
     13  720e					      REPEND
     14  720e		       66		      .byte.b	$60+(.LUM1/256)
     15  720f		       84		      .byte.b	$80+(.LUM2/256)
     16  7210		       18		      .byte.b	$10+(.LUM3/256)
     17  7211
     18  7211
     19  7211
     20  7211
     21  7211
     22  7211				   .LUM1      SET	.LUM1 + .STEP1
     23  7211				   .LUM2      SET	.LUM2 + .STEP2
     24  7211				   .LUM3      SET	.LUM3 + .STEP3
     13  7211					      REPEND
     14  7211		       66		      .byte.b	$60+(.LUM1/256)
     15  7212		       84		      .byte.b	$80+(.LUM2/256)
     16  7213		       18		      .byte.b	$10+(.LUM3/256)
     17  7214
     18  7214
     19  7214
     20  7214
     21  7214
     22  7214				   .LUM1      SET	.LUM1 + .STEP1
     23  7214				   .LUM2      SET	.LUM2 + .STEP2
     24  7214				   .LUM3      SET	.LUM3 + .STEP3
     13  7214					      REPEND
     14  7214		       66		      .byte.b	$60+(.LUM1/256)
     15  7215		       84		      .byte.b	$80+(.LUM2/256)
     16  7216		       18		      .byte.b	$10+(.LUM3/256)
     17  7217
     18  7217
     19  7217
     20  7217
     21  7217
     22  7217				   .LUM1      SET	.LUM1 + .STEP1
     23  7217				   .LUM2      SET	.LUM2 + .STEP2
     24  7217				   .LUM3      SET	.LUM3 + .STEP3
     13  7217					      REPEND
     14  7217		       66		      .byte.b	$60+(.LUM1/256)
     15  7218		       84		      .byte.b	$80+(.LUM2/256)
     16  7219		       18		      .byte.b	$10+(.LUM3/256)
     17  721a
     18  721a
     19  721a
     20  721a
     21  721a
     22  721a				   .LUM1      SET	.LUM1 + .STEP1
     23  721a				   .LUM2      SET	.LUM2 + .STEP2
     24  721a				   .LUM3      SET	.LUM3 + .STEP3
     13  721a					      REPEND
     14  721a		       66		      .byte.b	$60+(.LUM1/256)
     15  721b		       84		      .byte.b	$80+(.LUM2/256)
     16  721c		       18		      .byte.b	$10+(.LUM3/256)
     17  721d
     18  721d
     19  721d
     20  721d
     21  721d
     22  721d				   .LUM1      SET	.LUM1 + .STEP1
     23  721d				   .LUM2      SET	.LUM2 + .STEP2
     24  721d				   .LUM3      SET	.LUM3 + .STEP3
     13  721d					      REPEND
     14  721d		       66		      .byte.b	$60+(.LUM1/256)
     15  721e		       84		      .byte.b	$80+(.LUM2/256)
     16  721f		       18		      .byte.b	$10+(.LUM3/256)
     17  7220
     18  7220
     19  7220
     20  7220
     21  7220
     22  7220				   .LUM1      SET	.LUM1 + .STEP1
     23  7220				   .LUM2      SET	.LUM2 + .STEP2
     24  7220				   .LUM3      SET	.LUM3 + .STEP3
     13  7220					      REPEND
     14  7220		       66		      .byte.b	$60+(.LUM1/256)
     15  7221		       84		      .byte.b	$80+(.LUM2/256)
     16  7222		       18		      .byte.b	$10+(.LUM3/256)
     17  7223
     18  7223
     19  7223
     20  7223
     21  7223
     22  7223				   .LUM1      SET	.LUM1 + .STEP1
     23  7223				   .LUM2      SET	.LUM2 + .STEP2
     24  7223				   .LUM3      SET	.LUM3 + .STEP3
     13  7223					      REPEND
     14  7223		       66		      .byte.b	$60+(.LUM1/256)
     15  7224		       84		      .byte.b	$80+(.LUM2/256)
     16  7225		       18		      .byte.b	$10+(.LUM3/256)
     17  7226
     18  7226
     19  7226
     20  7226
     21  7226
     22  7226				   .LUM1      SET	.LUM1 + .STEP1
     23  7226				   .LUM2      SET	.LUM2 + .STEP2
     24  7226				   .LUM3      SET	.LUM3 + .STEP3
     13  7226					      REPEND
     14  7226		       66		      .byte.b	$60+(.LUM1/256)
     15  7227		       84		      .byte.b	$80+(.LUM2/256)
     16  7228		       18		      .byte.b	$10+(.LUM3/256)
     17  7229
     18  7229
     19  7229
     20  7229
     21  7229
     22  7229				   .LUM1      SET	.LUM1 + .STEP1
     23  7229				   .LUM2      SET	.LUM2 + .STEP2
     24  7229				   .LUM3      SET	.LUM3 + .STEP3
     13  7229					      REPEND
     14  7229		       66		      .byte.b	$60+(.LUM1/256)
     15  722a		       84		      .byte.b	$80+(.LUM2/256)
     16  722b		       18		      .byte.b	$10+(.LUM3/256)
     17  722c
     18  722c
     19  722c
     20  722c
     21  722c
     22  722c				   .LUM1      SET	.LUM1 + .STEP1
     23  722c				   .LUM2      SET	.LUM2 + .STEP2
     24  722c				   .LUM3      SET	.LUM3 + .STEP3
     13  722c					      REPEND
     14  722c		       66		      .byte.b	$60+(.LUM1/256)
     15  722d		       84		      .byte.b	$80+(.LUM2/256)
     16  722e		       18		      .byte.b	$10+(.LUM3/256)
     17  722f
     18  722f
     19  722f
     20  722f
     21  722f
     22  722f				   .LUM1      SET	.LUM1 + .STEP1
     23  722f				   .LUM2      SET	.LUM2 + .STEP2
     24  722f				   .LUM3      SET	.LUM3 + .STEP3
     13  722f					      REPEND
     14  722f		       66		      .byte.b	$60+(.LUM1/256)
     15  7230		       84		      .byte.b	$80+(.LUM2/256)
     16  7231		       18		      .byte.b	$10+(.LUM3/256)
     17  7232
     18  7232
     19  7232
     20  7232
     21  7232
     22  7232				   .LUM1      SET	.LUM1 + .STEP1
     23  7232				   .LUM2      SET	.LUM2 + .STEP2
     24  7232				   .LUM3      SET	.LUM3 + .STEP3
     13  7232					      REPEND
     14  7232		       66		      .byte.b	$60+(.LUM1/256)
     15  7233		       84		      .byte.b	$80+(.LUM2/256)
     16  7234		       18		      .byte.b	$10+(.LUM3/256)
     17  7235
     18  7235
     19  7235
     20  7235
     21  7235
     22  7235				   .LUM1      SET	.LUM1 + .STEP1
     23  7235				   .LUM2      SET	.LUM2 + .STEP2
     24  7235				   .LUM3      SET	.LUM3 + .STEP3
     13  7235					      REPEND
     14  7235		       66		      .byte.b	$60+(.LUM1/256)
     15  7236		       84		      .byte.b	$80+(.LUM2/256)
     16  7237		       18		      .byte.b	$10+(.LUM3/256)
     17  7238
     18  7238
     19  7238
     20  7238
     21  7238
     22  7238				   .LUM1      SET	.LUM1 + .STEP1
     23  7238				   .LUM2      SET	.LUM2 + .STEP2
     24  7238				   .LUM3      SET	.LUM3 + .STEP3
     13  7238					      REPEND
     14  7238		       66		      .byte.b	$60+(.LUM1/256)
     15  7239		       84		      .byte.b	$80+(.LUM2/256)
     16  723a		       18		      .byte.b	$10+(.LUM3/256)
     17  723b
     18  723b
     19  723b
     20  723b
     21  723b
     22  723b				   .LUM1      SET	.LUM1 + .STEP1
     23  723b				   .LUM2      SET	.LUM2 + .STEP2
     24  723b				   .LUM3      SET	.LUM3 + .STEP3
     13  723b					      REPEND
     14  723b		       66		      .byte.b	$60+(.LUM1/256)
     15  723c		       84		      .byte.b	$80+(.LUM2/256)
     16  723d		       18		      .byte.b	$10+(.LUM3/256)
     17  723e
     18  723e
     19  723e
     20  723e
     21  723e
     22  723e				   .LUM1      SET	.LUM1 + .STEP1
     23  723e				   .LUM2      SET	.LUM2 + .STEP2
     24  723e				   .LUM3      SET	.LUM3 + .STEP3
     13  723e					      REPEND
     14  723e		       66		      .byte.b	$60+(.LUM1/256)
     15  723f		       84		      .byte.b	$80+(.LUM2/256)
     16  7240		       18		      .byte.b	$10+(.LUM3/256)
     17  7241
     18  7241
     19  7241
     20  7241
     21  7241
     22  7241				   .LUM1      SET	.LUM1 + .STEP1
     23  7241				   .LUM2      SET	.LUM2 + .STEP2
     24  7241				   .LUM3      SET	.LUM3 + .STEP3
     13  7241					      REPEND
     14  7241		       66		      .byte.b	$60+(.LUM1/256)
     15  7242		       84		      .byte.b	$80+(.LUM2/256)
     16  7243		       18		      .byte.b	$10+(.LUM3/256)
     17  7244
     18  7244
     19  7244
     20  7244
     21  7244
     22  7244				   .LUM1      SET	.LUM1 + .STEP1
     23  7244				   .LUM2      SET	.LUM2 + .STEP2
     24  7244				   .LUM3      SET	.LUM3 + .STEP3
     13  7244					      REPEND
     14  7244		       66		      .byte.b	$60+(.LUM1/256)
     15  7245		       84		      .byte.b	$80+(.LUM2/256)
     16  7246		       18		      .byte.b	$10+(.LUM3/256)
     17  7247
     18  7247
     19  7247
     20  7247
     21  7247
     22  7247				   .LUM1      SET	.LUM1 + .STEP1
     23  7247				   .LUM2      SET	.LUM2 + .STEP2
     24  7247				   .LUM3      SET	.LUM3 + .STEP3
     13  7247					      REPEND
     14  7247		       66		      .byte.b	$60+(.LUM1/256)
     15  7248		       84		      .byte.b	$80+(.LUM2/256)
     16  7249		       18		      .byte.b	$10+(.LUM3/256)
     17  724a
     18  724a
     19  724a
     20  724a
     21  724a
     22  724a				   .LUM1      SET	.LUM1 + .STEP1
     23  724a				   .LUM2      SET	.LUM2 + .STEP2
     24  724a				   .LUM3      SET	.LUM3 + .STEP3
     13  724a					      REPEND
     14  724a		       66		      .byte.b	$60+(.LUM1/256)
     15  724b		       84		      .byte.b	$80+(.LUM2/256)
     16  724c		       18		      .byte.b	$10+(.LUM3/256)
     17  724d
     18  724d
     19  724d
     20  724d
     21  724d
     22  724d				   .LUM1      SET	.LUM1 + .STEP1
     23  724d				   .LUM2      SET	.LUM2 + .STEP2
     24  724d				   .LUM3      SET	.LUM3 + .STEP3
     13  724d					      REPEND
     14  724d		       66		      .byte.b	$60+(.LUM1/256)
     15  724e		       84		      .byte.b	$80+(.LUM2/256)
     16  724f		       18		      .byte.b	$10+(.LUM3/256)
     17  7250
     18  7250
     19  7250
     20  7250
     21  7250
     22  7250				   .LUM1      SET	.LUM1 + .STEP1
     23  7250				   .LUM2      SET	.LUM2 + .STEP2
     24  7250				   .LUM3      SET	.LUM3 + .STEP3
     13  7250					      REPEND
     14  7250		       66		      .byte.b	$60+(.LUM1/256)
     15  7251		       84		      .byte.b	$80+(.LUM2/256)
     16  7252		       18		      .byte.b	$10+(.LUM3/256)
     17  7253
     18  7253
     19  7253
     20  7253
     21  7253
     22  7253				   .LUM1      SET	.LUM1 + .STEP1
     23  7253				   .LUM2      SET	.LUM2 + .STEP2
     24  7253				   .LUM3      SET	.LUM3 + .STEP3
     13  7253					      REPEND
     14  7253		       66		      .byte.b	$60+(.LUM1/256)
     15  7254		       84		      .byte.b	$80+(.LUM2/256)
     16  7255		       18		      .byte.b	$10+(.LUM3/256)
     17  7256
     18  7256
     19  7256
     20  7256
     21  7256
     22  7256				   .LUM1      SET	.LUM1 + .STEP1
     23  7256				   .LUM2      SET	.LUM2 + .STEP2
     24  7256				   .LUM3      SET	.LUM3 + .STEP3
     13  7256					      REPEND
     14  7256		       66		      .byte.b	$60+(.LUM1/256)
     15  7257		       84		      .byte.b	$80+(.LUM2/256)
     16  7258		       18		      .byte.b	$10+(.LUM3/256)
     17  7259
     18  7259
     19  7259
     20  7259
     21  7259
     22  7259				   .LUM1      SET	.LUM1 + .STEP1
     23  7259				   .LUM2      SET	.LUM2 + .STEP2
     24  7259				   .LUM3      SET	.LUM3 + .STEP3
     13  7259					      REPEND
     14  7259		       66		      .byte.b	$60+(.LUM1/256)
     15  725a		       84		      .byte.b	$80+(.LUM2/256)
     16  725b		       18		      .byte.b	$10+(.LUM3/256)
     17  725c
     18  725c
     19  725c
     20  725c
     21  725c
     22  725c				   .LUM1      SET	.LUM1 + .STEP1
     23  725c				   .LUM2      SET	.LUM2 + .STEP2
     24  725c				   .LUM3      SET	.LUM3 + .STEP3
     13  725c					      REPEND
     14  725c		       66		      .byte.b	$60+(.LUM1/256)
     15  725d		       84		      .byte.b	$80+(.LUM2/256)
     16  725e		       18		      .byte.b	$10+(.LUM3/256)
     17  725f
     18  725f
     19  725f
     20  725f
     21  725f
     22  725f				   .LUM1      SET	.LUM1 + .STEP1
     23  725f				   .LUM2      SET	.LUM2 + .STEP2
     24  725f				   .LUM3      SET	.LUM3 + .STEP3
     13  725f					      REPEND
     14  725f		       66		      .byte.b	$60+(.LUM1/256)
     15  7260		       84		      .byte.b	$80+(.LUM2/256)
     16  7261		       18		      .byte.b	$10+(.LUM3/256)
     17  7262
     18  7262
     19  7262
     20  7262
     21  7262
     22  7262				   .LUM1      SET	.LUM1 + .STEP1
     23  7262				   .LUM2      SET	.LUM2 + .STEP2
     24  7262				   .LUM3      SET	.LUM3 + .STEP3
     13  7262					      REPEND
     14  7262		       66		      .byte.b	$60+(.LUM1/256)
     15  7263		       84		      .byte.b	$80+(.LUM2/256)
     16  7264		       18		      .byte.b	$10+(.LUM3/256)
     17  7265
     18  7265
     19  7265
     20  7265
     21  7265
     22  7265				   .LUM1      SET	.LUM1 + .STEP1
     23  7265				   .LUM2      SET	.LUM2 + .STEP2
     24  7265				   .LUM3      SET	.LUM3 + .STEP3
     13  7265					      REPEND
     14  7265		       66		      .byte.b	$60+(.LUM1/256)
     15  7266		       84		      .byte.b	$80+(.LUM2/256)
     16  7267		       18		      .byte.b	$10+(.LUM3/256)
     17  7268
     18  7268
     19  7268
     20  7268
     21  7268
     22  7268				   .LUM1      SET	.LUM1 + .STEP1
     23  7268				   .LUM2      SET	.LUM2 + .STEP2
     24  7268				   .LUM3      SET	.LUM3 + .STEP3
     13  7268					      REPEND
     14  7268		       66		      .byte.b	$60+(.LUM1/256)
     15  7269		       84		      .byte.b	$80+(.LUM2/256)
     16  726a		       18		      .byte.b	$10+(.LUM3/256)
     17  726b
     18  726b
     19  726b
     20  726b
     21  726b
     22  726b				   .LUM1      SET	.LUM1 + .STEP1
     23  726b				   .LUM2      SET	.LUM2 + .STEP2
     24  726b				   .LUM3      SET	.LUM3 + .STEP3
     13  726b					      REPEND
     14  726b		       66		      .byte.b	$60+(.LUM1/256)
     15  726c		       84		      .byte.b	$80+(.LUM2/256)
     16  726d		       18		      .byte.b	$10+(.LUM3/256)
     17  726e
     18  726e
     19  726e
     20  726e
     21  726e
     22  726e				   .LUM1      SET	.LUM1 + .STEP1
     23  726e				   .LUM2      SET	.LUM2 + .STEP2
     24  726e				   .LUM3      SET	.LUM3 + .STEP3
     13  726e					      REPEND
     14  726e		       66		      .byte.b	$60+(.LUM1/256)
     15  726f		       84		      .byte.b	$80+(.LUM2/256)
     16  7270		       18		      .byte.b	$10+(.LUM3/256)
     17  7271
     18  7271
     19  7271
     20  7271
     21  7271
     22  7271				   .LUM1      SET	.LUM1 + .STEP1
     23  7271				   .LUM2      SET	.LUM2 + .STEP2
     24  7271				   .LUM3      SET	.LUM3 + .STEP3
     13  7271					      REPEND
     14  7271		       66		      .byte.b	$60+(.LUM1/256)
     15  7272		       84		      .byte.b	$80+(.LUM2/256)
     16  7273		       18		      .byte.b	$10+(.LUM3/256)
     17  7274
     18  7274
     19  7274
     20  7274
     21  7274
     22  7274				   .LUM1      SET	.LUM1 + .STEP1
     23  7274				   .LUM2      SET	.LUM2 + .STEP2
     24  7274				   .LUM3      SET	.LUM3 + .STEP3
     13  7274					      REPEND
     14  7274		       66		      .byte.b	$60+(.LUM1/256)
     15  7275		       84		      .byte.b	$80+(.LUM2/256)
     16  7276		       18		      .byte.b	$10+(.LUM3/256)
     17  7277
     18  7277
     19  7277
     20  7277
     21  7277
     22  7277				   .LUM1      SET	.LUM1 + .STEP1
     23  7277				   .LUM2      SET	.LUM2 + .STEP2
     24  7277				   .LUM3      SET	.LUM3 + .STEP3
     13  7277					      REPEND
     14  7277		       66		      .byte.b	$60+(.LUM1/256)
     15  7278		       84		      .byte.b	$80+(.LUM2/256)
     16  7279		       18		      .byte.b	$10+(.LUM3/256)
     17  727a
     18  727a
     19  727a
     20  727a
     21  727a
     22  727a				   .LUM1      SET	.LUM1 + .STEP1
     23  727a				   .LUM2      SET	.LUM2 + .STEP2
     24  727a				   .LUM3      SET	.LUM3 + .STEP3
     13  727a					      REPEND
     14  727a		       66		      .byte.b	$60+(.LUM1/256)
     15  727b		       84		      .byte.b	$80+(.LUM2/256)
     16  727c		       18		      .byte.b	$10+(.LUM3/256)
     17  727d
     18  727d
     19  727d
     20  727d
     21  727d
     22  727d				   .LUM1      SET	.LUM1 + .STEP1
     23  727d				   .LUM2      SET	.LUM2 + .STEP2
     24  727d				   .LUM3      SET	.LUM3 + .STEP3
     13  727d					      REPEND
     14  727d		       66		      .byte.b	$60+(.LUM1/256)
     15  727e		       84		      .byte.b	$80+(.LUM2/256)
     16  727f		       18		      .byte.b	$10+(.LUM3/256)
     17  7280
     18  7280
     19  7280
     20  7280
     21  7280
     22  7280				   .LUM1      SET	.LUM1 + .STEP1
     23  7280				   .LUM2      SET	.LUM2 + .STEP2
     24  7280				   .LUM3      SET	.LUM3 + .STEP3
     13  7280					      REPEND
     14  7280		       66		      .byte.b	$60+(.LUM1/256)
     15  7281		       84		      .byte.b	$80+(.LUM2/256)
     16  7282		       18		      .byte.b	$10+(.LUM3/256)
     17  7283
     18  7283
     19  7283
     20  7283
     21  7283
     22  7283				   .LUM1      SET	.LUM1 + .STEP1
     23  7283				   .LUM2      SET	.LUM2 + .STEP2
     24  7283				   .LUM3      SET	.LUM3 + .STEP3
     13  7283					      REPEND
     14  7283		       66		      .byte.b	$60+(.LUM1/256)
     15  7284		       84		      .byte.b	$80+(.LUM2/256)
     16  7285		       18		      .byte.b	$10+(.LUM3/256)
     17  7286
     18  7286
     19  7286
     20  7286
     21  7286
     22  7286				   .LUM1      SET	.LUM1 + .STEP1
     23  7286				   .LUM2      SET	.LUM2 + .STEP2
     24  7286				   .LUM3      SET	.LUM3 + .STEP3
     13  7286					      REPEND
     14  7286		       66		      .byte.b	$60+(.LUM1/256)
     15  7287		       84		      .byte.b	$80+(.LUM2/256)
     16  7288		       18		      .byte.b	$10+(.LUM3/256)
     17  7289
     18  7289
     19  7289
     20  7289
     21  7289
     22  7289				   .LUM1      SET	.LUM1 + .STEP1
     23  7289				   .LUM2      SET	.LUM2 + .STEP2
     24  7289				   .LUM3      SET	.LUM3 + .STEP3
     13  7289					      REPEND
     14  7289		       66		      .byte.b	$60+(.LUM1/256)
     15  728a		       84		      .byte.b	$80+(.LUM2/256)
     16  728b		       18		      .byte.b	$10+(.LUM3/256)
     17  728c
     18  728c
     19  728c
     20  728c
     21  728c
     22  728c				   .LUM1      SET	.LUM1 + .STEP1
     23  728c				   .LUM2      SET	.LUM2 + .STEP2
     24  728c				   .LUM3      SET	.LUM3 + .STEP3
     13  728c					      REPEND
     14  728c		       66		      .byte.b	$60+(.LUM1/256)
     15  728d		       84		      .byte.b	$80+(.LUM2/256)
     16  728e		       18		      .byte.b	$10+(.LUM3/256)
     17  728f
     18  728f
     19  728f
     20  728f
     21  728f
     22  728f				   .LUM1      SET	.LUM1 + .STEP1
     23  728f				   .LUM2      SET	.LUM2 + .STEP2
     24  728f				   .LUM3      SET	.LUM3 + .STEP3
     13  728f					      REPEND
     14  728f		       66		      .byte.b	$60+(.LUM1/256)
     15  7290		       84		      .byte.b	$80+(.LUM2/256)
     16  7291		       18		      .byte.b	$10+(.LUM3/256)
     17  7292
     18  7292
     19  7292
     20  7292
     21  7292
     22  7292				   .LUM1      SET	.LUM1 + .STEP1
     23  7292				   .LUM2      SET	.LUM2 + .STEP2
     24  7292				   .LUM3      SET	.LUM3 + .STEP3
     13  7292					      REPEND
     14  7292		       66		      .byte.b	$60+(.LUM1/256)
     15  7293		       84		      .byte.b	$80+(.LUM2/256)
     16  7294		       18		      .byte.b	$10+(.LUM3/256)
     17  7295
     18  7295
     19  7295
     20  7295
     21  7295
     22  7295				   .LUM1      SET	.LUM1 + .STEP1
     23  7295				   .LUM2      SET	.LUM2 + .STEP2
     24  7295				   .LUM3      SET	.LUM3 + .STEP3
     13  7295					      REPEND
     14  7295		       66		      .byte.b	$60+(.LUM1/256)
     15  7296		       84		      .byte.b	$80+(.LUM2/256)
     16  7297		       18		      .byte.b	$10+(.LUM3/256)
     17  7298
     18  7298
     19  7298
     20  7298
     21  7298
     22  7298				   .LUM1      SET	.LUM1 + .STEP1
     23  7298				   .LUM2      SET	.LUM2 + .STEP2
     24  7298				   .LUM3      SET	.LUM3 + .STEP3
     13  7298					      REPEND
     14  7298		       66		      .byte.b	$60+(.LUM1/256)
     15  7299		       84		      .byte.b	$80+(.LUM2/256)
     16  729a		       18		      .byte.b	$10+(.LUM3/256)
     17  729b
     18  729b
     19  729b
     20  729b
     21  729b
     22  729b				   .LUM1      SET	.LUM1 + .STEP1
     23  729b				   .LUM2      SET	.LUM2 + .STEP2
     24  729b				   .LUM3      SET	.LUM3 + .STEP3
     13  729b					      REPEND
     14  729b		       66		      .byte.b	$60+(.LUM1/256)
     15  729c		       84		      .byte.b	$80+(.LUM2/256)
     16  729d		       18		      .byte.b	$10+(.LUM3/256)
     17  729e
     18  729e
     19  729e
     20  729e
     21  729e
     22  729e				   .LUM1      SET	.LUM1 + .STEP1
     23  729e				   .LUM2      SET	.LUM2 + .STEP2
     24  729e				   .LUM3      SET	.LUM3 + .STEP3
     13  729e					      REPEND
     14  729e		       66		      .byte.b	$60+(.LUM1/256)
     15  729f		       84		      .byte.b	$80+(.LUM2/256)
     16  72a0		       18		      .byte.b	$10+(.LUM3/256)
     17  72a1
     18  72a1
     19  72a1
     20  72a1
     21  72a1
     22  72a1				   .LUM1      SET	.LUM1 + .STEP1
     23  72a1				   .LUM2      SET	.LUM2 + .STEP2
     24  72a1				   .LUM3      SET	.LUM3 + .STEP3
     13  72a1					      REPEND
     14  72a1		       66		      .byte.b	$60+(.LUM1/256)
     15  72a2		       84		      .byte.b	$80+(.LUM2/256)
     16  72a3		       18		      .byte.b	$10+(.LUM3/256)
     17  72a4
     18  72a4
     19  72a4
     20  72a4
     21  72a4
     22  72a4				   .LUM1      SET	.LUM1 + .STEP1
     23  72a4				   .LUM2      SET	.LUM2 + .STEP2
     24  72a4				   .LUM3      SET	.LUM3 + .STEP3
     13  72a4					      REPEND
     14  72a4		       66		      .byte.b	$60+(.LUM1/256)
     15  72a5		       84		      .byte.b	$80+(.LUM2/256)
     16  72a6		       18		      .byte.b	$10+(.LUM3/256)
     17  72a7
     18  72a7
     19  72a7
     20  72a7
     21  72a7
     22  72a7				   .LUM1      SET	.LUM1 + .STEP1
     23  72a7				   .LUM2      SET	.LUM2 + .STEP2
     24  72a7				   .LUM3      SET	.LUM3 + .STEP3
     13  72a7					      REPEND
     14  72a7		       66		      .byte.b	$60+(.LUM1/256)
     15  72a8		       84		      .byte.b	$80+(.LUM2/256)
     16  72a9		       18		      .byte.b	$10+(.LUM3/256)
     17  72aa
     18  72aa
     19  72aa
     20  72aa
     21  72aa
     22  72aa				   .LUM1      SET	.LUM1 + .STEP1
     23  72aa				   .LUM2      SET	.LUM2 + .STEP2
     24  72aa				   .LUM3      SET	.LUM3 + .STEP3
     13  72aa					      REPEND
     14  72aa		       66		      .byte.b	$60+(.LUM1/256)
     15  72ab		       84		      .byte.b	$80+(.LUM2/256)
     16  72ac		       18		      .byte.b	$10+(.LUM3/256)
     17  72ad
     18  72ad
     19  72ad
     20  72ad
     21  72ad
     22  72ad				   .LUM1      SET	.LUM1 + .STEP1
     23  72ad				   .LUM2      SET	.LUM2 + .STEP2
     24  72ad				   .LUM3      SET	.LUM3 + .STEP3
     13  72ad					      REPEND
     14  72ad		       66		      .byte.b	$60+(.LUM1/256)
     15  72ae		       84		      .byte.b	$80+(.LUM2/256)
     16  72af		       18		      .byte.b	$10+(.LUM3/256)
     17  72b0
     18  72b0
     19  72b0
     20  72b0
     21  72b0
     22  72b0				   .LUM1      SET	.LUM1 + .STEP1
     23  72b0				   .LUM2      SET	.LUM2 + .STEP2
     24  72b0				   .LUM3      SET	.LUM3 + .STEP3
     25  72b0					      REPEND
    340  72b0							;colr_pal	  LUMTABLE $90, $20, $60, $6,$A,$a,$C,$6,$8
    341  72b0
    342  72b0							;    include "pizza.asm"
    343  72b0
      0  72b0					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  72b0		       02 b0	   .TEMP      =	* - _BANK_START
 TITLESCREEN (1K) SIZE =  $2b0 , FREE= $150
      2  72b0					      ECHO	"TITLESCREEN", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  72b0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  72b0				  -	      ECHO	"BANK OVERFLOW @ ", "TITLESCREEN", " size=", * - ORIGIN
      5  72b0				  -	      ERR
      6  72b0					      ENDIF
------- FILE ./chess.asm
------- FILE TitleScreen@2.asm LEVEL 2 PASS 4
      0  72b0					      include	"TitleScreen@2.asm"
      0  72b0					      SLOT	2
      1  72b0				  -	      IF	(2 < 0) || (2 > 3)
      2  72b0				  -	      ECHO	"Illegal bank address/segment location", 2
      3  72b0				  -	      ERR
      4  72b0					      ENDIF
      5  72b0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      6  72b0				   _BANK_SLOT SET	2 * 64
      0  72b0					      ROMBANK	TITLEDATA2
      1  7800 ????				      SEG	TITLEDATA2
      2  7400					      ORG	_ORIGIN
      3  7400					      RORG	_BANK_ADDRESS_ORIGIN
      4  7400				   _BANK_START SET	*
      5  7400				   TITLEDATA2_START SET	*
      6  7400				   _CURRENT_BANK SET	_ORIGIN/1024
      7  7400				   TITLEDATA2 SET	_BANK_SLOT + _CURRENT_BANK
      8  7400				   _ORIGIN    SET	_ORIGIN + 1024
      3  7400
      0  7400					      DEF	TitleData
      1  7400				   SLOT_TitleData SET	_BANK_SLOT
      2  7400				   BANK_TitleData SET	SLOT_TitleData + _CURRENT_BANK
      3  7400				   TitleData
      4  7400				   TEMPORARY_VAR SET	Overlay
      5  7400				   TEMPORARY_OFFSET SET	0
      6  7400				   VAR_BOUNDARY_TitleData SET	TEMPORARY_OFFSET
      7  7400				   FUNCTION_NAME SET	TitleData
------- FILE titleData.asm LEVEL 3 PASS 4
      0  7400					      include	"titleData.asm"
      1  7400				   COL_0
      2  7400		       07		      .byte.b	7	;R (67)
      3  7401		       06		      .byte.b	6	;G
      4  7402		       00		      .byte.b	0	;B
      5  7403		       02		      .byte.b	2	;R (66)
      6  7404		       00		      .byte.b	0	;G
      7  7405		       00		      .byte.b	0	;B
      8  7406		       00		      .byte.b	0	;R (65)
      9  7407		       00		      .byte.b	0	;G
     10  7408		       0b		      .byte.b	11	;B
     11  7409		       00		      .byte.b	0	;R (64)
     12  740a		       00		      .byte.b	0	;G
     13  740b		       00		      .byte.b	0	;B
     14  740c		       00		      .byte.b	0	;R (63)
     15  740d		       00		      .byte.b	0	;G
     16  740e		       0b		      .byte.b	11	;B
     17  740f		       00		      .byte.b	0	;R (62)
     18  7410		       00		      .byte.b	0	;G
     19  7411		       08		      .byte.b	8	;B
     20  7412		       00		      .byte.b	0	;R (61)
     21  7413		       00		      .byte.b	0	;G
     22  7414		       0b		      .byte.b	11	;B
     23  7415		       00		      .byte.b	0	;R (60)
     24  7416		       00		      .byte.b	0	;G
     25  7417		       00		      .byte.b	0	;B
     26  7418		       00		      .byte.b	0	;R (59)
     27  7419		       00		      .byte.b	0	;G
     28  741a		       00		      .byte.b	0	;B
     29  741b		       04		      .byte.b	4	;R (58)
     30  741c		       04		      .byte.b	4	;G
     31  741d		       00		      .byte.b	0	;B
     32  741e		       0f		      .byte.b	15	;R (57)
     33  741f		       00		      .byte.b	0	;G
     34  7420		       00		      .byte.b	0	;B
     35  7421		       0f		      .byte.b	15	;R (56)
     36  7422		       00		      .byte.b	0	;G
     37  7423		       00		      .byte.b	0	;B
     38  7424		       8f		      .byte.b	143	;R (55)
     39  7425		       80		      .byte.b	128	;G
     40  7426		       00		      .byte.b	0	;B
     41  7427		       8f		      .byte.b	143	;R (54)
     42  7428		       00		      .byte.b	0	;G
     43  7429		       00		      .byte.b	0	;B
     44  742a		       cf		      .byte.b	207	;R (53)
     45  742b		       40		      .byte.b	64	;G
     46  742c		       00		      .byte.b	0	;B
     47  742d		       0f		      .byte.b	15	;R (52)
     48  742e		       00		      .byte.b	0	;G
     49  742f		       00		      .byte.b	0	;B
     50  7430		       0f		      .byte.b	15	;R (51)
     51  7431		       00		      .byte.b	0	;G
     52  7432		       00		      .byte.b	0	;B
     53  7433		       0f		      .byte.b	15	;R (50)
     54  7434		       00		      .byte.b	0	;G
     55  7435		       00		      .byte.b	0	;B
     56  7436		       0f		      .byte.b	15	;R (49)
     57  7437		       08		      .byte.b	8	;G
     58  7438		       00		      .byte.b	0	;B
     59  7439		       07		      .byte.b	7	;R (48)
     60  743a		       00		      .byte.b	0	;G
     61  743b		       00		      .byte.b	0	;B
     62  743c		       07		      .byte.b	7	;R (47)
     63  743d		       00		      .byte.b	0	;G
     64  743e		       00		      .byte.b	0	;B
     65  743f		       07		      .byte.b	7	;R (46)
     66  7440		       00		      .byte.b	0	;G
     67  7441		       00		      .byte.b	0	;B
     68  7442		       07		      .byte.b	7	;R (45)
     69  7443		       00		      .byte.b	0	;G
     70  7444		       00		      .byte.b	0	;B
     71  7445		       07		      .byte.b	7	;R (44)
     72  7446		       00		      .byte.b	0	;G
     73  7447		       00		      .byte.b	0	;B
     74  7448		       07		      .byte.b	7	;R (43)
     75  7449		       00		      .byte.b	0	;G
     76  744a		       00		      .byte.b	0	;B
     77  744b		       8f		      .byte.b	143	;R (42)
     78  744c		       88		      .byte.b	136	;G
     79  744d		       00		      .byte.b	0	;B
     80  744e		       cf		      .byte.b	207	;R (41)
     81  744f		       40		      .byte.b	64	;G
     82  7450		       00		      .byte.b	0	;B
     83  7451		       0f		      .byte.b	15	;R (40)
     84  7452		       00		      .byte.b	0	;G
     85  7453		       00		      .byte.b	0	;B
     86  7454		       0f		      .byte.b	15	;R (39)
     87  7455		       00		      .byte.b	0	;G
     88  7456		       00		      .byte.b	0	;B
     89  7457		       0f		      .byte.b	15	;R (38)
     90  7458		       02		      .byte.b	2	;G
     91  7459		       00		      .byte.b	0	;B
     92  745a		       cf		      .byte.b	207	;R (37)
     93  745b		       c0		      .byte.b	192	;G
     94  745c		       00		      .byte.b	0	;B
     95  745d		       ef		      .byte.b	239	;R (36)
     96  745e		       a0		      .byte.b	160	;G
     97  745f		       00		      .byte.b	0	;B
     98  7460		       ef		      .byte.b	239	;R (35)
     99  7461		       ea		      .byte.b	234	;G
    100  7462		       00		      .byte.b	0	;B
    101  7463		       6f		      .byte.b	111	;R (34)
    102  7464		       40		      .byte.b	64	;G
    103  7465		       00		      .byte.b	0	;B
    104  7466		       0f		      .byte.b	15	;R (33)
    105  7467		       0a		      .byte.b	10	;G
    106  7468		       00		      .byte.b	0	;B
    107  7469		       0f		      .byte.b	15	;R (32)
    108  746a		       00		      .byte.b	0	;G
    109  746b		       00		      .byte.b	0	;B
    110  746c		       4f		      .byte.b	79	;R (31)
    111  746d		       41		      .byte.b	65	;G
    112  746e		       00		      .byte.b	0	;B
    113  746f		       67		      .byte.b	103	;R (30)
    114  7470		       63		      .byte.b	99	;G
    115  7471		       08		      .byte.b	8	;B
    116  7472		       6f		      .byte.b	111	;R (29)
    117  7473		       41		      .byte.b	65	;G
    118  7474		       00		      .byte.b	0	;B
    119  7475		       af		      .byte.b	175	;R (28)
    120  7476		       89		      .byte.b	137	;G
    121  7477		       00		      .byte.b	0	;B
    122  7478		       3f		      .byte.b	63	;R (27)
    123  7479		       33		      .byte.b	51	;G
    124  747a		       00		      .byte.b	0	;B
    125  747b		       0f		      .byte.b	15	;R (26)
    126  747c		       01		      .byte.b	1	;G
    127  747d		       00		      .byte.b	0	;B
    128  747e		       cd		      .byte.b	205	;R (25)
    129  747f		       c9		      .byte.b	201	;G
    130  7480		       02		      .byte.b	2	;B
    131  7481		       cf		      .byte.b	207	;R (24)
    132  7482		       81		      .byte.b	129	;G
    133  7483		       00		      .byte.b	0	;B
    134  7484		       ef		      .byte.b	239	;R (23)
    135  7485		       e5		      .byte.b	229	;G
    136  7486		       00		      .byte.b	0	;B
    137  7487		       4f		      .byte.b	79	;R (22)
    138  7488		       01		      .byte.b	1	;G
    139  7489		       00		      .byte.b	0	;B
    140  748a		       4f		      .byte.b	79	;R (21)
    141  748b		       40		      .byte.b	64	;G
    142  748c		       00		      .byte.b	0	;B
    143  748d		       8f		      .byte.b	143	;R (20)
    144  748e		       8e		      .byte.b	142	;G
    145  748f		       00		      .byte.b	0	;B
    146  7490		       87		      .byte.b	135	;R (19)
    147  7491		       84		      .byte.b	132	;G
    148  7492		       00		      .byte.b	0	;B
    149  7493		       87		      .byte.b	135	;R (18)
    150  7494		       04		      .byte.b	4	;G
    151  7495		       00		      .byte.b	0	;B
    152  7496		       8f		      .byte.b	143	;R (17)
    153  7497		       0e		      .byte.b	14	;G
    154  7498		       00		      .byte.b	0	;B
    155  7499		       8a		      .byte.b	138	;R (16)
    156  749a		       8a		      .byte.b	138	;G
    157  749b		       00		      .byte.b	0	;B
    158  749c		       06		      .byte.b	6	;R (15)
    159  749d		       06		      .byte.b	6	;G
    160  749e		       00		      .byte.b	0	;B
    161  749f		       02		      .byte.b	2	;R (14)
    162  74a0		       02		      .byte.b	2	;G
    163  74a1		       00		      .byte.b	0	;B
    164  74a2		       00		      .byte.b	0	;R (13)
    165  74a3		       00		      .byte.b	0	;G
    166  74a4		       00		      .byte.b	0	;B
    167  74a5		       00		      .byte.b	0	;R (12)
    168  74a6		       00		      .byte.b	0	;G
    169  74a7		       00		      .byte.b	0	;B
    170  74a8		       00		      .byte.b	0	;R (11)
    171  74a9		       00		      .byte.b	0	;G
    172  74aa		       00		      .byte.b	0	;B
    173  74ab		       00		      .byte.b	0	;R (10)
    174  74ac		       00		      .byte.b	0	;G
    175  74ad		       00		      .byte.b	0	;B
    176  74ae		       00		      .byte.b	0	;R (9)
    177  74af		       00		      .byte.b	0	;G
    178  74b0		       00		      .byte.b	0	;B
    179  74b1		       00		      .byte.b	0	;R (8)
    180  74b2		       00		      .byte.b	0	;G
    181  74b3		       07		      .byte.b	7	;B
    182  74b4		       00		      .byte.b	0	;R (7)
    183  74b5		       00		      .byte.b	0	;G
    184  74b6		       05		      .byte.b	5	;B
    185  74b7		       00		      .byte.b	0	;R (6)
    186  74b8		       00		      .byte.b	0	;G
    187  74b9		       05		      .byte.b	5	;B
    188  74ba		       00		      .byte.b	0	;R (5)
    189  74bb		       00		      .byte.b	0	;G
    190  74bc		       05		      .byte.b	5	;B
    191  74bd		       00		      .byte.b	0	;R (4)
    192  74be		       00		      .byte.b	0	;G
    193  74bf		       05		      .byte.b	5	;B
    194  74c0		       00		      .byte.b	0	;R (3)
    195  74c1		       00		      .byte.b	0	;G
    196  74c2		       07		      .byte.b	7	;B
    197  74c3		       00		      .byte.b	0	;R (2)
    198  74c4		       00		      .byte.b	0	;G
    199  74c5		       00		      .byte.b	0	;B
    200  74c6		       00		      .byte.b	0	;R (1)
    201  74c7		       00		      .byte.b	0	;G
    202  74c8		       00		      .byte.b	0	;B
    203  74c9		       00		      .byte.b	0	;R (0)
    204  74ca		       00		      .byte.b	0	;G
    205  74cb		       00		      .byte.b	0	;B
    206  74cc				   COL_1
    207  74cc		       00		      .byte.b	0	;R (67)
    208  74cd		       00		      .byte.b	0	;G
    209  74ce		       00		      .byte.b	0	;B
    210  74cf		       00		      .byte.b	0	;R (66)
    211  74d0		       00		      .byte.b	0	;G
    212  74d1		       00		      .byte.b	0	;B
    213  74d2		       04		      .byte.b	4	;R (65)
    214  74d3		       00		      .byte.b	0	;G
    215  74d4		       00		      .byte.b	0	;B
    216  74d5		       1c		      .byte.b	28	;R (64)
    217  74d6		       18		      .byte.b	24	;G
    218  74d7		       01		      .byte.b	1	;B
    219  74d8		       3c		      .byte.b	60	;R (63)
    220  74d9		       30		      .byte.b	48	;G
    221  74da		       01		      .byte.b	1	;B
    222  74db		       1c		      .byte.b	28	;R (62)
    223  74dc		       00		      .byte.b	0	;G
    224  74dd		       01		      .byte.b	1	;B
    225  74de		       1c		      .byte.b	28	;R (61)
    226  74df		       04		      .byte.b	4	;G
    227  74e0		       21		      .byte.b	33	;B
    228  74e1		       1c		      .byte.b	28	;R (60)
    229  74e2		       08		      .byte.b	8	;G
    230  74e3		       01		      .byte.b	1	;B
    231  74e4		       1c		      .byte.b	28	;R (59)
    232  74e5		       00		      .byte.b	0	;G
    233  74e6		       00		      .byte.b	0	;B
    234  74e7		       1b		      .byte.b	27	;R (58)
    235  74e8		       0b		      .byte.b	11	;G
    236  74e9		       04		      .byte.b	4	;B
    237  74ea		       1f		      .byte.b	31	;R (57)
    238  74eb		       1d		      .byte.b	29	;G
    239  74ec		       00		      .byte.b	0	;B
    240  74ed		       df		      .byte.b	223	;R (56)
    241  74ee		       d2		      .byte.b	210	;G
    242  74ef		       20		      .byte.b	32	;B
    243  74f0		       ff		      .byte.b	255	;R (55)
    244  74f1		       3c		      .byte.b	60	;G
    245  74f2		       00		      .byte.b	0	;B
    246  74f3		       ff		      .byte.b	255	;R (54)
    247  74f4		       4f		      .byte.b	79	;G
    248  74f5		       00		      .byte.b	0	;B
    249  74f6		       ff		      .byte.b	255	;R (53)
    250  74f7		       93		      .byte.b	147	;G
    251  74f8		       00		      .byte.b	0	;B
    252  74f9		       1f		      .byte.b	31	;R (52)
    253  74fa		       1f		      .byte.b	31	;G
    254  74fb		       00		      .byte.b	0	;B
    255  74fc		       00		      .byte.b	0	;R (51)
    256  74fd		       00		      .byte.b	0	;G
    257  74fe		       00		      .byte.b	0	;B
    258  74ff		       00		      .byte.b	0	;R (50)
    259  7500		       00		      .byte.b	0	;G
    260  7501		       00		      .byte.b	0	;B
    261  7502		       1a		      .byte.b	26	;R (49)
    262  7503		       1a		      .byte.b	26	;G
    263  7504		       00		      .byte.b	0	;B
    264  7505		       38		      .byte.b	56	;R (48)
    265  7506		       28		      .byte.b	40	;G
    266  7507		       00		      .byte.b	0	;B
    267  7508		       71		      .byte.b	113	;R (47)
    268  7509		       51		      .byte.b	81	;G
    269  750a		       00		      .byte.b	0	;B
    270  750b		       0b		      .byte.b	11	;R (46)
    271  750c		       0b		      .byte.b	11	;G
    272  750d		       00		      .byte.b	0	;B
    273  750e		       03		      .byte.b	3	;R (45)
    274  750f		       03		      .byte.b	3	;G
    275  7510		       00		      .byte.b	0	;B
    276  7511		       ca		      .byte.b	202	;R (44)
    277  7512		       ca		      .byte.b	202	;G
    278  7513		       00		      .byte.b	0	;B
    279  7514		       c8		      .byte.b	200	;R (43)
    280  7515		       c8		      .byte.b	200	;G
    281  7516		       00		      .byte.b	0	;B
    282  7517		       c8		      .byte.b	200	;R (42)
    283  7518		       40		      .byte.b	64	;G
    284  7519		       00		      .byte.b	0	;B
    285  751a		       48		      .byte.b	72	;R (41)
    286  751b		       40		      .byte.b	64	;G
    287  751c		       00		      .byte.b	0	;B
    288  751d		       08		      .byte.b	8	;R (40)
    289  751e		       08		      .byte.b	8	;G
    290  751f		       00		      .byte.b	0	;B
    291  7520		       a0		      .byte.b	160	;R (39)
    292  7521		       a0		      .byte.b	160	;G
    293  7522		       00		      .byte.b	0	;B
    294  7523		       20		      .byte.b	32	;R (38)
    295  7524		       00		      .byte.b	0	;G
    296  7525		       00		      .byte.b	0	;B
    297  7526		       20		      .byte.b	32	;R (37)
    298  7527		       00		      .byte.b	0	;G
    299  7528		       00		      .byte.b	0	;B
    300  7529		       20		      .byte.b	32	;R (36)
    301  752a		       20		      .byte.b	32	;G
    302  752b		       00		      .byte.b	0	;B
    303  752c		       40		      .byte.b	64	;R (35)
    304  752d		       40		      .byte.b	64	;G
    305  752e		       00		      .byte.b	0	;B
    306  752f		       c0		      .byte.b	192	;R (34)
    307  7530		       c0		      .byte.b	192	;G
    308  7531		       00		      .byte.b	0	;B
    309  7532		       40		      .byte.b	64	;R (33)
    310  7533		       00		      .byte.b	0	;G
    311  7534		       00		      .byte.b	0	;B
    312  7535		       40		      .byte.b	64	;R (32)
    313  7536		       40		      .byte.b	64	;G
    314  7537		       00		      .byte.b	0	;B
    315  7538		       00		      .byte.b	0	;R (31)
    316  7539		       00		      .byte.b	0	;G
    317  753a		       00		      .byte.b	0	;B
    318  753b		       80		      .byte.b	128	;R (30)
    319  753c		       80		      .byte.b	128	;G
    320  753d		       00		      .byte.b	0	;B
    321  753e		       c0		      .byte.b	192	;R (29)
    322  753f		       40		      .byte.b	64	;G
    323  7540		       00		      .byte.b	0	;B
    324  7541		       c0		      .byte.b	192	;R (28)
    325  7542		       c0		      .byte.b	192	;G
    326  7543		       00		      .byte.b	0	;B
    327  7544		       40		      .byte.b	64	;R (27)
    328  7545		       40		      .byte.b	64	;G
    329  7546		       00		      .byte.b	0	;B
    330  7547		       00		      .byte.b	0	;R (26)
    331  7548		       00		      .byte.b	0	;G
    332  7549		       00		      .byte.b	0	;B
    333  754a		       00		      .byte.b	0	;R (25)
    334  754b		       00		      .byte.b	0	;G
    335  754c		       00		      .byte.b	0	;B
    336  754d		       60		      .byte.b	96	;R (24)
    337  754e		       20		      .byte.b	32	;G
    338  754f		       00		      .byte.b	0	;B
    339  7550		       60		      .byte.b	96	;R (23)
    340  7551		       60		      .byte.b	96	;G
    341  7552		       00		      .byte.b	0	;B
    342  7553		       00		      .byte.b	0	;R (22)
    343  7554		       00		      .byte.b	0	;G
    344  7555		       00		      .byte.b	0	;B
    345  7556		       a0		      .byte.b	160	;R (21)
    346  7557		       a0		      .byte.b	160	;G
    347  7558		       00		      .byte.b	0	;B
    348  7559		       70		      .byte.b	112	;R (20)
    349  755a		       50		      .byte.b	80	;G
    350  755b		       00		      .byte.b	0	;B
    351  755c		       c0		      .byte.b	192	;R (19)
    352  755d		       c0		      .byte.b	192	;G
    353  755e		       00		      .byte.b	0	;B
    354  755f		       80		      .byte.b	128	;R (18)
    355  7560		       80		      .byte.b	128	;G
    356  7561		       00		      .byte.b	0	;B
    357  7562		       4c		      .byte.b	76	;R (17)
    358  7563		       4c		      .byte.b	76	;G
    359  7564		       00		      .byte.b	0	;B
    360  7565		       5c		      .byte.b	92	;R (16)
    361  7566		       1c		      .byte.b	28	;G
    362  7567		       00		      .byte.b	0	;B
    363  7568		       60		      .byte.b	96	;R (15)
    364  7569		       60		      .byte.b	96	;G
    365  756a		       00		      .byte.b	0	;B
    366  756b		       60		      .byte.b	96	;R (14)
    367  756c		       20		      .byte.b	32	;G
    368  756d		       00		      .byte.b	0	;B
    369  756e		       50		      .byte.b	80	;R (13)
    370  756f		       50		      .byte.b	80	;G
    371  7570		       06		      .byte.b	6	;B
    372  7571		       40		      .byte.b	64	;R (12)
    373  7572		       40		      .byte.b	64	;G
    374  7573		       08		      .byte.b	8	;B
    375  7574		       00		      .byte.b	0	;R (11)
    376  7575		       00		      .byte.b	0	;G
    377  7576		       08		      .byte.b	8	;B
    378  7577		       00		      .byte.b	0	;R (10)
    379  7578		       00		      .byte.b	0	;G
    380  7579		       08		      .byte.b	8	;B
    381  757a		       00		      .byte.b	0	;R (9)
    382  757b		       00		      .byte.b	0	;G
    383  757c		       08		      .byte.b	8	;B
    384  757d		       00		      .byte.b	0	;R (8)
    385  757e		       00		      .byte.b	0	;G
    386  757f		       06		      .byte.b	6	;B
    387  7580		       00		      .byte.b	0	;R (7)
    388  7581		       00		      .byte.b	0	;G
    389  7582		       00		      .byte.b	0	;B
    390  7583		       00		      .byte.b	0	;R (6)
    391  7584		       00		      .byte.b	0	;G
    392  7585		       00		      .byte.b	0	;B
    393  7586		       00		      .byte.b	0	;R (5)
    394  7587		       00		      .byte.b	0	;G
    395  7588		       00		      .byte.b	0	;B
    396  7589		       00		      .byte.b	0	;R (4)
    397  758a		       00		      .byte.b	0	;G
    398  758b		       00		      .byte.b	0	;B
    399  758c		       00		      .byte.b	0	;R (3)
    400  758d		       00		      .byte.b	0	;G
    401  758e		       00		      .byte.b	0	;B
    402  758f		       00		      .byte.b	0	;R (2)
    403  7590		       00		      .byte.b	0	;G
    404  7591		       00		      .byte.b	0	;B
    405  7592		       00		      .byte.b	0	;R (1)
    406  7593		       00		      .byte.b	0	;G
    407  7594		       00		      .byte.b	0	;B
    408  7595		       00		      .byte.b	0	;R (0)
    409  7596		       00		      .byte.b	0	;G
    410  7597		       00		      .byte.b	0	;B
    411  7598				   COL_2
    412  7598		       f0		      .byte.b	240	;R (67)
    413  7599		       f0		      .byte.b	240	;G
    414  759a		       00		      .byte.b	0	;B
    415  759b		       7f		      .byte.b	127	;R (66)
    416  759c		       21		      .byte.b	33	;G
    417  759d		       00		      .byte.b	0	;B
    418  759e		       00		      .byte.b	0	;R (65)
    419  759f		       00		      .byte.b	0	;G
    420  75a0		       a8		      .byte.b	168	;B
    421  75a1		       00		      .byte.b	0	;R (64)
    422  75a2		       00		      .byte.b	0	;G
    423  75a3		       ab		      .byte.b	171	;B
    424  75a4		       00		      .byte.b	0	;R (63)
    425  75a5		       00		      .byte.b	0	;G
    426  75a6		       b8		      .byte.b	184	;B
    427  75a7		       00		      .byte.b	0	;R (62)
    428  75a8		       00		      .byte.b	0	;G
    429  75a9		       a8		      .byte.b	168	;B
    430  75aa		       00		      .byte.b	0	;R (61)
    431  75ab		       00		      .byte.b	0	;G
    432  75ac		       a8		      .byte.b	168	;B
    433  75ad		       00		      .byte.b	0	;R (60)
    434  75ae		       00		      .byte.b	0	;G
    435  75af		       03		      .byte.b	3	;B
    436  75b0		       01		      .byte.b	1	;R (59)
    437  75b1		       01		      .byte.b	1	;G
    438  75b2		       00		      .byte.b	0	;B
    439  75b3		       89		      .byte.b	137	;R (58)
    440  75b4		       89		      .byte.b	137	;G
    441  75b5		       00		      .byte.b	0	;B
    442  75b6		       fd		      .byte.b	253	;R (57)
    443  75b7		       00		      .byte.b	0	;G
    444  75b8		       00		      .byte.b	0	;B
    445  75b9		       fd		      .byte.b	253	;R (56)
    446  75ba		       00		      .byte.b	0	;G
    447  75bb		       00		      .byte.b	0	;B
    448  75bc		       fd		      .byte.b	253	;R (55)
    449  75bd		       00		      .byte.b	0	;G
    450  75be		       00		      .byte.b	0	;B
    451  75bf		       fd		      .byte.b	253	;R (54)
    452  75c0		       00		      .byte.b	0	;G
    453  75c1		       00		      .byte.b	0	;B
    454  75c2		       fd		      .byte.b	253	;R (53)
    455  75c3		       01		      .byte.b	1	;G
    456  75c4		       00		      .byte.b	0	;B
    457  75c5		       fe		      .byte.b	254	;R (52)
    458  75c6		       06		      .byte.b	6	;G
    459  75c7		       00		      .byte.b	0	;B
    460  75c8		       f9		      .byte.b	249	;R (51)
    461  75c9		       09		      .byte.b	9	;G
    462  75ca		       00		      .byte.b	0	;B
    463  75cb		       f8		      .byte.b	248	;R (50)
    464  75cc		       08		      .byte.b	8	;G
    465  75cd		       00		      .byte.b	0	;B
    466  75ce		       f8		      .byte.b	248	;R (49)
    467  75cf		       00		      .byte.b	0	;G
    468  75d0		       00		      .byte.b	0	;B
    469  75d1		       f8		      .byte.b	248	;R (48)
    470  75d2		       00		      .byte.b	0	;G
    471  75d3		       00		      .byte.b	0	;B
    472  75d4		       fc		      .byte.b	252	;R (47)
    473  75d5		       04		      .byte.b	4	;G
    474  75d6		       00		      .byte.b	0	;B
    475  75d7		       fc		      .byte.b	252	;R (46)
    476  75d8		       04		      .byte.b	4	;G
    477  75d9		       00		      .byte.b	0	;B
    478  75da		       fc		      .byte.b	252	;R (45)
    479  75db		       04		      .byte.b	4	;G
    480  75dc		       00		      .byte.b	0	;B
    481  75dd		       fc		      .byte.b	252	;R (44)
    482  75de		       84		      .byte.b	132	;G
    483  75df		       00		      .byte.b	0	;B
    484  75e0		       fc		      .byte.b	252	;R (43)
    485  75e1		       00		      .byte.b	0	;G
    486  75e2		       00		      .byte.b	0	;B
    487  75e3		       fc		      .byte.b	252	;R (42)
    488  75e4		       00		      .byte.b	0	;G
    489  75e5		       00		      .byte.b	0	;B
    490  75e6		       fc		      .byte.b	252	;R (41)
    491  75e7		       00		      .byte.b	0	;G
    492  75e8		       00		      .byte.b	0	;B
    493  75e9		       fc		      .byte.b	252	;R (40)
    494  75ea		       04		      .byte.b	4	;G
    495  75eb		       00		      .byte.b	0	;B
    496  75ec		       f8		      .byte.b	248	;R (39)
    497  75ed		       00		      .byte.b	0	;G
    498  75ee		       00		      .byte.b	0	;B
    499  75ef		       f8		      .byte.b	248	;R (38)
    500  75f0		       00		      .byte.b	0	;G
    501  75f1		       00		      .byte.b	0	;B
    502  75f2		       f8		      .byte.b	248	;R (37)
    503  75f3		       08		      .byte.b	8	;G
    504  75f4		       00		      .byte.b	0	;B
    505  75f5		       f0		      .byte.b	240	;R (36)
    506  75f6		       00		      .byte.b	0	;G
    507  75f7		       00		      .byte.b	0	;B
    508  75f8		       e0		      .byte.b	224	;R (35)
    509  75f9		       20		      .byte.b	32	;G
    510  75fa		       00		      .byte.b	0	;B
    511  75fb		       c0		      .byte.b	192	;R (34)
    512  75fc		       40		      .byte.b	64	;G
    513  75fd		       00		      .byte.b	0	;B
    514  75fe		       00		      .byte.b	0	;R (33)
    515  75ff		       00		      .byte.b	0	;G
    516  7600		       80		      .byte.b	128	;B
    517  7601		       02		      .byte.b	2	;R (32)
    518  7602		       02		      .byte.b	2	;G
    519  7603		       00		      .byte.b	0	;B
    520  7604		       67		      .byte.b	103	;R (31)
    521  7605		       07		      .byte.b	7	;G
    522  7606		       10		      .byte.b	16	;B
    523  7607		       7f		      .byte.b	127	;R (30)
    524  7608		       0a		      .byte.b	10	;G
    525  7609		       80		      .byte.b	128	;B
    526  760a		       ff		      .byte.b	255	;R (29)
    527  760b		       20		      .byte.b	32	;G
    528  760c		       00		      .byte.b	0	;B
    529  760d		       ff		      .byte.b	255	;R (28)
    530  760e		       12		      .byte.b	18	;G
    531  760f		       00		      .byte.b	0	;B
    532  7610		       ff		      .byte.b	255	;R (27)
    533  7611		       44		      .byte.b	68	;G
    534  7612		       00		      .byte.b	0	;B
    535  7613		       fc		      .byte.b	252	;R (26)
    536  7614		       20		      .byte.b	32	;G
    537  7615		       00		      .byte.b	0	;B
    538  7616		       f8		      .byte.b	248	;R (25)
    539  7617		       e8		      .byte.b	232	;G
    540  7618		       00		      .byte.b	0	;B
    541  7619		       b0		      .byte.b	176	;R (24)
    542  761a		       a0		      .byte.b	160	;G
    543  761b		       00		      .byte.b	0	;B
    544  761c		       40		      .byte.b	64	;R (23)
    545  761d		       40		      .byte.b	64	;G
    546  761e		       80		      .byte.b	128	;B
    547  761f		       e0		      .byte.b	224	;R (22)
    548  7620		       00		      .byte.b	0	;G
    549  7621		       00		      .byte.b	0	;B
    550  7622		       b0		      .byte.b	176	;R (21)
    551  7623		       10		      .byte.b	16	;G
    552  7624		       40		      .byte.b	64	;B
    553  7625		       e0		      .byte.b	224	;R (20)
    554  7626		       20		      .byte.b	32	;G
    555  7627		       00		      .byte.b	0	;B
    556  7628		       c0		      .byte.b	192	;R (19)
    557  7629		       c0		      .byte.b	192	;G
    558  762a		       00		      .byte.b	0	;B
    559  762b		       80		      .byte.b	128	;R (18)
    560  762c		       00		      .byte.b	0	;G
    561  762d		       00		      .byte.b	0	;B
    562  762e		       c0		      .byte.b	192	;R (17)
    563  762f		       c0		      .byte.b	192	;G
    564  7630		       00		      .byte.b	0	;B
    565  7631		       00		      .byte.b	0	;R (16)
    566  7632		       00		      .byte.b	0	;G
    567  7633		       00		      .byte.b	0	;B
    568  7634		       00		      .byte.b	0	;R (15)
    569  7635		       00		      .byte.b	0	;G
    570  7636		       00		      .byte.b	0	;B
    571  7637		       00		      .byte.b	0	;R (14)
    572  7638		       00		      .byte.b	0	;G
    573  7639		       00		      .byte.b	0	;B
    574  763a		       00		      .byte.b	0	;R (13)
    575  763b		       00		      .byte.b	0	;G
    576  763c		       00		      .byte.b	0	;B
    577  763d		       00		      .byte.b	0	;R (12)
    578  763e		       00		      .byte.b	0	;G
    579  763f		       00		      .byte.b	0	;B
    580  7640		       00		      .byte.b	0	;R (11)
    581  7641		       00		      .byte.b	0	;G
    582  7642		       00		      .byte.b	0	;B
    583  7643		       00		      .byte.b	0	;R (10)
    584  7644		       00		      .byte.b	0	;G
    585  7645		       07		      .byte.b	7	;B
    586  7646		       00		      .byte.b	0	;R (9)
    587  7647		       00		      .byte.b	0	;G
    588  7648		       05		      .byte.b	5	;B
    589  7649		       00		      .byte.b	0	;R (8)
    590  764a		       00		      .byte.b	0	;G
    591  764b		       55		      .byte.b	85	;B
    592  764c		       00		      .byte.b	0	;R (7)
    593  764d		       00		      .byte.b	0	;G
    594  764e		       55		      .byte.b	85	;B
    595  764f		       00		      .byte.b	0	;R (6)
    596  7650		       00		      .byte.b	0	;G
    597  7651		       35		      .byte.b	53	;B
    598  7652		       00		      .byte.b	0	;R (5)
    599  7653		       00		      .byte.b	0	;G
    600  7654		       57		      .byte.b	87	;B
    601  7655		       00		      .byte.b	0	;R (4)
    602  7656		       00		      .byte.b	0	;G
    603  7657		       50		      .byte.b	80	;B
    604  7658		       00		      .byte.b	0	;R (3)
    605  7659		       00		      .byte.b	0	;G
    606  765a		       30		      .byte.b	48	;B
    607  765b		       00		      .byte.b	0	;R (2)
    608  765c		       00		      .byte.b	0	;G
    609  765d		       00		      .byte.b	0	;B
    610  765e		       00		      .byte.b	0	;R (1)
    611  765f		       00		      .byte.b	0	;G
    612  7660		       00		      .byte.b	0	;B
    613  7661		       00		      .byte.b	0	;R (0)
    614  7662		       00		      .byte.b	0	;G
    615  7663		       00		      .byte.b	0	;B
    616  7664				   COL_3
    617  7664		       80		      .byte.b	128	;R (67)
    618  7665		       80		      .byte.b	128	;G
    619  7666		       00		      .byte.b	0	;B
    620  7667		       78		      .byte.b	120	;R (66)
    621  7668		       10		      .byte.b	16	;G
    622  7669		       00		      .byte.b	0	;B
    623  766a		       02		      .byte.b	2	;R (65)
    624  766b		       02		      .byte.b	2	;G
    625  766c		       c0		      .byte.b	192	;B
    626  766d		       03		      .byte.b	3	;R (64)
    627  766e		       00		      .byte.b	0	;G
    628  766f		       5c		      .byte.b	92	;B
    629  7670		       01		      .byte.b	1	;R (63)
    630  7671		       00		      .byte.b	0	;G
    631  7672		       c4		      .byte.b	196	;B
    632  7673		       01		      .byte.b	1	;R (62)
    633  7674		       00		      .byte.b	0	;G
    634  7675		       1c		      .byte.b	28	;B
    635  7676		       01		      .byte.b	1	;R (61)
    636  7677		       00		      .byte.b	0	;G
    637  7678		       d0		      .byte.b	208	;B
    638  7679		       01		      .byte.b	1	;R (60)
    639  767a		       00		      .byte.b	0	;G
    640  767b		       1c		      .byte.b	28	;B
    641  767c		       01		      .byte.b	1	;R (59)
    642  767d		       00		      .byte.b	0	;G
    643  767e		       00		      .byte.b	0	;B
    644  767f		       1f		      .byte.b	31	;R (58)
    645  7680		       1f		      .byte.b	31	;G
    646  7681		       00		      .byte.b	0	;B
    647  7682		       df		      .byte.b	223	;R (57)
    648  7683		       53		      .byte.b	83	;G
    649  7684		       00		      .byte.b	0	;B
    650  7685		       df		      .byte.b	223	;R (56)
    651  7686		       14		      .byte.b	20	;G
    652  7687		       00		      .byte.b	0	;B
    653  7688		       df		      .byte.b	223	;R (55)
    654  7689		       13		      .byte.b	19	;G
    655  768a		       00		      .byte.b	0	;B
    656  768b		       df		      .byte.b	223	;R (54)
    657  768c		       1f		      .byte.b	31	;G
    658  768d		       00		      .byte.b	0	;B
    659  768e		       cf		      .byte.b	207	;R (53)
    660  768f		       4e		      .byte.b	78	;G
    661  7690		       00		      .byte.b	0	;B
    662  7691		       ef		      .byte.b	239	;R (52)
    663  7692		       6f		      .byte.b	111	;G
    664  7693		       00		      .byte.b	0	;B
    665  7694		       90		      .byte.b	144	;R (51)
    666  7695		       10		      .byte.b	16	;G
    667  7696		       00		      .byte.b	0	;B
    668  7697		       88		      .byte.b	136	;R (50)
    669  7698		       88		      .byte.b	136	;G
    670  7699		       00		      .byte.b	0	;B
    671  769a		       01		      .byte.b	1	;R (49)
    672  769b		       01		      .byte.b	1	;G
    673  769c		       00		      .byte.b	0	;B
    674  769d		       03		      .byte.b	3	;R (48)
    675  769e		       03		      .byte.b	3	;G
    676  769f		       00		      .byte.b	0	;B
    677  76a0		       09		      .byte.b	9	;R (47)
    678  76a1		       09		      .byte.b	9	;G
    679  76a2		       00		      .byte.b	0	;B
    680  76a3		       08		      .byte.b	8	;R (46)
    681  76a4		       08		      .byte.b	8	;G
    682  76a5		       00		      .byte.b	0	;B
    683  76a6		       0c		      .byte.b	12	;R (45)
    684  76a7		       0c		      .byte.b	12	;G
    685  76a8		       00		      .byte.b	0	;B
    686  76a9		       05		      .byte.b	5	;R (44)
    687  76aa		       05		      .byte.b	5	;G
    688  76ab		       00		      .byte.b	0	;B
    689  76ac		       01		      .byte.b	1	;R (43)
    690  76ad		       00		      .byte.b	0	;G
    691  76ae		       00		      .byte.b	0	;B
    692  76af		       01		      .byte.b	1	;R (42)
    693  76b0		       00		      .byte.b	0	;G
    694  76b1		       00		      .byte.b	0	;B
    695  76b2		       01		      .byte.b	1	;R (41)
    696  76b3		       00		      .byte.b	0	;G
    697  76b4		       00		      .byte.b	0	;B
    698  76b5		       81		      .byte.b	129	;R (40)
    699  76b6		       81		      .byte.b	129	;G
    700  76b7		       00		      .byte.b	0	;B
    701  76b8		       c0		      .byte.b	192	;R (39)
    702  76b9		       40		      .byte.b	64	;G
    703  76ba		       00		      .byte.b	0	;B
    704  76bb		       c0		      .byte.b	192	;R (38)
    705  76bc		       00		      .byte.b	0	;G
    706  76bd		       00		      .byte.b	0	;B
    707  76be		       e0		      .byte.b	224	;R (37)
    708  76bf		       20		      .byte.b	32	;G
    709  76c0		       00		      .byte.b	0	;B
    710  76c1		       e0		      .byte.b	224	;R (36)
    711  76c2		       00		      .byte.b	0	;G
    712  76c3		       00		      .byte.b	0	;B
    713  76c4		       f0		      .byte.b	240	;R (35)
    714  76c5		       10		      .byte.b	16	;G
    715  76c6		       00		      .byte.b	0	;B
    716  76c7		       f0		      .byte.b	240	;R (34)
    717  76c8		       00		      .byte.b	0	;G
    718  76c9		       00		      .byte.b	0	;B
    719  76ca		       f8		      .byte.b	248	;R (33)
    720  76cb		       08		      .byte.b	8	;G
    721  76cc		       00		      .byte.b	0	;B
    722  76cd		       f8		      .byte.b	248	;R (32)
    723  76ce		       08		      .byte.b	8	;G
    724  76cf		       00		      .byte.b	0	;B
    725  76d0		       f0		      .byte.b	240	;R (31)
    726  76d1		       80		      .byte.b	128	;G
    727  76d2		       00		      .byte.b	0	;B
    728  76d3		       f0		      .byte.b	240	;R (30)
    729  76d4		       00		      .byte.b	0	;G
    730  76d5		       00		      .byte.b	0	;B
    731  76d6		       f8		      .byte.b	248	;R (29)
    732  76d7		       88		      .byte.b	136	;G
    733  76d8		       00		      .byte.b	0	;B
    734  76d9		       f8		      .byte.b	248	;R (28)
    735  76da		       08		      .byte.b	8	;G
    736  76db		       00		      .byte.b	0	;B
    737  76dc		       f8		      .byte.b	248	;R (27)
    738  76dd		       08		      .byte.b	8	;G
    739  76de		       00		      .byte.b	0	;B
    740  76df		       f8		      .byte.b	248	;R (26)
    741  76e0		       88		      .byte.b	136	;G
    742  76e1		       00		      .byte.b	0	;B
    743  76e2		       f8		      .byte.b	248	;R (25)
    744  76e3		       08		      .byte.b	8	;G
    745  76e4		       00		      .byte.b	0	;B
    746  76e5		       f8		      .byte.b	248	;R (24)
    747  76e6		       08		      .byte.b	8	;G
    748  76e7		       00		      .byte.b	0	;B
    749  76e8		       f8		      .byte.b	248	;R (23)
    750  76e9		       08		      .byte.b	8	;G
    751  76ea		       00		      .byte.b	0	;B
    752  76eb		       f0		      .byte.b	240	;R (22)
    753  76ec		       00		      .byte.b	0	;G
    754  76ed		       00		      .byte.b	0	;B
    755  76ee		       f0		      .byte.b	240	;R (21)
    756  76ef		       10		      .byte.b	16	;G
    757  76f0		       00		      .byte.b	0	;B
    758  76f1		       e0		      .byte.b	224	;R (20)
    759  76f2		       20		      .byte.b	32	;G
    760  76f3		       00		      .byte.b	0	;B
    761  76f4		       c0		      .byte.b	192	;R (19)
    762  76f5		       00		      .byte.b	0	;G
    763  76f6		       00		      .byte.b	0	;B
    764  76f7		       c0		      .byte.b	192	;R (18)
    765  76f8		       40		      .byte.b	64	;G
    766  76f9		       00		      .byte.b	0	;B
    767  76fa		       83		      .byte.b	131	;R (17)
    768  76fb		       83		      .byte.b	131	;G
    769  76fc		       00		      .byte.b	0	;B
    770  76fd		       03		      .byte.b	3	;R (16)
    771  76fe		       03		      .byte.b	3	;G
    772  76ff		       00		      .byte.b	0	;B
    773  7700		       01		      .byte.b	1	;R (15)
    774  7701		       01		      .byte.b	1	;G
    775  7702		       00		      .byte.b	0	;B
    776  7703		       00		      .byte.b	0	;R (14)
    777  7704		       00		      .byte.b	0	;G
    778  7705		       00		      .byte.b	0	;B
    779  7706		       00		      .byte.b	0	;R (13)
    780  7707		       00		      .byte.b	0	;G
    781  7708		       0a		      .byte.b	10	;B
    782  7709		       00		      .byte.b	0	;R (12)
    783  770a		       00		      .byte.b	0	;G
    784  770b		       0a		      .byte.b	10	;B
    785  770c		       00		      .byte.b	0	;R (11)
    786  770d		       00		      .byte.b	0	;G
    787  770e		       0e		      .byte.b	14	;B
    788  770f		       00		      .byte.b	0	;R (10)
    789  7710		       00		      .byte.b	0	;G
    790  7711		       aa		      .byte.b	170	;B
    791  7712		       00		      .byte.b	0	;R (9)
    792  7713		       00		      .byte.b	0	;G
    793  7714		       ae		      .byte.b	174	;B
    794  7715		       00		      .byte.b	0	;R (8)
    795  7716		       00		      .byte.b	0	;G
    796  7717		       a4		      .byte.b	164	;B
    797  7718		       00		      .byte.b	0	;R (7)
    798  7719		       00		      .byte.b	0	;G
    799  771a		       a0		      .byte.b	160	;B
    800  771b		       00		      .byte.b	0	;R (6)
    801  771c		       00		      .byte.b	0	;G
    802  771d		       a0		      .byte.b	160	;B
    803  771e		       00		      .byte.b	0	;R (5)
    804  771f		       00		      .byte.b	0	;G
    805  7720		       c0		      .byte.b	192	;B
    806  7721		       00		      .byte.b	0	;R (4)
    807  7722		       00		      .byte.b	0	;G
    808  7723		       00		      .byte.b	0	;B
    809  7724		       00		      .byte.b	0	;R (3)
    810  7725		       00		      .byte.b	0	;G
    811  7726		       00		      .byte.b	0	;B
    812  7727		       00		      .byte.b	0	;R (2)
    813  7728		       00		      .byte.b	0	;G
    814  7729		       00		      .byte.b	0	;B
    815  772a		       00		      .byte.b	0	;R (1)
    816  772b		       00		      .byte.b	0	;G
    817  772c		       00		      .byte.b	0	;B
    818  772d		       00		      .byte.b	0	;R (0)
    819  772e		       00		      .byte.b	0	;G
    820  772f		       00		      .byte.b	0	;B
    821  7730				   COL_4
    822  7730		       00		      .byte.b	0	;R (67)
    823  7731		       00		      .byte.b	0	;G
    824  7732		       00		      .byte.b	0	;B
    825  7733		       00		      .byte.b	0	;R (66)
    826  7734		       00		      .byte.b	0	;G
    827  7735		       00		      .byte.b	0	;B
    828  7736		       00		      .byte.b	0	;R (65)
    829  7737		       00		      .byte.b	0	;G
    830  7738		       00		      .byte.b	0	;B
    831  7739		       01		      .byte.b	1	;R (64)
    832  773a		       01		      .byte.b	1	;G
    833  773b		       00		      .byte.b	0	;B
    834  773c		       03		      .byte.b	3	;R (63)
    835  773d		       02		      .byte.b	2	;G
    836  773e		       00		      .byte.b	0	;B
    837  773f		       03		      .byte.b	3	;R (62)
    838  7740		       03		      .byte.b	3	;G
    839  7741		       00		      .byte.b	0	;B
    840  7742		       03		      .byte.b	3	;R (61)
    841  7743		       02		      .byte.b	2	;G
    842  7744		       00		      .byte.b	0	;B
    843  7745		       03		      .byte.b	3	;R (60)
    844  7746		       03		      .byte.b	3	;G
    845  7747		       00		      .byte.b	0	;B
    846  7748		       03		      .byte.b	3	;R (59)
    847  7749		       02		      .byte.b	2	;G
    848  774a		       00		      .byte.b	0	;B
    849  774b		       03		      .byte.b	3	;R (58)
    850  774c		       03		      .byte.b	3	;G
    851  774d		       00		      .byte.b	0	;B
    852  774e		       03		      .byte.b	3	;R (57)
    853  774f		       03		      .byte.b	3	;G
    854  7750		       00		      .byte.b	0	;B
    855  7751		       0d		      .byte.b	13	;R (56)
    856  7752		       0d		      .byte.b	13	;G
    857  7753		       00		      .byte.b	0	;B
    858  7754		       1f		      .byte.b	31	;R (55)
    859  7755		       0b		      .byte.b	11	;G
    860  7756		       00		      .byte.b	0	;B
    861  7757		       3f		      .byte.b	63	;R (54)
    862  7758		       25		      .byte.b	37	;G
    863  7759		       00		      .byte.b	0	;B
    864  775a		       3f		      .byte.b	63	;R (53)
    865  775b		       30		      .byte.b	48	;G
    866  775c		       00		      .byte.b	0	;B
    867  775d		       21		      .byte.b	33	;R (52)
    868  775e		       21		      .byte.b	33	;G
    869  775f		       00		      .byte.b	0	;B
    870  7760		       00		      .byte.b	0	;R (51)
    871  7761		       00		      .byte.b	0	;G
    872  7762		       00		      .byte.b	0	;B
    873  7763		       00		      .byte.b	0	;R (50)
    874  7764		       00		      .byte.b	0	;G
    875  7765		       00		      .byte.b	0	;B
    876  7766		       01		      .byte.b	1	;R (49)
    877  7767		       01		      .byte.b	1	;G
    878  7768		       00		      .byte.b	0	;B
    879  7769		       03		      .byte.b	3	;R (48)
    880  776a		       02		      .byte.b	2	;G
    881  776b		       00		      .byte.b	0	;B
    882  776c		       07		      .byte.b	7	;R (47)
    883  776d		       07		      .byte.b	7	;G
    884  776e		       00		      .byte.b	0	;B
    885  776f		       00		      .byte.b	0	;R (46)
    886  7770		       00		      .byte.b	0	;G
    887  7771		       00		      .byte.b	0	;B
    888  7772		       00		      .byte.b	0	;R (45)
    889  7773		       00		      .byte.b	0	;G
    890  7774		       00		      .byte.b	0	;B
    891  7775		       06		      .byte.b	6	;R (44)
    892  7776		       06		      .byte.b	6	;G
    893  7777		       00		      .byte.b	0	;B
    894  7778		       0c		      .byte.b	12	;R (43)
    895  7779		       04		      .byte.b	4	;G
    896  777a		       00		      .byte.b	0	;B
    897  777b		       1c		      .byte.b	28	;R (42)
    898  777c		       1c		      .byte.b	28	;G
    899  777d		       00		      .byte.b	0	;B
    900  777e		       38		      .byte.b	56	;R (41)
    901  777f		       38		      .byte.b	56	;G
    902  7780		       00		      .byte.b	0	;B
    903  7781		       00		      .byte.b	0	;R (40)
    904  7782		       00		      .byte.b	0	;G
    905  7783		       00		      .byte.b	0	;B
    906  7784		       0a		      .byte.b	10	;R (39)
    907  7785		       0a		      .byte.b	10	;G
    908  7786		       00		      .byte.b	0	;B
    909  7787		       02		      .byte.b	2	;R (38)
    910  7788		       00		      .byte.b	0	;G
    911  7789		       00		      .byte.b	0	;B
    912  778a		       32		      .byte.b	50	;R (37)
    913  778b		       30		      .byte.b	48	;G
    914  778c		       00		      .byte.b	0	;B
    915  778d		       72		      .byte.b	114	;R (36)
    916  778e		       72		      .byte.b	114	;G
    917  778f		       00		      .byte.b	0	;B
    918  7790		       74		      .byte.b	116	;R (35)
    919  7791		       54		      .byte.b	84	;G
    920  7792		       00		      .byte.b	0	;B
    921  7793		       54		      .byte.b	84	;R (34)
    922  7794		       10		      .byte.b	16	;G
    923  7795		       00		      .byte.b	0	;B
    924  7796		       04		      .byte.b	4	;R (33)
    925  7797		       00		      .byte.b	0	;G
    926  7798		       00		      .byte.b	0	;B
    927  7799		       02		      .byte.b	2	;R (32)
    928  779a		       02		      .byte.b	2	;G
    929  779b		       00		      .byte.b	0	;B
    930  779c		       10		      .byte.b	16	;R (31)
    931  779d		       10		      .byte.b	16	;G
    932  779e		       00		      .byte.b	0	;B
    933  779f		       68		      .byte.b	104	;R (30)
    934  77a0		       68		      .byte.b	104	;G
    935  77a1		       00		      .byte.b	0	;B
    936  77a2		       6c		      .byte.b	108	;R (29)
    937  77a3		       24		      .byte.b	36	;G
    938  77a4		       00		      .byte.b	0	;B
    939  77a5		       4c		      .byte.b	76	;R (28)
    940  77a6		       08		      .byte.b	8	;G
    941  77a7		       00		      .byte.b	0	;B
    942  77a8		       d4		      .byte.b	212	;R (27)
    943  77a9		       d4		      .byte.b	212	;G
    944  77aa		       00		      .byte.b	0	;B
    945  77ab		       00		      .byte.b	0	;R (26)
    946  77ac		       00		      .byte.b	0	;G
    947  77ad		       00		      .byte.b	0	;B
    948  77ae		       2c		      .byte.b	44	;R (25)
    949  77af		       2c		      .byte.b	44	;G
    950  77b0		       00		      .byte.b	0	;B
    951  77b1		       36		      .byte.b	54	;R (24)
    952  77b2		       16		      .byte.b	22	;G
    953  77b3		       00		      .byte.b	0	;B
    954  77b4		       2e		      .byte.b	46	;R (23)
    955  77b5		       0e		      .byte.b	14	;G
    956  77b6		       00		      .byte.b	0	;B
    957  77b7		       60		      .byte.b	96	;R (22)
    958  77b8		       40		      .byte.b	64	;G
    959  77b9		       00		      .byte.b	0	;B
    960  77ba		       28		      .byte.b	40	;R (21)
    961  77bb		       28		      .byte.b	40	;G
    962  77bc		       00		      .byte.b	0	;B
    963  77bd		       0f		      .byte.b	15	;R (20)
    964  77be		       0d		      .byte.b	13	;G
    965  77bf		       00		      .byte.b	0	;B
    966  77c0		       1a		      .byte.b	26	;R (19)
    967  77c1		       1a		      .byte.b	26	;G
    968  77c2		       00		      .byte.b	0	;B
    969  77c3		       18		      .byte.b	24	;R (18)
    970  77c4		       08		      .byte.b	8	;G
    971  77c5		       00		      .byte.b	0	;B
    972  77c6		       14		      .byte.b	20	;R (17)
    973  77c7		       04		      .byte.b	4	;G
    974  77c8		       00		      .byte.b	0	;B
    975  77c9		       16		      .byte.b	22	;R (16)
    976  77ca		       16		      .byte.b	22	;G
    977  77cb		       00		      .byte.b	0	;B
    978  77cc		       04		      .byte.b	4	;R (15)
    979  77cd		       00		      .byte.b	0	;G
    980  77ce		       00		      .byte.b	0	;B
    981  77cf		       06		      .byte.b	6	;R (14)
    982  77d0		       02		      .byte.b	2	;G
    983  77d1		       00		      .byte.b	0	;B
    984  77d2		       05		      .byte.b	5	;R (13)
    985  77d3		       05		      .byte.b	5	;G
    986  77d4		       00		      .byte.b	0	;B
    987  77d5		       05		      .byte.b	5	;R (12)
    988  77d6		       05		      .byte.b	5	;G
    989  77d7		       00		      .byte.b	0	;B
    990  77d8		       00		      .byte.b	0	;R (11)
    991  77d9		       00		      .byte.b	0	;G
    992  77da		       00		      .byte.b	0	;B
    993  77db		       00		      .byte.b	0	;R (10)
    994  77dc		       00		      .byte.b	0	;G
    995  77dd		       00		      .byte.b	0	;B
    996  77de		       00		      .byte.b	0	;R (9)
    997  77df		       00		      .byte.b	0	;G
    998  77e0		       00		      .byte.b	0	;B
    999  77e1		       00		      .byte.b	0	;R (8)
   1000  77e2		       00		      .byte.b	0	;G
   1001  77e3		       00		      .byte.b	0	;B
   1002  77e4		       00		      .byte.b	0	;R (7)
   1003  77e5		       00		      .byte.b	0	;G
   1004  77e6		       00		      .byte.b	0	;B
   1005  77e7		       00		      .byte.b	0	;R (6)
   1006  77e8		       00		      .byte.b	0	;G
   1007  77e9		       00		      .byte.b	0	;B
   1008  77ea		       00		      .byte.b	0	;R (5)
   1009  77eb		       00		      .byte.b	0	;G
   1010  77ec		       00		      .byte.b	0	;B
   1011  77ed		       00		      .byte.b	0	;R (4)
   1012  77ee		       00		      .byte.b	0	;G
   1013  77ef		       00		      .byte.b	0	;B
   1014  77f0		       00		      .byte.b	0	;R (3)
   1015  77f1		       00		      .byte.b	0	;G
   1016  77f2		       00		      .byte.b	0	;B
   1017  77f3		       00		      .byte.b	0	;R (2)
   1018  77f4		       00		      .byte.b	0	;G
   1019  77f5		       00		      .byte.b	0	;B
   1020  77f6		       00		      .byte.b	0	;R (1)
   1021  77f7		       00		      .byte.b	0	;G
   1022  77f8		       00		      .byte.b	0	;B
   1023  77f9		       00		      .byte.b	0	;R (0)
   1024  77fa		       00		      .byte.b	0	;G
   1025  77fb		       00		      .byte.b	0	;B
------- FILE TitleScreen@2.asm
      6  77fc
      0  77fc					      CHECK_BANK_SIZE	"TITLEDATA2"
      1  77fc		       03 fc	   .TEMP      =	* - _BANK_START
 TITLEDATA2 (1K) SIZE =  $3fc , FREE= $4
      2  77fc					      ECHO	"TITLEDATA2", "(1K) SIZE = ", .TEMP, ", FREE=", _ROM_BANK_SIZE - .TEMP
      3  77fc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  77fc				  -	      ECHO	"BANK OVERFLOW @ ", "TITLEDATA2", " size=", * - ORIGIN
      5  77fc				  -	      ERR
      6  77fc					      ENDIF
------- FILE ./chess.asm
    575  77fc
    576  77fc
    577  7800		       00 00 00 00	      ALIGN	_ROM_BANK_SIZE
    578  7800
    579  7800							;---------------------------------------------------------------------------------------------------
    580  7800							;EOF
