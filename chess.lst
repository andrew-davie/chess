------- FILE ./chess.asm LEVEL 1 PASS 4
      1  8000 ????						; Chess
      2  8000 ????						; Atari 2600 Chess display system
      3  8000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  8000 ????						; andrew@taswegian.com
      5  8000 ????
      6  8000 ????
      7  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      8  8000 ????
      9  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.06, 06/SEP/2020
      3  8000 ????
      4  8000 ????	       00 6a	   VERSION_VCS =	106
      5  8000 ????
      6  8000 ????						; THIS IS A *THE* "STANDARD" VCS.H
      7  8000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  8000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  8000 ????						;
     10  8000 ????						; This file defines hardware registers and memory mapping for the
     11  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  8000 ????						; available at at https://dasm-assembler.github.io/
     14  8000 ????						;
     15  8000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     16  8000 ????						; contents, or would like ot add something, please report as an issue at...
     17  8000 ????						; https://github.com/dasm-assembler/dasm/issues
     18  8000 ????
     19  8000 ????						;
     20  8000 ????						; Latest Revisions...
     21  8000 ????						; 1.06  05/SEP/2020	 Modified header/license and links to new versions
     22  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  8000 ????						;			    This will allow conditional code to verify VCS.H being
     25  8000 ????						;			    used for code assembly.
     26  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  8000 ????						;			 mirrored reading/writing differences.	This is more a
     29  8000 ????						;			 readability issue, and binary compatibility with disassembled
     30  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  8000 ????						;			 which was broken by the use of segments in this file, as
     33  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  8000 ????						;						   it is safe to leave it undefined, and the base address will
     38  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  8000 ????						;			  - register definitions are now generated through assignment
     41  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  8000 ????						;			    address architecture.
     43  8000 ????						; 1.0	22/MAR/2003		Initial release
     44  8000 ????
     45  8000 ????
     46  8000 ????						;-------------------------------------------------------------------------------
     47  8000 ????
     48  8000 ????						; TIA_BASE_ADDRESS
     49  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  8000 ????						; Normally 0, the base address should (externally, before including this file)
     51  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  8000 ????						; < $40 as a bankswitch.
     54  8000 ????
     55  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56  8000 ????			  -TIA_BASE_ADDRESS =	0
     57  8000 ????				      ENDIF
     58  8000 ????
     59  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  8000 ????						; *OR* by declaring the label before including this file, eg:
     62  8000 ????						; TIA_BASE_ADDRESS = $40
     63  8000 ????						;   include "vcs.h"
     64  8000 ????
     65  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  8000 ????						; for the mirrored ROM hardware registers.
     68  8000 ????
     69  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  8000 ????				      ENDIF
     80  8000 ????
     81  8000 ????						;-------------------------------------------------------------------------------
     82  8000 ????
     83 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0040
     86 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0040
     88 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U006d
    134 U006d							;-------------------------------------------------------------------------------
    135 U006d
    136 U004e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0040					      ORG	TIA_BASE_READ_ADDRESS
    138 U0040
    139 U0040							;											bit 7	 bit 6
    140 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U004e
    155 U004e							;-------------------------------------------------------------------------------
    156 U004e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.09, 05/SEP/2020
      3  0000 ????
      4  0000 ????	       00 6d	   VERSION_MACRO =	109
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler.
     13  0000 ????						;
     14  0000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     15  0000 ????						; contents, or would like ot add something, please report as an issue at...
     16  0000 ????						; https://github.com/dasm-assembler/dasm/issues
     17  0000 ????
     18  0000 ????
     19  0000 ????						; Latest Revisions...
     20  0000 ????						; 1.09  05/SEP/2020	 - updated license/links
     21  0000 ????
     22  0000 ????						; 1.08  13/JUL/2020	 - added use of LXA to CLEAN_START
     23  0000 ????						; 1.07  19/JAN/2020	 - correction to comment VERTICAL_SYNC
     24  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_SYNC (Edwin Blink)
     25  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     26  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     27  0000 ????						;			   used for code assembly.
     28  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     29  0000 ????						;
     30  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     31  0000 ????						;
     32  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     33  0000 ????						;			   (standardised macro for vertical synch code)
     34  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     35  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     36  0000 ????						; 1.0	22/MAR/2003		Initial release
     37  0000 ????
     38  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     39  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     40  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     41  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     42  0000 ????						;   registers and require them to be defined first).
     43  0000 ????
     44  0000 ????						; Available macros...
     45  0000 ????						;   SLEEP n		 - sleep for n cycles
     46  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     47  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     48  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     49  0000 ????
     50  0000 ????						;-------------------------------------------------------------------------------
     51  0000 ????						; SLEEP duration
     52  0000 ????						; Original author: Thomas Jentzsch
     53  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     54  0000 ????						; useful for code where precise timing is required.
     55  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     56  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     57  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     58  0000 ????
     59  0000 ????				      MAC	sleep
     60  0000 ????			   .CYCLES    SET	{1}
     61  0000 ????
     62  0000 ????				      IF	.CYCLES < 2
     63  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     64  0000 ????				      ERR
     65  0000 ????				      ENDIF
     66  0000 ????
     67  0000 ????				      IF	.CYCLES & 1
     68  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     69  0000 ????				      nop	0
     70  0000 ????				      ELSE
     71  0000 ????				      bit	VSYNC
     72  0000 ????				      ENDIF
     73  0000 ????			   .CYCLES    SET	.CYCLES - 3
     74  0000 ????				      ENDIF
     75  0000 ????
     76  0000 ????				      REPEAT	.CYCLES / 2
     77  0000 ????				      nop
     78  0000 ????				      REPEND
     79  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     80  0000 ????
     81  0000 ????						;-------------------------------------------------------------------------------
     82  0000 ????						; VERTICAL_SYNC
     83  0000 ????						; revised version by Edwin Blink -- saves bytes!
     84  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     85  0000 ????						; Note: Alters the accumulator
     86  0000 ????
     87  0000 ????						; OUT: A = 0
     88  0000 ????
     89  0000 ????				      MAC	vertical_sync
     90  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     91  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     92  0000 ????				      sta	VSYNC
     93  0000 ????				      lsr
     94  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     95  0000 ????				      ENDM
     96  0000 ????
     97  0000 ????						;-------------------------------------------------------------------------------
     98  0000 ????						; CLEAN_START
     99  0000 ????						; Original author: Andrew Davie
    100  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    101  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    102  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    103  0000 ????						; Use as very first section of code on boot (ie: at reset)
    104  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    105  0000 ????
    106  0000 ????				      MAC	clean_start
    107  0000 ????				      sei
    108  0000 ????				      cld
    109  0000 ????
    110  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
    111  0000 ????				      lxa	#0
    112  0000 ????				      ELSE
    113  0000 ????				      ldx	#0
    114  0000 ????				      txa
    115  0000 ????				      ENDIF
    116  0000 ????				      tay
    117  0000 ????			   .CLEAR_STACK dex
    118  0000 ????				      txs
    119  0000 ????				      pha
    120  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  0000 ????
    122  0000 ????				      ENDM
    123  0000 ????
    124  0000 ????						;-------------------------------------------------------
    125  0000 ????						; SET_POINTER
    126  0000 ????						; Original author: Manuel Rotschkar
    127  0000 ????						;
    128  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  0000 ????						;
    130  0000 ????						; Usage: SET_POINTER pointer, address
    131  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  0000 ????						;
    133  0000 ????						; Note: Alters the accumulator, NZ flags
    134  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  0000 ????						; IN 2: absolute address
    136  0000 ????
    137  0000 ????				      MAC	set_pointer
    138  0000 ????			   .POINTER   SET	{1}
    139  0000 ????			   .ADDRESS   SET	{2}
    140  0000 ????
    141  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  0000 ????				      STA	.POINTER	; Store in pointer
    143  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  0000 ????
    146  0000 ????				      ENDM
    147  0000 ????
    148  0000 ????						;-------------------------------------------------------
    149  0000 ????						; BOUNDARY byte#
    150  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    151  0000 ????						;
    152  0000 ????						; Push data to a certain position inside a page and keep count of how
    153  0000 ????						; many free bytes the programmer will have.
    154  0000 ????						;
    155  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    156  0000 ????
    157  0000 ????			   .FREE_BYTES SET	0
    158  0000 ????				      MAC	boundary
    159  0000 ????				      REPEAT	256
    160  0000 ????				      IF	<. % {1} = 0
    161  0000 ????				      MEXIT
    162  0000 ????				      ELSE
    163  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    164  0000 ????				      .byte	$00
    165  0000 ????				      ENDIF
    166  0000 ????				      REPEND
    167  0000 ????				      ENDM
    168  0000 ????
    169  0000 ????
    170  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE _ MACROS.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"_ MACROS.asm"
      1  0000 ????						; MACROS.asm
      2  0000 ????						;---------------------------------------------------------------------------------------------------
      3  0000 ????
      4  0000 ????				      MAC	def
      5  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
      6  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
      7  0000 ????			   {1}			; entry point
      8  0000 ????			   TEMPORARY_VAR SET	Overlay
      9  0000 ????			   TEMPORARY_OFFSET SET	0
     10  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
     11  0000 ????			   FUNCTION_NAME SET	{1}
     12  0000 ????				      ENDM		; name of subroutine
     13  0000 ????
     14  0000 ????
     15  0000 ????						;---------------------------------------------------------------------------------------------------
     16  0000 ????
     17  0000 ????				      MAC	ramdef
     18  0000 ????
     19  0000 ????						; Just an alternate name for "DEF" that makes it clear the subroutine is in RAM
     20  0000 ????
     21  0000 ????				      DEF	{1}
     22  0000 ????				      ENDM		; {name of subroutine}
     23  0000 ????
     24  0000 ????
     25  0000 ????						;---------------------------------------------------------------------------------------------------
     26  0000 ????
     27  0000 ????				      MAC	slot
     28  0000 ????
     29  0000 ????				      IF	({1} < 0) || ({1} > 3)
     30  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
     31  0000 ????				      ERR
     32  0000 ????				      ENDIF
     33  0000 ????
     34  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
     35  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
     36  0000 ????
     37  0000 ????				      ENDM		; {1}
     38  0000 ????
     39  0000 ????
     40  0000 ????						;---------------------------------------------------------------------------------------------------
     41  0000 ????						; Temporary local variables
     42  0000 ????						; usage:
     43  0000 ????						;
     44  0000 ????						;   DEF fna
     45  0000 ????						;	 REF fnc
     46  0000 ????						;	 REF fnd
     47  0000 ????						;	 VAR localVar1,1
     48  0000 ????						;	 VAR ptr,2
     49  0000 ????						;	 VEND fna
     50  0000 ????						;
     51  0000 ????						; The above declares a functino named 'fna'
     52  0000 ????						; The function declares two local variables, 'localVar1' (1 byte) and 'ptr' (2 bytes)
     53  0000 ????						; These variables are given an address in the overlay area which does NOT overlap any of
     54  0000 ????						; the local variables which are declared in the referring functions 'fnc' and 'fnd'
     55  0000 ????						; Although the local variables are available to other functions (i.e., global in scope), care
     56  0000 ????						; should be taken NOT to use them in other functions unless absolutely necessary and required.
     57  0000 ????						; To share local variables between functions, they should be (re)declared in both so that they
     58  0000 ????						; have exactly the same addresses.
     59  0000 ????
     60  0000 ????
     61  0000 ????
     62  0000 ????						; The relative offset into the overlay area for the next variable declaration...
     63  0000 ????			   TEMPORARY_OFFSET SET	0
     64  0000 ????
     65  0000 ????
     66  0000 ????						;---------------------------------------------------------------------------------------------------
     67  0000 ????
     68  0000 ????						; Finalise the declaration block for local variables
     69  0000 ????						; {1} = name of the function for which this block is defined
     70  0000 ????				      MAC	vend
     71  0000 ????						; register the end of variables for this function
     72  0000 ????
     73  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
     74  0000 ????						;V2_._FUNCTION_NAME = TEMPORARY_VAR
     75  0000 ????				      ENDM
     76  0000 ????
     77  0000 ????
     78  0000 ????						;---------------------------------------------------------------------------------------------------
     79  0000 ????
     80  0000 ????						; Note a reference to this function by an external function
     81  0000 ????						; The external function's VEND block is used to guarantee that variables for
     82  0000 ????						; the function we are declaring will start AFTER all other variables in all referencing blocks
     83  0000 ????
     84  0000 ????				      MAC	ref
     85  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
     86  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
     87  0000 ????				      ENDIF
     88  0000 ????				      ENDM		; {1}
     89  0000 ????
     90  0000 ????
     91  0000 ????						;---------------------------------------------------------------------------------------------------
     92  0000 ????
     93  0000 ????						; Define a temporary variable for use in a subroutine
     94  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
     95  0000 ????
     96  0000 ????				      MAC	var
     97  0000 ????			   {1}	      =	TEMPORARY_VAR
     98  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
     99  0000 ????
    100  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    101  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    102  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    103  0000 ????				      ENDIF
    104  0000 ????				      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
    105  0000 ????			   VNAME      SETSTR	{1}
    106  0000 ????				      ECHO	"Temporary Variable", VNAME, "overflow!"
    107  0000 ????				      ERR
    108  0000 ????				      ENDIF
    109  0000 ????				      ENDM		; { name, size }
    110  0000 ????
    111  0000 ????
    112  0000 ????						;---------------------------------------------------------------------------------------------------
    113  0000 ????
    114  0000 ????				      MAC	rombank
    115  0000 ????				      SEG	ROM_{1}
    116  0000 ????				      ORG	_ORIGIN
    117  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    118  0000 ????			   _BANK_START SET	*
    119  0000 ????			   {1}_START  SET	*
    120  0000 ????			   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
    121  0000 ????			   ROMBANK_{1} SET	_BANK_SLOT + _CURRENT_BANK
    122  0000 ????			   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
    123  0000 ????			   _LAST_BANK SETSTR	{1}
    124  0000 ????			   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    125  0000 ????				      ENDM		; bank name
    126  0000 ????
    127  0000 ????
    128  0000 ????						;---------------------------------------------------------------------------------------------------
    129  0000 ????
    130  0000 ????				      MAC	check_bank_size
    131  0000 ????			   .TEMP      =	* - _BANK_START
    132  0000 ????				      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
    133  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    134  0000 ????				      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
    135  0000 ????				      ERR
    136  0000 ????				      ENDIF
    137  0000 ????				      ENDM
    138  0000 ????
    139  0000 ????
    140  0000 ????						;---------------------------------------------------------------------------------------------------
    141  0000 ????
    142  0000 ????				      MAC	check_ram_bank_size
    143  0000 ????			   .TEMP      =	* - _BANK_START
    144  0000 ????				      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
    145  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    146  0000 ????				      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
    147  0000 ????				      ERR
    148  0000 ????				      ENDIF
    149  0000 ????				      ENDM
    150  0000 ????
    151  0000 ????
    152  0000 ????						;---------------------------------------------------------------------------------------------------
    153  0000 ????
    154  0000 ????	       00 00	   _TYPE_RAM  =	0
    155  0000 ????	       00 01	   _TYPE_ROM  =	1
    156  0000 ????
    157  0000 ????				      MAC	end_bank
    158  0000 ????				      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
    159  0000 ????				      CHECK_RAM_BANK_SIZE
    160  0000 ????				      ELSE
    161  0000 ????				      CHECK_BANK_SIZE
    162  0000 ????				      ENDIF
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						;---------------------------------------------------------------------------------------------------
    167  0000 ????
    168  0000 ????				      MACRO	rambank
    169  0000 ????
    170  0000 ????				      SEG.U	RAM_{1}
    171  0000 ????				      ORG	ORIGIN_RAM
    172  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    173  0000 ????			   _BANK_START SET	*
    174  0000 ????			   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
    175  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + _CURRENT_RAMBANK
    176  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
    177  0000 ????			   _LAST_BANK SETSTR	{1}
    178  0000 ????			   _CURRENT_BANK_TYPE SET	_TYPE_RAM
    179  0000 ????				      ENDM		; {bank name}
    180  0000 ????
    181  0000 ????
    182  0000 ????						;---------------------------------------------------------------------------------------------------
    183  0000 ????
    184  0000 ????						; Failsafe call of function in another bank
    185  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    186  0000 ????
    187  0000 ????				      MAC	call
    188  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    189  0000 ????			   FNAME      SETSTR	{1}
    190  0000 ????				      ECHO	""
    191  0000 ????				      ECHO	"ERROR: Incompatible slot for call to function", FNAME
    192  0000 ????				      ECHO	"Cannot switch bank in use for ", FNAME
    193  0000 ????				      ERR
    194  0000 ????				      ENDIF
    195  0000 ????				      lda	#BANK_{1}
    196  0000 ????				      sta	SET_BANK
    197  0000 ????				      jsr	{1}
    198  0000 ????				      ENDM		; function name
    199  0000 ????
    200  0000 ????
    201  0000 ????						;---------------------------------------------------------------------------------------------------
    202  0000 ????
    203  0000 ????				      MAC	jump
    204  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    205  0000 ????			   FNAME      SETSTR	{1}
    206  0000 ????				      ECHO	""
    207  0000 ????				      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
    208  0000 ????				      ECHO	"Cannot switch bank in use for ", FNAME
    209  0000 ????				      ERR
    210  0000 ????				      ENDIF
    211  0000 ????				      lda	#BANK_{1}
    212  0000 ????				      sta	SET_BANK
    213  0000 ????				      jmp	{1}
    214  0000 ????				      ENDM		; function name
    215  0000 ????
    216  0000 ????
    217  0000 ????						;---------------------------------------------------------------------------------------------------
    218  0000 ????						; Macro inserts a page break if the object would overlap a page
    219  0000 ????
    220  0000 ????				      MAC	optional_pagebreak
    221  0000 ????
    222  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    223  0000 ????			   .EARLY_LOCATION SET	*
    224  0000 ????				      ALIGN	256
    225  0000 ????				      ECHO	"Page break for", {1}, "wasted", [* - .EARLY_LOCATION]d, "bytes"
    226  0000 ????				      ENDIF
    227  0000 ????				      ENDM		; { labelString, size }
    228  0000 ????
    229  0000 ????
    230  0000 ????						;---------------------------------------------------------------------------------------------------
    231  0000 ????
    232  0000 ????						; @author Fred Quimby
    233  0000 ????						; same as bAtari Basic rnd
    234  0000 ????
    235  0000 ????	       00 b4	   RND_EOR_VAL =	$B4
    236  0000 ????
    237  0000 ????				      MAC	next_random
    238  0000 ????
    239  0000 ????				      lda	rnd
    240  0000 ????				      lsr
    241  0000 ????				      bcc	.skipEOR
    242  0000 ????				      eor	#RND_EOR_VAL
    243  0000 ????			   .skipEOR   sta	rnd
    244  0000 ????
    245  0000 ????				      ENDM
    246  0000 ????
    247  0000 ????
    248  0000 ????						;---------------------------------------------------------------------------------------------------
    249  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    250  0000 ????
    251  0000 ????				      MAC	variable
    252  0000 ????
    253  0000 ????			   .NAME      SETSTR	{1}
    254  0000 ????				      OPTIONAL_PAGEBREAK	.NAME, {2}
    255  0000 ????			   {1}	      ds	{2}
    256  0000 ????
    257  0000 ????				      ENDM		; {name, size}
    258  0000 ????
    259  0000 ????
    260  0000 ????						;---------------------------------------------------------------------------------------------------
    261  0000 ????
    262  0000 ????						;TODO - check
    263  0000 ????
    264  0000 ????				      MAC	allocate
    265  0000 ????
    266  0000 ????			   .NAME      SETSTR	{1}
    267  0000 ????				      OPTIONAL_PAGEBREAK	.NAME, {2}
    268  0000 ????				      DEF	{1}
    269  0000 ????
    270  0000 ????				      ENDM		; {label}, {size}
    271  0000 ????
    272  0000 ????
    273  0000 ????						;---------------------------------------------------------------------------------------------------
    274  0000 ????
    275  0000 ????				      MAC	negeval
    276  0000 ????
    277  0000 ????				      sec
    278  0000 ????				      lda	#0
    279  0000 ????				      sbc	Evaluation
    280  0000 ????				      sta	Evaluation
    281  0000 ????				      lda	#0
    282  0000 ????				      sbc	Evaluation+1
    283  0000 ????				      sta	Evaluation+1
    284  0000 ????
    285  0000 ????				      ENDM
    286  0000 ????
    287  0000 ????
    288  0000 ????						;---------------------------------------------------------------------------------------------------
    289  0000 ????
    290  0000 ????				      MAC	swap
    291  0000 ????
    292  0000 ????				      lda	sideToMove
    293  0000 ????				      eor	#SWAP_SIDE|HUMAN
    294  0000 ????				      sta	sideToMove
    295  0000 ????
    296  0000 ????				      ENDM
    297  0000 ????
    298  0000 ????
    299  0000 ????						;---------------------------------------------------------------------------------------------------
    300  0000 ????						; RAM accessor macros
    301  0000 ????						; ALL RAM usage (reads and writes) should use these
    302  0000 ????						; They automate the write offset address addition, and make it clear what memory is being accessed
    303  0000 ????
    304  0000 ????
    305  0000 ????				      MAC	sta@ram
    306  0000 ????				      sta	[RAM]+{0}
    307  0000 ????				      ENDM		;{}
    308  0000 ????
    309  0000 ????				      MAC	stx@ram
    310  0000 ????				      stx	[RAM]+{0}
    311  0000 ????				      ENDM
    312  0000 ????
    313  0000 ????				      MAC	sty@ram
    314  0000 ????				      sty	[RAM]+{0}
    315  0000 ????				      ENDM
    316  0000 ????
    317  0000 ????				      MAC	sta@ply
    318  0000 ????				      sta	[RAM]+{0}
    319  0000 ????				      ENDM		;{}
    320  0000 ????
    321  0000 ????				      MAC	stx@ply
    322  0000 ????				      stx	[RAM]+{0}
    323  0000 ????				      ENDM
    324  0000 ????
    325  0000 ????				      MAC	sty@ply
    326  0000 ????				      sty	[RAM]+{0}
    327  0000 ????				      ENDM
    328  0000 ????
    329  0000 ????
    330  0000 ????				      MAC	lda@ram
    331  0000 ????				      lda	{0}
    332  0000 ????				      ENDM		;{}
    333  0000 ????
    334  0000 ????				      MAC	ldx@ram
    335  0000 ????				      ldx	{0}
    336  0000 ????				      ENDM		;{}
    337  0000 ????
    338  0000 ????				      MAC	ldy@ram
    339  0000 ????				      ldy	{0}
    340  0000 ????				      ENDM		;{}
    341  0000 ????
    342  0000 ????
    343  0000 ????				      MAC	lda@ply
    344  0000 ????				      lda	{0}
    345  0000 ????				      ENDM		;{}
    346  0000 ????
    347  0000 ????				      MAC	ldx@ply
    348  0000 ????				      ldx	{0}
    349  0000 ????				      ENDM		;{}
    350  0000 ????
    351  0000 ????				      MAC	ldy@ply
    352  0000 ????				      ldy	{0}
    353  0000 ????				      ENDM		;{}
    354  0000 ????
    355  0000 ????				      MAC	adc@ply
    356  0000 ????				      adc	{0}
    357  0000 ????				      ENDM		;{}
    358  0000 ????
    359  0000 ????				      MAC	sbc@ply
    360  0000 ????				      sbc	{0}
    361  0000 ????				      ENDM		;{}
    362  0000 ????
    363  0000 ????				      MAC	cmp@ply
    364  0000 ????				      cmp	{0}
    365  0000 ????				      ENDM		;{}
    366  0000 ????
    367  0000 ????				      MAC	ora@ram
    368  0000 ????				      ora	{0}
    369  0000 ????				      ENDM
    370  0000 ????
    371  0000 ????				      MAC	eor@ram
    372  0000 ????				      eor	{0}
    373  0000 ????				      ENDM
    374  0000 ????
    375  0000 ????				      MAC	and@ram
    376  0000 ????				      and	{0}
    377  0000 ????				      ENDM
    378  0000 ????
    379  0000 ????				      MACRO	cpx@ply
    380  0000 ????				      cpx	[RAM] + {0}
    381  0000 ????				      ENDM
    382  0000 ????
    383  0000 ????						;---------------------------------------------------------------------------------------------------
    384  0000 ????
    385  0000 ????				      MAC	set_platform
    386  0000 ????
    387  0000 ????						; 00 = NTSC
    388  0000 ????						; 01 = NTSC
    389  0000 ????						; 10 = PAL-50
    390  0000 ????						; 11 = PAL-60
    391  0000 ????				      lda	SWCHB
    392  0000 ????				      rol
    393  0000 ????				      rol
    394  0000 ????				      rol
    395  0000 ????				      and	#%11
    396  0000 ????				      eor	#PAL
    397  0000 ????				      sta	platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    398  0000 ????
    399  0000 ????				      ENDM
    400  0000 ????
    401  0000 ????
    402  0000 ????						;---------------------------------------------------------------------------------------------------
    403  0000 ????
    404  0000 ????				      MAC	timecheck
    405  0000 ????
    406  0000 ????				      lda	INTIM
    407  0000 ????				      cmp	#SPEEDOF_{1}
    408  0000 ????				      bcc	{2}
    409  0000 ????
    410  0000 ????				      ENDM		; {ident}, {branch if out of time}
    411  0000 ????
    412  0000 ????
    413  0000 ????						;---------------------------------------------------------------------------------------------------
    414  0000 ????
    415  0000 ????				      MAC	timing
    416  0000 ????
    417  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    418  0000 ????
    419  0000 ????				      ENDM		; {label}, {cycles}
    420  0000 ????
    421  0000 ????
    422  0000 ????						;---------------------------------------------------------------------------------------------------
    423  0000 ????						;EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 07	   PIECE_MASK =	7	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     14  0000 ????
     15  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     16  0000 ????
     17  0000 ????			   ORIGIN     SET	0
     18  0000 ????			   ORIGIN_RAM SET	0
     19  0000 ????
     20  0000 ????						;include "segtime.asm"
     21  0000 ????
     22  0000 ????
     23  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     24  0000 ????
     25  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     26  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     27  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     28  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     29  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     30  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     31  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     32  0000 ????
     33  0000 ????	       00 01	   YES	      =	1
     34  0000 ????	       00 00	   NO	      =	0
     35  0000 ????	       00 40	   HUMAN      =	64
     36  0000 ????
     37  0000 ????	       6f ff	   INFINITY   =	$7000-1	;32767
     38  0000 ????
     39  0000 ????
     40  0000 ????						; assemble diagnostics. Remove for release.
     41  0000 ????
     42  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     43  0000 ????	       00 00	   DIAGNOSTICS =	0
     44  0000 ????	       00 01	   QUIESCENCE =	1
     45  0000 ????	       00 00	   ASSERTS    =	0
     46  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     47  0000 ????	       00 01	   ENPASSANT_ENABLED =	1
     48  0000 ????	       00 01	   CASTLING_ENABLED =	1
     49  0000 ????	       00 01	   RAINBOW    =	1	; comment out to disable
     50  0000 ????
     51  0000 ????	       00 02	   SELECT_SWITCH =	2	; (SWCHB & SELECT_SWITCH)  0 == PRESSED
     52  0000 ????
     53  0000 ????
     54  0000 ????						; NOTE: SEARCH_DEPTH cannot be < 3, because the player's moves are generated from PLY+1, and use
     55  0000 ????						; PLY+2 for computer response (thus, 3). The bank allocation gets stomped!
     56  0000 ????
     57  0000 ????
     58  0000 ????	       00 05	   SEARCH_DEPTH =	5
     59  0000 ????	       00 08	   QUIESCE_EXTRA_DEPTH =	8
     60  0000 ????
     61  0000 ????
     62  0000 ????			  -	      IF	SEARCH_DEPTH < 3
     63  0000 ????			  -	      ECHO	"ERROR: Search depth must be >= 3"
     64  0000 ????			  -	      ERR
     65  0000 ????				      ENDIF
     66  0000 ????
     67  0000 ????
     68  0000 ????
     69  0000 ????	       00 0d	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     70  0000 ????	       00 0d	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     71  0000 ????
     72  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     73  0000 ????						;    ERR "Not enough RAM for PLY banks"
     74  0000 ????						;ENDIF
     75  0000 ????
     76  0000 ????
     77  0000 ????
     78  0000 ????
     79  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     80  0000 ????
     81  0000 ????
     82  0000 ????
     83  0000 ????						; DELAYS
     84  0000 ????
     85  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     86  0000 ????
     87  0000 ????						;===================================
     88  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     89  0000 ????						;===================================
     90  0000 ????
     91  0000 ????						;-------------------------------------------------------------------------------
     92  0000 ????						; The following are optional YES/NO depending on phase of the moon
     93  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     96  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     97  0000 ????			  -	      IF	FINAL_VERSION = YES
     98  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     99  0000 ????				      ENDIF
    100  0000 ????
    101  0000 ????						;-------------------------------------------------------------------------------
    102  0000 ????
    103  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    104  0000 ????
    105  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    106  0000 ????
    107  0000 ????						;------------------------------------------------------------------------------
    108  0000 ????
    109  0000 ????	       00 00	   PLUSCART   =	NO
    110  0000 ????
    111  0000 ????						;------------------------------------------------------------------------------
    112  0000 ????
    113  0000 ????
    114  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
    115  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    116  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    117  0000 ????
    118  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    119  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    120  0000 ????
    121  0000 ????
    122  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    123  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    124  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    125  0000 ????
    126  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    127  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    128  0000 ????
    129  0000 ????
    130  0000 ????						; Platform constants:
    131  0000 ????	       00 02	   PAL	      =	%10
    132  0000 ????	       00 02	   PAL_50     =	PAL|0
    133  0000 ????	       00 03	   PAL_60     =	PAL|1
    134  0000 ????
    135  0000 ????	       00 84	   NTSC_COLOUR_LINE_1 =	$84	; blue
    136  0000 ????	       00 46	   NTSC_COLOUR_LINE_2 =	$46	; red
    137  0000 ????	       00 d8	   NTSC_COLOUR_LINE_3 =	$D8	; green
    138  0000 ????
    139  0000 ????	       00 d4	   PAL_COLOUR_LINE_1 =	$D4	; blue
    140  0000 ????	       00 68	   PAL_COLOUR_LINE_2 =	$68	; red
    141  0000 ????	       00 3a	   PAL_COLOUR_LINE_3 =	$3A	; green
    142  0000 ????
    143  0000 ????
    144  0000 ????	       00 2e	   TIME_PART_2 =	46	;68
    145  0000 ????	       00 2d	   TIME_PART_1 =	45	;66
    146  0000 ????	       00 38	   TIME_PART_2_PAL =	56
    147  0000 ????	       00 4e	   TIME_PART_1_PAL =	78
    148  0000 ????
    149  0000 ????
    150  0000 ????	       00 00	   SLOT0      =	0
    151  0000 ????	       00 40	   SLOT1      =	64
    152  0000 ????	       00 80	   SLOT2      =	128
    153  0000 ????	       00 c0	   SLOT3      =	192
    154  0000 ????
    155  0000 ????
    156  0000 ????						;---------------------------------------------------------------------------------------------------
    157  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00b3 ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   framenum   ds	1
     10 U0081
     11 U0081		       00	   squareToDraw ds	1
     12 U0082		       00	   rnd	      ds	1	; random
     13 U0083		       00	   drawDelay  ds	1
     14 U0084		       00	   lastSquareX12 ds	1
     15 U0085
     16 U0085		       00	   drawCount  ds	1
     17 U0086		       00	   fromX12    ds	1
     18 U0087		       00	   toX12      ds	1
     19 U0088		       00	   originX12  ds	1
     20 U0089
     21 U0089		       00	   cursorX12  ds	1
     22 U008a
     23 U008a		       00	   mdelay     ds	1
     24 U008b		       00	   ccur       ds	1
     25 U008c		       00	   aiState    ds	1	; state
     26 U008d		       00	   aiFlashDelay ds	1
     27 U008e
     28 U008e		       00	   aiMoveIndex ds	1
     29 U008f
     30 U008f		       00	   aiFlashPhase ds	1
     31 U0090
     32 U0090		       00 00	   Evaluation ds	2	; tracks value of the board position
     33 U0092
     34 U0092		       00	   currentPiece ds	1
     35 U0093		       00	   currentSquare ds	1
     36 U0094		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     37 U0095		       00	   currentPly ds	1
     38 U0096
     39 U0096		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     40 U0097		       00	   fromPiece  ds	1
     41 U0098		       00	   lastPiece  ds	1
     42 U0099		       00	   previousPiece ds	1
     43 U009a
     44 U009a							;Platform			  ds 1		      ; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     45 U009a		       00 00	   speech_addr ds	2
     46 U009c							;bg				  ds 1
     47 U009c
     48 U009c		       00	   voxframe   ds	1
     49 U009d		       00	   temp       ds	1
     50 U009e		       00	   switch_states ds	1
     51 U009f		       00	   switch_edges ds	1
     52 U00a0
     53 U00a0
     54 U00a0
     55 U00a0
     56 U00a0		       00	   capture    ds	1
     57 U00a1
     58 U00a1				  -	      IF	DIAGNOSTICS
     59 U00a1				  -positionCount ds	3
     60 U00a1					      ENDIF
     61 U00a1
     62 U00a1							;maxPly			  ds 1
     63 U00a1		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     64 U00a2							;protecting			  ds 1
     65 U00a2		       00	   randomness ds	1
     66 U00a3							;__psb 			  ds 2
     67 U00a3
     68 U00a3		       00 00	   vkSquare   ds	2	; current move's king traversal squares during castling
     69 U00a5							;human 			  ds 1		      ; colour of human
     70 U00a5
     71 U00a5		       00	   platform   ds	1	; 0=NTSC, 1=PAL
     72 U00a6
     73 U00a6					      IFCONST	RAINBOW
     74 U00a6		       00	   base       ds	1
     75 U00a7					      ENDIF
     76 U00a7
     77 U00a7
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a7					      include	"overlays.asm"
      1 U00a7							; Chess
      2 U00a7							; Atari 2600 Chess display system
      3 U00a7							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a7							; andrew@taswegian.com
      5 U00a7
      6 U00a7							;---------------------------------------------------------------------------------------------------
      7 U00a7							; OVERLAYS!
      8 U00a7							; These variables are overlays, and should be managed with care
      9 U00a7							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a7							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a7							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a7							; overlay #2
     13 U00a7
     14 U00a7							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a7
     16 U00a7							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a7							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a7							;---------------------------------------------------------------------------------------------------
     19 U00a7
     20 U00a7
     21 U00a7							;OVERLAY_SIZE	  SET $4C	    ; maximum size
     22 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     23 U00a7
     24 U00a7
     25 U00a7							; This overlay variable is used for the overlay variables.  That's OK.
     26 U00a7							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     27 U00a7							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     28 U00a7							; (especially the latter ones) are only used in rare occasions.
     29 U00a7
     30 U00a7							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     31 U00a7							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     32 U00a7
      0 U00a7					      DEF	Overlay
      1 U00a7				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a7				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a7				   Overlay
      4 U00a7				   TEMPORARY_VAR SET	Overlay
      5 U00a7				   TEMPORARY_OFFSET SET	0
      6 U00a7				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a7				   FUNCTION_NAME SET	Overlay
     34 U00a7					      ds	MAXIMUM_REQUIRED_OVERLAY_SIZE	;--> overlay (share) variables
     35 U00a7				   END_OF_OVERLAY
     36 U00a7
     37 U00a7							;---------------------------------------------------------------------------------------------------
     38 U00a7							; And now... the overlays....
     39 U00a7
     40 U00a7							;ECHO "---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     41 U00a7
     42 U00a7							;---------------------------------------------------------------------------------------------------
     43 U00a7
      0 U00a7					      DEF	Variable_PieceShapeBuffer
      1 U00a7				   SLOT_Variable_PieceShapeBuffer SET	_BANK_SLOT
      2 U00a7				   BANK_Variable_PieceShapeBuffer SET	SLOT_Variable_PieceShapeBuffer + _CURRENT_BANK
      3 U00a7				   Variable_PieceShapeBuffer
      4 U00a7				   TEMPORARY_VAR SET	Overlay
      5 U00a7				   TEMPORARY_OFFSET SET	0
      6 U00a7				   VAR_BOUNDARY_Variable_PieceShapeBuffer SET	TEMPORARY_OFFSET
      7 U00a7				   FUNCTION_NAME SET	Variable_PieceShapeBuffer
      0 U00a7					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00a7		       00 a7	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00a7				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00a7
      4 U00a7				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00a7					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00a7				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00a7					      ENDIF
      8 U00a7				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9 U00a7				  -VNAME      SETSTR	__pieceShapeBuffer
     10 U00a7				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11 U00a7				  -	      ERR
     12 U00a7					      ENDIF
      0 U00a7					      VEND	Variable_PieceShapeBuffer
      1 U00a7
      2 U00a7
      3 U00a7		       00 ef	   VAREND_Variable_PieceShapeBuffer =	TEMPORARY_VAR
      4 U00a7
     47 U00a7
     48 U00a7							;---------------------------------------------------------------------------------------------------
     49 U00a7
     50 U00a7
     51 U00a7					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     52 U00a7					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $48
     53 U00a7					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     54 U00a7
     55 U00a7							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00a7					      include	"stack.asm"
      1 U00a7							; Chess
      2 U00a7							; Atari 2600 Chess display system
      3 U00a7							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a7							; andrew@taswegian.com
      5 U00a7
      6 U00a7
      7 U00a7		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00a7		       00 f3	   TOP_OF_STACK =	$FF-RESERVED_FOR_STACK
      9 U00a7
     10 U00a7		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     11 U00b3
     12 U00b3							; WARNING/NOTE - the alphabeta search violates the above size constraints
     13 U00b3							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     14 U00b3							;  but since overlay is not generally stressed during alphabeta, we're good.
     15 U00b3
     16 U00b3							; Ensure there isn't any stomping of stack/overlay excess usage
     17 U00b3
 Overlay boundary:  $ef
     18 U00b3					      ECHO	"Overlay boundary: ", Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE
 Stack boundary:  $e5
     19 U00b3					      ECHO	"Stack boundary: ", $FF- PLY_BANKS*2
     20 U00b3
     21 U00b3
     22 U00b3							; IGNORE stack stomping (sort of)
     23 U00b3							; The stack area is not used by the ply code...
     24 U00b3
     25 U00b3							;IF ($FF - PLY_BANKS*2) < (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     26 U00b3							;    ECHO "ERROR: Not enough reserved space for stack with given #PLY"
     27 U00b3							;    ERR
     28 U00b3							;ENDIF
     29 U00b3
     30 U00b3							;IF TOP_OF_STACK <= (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     31 U00b3							;    ECHO "ERROR: Not enough reserved space for stack"
     32 U00b3							;    ERR
     33 U00b3							;ENDIF
     34 U00b3
     35 U00b3
------- FILE ./chess.asm
    161 U00b3
 FREE BYTES IN ZERO PAGE =  $4c
    162 U00b3					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    163 U00b3				  -	      IF	* > $FF
    164 U00b3				  -	      ERR	"Zero Page overflow!"
    165 U00b3					      ENDIF
    166 U00b3
    167 U00b3							;------------------------------------------------------------------------------
    168 U00b3							;##############################################################################
    169 U00b3							;------------------------------------------------------------------------------
    170 U00b3
    171 U00b3							; NOW THE VERY INTERESTING '3E' RAM BANKS
    172 U00b3							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    173 U00b3							; IN A 1K MEMORY SPACE
    174 U00b3
    175 U00b3
    176 U00b3							;---------------------------------------------------------------------------------------------------
    177 U00b3
    178 U00b3
    179 U00b3					      MAC	phase
    180 U00b3					      lda	#AI_{1}
    181 U00b3					      sta	aiState
    182 U00b3					      ENDM		;#
    183 U00b3
    184 U00b3
    185 U00b3							;--------------------------------------------------------------------------------
    186 U00b3
------- FILE _ PIECE MACROS.asm LEVEL 2 PASS 4
      0 U00b3					      include	"_ PIECE MACROS.asm"
      1 U00b3							; Copyright (C)2020 Andrew Davie
      2 U00b3							; Common macros for piece move handlers
      3 U00b3
      4 U00b3							;---------------------------------------------------------------------------------------------------
      5 U00b3							; Looks at a square offset {1} to see if piece can move to it
      6 U00b3							; Adds the square to the movelist if it can
      7 U00b3							; Keeps moving in the same direction until it's blocked/off=board
      8 U00b3
      9 U00b3					      MAC	move_towards
     10 U00b3					      SUBROUTINE
     11 U00b3
     12 U00b3							; = 76 for single square (empty/take)
     13 U00b3
     14 U00b3					      lda	#0
     15 U00b3					      sta	capture
     16 U00b3
     17 U00b3					      ldx	currentSquare	; 3
     18 U00b3					      bne	.project	; 3   unconditional
     19 U00b3
     20 U00b3				   .empty     jsr	AddMove	; 57
     21 U00b3				   .project   ldy	ValidSquare+{1},x	; 4
     22 U00b3					      bmi	.invalid	; 2/3 off board!
     23 U00b3					      lda	Board,y	; 4   piece @ destination
     24 U00b3					      beq	.empty	; 2/3
     25 U00b3					      sta	capture
     26 U00b3					      eor	currentPiece	; 3
     27 U00b3					      bpl	.invalid	; 2/3 same colour
     28 U00b3					      jsr	AddMove	; 57  and exit
     29 U00b3
     30 U00b3				   .invalid
     31 U00b3
     32 U00b3					      ENDM
     33 U00b3
     34 U00b3
     35 U00b3							;---------------------------------------------------------------------------------------------------
     36 U00b3
     37 U00b3					      MAC	move_to
     38 U00b3					      SUBROUTINE
     39 U00b3
     40 U00b3					      ldy	ValidSquare+{1},x
     41 U00b3					      bmi	.invalid	; off board!
     42 U00b3					      lda	Board,y	; piece @ destination
     43 U00b3					      sta	capture
     44 U00b3					      beq	.squareEmpty
     45 U00b3					      eor	currentPiece
     46 U00b3					      bpl	.invalid	; same colour
     47 U00b3				   .squareEmpty jsr	AddMove
     48 U00b3				   .invalid
     49 U00b3
     50 U00b3					      ENDM
     51 U00b3
     52 U00b3
     53 U00b3							;---------------------------------------------------------------------------------------------------
     54 U00b3
     55 U00b3					      MAC	move_to_x
     56 U00b3					      ldx	currentSquare
     57 U00b3					      MOVE_TO	{1}
     58 U00b3					      ENDM
     59 U00b3
     60 U00b3
     61 U00b3							;---------------------------------------------------------------------------------------------------
     62 U00b3							; EOF
------- FILE ./chess.asm
    188 U00b3
------- FILE @3 STARTBANK.asm LEVEL 2 PASS 4
      0 U00b3					      include	"@3 STARTBANK.asm"	; MUST be first ROM bank
      1 U00b3				   _ORIGIN    SET	_FIRST_BANK
      2 U00b3
      3 U00b3							; This is the first (START UP) bank for the 3E+ cartridge/scheme
      4 U00b3							; This bank is guaranteed to be mapped to SLOT 3 by the hardware implementation.
      5 U00b3							; It must contain the reset vector for the game!
      6 U00b3							; It does NOT need to be switched in for the remainder of the game!
      7 U00b3
      8 U00b3							;---------------------------------------------------------------------------------------------------
      9 U00b3
      0 U00b3					      SLOT	3
      1 U00b3
      2 U00b3				  -	      IF	(3 < 0) || (3 > 3)
      3 U00b3				  -	      ECHO	"Illegal bank address/segment location", 3
      4 U00b3				  -	      ERR
      5 U00b3					      ENDIF
      6 U00b3
      7 U00b3				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8 U00b3				   _BANK_SLOT SET	3 * 64
      9 U00b3
      0 U00b3					      ROMBANK	STARTBANK
      1  0400 ????				      SEG	ROM_STARTBANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   STARTBANK_START SET	*
      6  0000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0000				   ROMBANK_STARTBANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0000				   _LAST_BANK SETSTR	STARTBANK
     10  0000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0000
     13  0000
     14  0000							;---------------------------------------------------------------------------------------------------
     15  0000
      0  0000					      DEF	StartCartridge
      1  0000				   SLOT_StartCartridge SET	_BANK_SLOT
      2  0000				   BANK_StartCartridge SET	SLOT_StartCartridge + _CURRENT_BANK
      3  0000				   StartCartridge
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartCartridge SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartCartridge
     17  0000
      0  0000					      CLEAN_START
      1  0000		       78		      sei
      2  0001		       d8		      cld
      3  0002
      4  0002					      IFNCONST	NO_ILLEGAL_OPCODES
      5  0002		       ab 00		      lxa	#0
      6  0004				  -	      ELSE
      7  0004				  -	      ldx	#0
      8  0004				  -	      txa
      9  0004					      ENDIF
     10  0004		       a8		      tay
     11  0005		       ca	   .CLEAR_STACK dex
     12  0006		       9a		      txs
     13  0007		       48		      pha
     14  0008		       d0 fb		      bne	.CLEAR_STACK
     15  000a
      0  000a					      JUMP	StartupBankReset	;@0
      1  000a				  -	      IF	SLOT_StartupBankReset == _BANK_SLOT
      2  000a				  -FNAME      SETSTR	StartupBankReset
      3  000a				  -	      ECHO	""
      4  000a				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  000a				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  000a				  -	      ERR
      7  000a					      ENDIF
      8  000a		       a9 01		      lda	#BANK_StartupBankReset
      9  000c		       85 3f		      sta	SET_BANK
     10  000e		       4c 00 f0 	      jmp	StartupBankReset
     20  0011
     21  0011							;---------------------------------------------------------------------------------------------------
     22  0011
     23  0011							; Lots of free space here
     24  0011
     25  0011							;---------------------------------------------------------------------------------------------------
     26  0011
 FREE BYTES IN STARTBANK =  $3eb
     27  0011					      ECHO	"FREE BYTES IN STARTBANK = ", $FFFC - *
     28  0011
     29  0011
     30  0011							;---------------------------------------------------------------------------------------------------
     31  0011
     32  0011							; The reset vectors
     33  0011							; these must live in the fixed bank (bank 0 in 3E+ format)
     34  0011
     35  03fc					      ORG	_FIRST_BANK + $3FC
     36  03fc					      RORG	$FFFC
      0  03fc					      DEF	InterruptVectors
      1  03fc				   SLOT_InterruptVectors SET	_BANK_SLOT
      2  03fc				   BANK_InterruptVectors SET	SLOT_InterruptVectors + _CURRENT_BANK
      3  03fc				   InterruptVectors
      4  03fc				   TEMPORARY_VAR SET	Overlay
      5  03fc				   TEMPORARY_OFFSET SET	0
      6  03fc				   VAR_BOUNDARY_InterruptVectors SET	TEMPORARY_OFFSET
      7  03fc				   FUNCTION_NAME SET	InterruptVectors
     38  03fc					      SUBROUTINE
     39  03fc
     40  03fc		       00 fc		      .word.w	StartCartridge	; RESET
     41  03fe		       00 fc		      .word.w	StartCartridge	; IRQ	      (not used)
     42  0400
     43  0400
     44  0400							;---------------------------------------------------------------------------------------------------
     45  0400
      0  0400					      END_BANK
      1  0400				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  0400				  -	      CHECK_RAM_BANK_SIZE
      3  0400					      ELSE
      0  0400					      CHECK_BANK_SIZE
      1  0400		       04 00	   .TEMP      =	* - _BANK_START
 ROM bank # 1 STARTBANK size = $400 free = -1
      2  0400					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  0400				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  0400				  -	      ERR
      6  0400					      ENDIF
      5  0400					      ENDIF
     47  0400
     48  0400							;---------------------------------------------------------------------------------------------------
     49  0400							;EOF
------- FILE ./chess.asm
    190  0400
------- FILE @0 HOME.asm LEVEL 2 PASS 4
      0  0400					      include	"@0 HOME.asm"
      1  0400							;---------------------------------------------------------------------------------------------------
      2  0400							; @0 HOME.asm
      3  0400
      4  0400							; Atari 2600 Chess
      5  0400							; Copyright (c) 2019-2020 Andrew Davie
      6  0400							; andrew@taswegian.com
      7  0400
      8  0400							;---------------------------------------------------------------------------------------------------
      9  0400
      0  0400					      SLOT	0
      1  0400
      2  0400				  -	      IF	(0 < 0) || (0 > 3)
      3  0400				  -	      ECHO	"Illegal bank address/segment location", 0
      4  0400				  -	      ERR
      5  0400					      ENDIF
      6  0400
      7  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      8  0400				   _BANK_SLOT SET	0 * 64
      9  0400
      0  0400					      ROMBANK	LOCKED_BANK
      1  07cb ????				      SEG	ROM_LOCKED_BANK
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   LOCKED_BANK_START SET	*
      6  0400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0400				   ROMBANK_LOCKED_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0400				   _LAST_BANK SETSTR	LOCKED_BANK
     10  0400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0400
     13  0400
     14  0400							;---------------------------------------------------------------------------------------------------
     15  0400
      0  0400					      DEF	StartupBankReset
      1  0400				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0400				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0400				   StartupBankReset
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	StartupBankReset
     17  0400					      SUBROUTINE
     18  0400
      0  0400					      VEND	StartupBankReset
      1  0400
      2  0400
      3  0400		       00 a7	   VAREND_StartupBankReset =	TEMPORARY_VAR
      4  0400
     20  0400
     21  0400
     22  0400							;CALL TitleScreen
     23  0400
      0  0400					      CALL	CartInit
      1  0400				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0400				  -FNAME      SETSTR	CartInit
      3  0400				  -	      ECHO	""
      4  0400				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0400				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0400				  -	      ERR
      7  0400					      ENDIF
      8  0400		       a9 42		      lda	#BANK_CartInit
      9  0402		       85 3f		      sta	SET_BANK
     10  0404		       20 00 f4 	      jsr	CartInit
      0  0407					      CALL	SetupBanks
      1  0407				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  0407				  -FNAME      SETSTR	SetupBanks
      3  0407				  -	      ECHO	""
      4  0407				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0407				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0407				  -	      ERR
      7  0407					      ENDIF
      8  0407		       a9 42		      lda	#BANK_SetupBanks
      9  0409		       85 3f		      sta	SET_BANK
     10  040b		       20 42 f4 	      jsr	SetupBanks
      0  040e					      CALL	InitialisePieceSquares
      1  040e				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  040e				  -FNAME      SETSTR	InitialisePieceSquares
      3  040e				  -	      ECHO	""
      4  040e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  040e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  040e				  -	      ERR
      7  040e					      ENDIF
      8  040e		       a9 42		      lda	#BANK_InitialisePieceSquares
      9  0410		       85 3f		      sta	SET_BANK
     10  0412		       20 f1 f5 	      jsr	InitialisePieceSquares
     27  0415
     28  0415
     29  0415		       20 3b f2 	      jsr	ListPlayerMoves	;@0
     30  0418
     31  0418
     32  0418				   .StartFrame
     33  0418
     34  0418
      0  0418					      CALL	InterlaceFrame
      1  0418				  -	      IF	SLOT_InterlaceFrame == _BANK_SLOT
      2  0418				  -FNAME      SETSTR	InterlaceFrame
      3  0418				  -	      ECHO	""
      4  0418				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0418				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0418				  -	      ERR
      7  0418					      ENDIF
      8  0418		       a9 d9		      lda	#BANK_InterlaceFrame
      9  041a		       85 3f		      sta	SET_BANK
     10  041c		       20 67 fc 	      jsr	InterlaceFrame
     36  041f
     37  041f
     38  041f		       a6 a5		      ldx	platform
     39  0421		       bd 86 f0 	      lda	time64a,x
     40  0424		       8d 96 02 	      sta	TIM64T
     41  0427
     42  0427							; LOTS OF PROCESSING TIME - USE IT
     43  0427
     44  0427					      IFCONST	RAINBOW
      0  0427					      CALL	RainBoard
      1  0427				  -	      IF	SLOT_RainBoard == _BANK_SLOT
      2  0427				  -FNAME      SETSTR	RainBoard
      3  0427				  -	      ECHO	""
      4  0427				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0427				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0427				  -	      ERR
      7  0427					      ENDIF
      8  0427		       a9 42		      lda	#BANK_RainBoard
      9  0429		       85 3f		      sta	SET_BANK
     10  042b		       20 7d f5 	      jsr	RainBoard
     46  042e					      ENDIF
     47  042e
      0  042e					      CALL	SayIt	;GameSpeak
      1  042e				  -	      IF	SLOT_SayIt == _BANK_SLOT
      2  042e				  -FNAME      SETSTR	SayIt
      3  042e				  -	      ECHO	""
      4  042e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  042e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  042e				  -	      ERR
      7  042e					      ENDIF
      8  042e		       a9 98		      lda	#BANK_SayIt
      9  0430		       85 3f		      sta	SET_BANK
     10  0432		       20 00 f8 	      jsr	SayIt
     49  0435		       20 99 f1 	      jsr	AiStateMachine
     50  0438
     51  0438
     52  0438				  -	      IF	ASSERTS
     53  0438				  -			; Catch timer expired already
     54  0438				  -			;		      bit TIMINT
     55  0438				  -			;.whoops	      bmi .whoops
     56  0438					      ENDIF
     57  0438
     58  0438
     59  0438		       2c 85 02    .wait      bit	TIMINT
     60  043b		       10 fb		      bpl	.wait
     61  043d
     62  043d
     63  043d							; START OF VISIBLE SCANLINES
     64  043d
     65  043d
      0  043d					      CALL	longD
      1  043d				  -	      IF	SLOT_longD == _BANK_SLOT
      2  043d				  -FNAME      SETSTR	longD
      3  043d				  -	      ECHO	""
      4  043d				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  043d				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  043d				  -	      ERR
      7  043d					      ENDIF
      8  043d		       a9 89		      lda	#BANK_longD
      9  043f		       85 3f		      sta	SET_BANK
     10  0441		       20 1d f8 	      jsr	longD
     67  0444
     68  0444
     69  0444		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     70  0446		       86 3e		      stx	SET_BANK_RAM
     71  0448		       20 a3 f8 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     72  044b
      0  044b					      CALL	tidySc
      1  044b				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  044b				  -FNAME      SETSTR	tidySc
      3  044b				  -	      ECHO	""
      4  044b				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  044b				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  044b				  -	      ERR
      7  044b					      ENDIF
      8  044b		       a9 89		      lda	#BANK_tidySc
      9  044d		       85 3f		      sta	SET_BANK
     10  044f		       20 04 f8 	      jsr	tidySc
     74  0452
     75  0452		       20 99 f1 	      jsr	AiStateMachine
     76  0455
     77  0455		       ad 84 02 	      lda	INTIM
     78  0458		       c9 14		      cmp	#20
     79  045a		       90 20		      bcc	.notnow
     80  045c
      0  045c					      CALL	PositionSprites
      1  045c				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  045c				  -FNAME      SETSTR	PositionSprites
      3  045c				  -	      ECHO	""
      4  045c				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  045c				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  045c				  -	      ERR
      7  045c					      ENDIF
      8  045c		       a9 45		      lda	#BANK_PositionSprites
      9  045e		       85 3f		      sta	SET_BANK
     10  0460		       20 00 f5 	      jsr	PositionSprites
     82  0463
     83  0463
     84  0463					      IF	1
     85  0463							; "draw" sprite shapes into row banks
     86  0463
     87  0463		       a2 07		      ldx	#7
     88  0465		       8a	   zapem      txa
     89  0466		       18		      clc
     90  0467		       69 80		      adc	#SLOT_DrawRow
     91  0469		       85 3e		      sta	SET_BANK_RAM
      0  046b					      CALL	WriteBlank	;@3
      1  046b				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  046b				  -FNAME      SETSTR	WriteBlank
      3  046b				  -	      ECHO	""
      4  046b				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  046b				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  046b				  -	      ERR
      7  046b					      ENDIF
      8  046b		       a9 da		      lda	#BANK_WriteBlank
      9  046d		       85 3f		      sta	SET_BANK
     10  046f		       20 0c fc 	      jsr	WriteBlank
     93  0472		       ca		      dex
     94  0473		       10 f0		      bpl	zapem
     95  0475
      0  0475					      CALL	WriteCursor	;@3
      1  0475				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  0475				  -FNAME      SETSTR	WriteCursor
      3  0475				  -	      ECHO	""
      4  0475				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0475				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0475				  -	      ERR
      7  0475					      ENDIF
      8  0475		       a9 da		      lda	#BANK_WriteCursor
      9  0477		       85 3f		      sta	SET_BANK
     10  0479		       20 35 fc 	      jsr	WriteCursor
     97  047c					      ENDIF
     98  047c
     99  047c				   .notnow
    100  047c
    101  047c		       2c 85 02    .waitTime  bit	TIMINT
    102  047f		       10 fb		      bpl	.waitTime
    103  0481		       85 42		      sta	WSYNC
    104  0483
    105  0483
    106  0483		       4c 18 f0 	      jmp	.StartFrame
    107  0486
    108  0486				   time64a
    109  0486		       2d 4e		      .byte.b	TIME_PART_1, TIME_PART_1_PAL
    110  0488
    111  0488							;---------------------------------------------------------------------------------------------------
    112  0488
      0  0488					      DEF	COMMON_VARS
      1  0488				   SLOT_COMMON_VARS SET	_BANK_SLOT
      2  0488				   BANK_COMMON_VARS SET	SLOT_COMMON_VARS + _CURRENT_BANK
      3  0488				   COMMON_VARS
      4  0488				   TEMPORARY_VAR SET	Overlay
      5  0488				   TEMPORARY_OFFSET SET	0
      6  0488				   VAR_BOUNDARY_COMMON_VARS SET	TEMPORARY_OFFSET
      7  0488				   FUNCTION_NAME SET	COMMON_VARS
    114  0488
      0  0488					      VAR	__thinkbar, 1
      1  0488		       00 a7	   __thinkbar =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__thinkbar
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
      0  0488					      VAR	__toggle, 1
      1  0488		       00 a8	   __toggle   =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__toggle
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
    117  0488
      0  0488					      VAR	__bestMove, 1
      1  0488		       00 a9	   __bestMove =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__bestMove
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
      0  0488					      VAR	__alpha, 2
      1  0488		       00 aa	   __alpha    =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__alpha
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
      0  0488					      VAR	__beta, 2
      1  0488		       00 ac	   __beta     =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__beta
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
      0  0488					      VAR	__negaMax, 2
      1  0488		       00 ae	   __negaMax  =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__negaMax
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
      0  0488					      VAR	__value, 2
      1  0488		       00 b0	   __value    =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__value
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
    123  0488
      0  0488					      VAR	__quiesceCapOnly, 1
      1  0488		       00 b2	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__quiesceCapOnly
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
    125  0488
      0  0488					      VAR	__originalPiece, 1
      1  0488		       00 b3	   __originalPiece =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__originalPiece
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
      0  0488					      VAR	__capturedPiece, 1
      1  0488		       00 b4	   __capturedPiece =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	__capturedPiece
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
    128  0488
    129  0488
      0  0488					      VAR	testzp, 2
      1  0488		       00 b5	   testzp     =	TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0488
      4  0488				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0488				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0488				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0488					      ENDIF
      8  0488				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0488				  -VNAME      SETSTR	testzp
     10  0488				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0488				  -	      ERR
     12  0488					      ENDIF
      0  0488					      VEND	COMMON_VARS
      1  0488
      2  0488
      3  0488		       00 b7	   VAREND_COMMON_VARS =	TEMPORARY_VAR
      4  0488
    132  0488
    133  0488
    134  0488							;---------------------------------------------------------------------------------------------------
    135  0488
      0  0488					      DEF	ThinkBar
      1  0488				   SLOT_ThinkBar SET	_BANK_SLOT
      2  0488				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  0488				   ThinkBar
      4  0488				   TEMPORARY_VAR SET	Overlay
      5  0488				   TEMPORARY_OFFSET SET	0
      6  0488				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  0488				   FUNCTION_NAME SET	ThinkBar
    137  0488					      SUBROUTINE
    138  0488
      0  0488					      REF	COMMON_VARS
      1  0488					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0488					      ENDIF
      0  0488					      REF	negaMax	;✅
      1  0488					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0488				   TEMPORARY_VAR SET	VAREND_negaMax
      3  0488					      ENDIF
      0  0488					      REF	quiesce	;✅
      1  0488				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0488				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0488					      ENDIF
    142  0488
      0  0488					      VEND	ThinkBar
      1  0488
      2  0488
      3  0488		       00 b9	   VAREND_ThinkBar =	TEMPORARY_VAR
      4  0488
    144  0488
    145  0488
    146  0488
    147  0488
    148  0488
    149  0488							; Check timer!
    150  0488
    151  0488				  -	      IF	0
    152  0488				  -	      lda	INTIM
    153  0488				  -	      bpl	.notick
    154  0488				  -	      lda	#127
    155  0488				  -	      sta	T1024T
    156  0488				  -	      inc	testzp
    157  0488				  -			;bne .notick
    158  0488				  -	      inc	testzp+1
    159  0488				  -
    160  0488				  -	      lda	testzp+1
    161  0488				  -	      asl
    162  0488				  -	      sta	COLUBK
    163  0488				  -
    164  0488				  -
    165  0488				  -
    166  0488				  -.notick
    167  0488					      ENDIF
    168  0488
    169  0488
    170  0488				  -	      IF	DIAGNOSTICS
    171  0488				  -
    172  0488				  -	      inc	positionCount
    173  0488				  -	      bne	.p1
    174  0488				  -	      inc	positionCount+1
    175  0488				  -	      bne	.p1
    176  0488				  -	      inc	positionCount+2
    177  0488				  -.p1
    178  0488					      ENDIF
    179  0488
    180  0488							; The 'thinkbar' pattern...
    181  0488
    182  0488		       a9 00		      lda	#0
    183  048a		       a4 4c		      ldy	INPT4
    184  048c		       30 13		      bmi	.doThink
    185  048e
    186  048e		       e6 a7		      inc	__thinkbar
    187  0490		       a5 a7		      lda	__thinkbar
    188  0492		       29 0f		      and	#15
    189  0494		       a8		      tay
    190  0495		       a5 82		      lda	rnd
    191  0497		       29 06		      and	#6
    192  0499		       19 a8 f0 	      ora	TBcol,y
    193  049c		       85 48		      sta	COLUPF
    194  049e
    195  049e		       b9 b8 f0 	      lda	SynapsePattern,y
    196  04a1		       85 4f	   .doThink   sta	PF2
    197  04a3		       85 4e		      sta	PF1
    198  04a5		       85 4d		      sta	PF0
    199  04a7		       60		      rts
    200  04a8
    201  04a8
    202  04a8				   TBcol
    203  04a8				   .TBC       SET	2
    204  04a8					      REPEAT	16
    205  04a8		       02		      .byte.b	.TBC
    206  04a8				   .TBC       SET	.TBC + 16
    204  04a8					      REPEND
    205  04a9		       12		      .byte.b	.TBC
    206  04a9				   .TBC       SET	.TBC + 16
    204  04a9					      REPEND
    205  04aa		       22		      .byte.b	.TBC
    206  04aa				   .TBC       SET	.TBC + 16
    204  04aa					      REPEND
    205  04ab		       32		      .byte.b	.TBC
    206  04ab				   .TBC       SET	.TBC + 16
    204  04ab					      REPEND
    205  04ac		       42		      .byte.b	.TBC
    206  04ac				   .TBC       SET	.TBC + 16
    204  04ac					      REPEND
    205  04ad		       52		      .byte.b	.TBC
    206  04ad				   .TBC       SET	.TBC + 16
    204  04ad					      REPEND
    205  04ae		       62		      .byte.b	.TBC
    206  04ae				   .TBC       SET	.TBC + 16
    204  04ae					      REPEND
    205  04af		       72		      .byte.b	.TBC
    206  04af				   .TBC       SET	.TBC + 16
    204  04af					      REPEND
    205  04b0		       82		      .byte.b	.TBC
    206  04b0				   .TBC       SET	.TBC + 16
    204  04b0					      REPEND
    205  04b1		       92		      .byte.b	.TBC
    206  04b1				   .TBC       SET	.TBC + 16
    204  04b1					      REPEND
    205  04b2		       a2		      .byte.b	.TBC
    206  04b2				   .TBC       SET	.TBC + 16
    204  04b2					      REPEND
    205  04b3		       b2		      .byte.b	.TBC
    206  04b3				   .TBC       SET	.TBC + 16
    204  04b3					      REPEND
    205  04b4		       c2		      .byte.b	.TBC
    206  04b4				   .TBC       SET	.TBC + 16
    204  04b4					      REPEND
    205  04b5		       d2		      .byte.b	.TBC
    206  04b5				   .TBC       SET	.TBC + 16
    204  04b5					      REPEND
    205  04b6		       e2		      .byte.b	.TBC
    206  04b6				   .TBC       SET	.TBC + 16
    204  04b6					      REPEND
    205  04b7		       f2		      .byte.b	.TBC
    206  04b7				   .TBC       SET	.TBC + 16
    207  04b8					      REPEND
    208  04b8
    209  04b8				   SynapsePattern
    210  04b8
    211  04b8		       c1		      .byte.b	%11000001
    212  04b9		       60		      .byte.b	%01100000
    213  04ba		       30		      .byte.b	%00110000
    214  04bb		       18		      .byte.b	%00011000
    215  04bc		       0c		      .byte.b	%00001100
    216  04bd		       06		      .byte.b	%00000110
    217  04be		       83		      .byte.b	%10000011
    218  04bf		       c1		      .byte.b	%11000001
    219  04c0
    220  04c0		       83		      .byte.b	%10000011
    221  04c1		       06		      .byte.b	%00000110
    222  04c2		       0c		      .byte.b	%00001100
    223  04c3		       18		      .byte.b	%00011000
    224  04c4		       30		      .byte.b	%00110000
    225  04c5		       60		      .byte.b	%01100000
    226  04c6		       c1		      .byte.b	%11000001
    227  04c7		       83		      .byte.b	%10000011
    228  04c8
    229  04c8
    230  04c8							;---------------------------------------------------------------------------------------------------
    231  04c8
      0  04c8					      DEF	CopySinglePiece
      1  04c8				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  04c8				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  04c8				   CopySinglePiece
      4  04c8				   TEMPORARY_VAR SET	Overlay
      5  04c8				   TEMPORARY_OFFSET SET	0
      6  04c8				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  04c8				   FUNCTION_NAME SET	CopySinglePiece
    233  04c8					      SUBROUTINE
    234  04c8
    235  04c8							; Common vairables...
    236  04c8							; REQUIRES calling routines to "REF Variable_PieceShapeBuffer"
    237  04c8
      0  04c8					      TIMING	CopySinglePiece, (2600)
      1  04c8
      2  04c8		       00 29	   SPEEDOF_CopySinglePiece =	((2600)/64) + 1
      3  04c8
    239  04c8
      0  04c8					      REF	Variable_PieceShapeBuffer
      1  04c8					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  04c8				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  04c8					      ENDIF
      0  04c8					      REF	showMoveCaptures	;✅
      1  04c8				  -	      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  04c8					      ENDIF
      0  04c8					      REF	aiDrawEntireBoard	;✅
      1  04c8				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  04c8					      ENDIF
      0  04c8					      REF	aiDrawPart2	;✅
      1  04c8				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  04c8					      ENDIF
      0  04c8					      REF	aiMarchB	;✅
      1  04c8				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  04c8					      ENDIF
      0  04c8					      REF	aiFlashComputerMove	;✅
      1  04c8				  -	      IF	VAREND_aiFlashComputerMove > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiFlashComputerMove
      3  04c8					      ENDIF
      0  04c8					      REF	aiSelectDestinationSquare	;✅
      1  04c8				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  04c8					      ENDIF
      0  04c8					      REF	aiMarchA2	;✅
      1  04c8				  -	      IF	VAREND_aiMarchA2 > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiMarchA2
      3  04c8					      ENDIF
      0  04c8					      REF	aiMarchB2	;✅
      1  04c8				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  04c8					      ENDIF
      0  04c8					      REF	aiWriteStartPieceBlank	;✅
      1  04c8				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  04c8					      ENDIF
      0  04c8					      REF	aiChoosePromotePiece	;✅
      1  04c8				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  04c8					      ENDIF
      0  04c8					      REF	aiMarchToTargetB	;✅
      1  04c8				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  04c8					      ENDIF
      0  04c8					      REF	aiPromotePawnStart	;✅
      1  04c8				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  04c8					      ENDIF
      0  04c8					      REF	aiFinalFlash	;✅
      1  04c8				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  04c8					      ENDIF
    254  04c8
    255  04c8
      0  04c8					      VEND	CopySinglePiece
      1  04c8
      2  04c8
      3  04c8		       00 ef	   VAREND_CopySinglePiece =	TEMPORARY_VAR
      4  04c8
    257  04c8
    258  04c8							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    259  04c8							; ALSO CAN'T USE IN THIS ROUTINE
    260  04c8							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    261  04c8							; @2150 max
    262  04c8							; = 33 TIM64T
    263  04c8
      0  04c8					      CALL	CopySetup	;@2
      1  04c8				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  04c8				  -FNAME      SETSTR	CopySetup
      3  04c8				  -	      ECHO	""
      4  04c8				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  04c8				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  04c8				  -	      ERR
      7  04c8					      ENDIF
      8  04c8		       a9 89		      lda	#BANK_CopySetup
      9  04ca		       85 3f		      sta	SET_BANK
     10  04cc		       20 9f f8 	      jsr	CopySetup
    265  04cf
    266  04cf
      0  04cf					      DEF	InterceptMarkerCopy
      1  04cf				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  04cf				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  04cf				   InterceptMarkerCopy
      4  04cf				   TEMPORARY_VAR SET	Overlay
      5  04cf				   TEMPORARY_OFFSET SET	0
      6  04cf				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  04cf				   FUNCTION_NAME SET	InterceptMarkerCopy
    268  04cf					      SUBROUTINE
    269  04cf
      0  04cf					      REF	CopySinglePiece	;✅
      1  04cf					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  04cf				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  04cf					      ENDIF
      0  04cf					      REF	showPromoteOptions	;✅
      1  04cf				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  04cf				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  04cf					      ENDIF
      0  04cf					      REF	showMoveOptions	;✅
      1  04cf				  -	      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  04cf				  -TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  04cf					      ENDIF
    273  04cf
      0  04cf					      VAR	__psb, 2
      1  04cf		       00 ef	   __psb      =	TEMPORARY_VAR
      2  04cf				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  04cf
      4  04cf				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  04cf					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  04cf				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  04cf					      ENDIF
      8  04cf				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  04cf				  -VNAME      SETSTR	__psb
     10  04cf				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  04cf				  -	      ERR
     12  04cf					      ENDIF
    275  04cf
      0  04cf					      VEND	InterceptMarkerCopy
      1  04cf
      2  04cf
      3  04cf		       00 f1	   VAREND_InterceptMarkerCopy =	TEMPORARY_VAR
      4  04cf
    277  04cf
    278  04cf							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    279  04cf							; y = piece index
    280  04cf
    281  04cf		       a9 89		      lda	#BANK_PIECE_VECTOR_BANK
    282  04d1		       85 3f		      sta	SET_BANK	;@2
    283  04d3
    284  04d3		       b9 e9 f9 	      lda	PIECE_VECTOR_LO,y
    285  04d6		       85 ef		      sta	__psb
    286  04d8		       b9 79 fa 	      lda	PIECE_VECTOR_HI,y
    287  04db		       85 f0		      sta	__psb+1
    288  04dd		       b9 09 fb 	      lda	PIECE_VECTOR_BANK,y
    289  04e0		       85 3f		      sta	SET_BANK	;@2
    290  04e2
    291  04e2		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    292  04e4		       b1 ef	   .copy      lda	(__psb),y
    293  04e6		       99 a7 00 	      sta	__pieceShapeBuffer,y
    294  04e9		       88		      dey
    295  04ea		       10 f8		      bpl	.copy
    296  04ec
    297  04ec		       a5 81		      lda	squareToDraw
    298  04ee		       38		      sec
    299  04ef		       a2 0a		      ldx	#10
    300  04f1		       e9 0a	   .sub10     sbc	#10
    301  04f3		       ca		      dex
    302  04f4		       b0 fb		      bcs	.sub10
    303  04f6
    304  04f6		       69 08		      adc	#8
    305  04f8		       c9 04		      cmp	#4	; CS = right side of screen
    306  04fa
    307  04fa		       8a		      txa
    308  04fb		       09 80		      ora	#[SLOT2]
    309  04fd		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    310  04ff
    311  04ff		       20 3b f3 	      jsr	CopyPieceToRowBitmap	;@3
    312  0502		       60		      rts
    313  0503
    314  0503
    315  0503							;---------------------------------------------------------------------------------------------------
    316  0503
    317  0503				   P	      SET	0
    318  0503					      MAC	ain
    319  0503				   AI_{1}     SET	P
    320  0503				   P	      SET	P+1
    321  0503					      ENDM
    322  0503
    323  0503					      MAC	lo
    324  0503					      .byte	<ai{1}
    325  0503					      ENDM
    326  0503
    327  0503					      MAC	hi
    328  0503					      .byte	>ai{1}
    329  0503					      ENDM
    330  0503
    331  0503					      MAC	bk
    332  0503					      .byte	BANK_ai{1}
    333  0503					      ENDM
    334  0503
    335  0503
    336  0503		       00 28	   ONCEPERFRAME =	40
    337  0503
    338  0503					      MAC	tabdef
    339  0503
    340  0503					      {1}	FlashComputerMove	; 0
    341  0503					      {1}	BeginSelectMovePhase	; 1
    342  0503					      {1}	SelectStartSquare	; 2
    343  0503					      {1}	StartSquareSelected	; 3
    344  0503					      {1}	DrawMoves	; 4
    345  0503					      {1}	ShowMoveCaptures	; 5
    346  0503					      {1}	SlowFlash	; 6
    347  0503					      {1}	UnDrawTargetSquares	; 7
    348  0503					      {1}	SelectDestinationSquare	; 8
    349  0503					      {1}	Quiescent	; 9
    350  0503					      {1}	ReselectDebounce	; 10
    351  0503					      {1}	StartMoveGen	; 11
    352  0503					      {1}	StepMoveGen	; 12
    353  0503					      {1}	StartClearBoard	; 13
    354  0503					      {1}	ClearEachRow	; 14
    355  0503					      {1}	DrawEntireBoard	; 15
    356  0503					      {1}	DrawPart2	; 16
    357  0503					      {1}	DrawPart3	; 17
    358  0503					      {1}	GenerateMoves	; 18
    359  0503					      {1}	ComputerMove	; 19
    360  0503					      {1}	MoveIsSelected	; 20
    361  0503					      {1}	WriteStartPieceBlank	; 21
    362  0503					      {1}	MarchToTargetA	; 22
    363  0503					      {1}	MarchA2	; 23
    364  0503					      {1}	MarchB	; 24
    365  0503					      {1}	MarchToTargetB	; 25
    366  0503					      {1}	MarchB2	; 26
    367  0503					      {1}	FinalFlash	; 27
    368  0503					      {1}	SpecialMoveFixup	; 28
    369  0503					      {1}	InCheckBackup	; 29
    370  0503					      {1}	InCheckDelay	; 30
    371  0503					      {1}	PromotePawnStart	; 31
    372  0503					      {1}	RollPromotionPiece	; 32
    373  0503					      {1}	ChoosePromotePiece	; 33
    374  0503					      {1}	ChooseDebounce	; 34
    375  0503					      {1}	CheckMate	; 35
    376  0503					      {1}	Draw	; 36
    377  0503					      {1}	DelayAfterMove	; 37
    378  0503					      {1}	DelayAfterMove2	; 38
    379  0503					      {1}	DelayAfterPlaced	; 39
    380  0503					      {1}	DelayAfterPlaced2	; 40
    381  0503					      {1}	EPHandler	; 41
    382  0503					      {1}	EPFlash	; 42
    383  0503					      {1}	DebounceSelect	; 43
    384  0503					      {1}	InCheckBackupStart	; 44
    385  0503					      {1}	RestoreBitmaps	; 45
    386  0503					      {1}	WaitBitmap	; 46
    387  0503					      {1}	MaskBitmapBackground	; 47
    388  0503					      {1}	DrawBitmap2	; 48
    389  0503					      {1}	DrawBitmap3	; 49
    390  0503
    391  0503					      ENDM		; {1} = macro to use
    392  0503
      0  0503					      TABDEF	AIN
      1  0503
      0  0503					      AIN	FlashComputerMove
      1  0503				   AI_FlashComputerMove SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	BeginSelectMovePhase
      1  0503				   AI_BeginSelectMovePhase SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	SelectStartSquare
      1  0503				   AI_SelectStartSquare SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	StartSquareSelected
      1  0503				   AI_StartSquareSelected SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DrawMoves
      1  0503				   AI_DrawMoves SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	ShowMoveCaptures
      1  0503				   AI_ShowMoveCaptures SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	SlowFlash
      1  0503				   AI_SlowFlash SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	UnDrawTargetSquares
      1  0503				   AI_UnDrawTargetSquares SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	SelectDestinationSquare
      1  0503				   AI_SelectDestinationSquare SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	Quiescent
      1  0503				   AI_Quiescent SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	ReselectDebounce
      1  0503				   AI_ReselectDebounce SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	StartMoveGen
      1  0503				   AI_StartMoveGen SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	StepMoveGen
      1  0503				   AI_StepMoveGen SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	StartClearBoard
      1  0503				   AI_StartClearBoard SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	ClearEachRow
      1  0503				   AI_ClearEachRow SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DrawEntireBoard
      1  0503				   AI_DrawEntireBoard SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DrawPart2
      1  0503				   AI_DrawPart2 SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DrawPart3
      1  0503				   AI_DrawPart3 SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	GenerateMoves
      1  0503				   AI_GenerateMoves SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	ComputerMove
      1  0503				   AI_ComputerMove SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	MoveIsSelected
      1  0503				   AI_MoveIsSelected SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	WriteStartPieceBlank
      1  0503				   AI_WriteStartPieceBlank SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	MarchToTargetA
      1  0503				   AI_MarchToTargetA SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	MarchA2
      1  0503				   AI_MarchA2 SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	MarchB
      1  0503				   AI_MarchB  SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	MarchToTargetB
      1  0503				   AI_MarchToTargetB SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	MarchB2
      1  0503				   AI_MarchB2 SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	FinalFlash
      1  0503				   AI_FinalFlash SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	SpecialMoveFixup
      1  0503				   AI_SpecialMoveFixup SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	InCheckBackup
      1  0503				   AI_InCheckBackup SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	InCheckDelay
      1  0503				   AI_InCheckDelay SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	PromotePawnStart
      1  0503				   AI_PromotePawnStart SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	RollPromotionPiece
      1  0503				   AI_RollPromotionPiece SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	ChoosePromotePiece
      1  0503				   AI_ChoosePromotePiece SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	ChooseDebounce
      1  0503				   AI_ChooseDebounce SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	CheckMate
      1  0503				   AI_CheckMate SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	Draw
      1  0503				   AI_Draw    SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DelayAfterMove
      1  0503				   AI_DelayAfterMove SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DelayAfterMove2
      1  0503				   AI_DelayAfterMove2 SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DelayAfterPlaced
      1  0503				   AI_DelayAfterPlaced SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DelayAfterPlaced2
      1  0503				   AI_DelayAfterPlaced2 SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	EPHandler
      1  0503				   AI_EPHandler SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	EPFlash
      1  0503				   AI_EPFlash SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DebounceSelect
      1  0503				   AI_DebounceSelect SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	InCheckBackupStart
      1  0503				   AI_InCheckBackupStart SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	RestoreBitmaps
      1  0503				   AI_RestoreBitmaps SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	WaitBitmap
      1  0503				   AI_WaitBitmap SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	MaskBitmapBackground
      1  0503				   AI_MaskBitmapBackground SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DrawBitmap2
      1  0503				   AI_DrawBitmap2 SET	P
      2  0503				   P	      SET	P+1
      0  0503					      AIN	DrawBitmap3
      1  0503				   AI_DrawBitmap3 SET	P
      2  0503				   P	      SET	P+1
     52  0503
    394  0503
      0  0503					      DEF	AiVectorLO
      1  0503				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  0503				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  0503				   AiVectorLO
      4  0503				   TEMPORARY_VAR SET	Overlay
      5  0503				   TEMPORARY_OFFSET SET	0
      6  0503				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  0503				   FUNCTION_NAME SET	AiVectorLO
      0  0503					      TABDEF	LO
      1  0503
      0  0503					      LO	FlashComputerMove
      1  0503		       7b		      .byte.b	<aiFlashComputerMove
      0  0504					      LO	BeginSelectMovePhase
      1  0504		       57		      .byte.b	<aiBeginSelectMovePhase
      0  0505					      LO	SelectStartSquare
      1  0505		       b4		      .byte.b	<aiSelectStartSquare
      0  0506					      LO	StartSquareSelected
      1  0506		       b4		      .byte.b	<aiStartSquareSelected
      0  0507					      LO	DrawMoves
      1  0507		       1c		      .byte.b	<aiDrawMoves
      0  0508					      LO	ShowMoveCaptures
      1  0508		       10		      .byte.b	<aiShowMoveCaptures
      0  0509					      LO	SlowFlash
      1  0509		       36		      .byte.b	<aiSlowFlash
      0  050a					      LO	UnDrawTargetSquares
      1  050a		       e6		      .byte.b	<aiUnDrawTargetSquares
      0  050b					      LO	SelectDestinationSquare
      1  050b		       5f		      .byte.b	<aiSelectDestinationSquare
      0  050c					      LO	Quiescent
      1  050c		       6c		      .byte.b	<aiQuiescent
      0  050d					      LO	ReselectDebounce
      1  050d		       14		      .byte.b	<aiReselectDebounce
      0  050e					      LO	StartMoveGen
      1  050e		       00		      .byte.b	<aiStartMoveGen
      0  050f					      LO	StepMoveGen
      1  050f		       cf		      .byte.b	<aiStepMoveGen
      0  0510					      LO	StartClearBoard
      1  0510		       31		      .byte.b	<aiStartClearBoard
      0  0511					      LO	ClearEachRow
      1  0511		       3e		      .byte.b	<aiClearEachRow
      0  0512					      LO	DrawEntireBoard
      1  0512		       f7		      .byte.b	<aiDrawEntireBoard
      0  0513					      LO	DrawPart2
      1  0513		       2b		      .byte.b	<aiDrawPart2
      0  0514					      LO	DrawPart3
      1  0514		       2e		      .byte.b	<aiDrawPart3
      0  0515					      LO	GenerateMoves
      1  0515		       9a		      .byte.b	<aiGenerateMoves
      0  0516					      LO	ComputerMove
      1  0516		       00		      .byte.b	<aiComputerMove
      0  0517					      LO	MoveIsSelected
      1  0517		       59		      .byte.b	<aiMoveIsSelected
      0  0518					      LO	WriteStartPieceBlank
      1  0518		       d7		      .byte.b	<aiWriteStartPieceBlank
      0  0519					      LO	MarchToTargetA
      1  0519		       38		      .byte.b	<aiMarchToTargetA
      0  051a					      LO	MarchA2
      1  051a		       90		      .byte.b	<aiMarchA2
      0  051b					      LO	MarchB
      1  051b		       48		      .byte.b	<aiMarchB
      0  051c					      LO	MarchToTargetB
      1  051c		       54		      .byte.b	<aiMarchToTargetB
      0  051d					      LO	MarchB2
      1  051d		       bd		      .byte.b	<aiMarchB2
      0  051e					      LO	FinalFlash
      1  051e		       92		      .byte.b	<aiFinalFlash
      0  051f					      LO	SpecialMoveFixup
      1  051f		       92		      .byte.b	<aiSpecialMoveFixup
      0  0520					      LO	InCheckBackup
      1  0520		       0e		      .byte.b	<aiInCheckBackup
      0  0521					      LO	InCheckDelay
      1  0521		       4a		      .byte.b	<aiInCheckDelay
      0  0522					      LO	PromotePawnStart
      1  0522		       76		      .byte.b	<aiPromotePawnStart
      0  0523					      LO	RollPromotionPiece
      1  0523		       c0		      .byte.b	<aiRollPromotionPiece
      0  0524					      LO	ChoosePromotePiece
      1  0524		       13		      .byte.b	<aiChoosePromotePiece
      0  0525					      LO	ChooseDebounce
      1  0525		       00		      .byte.b	<aiChooseDebounce
      0  0526					      LO	CheckMate
      1  0526		       62		      .byte.b	<aiCheckMate
      0  0527					      LO	Draw
      1  0527		       58		      .byte.b	<aiDraw
      0  0528					      LO	DelayAfterMove
      1  0528		       1d		      .byte.b	<aiDelayAfterMove
      0  0529					      LO	DelayAfterMove2
      1  0529		       26		      .byte.b	<aiDelayAfterMove2
      0  052a					      LO	DelayAfterPlaced
      1  052a		       2f		      .byte.b	<aiDelayAfterPlaced
      0  052b					      LO	DelayAfterPlaced2
      1  052b		       3f		      .byte.b	<aiDelayAfterPlaced2
      0  052c					      LO	EPHandler
      1  052c		       01		      .byte.b	<aiEPHandler
      0  052d					      LO	EPFlash
      1  052d		       aa		      .byte.b	<aiEPFlash
      0  052e					      LO	DebounceSelect
      1  052e		       fd		      .byte.b	<aiDebounceSelect
      0  052f					      LO	InCheckBackupStart
      1  052f		       05		      .byte.b	<aiInCheckBackupStart
      0  0530					      LO	RestoreBitmaps
      1  0530		       33		      .byte.b	<aiRestoreBitmaps
      0  0531					      LO	WaitBitmap
      1  0531		       22		      .byte.b	<aiWaitBitmap
      0  0532					      LO	MaskBitmapBackground
      1  0532		       85		      .byte.b	<aiMaskBitmapBackground
      0  0533					      LO	DrawBitmap2
      1  0533		       cb		      .byte.b	<aiDrawBitmap2
      0  0534					      LO	DrawBitmap3
      1  0534		       f2		      .byte.b	<aiDrawBitmap3
     52  0535
    397  0535
      0  0535					      DEF	AiVectorHI
      1  0535				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  0535				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  0535				   AiVectorHI
      4  0535				   TEMPORARY_VAR SET	Overlay
      5  0535				   TEMPORARY_OFFSET SET	0
      6  0535				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  0535				   FUNCTION_NAME SET	AiVectorHI
      0  0535					      TABDEF	HI
      1  0535
      0  0535					      HI	FlashComputerMove
      1  0535		       f4		      .byte.b	>aiFlashComputerMove
      0  0536					      HI	BeginSelectMovePhase
      1  0536		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0537					      HI	SelectStartSquare
      1  0537		       f4		      .byte.b	>aiSelectStartSquare
      0  0538					      HI	StartSquareSelected
      1  0538		       f5		      .byte.b	>aiStartSquareSelected
      0  0539					      HI	DrawMoves
      1  0539		       f5		      .byte.b	>aiDrawMoves
      0  053a					      HI	ShowMoveCaptures
      1  053a		       f6		      .byte.b	>aiShowMoveCaptures
      0  053b					      HI	SlowFlash
      1  053b		       f6		      .byte.b	>aiSlowFlash
      0  053c					      HI	UnDrawTargetSquares
      1  053c		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  053d					      HI	SelectDestinationSquare
      1  053d		       f6		      .byte.b	>aiSelectDestinationSquare
      0  053e					      HI	Quiescent
      1  053e		       f7		      .byte.b	>aiQuiescent
      0  053f					      HI	ReselectDebounce
      1  053f		       f4		      .byte.b	>aiReselectDebounce
      0  0540					      HI	StartMoveGen
      1  0540		       f4		      .byte.b	>aiStartMoveGen
      0  0541					      HI	StepMoveGen
      1  0541		       f4		      .byte.b	>aiStepMoveGen
      0  0542					      HI	StartClearBoard
      1  0542		       f8		      .byte.b	>aiStartClearBoard
      0  0543					      HI	ClearEachRow
      1  0543		       f8		      .byte.b	>aiClearEachRow
      0  0544					      HI	DrawEntireBoard
      1  0544		       f6		      .byte.b	>aiDrawEntireBoard
      0  0545					      HI	DrawPart2
      1  0545		       f7		      .byte.b	>aiDrawPart2
      0  0546					      HI	DrawPart3
      1  0546		       f7		      .byte.b	>aiDrawPart3
      0  0547					      HI	GenerateMoves
      1  0547		       f4		      .byte.b	>aiGenerateMoves
      0  0548					      HI	ComputerMove
      1  0548		       f4		      .byte.b	>aiComputerMove
      0  0549					      HI	MoveIsSelected
      1  0549		       f8		      .byte.b	>aiMoveIsSelected
      0  054a					      HI	WriteStartPieceBlank
      1  054a		       f5		      .byte.b	>aiWriteStartPieceBlank
      0  054b					      HI	MarchToTargetA
      1  054b		       f5		      .byte.b	>aiMarchToTargetA
      0  054c					      HI	MarchA2
      1  054c		       f7		      .byte.b	>aiMarchA2
      0  054d					      HI	MarchB
      1  054d		       f7		      .byte.b	>aiMarchB
      0  054e					      HI	MarchToTargetB
      1  054e		       f4		      .byte.b	>aiMarchToTargetB
      0  054f					      HI	MarchB2
      1  054f		       f7		      .byte.b	>aiMarchB2
      0  0550					      HI	FinalFlash
      1  0550		       f5		      .byte.b	>aiFinalFlash
      0  0551					      HI	SpecialMoveFixup
      1  0551		       f6		      .byte.b	>aiSpecialMoveFixup
      0  0552					      HI	InCheckBackup
      1  0552		       f4		      .byte.b	>aiInCheckBackup
      0  0553					      HI	InCheckDelay
      1  0553		       f4		      .byte.b	>aiInCheckDelay
      0  0554					      HI	PromotePawnStart
      1  0554		       f4		      .byte.b	>aiPromotePawnStart
      0  0555					      HI	RollPromotionPiece
      1  0555		       f6		      .byte.b	>aiRollPromotionPiece
      0  0556					      HI	ChoosePromotePiece
      1  0556		       f7		      .byte.b	>aiChoosePromotePiece
      0  0557					      HI	ChooseDebounce
      1  0557		       f4		      .byte.b	>aiChooseDebounce
      0  0558					      HI	CheckMate
      1  0558		       f7		      .byte.b	>aiCheckMate
      0  0559					      HI	Draw
      1  0559		       f7		      .byte.b	>aiDraw
      0  055a					      HI	DelayAfterMove
      1  055a		       f4		      .byte.b	>aiDelayAfterMove
      0  055b					      HI	DelayAfterMove2
      1  055b		       f4		      .byte.b	>aiDelayAfterMove2
      0  055c					      HI	DelayAfterPlaced
      1  055c		       f4		      .byte.b	>aiDelayAfterPlaced
      0  055d					      HI	DelayAfterPlaced2
      1  055d		       f4		      .byte.b	>aiDelayAfterPlaced2
      0  055e					      HI	EPHandler
      1  055e		       f6		      .byte.b	>aiEPHandler
      0  055f					      HI	EPFlash
      1  055f		       f6		      .byte.b	>aiEPFlash
      0  0560					      HI	DebounceSelect
      1  0560		       f4		      .byte.b	>aiDebounceSelect
      0  0561					      HI	InCheckBackupStart
      1  0561		       f4		      .byte.b	>aiInCheckBackupStart
      0  0562					      HI	RestoreBitmaps
      1  0562		       f4		      .byte.b	>aiRestoreBitmaps
      0  0563					      HI	WaitBitmap
      1  0563		       f4		      .byte.b	>aiWaitBitmap
      0  0564					      HI	MaskBitmapBackground
      1  0564		       fc		      .byte.b	>aiMaskBitmapBackground
      0  0565					      HI	DrawBitmap2
      1  0565		       fc		      .byte.b	>aiDrawBitmap2
      0  0566					      HI	DrawBitmap3
      1  0566		       fc		      .byte.b	>aiDrawBitmap3
     52  0567
    400  0567
      0  0567					      DEF	AiVectorBANK
      1  0567				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  0567				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  0567				   AiVectorBANK
      4  0567				   TEMPORARY_VAR SET	Overlay
      5  0567				   TEMPORARY_OFFSET SET	0
      6  0567				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  0567				   FUNCTION_NAME SET	AiVectorBANK
      0  0567					      TABDEF	BK
      1  0567
      0  0567					      BK	FlashComputerMove
      1  0567		       44		      .byte.b	BANK_aiFlashComputerMove
      0  0568					      BK	BeginSelectMovePhase
      1  0568		       44		      .byte.b	BANK_aiBeginSelectMovePhase
      0  0569					      BK	SelectStartSquare
      1  0569		       44		      .byte.b	BANK_aiSelectStartSquare
      0  056a					      BK	StartSquareSelected
      1  056a		       45		      .byte.b	BANK_aiStartSquareSelected
      0  056b					      BK	DrawMoves
      1  056b		       44		      .byte.b	BANK_aiDrawMoves
      0  056c					      BK	ShowMoveCaptures
      1  056c		       44		      .byte.b	BANK_aiShowMoveCaptures
      0  056d					      BK	SlowFlash
      1  056d		       44		      .byte.b	BANK_aiSlowFlash
      0  056e					      BK	UnDrawTargetSquares
      1  056e		       44		      .byte.b	BANK_aiUnDrawTargetSquares
      0  056f					      BK	SelectDestinationSquare
      1  056f		       44		      .byte.b	BANK_aiSelectDestinationSquare
      0  0570					      BK	Quiescent
      1  0570		       42		      .byte.b	BANK_aiQuiescent
      0  0571					      BK	ReselectDebounce
      1  0571		       45		      .byte.b	BANK_aiReselectDebounce
      0  0572					      BK	StartMoveGen
      1  0572		       44		      .byte.b	BANK_aiStartMoveGen
      0  0573					      BK	StepMoveGen
      1  0573		       45		      .byte.b	BANK_aiStepMoveGen
      0  0574					      BK	StartClearBoard
      1  0574		       89		      .byte.b	BANK_aiStartClearBoard
      0  0575					      BK	ClearEachRow
      1  0575		       89		      .byte.b	BANK_aiClearEachRow
      0  0576					      BK	DrawEntireBoard
      1  0576		       42		      .byte.b	BANK_aiDrawEntireBoard
      0  0577					      BK	DrawPart2
      1  0577		       42		      .byte.b	BANK_aiDrawPart2
      0  0578					      BK	DrawPart3
      1  0578		       42		      .byte.b	BANK_aiDrawPart3
      0  0579					      BK	GenerateMoves
      1  0579		       45		      .byte.b	BANK_aiGenerateMoves
      0  057a					      BK	ComputerMove
      1  057a		       43		      .byte.b	BANK_aiComputerMove
      0  057b					      BK	MoveIsSelected
      1  057b		       89		      .byte.b	BANK_aiMoveIsSelected
      0  057c					      BK	WriteStartPieceBlank
      1  057c		       45		      .byte.b	BANK_aiWriteStartPieceBlank
      0  057d					      BK	MarchToTargetA
      1  057d		       45		      .byte.b	BANK_aiMarchToTargetA
      0  057e					      BK	MarchA2
      1  057e		       44		      .byte.b	BANK_aiMarchA2
      0  057f					      BK	MarchB
      1  057f		       42		      .byte.b	BANK_aiMarchB
      0  0580					      BK	MarchToTargetB
      1  0580		       45		      .byte.b	BANK_aiMarchToTargetB
      0  0581					      BK	MarchB2
      1  0581		       44		      .byte.b	BANK_aiMarchB2
      0  0582					      BK	FinalFlash
      1  0582		       45		      .byte.b	BANK_aiFinalFlash
      0  0583					      BK	SpecialMoveFixup
      1  0583		       42		      .byte.b	BANK_aiSpecialMoveFixup
      0  0584					      BK	InCheckBackup
      1  0584		       44		      .byte.b	BANK_aiInCheckBackup
      0  0585					      BK	InCheckDelay
      1  0585		       44		      .byte.b	BANK_aiInCheckDelay
      0  0586					      BK	PromotePawnStart
      1  0586		       45		      .byte.b	BANK_aiPromotePawnStart
      0  0587					      BK	RollPromotionPiece
      1  0587		       44		      .byte.b	BANK_aiRollPromotionPiece
      0  0588					      BK	ChoosePromotePiece
      1  0588		       44		      .byte.b	BANK_aiChoosePromotePiece
      0  0589					      BK	ChooseDebounce
      1  0589		       45		      .byte.b	BANK_aiChooseDebounce
      0  058a					      BK	CheckMate
      1  058a		       42		      .byte.b	BANK_aiCheckMate
      0  058b					      BK	Draw
      1  058b		       42		      .byte.b	BANK_aiDraw
      0  058c					      BK	DelayAfterMove
      1  058c		       45		      .byte.b	BANK_aiDelayAfterMove
      0  058d					      BK	DelayAfterMove2
      1  058d		       45		      .byte.b	BANK_aiDelayAfterMove2
      0  058e					      BK	DelayAfterPlaced
      1  058e		       45		      .byte.b	BANK_aiDelayAfterPlaced
      0  058f					      BK	DelayAfterPlaced2
      1  058f		       45		      .byte.b	BANK_aiDelayAfterPlaced2
      0  0590					      BK	EPHandler
      1  0590		       45		      .byte.b	BANK_aiEPHandler
      0  0591					      BK	EPFlash
      1  0591		       42		      .byte.b	BANK_aiEPFlash
      0  0592					      BK	DebounceSelect
      1  0592		       44		      .byte.b	BANK_aiDebounceSelect
      0  0593					      BK	InCheckBackupStart
      1  0593		       44		      .byte.b	BANK_aiInCheckBackupStart
      0  0594					      BK	RestoreBitmaps
      1  0594		       44		      .byte.b	BANK_aiRestoreBitmaps
      0  0595					      BK	WaitBitmap
      1  0595		       44		      .byte.b	BANK_aiWaitBitmap
      0  0596					      BK	MaskBitmapBackground
      1  0596		       da		      .byte.b	BANK_aiMaskBitmapBackground
      0  0597					      BK	DrawBitmap2
      1  0597		       da		      .byte.b	BANK_aiDrawBitmap2
      0  0598					      BK	DrawBitmap3
      1  0598		       da		      .byte.b	BANK_aiDrawBitmap3
     52  0599
    403  0599
    404  0599
    405  0599							;---------------------------------------------------------------------------------------------------
    406  0599
      0  0599					      DEF	AiStateMachine
      1  0599				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0599				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0599				   AiStateMachine
      4  0599				   TEMPORARY_VAR SET	Overlay
      5  0599				   TEMPORARY_OFFSET SET	0
      6  0599				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0599				   FUNCTION_NAME SET	AiStateMachine
    408  0599					      SUBROUTINE
    409  0599
      0  0599					      REF	StartupBankReset	;✅
      1  0599				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0599				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0599					      ENDIF
      0  0599					      VAR	__aiVec, 2
      1  0599		       00 a7	   __aiVec    =	TEMPORARY_VAR
      2  0599				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0599
      4  0599				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0599				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0599				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0599					      ENDIF
      8  0599				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0599				  -VNAME      SETSTR	__aiVec
     10  0599				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0599				  -	      ERR
     12  0599					      ENDIF
      0  0599					      VEND	AiStateMachine
      1  0599
      2  0599
      3  0599		       00 a9	   VAREND_AiStateMachine =	TEMPORARY_VAR
      4  0599
    413  0599
    414  0599
    415  0599							; State machine vector setup - points to current routine to execute
    416  0599
    417  0599		       a6 8c		      ldx	aiState
    418  059b		       bd 03 f1 	      lda	AiVectorLO,x
    419  059e		       85 a7		      sta	__aiVec
    420  05a0		       bd 35 f1 	      lda	AiVectorHI,x
    421  05a3		       85 a8		      sta	__aiVec+1
    422  05a5
    423  05a5		       bd 67 f1 	      lda	AiVectorBANK,x
    424  05a8		       85 3f		      sta	SET_BANK
    425  05aa		       6c a7 00 	      jmp	(__aiVec)	; NOTE: could branch back to squeeze cycles
    426  05ad
    427  05ad
    428  05ad							;---------------------------------------------------------------------------------------------------
    429  05ad
      0  05ad					      DEF	GenerateAllMoves
      1  05ad				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  05ad				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  05ad				   GenerateAllMoves
      4  05ad				   TEMPORARY_VAR SET	Overlay
      5  05ad				   TEMPORARY_OFFSET SET	0
      6  05ad				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  05ad				   FUNCTION_NAME SET	GenerateAllMoves
    431  05ad					      SUBROUTINE
    432  05ad
      0  05ad					      REF	ListPlayerMoves	;✅
      1  05ad					      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  05ad				   TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  05ad					      ENDIF
      0  05ad					      REF	aiComputerMove	;✅
      1  05ad				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  05ad				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  05ad					      ENDIF
      0  05ad					      REF	quiesce	;✅
      1  05ad					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  05ad				   TEMPORARY_VAR SET	VAREND_quiesce
      3  05ad					      ENDIF
      0  05ad					      REF	negaMax	;✅
      1  05ad				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  05ad				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  05ad					      ENDIF
    437  05ad
      0  05ad					      VAR	__vector, 2
      1  05ad		       00 b9	   __vector   =	TEMPORARY_VAR
      2  05ad				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  05ad
      4  05ad				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05ad				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05ad				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05ad					      ENDIF
      8  05ad				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  05ad				  -VNAME      SETSTR	__vector
     10  05ad				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  05ad				  -	      ERR
     12  05ad					      ENDIF
    439  05ad
      0  05ad					      VEND	GenerateAllMoves
      1  05ad
      2  05ad
      3  05ad		       00 bb	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
      4  05ad
    441  05ad
    442  05ad							; Do the move generation in two passes - pawns then pieces
    443  05ad							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    444  05ad
    445  05ad							;{
    446  05ad
    447  05ad							; This MUST be called at the start of a new ply
    448  05ad							; It initialises the movelist to empty
    449  05ad							; x must be preserved
    450  05ad
    451  05ad		       a5 95		      lda	currentPly
    452  05af		       85 3e		      sta	SET_BANK_RAM	;@2
    453  05b1
    454  05b1							; note that 'alpha' and 'beta' are set externally!!
    455  05b1
    456  05b1		       a9 ff		      lda	#-1
      0  05b3					      sta@PLY	moveIndex	; no valid moves
      1  05b3		       8d cf fb 	      sta	[RAM]+moveIndex
      0  05b6					      sta@PLY	bestMove
      1  05b6		       8d d1 fb 	      sta	[RAM]+bestMove
    459  05b9
    460  05b9		       a5 94		      lda	enPassantPawn	; flag/square from last actual move made
      0  05bb					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  05bb		       8d ca fb 	      sta	[RAM]+enPassantSquare
    462  05be
    463  05be		       a5 a3		      lda	vkSquare
      0  05c0					      sta@PLY	virtualKingSquare
      1  05c0		       8d da fb 	      sta	[RAM]+virtualKingSquare
    465  05c3		       a5 a4		      lda	vkSquare+1
      0  05c5					      sta@PLY	virtualKingSquare+1	; traversal squares of king for castling
      1  05c5		       8d db fb 	      sta	[RAM]+virtualKingSquare+1
    467  05c8
    468  05c8							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    469  05c8							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    470  05c8							; start of each new ply.
    471  05c8
    472  05c8		       a5 90		      lda	Evaluation
      0  05ca					      sta@PLY	savedEvaluation
      1  05ca		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    474  05cd		       a5 91		      lda	Evaluation+1
      0  05cf					      sta@PLY	savedEvaluation+1
      1  05cf		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    476  05d2							;}
    477  05d2
    478  05d2		       a9 00		      lda	#0
      0  05d4					      sta@PLY	inCheck	; flags ANY check at a ply (for draw detection)
      1  05d4		       8d dc fb 	      sta	[RAM]+inCheck
    480  05d7
    481  05d7
    482  05d7		       20 e1 f1 	      jsr	MoveGenX
    483  05da
      0  05da					      JUMP	Sort	;@1
      1  05da				  -	      IF	SLOT_Sort == _BANK_SLOT
      2  05da				  -FNAME      SETSTR	Sort
      3  05da				  -	      ECHO	""
      4  05da				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  05da				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  05da				  -	      ERR
      7  05da					      ENDIF
      8  05da		       a9 43		      lda	#BANK_Sort
      9  05dc		       85 3f		      sta	SET_BANK
     10  05de		       4c 5e f6 	      jmp	Sort
    485  05e1
    486  05e1
      0  05e1					      DEF	MoveGenX
      1  05e1				   SLOT_MoveGenX SET	_BANK_SLOT
      2  05e1				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  05e1				   MoveGenX
      4  05e1				   TEMPORARY_VAR SET	Overlay
      5  05e1				   TEMPORARY_OFFSET SET	0
      6  05e1				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  05e1				   FUNCTION_NAME SET	MoveGenX
    488  05e1					      SUBROUTINE
    489  05e1
    490  05e1		       a9 e3		      lda	#RAMBANK_BOARD
    491  05e3		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    492  05e5
    493  05e5		       a2 64		      ldx	#100
    494  05e7		       d0 02		      bne	.next
    495  05e9
      0  05e9					      DEF	MoveReturn
      1  05e9				   SLOT_MoveReturn SET	_BANK_SLOT
      2  05e9				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  05e9				   MoveReturn
      4  05e9				   TEMPORARY_VAR SET	Overlay
      5  05e9				   TEMPORARY_OFFSET SET	0
      6  05e9				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  05e9				   FUNCTION_NAME SET	MoveReturn
    497  05e9
    498  05e9		       a6 93		      ldx	currentSquare
    499  05eb		       ca	   .next      dex
    500  05ec		       e0 16		      cpx	#22
    501  05ee		       90 2e		      bcc	.exit
    502  05f0
    503  05f0		       bd 79 fc 	      lda	Board,x
    504  05f3		       f0 f6		      beq	.next
    505  05f5		       c9 ff		      cmp	#-1
    506  05f7		       f0 f2		      beq	.next
    507  05f9		       45 96		      eor	sideToMove
    508  05fb		       30 ee		      bmi	.next
    509  05fd
    510  05fd		       86 93		      stx	currentSquare
    511  05ff
    512  05ff		       45 96		      eor	sideToMove
    513  0601		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    514  0603		       85 92		      sta	currentPiece
    515  0605		       29 07		      and	#PIECE_MASK
    516  0607		       a8		      tay
    517  0608
    518  0608		       c9 08	   huh	      cmp	#KING+1
    519  060a		       b0 fc		      bcs	huh
    520  060c
    521  060c		       b9 2b f2 	      lda	HandlerVectorHI,y
    522  060f		       85 ba		      sta	__vector+1
    523  0611		       b9 23 f2 	      lda	HandlerVectorLO,y
    524  0614		       85 b9		      sta	__vector
    525  0616
    526  0616		       b9 33 f2 	      lda	HandlerVectorBANK,y
    527  0619		       85 3f		      sta	SET_BANK	;@1
    528  061b
    529  061b		       6c b9 00 	      jmp	(__vector)
    530  061e
    531  061e
    532  061e		       a9 43	   .exit      lda	#BANK_negaMax
    533  0620		       85 3f		      sta	SET_BANK
    534  0622		       60		      rts
    535  0623
    536  0623					      MAC	handlevec
    537  0623					      DEF	HandlerVector{1}
    538  0623
    539  0623					      .byte	{2}MoveReturn
    540  0623					      .byte	{2}Handle_WHITE_PAWN	; 1
    541  0623					      .byte	{2}Handle_BLACK_PAWN	; 2
    542  0623					      .byte	{2}Handle_KNIGHT	; 3
    543  0623					      .byte	{2}Handle_BISHOP	; 4
    544  0623					      .byte	{2}Handle_ROOK	; 5
    545  0623					      .byte	{2}Handle_QUEEN	; 6
    546  0623					      .byte	{2}Handle_KING	; 7
    547  0623					      ENDM		; {label}, {macro}
    548  0623
    549  0623
      0  0623					      HANDLEVEC	LO, <
      0  0623					      DEF	HandlerVectorLO
      1  0623				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  0623				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  0623				   HandlerVectorLO
      4  0623				   TEMPORARY_VAR SET	Overlay
      5  0623				   TEMPORARY_OFFSET SET	0
      6  0623				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  0623				   FUNCTION_NAME SET	HandlerVectorLO
      2  0623
      3  0623		       e9		      .byte.b	<MoveReturn
      4  0624		       29		      .byte.b	<Handle_WHITE_PAWN
      5  0625		       f9		      .byte.b	<Handle_BLACK_PAWN
      6  0626		       a0		      .byte.b	<Handle_KNIGHT
      7  0627		       49		      .byte.b	<Handle_BISHOP
      8  0628		       00		      .byte.b	<Handle_ROOK
      9  0629		       7b		      .byte.b	<Handle_QUEEN
     10  062a		       6e		      .byte.b	<Handle_KING
      0  062b					      HANDLEVEC	HI, >
      0  062b					      DEF	HandlerVectorHI
      1  062b				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  062b				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  062b				   HandlerVectorHI
      4  062b				   TEMPORARY_VAR SET	Overlay
      5  062b				   TEMPORARY_OFFSET SET	0
      6  062b				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  062b				   FUNCTION_NAME SET	HandlerVectorHI
      2  062b
      3  062b		       f1		      .byte.b	>MoveReturn
      4  062c		       f4		      .byte.b	>Handle_WHITE_PAWN
      5  062d		       f4		      .byte.b	>Handle_BLACK_PAWN
      6  062e		       f5		      .byte.b	>Handle_KNIGHT
      7  062f		       f6		      .byte.b	>Handle_BISHOP
      8  0630		       f4		      .byte.b	>Handle_ROOK
      9  0631		       f4		      .byte.b	>Handle_QUEEN
     10  0632		       f5		      .byte.b	>Handle_KING
      0  0633					      HANDLEVEC	BANK, BANK_
      0  0633					      DEF	HandlerVectorBANK
      1  0633				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  0633				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  0633				   HandlerVectorBANK
      4  0633				   TEMPORARY_VAR SET	Overlay
      5  0633				   TEMPORARY_OFFSET SET	0
      6  0633				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  0633				   FUNCTION_NAME SET	HandlerVectorBANK
      2  0633
      3  0633		       01		      .byte.b	BANK_MoveReturn
      4  0634		       46		      .byte.b	BANK_Handle_WHITE_PAWN
      5  0635		       46		      .byte.b	BANK_Handle_BLACK_PAWN
      6  0636		       46		      .byte.b	BANK_Handle_KNIGHT
      7  0637		       46		      .byte.b	BANK_Handle_BISHOP
      8  0638		       47		      .byte.b	BANK_Handle_ROOK
      9  0639		       47		      .byte.b	BANK_Handle_QUEEN
     10  063a		       47		      .byte.b	BANK_Handle_KING
    553  063b
    554  063b
    555  063b							;---------------------------------------------------------------------------------------------------
    556  063b
      0  063b					      DEF	ListPlayerMoves
      1  063b				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  063b				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  063b				   ListPlayerMoves
      4  063b				   TEMPORARY_VAR SET	Overlay
      5  063b				   TEMPORARY_OFFSET SET	0
      6  063b				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  063b				   FUNCTION_NAME SET	ListPlayerMoves
    558  063b					      SUBROUTINE
    559  063b
    560  063b							; Build a list of (mostly) valid player moves. The list of all moves is generated, and then
    561  063b							; these are each verified by making the move and listing all opponent moves. If the opponent
    562  063b							; can capture the king, the move is invalidated by setting its "from" square to zero.
    563  063b
    564  063b							; The movelist is built in the second ply so as not to stomp on the movelist from the computer
    565  063b							; on the previous response. This allows the player movelist to be generated BEFORE the
    566  063b							; computer's move has been visually shown on the screen.
    567  063b
    568  063b							; This in turn requires the minimum memory for PLY banks to be 3 (computer, player, response)
    569  063b
      0  063b					      REF	COMMON_VARS
      1  063b					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  063b				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  063b					      ENDIF
      0  063b					      REF	selectmove	;✅
      1  063b				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  063b				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  063b					      ENDIF
      0  063b					      REF	StartupBankReset	;✅
      1  063b				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  063b				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  063b					      ENDIF
    573  063b
      0  063b					      VEND	ListPlayerMoves
      1  063b
      2  063b
      3  063b		       00 b7	   VAREND_ListPlayerMoves =	TEMPORARY_VAR
      4  063b
    575  063b
    576  063b
    577  063b		       a9 00		      lda	#0
    578  063d		       85 b2		      sta	__quiesceCapOnly	; gen ALL moves
    579  063f
    580  063f		       a9 89		      lda	#RAMBANK_PLY+1
    581  0641		       85 95		      sta	currentPly
    582  0643
    583  0643		       20 ad f1 	      jsr	GenerateAllMoves	;@this
    584  0646
      0  0646					      ldx@PLY	moveIndex
      1  0646		       ae cf f9 	      ldx	moveIndex
      0  0649				   .scan      stx@PLY	movePtr
      1  0649		       8e d0 fb 	      stx	[RAM]+movePtr
    587  064c
      0  064c					      CALL	MakeMove	;@1
      1  064c				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  064c				  -FNAME      SETSTR	MakeMove
      3  064c				  -	      ECHO	""
      4  064c				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  064c				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  064c				  -	      ERR
      7  064c					      ENDIF
      8  064c		       a9 43		      lda	#BANK_MakeMove
      9  064e		       85 3f		      sta	SET_BANK
     10  0650		       20 7f f4 	      jsr	MakeMove
    589  0653
    590  0653		       e6 95		      inc	currentPly
    591  0655		       20 ad f1 	      jsr	GenerateAllMoves	;@this
    592  0658
    593  0658		       c6 95		      dec	currentPly
    594  065a
    595  065a		       20 98 f2 	      jsr	unmakeMove	;@this
    596  065d
    597  065d		       a5 a1		      lda	flagCheck
    598  065f		       f0 08		      beq	.next
    599  0661
      0  0661					      ldx@PLY	movePtr
      1  0661		       ae d0 f9 	      ldx	movePtr
    601  0664		       a9 00		      lda	#0
      0  0666					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  0666		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    603  0669
      0  0669				   .next      ldx@PLY	movePtr
      1  0669		       ae d0 f9 	      ldx	movePtr
    605  066c		       ca		      dex
    606  066d		       10 da		      bpl	.scan
    607  066f
    608  066f		       60		      rts
    609  0670
    610  0670
    611  0670							;---------------------------------------------------------------------------------------------------
    612  0670
      0  0670					      DEF	AddMove
      1  0670				   SLOT_AddMove SET	_BANK_SLOT
      2  0670				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  0670				   AddMove
      4  0670				   TEMPORARY_VAR SET	Overlay
      5  0670				   TEMPORARY_OFFSET SET	0
      6  0670				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  0670				   FUNCTION_NAME SET	AddMove
    614  0670					      SUBROUTINE
    615  0670
      0  0670					      REF	Handle_KING	;✅
      1  0670					      IF	VAREND_Handle_KING > TEMPORARY_VAR
      2  0670				   TEMPORARY_VAR SET	VAREND_Handle_KING
      3  0670					      ENDIF
      0  0670					      REF	Handle_QUEEN	;✅
      1  0670				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  0670				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  0670					      ENDIF
      0  0670					      REF	Handle_ROOK	;✅
      1  0670				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  0670				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  0670					      ENDIF
      0  0670					      REF	Handle_BISHOP	;✅
      1  0670				  -	      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  0670				  -TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  0670					      ENDIF
      0  0670					      REF	Handle_KNIGHT	;✅
      1  0670				  -	      IF	VAREND_Handle_KNIGHT > TEMPORARY_VAR
      2  0670				  -TEMPORARY_VAR SET	VAREND_Handle_KNIGHT
      3  0670					      ENDIF
      0  0670					      REF	Handle_WHITE_PAWN	;✅
      1  0670				  -	      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  0670				  -TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  0670					      ENDIF
      0  0670					      REF	Handle_BLACK_PAWN	;✅
      1  0670				  -	      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  0670				  -TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  0670					      ENDIF
    623  0670
      0  0670					      VEND	AddMove
      1  0670
      2  0670
      3  0670		       00 bb	   VAREND_AddMove =	TEMPORARY_VAR
      4  0670
    625  0670
    626  0670							; add square in y register to movelist as destination (X12 format)
    627  0670							; [y]		     to square (X12)
    628  0670							; currentSquare     from square (X12)
    629  0670							; currentPiece      piece.
    630  0670							;   ENPASSANT flag set if pawn double-moving off opening rank
    631  0670							; capture	     captured piece
    632  0670
    633  0670
    634  0670		       a5 a0		      lda	capture
    635  0672		       d0 04		      bne	.always
    636  0674		       a5 b2		      lda	__quiesceCapOnly
    637  0676		       d0 1c		      bne	.abort
    638  0678
    639  0678		       98	   .always    tya
    640  0679		       aa		      tax
    641  067a
      0  067a					      ldy@PLY	moveIndex
      1  067a		       ac cf f9 	      ldy	moveIndex
    643  067d		       c8		      iny
      0  067e					      sty@PLY	moveIndex
      1  067e		       8c cf fb 	      sty	[RAM]+moveIndex
    645  0681
      0  0681					      sta@PLY	MoveTo,y
      1  0681		       99 64 fa 	      sta	[RAM]+MoveTo,y
    647  0684		       a5 93		      lda	currentSquare
      0  0686					      sta@PLY	MoveFrom,y
      1  0686		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    649  0689		       a5 92		      lda	currentPiece
      0  068b					      sta@PLY	MovePiece,y
      1  068b		       99 00 fb 	      sta	[RAM]+MovePiece,y
    651  068e		       a5 a0		      lda	capture
      0  0690					      sta@PLY	MoveCapture,y
      1  0690		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    653  0693		       60		      rts
    654  0694
    655  0694		       98	   .abort     tya
    656  0695		       aa		      tax
    657  0696		       60		      rts
    658  0697
    659  0697
    660  0697							;---------------------------------------------------------------------------------------------------
    661  0697
      0  0697					      DEF	debug
      1  0697				   SLOT_debug SET	_BANK_SLOT
      2  0697				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  0697				   debug
      4  0697				   TEMPORARY_VAR SET	Overlay
      5  0697				   TEMPORARY_OFFSET SET	0
      6  0697				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  0697				   FUNCTION_NAME SET	debug
    663  0697					      SUBROUTINE
    664  0697
    665  0697
    666  0697		       60		      rts
    667  0698
    668  0698
    669  0698							;---------------------------------------------------------------------------------------------------
    670  0698
      0  0698					      DEF	unmakeMove
      1  0698				   SLOT_unmakeMove SET	_BANK_SLOT
      2  0698				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  0698				   unmakeMove
      4  0698				   TEMPORARY_VAR SET	Overlay
      5  0698				   TEMPORARY_OFFSET SET	0
      6  0698				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  0698				   FUNCTION_NAME SET	unmakeMove
    672  0698					      SUBROUTINE
    673  0698
      0  0698					      REF	selectmove	;✅
      1  0698					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0698				   TEMPORARY_VAR SET	VAREND_selectmove
      3  0698					      ENDIF
      0  0698					      REF	ListPlayerMoves	;✅
      1  0698				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0698				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0698					      ENDIF
      0  0698					      REF	quiesce	;✅
      1  0698					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0698				   TEMPORARY_VAR SET	VAREND_quiesce
      3  0698					      ENDIF
      0  0698					      REF	negaMax	;✅
      1  0698				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0698				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0698					      ENDIF
      0  0698					      VEND	unmakeMove
      1  0698
      2  0698
      3  0698		       00 b9	   VAREND_unmakeMove =	TEMPORARY_VAR
      4  0698
    679  0698
    680  0698							; restore the board evaluation to what it was at the start of this ply
    681  0698							; TODO: note: moved flag seems wrong on restoration??
    682  0698
    683  0698		       a5 95		      lda	currentPly
    684  069a		       85 3e		      sta	SET_BANK_RAM	;@2
    685  069c		       a2 e3		      ldx	#RAMBANK_BOARD
    686  069e		       86 3e		      stx	SET_BANK_RAM	;@3
    687  06a0
      0  06a0					      lda@PLY	savedEvaluation
      1  06a0		       ad c8 f9 	      lda	savedEvaluation
    689  06a3		       85 90		      sta	Evaluation
      0  06a5					      lda@PLY	savedEvaluation+1
      1  06a5		       ad c9 f9 	      lda	savedEvaluation+1
    691  06a8		       85 91		      sta	Evaluation+1
    692  06aa
      0  06aa					      lda@PLY	virtualKingSquare
      1  06aa		       ad da f9 	      lda	virtualKingSquare
    694  06ad		       85 a3		      sta	vkSquare
      0  06af					      lda@PLY	virtualKingSquare+1
      1  06af		       ad db f9 	      lda	virtualKingSquare+1
    696  06b2		       85 a4		      sta	vkSquare+1
    697  06b4
      0  06b4					      lda@PLY	enPassantSquare
      1  06b4		       ad ca f9 	      lda	enPassantSquare
    699  06b7		       85 94		      sta	enPassantPawn
    700  06b9
      0  06b9					      ldx@PLY	movePtr
      1  06b9		       ae d0 f9 	      ldx	movePtr
      0  06bc					      ldy@PLY	MoveFrom,x
      1  06bc		       bc 00 f8 	      ldy	MoveFrom,x
      0  06bf					      lda@PLY	restorePiece
      1  06bf		       ad d9 f9 	      lda	restorePiece
      0  06c2					      sta@RAM	Board,y
      1  06c2		       99 79 fe 	      sta	[RAM]+Board,y
    705  06c5
      0  06c5					      ldy@PLY	MoveTo,x
      1  06c5		       bc 64 f8 	      ldy	MoveTo,x
      0  06c8					      lda@PLY	capturedPiece
      1  06c8		       ad cb f9 	      lda	capturedPiece
      0  06cb					      sta@RAM	Board,y
      1  06cb		       99 79 fe 	      sta	[RAM]+Board,y
    709  06ce
    710  06ce
    711  06ce							; See if there are any 'secondary' pieces that moved
    712  06ce							; here we're dealing with reverting a castling or enPassant move
    713  06ce
      0  06ce					      lda@PLY	secondaryPiece
      1  06ce		       ad cc f9 	      lda	secondaryPiece
    715  06d1		       f0 10		      beq	.noSecondary
      0  06d3					      ldx@PLY	secondarySquare
      1  06d3		       ae cd f9 	      ldx	secondarySquare
      0  06d6					      sta@RAM	Board,x	; put piece back
      1  06d6		       9d 79 fe 	      sta	[RAM]+Board,x
      0  06d9					      ldy@PLY	secondaryBlank
      1  06d9		       ac ce f9 	      ldy	secondaryBlank
    719  06dc		       f0 05		      beq	.noSecondary	; enpassant - no blanker square
    720  06de		       a9 00		      lda	#0
      0  06e0					      sta@RAM	Board,y	; blank piece origin
      1  06e0		       99 79 fe 	      sta	[RAM]+Board,y
    722  06e3
      0  06e3				   .noSecondary SWAP
      1  06e3
      2  06e3		       a5 96		      lda	sideToMove
      3  06e5		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  06e7		       85 96		      sta	sideToMove
      5  06e9
    724  06e9		       60		      rts
    725  06ea
    726  06ea
    727  06ea							;---------------------------------------------------------------------------------------------------
    728  06ea
      0  06ea					      DEF	showMoveCaptures
      1  06ea				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  06ea				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  06ea				   showMoveCaptures
      4  06ea				   TEMPORARY_VAR SET	Overlay
      5  06ea				   TEMPORARY_OFFSET SET	0
      6  06ea				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  06ea				   FUNCTION_NAME SET	showMoveCaptures
    730  06ea					      SUBROUTINE
    731  06ea
      0  06ea					      REF	aiShowMoveCaptures	;✅
      1  06ea					      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  06ea				   TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  06ea					      ENDIF
    733  06ea
      0  06ea					      VAR	__toSquareX12, 1
      1  06ea		       00 a9	   __toSquareX12 =	TEMPORARY_VAR
      2  06ea				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06ea
      4  06ea				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06ea				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06ea				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06ea					      ENDIF
      8  06ea				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  06ea				  -VNAME      SETSTR	__toSquareX12
     10  06ea				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  06ea				  -	      ERR
     12  06ea					      ENDIF
      0  06ea					      VAR	__fromPiece, 1
      1  06ea		       00 aa	   __fromPiece =	TEMPORARY_VAR
      2  06ea				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06ea
      4  06ea				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06ea				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06ea				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06ea					      ENDIF
      8  06ea				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  06ea				  -VNAME      SETSTR	__fromPiece
     10  06ea				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  06ea				  -	      ERR
     12  06ea					      ENDIF
      0  06ea					      VAR	__aiMoveIndex, 1
      1  06ea		       00 ab	   __aiMoveIndex =	TEMPORARY_VAR
      2  06ea				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06ea
      4  06ea				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06ea				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06ea				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06ea					      ENDIF
      8  06ea				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  06ea				  -VNAME      SETSTR	__aiMoveIndex
     10  06ea				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  06ea				  -	      ERR
     12  06ea					      ENDIF
    737  06ea
      0  06ea					      VEND	showMoveCaptures
      1  06ea
      2  06ea
      3  06ea		       00 ac	   VAREND_showMoveCaptures =	TEMPORARY_VAR
      4  06ea
    739  06ea
    740  06ea							; place a marker on the board for any square matching the piece
    741  06ea							; EXCEPT for squares which are occupied (we'll flash those later)
    742  06ea							; x = movelist item # being checked
    743  06ea
    744  06ea
    745  06ea		       a6 8e	   .next      ldx	aiMoveIndex
    746  06ec		       86 ab		      stx	__aiMoveIndex
    747  06ee		       30 4a		      bmi	.skip	; no moves in list
    748  06f0
    749  06f0		       ad 84 02 	      lda	INTIM
    750  06f3		       c9 14		      cmp	#20
    751  06f5		       90 43		      bcc	.skip
    752  06f7
    753  06f7		       c6 8e		      dec	aiMoveIndex
    754  06f9
    755  06f9		       a9 89		      lda	#RAMBANK_PLY+1
    756  06fb		       85 3e		      sta	SET_BANK_RAM
      0  06fd					      lda@PLY	MoveFrom,x
      1  06fd		       bd 00 f8 	      lda	MoveFrom,x
    758  0700		       c5 86		      cmp	fromX12
    759  0702		       d0 e6		      bne	.next
    760  0704
      0  0704					      lda@PLY	MoveTo,x
      1  0704		       bd 64 f8 	      lda	MoveTo,x
    762  0707		       85 a9		      sta	__toSquareX12
    763  0709		       a8		      tay
    764  070a
    765  070a		       a9 e3		      lda	#RAMBANK_BOARD
    766  070c		       85 3e		      sta	SET_BANK_RAM	;@3
    767  070e		       b9 79 fc 	      lda	Board,y
    768  0711		       29 07		      and	#PIECE_MASK
    769  0713		       f0 d5		      beq	.next
    770  0715
    771  0715							; There's something on the board at destination, so it's a capture
    772  0715							; Let's see if we are doing a pawn promote...
    773  0715
    774  0715		       a4 86		      ldy	fromX12
    775  0717
    776  0717		       a9 e3		      lda	#RAMBANK_BOARD
    777  0719		       85 3e		      sta	SET_BANK_RAM	;@3
    778  071b		       b9 79 fc 	      lda	Board,y
    779  071e		       85 aa		      sta	__fromPiece
    780  0720
    781  0720		       a9 89		      lda	#RAMBANK_PLY+1
    782  0722		       85 3e		      sta	SET_BANK_RAM
      0  0724					      lda@PLY	MovePiece,x
      1  0724		       bd 00 f9 	      lda	MovePiece,x
    784  0727		       45 aa		      eor	__fromPiece
    785  0729		       29 07		      and	#PIECE_MASK
    786  072b		       f0 06		      beq	.legit	; from == to, so not a promote
    787  072d
    788  072d							; Have detected a promotion duplicate - skip all 3 of them
    789  072d							; TODO: this will need reworking once moves are sorted
    790  072d
    791  072d		       c6 8e		      dec	aiMoveIndex	; skip "KBRQ" promotes
    792  072f		       c6 8e		      dec	aiMoveIndex
    793  0731		       c6 8e		      dec	aiMoveIndex
    794  0733
    795  0733				   .legit
    796  0733
    797  0733							;TIMECHECK CopySinglePiece, restoreIndex     ; not enough time to draw
    798  0733
    799  0733		       a5 a9		      lda	__toSquareX12
    800  0735		       85 81		      sta	squareToDraw
    801  0737
    802  0737							; WARNING - local variables will not survive the following call...!
    803  0737		       20 c8 f0 	      jsr	CopySinglePiece	;@0
    804  073a
    805  073a		       60	   .skip      rts
    806  073b
    807  073b
    808  073b							;---------------------------------------------------------------------------------------------------
    809  073b
      0  073b					      DEF	CopyPieceToRowBitmap
      1  073b				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  073b				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  073b				   CopyPieceToRowBitmap
      4  073b				   TEMPORARY_VAR SET	Overlay
      5  073b				   TEMPORARY_OFFSET SET	0
      6  073b				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  073b				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    811  073b					      SUBROUTINE
    812  073b
      0  073b					      REF	Variable_PieceShapeBuffer
      1  073b					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  073b				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  073b					      ENDIF
      0  073b					      REF	InterceptMarkerCopy	;✅
      1  073b					      IF	VAREND_InterceptMarkerCopy > TEMPORARY_VAR
      2  073b				   TEMPORARY_VAR SET	VAREND_InterceptMarkerCopy
      3  073b					      ENDIF
    815  073b
      0  073b					      VEND	CopyPieceToRowBitmap
      1  073b
      2  073b
      3  073b		       00 f1	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
      4  073b
    817  073b
    818  073b		       a0 11		      ldy	#17
    819  073d		       b0 30		      bcs	.rightSide
    820  073f
    821  073f		       b9 a7 00    .copyPiece lda	__pieceShapeBuffer,y
    822  0742		       f0 06		      beq	.blank1
    823  0744		       59 00 f8 	      eor	ChessBitmap,y
      0  0747					      sta@RAM	ChessBitmap,y
      1  0747		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    825  074a
    826  074a		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    827  074d		       f0 06		      beq	.blank2
    828  074f		       59 12 f8 	      eor	ChessBitmap+18,y
      0  0752					      sta@RAM	ChessBitmap+18,y
      1  0752		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    830  0755
    831  0755		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    832  0758		       f0 06		      beq	.blank3
    833  075a		       59 24 f8 	      eor	ChessBitmap+36,y
      0  075d					      sta@RAM	ChessBitmap+36,y
      1  075d		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    835  0760
    836  0760		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    837  0763		       f0 06		      beq	.blank4
    838  0765		       59 36 f8 	      eor	ChessBitmap+54,y
      0  0768					      sta@RAM	ChessBitmap+54,y
      1  0768		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    840  076b
    841  076b		       88	   .blank4    dey
    842  076c		       10 d1		      bpl	.copyPiece
    843  076e		       60		      rts
    844  076f
    845  076f				   .rightSide
    846  076f
    847  076f					      SUBROUTINE
    848  076f
    849  076f		       b9 a7 00    .copyPieceR lda	__pieceShapeBuffer,y
    850  0772		       f0 06		      beq	.blank1
    851  0774		       59 48 f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE,y
      0  0777					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE,y
      1  0777		       99 48 fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE,y
    853  077a
    854  077a		       b9 b9 00    .blank1    lda	__pieceShapeBuffer+18,y
    855  077d		       f0 06		      beq	.blank2
    856  077f		       59 5a f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE+18,y
      0  0782					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE+18,y
      1  0782		       99 5a fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE+18,y
    858  0785
    859  0785		       b9 cb 00    .blank2    lda	__pieceShapeBuffer+36,y
    860  0788		       f0 06		      beq	.blank3
    861  078a		       59 6c f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE+36,y
      0  078d					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE+36,y
      1  078d		       99 6c fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE+36,y
    863  0790
    864  0790		       b9 dd 00    .blank3    lda	__pieceShapeBuffer+54,y
    865  0793		       f0 06		      beq	.blank4
    866  0795		       59 7e f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE+54,y
      0  0798					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE+54,y
      1  0798		       99 7e fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE+54,y
    868  079b
    869  079b		       88	   .blank4    dey
    870  079c		       10 d1		      bpl	.copyPieceR
    871  079e		       60		      rts
    872  079f
    873  079f
    874  079f							;---------------------------------------------------------------------------------------------------
    875  079f
      0  079f					      DEF	EnPassantRemoveCapturedPawn
      1  079f				   SLOT_EnPassantRemoveCapturedPawn SET	_BANK_SLOT
      2  079f				   BANK_EnPassantRemoveCapturedPawn SET	SLOT_EnPassantRemoveCapturedPawn + _CURRENT_BANK
      3  079f				   EnPassantRemoveCapturedPawn
      4  079f				   TEMPORARY_VAR SET	Overlay
      5  079f				   TEMPORARY_OFFSET SET	0
      6  079f				   VAR_BOUNDARY_EnPassantRemoveCapturedPawn SET	TEMPORARY_OFFSET
      7  079f				   FUNCTION_NAME SET	EnPassantRemoveCapturedPawn
    877  079f					      SUBROUTINE
    878  079f
      0  079f					      REF	aiSpecialMoveFixup
      1  079f					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  079f				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  079f					      ENDIF
      0  079f					      VEND	EnPassantRemoveCapturedPawn
      1  079f
      2  079f
      3  079f		       00 b7	   VAREND_EnPassantRemoveCapturedPawn =	TEMPORARY_VAR
      4  079f
    881  079f
    882  079f		       a4 94		      ldy	enPassantPawn
    883  07a1		       f0 27		      beq	.exit
    884  07a3
    885  07a3
    886  07a3		       a9 e3		      lda	#RAMBANK_BOARD
    887  07a5		       85 3e		      sta	SET_BANK_RAM	;@3
    888  07a7
    889  07a7							; Account for the opponent pawn being removed
    890  07a7							; Effectively ADD the values to our current score
    891  07a7
    892  07a7		       a5 96		      lda	sideToMove
    893  07a9		       49 80		      eor	#128
    894  07ab		       29 80		      and	#128
    895  07ad		       09 01		      ora	#WP	; == BP in this usage
    896  07af
    897  07af		       a2 89		      ldx	#BANK_AddPiecePositionValue
    898  07b1		       86 3f		      stx	SET_BANK	;@2
    899  07b3		       20 59 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    900  07b6
    901  07b6		       a9 01		      lda	#WP	; == BP
    902  07b8		       a2 89		      ldx	#BANK_AddPieceMaterialValue
    903  07ba		       86 3f		      stx	SET_BANK	;@2
    904  07bc		       20 36 f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    905  07bf
    906  07bf		       a9 e3		      lda	#RAMBANK_BOARD
    907  07c1		       85 3e		      sta	SET_BANK_RAM	;@3
    908  07c3
    909  07c3		       a6 94		      ldx	enPassantPawn
    910  07c5		       a9 00		      lda	#0
      0  07c7					      sta@RAM	Board,x
      1  07c7		       9d 79 fe 	      sta	[RAM]+Board,x
    912  07ca
    913  07ca
    914  07ca		       60	   .exit      rts
    915  07cb
    916  07cb
    917  07cb							;---------------------------------------------------------------------------------------------------
    918  07cb
      0  07cb					      END_BANK
      1  07cb				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  07cb				  -	      CHECK_RAM_BANK_SIZE
      3  07cb					      ELSE
      0  07cb					      CHECK_BANK_SIZE
      1  07cb		       03 cb	   .TEMP      =	* - _BANK_START
 ROM bank # 2 LOCKED_BANK size = $3cb free = 52
      2  07cb					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  07cb				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  07cb				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  07cb				  -	      ERR
      6  07cb					      ENDIF
      5  07cb					      ENDIF
    920  07cb
    921  07cb							;---------------------------------------------------------------------------------------------------
    922  07cb							; EOF
------- FILE ./chess.asm
    192  07cb
------- FILE @1 GENERIC #1.asm LEVEL 2 PASS 4
      0  07cb					      include	"@1 GENERIC #1.asm"
      1  07cb							;---------------------------------------------------------------------------------------------------
      2  07cb							; @1 GENERIC #1.asm
      3  07cb
      4  07cb							; Atari 2600 Chess
      5  07cb							; Copyright (c) 2019-2020 Andrew Davie
      6  07cb							; andrew@taswegian.com
      7  07cb
      8  07cb							;---------------------------------------------------------------------------------------------------
      9  07cb
      0  07cb					      SLOT	1	; which bank this code switches to
      1  07cb
      2  07cb				  -	      IF	(1 < 0) || (1 > 3)
      3  07cb				  -	      ECHO	"Illegal bank address/segment location", 1
      4  07cb				  -	      ERR
      5  07cb					      ENDIF
      6  07cb
      7  07cb				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  07cb				   _BANK_SLOT SET	1 * 64
      9  07cb
      0  07cb					      ROMBANK	ONE
      1  0b94 ????				      SEG	ROM_ONE
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   ONE_START  SET	*
      6  0800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0800				   ROMBANK_ONE SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0800				   _LAST_BANK SETSTR	ONE
     10  0800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0800
     13  0800
     14  0800							;---------------------------------------------------------------------------------------------------
     15  0800
      0  0800					      DEF	CartInit
      1  0800				   SLOT_CartInit SET	_BANK_SLOT
      2  0800				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0800				   CartInit
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	CartInit
     17  0800					      SUBROUTINE
     18  0800
      0  0800					      REF	StartupBankReset	;✅
      1  0800				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0800				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0800					      ENDIF
     20  0800
      0  0800					      VEND	CartInit
      1  0800
      2  0800
      3  0800		       00 a7	   VAREND_CartInit =	TEMPORARY_VAR
      4  0800
     22  0800
     23  0800
     24  0800							; See if we can come up with something 'random' for startup
     25  0800
     26  0800		       ac 84 02 	      ldy	INTIM
     27  0803		       d0 02		      bne	.toR
     28  0805		       a0 9a		      ldy	#$9A
     29  0807		       84 82	   .toR       sty	rnd
     30  0809
     31  0809		       a9 1f		      lda	#31
     32  080b		       85 a2		      sta	randomness
     33  080d
     34  080d		       a9 00		      lda	#0
     35  080f		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     36  0812		       85 6b		      sta	HMCLR
     37  0814
     38  0814
     39  0814		       85 5b		      sta	GRP0
     40  0816		       85 5c		      sta	GRP1
     41  0818		       85 5d		      sta	ENAM0
     42  081a		       85 5e		      sta	ENAM1
     43  081c		       85 5f		      sta	ENABL
     44  081e
     45  081e							;lda #$FF
     46  081e		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     47  0821
     48  0821							; cleanup remains of title screen
     49  0821							;sta GRP0
     50  0821							;sta GRP1
     51  0821
     52  0821		       a9 07		      lda	#%111
     53  0823		       85 44		      sta	NUSIZ0
     54  0825		       85 45		      sta	NUSIZ1	; quad-width
     55  0827
     56  0827							;lda #%00000100
     57  0827							;sta CTRLPF
     58  0827		       a9 00		      lda	#BACKGCOL
     59  0829		       85 49		      sta	COLUBK
     60  082b
     61  082b
     62  082b		       a9 40		      lda	#WHITE|HUMAN
     63  082d		       85 96		      sta	sideToMove
     64  082f
     65  082f		       ad 82 02 	      lda	SWCHB
     66  0832		       0a		      asl
     67  0833		       2a		      rol
     68  0834		       2a		      rol
     69  0835		       29 01		      and	#1
     70  0837		       85 a5		      sta	platform	; P1 difficulty --> NTSC/PAL
     71  0839
      0  0839					      SPEAK	silence_speech
      1  0839
      2  0839		       a9 cd		      lda	#<silence_speech
      3  083b		       85 9a		      sta	speech_addr
      4  083d		       a9 f8		      lda	#>silence_speech
      5  083f		       85 9b		      sta	speech_addr+1
      6  0841
     73  0841							;SPEAK left_speech
     74  0841		       60		      rts
     75  0842
     76  0842
     77  0842							;---------------------------------------------------------------------------------------------------
     78  0842
      0  0842					      DEF	SetupBanks
      1  0842				   SLOT_SetupBanks SET	_BANK_SLOT
      2  0842				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  0842				   SetupBanks
      4  0842				   TEMPORARY_VAR SET	Overlay
      5  0842				   TEMPORARY_OFFSET SET	0
      6  0842				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  0842				   FUNCTION_NAME SET	SetupBanks
     80  0842					      SUBROUTINE
     81  0842
      0  0842					      REF	StartupBankReset
      1  0842				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0842				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0842					      ENDIF
      0  0842					      VEND	SetupBanks
      1  0842
      2  0842
      3  0842		       00 a7	   VAREND_SetupBanks =	TEMPORARY_VAR
      4  0842
     84  0842
     85  0842
     86  0842
     87  0842							; Move a copy of the row bank template to the first 8 banks of RAM
     88  0842							; and then terminate the draw subroutine by substituting in a RTS on the last one
     89  0842
      0  0842					      REF	StartupBankReset	;✅
      1  0842				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0842				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0842					      ENDIF
      0  0842					      VEND	SetupBanks
      1  0842
      2  0842
      3  0842		       00 a7	   VAREND_SetupBanks =	TEMPORARY_VAR
      4  0842
     92  0842
     93  0842							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     94  0842
     95  0842				   .ROWBANK   SET	0
     96  0842					      REPEAT	8
     97  0842		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     98  0844		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     99  0846		       20 db f5 	      jsr	CopyShadowROMtoRAM
    100  0846				   .ROWBANK   SET	.ROWBANK+1
     96  0846					      REPEND
     97  0849		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     98  084b		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     99  084d		       20 db f5 	      jsr	CopyShadowROMtoRAM
    100  084d				   .ROWBANK   SET	.ROWBANK+1
     96  084d					      REPEND
     97  0850		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     98  0852		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     99  0854		       20 db f5 	      jsr	CopyShadowROMtoRAM
    100  0854				   .ROWBANK   SET	.ROWBANK+1
     96  0854					      REPEND
     97  0857		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     98  0859		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     99  085b		       20 db f5 	      jsr	CopyShadowROMtoRAM
    100  085b				   .ROWBANK   SET	.ROWBANK+1
     96  085b					      REPEND
     97  085e		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     98  0860		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     99  0862		       20 db f5 	      jsr	CopyShadowROMtoRAM
    100  0862				   .ROWBANK   SET	.ROWBANK+1
     96  0862					      REPEND
     97  0865		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     98  0867		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     99  0869		       20 db f5 	      jsr	CopyShadowROMtoRAM
    100  0869				   .ROWBANK   SET	.ROWBANK+1
     96  0869					      REPEND
     97  086c		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     98  086e		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     99  0870		       20 db f5 	      jsr	CopyShadowROMtoRAM
    100  0870				   .ROWBANK   SET	.ROWBANK+1
     96  0870					      REPEND
     97  0873		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     98  0875		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     99  0877		       20 db f5 	      jsr	CopyShadowROMtoRAM
    100  0877				   .ROWBANK   SET	.ROWBANK+1
    101  087a					      REPEND
    102  087a
    103  087a
    104  087a							; Patch the final row's "loop" to a RTS
    105  087a
    106  087a		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
    107  087c		       86 3e		      stx	SET_BANK_RAM
    108  087e		       a9 60		      lda	#$60	; "rts"
      0  0880					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0880		       8d a0 fa 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
    110  0883
    111  0883
    112  0883							; Patch the NTSC/PAL colours in all row banks
    113  0883
    114  0883		       a6 a5		      ldx	platform
    115  0883				   .ROWBANK   SET	[SLOT2]
    116  0885					      REPEAT	8
    117  0885		       a9 80		      lda	#.ROWBANK
    118  0887		       85 3e		      sta	SET_BANK_RAM
    119  0889
    120  0889		       bd 4d f5 	      lda	col1,x
      0  088c					      sta@RAM	SMCOL1+1
      1  088c		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    122  088f		       bd 5d f5 	      lda	col2,x
      0  0892					      sta@RAM	SMCOL2+1
      1  0892		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    124  0895		       bd 6d f5 	      lda	col3,x
      0  0898					      sta@RAM	SMCOL3+1
      1  0898		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    126  089b
    127  089b					      IFCONST	RAINBOW
    128  089b		       e8		      inx
    129  089c		       e8		      inx
    130  089d					      ENDIF
    131  089d
    132  089d				   .ROWBANK   SET	.ROWBANK + 1
    116  089d					      REPEND
    117  089d		       a9 81		      lda	#.ROWBANK
    118  089f		       85 3e		      sta	SET_BANK_RAM
    119  08a1
    120  08a1		       bd 4d f5 	      lda	col1,x
      0  08a4					      sta@RAM	SMCOL1+1
      1  08a4		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    122  08a7		       bd 5d f5 	      lda	col2,x
      0  08aa					      sta@RAM	SMCOL2+1
      1  08aa		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    124  08ad		       bd 6d f5 	      lda	col3,x
      0  08b0					      sta@RAM	SMCOL3+1
      1  08b0		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    126  08b3
    127  08b3					      IFCONST	RAINBOW
    128  08b3		       e8		      inx
    129  08b4		       e8		      inx
    130  08b5					      ENDIF
    131  08b5
    132  08b5				   .ROWBANK   SET	.ROWBANK + 1
    116  08b5					      REPEND
    117  08b5		       a9 82		      lda	#.ROWBANK
    118  08b7		       85 3e		      sta	SET_BANK_RAM
    119  08b9
    120  08b9		       bd 4d f5 	      lda	col1,x
      0  08bc					      sta@RAM	SMCOL1+1
      1  08bc		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    122  08bf		       bd 5d f5 	      lda	col2,x
      0  08c2					      sta@RAM	SMCOL2+1
      1  08c2		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    124  08c5		       bd 6d f5 	      lda	col3,x
      0  08c8					      sta@RAM	SMCOL3+1
      1  08c8		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    126  08cb
    127  08cb					      IFCONST	RAINBOW
    128  08cb		       e8		      inx
    129  08cc		       e8		      inx
    130  08cd					      ENDIF
    131  08cd
    132  08cd				   .ROWBANK   SET	.ROWBANK + 1
    116  08cd					      REPEND
    117  08cd		       a9 83		      lda	#.ROWBANK
    118  08cf		       85 3e		      sta	SET_BANK_RAM
    119  08d1
    120  08d1		       bd 4d f5 	      lda	col1,x
      0  08d4					      sta@RAM	SMCOL1+1
      1  08d4		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    122  08d7		       bd 5d f5 	      lda	col2,x
      0  08da					      sta@RAM	SMCOL2+1
      1  08da		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    124  08dd		       bd 6d f5 	      lda	col3,x
      0  08e0					      sta@RAM	SMCOL3+1
      1  08e0		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    126  08e3
    127  08e3					      IFCONST	RAINBOW
    128  08e3		       e8		      inx
    129  08e4		       e8		      inx
    130  08e5					      ENDIF
    131  08e5
    132  08e5				   .ROWBANK   SET	.ROWBANK + 1
    116  08e5					      REPEND
    117  08e5		       a9 84		      lda	#.ROWBANK
    118  08e7		       85 3e		      sta	SET_BANK_RAM
    119  08e9
    120  08e9		       bd 4d f5 	      lda	col1,x
      0  08ec					      sta@RAM	SMCOL1+1
      1  08ec		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    122  08ef		       bd 5d f5 	      lda	col2,x
      0  08f2					      sta@RAM	SMCOL2+1
      1  08f2		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    124  08f5		       bd 6d f5 	      lda	col3,x
      0  08f8					      sta@RAM	SMCOL3+1
      1  08f8		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    126  08fb
    127  08fb					      IFCONST	RAINBOW
    128  08fb		       e8		      inx
    129  08fc		       e8		      inx
    130  08fd					      ENDIF
    131  08fd
    132  08fd				   .ROWBANK   SET	.ROWBANK + 1
    116  08fd					      REPEND
    117  08fd		       a9 85		      lda	#.ROWBANK
    118  08ff		       85 3e		      sta	SET_BANK_RAM
    119  0901
    120  0901		       bd 4d f5 	      lda	col1,x
      0  0904					      sta@RAM	SMCOL1+1
      1  0904		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    122  0907		       bd 5d f5 	      lda	col2,x
      0  090a					      sta@RAM	SMCOL2+1
      1  090a		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    124  090d		       bd 6d f5 	      lda	col3,x
      0  0910					      sta@RAM	SMCOL3+1
      1  0910		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    126  0913
    127  0913					      IFCONST	RAINBOW
    128  0913		       e8		      inx
    129  0914		       e8		      inx
    130  0915					      ENDIF
    131  0915
    132  0915				   .ROWBANK   SET	.ROWBANK + 1
    116  0915					      REPEND
    117  0915		       a9 86		      lda	#.ROWBANK
    118  0917		       85 3e		      sta	SET_BANK_RAM
    119  0919
    120  0919		       bd 4d f5 	      lda	col1,x
      0  091c					      sta@RAM	SMCOL1+1
      1  091c		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    122  091f		       bd 5d f5 	      lda	col2,x
      0  0922					      sta@RAM	SMCOL2+1
      1  0922		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    124  0925		       bd 6d f5 	      lda	col3,x
      0  0928					      sta@RAM	SMCOL3+1
      1  0928		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    126  092b
    127  092b					      IFCONST	RAINBOW
    128  092b		       e8		      inx
    129  092c		       e8		      inx
    130  092d					      ENDIF
    131  092d
    132  092d				   .ROWBANK   SET	.ROWBANK + 1
    116  092d					      REPEND
    117  092d		       a9 87		      lda	#.ROWBANK
    118  092f		       85 3e		      sta	SET_BANK_RAM
    119  0931
    120  0931		       bd 4d f5 	      lda	col1,x
      0  0934					      sta@RAM	SMCOL1+1
      1  0934		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    122  0937		       bd 5d f5 	      lda	col2,x
      0  093a					      sta@RAM	SMCOL2+1
      1  093a		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    124  093d		       bd 6d f5 	      lda	col3,x
      0  0940					      sta@RAM	SMCOL3+1
      1  0940		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    126  0943
    127  0943					      IFCONST	RAINBOW
    128  0943		       e8		      inx
    129  0944		       e8		      inx
    130  0945					      ENDIF
    131  0945
    132  0945				   .ROWBANK   SET	.ROWBANK + 1
    133  0945					      REPEND
    134  0945
    135  0945
    136  0945
    137  0945							; copy the BOARD/MOVES bank
    138  0945
    139  0945		       a2 9d		      ldx	#ROMBANK_SHADOW_BOARD
    140  0947		       a0 e3		      ldy	#RAMBANK_BOARD
    141  0949		       20 db f5 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    142  094c
    143  094c
    144  094c							; copy the PLY banks
    145  094c							; If there's no content (only variable decs) then we don't really need to do this.
    146  094c
    147  094c							;.PLY SET 0
    148  094c							;    REPEAT PLY_BANKS
    149  094c
    150  094c							;		      ldx #SHADOW_PLY
    151  094c							;		      ldy #RAMBANK_PLY + .PLY
    152  094c							;jsr CopyShadowROMtoRAM
    153  094c							;.PLY SET .PLY + 1
    154  094c							;    REPEND
    155  094c
    156  094c							; copy the evaluation code/tables
    157  094c							; 3E+ moved from RAM to ROM
    158  094c
    159  094c							;		      ldx #[SLOT2] + SHADOW_EVAL
    160  094c							;		      ldy #[SLOT3] + EVAL
    161  094c							;		      jsr CopyShadowROMtoRAM
    162  094c
    163  094c
    164  094c							;		      ldy #RAMBANK_RAM_PIECELIST
    165  094c							;		      ldx #ROM_PIECELIST
    166  094c							;		      jsr CopyShadowROMtoRAM
    167  094c
    168  094c		       60		      rts
    169  094d
    170  094d
    171  094d				   col1
    172  094d		       84 d4		      .byte.b	NTSC_COLOUR_LINE_1, PAL_COLOUR_LINE_1
    173  094f					      IFCONST	RAINBOW
    174  094f		       94 d4		      .byte.b	(NTSC_COLOUR_LINE_1+16)&$FF, PAL_COLOUR_LINE_1
    175  0951		       a4 d4		      .byte.b	(NTSC_COLOUR_LINE_1+32)&$FF, PAL_COLOUR_LINE_1
    176  0953		       b4 d4		      .byte.b	(NTSC_COLOUR_LINE_1+48)&$FF, PAL_COLOUR_LINE_1
    177  0955		       c4 d4		      .byte.b	(NTSC_COLOUR_LINE_1+64)&$FF, PAL_COLOUR_LINE_1
    178  0957		       d4 d4		      .byte.b	(NTSC_COLOUR_LINE_1+80)&$FF, PAL_COLOUR_LINE_1
    179  0959		       e4 d4		      .byte.b	(NTSC_COLOUR_LINE_1+96)&$FF, PAL_COLOUR_LINE_1
    180  095b		       f4 d4		      .byte.b	(NTSC_COLOUR_LINE_1+112)&$FF, PAL_COLOUR_LINE_1
    181  095d					      ENDIF
    182  095d				   col2
    183  095d		       46 68		      .byte.b	NTSC_COLOUR_LINE_2, PAL_COLOUR_LINE_2
    184  095f					      IFCONST	RAINBOW
    185  095f		       66 68		      .byte.b	(NTSC_COLOUR_LINE_2+32)&$FF, PAL_COLOUR_LINE_2
    186  0961		       76 68		      .byte.b	(NTSC_COLOUR_LINE_2+48)&$FF, PAL_COLOUR_LINE_2
    187  0963		       86 68		      .byte.b	(NTSC_COLOUR_LINE_2+64)&$FF, PAL_COLOUR_LINE_2
    188  0965		       96 68		      .byte.b	(NTSC_COLOUR_LINE_2+80)&$FF, PAL_COLOUR_LINE_2
    189  0967		       a6 68		      .byte.b	(NTSC_COLOUR_LINE_2+96)&$FF, PAL_COLOUR_LINE_2
    190  0969		       b6 68		      .byte.b	(NTSC_COLOUR_LINE_2+112)&$FF, PAL_COLOUR_LINE_2
    191  096b		       c6 68		      .byte.b	(NTSC_COLOUR_LINE_2+128)&$FF, PAL_COLOUR_LINE_2
    192  096d					      ENDIF
    193  096d				   col3
    194  096d		       d8 3a		      .byte.b	NTSC_COLOUR_LINE_3, PAL_COLOUR_LINE_3
    195  096f					      IFCONST	RAINBOW
    196  096f		       f8 3a		      .byte.b	(NTSC_COLOUR_LINE_3+32)&$FF, PAL_COLOUR_LINE_3
    197  0971		       08 3a		      .byte.b	(NTSC_COLOUR_LINE_3+48)&$FF, PAL_COLOUR_LINE_3
    198  0973		       18 3a		      .byte.b	(NTSC_COLOUR_LINE_3+64)&$FF, PAL_COLOUR_LINE_3
    199  0975		       28 3a		      .byte.b	(NTSC_COLOUR_LINE_3+80)&$FF, PAL_COLOUR_LINE_3
    200  0977		       38 3a		      .byte.b	(NTSC_COLOUR_LINE_3+96)&$FF, PAL_COLOUR_LINE_3
    201  0979		       48 3a		      .byte.b	(NTSC_COLOUR_LINE_3+112)&$FF, PAL_COLOUR_LINE_3
    202  097b		       58 3a		      .byte.b	(NTSC_COLOUR_LINE_3+128)&$FF, PAL_COLOUR_LINE_3
    203  097d					      ENDIF
    204  097d
    205  097d
    206  097d					      IFCONST	RAINBOW
      0  097d					      DEF	RainBoard
      1  097d				   SLOT_RainBoard SET	_BANK_SLOT
      2  097d				   BANK_RainBoard SET	SLOT_RainBoard + _CURRENT_BANK
      3  097d				   RainBoard
      4  097d				   TEMPORARY_VAR SET	Overlay
      5  097d				   TEMPORARY_OFFSET SET	0
      6  097d				   VAR_BOUNDARY_RainBoard SET	TEMPORARY_OFFSET
      7  097d				   FUNCTION_NAME SET	RainBoard
    208  097d
    209  097d		       18		      clc
    210  097e		       a5 a6		      lda	base
    211  0980		       69 04		      adc	#4
    212  0982		       85 a6		      sta	base
    213  0984
    214  0984		       29 f0		      and	#$F0
    215  0986		       f0 f5		      beq	RainBoard
    216  0988
    217  0988		       09 08		      ora	#8
    218  098a
    219  098a
    220  098a				   .ROWBANK   SET	[SLOT2]
    221  098a					      REPEAT	8
    222  098a		       a0 80		      ldy	#.ROWBANK
    223  098c		       84 3e		      sty	SET_BANK_RAM
    224  098e
      0  098e					      sta@RAM	SMCOL1+1
      1  098e		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    226  0991
    227  0991		       18		      clc
    228  0992		       69 10		      adc	#16
    229  0994
    230  0994				   .ROWBANK   SET	.ROWBANK + 1
    221  0994					      REPEND
    222  0994		       a0 81		      ldy	#.ROWBANK
    223  0996		       84 3e		      sty	SET_BANK_RAM
    224  0998
      0  0998					      sta@RAM	SMCOL1+1
      1  0998		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    226  099b
    227  099b		       18		      clc
    228  099c		       69 10		      adc	#16
    229  099e
    230  099e				   .ROWBANK   SET	.ROWBANK + 1
    221  099e					      REPEND
    222  099e		       a0 82		      ldy	#.ROWBANK
    223  09a0		       84 3e		      sty	SET_BANK_RAM
    224  09a2
      0  09a2					      sta@RAM	SMCOL1+1
      1  09a2		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    226  09a5
    227  09a5		       18		      clc
    228  09a6		       69 10		      adc	#16
    229  09a8
    230  09a8				   .ROWBANK   SET	.ROWBANK + 1
    221  09a8					      REPEND
    222  09a8		       a0 83		      ldy	#.ROWBANK
    223  09aa		       84 3e		      sty	SET_BANK_RAM
    224  09ac
      0  09ac					      sta@RAM	SMCOL1+1
      1  09ac		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    226  09af
    227  09af		       18		      clc
    228  09b0		       69 10		      adc	#16
    229  09b2
    230  09b2				   .ROWBANK   SET	.ROWBANK + 1
    221  09b2					      REPEND
    222  09b2		       a0 84		      ldy	#.ROWBANK
    223  09b4		       84 3e		      sty	SET_BANK_RAM
    224  09b6
      0  09b6					      sta@RAM	SMCOL1+1
      1  09b6		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    226  09b9
    227  09b9		       18		      clc
    228  09ba		       69 10		      adc	#16
    229  09bc
    230  09bc				   .ROWBANK   SET	.ROWBANK + 1
    221  09bc					      REPEND
    222  09bc		       a0 85		      ldy	#.ROWBANK
    223  09be		       84 3e		      sty	SET_BANK_RAM
    224  09c0
      0  09c0					      sta@RAM	SMCOL1+1
      1  09c0		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    226  09c3
    227  09c3		       18		      clc
    228  09c4		       69 10		      adc	#16
    229  09c6
    230  09c6				   .ROWBANK   SET	.ROWBANK + 1
    221  09c6					      REPEND
    222  09c6		       a0 86		      ldy	#.ROWBANK
    223  09c8		       84 3e		      sty	SET_BANK_RAM
    224  09ca
      0  09ca					      sta@RAM	SMCOL1+1
      1  09ca		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    226  09cd
    227  09cd		       18		      clc
    228  09ce		       69 10		      adc	#16
    229  09d0
    230  09d0				   .ROWBANK   SET	.ROWBANK + 1
    221  09d0					      REPEND
    222  09d0		       a0 87		      ldy	#.ROWBANK
    223  09d2		       84 3e		      sty	SET_BANK_RAM
    224  09d4
      0  09d4					      sta@RAM	SMCOL1+1
      1  09d4		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    226  09d7
    227  09d7		       18		      clc
    228  09d8		       69 10		      adc	#16
    229  09da
    230  09da				   .ROWBANK   SET	.ROWBANK + 1
    231  09da					      REPEND
    232  09da
    233  09da		       60		      rts
    234  09db					      ENDIF
    235  09db
    236  09db
    237  09db							;---------------------------------------------------------------------------------------------------
    238  09db
      0  09db					      DEF	CopyShadowROMtoRAM
      1  09db				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  09db				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  09db				   CopyShadowROMtoRAM
      4  09db				   TEMPORARY_VAR SET	Overlay
      5  09db				   TEMPORARY_OFFSET SET	0
      6  09db				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  09db				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    240  09db					      SUBROUTINE
    241  09db
      0  09db					      REF	SetupBanks	;✅
      1  09db				  -	      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  09db				  -TEMPORARY_VAR SET	VAREND_SetupBanks
      3  09db					      ENDIF
    243  09db
      0  09db					      VEND	CopyShadowROMtoRAM
      1  09db
      2  09db
      3  09db		       00 a7	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
      4  09db
    245  09db
    246  09db							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    247  09db							; used to setup callable RAM code from ROM templates
    248  09db
    249  09db							; x = source ROM bank
    250  09db							; y = destination RAM bank (preserved)
    251  09db
    252  09db		       86 3f		      stx	SET_BANK
    253  09dd		       84 3e		      sty	SET_BANK_RAM
    254  09df
    255  09df		       a2 00		      ldx	#0
    256  09e1		       bd 00 f8    .copyPage  lda	$F800,x
      0  09e4					      sta@RAM	$FC00,x
      1  09e4		       9d 00 fe 	      sta	[RAM]+$FC00,x
    258  09e7		       bd 00 f9 	      lda	$F900,x
      0  09ea					      sta@RAM	$FD00,x
      1  09ea		       9d 00 ff 	      sta	[RAM]+$FD00,x
    260  09ed		       ca		      dex
    261  09ee		       d0 f1		      bne	.copyPage
    262  09f0		       60		      rts
    263  09f1
    264  09f1
    265  09f1							;---------------------------------------------------------------------------------------------------
    266  09f1
      0  09f1					      DEF	InitialisePieceSquares
      1  09f1				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  09f1				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  09f1				   InitialisePieceSquares
      4  09f1				   TEMPORARY_VAR SET	Overlay
      5  09f1				   TEMPORARY_OFFSET SET	0
      6  09f1				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  09f1				   FUNCTION_NAME SET	InitialisePieceSquares
    268  09f1					      SUBROUTINE
    269  09f1
      0  09f1					      REF	COMMON_VARS
      1  09f1					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  09f1				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  09f1					      ENDIF
      0  09f1					      REF	StartupBankReset	;✅
      1  09f1				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  09f1				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  09f1					      ENDIF
    272  09f1
      0  09f1					      VAR	__initPiece, 1
      1  09f1		       00 b7	   __initPiece =	TEMPORARY_VAR
      2  09f1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  09f1
      4  09f1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  09f1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  09f1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  09f1					      ENDIF
      8  09f1				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  09f1				  -VNAME      SETSTR	__initPiece
     10  09f1				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  09f1				  -	      ERR
     12  09f1					      ENDIF
      0  09f1					      VAR	__initSquare, 1
      1  09f1		       00 b8	   __initSquare =	TEMPORARY_VAR
      2  09f1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  09f1
      4  09f1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  09f1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  09f1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  09f1					      ENDIF
      8  09f1				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  09f1				  -VNAME      SETSTR	__initSquare
     10  09f1				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  09f1				  -	      ERR
     12  09f1					      ENDIF
      0  09f1					      VAR	__initListPtr, 1
      1  09f1		       00 b9	   __initListPtr =	TEMPORARY_VAR
      2  09f1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  09f1
      4  09f1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  09f1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  09f1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  09f1					      ENDIF
      8  09f1				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  09f1				  -VNAME      SETSTR	__initListPtr
     10  09f1				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  09f1				  -	      ERR
     12  09f1					      ENDIF
      0  09f1					      VAR	__op, 1
      1  09f1		       00 ba	   __op       =	TEMPORARY_VAR
      2  09f1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  09f1
      4  09f1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  09f1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  09f1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  09f1					      ENDIF
      8  09f1				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  09f1				  -VNAME      SETSTR	__op
     10  09f1				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  09f1				  -	      ERR
     12  09f1					      ENDIF
    277  09f1
      0  09f1					      VEND	InitialisePieceSquares
      1  09f1
      2  09f1
      3  09f1		       00 bb	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
      4  09f1
    279  09f1
    280  09f1		       a9 00		      lda	#0
    281  09f3		       85 90		      sta	Evaluation
    282  09f5		       85 91		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    283  09f7		       85 94		      sta	enPassantPawn	; no en-passant
    284  09f9
    285  09f9
      0  09f9					      PHASE	StartClearBoard
      1  09f9		       a9 0d		      lda	#AI_StartClearBoard
      2  09fb		       85 8c		      sta	aiState
    287  09fd
    288  09fd		       a2 00		      ldx	#0
    289  09ff				   .fillPieceLists
    290  09ff
    291  09ff
    292  09ff		       bd 51 f6 	      lda	InitPieceList,x	; colour/-1
    293  0a02		       f0 4c		      beq	.exit
    294  0a04		       85 ba		      sta	__op	; type
    295  0a06		       bc 52 f6 	      ldy	InitPieceList+1,x	; square
    296  0a09		       84 b8		      sty	__initSquare
    297  0a0b
    298  0a0b		       a9 e3		      lda	#RAMBANK_BOARD
    299  0a0d		       85 3e		      sta	SET_BANK_RAM
    300  0a0f		       a5 ba		      lda	__op
      0  0a11					      sta@RAM	Board,y
      1  0a11		       99 79 fe 	      sta	[RAM]+Board,y
    302  0a14		       10 0d		      bpl	.white
    303  0a16
      0  0a16					      NEGEVAL
      1  0a16
      2  0a16		       38		      sec
      3  0a17		       a9 00		      lda	#0
      4  0a19		       e5 90		      sbc	Evaluation
      5  0a1b		       85 90		      sta	Evaluation
      6  0a1d		       a9 00		      lda	#0
      7  0a1f		       e5 91		      sbc	Evaluation+1
      8  0a21		       85 91		      sta	Evaluation+1
      9  0a23
    305  0a23				   .white
    306  0a23
    307  0a23		       86 b9		      stx	__initListPtr
    308  0a25
    309  0a25							; Add the material value of the piece to the evaluation
    310  0a25
    311  0a25		       a5 ba		      lda	__op
    312  0a27		       a2 89		      ldx	#BANK_AddPieceMaterialValue
    313  0a29		       86 3f		      stx	SET_BANK	;@2
    314  0a2b		       20 36 f9 	      jsr	AddPieceMaterialValue
    315  0a2e
    316  0a2e
    317  0a2e							; add the positional value of the piece to the evaluation
    318  0a2e
    319  0a2e		       a4 b8		      ldy	__initSquare
    320  0a30		       a5 ba		      lda	__op
    321  0a32		       a2 89		      ldx	#BANK_AddPiecePositionValue
    322  0a34		       86 3f		      stx	SET_BANK
    323  0a36		       20 59 f9 	      jsr	AddPiecePositionValue
    324  0a39
    325  0a39		       a5 ba		      lda	__op	; type/colour
    326  0a3b		       10 0d		      bpl	.white2
      0  0a3d					      NEGEVAL
      1  0a3d
      2  0a3d		       38		      sec
      3  0a3e		       a9 00		      lda	#0
      4  0a40		       e5 90		      sbc	Evaluation
      5  0a42		       85 90		      sta	Evaluation
      6  0a44		       a9 00		      lda	#0
      7  0a46		       e5 91		      sbc	Evaluation+1
      8  0a48		       85 91		      sta	Evaluation+1
      9  0a4a
    328  0a4a				   .white2
    329  0a4a
    330  0a4a		       a6 b9		      ldx	__initListPtr
    331  0a4c		       e8		      inx
    332  0a4d		       e8		      inx
    333  0a4e		       10 af		      bpl	.fillPieceLists
    334  0a50
    335  0a50				   .exit
    336  0a50		       60		      rts
    337  0a51
    338  0a51
    339  0a51				   InitPieceList
    340  0a51
    341  0a51
    342  0a51					      IF	!TEST_POSITION
    343  0a51
    344  0a51		       06 19		      .byte.b	WHITE|Q, 25
    345  0a53		       04 18		      .byte.b	WHITE|B, 24
    346  0a55		       04 1b		      .byte.b	WHITE|B, 27
    347  0a57		       05 16		      .byte.b	WHITE|R, 22
    348  0a59		       05 1d		      .byte.b	WHITE|R, 29
    349  0a5b		       03 17		      .byte.b	WHITE|N, 23
    350  0a5d		       03 1c		      .byte.b	WHITE|N, 28
    351  0a5f
    352  0a5f		       01 23		      .byte.b	WHITE|WP, 35
    353  0a61		       01 24		      .byte.b	WHITE|WP, 36
    354  0a63		       01 22		      .byte.b	WHITE|WP, 34
    355  0a65		       01 25		      .byte.b	WHITE|WP, 37
    356  0a67		       01 21		      .byte.b	WHITE|WP, 33
    357  0a69		       01 26		      .byte.b	WHITE|WP, 38
    358  0a6b		       01 20		      .byte.b	WHITE|WP, 32
    359  0a6d		       01 27		      .byte.b	WHITE|WP, 39
    360  0a6f
    361  0a6f		       07 1a		      .byte.b	WHITE|K, 26
    362  0a71
    363  0a71		       86 5f		      .byte.b	BLACK|Q, 95
    364  0a73		       84 5e		      .byte.b	BLACK|B, 94
    365  0a75		       84 61		      .byte.b	BLACK|B, 97
    366  0a77		       85 5c		      .byte.b	BLACK|R, 92
    367  0a79		       85 63		      .byte.b	BLACK|R, 99
    368  0a7b		       83 5d		      .byte.b	BLACK|N, 93
    369  0a7d		       83 62		      .byte.b	BLACK|N, 98
    370  0a7f
    371  0a7f		       82 55		      .byte.b	BLACK|BP, 85
    372  0a81		       82 56		      .byte.b	BLACK|BP, 86
    373  0a83		       82 54		      .byte.b	BLACK|BP, 84
    374  0a85		       82 57		      .byte.b	BLACK|BP, 87
    375  0a87		       82 53		      .byte.b	BLACK|BP, 83
    376  0a89		       82 58		      .byte.b	BLACK|BP, 88
    377  0a8b		       82 52		      .byte.b	BLACK|BP, 82
    378  0a8d		       82 59		      .byte.b	BLACK|BP, 89
    379  0a8f
    380  0a8f		       87 60		      .byte.b	BLACK|K, 96
    381  0a91
    382  0a91		       00		      .byte.b	0	;end
    383  0a92
    384  0a92				  -	      ELSE		; test position...
    385  0a92				  -
    386  0a92				  -	      IF	0
    387  0a92				  -			; make sure illegal moves leaving K in check are removed
    388  0a92				  -
    389  0a92				  -	      .byte	WHITE|N, 28
    390  0a92				  -	      .byte	WHITE|K, 26
    391  0a92				  -
    392  0a92				  -	      .byte	BLACK|Q, 29
    393  0a92				  -
    394  0a92				  -	      .byte	0	;end
    395  0a92				  -
    396  0a92				  -	      ENDIF
    397  0a92				  -
    398  0a92				  -	      IF	0
    399  0a92				  -
    400  0a92				  -	      .byte	WHITE|K, 28
    401  0a92				  -	      .byte	WHITE|WP, 37
    402  0a92				  -	      .byte	WHITE|WP, 38
    403  0a92				  -	      .byte	WHITE|WP, 53
    404  0a92				  -	      .byte	WHITE|WP, 49
    405  0a92				  -	      .byte	WHITE|WP, 32
    406  0a92				  -	      .byte	WHITE|R, 27
    407  0a92				  -	      .byte	WHITE|B, 46
    408  0a92				  -	      .byte	WHITE|R, 54
    409  0a92				  -
    410  0a92				  -	      .byte	BLACK|BP, 56
    411  0a92				  -	      .byte	BLACK|BP, 87
    412  0a92				  -	      .byte	BLACK|BP, 88
    413  0a92				  -	      .byte	BLACK|BP, 89
    414  0a92				  -	      .byte	BLACK|BP, 84
    415  0a92				  -	      .byte	BLACK|B, 66
    416  0a92				  -	      .byte	BLACK|R, 69
    417  0a92				  -	      .byte	BLACK|K, 98
    418  0a92				  -
    419  0a92				  -	      .byte	BLACK|R, 92
    420  0a92				  -
    421  0a92				  -
    422  0a92				  -
    423  0a92				  -	      ENDIF
    424  0a92				  -
    425  0a92				  -	      IF	TEST_POSITION & 0
    426  0a92				  -			; Castling across/into check
    427  0a92				  -			; pawn promotion
    428  0a92				  -
    429  0a92				  -	      .byte	WHITE|K, 26
    430  0a92				  -	      .byte	WHITE|R, 29
    431  0a92				  -	      .byte	BLACK|B, 45
    432  0a92				  -	      .byte	WHITE|Q, 72
    433  0a92				  -	      .byte	BLACK|N, 84
    434  0a92				  -	      .byte	WHITE|WP,89
    435  0a92				  -
    436  0a92				  -	      ENDIF
    437  0a92				  -
    438  0a92				  -
    439  0a92				  -
    440  0a92				  -	      IF	TEST_POSITION & 0
    441  0a92				  -			; En passant test
    442  0a92				  -
    443  0a92				  -	      .byte	BLACK|BP, 88
    444  0a92				  -	      .byte	BLACK|BP, 86
    445  0a92				  -
    446  0a92				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    447  0a92				  -	      .byte	WHITE|K, 52
    448  0a92				  -
    449  0a92				  -
    450  0a92				  -	      ENDIF
    451  0a92				  -
    452  0a92				  -	      IF	TEST_POSITION & 0
    453  0a92				  -			; En passant test (white)
    454  0a92				  -
    455  0a92				  -	      .byte	BLACK|BP|FLAG_MOVED, 53
    456  0a92				  -
    457  0a92				  -	      .byte	WHITE|WP, 34
    458  0a92				  -	      .byte	WHITE|K, 52
    459  0a92				  -
    460  0a92				  -
    461  0a92				  -	      .byte	BLACK|BP, 88
    462  0a92				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    463  0a92				  -
    464  0a92				  -
    465  0a92				  -	      ENDIF
    466  0a92				  -
    467  0a92				  -
    468  0a92				  -	      IF	TEST_POSITION & 0
    469  0a92				  -			; castle
    470  0a92				  -
    471  0a92				  -	      .byte	BLACK|R, 99
    472  0a92				  -	      .byte	BLACK|K, 96
    473  0a92				  -	      .byte	BLACK|BP, 89
    474  0a92				  -	      .byte	BLACK|BP, 88
    475  0a92				  -
    476  0a92				  -			;.byte WHITE|WP, 37
    477  0a92				  -			;.byte WHITE|WP, 38
    478  0a92				  -			;.byte WHITE|WP, 39
    479  0a92				  -	      .byte	WHITE|R,29
    480  0a92				  -	      .byte	WHITE|K, 26
    481  0a92				  -
    482  0a92				  -	      ENDIF
    483  0a92				  -
    484  0a92				  -
    485  0a92				  -	      IF	TEST_POSITION & 1
    486  0a92				  -			; mate/draw
    487  0a92				  -
    488  0a92				  -	      .byte	BLACK|K, 99
    489  0a92				  -
    490  0a92				  -	      .byte	WHITE|Q,78
    491  0a92				  -	      .byte	WHITE|K, 79
    492  0a92				  -
    493  0a92				  -	      ENDIF
    494  0a92				  -
    495  0a92				  -
    496  0a92				  -	      IF	TEST_POSITION & 0
    497  0a92				  -			; promote test
    498  0a92				  -
    499  0a92				  -	      .byte	BLACK|K, 22
    500  0a92				  -	      .byte	BLACK|N, 96
    501  0a92				  -
    502  0a92				  -	      .byte	WHITE|WP, 87
    503  0a92				  -	      .byte	WHITE|R,95
    504  0a92				  -	      .byte	WHITE|R,94
    505  0a92				  -	      .byte	WHITE|K, 52
    506  0a92				  -
    507  0a92				  -
    508  0a92				  -	      ENDIF
    509  0a92				  -
    510  0a92				  -
    511  0a92				  -
    512  0a92				  -	      IF	0
    513  0a92				  -
    514  0a92				  -
    515  0a92				  -			;.byte BLACK|R, 97
    516  0a92				  -	      .byte	BLACK|K, 98
    517  0a92				  -	      .byte	BLACK|BP, 87
    518  0a92				  -	      .byte	BLACK|BP, 88
    519  0a92				  -	      .byte	BLACK|BP, 89
    520  0a92				  -			;    .byte BLACK|B, 76
    521  0a92				  -
    522  0a92				  -
    523  0a92				  -	      .byte	WHITE|R,28
    524  0a92				  -	      .byte	WHITE|Q,58
    525  0a92				  -			;   .byte WHITE|N,65
    526  0a92				  -	      ENDIF
    527  0a92				  -
    528  0a92				  -	      IF	0
    529  0a92				  -			;.byte WHITE|WP, 56
    530  0a92				  -
    531  0a92				  -
    532  0a92				  -	      .byte	BLACK|K, 98
    533  0a92				  -
    534  0a92				  -
    535  0a92				  -	      .byte	WHITE|R,29
    536  0a92				  -	      .byte	WHITE|Q,49
    537  0a92				  -	      .byte	WHITE|N,65
    538  0a92				  -	      ENDIF
    539  0a92				  -	      .byte	0	;end
    540  0a92				  -
    541  0a92					      ENDIF
    542  0a92
    543  0a92
    544  0a92
    545  0a92							;---------------------------------------------------------------------------------------------------
    546  0a92
      0  0a92					      DEF	aiSpecialMoveFixup
      1  0a92				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  0a92				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  0a92				   aiSpecialMoveFixup
      4  0a92				   TEMPORARY_VAR SET	Overlay
      5  0a92				   TEMPORARY_OFFSET SET	0
      6  0a92				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  0a92				   FUNCTION_NAME SET	aiSpecialMoveFixup
    548  0a92					      SUBROUTINE
    549  0a92
      0  0a92					      REF	COMMON_VARS
      1  0a92					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0a92				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0a92					      ENDIF
      0  0a92					      REF	AiStateMachine	;✅
      1  0a92				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a92				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a92					      ENDIF
      0  0a92					      VEND	aiSpecialMoveFixup
      1  0a92
      2  0a92
      3  0a92		       00 b7	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
      4  0a92
    553  0a92
    554  0a92		       ad 84 02 	      lda	INTIM
    555  0a95		       c9 2d		      cmp	#SPEEDOF_CopySinglePiece+4
    556  0a97		       b0 01		      bcs	.cont
    557  0a99		       60		      rts
    558  0a9a
    559  0a9a
    560  0a9a				   .cont
    561  0a9a
      0  0a9a					      PHASE	DelayAfterPlaced
      1  0a9a		       a9 27		      lda	#AI_DelayAfterPlaced
      2  0a9c		       85 8c		      sta	aiState
    563  0a9e
    564  0a9e
    565  0a9e							; Special move fixup
    566  0a9e
    567  0a9e		       a5 95		      lda	currentPly
    568  0aa0		       85 3e		      sta	SET_BANK_RAM
    569  0aa2
    570  0aa2		       20 d3 f6 	      jsr	CastleFixupDraw
    571  0aa5
    572  0aa5		       a5 86		      lda	fromX12
    573  0aa7		       85 81		      sta	squareToDraw
    574  0aa9
    575  0aa9		       60		      rts
    576  0aaa
    577  0aaa
    578  0aaa							;---------------------------------------------------------------------------------------------------
    579  0aaa
      0  0aaa					      DEF	aiEPFlash
      1  0aaa				   SLOT_aiEPFlash SET	_BANK_SLOT
      2  0aaa				   BANK_aiEPFlash SET	SLOT_aiEPFlash + _CURRENT_BANK
      3  0aaa				   aiEPFlash
      4  0aaa				   TEMPORARY_VAR SET	Overlay
      5  0aaa				   TEMPORARY_OFFSET SET	0
      6  0aaa				   VAR_BOUNDARY_aiEPFlash SET	TEMPORARY_OFFSET
      7  0aaa				   FUNCTION_NAME SET	aiEPFlash
    581  0aaa					      SUBROUTINE
    582  0aaa
      0  0aaa					      REF	Variable_PieceShapeBuffer
      1  0aaa					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0aaa				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0aaa					      ENDIF
      0  0aaa					      REF	AiStateMachine
      1  0aaa				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0aaa				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0aaa					      ENDIF
      0  0aaa					      VEND	aiEPFlash
      1  0aaa
      2  0aaa
      3  0aaa		       00 ef	   VAREND_aiEPFlash =	TEMPORARY_VAR
      4  0aaa
    586  0aaa
    587  0aaa		       a5 83		      lda	drawDelay
    588  0aac		       f0 03		      beq	.deCount
    589  0aae		       c6 83		      dec	drawDelay
    590  0ab0		       60		      rts
    591  0ab1
    592  0ab1		       a5 85	   .deCount   lda	drawCount
    593  0ab3		       f0 0e		      beq	.flashDone2
    594  0ab5		       c6 85		      dec	drawCount
    595  0ab7
    596  0ab7		       a9 0a		      lda	#10
    597  0ab9		       85 83		      sta	drawDelay	; "getting ready to move" flash
    598  0abb
    599  0abb		       a5 94		      lda	enPassantPawn
    600  0abd		       85 81		      sta	squareToDraw
    601  0abf
    602  0abf							; WARNING - local variables will not survive the following call...!
    603  0abf		       20 c8 f0 	      jsr	CopySinglePiece	;@0
    604  0ac2		       60		      rts
    605  0ac3
    606  0ac3				   .flashDone2
    607  0ac3
    608  0ac3
    609  0ac3		       a9 00		      lda	#0	; on/off count
    610  0ac5		       85 85		      sta	drawCount	; flashing for piece about to move
    611  0ac7		       a9 00		      lda	#0
    612  0ac9		       85 83		      sta	drawDelay
    613  0acb
    614  0acb		       20 9f f3 	      jsr	EnPassantRemoveCapturedPawn
    615  0ace
    616  0ace							;lda #100
    617  0ace							;sta aiFlashDelay ;???
    618  0ace
      0  0ace					      PHASE	FinalFlash
      1  0ace		       a9 1b		      lda	#AI_FinalFlash
      2  0ad0		       85 8c		      sta	aiState
    620  0ad2		       60		      rts
    621  0ad3
    622  0ad3
    623  0ad3							;---------------------------------------------------------------------------------------------------
    624  0ad3
      0  0ad3					      DEF	CastleFixupDraw
      1  0ad3				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  0ad3				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  0ad3				   CastleFixupDraw
      4  0ad3				   TEMPORARY_VAR SET	Overlay
      5  0ad3				   TEMPORARY_OFFSET SET	0
      6  0ad3				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  0ad3				   FUNCTION_NAME SET	CastleFixupDraw
    626  0ad3					      SUBROUTINE
    627  0ad3
      0  0ad3					      REF	aiSpecialMoveFixup	;✅
      1  0ad3					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0ad3				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0ad3					      ENDIF
      0  0ad3					      VEND	CastleFixupDraw
      1  0ad3
      2  0ad3
      3  0ad3		       00 b7	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
      4  0ad3
    630  0ad3
    631  0ad3							; guarantee flags for piece, post-move, are correct
    632  0ad3
    633  0ad3
    634  0ad3		       a9 e3		      lda	#RAMBANK_BOARD
    635  0ad5		       85 3e		      sta	SET_BANK_RAM	;@2
    636  0ad7
    637  0ad7		       a5 97		      lda	fromPiece
    638  0ad9		       29 df		      and	#~FLAG_ENPASSANT
    639  0adb		       09 40		      ora	#FLAG_MOVED
    640  0add
    641  0add		       a4 86		      ldy	fromX12	; destination
      0  0adf					      sta@RAM	Board,y
      1  0adf		       99 79 fe 	      sta	[RAM]+Board,y
    643  0ae2
    644  0ae2
    645  0ae2							; fixup any castling issues
    646  0ae2							; at this point the king has finished his two-square march
    647  0ae2							; based on the finish square, we determine which rook we're interacting with
    648  0ae2							; and generate a 'move' for the rook to position on the other side of the king
    649  0ae2
    650  0ae2
    651  0ae2					      IF	CASTLING_ENABLED
      0  0ae2					      CALL	GenCastleMoveForRook	;@3
      1  0ae2				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  0ae2				  -FNAME      SETSTR	GenCastleMoveForRook
      3  0ae2				  -	      ECHO	""
      4  0ae2				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0ae2				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0ae2				  -	      ERR
      7  0ae2					      ENDIF
      8  0ae2		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      9  0ae4		       85 3f		      sta	SET_BANK
     10  0ae6		       20 22 fc 	      jsr	GenCastleMoveForRook
    653  0ae9		       b0 07		      bcs	.phase
    654  0aeb					      ENDIF
    655  0aeb
      0  0aeb					      SWAP
      1  0aeb
      2  0aeb		       a5 96		      lda	sideToMove
      3  0aed		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  0aef		       85 96		      sta	sideToMove
      5  0af1
    657  0af1		       60		      rts
    658  0af2
    659  0af2				   .phase
    660  0af2
    661  0af2							; in this siutation (castle, rook moving) we do not change sides yet!
    662  0af2
      0  0af2					      PHASE	MoveIsSelected
      1  0af2		       a9 14		      lda	#AI_MoveIsSelected
      2  0af4		       85 8c		      sta	aiState
    664  0af6		       60		      rts
    665  0af7
    666  0af7
    667  0af7							;---------------------------------------------------------------------------------------------------
    668  0af7
      0  0af7					      DEF	aiDrawEntireBoard
      1  0af7				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  0af7				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  0af7				   aiDrawEntireBoard
      4  0af7				   TEMPORARY_VAR SET	Overlay
      5  0af7				   TEMPORARY_OFFSET SET	0
      6  0af7				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  0af7				   FUNCTION_NAME SET	aiDrawEntireBoard
    670  0af7					      SUBROUTINE
    671  0af7
      0  0af7					      REF	Variable_PieceShapeBuffer
      1  0af7					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0af7				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0af7					      ENDIF
      0  0af7					      REF	AiStateMachine	;✅
      1  0af7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0af7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0af7					      ENDIF
    674  0af7
      0  0af7					      VEND	aiDrawEntireBoard
      1  0af7
      2  0af7
      3  0af7		       00 ef	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
      4  0af7
    676  0af7
    677  0af7
    678  0af7		       ad 84 02 	      lda	INTIM
    679  0afa		       c9 2d		      cmp	#SPEEDOF_CopySinglePiece+4
    680  0afc		       90 2c		      bcc	.exit
    681  0afe
    682  0afe							; We use [SLOT3] for accessing board
    683  0afe
    684  0afe		       a9 e3		      lda	#RAMBANK_BOARD
    685  0b00		       85 3e		      sta	SET_BANK_RAM
    686  0b02		       a4 81		      ldy	squareToDraw
    687  0b04		       b9 15 fc 	      lda	ValidSquare,y
    688  0b07		       30 1d		      bmi	.isablank2
    689  0b09
    690  0b09		       b9 79 fc 	      lda	Board,y
    691  0b0c		       f0 13		      beq	.isablank
    692  0b0e		       48		      pha
    693  0b0f		       a9 00		      lda	#BLANK
      0  0b11					      sta@RAM	Board,y
      1  0b11		       99 79 fe 	      sta	[RAM]+Board,y
    695  0b14
    696  0b14							; WARNING - local variables will not survive the following call...!
    697  0b14		       20 c8 f0 	      jsr	CopySinglePiece	;@0
    698  0b17
    699  0b17		       a9 e3		      lda	#RAMBANK_BOARD
    700  0b19		       85 3e		      sta	SET_BANK_RAM
    701  0b1b
    702  0b1b		       a4 81		      ldy	squareToDraw
    703  0b1d		       68		      pla
      0  0b1e					      sta@RAM	Board,y
      1  0b1e		       99 79 fe 	      sta	[RAM]+Board,y
    705  0b21
      0  0b21				   .isablank  PHASE	DrawPart2
      1  0b21		       a9 10		      lda	#AI_DrawPart2
      2  0b23		       85 8c		      sta	aiState
    707  0b25		       60		      rts
    708  0b26
      0  0b26				   .isablank2 PHASE	DrawPart3
      1  0b26		       a9 11		      lda	#AI_DrawPart3
      2  0b28		       85 8c		      sta	aiState
    710  0b2a		       60	   .exit      rts
    711  0b2b
    712  0b2b
    713  0b2b							;---------------------------------------------------------------------------------------------------
    714  0b2b
      0  0b2b					      DEF	aiDrawPart2
      1  0b2b				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  0b2b				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  0b2b				   aiDrawPart2
      4  0b2b				   TEMPORARY_VAR SET	Overlay
      5  0b2b				   TEMPORARY_OFFSET SET	0
      6  0b2b				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  0b2b				   FUNCTION_NAME SET	aiDrawPart2
    716  0b2b					      SUBROUTINE
    717  0b2b
      0  0b2b					      REF	Variable_PieceShapeBuffer
      1  0b2b					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0b2b				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0b2b					      ENDIF
      0  0b2b					      REF	AiStateMachine
      1  0b2b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0b2b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0b2b					      ENDIF
      0  0b2b					      VEND	aiDrawPart2
      1  0b2b
      2  0b2b
      3  0b2b		       00 ef	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
      4  0b2b
    721  0b2b
    722  0b2b							; WARNING - local variables will not survive the following call...!
    723  0b2b		       20 c8 f0 	      jsr	CopySinglePiece	;@0
    724  0b2e
      0  0b2e					      DEF	aiDrawPart3
      1  0b2e				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  0b2e				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  0b2e				   aiDrawPart3
      4  0b2e				   TEMPORARY_VAR SET	Overlay
      5  0b2e				   TEMPORARY_OFFSET SET	0
      6  0b2e				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  0b2e				   FUNCTION_NAME SET	aiDrawPart3
    726  0b2e					      SUBROUTINE
    727  0b2e
    728  0b2e		       c6 81		      dec	squareToDraw
    729  0b30		       a5 81		      lda	squareToDraw
    730  0b32		       c9 16		      cmp	#22
    731  0b34		       90 05		      bcc	.comp
    732  0b36
      0  0b36					      PHASE	DrawEntireBoard
      1  0b36		       a9 0f		      lda	#AI_DrawEntireBoard
      2  0b38		       85 8c		      sta	aiState
    734  0b3a		       60		      rts
    735  0b3b
    736  0b3b				   .comp
    737  0b3b
    738  0b3b							;SPEAK SAY_how_about
    739  0b3b
    740  0b3b		       a9 ff		      lda	#-1
    741  0b3d		       85 87		      sta	toX12	; becomes startup flash square
    742  0b3f		       a9 24		      lda	#36	; becomes cursor position
    743  0b41		       85 88		      sta	originX12
    744  0b43
    745  0b43
      0  0b43					      PHASE	GenerateMoves
      1  0b43		       a9 12		      lda	#AI_GenerateMoves
      2  0b45		       85 8c		      sta	aiState
    747  0b47		       60		      rts
    748  0b48
    749  0b48
    750  0b48							;---------------------------------------------------------------------------------------------------
    751  0b48
      0  0b48					      DEF	aiMarchB
      1  0b48				   SLOT_aiMarchB SET	_BANK_SLOT
      2  0b48				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  0b48				   aiMarchB
      4  0b48				   TEMPORARY_VAR SET	Overlay
      5  0b48				   TEMPORARY_OFFSET SET	0
      6  0b48				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  0b48				   FUNCTION_NAME SET	aiMarchB
    753  0b48					      SUBROUTINE
    754  0b48
      0  0b48					      REF	Variable_PieceShapeBuffer
      1  0b48					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0b48				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0b48					      ENDIF
      0  0b48					      REF	AiStateMachine
      1  0b48				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0b48				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0b48					      ENDIF
      0  0b48					      VEND	aiMarchB
      1  0b48
      2  0b48
      3  0b48		       00 ef	   VAREND_aiMarchB =	TEMPORARY_VAR
      4  0b48
    758  0b48
    759  0b48							; Draw the piece in the new square
    760  0b48
    761  0b48		       a5 86		      lda	fromX12
    762  0b4a		       85 81		      sta	squareToDraw
    763  0b4c
    764  0b4c							; WARNING - local variables will not survive the following call...!
    765  0b4c		       20 c8 f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
    766  0b4f
    767  0b4f		       a9 02		      lda	#2	; snail trail delay
    768  0b51		       85 83		      sta	drawDelay
    769  0b53
      0  0b53					      PHASE	MarchToTargetB
      1  0b53		       a9 19		      lda	#AI_MarchToTargetB
      2  0b55		       85 8c		      sta	aiState
    771  0b57		       60		      rts
    772  0b58
    773  0b58
    774  0b58							;---------------------------------------------------------------------------------------------------
    775  0b58
      0  0b58					      DEF	aiDraw
      1  0b58				   SLOT_aiDraw SET	_BANK_SLOT
      2  0b58				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  0b58				   aiDraw
      4  0b58				   TEMPORARY_VAR SET	Overlay
      5  0b58				   TEMPORARY_OFFSET SET	0
      6  0b58				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  0b58				   FUNCTION_NAME SET	aiDraw
    777  0b58					      SUBROUTINE
    778  0b58
    779  0b58		       a6 a5		      ldx	platform
    780  0b5a		       bd 60 f7 	      lda	colGreen,x
    781  0b5d		       85 49		      sta	COLUBK
    782  0b5f		       60		      rts
    783  0b60
    784  0b60				   colGreen
    785  0b60		       c2 34		      .byte.b	$C2, $34
    786  0b62
    787  0b62							;---------------------------------------------------------------------------------------------------
    788  0b62
      0  0b62					      DEF	aiCheckMate
      1  0b62				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  0b62				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  0b62				   aiCheckMate
      4  0b62				   TEMPORARY_VAR SET	Overlay
      5  0b62				   TEMPORARY_OFFSET SET	0
      6  0b62				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  0b62				   FUNCTION_NAME SET	aiCheckMate
    790  0b62					      SUBROUTINE
    791  0b62		       a6 a5		      ldx	platform
    792  0b64		       bd 6a f7 	      lda	colRed,x
    793  0b67		       85 49		      sta	COLUBK
    794  0b69		       60		      rts
    795  0b6a
    796  0b6a				   colRed
    797  0b6a		       42 64		      .byte.b	$42, $64
    798  0b6c
    799  0b6c							;---------------------------------------------------------------------------------------------------
    800  0b6c
      0  0b6c					      DEF	aiQuiescent
      1  0b6c				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  0b6c				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  0b6c				   aiQuiescent
      4  0b6c				   TEMPORARY_VAR SET	Overlay
      5  0b6c				   TEMPORARY_OFFSET SET	0
      6  0b6c				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  0b6c				   FUNCTION_NAME SET	aiQuiescent
    802  0b6c					      SUBROUTINE
    803  0b6c
      0  0b6c					      REF	AiStateMachine
      1  0b6c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0b6c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0b6c					      ENDIF
      0  0b6c					      VEND	aiQuiescent
      1  0b6c
      2  0b6c
      3  0b6c		       00 a9	   VAREND_aiQuiescent =	TEMPORARY_VAR
      4  0b6c
    806  0b6c
    807  0b6c							; Move has been selected
    808  0b6c
    809  0b6c		       a9 ff		      lda	#-1
    810  0b6e		       85 89		      sta	cursorX12
    811  0b70
    812  0b70		       a5 86		      lda	fromX12
    813  0b72		       85 88		      sta	originX12
      0  0b74					      CALL	GetPiece	;@3		    ; from the movelist
      1  0b74				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  0b74				  -FNAME      SETSTR	GetPiece
      3  0b74				  -	      ECHO	""
      4  0b74				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0b74				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0b74				  -	      ERR
      7  0b74					      ENDIF
      8  0b74		       a9 d9		      lda	#BANK_GetPiece
      9  0b76		       85 3f		      sta	SET_BANK
     10  0b78		       20 01 fc 	      jsr	GetPiece
    815  0b7b
    816  0b7b		       a4 86		      ldy	fromX12
    817  0b7d		       a9 e3		      lda	#RAMBANK_BOARD
    818  0b7f		       85 3e		      sta	SET_BANK_RAM	;@3
    819  0b81		       b9 79 fc 	      lda	Board,y
    820  0b84		       45 97		      eor	fromPiece
    821  0b86		       29 07		      and	#PIECE_MASK	; if not the same piece board/movelist...
    822  0b88		       d0 05		      bne	.promote	; promote a pawn
    823  0b8a
      0  0b8a					      PHASE	MoveIsSelected
      1  0b8a		       a9 14		      lda	#AI_MoveIsSelected
      2  0b8c		       85 8c		      sta	aiState
    825  0b8e		       60		      rts
    826  0b8f
      0  0b8f				   .promote   PHASE	PromotePawnStart
      1  0b8f		       a9 1f		      lda	#AI_PromotePawnStart
      2  0b91		       85 8c		      sta	aiState
    828  0b93		       60		      rts
    829  0b94
    830  0b94
    831  0b94							;---------------------------------------------------------------------------------------------------
    832  0b94
      0  0b94					      END_BANK
      1  0b94				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  0b94				  -	      CHECK_RAM_BANK_SIZE
      3  0b94					      ELSE
      0  0b94					      CHECK_BANK_SIZE
      1  0b94		       03 94	   .TEMP      =	* - _BANK_START
 ROM bank # 3 ONE size = $394 free = 107
      2  0b94					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  0b94				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0b94				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  0b94				  -	      ERR
      6  0b94					      ENDIF
      5  0b94					      ENDIF
    834  0b94
    835  0b94							;---------------------------------------------------------------------------------------------------
    836  0b94							; EOF
------- FILE ./chess.asm
------- FILE @1 NEGAMAX.asm LEVEL 2 PASS 4
      0  0b94					      include	"@1 NEGAMAX.asm"
      1  0b94							;---------------------------------------------------------------------------------------------------
      2  0b94							; @1 NEGAMAX.asm
      3  0b94
      4  0b94							; Atari 2600 Chess
      5  0b94							; Copyright (c) 2019-2020 Andrew Davie
      6  0b94							; andrew@taswegian.com
      7  0b94
      8  0b94							;---------------------------------------------------------------------------------------------------
      9  0b94
      0  0b94					      SLOT	1
      1  0b94
      2  0b94				  -	      IF	(1 < 0) || (1 > 3)
      3  0b94				  -	      ECHO	"Illegal bank address/segment location", 1
      4  0b94				  -	      ERR
      5  0b94					      ENDIF
      6  0b94
      7  0b94				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  0b94				   _BANK_SLOT SET	1 * 64
      9  0b94
      0  0b94					      ROMBANK	NEGAMAX
      1  0fd7 ????				      SEG	ROM_NEGAMAX
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   NEGAMAX_START SET	*
      6  0c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0c00				   ROMBANK_NEGAMAX SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0c00				   _LAST_BANK SETSTR	NEGAMAX
     10  0c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0c00
     13  0c00
     14  0c00							;---------------------------------------------------------------------------------------------------
     15  0c00
      0  0c00					      DEF	aiComputerMove
      1  0c00				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  0c00				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  0c00				   aiComputerMove
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	aiComputerMove
     17  0c00					      SUBROUTINE
     18  0c00
      0  0c00					      REF	AiStateMachine	;✅
      1  0c00					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0c00				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0c00					      ENDIF
      0  0c00					      VEND	aiComputerMove
      1  0c00
      2  0c00
      3  0c00		       00 a9	   VAREND_aiComputerMove =	TEMPORARY_VAR
      4  0c00
     21  0c00
     22  0c00							; Computer is about to select a move
     23  0c00
     24  0c00
     25  0c00		       a9 88		      lda	#RAMBANK_PLY
     26  0c02		       85 95		      sta	currentPly
     27  0c04		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     28  0c06
     29  0c06		       a9 01		      lda	#1
     30  0c08		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
     31  0c0a
     32  0c0a		       20 3a f4 	      jsr	selectmove	;@this
     33  0c0d
     34  0c0d		       a9 00		      lda	#0
     35  0c0f		       85 4a		      sta	CTRLPF	; clear mirroring
     36  0c11		       85 4e		      sta	PF1
     37  0c13		       85 4f		      sta	PF2
     38  0c15
     39  0c15							; correct ply is already switched
     40  0c15
      0  0c15					      lda@PLY	bestMove
      1  0c15		       ad d1 f9 	      lda	bestMove
     42  0c18		       10 17		      bpl	.notComputer
     43  0c1a
     44  0c1a							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     45  0c1a
      0  0c1a					      SWAP
      1  0c1a
      2  0c1a		       a5 96		      lda	sideToMove
      3  0c1c		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  0c1e		       85 96		      sta	sideToMove
      5  0c20
     47  0c20		       20 ad f1 	      jsr	GenerateAllMoves	;@0
     48  0c23		       a5 a1		      lda	flagCheck
     49  0c25		       f0 05		      beq	.gameDrawn
     50  0c27
      0  0c27					      PHASE	CheckMate
      1  0c27		       a9 23		      lda	#AI_CheckMate
      2  0c29		       85 8c		      sta	aiState
     52  0c2b		       60		      rts
     53  0c2c
     54  0c2c
      0  0c2c				   .gameDrawn PHASE	Draw
      1  0c2c		       a9 24		      lda	#AI_Draw
      2  0c2e		       85 8c		      sta	aiState
     56  0c30		       60		      rts
     57  0c31
     58  0c31				   .notComputer
     59  0c31
     60  0c31
     61  0c31		       a9 ff		      lda	#-1
     62  0c33		       85 89		      sta	cursorX12
     63  0c35
      0  0c35					      PHASE	DelayAfterMove
      1  0c35		       a9 25		      lda	#AI_DelayAfterMove
      2  0c37		       85 8c		      sta	aiState
     65  0c39		       60	   .halted    rts
     66  0c3a
     67  0c3a
     68  0c3a							;---------------------------------------------------------------------------------------------------
     69  0c3a
      0  0c3a					      DEF	selectmove
      1  0c3a				   SLOT_selectmove SET	_BANK_SLOT
      2  0c3a				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  0c3a				   selectmove
      4  0c3a				   TEMPORARY_VAR SET	Overlay
      5  0c3a				   TEMPORARY_OFFSET SET	0
      6  0c3a				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  0c3a				   FUNCTION_NAME SET	selectmove
     71  0c3a					      SUBROUTINE
     72  0c3a
      0  0c3a					      REF	COMMON_VARS
      1  0c3a					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0c3a				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0c3a					      ENDIF
      0  0c3a					      REF	aiComputerMove	;✅
      1  0c3a				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  0c3a				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  0c3a					      ENDIF
      0  0c3a					      VEND	selectmove
      1  0c3a
      2  0c3a
      3  0c3a		       00 b7	   VAREND_selectmove =	TEMPORARY_VAR
      4  0c3a
     76  0c3a
     77  0c3a
     78  0c3a							; RAM bank already switched in!!!
     79  0c3a							; returns with RAM bank switched
     80  0c3a
     81  0c3a
     82  0c3a				  -	      IF	DIAGNOSTICS
     83  0c3a				  -
     84  0c3a				  -	      lda	#0
     85  0c3a				  -	      sta	positionCount
     86  0c3a				  -	      sta	positionCount+1
     87  0c3a				  -	      sta	positionCount+2
     88  0c3a				  -			;sta maxPly
     89  0c3a					      ENDIF
     90  0c3a
     91  0c3a		       a9 ff		      lda	#<INFINITY
     92  0c3c		       85 ac		      sta	__beta
     93  0c3e		       a9 6f		      lda	#>INFINITY
     94  0c40		       85 ad		      sta	__beta+1
     95  0c42
     96  0c42		       a9 01		      lda	#<-INFINITY
     97  0c44		       85 aa		      sta	__alpha
     98  0c46		       a9 90		      lda	#>-INFINITY
     99  0c48		       85 ab		      sta	__alpha+1	; player tries to maximise
    100  0c4a
    101  0c4a		       a2 05		      ldx	#SEARCH_DEPTH
    102  0c4c		       a9 00		      lda	#0	; no captured piece
    103  0c4e		       85 b2		      sta	__quiesceCapOnly	; ALL moves to be generated
    104  0c50
    105  0c50		       20 1d f5 	      jsr	negaMax
    106  0c53
    107  0c53
    108  0c53							;lda currentPly
    109  0c53							;sta SET_BANK_RAM ;tmp?
    110  0c53
    111  0c53
    112  0c53							;SPEAK SAY_your_move ;left_speech
    113  0c53
    114  0c53
      0  0c53					      ldx@PLY	bestMove
      1  0c53		       ae d1 f9 	      ldx	bestMove
    116  0c56		       30 26		      bmi	.nomove
    117  0c58
    118  0c58							; Generate player's moves in reply
    119  0c58							; Make the computer move, list player moves (PLY+1), unmake computer move
    120  0c58
      0  0c58					      stx@PLY	movePtr
      1  0c58		       8e d0 fb 	      stx	[RAM]+movePtr
    122  0c5b		       20 7f f4 	      jsr	MakeMove	;@this
    123  0c5e		       20 3b f2 	      jsr	ListPlayerMoves	;@0
    124  0c61
    125  0c61		       c6 95		      dec	currentPly
    126  0c63		       20 98 f2 	      jsr	unmakeMove	;@0
    127  0c66
    128  0c66							; Grab the computer move details for the UI animation
    129  0c66
    130  0c66		       a9 88		      lda	#RAMBANK_PLY
    131  0c68		       85 3e		      sta	SET_BANK_RAM
    132  0c6a
      0  0c6a					      ldx@PLY	bestMove
      1  0c6a		       ae d1 f9 	      ldx	bestMove
      0  0c6d					      lda@PLY	MoveTo,x
      1  0c6d		       bd 64 f8 	      lda	MoveTo,x
    135  0c70		       85 87		      sta	toX12
      0  0c72					      lda@PLY	MoveFrom,x
      1  0c72		       bd 00 f8 	      lda	MoveFrom,x
    137  0c75		       85 88		      sta	originX12
    138  0c77		       85 86		      sta	fromX12
      0  0c79					      lda@PLY	MovePiece,x
      1  0c79		       bd 00 f9 	      lda	MovePiece,x
    140  0c7c		       85 97		      sta	fromPiece
    141  0c7e
    142  0c7e				   .nomove
    143  0c7e		       60		      rts
    144  0c7f
    145  0c7f
    146  0c7f							;---------------------------------------------------------------------------------------------------
    147  0c7f
      0  0c7f					      DEF	MakeMove
      1  0c7f				   SLOT_MakeMove SET	_BANK_SLOT
      2  0c7f				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  0c7f				   MakeMove
      4  0c7f				   TEMPORARY_VAR SET	Overlay
      5  0c7f				   TEMPORARY_OFFSET SET	0
      6  0c7f				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  0c7f				   FUNCTION_NAME SET	MakeMove
    149  0c7f					      SUBROUTINE
    150  0c7f
      0  0c7f					      REF	COMMON_VARS
      1  0c7f					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0c7f				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0c7f					      ENDIF
      0  0c7f					      REF	selectmove	;✅
      1  0c7f				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0c7f				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0c7f					      ENDIF
      0  0c7f					      REF	ListPlayerMoves	;✅
      1  0c7f				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0c7f				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0c7f					      ENDIF
      0  0c7f					      REF	quiesce	;✅
      1  0c7f					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0c7f				   TEMPORARY_VAR SET	VAREND_quiesce
      3  0c7f					      ENDIF
      0  0c7f					      REF	negaMax	;✅
      1  0c7f				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0c7f				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0c7f					      ENDIF
      0  0c7f					      VEND	MakeMove
      1  0c7f
      2  0c7f
      3  0c7f		       00 b9	   VAREND_MakeMove =	TEMPORARY_VAR
      4  0c7f
    157  0c7f
    158  0c7f							; Do a move without any GUI stuff
    159  0c7f							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    160  0c7f							; and all relevant flags in original state. This is NOT used for the visible move on the
    161  0c7f							; screen.
    162  0c7f
    163  0c7f
    164  0c7f							; fromPiece	 piece doing the move
    165  0c7f							; fromX12	 current square X12
    166  0c7f							; originX12	 starting square X12
    167  0c7f							; toX12	 ending square X12
    168  0c7f
    169  0c7f							; BANK:SLOT2 = currentPly
    170  0c7f
    171  0c7f
    172  0c7f							; There are potentially "two" moves, with the following
    173  0c7f							; a) Castling, moving both rook and king
    174  0c7f							; b) en-Passant, capturing pawn on "odd" square
    175  0c7f							; These both set "secondary" movers which are used for restoring during unmakeMove
    176  0c7f
    177  0c7f		       a0 e3		      ldy	#RAMBANK_BOARD
    178  0c81		       84 3e		      sty	SET_BANK_RAM	;@3
    179  0c83
      0  0c83					      ldx@PLY	movePtr
      1  0c83		       ae d0 f9 	      ldx	movePtr
      0  0c86					      ldy@PLY	MoveFrom,x
      1  0c86		       bc 00 f8 	      ldy	MoveFrom,x
    182  0c89		       84 86		      sty	fromX12
    183  0c8b		       84 88		      sty	originX12
    184  0c8d
      0  0c8d					      lda@RAM	Board,y
      1  0c8d		       b9 79 fc 	      lda	Board,y
    186  0c90		       85 b3		      sta	__originalPiece
      0  0c92					      sta@PLY	restorePiece
      1  0c92		       8d d9 fb 	      sta	[RAM]+restorePiece
    188  0c95
    189  0c95		       a9 00		      lda	#0
      0  0c97					      sta@RAM	Board,y
      1  0c97		       99 79 fe 	      sta	[RAM]+Board,y
      0  0c9a					      sta@PLY	secondaryPiece
      1  0c9a		       8d cc fb 	      sta	[RAM]+secondaryPiece
    192  0c9d
    193  0c9d		       85 a3		      sta	vkSquare
    194  0c9f		       85 a4		      sta	vkSquare+1
    195  0ca1
      0  0ca1					      ldy@PLY	MoveTo,x
      1  0ca1		       bc 64 f8 	      ldy	MoveTo,x
    197  0ca4		       84 87		      sty	toX12
    198  0ca6
      0  0ca6					      lda@RAM	Board,y
      1  0ca6		       b9 79 fc 	      lda	Board,y
    200  0ca9		       85 b4		      sta	__capturedPiece
      0  0cab					      sta@PLY	capturedPiece
      1  0cab		       8d cb fb 	      sta	[RAM]+capturedPiece
    202  0cae
      0  0cae					      lda@PLY	MovePiece,x
      1  0cae		       bd 00 f9 	      lda	MovePiece,x
    204  0cb1		       85 97		      sta	fromPiece
    205  0cb3
    206  0cb3		       29 87		      and	#PIECE_MASK|FLAG_COLOUR
    207  0cb5		       09 40		      ora	#FLAG_MOVED
      0  0cb7					      sta@RAM	Board,y
      1  0cb7		       99 79 fe 	      sta	[RAM]+Board,y
    209  0cba
    210  0cba
      0  0cba				   .move      CALL	AdjustMaterialPositionalValue	;@2
      1  0cba				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  0cba				  -FNAME      SETSTR	AdjustMaterialPositionalValue
      3  0cba				  -	      ECHO	""
      4  0cba				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0cba				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0cba				  -	      ERR
      7  0cba					      ENDIF
      8  0cba		       a9 89		      lda	#BANK_AdjustMaterialPositionalValue
      9  0cbc		       85 3f		      sta	SET_BANK
     10  0cbe		       20 ea f8 	      jsr	AdjustMaterialPositionalValue
    212  0cc1
    213  0cc1
    214  0cc1					      IF	CASTLING_ENABLED
    215  0cc1
    216  0cc1							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    217  0cc1							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    218  0cc1							; redo the moving code (for the rook, this time).
    219  0cc1
    220  0cc1							; Set the squares that need to be checked for "virtual check" - preventing the king
    221  0cc1							; from castling from/across check.
    222  0cc1
    223  0cc1		       a5 97		      lda	fromPiece
    224  0cc3		       29 17		      and	#FLAG_CASTLE|KING
    225  0cc5		       c9 17		      cmp	#FLAG_CASTLE|KING
    226  0cc7		       d0 13		      bne	.exit	; NOT involved in castle!
    227  0cc9
    228  0cc9							; Must be a king, castling. Calculate the virtual squares which need to be checked for
    229  0cc9							; invalid castling. Prevents moving in/across check.
    230  0cc9
    231  0cc9		       18		      clc
    232  0cca		       a5 88		      lda	originX12
    233  0ccc		       85 a4		      sta	vkSquare+1	; king origin
    234  0cce		       65 87		      adc	toX12
    235  0cd0		       4a		      lsr
    236  0cd1		       85 a3		      sta	vkSquare	; intermediate square
    237  0cd3
    238  0cd3
    239  0cd3							; Now generate a new move for the rook
    240  0cd3
      0  0cd3					      CALL	GenCastleMoveForRook	;@3
      1  0cd3				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  0cd3				  -FNAME      SETSTR	GenCastleMoveForRook
      3  0cd3				  -	      ECHO	""
      4  0cd3				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0cd3				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0cd3				  -	      ERR
      7  0cd3					      ENDIF
      8  0cd3		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      9  0cd5		       85 3f		      sta	SET_BANK
     10  0cd7		       20 22 fc 	      jsr	GenCastleMoveForRook
    242  0cda		       b0 de		      bcs	.move	; move the rook!
    243  0cdc
    244  0cdc				   .exit
    245  0cdc					      ENDIF
    246  0cdc
    247  0cdc
    248  0cdc					      IF	ENPASSANT_ENABLED
    249  0cdc
      0  0cdc					      CALL	EnPassantFixupDraw	; generate enPassantPawn value
      1  0cdc				  -	      IF	SLOT_EnPassantFixupDraw == _BANK_SLOT
      2  0cdc				  -FNAME      SETSTR	EnPassantFixupDraw
      3  0cdc				  -	      ECHO	""
      4  0cdc				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0cdc				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0cdc				  -	      ERR
      7  0cdc					      ENDIF
      8  0cdc		       a9 89		      lda	#BANK_EnPassantFixupDraw
      9  0cde		       85 3f		      sta	SET_BANK
     10  0ce0		       20 80 f8 	      jsr	EnPassantFixupDraw
    251  0ce3							;CALL EnPassantRemoveCapturedPawn
    252  0ce3
    253  0ce3					      ENDIF
    254  0ce3
    255  0ce3
    256  0ce3							; Swap over sides
    257  0ce3
      0  0ce3					      NEGEVAL
      1  0ce3
      2  0ce3		       38		      sec
      3  0ce4		       a9 00		      lda	#0
      4  0ce6		       e5 90		      sbc	Evaluation
      5  0ce8		       85 90		      sta	Evaluation
      6  0cea		       a9 00		      lda	#0
      7  0cec		       e5 91		      sbc	Evaluation+1
      8  0cee		       85 91		      sta	Evaluation+1
      9  0cf0
      0  0cf0					      SWAP
      1  0cf0
      2  0cf0		       a5 96		      lda	sideToMove
      3  0cf2		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  0cf4		       85 96		      sta	sideToMove
      5  0cf6
    260  0cf6
    261  0cf6		       a5 95		      lda	currentPly
    262  0cf8		       85 3e		      sta	SET_BANK_RAM
    263  0cfa		       60		      rts
    264  0cfb
    265  0cfb
    266  0cfb							;---------------------------------------------------------------------------------------------------
    267  0cfb
    268  0cfb							;function negaMax(node, depth, α, β, color) is
    269  0cfb							;    if depth = 0 or node is a terminal node then
    270  0cfb							;	  return color × the heuristic value of node
    271  0cfb
    272  0cfb							;    childNodes := generateMoves(node)
    273  0cfb							;    childNodes := orderMoves(childNodes)
    274  0cfb							;    value := −∞
    275  0cfb							;    foreach child in childNodes do
    276  0cfb							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    277  0cfb							;	  α := max(α, value)
    278  0cfb							;	  if α ≥ β then
    279  0cfb							;	      break (* cut-off *)
    280  0cfb							;    return value
    281  0cfb							;(* Initial call for Player A's root node *)
    282  0cfb							;negaMax(rootNode, depth, −∞, +∞, 1)
    283  0cfb
    284  0cfb
    285  0cfb					      SUBROUTINE
    286  0cfb
    287  0cfb		       a9 ff	   .doQ       lda	#-1
    288  0cfd		       85 b2		      sta	__quiesceCapOnly
    289  0cff		       20 f0 f6 	      jsr	quiesce
    290  0d02		       e6 b2		      inc	__quiesceCapOnly
    291  0d04		       60		      rts
    292  0d05
    293  0d05
      0  0d05				   .exit      lda@PLY	value
      1  0d05		       ad d6 f9 	      lda	value
    295  0d08		       85 ae		      sta	__negaMax
      0  0d0a					      lda@PLY	value+1
      1  0d0a		       ad d7 f9 	      lda	value+1
    297  0d0d		       85 af		      sta	__negaMax+1
    298  0d0f		       60		      rts
    299  0d10
    300  0d10
    301  0d10				   .terminal
    302  0d10
    303  0d10					      IF	QUIESCE_EXTRA_DEPTH > 0
    304  0d10		       c9 00		      cmp	#0	; captured piece
    305  0d12		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
    306  0d14					      ENDIF
    307  0d14
    308  0d14		       a5 90		      lda	Evaluation
    309  0d16		       85 ae		      sta	__negaMax
    310  0d18		       a5 91		      lda	Evaluation+1
    311  0d1a		       85 af		      sta	__negaMax+1
    312  0d1c
    313  0d1c		       60	   .inCheck2  rts
    314  0d1d
    315  0d1d
    316  0d1d							;---------------------------------------------------------------------------------------------------
    317  0d1d
      0  0d1d					      DEF	negaMax
      1  0d1d				   SLOT_negaMax SET	_BANK_SLOT
      2  0d1d				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  0d1d				   negaMax
      4  0d1d				   TEMPORARY_VAR SET	Overlay
      5  0d1d				   TEMPORARY_OFFSET SET	0
      6  0d1d				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  0d1d				   FUNCTION_NAME SET	negaMax
    319  0d1d
    320  0d1d							; PARAMS depth-1, -beta, -alpha
    321  0d1d							; pased through temporary variables (__alpha, __beta) and X reg
    322  0d1d
    323  0d1d							; pass...
    324  0d1d							; x = depthleft
    325  0d1d							; a = captured piece
    326  0d1d							; SET_BANK_RAM      --> current ply
    327  0d1d							; __alpha[2] = param alpha
    328  0d1d							; __beta[2] = param beta
    329  0d1d
    330  0d1d
      0  0d1d					      REF	COMMON_VARS
      1  0d1d					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0d1d				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0d1d					      ENDIF
      0  0d1d					      REF	selectmove	;✅
      1  0d1d				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0d1d				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0d1d					      ENDIF
      0  0d1d					      VAR	ev2,2
      1  0d1d		       00 b7	   ev2	      =	TEMPORARY_VAR
      2  0d1d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0d1d
      4  0d1d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0d1d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0d1d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0d1d					      ENDIF
      8  0d1d				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0d1d				  -VNAME      SETSTR	ev2
     10  0d1d				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0d1d				  -	      ERR
     12  0d1d					      ENDIF
      0  0d1d					      VEND	negaMax
      1  0d1d
      2  0d1d
      3  0d1d		       00 b9	   VAREND_negaMax =	TEMPORARY_VAR
      4  0d1d
    335  0d1d
    336  0d1d
    337  0d1d		       48		      pha
    338  0d1e
    339  0d1e		       20 88 f0 	      jsr	ThinkBar	;@0
    340  0d21
    341  0d21		       a5 95		      lda	currentPly
    342  0d23		       85 3e		      sta	SET_BANK_RAM	;@2
    343  0d25
    344  0d25		       68		      pla
    345  0d26		       ca		      dex
    346  0d27		       30 e7		      bmi	.terminal
      0  0d29					      stx@PLY	depthLeft
      1  0d29		       8e d8 fb 	      stx	[RAM]+depthLeft
    348  0d2c
    349  0d2c
    350  0d2c							; Allow the player to force computer to select a move. Press the SELECT switch
    351  0d2c
      0  0d2c					      lda@PLY	bestMove
      1  0d2c		       ad d1 f9 	      lda	bestMove
    353  0d2f		       30 07		      bmi	.noCheat	; can't force if no move chosen!
    354  0d31		       ad 82 02 	      lda	SWCHB
    355  0d34		       29 02		      and	#SELECT_SWITCH
    356  0d36		       f0 cd		      beq	.exit	; SELECT abort
    357  0d38				   .noCheat
    358  0d38
    359  0d38
    360  0d38					      IF	1
      0  0d38					      NEXT_RANDOM
      1  0d38
      2  0d38		       a5 82		      lda	rnd
      3  0d3a		       4a		      lsr
      4  0d3b		       90 02		      bcc	.skipEOR
      5  0d3d		       49 b4		      eor	#RND_EOR_VAL
      6  0d3f		       85 82	   .skipEOR   sta	rnd
      7  0d41
    362  0d41		       25 a2		      and	randomness
    363  0d43		       65 90		      adc	Evaluation
    364  0d45		       85 90		      sta	Evaluation	; since it's random we don't care about HI
    365  0d47							;bcc .evOK
    366  0d47							;inc Evaluation+1
    367  0d47				   .evOK
    368  0d47					      ENDIF
    369  0d47
    370  0d47		       a5 aa		      lda	__alpha
      0  0d49					      sta@PLY	alpha
      1  0d49		       8d d2 fb 	      sta	[RAM]+alpha
    372  0d4c		       a5 ab		      lda	__alpha+1
      0  0d4e					      sta@PLY	alpha+1
      1  0d4e		       8d d3 fb 	      sta	[RAM]+alpha+1
    374  0d51
    375  0d51		       a5 ac		      lda	__beta
      0  0d53					      sta@PLY	beta
      1  0d53		       8d d4 fb 	      sta	[RAM]+beta
    377  0d56		       a5 ad		      lda	__beta+1
      0  0d58					      sta@PLY	beta+1
      1  0d58		       8d d5 fb 	      sta	[RAM]+beta+1
    379  0d5b
    380  0d5b
    381  0d5b		       20 ad f1 	      jsr	GenerateAllMoves	;@0
    382  0d5e
      0  0d5e					      DEF	negaLoop
      1  0d5e				   SLOT_negaLoop SET	_BANK_SLOT
      2  0d5e				   BANK_negaLoop SET	SLOT_negaLoop + _CURRENT_BANK
      3  0d5e				   negaLoop
      4  0d5e				   TEMPORARY_VAR SET	Overlay
      5  0d5e				   TEMPORARY_OFFSET SET	0
      6  0d5e				   VAR_BOUNDARY_negaLoop SET	TEMPORARY_OFFSET
      7  0d5e				   FUNCTION_NAME SET	negaLoop
    384  0d5e
    385  0d5e
    386  0d5e		       a5 a1		      lda	flagCheck
    387  0d60		       d0 ba		      bne	.inCheck2	; OTHER guy in check
    388  0d62
    389  0d62
    390  0d62					      IF	1
    391  0d62							; TODO: how does this sit with the move ordering subsearch?
    392  0d62
    393  0d62							; add mobility to the score (for all moves). Will un-add on move revert
    394  0d62
      0  0d62					      lda@PLY	moveIndex
      1  0d62		       ad cf f9 	      lda	moveIndex
    396  0d65		       c9 ff		      cmp	#$FF
    397  0d67		       f0 18		      beq	.nomoves
    398  0d69
    399  0d69		       a2 00		      ldx	#0
    400  0d6b		       86 b8		      stx	ev2+1
    401  0d6d
    402  0d6d					      REPEAT	1
    403  0d6d		       0a		      asl
    404  0d6e		       26 b8		      rol	ev2+1
    405  0d70					      REPEND
    406  0d70
    407  0d70		       18		      clc
    408  0d71		       65 90		      adc	Evaluation
      0  0d73					      sta@PLY	savedEvaluation
      1  0d73		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    410  0d76		       85 90		      sta	Evaluation
    411  0d78		       a5 91		      lda	Evaluation+1
    412  0d7a		       65 b8		      adc	ev2+1
    413  0d7c		       85 91		      sta	Evaluation+1
      0  0d7e					      sta@PLY	savedEvaluation+1
      1  0d7e		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    415  0d81
    416  0d81				   .nomoves
    417  0d81					      ENDIF
    418  0d81
    419  0d81		       a9 01		      lda	#<-INFINITY
      0  0d83					      sta@PLY	value
      1  0d83		       8d d6 fb 	      sta	[RAM]+value
    421  0d86		       a9 90		      lda	#>-INFINITY
      0  0d88					      sta@PLY	value+1
      1  0d88		       8d d7 fb 	      sta	[RAM]+value+1
    423  0d8b
      0  0d8b					      ldx@PLY	moveIndex
      1  0d8b		       ae cf f9 	      ldx	moveIndex
    425  0d8e		       10 03		      bpl	.forChild
    426  0d90		       4c 05 f5 	      jmp	.exit
    427  0d93
      0  0d93				   .forChild  stx@PLY	movePtr
      1  0d93		       8e d0 fb 	      stx	[RAM]+movePtr
    429  0d96
    430  0d96		       20 7f f4 	      jsr	MakeMove	;@this
    431  0d99
    432  0d99
    433  0d99							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    434  0d99
    435  0d99							; PARAMS depth-1, -beta, -alpha
    436  0d99							; pased through temporary variables (__alpha, __beta) and X reg
    437  0d99
    438  0d99		       38		      sec
    439  0d9a		       a9 00		      lda	#0
      0  0d9c					      sbc@PLY	beta
      1  0d9c		       ed d4 f9 	      sbc	beta
    441  0d9f		       85 aa		      sta	__alpha
    442  0da1		       a9 00		      lda	#0
      0  0da3					      sbc@PLY	beta+1
      1  0da3		       ed d5 f9 	      sbc	beta+1
    444  0da6		       85 ab		      sta	__alpha+1
    445  0da8
    446  0da8		       38		      sec
    447  0da9		       a9 00		      lda	#0
      0  0dab					      sbc@PLY	alpha
      1  0dab		       ed d2 f9 	      sbc	alpha
    449  0dae		       85 ac		      sta	__beta
    450  0db0		       a9 00		      lda	#0
      0  0db2					      sbc@PLY	alpha+1
      1  0db2		       ed d3 f9 	      sbc	alpha+1
    452  0db5		       85 ad		      sta	__beta+1
    453  0db7
    454  0db7
      0  0db7					      ldx@PLY	depthLeft
      1  0db7		       ae d8 f9 	      ldx	depthLeft
      0  0dba					      lda@PLY	capturedPiece
      1  0dba		       ad cb f9 	      lda	capturedPiece
    457  0dbd
    458  0dbd		       e6 95		      inc	currentPly
    459  0dbf		       a4 95		      ldy	currentPly
    460  0dc1		       84 3e		      sty	SET_BANK_RAM	; self-switch
    461  0dc3
    462  0dc3		       20 1d f5 	      jsr	negaMax	;@this
    463  0dc6
    464  0dc6		       c6 95		      dec	currentPly
    465  0dc8
    466  0dc8
    467  0dc8		       a5 95		      lda	currentPly
    468  0dca		       85 3e		      sta	SET_BANK_RAM
    469  0dcc
      0  0dcc					      ldx@PLY	movePtr
      1  0dcc		       ae d0 f9 	      ldx	movePtr
    471  0dcf
    472  0dcf		       18		      clc
    473  0dd0		       69 0d		      adc	#RAMBANK_SORT-RAMBANK_PLY
    474  0dd2		       85 3e		      sta	SET_BANK_RAM
    475  0dd4
    476  0dd4		       a5 ae		      lda	__negaMax
      0  0dd6					      sta@RAM	MoveValueLO,x
      1  0dd6		       9d 00 fa 	      sta	[RAM]+MoveValueLO,x
    478  0dd9		       a5 af		      lda	__negaMax+1
      0  0ddb					      sta@RAM	MoveValueHI,x
      1  0ddb		       9d 64 fa 	      sta	[RAM]+MoveValueHI,x
    480  0dde
    481  0dde		       20 98 f2 	      jsr	unmakeMove	;@0
    482  0de1
    483  0de1		       a5 95		      lda	currentPly
    484  0de3		       85 3e		      sta	SET_BANK_RAM
    485  0de5
    486  0de5		       38		      sec
    487  0de6		       a9 00		      lda	#0
    488  0de8		       e5 ae		      sbc	__negaMax
    489  0dea		       85 ae		      sta	__negaMax
    490  0dec		       a9 00		      lda	#0
    491  0dee		       e5 af		      sbc	__negaMax+1
    492  0df0		       85 af		      sta	__negaMax+1	; -negaMax(...)
    493  0df2
    494  0df2
    495  0df2					      IF	1
    496  0df2		       a5 a1		      lda	flagCheck
    497  0df4		       f0 09		      beq	.notCheck
      0  0df6					      sta@PLY	inCheck
      1  0df6		       8d dc fb 	      sta	[RAM]+inCheck
    499  0df9
    500  0df9							; at this point we've determined that the move was illegal, because the next ply detected
    501  0df9							; a king capture. So, the move should be totally discounted
    502  0df9
    503  0df9		       a9 00		      lda	#0
    504  0dfb		       85 a1		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    505  0dfd		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
    506  0dff					      ENDIF
    507  0dff
    508  0dff
    509  0dff				   .notCheck
    510  0dff
    511  0dff		       38		      sec
      0  0e00					      lda@PLY	value
      1  0e00		       ad d6 f9 	      lda	value
    513  0e03		       e5 ae		      sbc	__negaMax
      0  0e05					      lda@PLY	value+1
      1  0e05		       ad d7 f9 	      lda	value+1
    515  0e08		       e5 af		      sbc	__negaMax+1
    516  0e0a		       50 02		      bvc	.lab0
    517  0e0c		       49 80		      eor	#$80
    518  0e0e		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    519  0e10
    520  0e10
    521  0e10							; so, negaMax > value!
    522  0e10
    523  0e10
    524  0e10		       a5 ae		      lda	__negaMax
      0  0e12					      sta@PLY	value
      1  0e12		       8d d6 fb 	      sta	[RAM]+value
    526  0e15		       a5 af		      lda	__negaMax+1
      0  0e17					      sta@PLY	value+1	; max(value, -negaMax)
      1  0e17		       8d d7 fb 	      sta	[RAM]+value+1
    528  0e1a
      0  0e1a					      lda@PLY	movePtr
      1  0e1a		       ad d0 f9 	      lda	movePtr
      0  0e1d					      sta@PLY	bestMove
      1  0e1d		       8d d1 fb 	      sta	[RAM]+bestMove
    531  0e20				   .lt0
    532  0e20
    533  0e20							;	  α := max(α, value)
    534  0e20
    535  0e20		       38		      sec
      0  0e21					      lda@PLY	value
      1  0e21		       ad d6 f9 	      lda	value
      0  0e24					      sbc@PLY	alpha
      1  0e24		       ed d2 f9 	      sbc	alpha
      0  0e27					      lda@PLY	value+1
      1  0e27		       ad d7 f9 	      lda	value+1
      0  0e2a					      sbc@PLY	alpha+1
      1  0e2a		       ed d3 f9 	      sbc	alpha+1
    540  0e2d		       50 02		      bvc	.lab1
    541  0e2f		       49 80		      eor	#$80
    542  0e31		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    543  0e33
      0  0e33					      lda@PLY	value
      1  0e33		       ad d6 f9 	      lda	value
      0  0e36					      sta@PLY	alpha
      1  0e36		       8d d2 fb 	      sta	[RAM]+alpha
      0  0e39					      lda@PLY	value+1
      1  0e39		       ad d7 f9 	      lda	value+1
      0  0e3c					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  0e3c		       8d d3 fb 	      sta	[RAM]+alpha+1
    548  0e3f
    549  0e3f				   .lt1
    550  0e3f
    551  0e3f							;	  if α ≥ β then
    552  0e3f							;	      break (* cut-off *)
    553  0e3f
    554  0e3f		       38		      sec
      0  0e40					      lda@PLY	alpha
      1  0e40		       ad d2 f9 	      lda	alpha
      0  0e43					      sbc@PLY	beta
      1  0e43		       ed d4 f9 	      sbc	beta
      0  0e46					      lda@PLY	alpha+1
      1  0e46		       ad d3 f9 	      lda	alpha+1
      0  0e49					      sbc@PLY	beta+1
      1  0e49		       ed d5 f9 	      sbc	beta+1
    559  0e4c		       50 02		      bvc	.lab2
    560  0e4e		       49 80		      eor	#$80
    561  0e50		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    562  0e52
    563  0e52
      0  0e52				   .nextMove  ldx@PLY	movePtr
      1  0e52		       ae d0 f9 	      ldx	movePtr
    565  0e55		       ca	   .nextX     dex
    566  0e56		       30 03		      bmi	.retrn
    567  0e58		       4c 93 f5 	      jmp	.forChild
    568  0e5b
    569  0e5b				   .retrn
    570  0e5b
    571  0e5b				  -	      IF	0
    572  0e5b				  -
    573  0e5b				  -			; If there has been NO "best move" found, then there were no valid moves
    574  0e5b				  -			; if the side was in check, that's OK we'll score a checkmate for that
    575  0e5b				  -			; but if NOT in check, then it's a stalemate, and the score needs to be adjusted
    576  0e5b				  -
    577  0e5b				  -	      lda@PLY	bestMove
    578  0e5b				  -	      bpl	.someMoveOK
    579  0e5b				  -	      lda@PLY	inCheck
    580  0e5b				  -	      bne	.someMoveOK	; it's a checkmate
    581  0e5b				  -
    582  0e5b				  -			;lda #0
    583  0e5b				  -	      sta@PLY	value
    584  0e5b				  -	      sta@PLY	value+1
    585  0e5b				  -
    586  0e5b				  -.someMoveOK
    587  0e5b					      ENDIF
    588  0e5b
    589  0e5b		       4c 05 f5 	      jmp	.exit
    590  0e5e
    591  0e5e
    592  0e5e							;---------------------------------------------------------------------------------------------------
    593  0e5e
    594  0e5e					      MAC	xchg
    595  0e5e					      lda@PLY	{1},x
    596  0e5e					      pha		;sta __xchg
    597  0e5e					      lda@PLY	{1},y
    598  0e5e					      sta@PLY	{1},x
    599  0e5e					      pla		;lda __xchg
    600  0e5e					      sta@PLY	{1},y
    601  0e5e					      ENDM		;{name}
    602  0e5e
    603  0e5e
    604  0e5e				  -	      IF	0
    605  0e5e				  -			; bubble sort from Wikipedia
    606  0e5e				  -
    607  0e5e				  -			;n := length(A)
    608  0e5e				  -			;repeat
    609  0e5e				  -			;    newn := 0
    610  0e5e				  -			;    for i := 1 to n - 1 inclusive do
    611  0e5e				  -			;	  if A[i - 1] > A[i] then
    612  0e5e				  -			;	      swap(A[i - 1], A[i])
    613  0e5e				  -			;	      newn := i
    614  0e5e				  -			;	  end if
    615  0e5e				  -			;    end for
    616  0e5e				  -			;    n := newn
    617  0e5e				  -			;until n ≤ 1
    618  0e5e				  -
    619  0e5e					      ENDIF
    620  0e5e
    621  0e5e
    622  0e5e
      0  0e5e					      DEF	Sort
      1  0e5e				   SLOT_Sort  SET	_BANK_SLOT
      2  0e5e				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  0e5e				   Sort
      4  0e5e				   TEMPORARY_VAR SET	Overlay
      5  0e5e				   TEMPORARY_OFFSET SET	0
      6  0e5e				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  0e5e				   FUNCTION_NAME SET	Sort
    624  0e5e					      SUBROUTINE
    625  0e5e
      0  0e5e					      REF	GenerateAllMoves
      1  0e5e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  0e5e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  0e5e					      ENDIF
      0  0e5e					      VAR	__xchg, 1
      1  0e5e		       00 bb	   __xchg     =	TEMPORARY_VAR
      2  0e5e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0e5e
      4  0e5e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0e5e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0e5e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0e5e					      ENDIF
      8  0e5e				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0e5e				  -VNAME      SETSTR	__xchg
     10  0e5e				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0e5e				  -	      ERR
     12  0e5e					      ENDIF
      0  0e5e					      VAR	__n, 1
      1  0e5e		       00 bc	   __n	      =	TEMPORARY_VAR
      2  0e5e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0e5e
      4  0e5e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0e5e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0e5e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0e5e					      ENDIF
      8  0e5e				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0e5e				  -VNAME      SETSTR	__n
     10  0e5e				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0e5e				  -	      ERR
     12  0e5e					      ENDIF
      0  0e5e					      VAR	__newn, 1
      1  0e5e		       00 bd	   __newn     =	TEMPORARY_VAR
      2  0e5e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0e5e
      4  0e5e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0e5e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0e5e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0e5e					      ENDIF
      8  0e5e				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0e5e				  -VNAME      SETSTR	__newn
     10  0e5e				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0e5e				  -	      ERR
     12  0e5e					      ENDIF
      0  0e5e					      VAR	__i, 1
      1  0e5e		       00 be	   __i	      =	TEMPORARY_VAR
      2  0e5e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0e5e
      4  0e5e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0e5e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0e5e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0e5e					      ENDIF
      8  0e5e				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0e5e				  -VNAME      SETSTR	__i
     10  0e5e				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0e5e				  -	      ERR
     12  0e5e					      ENDIF
      0  0e5e					      VAR	__bank2, 1
      1  0e5e		       00 bf	   __bank2    =	TEMPORARY_VAR
      2  0e5e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0e5e
      4  0e5e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0e5e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0e5e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0e5e					      ENDIF
      8  0e5e				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0e5e				  -VNAME      SETSTR	__bank2
     10  0e5e				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0e5e				  -	      ERR
     12  0e5e					      ENDIF
      0  0e5e					      VEND	Sort
      1  0e5e
      2  0e5e
      3  0e5e		       00 c0	   VAREND_Sort =	TEMPORARY_VAR
      4  0e5e
    633  0e5e
    634  0e5e		       a5 b2		      lda	__quiesceCapOnly
    635  0e60		       f0 03		      beq	.nonExit
    636  0e62		       4c cd f6 	      jmp	.exit	; only caps present so already sorted!
    637  0e65				   .nonExit
    638  0e65
    639  0e65					      IF	1
    640  0e65
    641  0e65							; Run a shallow negamax search to get the values for each move
    642  0e65							; and then do a bubble sort of the results
    643  0e65
    644  0e65		       a5 95		      lda	currentPly
    645  0e67		       c9 89		      cmp	#RAMBANK_PLY+1
    646  0e69		       b0 62		      bcs	.tooDeep
    647  0e6b
      0  0e6b					      lda@PLY	depthLeft
      1  0e6b		       ad d8 f9 	      lda	depthLeft
    649  0e6e		       48		      pha
      0  0e6f					      lda@PLY	movePtr
      1  0e6f		       ad d0 f9 	      lda	movePtr
    651  0e72		       48		      pha
    652  0e73
      0  0e73					      lda@PLY	alpha+1
      1  0e73		       ad d3 f9 	      lda	alpha+1
    654  0e76		       48		      pha
      0  0e77					      lda@PLY	alpha
      1  0e77		       ad d2 f9 	      lda	alpha
    656  0e7a		       48		      pha
      0  0e7b					      lda@PLY	beta+1
      1  0e7b		       ad d5 f9 	      lda	beta+1
    658  0e7e		       48		      pha
      0  0e7f					      lda@PLY	beta
      1  0e7f		       ad d4 f9 	      lda	beta
    660  0e82		       48		      pha
    661  0e83
      0  0e83					      lda@PLY	value+1
      1  0e83		       ad d7 f9 	      lda	value+1
    663  0e86		       48		      pha
      0  0e87					      lda@PLY	value
      1  0e87		       ad d6 f9 	      lda	value
    665  0e8a		       48		      pha
    666  0e8b
    667  0e8b
    668  0e8b		       a9 ff		      lda	#<INFINITY
    669  0e8d		       85 ac		      sta	__beta
    670  0e8f		       a9 6f		      lda	#>INFINITY
    671  0e91		       85 ad		      sta	__beta+1
    672  0e93
    673  0e93		       a9 01		      lda	#<-INFINITY
    674  0e95		       85 aa		      sta	__alpha
    675  0e97		       a9 90		      lda	#>-INFINITY
    676  0e99		       85 ab		      sta	__alpha+1	; player tries to maximise
    677  0e9b
    678  0e9b		       a2 02		      ldx	#2
      0  0e9d					      stx@PLY	depthLeft
      1  0e9d		       8e d8 fb 	      stx	[RAM]+depthLeft
    680  0ea0
    681  0ea0		       20 5e f5 	      jsr	negaLoop
    682  0ea3
      0  0ea3					      CALL	BubbleSort	;@3
      1  0ea3				  -	      IF	SLOT_BubbleSort == _BANK_SLOT
      2  0ea3				  -FNAME      SETSTR	BubbleSort
      3  0ea3				  -	      ECHO	""
      4  0ea3				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0ea3				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0ea3				  -	      ERR
      7  0ea3					      ENDIF
      8  0ea3		       a9 d9		      lda	#BANK_BubbleSort
      9  0ea5		       85 3f		      sta	SET_BANK
     10  0ea7		       20 aa fc 	      jsr	BubbleSort
    684  0eaa
    685  0eaa		       68		      pla
      0  0eab					      sta@PLY	value
      1  0eab		       8d d6 fb 	      sta	[RAM]+value
    687  0eae		       68		      pla
      0  0eaf					      sta@PLY	value+1
      1  0eaf		       8d d7 fb 	      sta	[RAM]+value+1
    689  0eb2
    690  0eb2		       68		      pla
      0  0eb3					      sta@PLY	beta
      1  0eb3		       8d d4 fb 	      sta	[RAM]+beta
    692  0eb6		       68		      pla
      0  0eb7					      sta@PLY	beta+1
      1  0eb7		       8d d5 fb 	      sta	[RAM]+beta+1
    694  0eba		       68		      pla
      0  0ebb					      sta@PLY	alpha
      1  0ebb		       8d d2 fb 	      sta	[RAM]+alpha
    696  0ebe		       68		      pla
      0  0ebf					      sta@PLY	alpha+1
      1  0ebf		       8d d3 fb 	      sta	[RAM]+alpha+1
    698  0ec2
    699  0ec2		       68		      pla
      0  0ec3					      sta@PLY	movePtr
      1  0ec3		       8d d0 fb 	      sta	[RAM]+movePtr
    701  0ec6		       68		      pla
      0  0ec7					      sta@PLY	depthLeft
      1  0ec7		       8d d8 fb 	      sta	[RAM]+depthLeft
    703  0eca
    704  0eca		       20 97 f2 	      jsr	debug
    705  0ecd				   .tooDeep
    706  0ecd					      ENDIF
    707  0ecd				   .exit
    708  0ecd
    709  0ecd
    710  0ecd
    711  0ecd
    712  0ecd							; Scan for capture of king
    713  0ecd							; Also scan for virtual king captures (squares involved in castling)
    714  0ecd
      0  0ecd					      ldx@PLY	moveIndex
      1  0ecd		       ae cf f9 	      ldx	moveIndex
    716  0ed0		       30 19		      bmi	.notCheck	; OK if no captures in quiesce!
    717  0ed2
      0  0ed2				   .scanCheck lda@PLY	MoveCapture,x
      1  0ed2		       bd 64 f9 	      lda	MoveCapture,x
    719  0ed5		       29 07		      and	#PIECE_MASK
    720  0ed7		       c9 07		      cmp	#KING
    721  0ed9		       f0 12		      beq	.check
    722  0edb
    723  0edb							; If the squares the king is crossing for castling are capturable, then that's an illegal
    724  0edb							; castle move and it's treated as if the king were in check.
    725  0edb
      0  0edb					      lda@PLY	MoveTo,x
      1  0edb		       bd 64 f8 	      lda	MoveTo,x
      0  0ede					      cmp@PLY	virtualKingSquare
      1  0ede		       cd da f9 	      cmp	virtualKingSquare
    728  0ee1		       f0 0a		      beq	.check
      0  0ee3					      cmp@PLY	virtualKingSquare+1
      1  0ee3		       cd db f9 	      cmp	virtualKingSquare+1
    730  0ee6		       f0 05		      beq	.check
    731  0ee8
    732  0ee8		       ca	   .nextScan  dex
    733  0ee9		       10 e7		      bpl	.scanCheck
    734  0eeb
    735  0eeb		       a9 00	   .notCheck  lda	#0
    736  0eed		       85 a1	   .check     sta	flagCheck
    737  0eef		       60		      rts
    738  0ef0
    739  0ef0
    740  0ef0							;---------------------------------------------------------------------------------------------------
    741  0ef0							; QUIESCE!
    742  0ef0
    743  0ef0							;int Quiesce( int alpha, int beta ) {
    744  0ef0							;    int stand_pat = Evaluate();
    745  0ef0							;    if( stand_pat >= beta )
    746  0ef0							;	  return beta;
    747  0ef0							;    if( alpha < stand_pat )
    748  0ef0							;	  alpha = stand_pat;
    749  0ef0
    750  0ef0							;    until( every_capture_has_been_examined )	{
    751  0ef0							;	  MakeCapture();
    752  0ef0							;	  score = -Quiesce( -beta, -alpha );
    753  0ef0							;	  TakeBackMove();
    754  0ef0
    755  0ef0							;	  if( score >= beta )
    756  0ef0							;	      return beta;
    757  0ef0							;	  if( score > alpha )
    758  0ef0							;	     alpha = score;
    759  0ef0							;    }
    760  0ef0							;    return alpha;
    761  0ef0							;}
    762  0ef0
    763  0ef0
    764  0ef0							;---------------------------------------------------------------------------------------------------
    765  0ef0
      0  0ef0					      DEF	quiesce
      1  0ef0				   SLOT_quiesce SET	_BANK_SLOT
      2  0ef0				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  0ef0				   quiesce
      4  0ef0				   TEMPORARY_VAR SET	Overlay
      5  0ef0				   TEMPORARY_OFFSET SET	0
      6  0ef0				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  0ef0				   FUNCTION_NAME SET	quiesce
    767  0ef0					      SUBROUTINE
    768  0ef0
    769  0ef0							; pass...
    770  0ef0							; x = depthleft
    771  0ef0							; SET_BANK_RAM      --> current ply
    772  0ef0							; __alpha[2] = param alpha
    773  0ef0							; __beta[2] = param beta
    774  0ef0
    775  0ef0
      0  0ef0					      REF	COMMON_VARS
      1  0ef0					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0ef0				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0ef0					      ENDIF
      0  0ef0					      REF	negaMax
      1  0ef0					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0ef0				   TEMPORARY_VAR SET	VAREND_negaMax
      3  0ef0					      ENDIF
      0  0ef0					      VEND	quiesce
      1  0ef0
      2  0ef0
      3  0ef0		       00 b9	   VAREND_quiesce =	TEMPORARY_VAR
      4  0ef0
    779  0ef0
    780  0ef0		       a5 95		      lda	currentPly
    781  0ef2		       c9 94		      cmp	#RAMBANK_PLY + PLY_BANKS -1
    782  0ef4		       b0 28		      bcs	.retBeta
    783  0ef6							;sta SET_BANK_RAM ;tmp
    784  0ef6
    785  0ef6
    786  0ef6		       20 88 f0 	      jsr	ThinkBar	;@0
    787  0ef9
    788  0ef9		       a5 ac		      lda	__beta
      0  0efb					      sta@PLY	beta
      1  0efb		       8d d4 fb 	      sta	[RAM]+beta
    790  0efe		       a5 ad		      lda	__beta+1
      0  0f00					      sta@PLY	beta+1
      1  0f00		       8d d5 fb 	      sta	[RAM]+beta+1
    792  0f03
    793  0f03		       a5 aa		      lda	__alpha
      0  0f05					      sta@PLY	alpha
      1  0f05		       8d d2 fb 	      sta	[RAM]+alpha
    795  0f08		       a5 ab		      lda	__alpha+1
      0  0f0a					      sta@PLY	alpha+1
      1  0f0a		       8d d3 fb 	      sta	[RAM]+alpha+1
    797  0f0d
    798  0f0d
    799  0f0d							;    int stand_pat = Evaluate();
    800  0f0d							;    if( stand_pat >= beta )
    801  0f0d							;	  return beta;
    802  0f0d
    803  0f0d		       38		      sec
    804  0f0e		       a5 90		      lda	Evaluation
      0  0f10					      sbc@PLY	beta
      1  0f10		       ed d4 f9 	      sbc	beta
    806  0f13		       a5 91		      lda	Evaluation+1
      0  0f15					      sbc@PLY	beta+1
      1  0f15		       ed d5 f9 	      sbc	beta+1
    808  0f18		       50 02		      bvc	.spat0
    809  0f1a		       49 80		      eor	#$80
    810  0f1c		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    811  0f1e
    812  0f1e		       ad d4 f9    .retBeta   lda	beta
    813  0f21		       85 ae		      sta	__negaMax
    814  0f23		       ad d5 f9 	      lda	beta+1
    815  0f26		       85 af		      sta	__negaMax+1
    816  0f28
    817  0f28		       60	   .abort     rts
    818  0f29
    819  0f29				   .norb
    820  0f29
    821  0f29
    822  0f29							;    if( alpha < stand_pat )
    823  0f29							;	  alpha = stand_pat;
    824  0f29
    825  0f29		       38		      sec
    826  0f2a		       ad d2 f9 	      lda	alpha
    827  0f2d		       e5 90		      sbc	Evaluation
    828  0f2f		       ad d3 f9 	      lda	alpha+1
    829  0f32		       e5 91		      sbc	Evaluation+1
    830  0f34		       50 02		      bvc	.spat1
    831  0f36		       49 80		      eor	#$80
    832  0f38		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    833  0f3a
    834  0f3a							; alpha < stand_pat
    835  0f3a
    836  0f3a		       a5 90		      lda	Evaluation
      0  0f3c					      sta@PLY	alpha
      1  0f3c		       8d d2 fb 	      sta	[RAM]+alpha
    838  0f3f		       a5 91		      lda	Evaluation+1
      0  0f41					      sta@PLY	alpha+1
      1  0f41		       8d d3 fb 	      sta	[RAM]+alpha+1
    840  0f44
    841  0f44				   .alpha
    842  0f44		       20 ad f1 	      jsr	GenerateAllMoves
    843  0f47		       a5 a1		      lda	flagCheck
    844  0f49		       d0 dd		      bne	.abort	; pure abort
    845  0f4b
      0  0f4b					      ldx@PLY	moveIndex
      1  0f4b		       ae cf f9 	      ldx	moveIndex
    847  0f4e		       30 76		      bmi	.exit
    848  0f50
      0  0f50				   .forChild  stx@PLY	movePtr
      1  0f50		       8e d0 fb 	      stx	[RAM]+movePtr
    850  0f53
    851  0f53							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    852  0f53
    853  0f53		       20 7f f4 	      jsr	MakeMove	;@this
    854  0f56
    855  0f56		       38		      sec
    856  0f57		       a9 00		      lda	#0
      0  0f59					      sbc@PLY	beta
      1  0f59		       ed d4 f9 	      sbc	beta
    858  0f5c		       85 aa		      sta	__alpha
    859  0f5e		       a9 00		      lda	#0
      0  0f60					      sbc@PLY	beta+1
      1  0f60		       ed d5 f9 	      sbc	beta+1
    861  0f63		       85 ab		      sta	__alpha+1
    862  0f65
    863  0f65		       38		      sec
    864  0f66		       a9 00		      lda	#0
      0  0f68					      sbc@PLY	alpha
      1  0f68		       ed d2 f9 	      sbc	alpha
    866  0f6b		       85 ac		      sta	__beta
    867  0f6d		       a9 00		      lda	#0
      0  0f6f					      sbc@PLY	alpha+1
      1  0f6f		       ed d3 f9 	      sbc	alpha+1
    869  0f72		       85 ad		      sta	__beta+1
    870  0f74
    871  0f74		       e6 95		      inc	currentPly
    872  0f76		       a5 95		      lda	currentPly
    873  0f78		       85 3e		      sta	SET_BANK_RAM	; self-switch
    874  0f7a
    875  0f7a		       20 f0 f6 	      jsr	quiesce	;@this
    876  0f7d
    877  0f7d		       c6 95		      dec	currentPly
    878  0f7f
    879  0f7f		       20 98 f2 	      jsr	unmakeMove	;@0
    880  0f82
    881  0f82		       a5 a1		      lda	flagCheck	; don't consider moves which leave us in check
    882  0f84		       d0 4b		      bne	.inCheck
    883  0f86
    884  0f86		       38		      sec
    885  0f87							;lda #0			 ; already 0
    886  0f87		       e5 ae		      sbc	__negaMax
    887  0f89		       85 ae		      sta	__negaMax
    888  0f8b		       a9 00		      lda	#0
    889  0f8d		       e5 af		      sbc	__negaMax+1
    890  0f8f		       85 af		      sta	__negaMax+1	; -negaMax(...)
    891  0f91
    892  0f91
    893  0f91
    894  0f91							;	  if( score >= beta )
    895  0f91							;	      return beta;
    896  0f91
    897  0f91
    898  0f91		       38		      sec
    899  0f92		       a5 ae		      lda	__negaMax
      0  0f94					      sbc@PLY	beta
      1  0f94		       ed d4 f9 	      sbc	beta
    901  0f97		       a5 af		      lda	__negaMax+1
      0  0f99					      sbc@PLY	beta+1
      1  0f99		       ed d5 f9 	      sbc	beta+1
    903  0f9c		       50 02		      bvc	.lab0
    904  0f9e		       49 80		      eor	#$80
    905  0fa0		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    906  0fa2		       4c 1e f7 	      jmp	.retBeta
    907  0fa5				   .nrb2
    908  0fa5
    909  0fa5							;	  if( score > alpha )
    910  0fa5							;	     alpha = score;
    911  0fa5							;    }
    912  0fa5
    913  0fa5		       38		      sec
      0  0fa6					      lda@PLY	alpha
      1  0fa6		       ad d2 f9 	      lda	alpha
    915  0fa9		       e5 ae		      sbc	__negaMax
      0  0fab					      lda@PLY	alpha+1
      1  0fab		       ad d3 f9 	      lda	alpha+1
    917  0fae		       e5 af		      sbc	__negaMax+1
    918  0fb0		       50 02		      bvc	.lab2
    919  0fb2		       49 80		      eor	#$80
    920  0fb4		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    921  0fb6
    922  0fb6							; score > alpha
    923  0fb6
    924  0fb6		       a5 ae		      lda	__negaMax
      0  0fb8					      sta@PLY	alpha
      1  0fb8		       8d d2 fb 	      sta	[RAM]+alpha
    926  0fbb		       a5 af		      lda	__negaMax+1
      0  0fbd					      sta@PLY	alpha+1
      1  0fbd		       8d d3 fb 	      sta	[RAM]+alpha+1
    928  0fc0
      0  0fc0				   .nextMove  ldx@PLY	movePtr
      1  0fc0		       ae d0 f9 	      ldx	movePtr
    930  0fc3		       ca		      dex
    931  0fc4		       10 8a		      bpl	.forChild
    932  0fc6
    933  0fc6							;    return alpha;
    934  0fc6
    935  0fc6				   .exit
      0  0fc6					      lda@PLY	alpha
      1  0fc6		       ad d2 f9 	      lda	alpha
    937  0fc9		       85 ae		      sta	__negaMax
      0  0fcb					      lda@PLY	alpha+1
      1  0fcb		       ad d3 f9 	      lda	alpha+1
    939  0fce		       85 af		      sta	__negaMax+1
    940  0fd0		       60		      rts
    941  0fd1
    942  0fd1		       a9 00	   .inCheck   lda	#0
    943  0fd3		       85 a1		      sta	flagCheck
    944  0fd5		       f0 e9		      beq	.nextMove
    945  0fd7
    946  0fd7
    947  0fd7							;---------------------------------------------------------------------------------------------------
    948  0fd7
      0  0fd7					      END_BANK
      1  0fd7				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  0fd7				  -	      CHECK_RAM_BANK_SIZE
      3  0fd7					      ELSE
      0  0fd7					      CHECK_BANK_SIZE
      1  0fd7		       03 d7	   .TEMP      =	* - _BANK_START
 ROM bank # 4 NEGAMAX size = $3d7 free = 40
      2  0fd7					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  0fd7				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0fd7				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  0fd7				  -	      ERR
      6  0fd7					      ENDIF
      5  0fd7					      ENDIF
    950  0fd7
    951  0fd7							;---------------------------------------------------------------------------------------------------
    952  0fd7							; EOF
------- FILE ./chess.asm
------- FILE @1 STATE MACHINE #1.asm LEVEL 2 PASS 4
      0  0fd7					      include	"@1 STATE MACHINE #1.asm"
      1  0fd7							;---------------------------------------------------------------------------------------------------
      2  0fd7							; @1 STATE MACHINE #1.asm
      3  0fd7
      4  0fd7							; Atari 2600 Chess
      5  0fd7							; Copyright (c) 2019-2020 Andrew Davie
      6  0fd7							; andrew@taswegian.com
      7  0fd7
      8  0fd7
      9  0fd7							;---------------------------------------------------------------------------------------------------
     10  0fd7
      0  0fd7					      SLOT	1
      1  0fd7
      2  0fd7				  -	      IF	(1 < 0) || (1 > 3)
      3  0fd7				  -	      ECHO	"Illegal bank address/segment location", 1
      4  0fd7				  -	      ERR
      5  0fd7					      ENDIF
      6  0fd7
      7  0fd7				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  0fd7				   _BANK_SLOT SET	1 * 64
      9  0fd7
      0  0fd7					      ROMBANK	STATEMACHINE
      1  13e1 ????				      SEG	ROM_STATEMACHINE
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   STATEMACHINE_START SET	*
      6  1000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1000				   ROMBANK_STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1000				   _LAST_BANK SETSTR	STATEMACHINE
     10  1000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1000
     14  1000
     15  1000							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
     16  1000
     17  1000
     18  1000		       00 10	   CURSOR_MOVE_SPEED =	16
     19  1000		       00 14	   CAP_SPEED  =	20
     20  1000		       00 28	   HOLD_DELAY =	40
     21  1000
     22  1000
     23  1000							;---------------------------------------------------------------------------------------------------
     24  1000
      0  1000					      DEF	aiStartMoveGen
      1  1000				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  1000				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  1000				   aiStartMoveGen
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	aiStartMoveGen
     26  1000					      SUBROUTINE
     27  1000
      0  1000					      REF	AiStateMachine
      1  1000					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1000				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1000					      ENDIF
      0  1000					      VEND	aiStartMoveGen
      1  1000
      2  1000
      3  1000		       00 a9	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
      4  1000
     30  1000
     31  1000							; To assist with castling, generate the moves for the opponent, giving us effectively
     32  1000							; a list of squares that are being attacked. The castling can't happen if the king is
     33  1000							; in check or if the squares it would have to move over are in check
     34  1000
     35  1000							; we don't need to worry about this if K has moved, or relevant R has moved or if
     36  1000							; the squares between are occupied. We can tell THAT by examining the movelist to see
     37  1000							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     38  1000
     39  1000							;inc currentPly
     40  1000							;jsr InitialiseMoveGeneration
     41  1000
      0  1000					      PHASE	StepMoveGen
      1  1000		       a9 0c		      lda	#AI_StepMoveGen
      2  1002		       85 8c		      sta	aiState
     43  1004		       60		      rts
     44  1005
     45  1005
     46  1005							;---------------------------------------------------------------------------------------------------
     47  1005
      0  1005					      DEF	aiInCheckBackupStart
      1  1005				   SLOT_aiInCheckBackupStart SET	_BANK_SLOT
      2  1005				   BANK_aiInCheckBackupStart SET	SLOT_aiInCheckBackupStart + _CURRENT_BANK
      3  1005				   aiInCheckBackupStart
      4  1005				   TEMPORARY_VAR SET	Overlay
      5  1005				   TEMPORARY_OFFSET SET	0
      6  1005				   VAR_BOUNDARY_aiInCheckBackupStart SET	TEMPORARY_OFFSET
      7  1005				   FUNCTION_NAME SET	aiInCheckBackupStart
     49  1005					      SUBROUTINE
     50  1005
      0  1005					      REF	AiStateMachine
      1  1005					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1005				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1005					      ENDIF
      0  1005					      VEND	aiInCheckBackupStart
      1  1005
      2  1005
      3  1005		       00 a9	   VAREND_aiInCheckBackupStart =	TEMPORARY_VAR
      4  1005
     53  1005
     54  1005
     55  1005
     56  1005		       a9 08		      lda	#8
     57  1007		       85 85		      sta	drawCount	; row to draw
     58  1009
      0  1009					      PHASE	InCheckBackup
      1  1009		       a9 1d		      lda	#AI_InCheckBackup
      2  100b		       85 8c		      sta	aiState
     60  100d		       60		      rts
     61  100e
     62  100e
     63  100e							;---------------------------------------------------------------------------------------------------
     64  100e
      0  100e					      DEF	aiInCheckBackup
      1  100e				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  100e				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  100e				   aiInCheckBackup
      4  100e				   TEMPORARY_VAR SET	Overlay
      5  100e				   TEMPORARY_OFFSET SET	0
      6  100e				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  100e				   FUNCTION_NAME SET	aiInCheckBackup
     66  100e					      SUBROUTINE
     67  100e
      0  100e					      REF	AiStateMachine
      1  100e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  100e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  100e					      ENDIF
      0  100e					      VEND	aiInCheckBackup
      1  100e
      2  100e
      3  100e		       00 a9	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
      4  100e
     70  100e
     71  100e
     72  100e							; We're about to draw some large text on the screen
     73  100e							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     74  100e
     75  100e		       c6 85		      dec	drawCount
     76  1010		       30 07		      bmi	.exit	; done all rows
     77  1012
      0  1012					      JUMP	BackupBitmaps	;@3
      1  1012				  -	      IF	SLOT_BackupBitmaps == _BANK_SLOT
      2  1012				  -FNAME      SETSTR	BackupBitmaps
      3  1012				  -	      ECHO	""
      4  1012				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  1012				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1012				  -	      ERR
      7  1012					      ENDIF
      8  1012		       a9 da		      lda	#BANK_BackupBitmaps
      9  1014		       85 3f		      sta	SET_BANK
     10  1016		       4c 5d fc 	      jmp	BackupBitmaps
     79  1019
     80  1019				   .exit
     81  1019
     82  1019		       a9 08		      lda	#8
     83  101b		       85 85		      sta	drawCount	; ROW
     84  101d
      0  101d					      PHASE	MaskBitmapBackground
      1  101d		       a9 2f		      lda	#AI_MaskBitmapBackground
      2  101f		       85 8c		      sta	aiState
     86  1021		       60		      rts
     87  1022
     88  1022
     89  1022							;---------------------------------------------------------------------------------------------------
     90  1022
      0  1022					      DEF	aiWaitBitmap
      1  1022				   SLOT_aiWaitBitmap SET	_BANK_SLOT
      2  1022				   BANK_aiWaitBitmap SET	SLOT_aiWaitBitmap + _CURRENT_BANK
      3  1022				   aiWaitBitmap
      4  1022				   TEMPORARY_VAR SET	Overlay
      5  1022				   TEMPORARY_OFFSET SET	0
      6  1022				   VAR_BOUNDARY_aiWaitBitmap SET	TEMPORARY_OFFSET
      7  1022				   FUNCTION_NAME SET	aiWaitBitmap
     92  1022					      SUBROUTINE
     93  1022
      0  1022					      REF	AiStateMachine
      1  1022					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1022				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1022					      ENDIF
      0  1022					      VEND	aiWaitBitmap
      1  1022
      2  1022
      3  1022		       00 a9	   VAREND_aiWaitBitmap =	TEMPORARY_VAR
      4  1022
     96  1022
     97  1022							;		      lda INPT4
     98  1022							;		      bmi .noButton
     99  1022							;PHASE DrawBitmap
    100  1022							;rts
    101  1022		       c6 85		      dec	drawCount
    102  1024		       a5 85		      lda	drawCount
    103  1026		       c9 dc		      cmp	#220
    104  1028		       d0 08		      bne	.noButton
    105  102a
    106  102a
    107  102a				   .button
    108  102a		       a9 08		      lda	#8
    109  102c		       85 85		      sta	drawCount	; ROW#
    110  102e
      0  102e					      PHASE	RestoreBitmaps
      1  102e		       a9 2d		      lda	#AI_RestoreBitmaps
      2  1030		       85 8c		      sta	aiState
    112  1032		       60	   .noButton  rts
    113  1033
    114  1033
    115  1033							;---------------------------------------------------------------------------------------------------
    116  1033
      0  1033					      DEF	aiRestoreBitmaps
      1  1033				   SLOT_aiRestoreBitmaps SET	_BANK_SLOT
      2  1033				   BANK_aiRestoreBitmaps SET	SLOT_aiRestoreBitmaps + _CURRENT_BANK
      3  1033				   aiRestoreBitmaps
      4  1033				   TEMPORARY_VAR SET	Overlay
      5  1033				   TEMPORARY_OFFSET SET	0
      6  1033				   VAR_BOUNDARY_aiRestoreBitmaps SET	TEMPORARY_OFFSET
      7  1033				   FUNCTION_NAME SET	aiRestoreBitmaps
    118  1033					      SUBROUTINE
    119  1033
    120  1033		       c6 85		      dec	drawCount
    121  1035		       30 07		      bmi	.exit	; done all rows
    122  1037
      0  1037					      JUMP	RestoreBitmaps	;@3
      1  1037				  -	      IF	SLOT_RestoreBitmaps == _BANK_SLOT
      2  1037				  -FNAME      SETSTR	RestoreBitmaps
      3  1037				  -	      ECHO	""
      4  1037				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  1037				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1037				  -	      ERR
      7  1037					      ENDIF
      8  1037		       a9 da		      lda	#BANK_RestoreBitmaps
      9  1039		       85 3f		      sta	SET_BANK
     10  103b		       4c 71 fc 	      jmp	RestoreBitmaps
    124  103e
    125  103e				   .exit
    126  103e
    127  103e		       a5 4c		      lda	INPT4
    128  1040							;bmi .noButton
      0  1040					      PHASE	SelectStartSquare
      1  1040		       a9 02		      lda	#AI_SelectStartSquare
      2  1042		       85 8c		      sta	aiState
    130  1044		       60		      rts
    131  1045				   .noButton
    132  1045							;		      PHASE InCheckDelay
      0  1045					      PHASE	SelectStartSquare
      1  1045		       a9 02		      lda	#AI_SelectStartSquare
      2  1047		       85 8c		      sta	aiState
    134  1049							;PHASE InCheckBackupStart
    135  1049		       60		      rts
    136  104a
    137  104a
    138  104a
    139  104a							;---------------------------------------------------------------------------------------------------
    140  104a
      0  104a					      DEF	aiInCheckDelay
      1  104a				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  104a				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  104a				   aiInCheckDelay
      4  104a				   TEMPORARY_VAR SET	Overlay
      5  104a				   TEMPORARY_OFFSET SET	0
      6  104a				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  104a				   FUNCTION_NAME SET	aiInCheckDelay
    142  104a					      SUBROUTINE
    143  104a
      0  104a					      REF	AiStateMachine
      1  104a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  104a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  104a					      ENDIF
      0  104a					      VEND	aiInCheckDelay
      1  104a
      2  104a
      3  104a		       00 a9	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
      4  104a
    146  104a
    147  104a		       c6 8a		      dec	mdelay
    148  104c		       d0 08		      bne	.exit
    149  104e
    150  104e		       a9 00		      lda	#0
    151  1050		       85 49		      sta	COLUBK
    152  1052
      0  1052					      PHASE	BeginSelectMovePhase
      1  1052		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  1054		       85 8c		      sta	aiState
    154  1056		       60	   .exit      rts
    155  1057
    156  1057
    157  1057							;---------------------------------------------------------------------------------------------------
    158  1057
      0  1057					      DEF	aiBeginSelectMovePhase
      1  1057				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  1057				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  1057				   aiBeginSelectMovePhase
      4  1057				   TEMPORARY_VAR SET	Overlay
      5  1057				   TEMPORARY_OFFSET SET	0
      6  1057				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  1057				   FUNCTION_NAME SET	aiBeginSelectMovePhase
    160  1057					      SUBROUTINE
    161  1057
      0  1057					      REF	AiStateMachine
      1  1057					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1057				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1057					      ENDIF
      0  1057					      VEND	aiBeginSelectMovePhase
      1  1057
      2  1057
      3  1057		       00 a9	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
      4  1057
    164  1057
    165  1057		       a6 a5		      ldx	platform
    166  1059		       bd 79 f4 	      lda	greyCol,x
    167  105c		       85 46		      sta	COLUP0
    168  105e
    169  105e		       a2 04		      ldx	#%100
    170  1060		       86 4a		      stx	CTRLPF	; under
    171  1062
    172  1062		       a9 00		      lda	#0
    173  1064		       85 8a		      sta	mdelay	;?
    174  1066		       85 8f		      sta	aiFlashPhase	; odd/even for flashing pieces
    175  1068
    176  1068		       a9 28		      lda	#CAP_SPEED*2
    177  106a		       85 8d		      sta	aiFlashDelay
    178  106c
    179  106c		       a9 ff		      lda	#-1
    180  106e		       85 86		      sta	fromX12
    181  1070		       85 87		      sta	toX12
    182  1072
    183  1072		       46 a2		      lsr	randomness
    184  1074
    185  1074
      0  1074					      PHASE	FlashComputerMove
      1  1074		       a9 00		      lda	#AI_FlashComputerMove
      2  1076		       85 8c		      sta	aiState
    187  1078		       60		      rts
    188  1079
    189  1079				   greyCol
    190  1079		       06 08		      .byte.b	6, 8
    191  107b
    192  107b							;---------------------------------------------------------------------------------------------------
    193  107b
      0  107b					      DEF	aiFlashComputerMove
      1  107b				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  107b				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  107b				   aiFlashComputerMove
      4  107b				   TEMPORARY_VAR SET	Overlay
      5  107b				   TEMPORARY_OFFSET SET	0
      6  107b				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  107b				   FUNCTION_NAME SET	aiFlashComputerMove
    195  107b					      SUBROUTINE
    196  107b
      0  107b					      REF	Variable_PieceShapeBuffer
      1  107b					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  107b				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  107b					      ENDIF
      0  107b					      REF	AiStateMachine
      1  107b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  107b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  107b					      ENDIF
      0  107b					      VEND	aiFlashComputerMove
      1  107b
      2  107b
      3  107b		       00 ef	   VAREND_aiFlashComputerMove =	TEMPORARY_VAR
      4  107b
    200  107b
    201  107b		       a5 81		      lda	squareToDraw
    202  107d		       30 30		      bmi	.initial2	; startup - no computer move to show
    203  107f
    204  107f		       a5 8f		      lda	aiFlashPhase
    205  1081		       4a		      lsr
    206  1082		       b0 0c		      bcs	.noSwapside	; only check for SELECT/exit if piece is drawn
    207  1084
    208  1084		       ad 82 02 	      lda	SWCHB
    209  1087		       29 02		      and	#SELECT_SWITCH
    210  1089		       d0 05		      bne	.noSwapside
    211  108b
      0  108b					      PHASE	DebounceSelect
      1  108b		       a9 2b		      lda	#AI_DebounceSelect
      2  108d		       85 8c		      sta	aiState
    213  108f		       60		      rts
    214  1090				   .noSwapside
    215  1090
    216  1090							; "squareToDraw" is the piece that should flash while human waits
    217  1090
    218  1090		       ad 80 02 	      lda	SWCHA
    219  1093		       29 f0		      and	#$F0	; UDLR bits
    220  1095		       c9 f0		      cmp	#$F0	; all NOT pressed
    221  1097		       f0 08		      beq	.nodir
    222  1099
    223  1099							; direction has been pressed, so transition out of flashing
    224  1099
    225  1099		       a9 01		      lda	#1
    226  109b		       85 8d		      sta	aiFlashDelay
    227  109d		       25 8f		      and	aiFlashPhase
    228  109f		       f0 0e		      beq	.initial
    229  10a1
    230  10a1		       c6 8d	   .nodir     dec	aiFlashDelay
    231  10a3		       d0 0e		      bne	.exit	; don't flash
    232  10a5		       a9 28		      lda	#CAP_SPEED*2
    233  10a7		       85 8d		      sta	aiFlashDelay
    234  10a9
    235  10a9		       e6 8f		      inc	aiFlashPhase
    236  10ab
    237  10ab							; WARNING - local variables will not survive the following call...!
    238  10ab		       20 c8 f0 	      jsr	CopySinglePiece	;@0
    239  10ae		       60		      rts
    240  10af
    241  10af				   .initial
    242  10af
    243  10af							;SWAP
    244  10af				   .initial2
    245  10af
    246  10af
    247  10af							;PHASE InCheckBackupStart ;tmp
    248  10af							;rts
    249  10af
    250  10af
      0  10af					      PHASE	SelectStartSquare
      1  10af		       a9 02		      lda	#AI_SelectStartSquare
      2  10b1		       85 8c		      sta	aiState
    252  10b3
    253  10b3		       60	   .exit      rts
    254  10b4
    255  10b4
    256  10b4							;---------------------------------------------------------------------------------------------------
    257  10b4
      0  10b4					      DEF	aiSelectStartSquare
      1  10b4				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  10b4				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  10b4				   aiSelectStartSquare
      4  10b4				   TEMPORARY_VAR SET	Overlay
      5  10b4				   TEMPORARY_OFFSET SET	0
      6  10b4				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  10b4				   FUNCTION_NAME SET	aiSelectStartSquare
    259  10b4					      SUBROUTINE
    260  10b4
      0  10b4					      REF	AiStateMachine
      1  10b4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  10b4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  10b4					      ENDIF
      0  10b4					      VEND	aiSelectStartSquare
      1  10b4
      2  10b4
      3  10b4		       00 a9	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
      4  10b4
    263  10b4
      0  10b4					      NEXT_RANDOM
      1  10b4
      2  10b4		       a5 82		      lda	rnd
      3  10b6		       4a		      lsr
      4  10b7		       90 02		      bcc	.skipEOR
      5  10b9		       49 b4		      eor	#RND_EOR_VAL
      6  10bb		       85 82	   .skipEOR   sta	rnd
      7  10bd
    265  10bd
    266  10bd		       ad 82 02 	      lda	SWCHB
    267  10c0		       29 02		      and	#SELECT_SWITCH
    268  10c2		       f0 34		      beq	.swapside
    269  10c4
      0  10c4					      CALL	moveCursor	;@2
      1  10c4				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  10c4				  -FNAME      SETSTR	moveCursor
      3  10c4				  -	      ECHO	""
      4  10c4				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  10c4				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  10c4				  -	      ERR
      7  10c4					      ENDIF
      8  10c4		       a9 8a		      lda	#BANK_moveCursor
      9  10c6		       85 3f		      sta	SET_BANK
     10  10c8		       20 00 f8 	      jsr	moveCursor
    271  10cb
    272  10cb							; Search the player's movelist for the square, so we can set cursor colour
    273  10cb
    274  10cb		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
    275  10cd		       85 3e		      sta	SET_BANK_RAM	;@2
    276  10cf
    277  10cf		       a5 89		      lda	cursorX12
    278  10d1		       85 86		      sta	fromX12
    279  10d3
      0  10d3					      ldy@PLY	moveIndex
      1  10d3		       ac cf f9 	      ldy	moveIndex
    281  10d6		       30 0d		      bmi	.done
    282  10d8
    283  10d8		       d9 00 f8    .scan      cmp	MoveFrom,y
    284  10db		       f0 03		      beq	.scanned
    285  10dd		       88		      dey
    286  10de		       10 f8		      bpl	.scan
    287  10e0
      0  10e0				   .scanned   lda@PLY	MovePiece,y
      1  10e0		       b9 00 f9 	      lda	MovePiece,y
    289  10e3		       85 97		      sta	fromPiece
    290  10e5
    291  10e5		       c6 8b	   .done      dec	ccur	; pulse colour for valid squares
      0  10e7					      CALL	setCursorColours
      1  10e7				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  10e7				  -FNAME      SETSTR	setCursorColours
      3  10e7				  -	      ECHO	""
      4  10e7				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  10e7				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  10e7				  -	      ERR
      7  10e7					      ENDIF
      8  10e7		       a9 8a		      lda	#BANK_setCursorColours
      9  10e9		       85 3f		      sta	SET_BANK
     10  10eb		       20 4a f8 	      jsr	setCursorColours
    293  10ee
    294  10ee		       98		      tya
    295  10ef		       05 4c		      ora	INPT4
    296  10f1		       30 04		      bmi	.exit	; illegal square or no button press
    297  10f3
      0  10f3					      PHASE	StartSquareSelected
      1  10f3		       a9 03		      lda	#AI_StartSquareSelected
      2  10f5		       85 8c		      sta	aiState
    299  10f7
    300  10f7		       60	   .exit      rts
    301  10f8
    302  10f8
    303  10f8
    304  10f8				   .swapside
    305  10f8
      0  10f8					      PHASE	DebounceSelect
      1  10f8		       a9 2b		      lda	#AI_DebounceSelect
      2  10fa		       85 8c		      sta	aiState
    307  10fc		       60		      rts
    308  10fd
    309  10fd							;---------------------------------------------------------------------------------------------------
    310  10fd
      0  10fd					      DEF	aiDebounceSelect
      1  10fd				   SLOT_aiDebounceSelect SET	_BANK_SLOT
      2  10fd				   BANK_aiDebounceSelect SET	SLOT_aiDebounceSelect + _CURRENT_BANK
      3  10fd				   aiDebounceSelect
      4  10fd				   TEMPORARY_VAR SET	Overlay
      5  10fd				   TEMPORARY_OFFSET SET	0
      6  10fd				   VAR_BOUNDARY_aiDebounceSelect SET	TEMPORARY_OFFSET
      7  10fd				   FUNCTION_NAME SET	aiDebounceSelect
    312  10fd					      SUBROUTINE
    313  10fd
    314  10fd		       ad 82 02 	      lda	SWCHB
    315  1100		       29 02		      and	#SELECT_SWITCH
    316  1102		       f0 17		      beq	.exit	; SELECT still pressed
    317  1104
    318  1104		       a5 96		      lda	sideToMove
    319  1106		       49 40		      eor	#HUMAN
    320  1108		       85 96		      sta	sideToMove
    321  110a
      0  110a					      NEGEVAL
      1  110a
      2  110a		       38		      sec
      3  110b		       a9 00		      lda	#0
      4  110d		       e5 90		      sbc	Evaluation
      5  110f		       85 90		      sta	Evaluation
      6  1111		       a9 00		      lda	#0
      7  1113		       e5 91		      sbc	Evaluation+1
      8  1115		       85 91		      sta	Evaluation+1
      9  1117
    323  1117
      0  1117					      PHASE	ComputerMove
      1  1117		       a9 13		      lda	#AI_ComputerMove
      2  1119		       85 8c		      sta	aiState
    325  111b		       60	   .exit      rts
    326  111c
    327  111c
    328  111c							;---------------------------------------------------------------------------------------------------
    329  111c
      0  111c					      DEF	aiDrawMoves
      1  111c				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  111c				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  111c				   aiDrawMoves
      4  111c				   TEMPORARY_VAR SET	Overlay
      5  111c				   TEMPORARY_OFFSET SET	0
      6  111c				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  111c				   FUNCTION_NAME SET	aiDrawMoves
    331  111c					      SUBROUTINE
    332  111c
      0  111c					      REF	AiStateMachine
      1  111c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  111c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  111c					      ENDIF
      0  111c					      VEND	aiDrawMoves
      1  111c
      2  111c
      3  111c		       00 a9	   VAREND_aiDrawMoves =	TEMPORARY_VAR
      4  111c
    335  111c
    336  111c		       c6 8b		      dec	ccur
      0  111e					      CALL	setCursorColours
      1  111e				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  111e				  -FNAME      SETSTR	setCursorColours
      3  111e				  -	      ECHO	""
      4  111e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  111e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  111e				  -	      ERR
      7  111e					      ENDIF
      8  111e		       a9 8a		      lda	#BANK_setCursorColours
      9  1120		       85 3f		      sta	SET_BANK
     10  1122		       20 4a f8 	      jsr	setCursorColours
    338  1125
    339  1125		       c6 8a		      dec	mdelay
    340  1127		       d0 25		      bne	.exit
    341  1129		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    342  112b		       85 8a		      sta	mdelay	; once triggered, runs always
    343  112d
    344  112d		       a5 8e		      lda	aiMoveIndex
    345  112f		       10 09		      bpl	.valid
    346  1131
    347  1131		       a9 89		      lda	#RAMBANK_PLY+1
    348  1133		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1135					      lda@PLY	moveIndex
      1  1135		       ad cf f9 	      lda	moveIndex
    350  1138		       85 8e		      sta	aiMoveIndex
    351  113a				   .valid
    352  113a
    353  113a		       20 5b f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    354  113d		       a5 8e		      lda	aiMoveIndex
    355  113f		       10 19		      bpl	.unsure	; still drawing in this phase
    356  1141
    357  1141		       a9 14		      lda	#CAP_SPEED
    358  1143		       85 8a		      sta	mdelay
    359  1145
    360  1145		       a9 00		      lda	#0
    361  1147		       85 8f		      sta	aiFlashPhase	; controls odd/even exit of flashing
    362  1149
      0  1149					      PHASE	ShowMoveCaptures
      1  1149		       a9 05		      lda	#AI_ShowMoveCaptures
      2  114b		       85 8c		      sta	aiState
    364  114d		       60		      rts
    365  114e
    366  114e				   .exit
    367  114e
    368  114e							; Initial piece selection has happened, but the button hasn't been released yet
    369  114e							; AND we're still in the waiting phase to see if the button was held long enough for move show
    370  114e
    371  114e		       a5 4c		      lda	INPT4
    372  1150		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    373  1152
    374  1152							; Aha! Button released, so we know the selected piece and can start flashing it
    375  1152							; and allowing movement of the selector to a destination square...
    376  1152
    377  1152		       a9 18		      lda	#6*4
    378  1154		       85 8b		      sta	ccur	; bright green square for selection
    379  1156
      0  1156					      PHASE	SelectDestinationSquare
      1  1156		       a9 08		      lda	#AI_SelectDestinationSquare
      2  1158		       85 8c		      sta	aiState
    381  115a
    382  115a		       60	   .unsure    rts
    383  115b
    384  115b
    385  115b							;---------------------------------------------------------------------------------------------------
    386  115b
      0  115b					      DEF	showMoveOptions
      1  115b				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  115b				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  115b				   showMoveOptions
      4  115b				   TEMPORARY_VAR SET	Overlay
      5  115b				   TEMPORARY_OFFSET SET	0
      6  115b				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  115b				   FUNCTION_NAME SET	showMoveOptions
    388  115b					      SUBROUTINE
    389  115b
      0  115b					      REF	aiDrawMoves
      1  115b					      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  115b				   TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  115b					      ENDIF
      0  115b					      REF	aiUnDrawTargetSquares
      1  115b				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  115b				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  115b					      ENDIF
    392  115b
      0  115b					      VAR	__saveIdx, 1
      1  115b		       00 a9	   __saveIdx  =	TEMPORARY_VAR
      2  115b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  115b
      4  115b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  115b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  115b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  115b					      ENDIF
      8  115b				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  115b				  -VNAME      SETSTR	__saveIdx
     10  115b				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  115b				  -	      ERR
     12  115b					      ENDIF
      0  115b					      VAR	__piece, 1
      1  115b		       00 aa	   __piece    =	TEMPORARY_VAR
      2  115b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  115b
      4  115b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  115b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  115b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  115b					      ENDIF
      8  115b				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  115b				  -VNAME      SETSTR	__piece
     10  115b				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  115b				  -	      ERR
     12  115b					      ENDIF
    395  115b
      0  115b					      VEND	showMoveOptions
      1  115b
      2  115b
      3  115b		       00 ab	   VAREND_showMoveOptions =	TEMPORARY_VAR
      4  115b
    397  115b
    398  115b							; place a marker on the board for any square matching the piece
    399  115b							; EXCEPT for squares which are occupied (we'll flash those later)
    400  115b
    401  115b		       a6 8e	   .next      ldx	aiMoveIndex
    402  115d		       86 a9		      stx	__saveIdx
    403  115f		       30 4c		      bmi	.skip
    404  1161
    405  1161		       ad 84 02 	      lda	INTIM
    406  1164		       c9 2b		      cmp	#2+SPEEDOF_CopySinglePiece
    407  1166		       90 45		      bcc	.skip
    408  1168
    409  1168		       c6 8e		      dec	aiMoveIndex
    410  116a
    411  116a		       a9 89		      lda	#RAMBANK_PLY+1
    412  116c		       85 3e		      sta	SET_BANK_RAM	;@2
    413  116e
      0  116e					      lda@PLY	MoveFrom,x
      1  116e		       bd 00 f8 	      lda	MoveFrom,x
    415  1171		       c5 86		      cmp	fromX12
    416  1173		       d0 e6		      bne	.next
    417  1175
      0  1175					      lda@PLY	MoveTo,x
      1  1175		       bd 64 f8 	      lda	MoveTo,x
    419  1178		       85 81		      sta	squareToDraw
    420  117a
      0  117a					      lda@PLY	MovePiece,x
      1  117a		       bd 00 f9 	      lda	MovePiece,x
    422  117d		       85 aa		      sta	__piece
    423  117f
    424  117f							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    425  117f							; TODO this could/will fail on sorted lists. MMh.
    426  117f
    427  117f		       ca		      dex
    428  1180		       30 16		      bmi	.prom
    429  1182
      0  1182					      lda@PLY	MoveTo,x
      1  1182		       bd 64 f8 	      lda	MoveTo,x
    431  1185		       c5 81		      cmp	squareToDraw
    432  1187		       d0 0f		      bne	.prom
    433  1189
      0  1189					      lda@PLY	MovePiece,x
      1  1189		       bd 00 f9 	      lda	MovePiece,x
    435  118c		       45 aa		      eor	__piece
    436  118e		       29 07		      and	#PIECE_MASK
    437  1190		       f0 06		      beq	.prom	; same piece type so not a promote
    438  1192
    439  1192		       c6 8e		      dec	aiMoveIndex
    440  1194		       c6 8e		      dec	aiMoveIndex
    441  1196		       c6 8e		      dec	aiMoveIndex
    442  1198				   .prom
    443  1198
    444  1198		       a4 81		      ldy	squareToDraw
    445  119a
    446  119a		       a9 e3		      lda	#RAMBANK_BOARD
    447  119c		       85 3e		      sta	SET_BANK_RAM	;@3
    448  119e		       b9 79 fc 	      lda	Board,y
    449  11a1		       29 07		      and	#PIECE_MASK
    450  11a3		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    451  11a5
    452  11a5
    453  11a5							;lda INTIM
    454  11a5							;cmp #SPEEDOF_CopySinglePiece
    455  11a5							;bcc .skip
    456  11a5
    457  11a5							;lda aiMoveIndex
    458  11a5							;sta __saveIdx
    459  11a5
    460  11a5							; Draw the marker..."?
    461  11a5							; WARNING - local variables will not survive the following call...!
    462  11a5
    463  11a5		       a0 1c		      ldy	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    464  11a7		       20 b2 f5 	      jsr	CopySetupForMarker	;@this
    465  11aa		       4c cf f0 	      jmp	InterceptMarkerCopy	;@0
    466  11ad
    467  11ad
    468  11ad
    469  11ad		       a5 a9	   .skip      lda	__saveIdx
    470  11af		       85 8e		      sta	aiMoveIndex
    471  11b1		       60		      rts
    472  11b2
    473  11b2
    474  11b2							;---------------------------------------------------------------------------------------------------
    475  11b2
      0  11b2					      DEF	CopySetupForMarker
      1  11b2				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  11b2				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  11b2				   CopySetupForMarker
      4  11b2				   TEMPORARY_VAR SET	Overlay
      5  11b2				   TEMPORARY_OFFSET SET	0
      6  11b2				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  11b2				   FUNCTION_NAME SET	CopySetupForMarker
    477  11b2					      SUBROUTINE
    478  11b2
      0  11b2					      REF	showMoveOptions
      1  11b2					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  11b2					      ENDIF
      0  11b2					      REF	showPromoteOptions
      1  11b2					      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  11b2					      ENDIF
    481  11b2
      0  11b2					      VAR	__pieceColour2b, 1
      1  11b2		       00 ef	   __pieceColour2b =	TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  11b2
      4  11b2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  11b2				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  11b2				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  11b2					      ENDIF
      8  11b2				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  11b2				  -VNAME      SETSTR	__pieceColour2b
     10  11b2				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  11b2				  -	      ERR
     12  11b2					      ENDIF
      0  11b2					      VAR	__tmpb, 1
      1  11b2		       00 f0	   __tmpb     =	TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  11b2
      4  11b2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  11b2				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  11b2				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  11b2					      ENDIF
      8  11b2				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  11b2				  -VNAME      SETSTR	__tmpb
     10  11b2				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  11b2				  -	      ERR
     12  11b2					      ENDIF
      0  11b2					      VAR	__shiftxb, 1
      1  11b2		       00 f1	   __shiftxb  =	TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  11b2
      4  11b2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  11b2					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  11b2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  11b2					      ENDIF
      8  11b2				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  11b2				  -VNAME      SETSTR	__shiftxb
     10  11b2				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  11b2				  -	      ERR
     12  11b2					      ENDIF
    485  11b2
      0  11b2					      VEND	CopySetupForMarker
      1  11b2
      2  11b2
      3  11b2		       00 f2	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
      4  11b2
    487  11b2
    488  11b2
    489  11b2							; y = base shape
    490  11b2							; figure colouration of square
    491  11b2
    492  11b2		       a5 81		      lda	squareToDraw
    493  11b4
    494  11b4		       a2 0a		      ldx	#10
    495  11b6		       38		      sec
    496  11b7		       e9 0a	   .sub10     sbc	#10
    497  11b9		       ca		      dex
    498  11ba		       b0 fb		      bcs	.sub10
    499  11bc		       69 08		      adc	#8
    500  11be		       85 f1		      sta	__shiftxb
    501  11c0		       86 f0		      stx	__tmpb
    502  11c2		       65 f0		      adc	__tmpb
    503  11c4
    504  11c4
    505  11c4		       29 01		      and	#1
    506  11c6							;eor #1
    507  11c6		       f0 02		      beq	.white
    508  11c8		       a9 24		      lda	#36
    509  11ca				   .white
    510  11ca		       85 ef		      sta	__pieceColour2b	; actually SQUARE black/white
    511  11cc
    512  11cc		       a5 96		      lda	sideToMove
    513  11ce		       0a		      asl
    514  11cf		       90 02		      bcc	.blackAdjust
    515  11d1		       09 10		      ora	#16	; switch white pieces
    516  11d3		       4a	   .blackAdjust lsr
    517  11d4		       29 0f		      and	#%1111
    518  11d6		       aa		      tax
    519  11d7
    520  11d7		       a5 f1		      lda	__shiftxb
    521  11d9		       29 03		      and	#3	; shift position in P
    522  11db		       85 f1		      sta	__shiftxb
    523  11dd
    524  11dd		       98		      tya
    525  11de		       18		      clc
    526  11df		       65 f1		      adc	__shiftxb
    527  11e1		       18		      clc
    528  11e2		       65 ef		      adc	__pieceColour2b
    529  11e4		       a8		      tay
    530  11e5		       60		      rts
    531  11e6
    532  11e6
    533  11e6							;---------------------------------------------------------------------------------------------------
    534  11e6
      0  11e6					      DEF	aiUnDrawTargetSquares
      1  11e6				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  11e6				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  11e6				   aiUnDrawTargetSquares
      4  11e6				   TEMPORARY_VAR SET	Overlay
      5  11e6				   TEMPORARY_OFFSET SET	0
      6  11e6				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  11e6				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    536  11e6					      SUBROUTINE
    537  11e6
      0  11e6					      REF	AiStateMachine
      1  11e6					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  11e6				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  11e6					      ENDIF
      0  11e6					      VEND	aiUnDrawTargetSquares
      1  11e6
      2  11e6
      3  11e6		       00 a9	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
      4  11e6
    540  11e6
    541  11e6
    542  11e6		       c6 8b		      dec	ccur
      0  11e8					      CALL	setCursorColours
      1  11e8				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  11e8				  -FNAME      SETSTR	setCursorColours
      3  11e8				  -	      ECHO	""
      4  11e8				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  11e8				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  11e8				  -	      ERR
      7  11e8					      ENDIF
      8  11e8		       a9 8a		      lda	#BANK_setCursorColours
      9  11ea		       85 3f		      sta	SET_BANK
     10  11ec		       20 4a f8 	      jsr	setCursorColours
    544  11ef
    545  11ef		       c6 8a		      dec	mdelay
    546  11f1		       d0 1c		      bne	.exit
    547  11f3		       a9 01		      lda	#1
    548  11f5		       85 8a		      sta	mdelay	; once triggered, runs always
    549  11f7
    550  11f7		       a5 8e		      lda	aiMoveIndex
    551  11f9		       10 09		      bpl	.valid
    552  11fb
    553  11fb		       a9 89		      lda	#RAMBANK_PLY+1
    554  11fd		       85 3e		      sta	SET_BANK_RAM	;@2
      0  11ff					      lda@PLY	moveIndex
      1  11ff		       ad cf f9 	      lda	moveIndex
    556  1202		       85 8e		      sta	aiMoveIndex
    557  1204				   .valid
    558  1204
    559  1204		       20 5b f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    560  1207		       a5 8e		      lda	aiMoveIndex
    561  1209		       10 04		      bpl	.exit	; still drawing in this phase
    562  120b
      0  120b					      PHASE	SelectStartSquare
      1  120b		       a9 02		      lda	#AI_SelectStartSquare
      2  120d		       85 8c		      sta	aiState
    564  120f
    565  120f		       60	   .exit      rts
    566  1210
    567  1210
    568  1210							;---------------------------------------------------------------------------------------------------
    569  1210
    570  1210
      0  1210					      DEF	aiShowMoveCaptures
      1  1210				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  1210				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  1210				   aiShowMoveCaptures
      4  1210				   TEMPORARY_VAR SET	Overlay
      5  1210				   TEMPORARY_OFFSET SET	0
      6  1210				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  1210				   FUNCTION_NAME SET	aiShowMoveCaptures
    572  1210					      SUBROUTINE
    573  1210
      0  1210					      REF	AiStateMachine
      1  1210					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1210				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1210					      ENDIF
      0  1210					      VEND	aiShowMoveCaptures
      1  1210
      2  1210
      3  1210		       00 a9	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
      4  1210
    576  1210
    577  1210							; draw/undraw ALL captured pieces
    578  1210							; we should do this an even number of times so that pieces don't disappear
    579  1210
    580  1210		       c6 8b		      dec	ccur
      0  1212					      CALL	setCursorColours
      1  1212				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1212				  -FNAME      SETSTR	setCursorColours
      3  1212				  -	      ECHO	""
      4  1212				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1212				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1212				  -	      ERR
      7  1212					      ENDIF
      8  1212		       a9 8a		      lda	#BANK_setCursorColours
      9  1214		       85 3f		      sta	SET_BANK
     10  1216		       20 4a f8 	      jsr	setCursorColours
    582  1219
    583  1219		       c6 8a		      dec	mdelay	; flash speed UNVARYING despite draw happening
    584  121b
    585  121b		       a5 8e		      lda	aiMoveIndex
    586  121d		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    587  121f		       a9 89		      lda	#RAMBANK_PLY+1
    588  1221		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1223					      lda@PLY	moveIndex
      1  1223		       ad cf f9 	      lda	moveIndex
    590  1226		       85 8e		      sta	aiMoveIndex
    591  1228				   .valid
    592  1228
    593  1228							;lda #BANK_showMoveCaptures
    594  1228							;sta SET_BANK;@0
    595  1228
    596  1228		       20 ea f2 	      jsr	showMoveCaptures	;@0
    597  122b		       a5 8e		      lda	aiMoveIndex
    598  122d		       10 06		      bpl	.exit
    599  122f
    600  122f		       e6 8f		      inc	aiFlashPhase
    601  1231
      0  1231					      PHASE	SlowFlash
      1  1231		       a9 06		      lda	#AI_SlowFlash
      2  1233		       85 8c		      sta	aiState
    603  1235
    604  1235		       60	   .exit      rts
    605  1236
    606  1236
    607  1236							;---------------------------------------------------------------------------------------------------
    608  1236
      0  1236					      DEF	aiSlowFlash
      1  1236				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  1236				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  1236				   aiSlowFlash
      4  1236				   TEMPORARY_VAR SET	Overlay
      5  1236				   TEMPORARY_OFFSET SET	0
      6  1236				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  1236				   FUNCTION_NAME SET	aiSlowFlash
    610  1236					      SUBROUTINE
    611  1236
      0  1236					      REF	AiStateMachine
      1  1236					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1236				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1236					      ENDIF
      0  1236					      VEND	aiSlowFlash
      1  1236
      2  1236
      3  1236		       00 a9	   VAREND_aiSlowFlash =	TEMPORARY_VAR
      4  1236
    614  1236
    615  1236							; Joystick button is held down, so we're displaying the available moves
    616  1236							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    617  1236
    618  1236		       c6 8b		      dec	ccur
      0  1238					      CALL	setCursorColours
      1  1238				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1238				  -FNAME      SETSTR	setCursorColours
      3  1238				  -	      ECHO	""
      4  1238				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1238				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1238				  -	      ERR
      7  1238					      ENDIF
      8  1238		       a9 8a		      lda	#BANK_setCursorColours
      9  123a		       85 3f		      sta	SET_BANK
     10  123c		       20 4a f8 	      jsr	setCursorColours
    620  123f
    621  123f		       a5 8f		      lda	aiFlashPhase
    622  1241		       29 01		      and	#1
    623  1243		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    624  1245
    625  1245		       a5 4c		      lda	INPT4
    626  1247		       30 0d		      bmi	.butpress	; exit on button release
    627  1249
    628  1249				   .notEven
    629  1249
    630  1249							; Wait for delay to expire then back and flash 'em again
    631  1249
    632  1249		       c6 8a		      dec	mdelay
    633  124b		       10 08		      bpl	.slowWait
    634  124d
    635  124d		       a9 14		      lda	#CAP_SPEED
    636  124f		       85 8a		      sta	mdelay
    637  1251
      0  1251					      PHASE	ShowMoveCaptures	; go back and rEORdraw all captures again
      1  1251		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1253		       85 8c		      sta	aiState
    639  1255
    640  1255		       60	   .slowWait  rts
    641  1256
    642  1256
    643  1256		       a9 01	   .butpress  lda	#1
    644  1258		       85 8a		      sta	mdelay
    645  125a
      0  125a					      PHASE	UnDrawTargetSquares
      1  125a		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  125c		       85 8c		      sta	aiState
    647  125e		       60		      rts
    648  125f
    649  125f
    650  125f							;---------------------------------------------------------------------------------------------------
    651  125f
      0  125f					      DEF	aiSelectDestinationSquare
      1  125f				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  125f				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  125f				   aiSelectDestinationSquare
      4  125f				   TEMPORARY_VAR SET	Overlay
      5  125f				   TEMPORARY_OFFSET SET	0
      6  125f				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  125f				   FUNCTION_NAME SET	aiSelectDestinationSquare
    653  125f					      SUBROUTINE
    654  125f
      0  125f					      REF	Variable_PieceShapeBuffer
      1  125f					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  125f				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  125f					      ENDIF
      0  125f					      REF	AiStateMachine
      1  125f				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  125f				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  125f					      ENDIF
      0  125f					      VEND	aiSelectDestinationSquare
      1  125f
      2  125f
      3  125f		       00 ef	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
      4  125f
    658  125f
    659  125f							; Piece is selected and now we're looking for a button press on a destination square
    660  125f							; we flash the piece on-and-off while we're doing that
    661  125f							; Flash the selected piece
    662  125f
    663  125f		       ad 84 02 	      lda	INTIM
    664  1262		       c9 28		      cmp	#ONCEPERFRAME
    665  1264		       90 0e		      bcc	.exit
    666  1266
    667  1266
    668  1266		       c6 8d		      dec	aiFlashDelay
    669  1268		       d0 0a		      bne	.exit	; don't flash
    670  126a		       a9 14		      lda	#CAP_SPEED
    671  126c		       85 8d		      sta	aiFlashDelay
    672  126e
    673  126e		       e6 8f		      inc	aiFlashPhase
    674  1270
    675  1270							; WARNING - local variables will not survive the following call...!
    676  1270		       20 c8 f0 	      jsr	CopySinglePiece	;@0
    677  1273		       60		      rts
    678  1274
    679  1274				   .exit
      0  1274					      CALL	moveCursor	;@2
      1  1274				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  1274				  -FNAME      SETSTR	moveCursor
      3  1274				  -	      ECHO	""
      4  1274				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1274				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1274				  -	      ERR
      7  1274					      ENDIF
      8  1274		       a9 8a		      lda	#BANK_moveCursor
      9  1276		       85 3f		      sta	SET_BANK
     10  1278		       20 00 f8 	      jsr	moveCursor
    681  127b
    682  127b		       ad 84 02 	      lda	INTIM
    683  127e		       c9 14		      cmp	#20
    684  1280		       90 3d		      bcc	.noButton
    685  1282
    686  1282
    687  1282		       a4 89		      ldy	cursorX12
    688  1284		       84 87		      sty	toX12
    689  1286
      0  1286					      CALL	GetPiece	;@3
      1  1286				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1286				  -FNAME      SETSTR	GetPiece
      3  1286				  -	      ECHO	""
      4  1286				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1286				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1286				  -	      ERR
      7  1286					      ENDIF
      8  1286		       a9 d9		      lda	#BANK_GetPiece
      9  1288		       85 3f		      sta	SET_BANK
     10  128a		       20 01 fc 	      jsr	GetPiece
      0  128d					      CALL	setCursorColours
      1  128d				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  128d				  -FNAME      SETSTR	setCursorColours
      3  128d				  -	      ECHO	""
      4  128d				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  128d				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  128d				  -	      ERR
      7  128d					      ENDIF
      8  128d		       a9 8a		      lda	#BANK_setCursorColours
      9  128f		       85 3f		      sta	SET_BANK
     10  1291		       20 4a f8 	      jsr	setCursorColours
    692  1294
    693  1294
    694  1294							; y = valid square
    695  1294
    696  1294		       a5 4c		      lda	INPT4
    697  1296		       30 27		      bmi	.noButton
    698  1298
    699  1298		       a5 87		      lda	toX12
    700  129a		       c5 86		      cmp	fromX12
    701  129c		       f0 0d		      beq	.cancel
    702  129e
    703  129e		       c0 ff		      cpy	#-1
    704  12a0		       f0 1d		      beq	.noButton	; not a valid square
    705  12a2
    706  12a2		       a5 8f		      lda	aiFlashPhase
    707  12a4		       29 01		      and	#1
    708  12a6		       f0 13		      beq	.done
    709  12a8		       85 8d		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    710  12aa		       60		      rts
    711  12ab
    712  12ab				   .cancel
    713  12ab
    714  12ab		       a5 8f		      lda	aiFlashPhase
    715  12ad		       29 01		      and	#1
    716  12af		       f0 05		      beq	.doCancel
    717  12b1
    718  12b1							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    719  12b1
    720  12b1		       a9 01		      lda	#1
    721  12b3		       85 8d		      sta	aiFlashDelay
    722  12b5		       60		      rts
    723  12b6
    724  12b6
      0  12b6				   .doCancel  PHASE	ReselectDebounce
      1  12b6		       a9 0a		      lda	#AI_ReselectDebounce
      2  12b8		       85 8c		      sta	aiState
    726  12ba		       60		      rts
    727  12bb
      0  12bb				   .done      PHASE	Quiescent	; destination selected!
      1  12bb		       a9 09		      lda	#AI_Quiescent
      2  12bd		       85 8c		      sta	aiState
    729  12bf		       60	   .noButton  rts
    730  12c0
    731  12c0
    732  12c0
    733  12c0
    734  12c0
    735  12c0							;---------------------------------------------------------------------------------------------------
    736  12c0
      0  12c0					      DEF	aiRollPromotionPiece
      1  12c0				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  12c0				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  12c0				   aiRollPromotionPiece
      4  12c0				   TEMPORARY_VAR SET	Overlay
      5  12c0				   TEMPORARY_OFFSET SET	0
      6  12c0				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  12c0				   FUNCTION_NAME SET	aiRollPromotionPiece
    738  12c0					      SUBROUTINE
    739  12c0
      0  12c0					      REF	AiStateMachine
      1  12c0					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  12c0				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  12c0					      ENDIF
      0  12c0					      VEND	aiRollPromotionPiece
      1  12c0
      2  12c0
      3  12c0		       00 a9	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
      4  12c0
    742  12c0
    743  12c0							; Flash the '?' and wait for an UDLR move
    744  12c0
    745  12c0		       ad 84 02 	      lda	INTIM
    746  12c3		       c9 29		      cmp	#SPEEDOF_CopySinglePiece
    747  12c5		       90 2b		      bcc	.exit
    748  12c7
    749  12c7		       ad 80 02 	      lda	SWCHA
    750  12ca		       29 f0		      and	#$F0
    751  12cc		       c9 f0		      cmp	#$F0
    752  12ce		       f0 0a		      beq	.nojoy
    753  12d0
    754  12d0		       a9 00		      lda	#0
    755  12d2		       85 8d		      sta	aiFlashDelay
    756  12d4
    757  12d4		       a5 8f		      lda	aiFlashPhase
    758  12d6		       29 01		      and	#1
    759  12d8		       f0 19		      beq	.even
    760  12da
    761  12da		       a5 8d	   .nojoy     lda	aiFlashDelay
    762  12dc		       f0 03		      beq	.do
    763  12de		       c6 8d		      dec	aiFlashDelay
    764  12e0		       60		      rts
    765  12e1
    766  12e1				   .do
    767  12e1		       a9 1e		      lda	#30
    768  12e3		       85 8d		      sta	aiFlashDelay	; speed of "?" flashing
    769  12e5
    770  12e5
    771  12e5		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    772  12e7		       a5 96		      lda	sideToMove
    773  12e9		       10 02		      bpl	.wtm
    774  12eb		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    775  12ed				   .wtm
    776  12ed		       20 07 f7 	      jsr	showPromoteOptions	; draw the "?"
    777  12f0
    778  12f0		       e6 8f		      inc	aiFlashPhase
    779  12f2
    780  12f2		       60	   .exit      rts
    781  12f3
    782  12f3
    783  12f3		       a9 03	   .even      lda	#3	; QUEEN
    784  12f5		       85 97		      sta	fromPiece	; cycles as index to NBRQ
    785  12f7
    786  12f7							;inc aiFlashPhase
    787  12f7
    788  12f7		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    789  12f9		       a5 96		      lda	sideToMove
    790  12fb		       10 02		      bpl	.blackStuff
    791  12fd		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    792  12ff				   .blackStuff
    793  12ff
    794  12ff		       20 07 f7 	      jsr	showPromoteOptions	; draw the initial Q
    795  1302
      0  1302					      PHASE	ChooseDebounce
      1  1302		       a9 22		      lda	#AI_ChooseDebounce
      2  1304		       85 8c		      sta	aiState
    797  1306		       60		      rts
    798  1307
    799  1307
    800  1307							;---------------------------------------------------------------------------------------------------
    801  1307
      0  1307					      DEF	showPromoteOptions
      1  1307				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  1307				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  1307				   showPromoteOptions
      4  1307				   TEMPORARY_VAR SET	Overlay
      5  1307				   TEMPORARY_OFFSET SET	0
      6  1307				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  1307				   FUNCTION_NAME SET	showPromoteOptions
    803  1307					      SUBROUTINE
    804  1307
      0  1307					      REF	aiRollPromotionPiece	;✅
      1  1307					      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  1307				   TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  1307					      ENDIF
      0  1307					      REF	aiChoosePromotePiece	;✅
      1  1307					      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  1307				   TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  1307					      ENDIF
      0  1307					      VEND	showPromoteOptions
      1  1307
      2  1307
      3  1307		       00 ef	   VAREND_showPromoteOptions =	TEMPORARY_VAR
      4  1307
    808  1307
    809  1307							; X = character shape # (?/N/B/R/Q)
    810  1307
    811  1307		       a4 87		      ldy	toX12
    812  1309		       84 81		      sty	squareToDraw
    813  130b
    814  130b		       8a		      txa
    815  130c		       a8		      tay
    816  130d
    817  130d		       20 b2 f5 	      jsr	CopySetupForMarker	;@this
    818  1310		       4c cf f0 	      jmp	InterceptMarkerCopy	;@0
    819  1313
    820  1313
    821  1313							;---------------------------------------------------------------------------------------------------
    822  1313
      0  1313					      DEF	aiChoosePromotePiece
      1  1313				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  1313				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  1313				   aiChoosePromotePiece
      4  1313				   TEMPORARY_VAR SET	Overlay
      5  1313				   TEMPORARY_OFFSET SET	0
      6  1313				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  1313				   FUNCTION_NAME SET	aiChoosePromotePiece
    824  1313					      SUBROUTINE
    825  1313
      0  1313					      REF	Variable_PieceShapeBuffer
      1  1313					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1313				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1313					      ENDIF
      0  1313					      REF	AiStateMachine
      1  1313				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1313				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1313					      ENDIF
      0  1313					      VEND	aiChoosePromotePiece
      1  1313
      2  1313
      3  1313		       00 ef	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
      4  1313
    829  1313
    830  1313							; Question-mark phase has exited via joystick direction
    831  1313							; Now we cycle through the selectable pieces
    832  1313
    833  1313		       ad 84 02 	      lda	INTIM
    834  1316		       c9 29		      cmp	#SPEEDOF_CopySinglePiece
    835  1318		       90 4e		      bcc	.exit
    836  131a
    837  131a		       a5 4c		      lda	INPT4
    838  131c		       30 0a		      bmi	.nobut	; no press
    839  131e
    840  131e							; button pressed but make sure phase is correct for exit
    841  131e
    842  131e		       a9 01		      lda	#1
    843  1320		       85 8d		      sta	aiFlashDelay	; force quick rehash to this if phase incorrect
    844  1322
    845  1322		       a5 8f		      lda	aiFlashPhase
    846  1324		       29 01		      and	#1
    847  1326		       f0 41		      beq	.chosen	; button pressed --> selection made
    848  1328				   .nobut
    849  1328
    850  1328		       ad 80 02 	      lda	SWCHA
    851  132b		       29 f0		      and	#$F0
    852  132d		       c9 f0		      cmp	#$F0
    853  132f		       f0 04		      beq	.nodir	; no direction pressed
    854  1331
    855  1331
    856  1331		       a9 01		      lda	#1
    857  1333		       85 8d		      sta	aiFlashDelay
    858  1335
    859  1335
    860  1335		       c6 8d	   .nodir     dec	aiFlashDelay
    861  1337		       d0 2f		      bne	.exit
    862  1339
    863  1339		       a9 1e		      lda	#30
    864  133b		       85 8d		      sta	aiFlashDelay
    865  133d
    866  133d		       a5 8f		      lda	aiFlashPhase
    867  133f		       4a		      lsr
    868  1340		       b0 1c		      bcs	.odd	; must wait until piece undrawn
    869  1342
    870  1342		       ad 80 02 	      lda	SWCHA
    871  1345		       29 f0		      and	#$F0
    872  1347		       c9 f0		      cmp	#$F0
    873  1349		       f0 13		      beq	.odd	; no direction pressed
    874  134b
    875  134b		       4a		      lsr
    876  134c		       4a		      lsr
    877  134d		       4a		      lsr
    878  134e		       4a		      lsr
    879  134f		       a8		      tay
    880  1350
    881  1350
    882  1350							; cycle to the next promotable piece (N/B/R/Q)
    883  1350							; TODO; use joy table for mod instead of just incrementing all the time
    884  1350
    885  1350		       18		      clc
    886  1351		       a5 97		      lda	fromPiece
    887  1353		       79 65 f8 	      adc	JoyCombined,y
    888  1356		       29 03		      and	#3
    889  1358		       85 97		      sta	fromPiece
    890  135a
      0  135a					      PHASE	ChooseDebounce	; after draw, wait for release
      1  135a		       a9 22		      lda	#AI_ChooseDebounce
      2  135c		       85 8c		      sta	aiState
    892  135e
    893  135e				   .odd
    894  135e
    895  135e				   .force
    896  135e		       e6 8f		      inc	aiFlashPhase	; on/off toggle
    897  1360
    898  1360		       a4 97		      ldy	fromPiece
    899  1362		       be 88 f7 	      ldx	promotePiece,y
    900  1365		       20 07 f7 	      jsr	showPromoteOptions	;@this
    901  1368
    902  1368		       60	   .exit      rts
    903  1369
    904  1369
    905  1369
    906  1369
    907  1369
    908  1369
    909  1369				   .chosen
    910  1369		       a5 97		      lda	fromPiece
    911  136b		       29 07		      and	#PIECE_MASK
    912  136d		       aa		      tax
    913  136e
    914  136e		       bd 8c f7 	      lda	promoteType,x
    915  1371		       85 97		      sta	fromPiece
    916  1373
    917  1373		       a4 87		      ldy	toX12
    918  1375		       a9 e3		      lda	#RAMBANK_BOARD
    919  1377		       85 3e		      sta	SET_BANK_RAM	;@3
    920  1379		       b9 79 fc 	      lda	Board,y
    921  137c		       29 07		      and	#PIECE_MASK
    922  137e		       f0 03		      beq	.nothing
    923  1380
    924  1380		       20 c8 f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
    925  1383
      0  1383				   .nothing   PHASE	MoveIsSelected
      1  1383		       a9 14		      lda	#AI_MoveIsSelected
      2  1385		       85 8c		      sta	aiState
    927  1387		       60		      rts
    928  1388
      0  1388					      ALLOCATE	promotePiece, 4
      1  1388
      2  1388				   .NAME      SETSTR	promotePiece
      0  1388					      OPTIONAL_PAGEBREAK	.NAME, 4
      1  1388
      2  1388				  -	      IF	(>( * + 4 -1 )) > ( >* )
      3  1388				  -.EARLY_LOCATION SET	*
      4  1388				  -	      ALIGN	256
      5  1388				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  1388					      ENDIF
      0  1388					      DEF	promotePiece
      1  1388				   SLOT_promotePiece SET	_BANK_SLOT
      2  1388				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  1388				   promotePiece
      4  1388				   TEMPORARY_VAR SET	Overlay
      5  1388				   TEMPORARY_OFFSET SET	0
      6  1388				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  1388				   FUNCTION_NAME SET	promotePiece
      5  1388
    930  1388		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    931  1389		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    932  138a		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    933  138b		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    934  138c
      0  138c					      ALLOCATE	promoteType,4
      1  138c
      2  138c				   .NAME      SETSTR	promoteType
      0  138c					      OPTIONAL_PAGEBREAK	.NAME, 4
      1  138c
      2  138c				  -	      IF	(>( * + 4 -1 )) > ( >* )
      3  138c				  -.EARLY_LOCATION SET	*
      4  138c				  -	      ALIGN	256
      5  138c				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  138c					      ENDIF
      0  138c					      DEF	promoteType
      1  138c				   SLOT_promoteType SET	_BANK_SLOT
      2  138c				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  138c				   promoteType
      4  138c				   TEMPORARY_VAR SET	Overlay
      5  138c				   TEMPORARY_OFFSET SET	0
      6  138c				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  138c				   FUNCTION_NAME SET	promoteType
      5  138c
    936  138c		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    937  1390
    938  1390
    939  1390							;---------------------------------------------------------------------------------------------------
    940  1390
      0  1390					      DEF	aiMarchA2
      1  1390				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  1390				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  1390				   aiMarchA2
      4  1390				   TEMPORARY_VAR SET	Overlay
      5  1390				   TEMPORARY_OFFSET SET	0
      6  1390				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  1390				   FUNCTION_NAME SET	aiMarchA2
    942  1390					      SUBROUTINE
    943  1390
      0  1390					      REF	Variable_PieceShapeBuffer
      1  1390					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1390				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1390					      ENDIF
      0  1390					      REF	AiStateMachine
      1  1390				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1390				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1390					      ENDIF
      0  1390					      VEND	aiMarchA2
      1  1390
      2  1390
      3  1390		       00 ef	   VAREND_aiMarchA2 =	TEMPORARY_VAR
      4  1390
    947  1390
    948  1390							; erase object in new sqare --> blank
    949  1390
    950  1390		       a4 86		      ldy	fromX12
    951  1392		       84 81		      sty	squareToDraw
    952  1394
    953  1394		       a9 e3		      lda	#RAMBANK_BOARD
    954  1396		       85 3e		      sta	SET_BANK_RAM	;@3
    955  1398		       b9 79 fc 	      lda	Board,y
    956  139b		       f0 03		      beq	.skipbl
    957  139d
    958  139d							; WARNING - local variables will not survive the following call...!
    959  139d		       20 c8 f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    960  13a0
    961  13a0				   .skipbl
    962  13a0		       a4 86		      ldy	fromX12
    963  13a2		       84 aa		      sty	__boardIndex
    964  13a4
    965  13a4		       a9 e3		      lda	#RAMBANK_BOARD
    966  13a6		       85 3e		      sta	SET_BANK_RAM	;@3
    967  13a8		       b9 79 fc 	      lda	Board,y
    968  13ab		       85 98		      sta	lastPiece	; what we are overwriting
    969  13ad		       a5 97		      lda	fromPiece
    970  13af		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    971  13b1		       29 df		      and	#~FLAG_ENPASSANT
    972  13b3		       a4 aa		      ldy	__boardIndex
      0  13b5					      sta@RAM	Board,y	; and what's actually moving there
      1  13b5		       99 79 fe 	      sta	[RAM]+Board,y
    974  13b8
    975  13b8
      0  13b8					      PHASE	MarchB
      1  13b8		       a9 18		      lda	#AI_MarchB
      2  13ba		       85 8c		      sta	aiState
    977  13bc		       60		      rts
    978  13bd
    979  13bd
    980  13bd							;---------------------------------------------------------------------------------------------------
    981  13bd
      0  13bd					      DEF	aiMarchB2
      1  13bd				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  13bd				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  13bd				   aiMarchB2
      4  13bd				   TEMPORARY_VAR SET	Overlay
      5  13bd				   TEMPORARY_OFFSET SET	0
      6  13bd				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  13bd				   FUNCTION_NAME SET	aiMarchB2
    983  13bd					      SUBROUTINE
    984  13bd
      0  13bd					      REF	Variable_PieceShapeBuffer
      1  13bd					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  13bd				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  13bd					      ENDIF
      0  13bd					      REF	AiStateMachine
      1  13bd				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  13bd				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  13bd					      ENDIF
      0  13bd					      VEND	aiMarchB2
      1  13bd
      2  13bd
      3  13bd		       00 ef	   VAREND_aiMarchB2 =	TEMPORARY_VAR
      4  13bd
    988  13bd
    989  13bd		       a4 84		      ldy	lastSquareX12
    990  13bf		       84 81		      sty	squareToDraw
    991  13c1
    992  13c1		       a9 e3		      lda	#RAMBANK_BOARD
    993  13c3		       85 3e		      sta	SET_BANK_RAM	;@3
    994  13c5		       b9 79 fc 	      lda	Board,y
    995  13c8		       f0 03		      beq	.skipbl2
    996  13ca
    997  13ca							; WARNING - local variables will not survive the following call...!
    998  13ca		       20 c8 f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    999  13cd				   .skipbl2
   1000  13cd
   1001  13cd		       a5 86		      lda	fromX12
   1002  13cf		       c5 87		      cmp	toX12
   1003  13d1		       f0 09		      beq	xhalt
   1004  13d3
   1005  13d3		       a9 02		      lda	#2	;??? inter-move segment speed (can be 0)
   1006  13d5		       85 83		      sta	drawDelay
      0  13d7					      PHASE	MarchToTargetA
      1  13d7		       a9 16		      lda	#AI_MarchToTargetA
      2  13d9		       85 8c		      sta	aiState
   1008  13db
   1009  13db		       60		      rts
   1010  13dc
      0  13dc				   xhalt      PHASE	EPHandler
      1  13dc		       a9 29		      lda	#AI_EPHandler
      2  13de		       85 8c		      sta	aiState
   1012  13e0		       60		      rts
   1013  13e1
   1014  13e1
   1015  13e1
   1016  13e1
   1017  13e1							;---------------------------------------------------------------------------------------------------
   1018  13e1
      0  13e1					      END_BANK
      1  13e1				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  13e1				  -	      CHECK_RAM_BANK_SIZE
      3  13e1					      ELSE
      0  13e1					      CHECK_BANK_SIZE
      1  13e1		       03 e1	   .TEMP      =	* - _BANK_START
 ROM bank # 5 STATEMACHINE size = $3e1 free = 30
      2  13e1					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  13e1				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  13e1				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  13e1				  -	      ERR
      6  13e1					      ENDIF
      5  13e1					      ENDIF
   1020  13e1
   1021  13e1							;---------------------------------------------------------------------------------------------------
   1022  13e1							; EOF
------- FILE ./chess.asm
------- FILE @1 STATE MACHINE #2.asm LEVEL 2 PASS 4
      0  13e1					      include	"@1 STATE MACHINE #2.asm"
      1  13e1							;---------------------------------------------------------------------------------------------------
      2  13e1							; @1 STATE MACHINE #2.asm
      3  13e1
      4  13e1							; Atari 2600 Chess
      5  13e1							; Copyright (c) 2019-2020 Andrew Davie
      6  13e1							; andrew@taswegian.com
      7  13e1
      8  13e1
      9  13e1							;---------------------------------------------------------------------------------------------------
     10  13e1
      0  13e1					      SLOT	1
      1  13e1
      2  13e1				  -	      IF	(1 < 0) || (1 > 3)
      3  13e1				  -	      ECHO	"Illegal bank address/segment location", 1
      4  13e1				  -	      ERR
      5  13e1					      ENDIF
      6  13e1
      7  13e1				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  13e1				   _BANK_SLOT SET	1 * 64
      9  13e1
      0  13e1					      ROMBANK	STATEMACHINE2
      1  1630 ????				      SEG	ROM_STATEMACHINE2
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   STATEMACHINE2_START SET	*
      6  1400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1400				   ROMBANK_STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1400				   _LAST_BANK SETSTR	STATEMACHINE2
     10  1400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1400
     14  1400
     15  1400							;---------------------------------------------------------------------------------------------------
     16  1400
      0  1400					      DEF	aiChooseDebounce
      1  1400				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  1400				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  1400				   aiChooseDebounce
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	aiChooseDebounce
     18  1400					      SUBROUTINE
     19  1400
      0  1400					      REF	AiStateMachine
      1  1400					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1400				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1400					      ENDIF
      0  1400					      VEND	aiChooseDebounce
      1  1400
      2  1400
      3  1400		       00 a9	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
      4  1400
     22  1400
     23  1400							; We've changed promotion piece, and drawn it
     24  1400							; wait for joystick to be released before continuing
     25  1400
     26  1400		       ad 80 02 	      lda	SWCHA
     27  1403		       29 f0		      and	#$F0
     28  1405		       c9 f0		      cmp	#$F0
     29  1407		       d0 0a		      bne	.exit	; wait while joystick still pressed
     30  1409
     31  1409		       a9 01		      lda	#1
     32  140b		       85 8d		      sta	aiFlashDelay
     33  140d		       85 8f		      sta	aiFlashPhase
     34  140f
      0  140f					      PHASE	ChoosePromotePiece
      1  140f		       a9 21		      lda	#AI_ChoosePromotePiece
      2  1411		       85 8c		      sta	aiState
     36  1413		       60	   .exit      rts
     37  1414
     38  1414
     39  1414							;---------------------------------------------------------------------------------------------------
     40  1414
      0  1414					      DEF	aiReselectDebounce
      1  1414				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  1414				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  1414				   aiReselectDebounce
      4  1414				   TEMPORARY_VAR SET	Overlay
      5  1414				   TEMPORARY_OFFSET SET	0
      6  1414				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  1414				   FUNCTION_NAME SET	aiReselectDebounce
     42  1414					      SUBROUTINE
     43  1414
      0  1414					      REF	AiStateMachine
      1  1414					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1414				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1414					      ENDIF
      0  1414					      VEND	aiReselectDebounce
      1  1414
      2  1414
      3  1414		       00 a9	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
      4  1414
     46  1414
     47  1414							; We've just cancelled the move. Wait for the button to be released
     48  1414							; and then go back to selecting a piece to move
     49  1414
     50  1414		       a5 4c		      lda	INPT4
     51  1416		       10 04		      bpl	.exit	; button still pressed, so wait
     52  1418
      0  1418					      PHASE	SelectStartSquare
      1  1418		       a9 02		      lda	#AI_SelectStartSquare
      2  141a		       85 8c		      sta	aiState
     54  141c		       60	   .exit      rts
     55  141d
     56  141d
     57  141d							;---------------------------------------------------------------------------------------------------
     58  141d
      0  141d					      DEF	aiDelayAfterMove
      1  141d				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  141d				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  141d				   aiDelayAfterMove
      4  141d				   TEMPORARY_VAR SET	Overlay
      5  141d				   TEMPORARY_OFFSET SET	0
      6  141d				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  141d				   FUNCTION_NAME SET	aiDelayAfterMove
     60  141d					      SUBROUTINE
     61  141d
      0  141d					      REF	AiStateMachine
      1  141d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  141d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  141d					      ENDIF
      0  141d					      VEND	aiDelayAfterMove
      1  141d
      2  141d
      3  141d		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
      4  141d
     64  141d
     65  141d		       a9 32		      lda	#50
     66  141f		       85 8d		      sta	aiFlashDelay
      0  1421					      PHASE	DelayAfterMove2
      1  1421		       a9 26		      lda	#AI_DelayAfterMove2
      2  1423		       85 8c		      sta	aiState
     68  1425		       60	   .exit      rts
     69  1426
     70  1426
     71  1426							;---------------------------------------------------------------------------------------------------
     72  1426
      0  1426					      DEF	aiDelayAfterMove2
      1  1426				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  1426				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  1426				   aiDelayAfterMove2
      4  1426				   TEMPORARY_VAR SET	Overlay
      5  1426				   TEMPORARY_OFFSET SET	0
      6  1426				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  1426				   FUNCTION_NAME SET	aiDelayAfterMove2
     74  1426					      SUBROUTINE
     75  1426
      0  1426					      REF	AiStateMachine
      1  1426					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1426				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1426					      ENDIF
      0  1426					      VEND	aiDelayAfterMove
      1  1426
      2  1426
      3  1426		       00 a9	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
      4  1426
     78  1426
     79  1426		       c6 8d		      dec	aiFlashDelay
     80  1428		       d0 04		      bne	.exit
      0  142a					      PHASE	MoveIsSelected
      1  142a		       a9 14		      lda	#AI_MoveIsSelected
      2  142c		       85 8c		      sta	aiState
     82  142e		       60	   .exit      rts
     83  142f
     84  142f
     85  142f							;---------------------------------------------------------------------------------------------------
     86  142f
      0  142f					      DEF	aiDelayAfterPlaced
      1  142f				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  142f				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  142f				   aiDelayAfterPlaced
      4  142f				   TEMPORARY_VAR SET	Overlay
      5  142f				   TEMPORARY_OFFSET SET	0
      6  142f				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  142f				   FUNCTION_NAME SET	aiDelayAfterPlaced
     88  142f					      SUBROUTINE
     89  142f
      0  142f					      REF	AiStateMachine
      1  142f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  142f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  142f					      ENDIF
      0  142f					      VEND	aiDelayAfterPlaced
      1  142f
      2  142f
      3  142f		       00 a9	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
      4  142f
     92  142f
     93  142f		       a2 4b		      ldx	#75	; delay after human move
     94  1431		       a5 96		      lda	sideToMove
     95  1433		       0a		      asl
     96  1434		       30 02		      bmi	.human
     97  1436		       a2 01		      ldx	#1	; delay after computer move
     98  1438		       86 8d	   .human     stx	aiFlashDelay
     99  143a
      0  143a					      PHASE	DelayAfterPlaced2
      1  143a		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  143c		       85 8c		      sta	aiState
    101  143e		       60		      rts
    102  143f
    103  143f
    104  143f							;---------------------------------------------------------------------------------------------------
    105  143f
      0  143f					      DEF	aiDelayAfterPlaced2
      1  143f				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  143f				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  143f				   aiDelayAfterPlaced2
      4  143f				   TEMPORARY_VAR SET	Overlay
      5  143f				   TEMPORARY_OFFSET SET	0
      6  143f				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  143f				   FUNCTION_NAME SET	aiDelayAfterPlaced2
    107  143f					      SUBROUTINE
    108  143f
      0  143f					      REF	AiStateMachine
      1  143f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  143f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  143f					      ENDIF
      0  143f					      VEND	aiDelayAfterPlaced2
      1  143f
      2  143f
      3  143f		       00 a9	   VAREND_aiDelayAfterPlaced2 =	TEMPORARY_VAR
      4  143f
    111  143f
    112  143f
    113  143f		       ad 82 02 	      lda	SWCHB
    114  1442		       29 02		      and	#SELECT_SWITCH
    115  1444		       d0 05		      bne	.noSwapside
    116  1446
      0  1446					      PHASE	DebounceSelect
      1  1446		       a9 2b		      lda	#AI_DebounceSelect
      2  1448		       85 8c		      sta	aiState
    118  144a		       60		      rts
    119  144b				   .noSwapside
    120  144b
    121  144b
    122  144b		       c6 8d		      dec	aiFlashDelay
    123  144d		       d0 04		      bne	.exit
    124  144f
    125  144f							;SWAP
    126  144f
      0  144f					      PHASE	GenerateMoves
      1  144f		       a9 12		      lda	#AI_GenerateMoves
      2  1451		       85 8c		      sta	aiState
    128  1453		       60	   .exit      rts
    129  1454
    130  1454
    131  1454							;---------------------------------------------------------------------------------------------------
    132  1454
      0  1454					      DEF	aiMarchToTargetB
      1  1454				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  1454				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  1454				   aiMarchToTargetB
      4  1454				   TEMPORARY_VAR SET	Overlay
      5  1454				   TEMPORARY_OFFSET SET	0
      6  1454				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  1454				   FUNCTION_NAME SET	aiMarchToTargetB
    134  1454					      SUBROUTINE
    135  1454
      0  1454					      REF	Variable_PieceShapeBuffer
      1  1454					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1454				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1454					      ENDIF
      0  1454					      REF	AiStateMachine
      1  1454				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1454				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1454					      ENDIF
      0  1454					      VEND	aiMarchToTargetB
      1  1454
      2  1454
      3  1454		       00 ef	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
      4  1454
    139  1454
    140  1454							; now we want to undraw the piece in the old square
    141  1454
    142  1454		       a5 83		      lda	drawDelay
    143  1456		       f0 03		      beq	.stepOne
    144  1458		       c6 83		      dec	drawDelay
    145  145a		       60		      rts
    146  145b
    147  145b				   .stepOne
    148  145b		       a5 84		      lda	lastSquareX12
    149  145d		       85 81		      sta	squareToDraw
    150  145f
    151  145f							; WARNING - local variables will not survive the following call...!
    152  145f		       20 c8 f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    153  1462
    154  1462		       a4 84		      ldy	lastSquareX12
    155  1464		       a5 99		      lda	previousPiece
    156  1466
    157  1466		       a2 e3		      ldx	#RAMBANK_BOARD
    158  1468		       86 3e		      stx	SET_BANK_RAM	;@3
      0  146a					      sta@RAM	Board,y	; and what's actually moving there
      1  146a		       99 79 fe 	      sta	[RAM]+Board,y
    160  146d
    161  146d		       a5 98		      lda	lastPiece
    162  146f		       85 99		      sta	previousPiece
    163  1471
      0  1471					      PHASE	MarchB2
      1  1471		       a9 1a		      lda	#AI_MarchB2
      2  1473		       85 8c		      sta	aiState
    165  1475		       60		      rts
    166  1476
    167  1476
    168  1476							;---------------------------------------------------------------------------------------------------
    169  1476
      0  1476					      DEF	aiPromotePawnStart
      1  1476				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  1476				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  1476				   aiPromotePawnStart
      4  1476				   TEMPORARY_VAR SET	Overlay
      5  1476				   TEMPORARY_OFFSET SET	0
      6  1476				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  1476				   FUNCTION_NAME SET	aiPromotePawnStart
    171  1476					      SUBROUTINE
    172  1476
      0  1476					      REF	Variable_PieceShapeBuffer
      1  1476					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1476				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1476					      ENDIF
      0  1476					      REF	AiStateMachine
      1  1476				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1476				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1476					      ENDIF
      0  1476					      VEND	aiPromotePawnStart
      1  1476
      2  1476
      3  1476		       00 ef	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
      4  1476
    176  1476
    177  1476
    178  1476		       ad 84 02 	      lda	INTIM
    179  1479		       c9 29		      cmp	#SPEEDOF_CopySinglePiece
    180  147b		       90 1c		      bcc	.exit
    181  147d
    182  147d		       a9 00		      lda	#0
    183  147f		       85 8f		      sta	aiFlashPhase
    184  1481		       85 8d		      sta	aiFlashDelay
    185  1483
    186  1483		       a4 87		      ldy	toX12
    187  1485		       84 81		      sty	squareToDraw
    188  1487
    189  1487		       a9 e3		      lda	#RAMBANK_BOARD
    190  1489		       85 3e		      sta	SET_BANK_RAM	;@3
    191  148b		       b9 79 fc 	      lda	Board,y
    192  148e		       29 07		      and	#PIECE_MASK
    193  1490		       f0 03		      beq	.empty
    194  1492
    195  1492							; WARNING - local variables will not survive the following call...!
    196  1492		       20 c8 f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    197  1495
      0  1495				   .empty     PHASE	RollPromotionPiece
      1  1495		       a9 20		      lda	#AI_RollPromotionPiece
      2  1497		       85 8c		      sta	aiState
    199  1499		       60	   .exit      rts
    200  149a
    201  149a
    202  149a							;---------------------------------------------------------------------------------------------------
    203  149a
      0  149a					      DEF	aiGenerateMoves
      1  149a				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  149a				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  149a				   aiGenerateMoves
      4  149a				   TEMPORARY_VAR SET	Overlay
      5  149a				   TEMPORARY_OFFSET SET	0
      6  149a				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  149a				   FUNCTION_NAME SET	aiGenerateMoves
    205  149a					      SUBROUTINE
    206  149a
      0  149a					      REF	AiStateMachine
      1  149a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  149a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  149a					      ENDIF
      0  149a					      VEND	aiGenerateMoves
      1  149a
      2  149a
      3  149a		       00 a9	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
      4  149a
    209  149a
    210  149a							;	      CALL Breaker
    211  149a
    212  149a		       a5 87		      lda	toX12
    213  149c		       85 81		      sta	squareToDraw	; for showing move (display square)
    214  149e
    215  149e		       a5 96		      lda	sideToMove
    216  14a0		       0a		      asl
    217  14a1		       30 17		      bmi	.player
    218  14a3
    219  14a3		       a5 82		      lda	rnd
    220  14a5		       29 07		      and	#7
    221  14a7		       a9 05		      lda	#5
    222  14a9		       0a		      asl
    223  14aa		       aa		      tax
    224  14ab
    225  14ab		       bd bf f4 	      lda	speakRandom,x
    226  14ae		       85 9a		      sta	speech_addr
    227  14b0		       bd c0 f4 	      lda	speakRandom+1,x
    228  14b3		       85 9b		      sta	speech_addr+1
    229  14b5
    230  14b5
    231  14b5							;		      SPEAK SAY_you_are_a_loser ;computer_moved
    232  14b5
      0  14b5				   .computer  PHASE	ComputerMove	; computer select move
      1  14b5		       a9 13		      lda	#AI_ComputerMove
      2  14b7		       85 8c		      sta	aiState
    234  14b9		       60		      rts
    235  14ba
    236  14ba
      0  14ba				   .player    PHASE	StartMoveGen
      1  14ba		       a9 0b		      lda	#AI_StartMoveGen
      2  14bc		       85 8c		      sta	aiState
    238  14be		       60		      rts
    239  14bf
    240  14bf
    241  14bf
    242  14bf				   speakRandom
    243  14bf
    244  14bf		       e6 f9		      .word.w	SAY_you_are_a_loser
    245  14c1		       b6 f9		      .word.w	SAY_hi_mum
    246  14c3		       54 f9		      .word.w	SAY_noCPU
    247  14c5		       8b f9		      .word.w	SAY_NQB3
    248  14c7		       35 f9		      .word.w	SAY_mistake
    249  14c9		       08 f9		      .word.w	SAY_feet
    250  14cb		       f3 f8		      .word.w	SAY_atari
    251  14cd		       dc f8		      .word.w	SAY_blindfold
    252  14cf
    253  14cf
    254  14cf
    255  14cf							;---------------------------------------------------------------------------------------------------
    256  14cf
      0  14cf					      DEF	aiStepMoveGen
      1  14cf				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  14cf				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  14cf				   aiStepMoveGen
      4  14cf				   TEMPORARY_VAR SET	Overlay
      5  14cf				   TEMPORARY_OFFSET SET	0
      6  14cf				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  14cf				   FUNCTION_NAME SET	aiStepMoveGen
    258  14cf					      SUBROUTINE
    259  14cf
      0  14cf					      REF	AiStateMachine
      1  14cf					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  14cf				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  14cf					      ENDIF
      0  14cf					      VEND	aiStepMoveGen
      1  14cf
      2  14cf
      3  14cf		       00 a9	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
      4  14cf
    262  14cf
    263  14cf		       a5 88		      lda	originX12	; location of cursor (show move)
    264  14d1		       85 89		      sta	cursorX12
      0  14d3					      PHASE	BeginSelectMovePhase
      1  14d3		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  14d5		       85 8c		      sta	aiState
    266  14d7		       60		      rts
    267  14d8
    268  14d8
    269  14d8							;---------------------------------------------------------------------------------------------------
    270  14d8
    271  1500		       00 00 00 00*	      align	256	; TODO?
    272  1500
    273  1500
      0  1500					      DEF	PositionSprites
      1  1500				   SLOT_PositionSprites SET	_BANK_SLOT
      2  1500				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  1500				   PositionSprites
      4  1500				   TEMPORARY_VAR SET	Overlay
      5  1500				   TEMPORARY_OFFSET SET	0
      6  1500				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  1500				   FUNCTION_NAME SET	PositionSprites
    275  1500					      SUBROUTINE
    276  1500
      0  1500					      REF	StartupBankReset
      1  1500				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1500				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1500					      ENDIF
      0  1500					      VEND	PositionSprites
      1  1500
      2  1500
      3  1500		       00 a7	   VAREND_PositionSprites =	TEMPORARY_VAR
      4  1500
    279  1500
    280  1500
    281  1500		       a5 89		      lda	cursorX12
    282  1502		       38		      sec
    283  1503		       e9 0a	   .sub10     sbc	#10
    284  1505		       b0 fc		      bcs	.sub10
    285  1507		       69 08		      adc	#8
    286  1509		       a8		      tay
    287  150a
    288  150a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
    289  150c
    290  150c		       b9 30 f5 	      lda	colToPixel,y
    291  150f
    292  150f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    293  1510		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    294  1512		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    295  1514
    296  1514		       a8		      tay
    297  1515		       b9 30 f4 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    298  1518		       85 60		      sta	HMP0
    299  151a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    300  151c
    301  151c		       85 42		      sta	WSYNC
    302  151e		       85 6a		      sta	HMOVE
    303  1520
    304  1520		       60		      rts
    305  1521
    306  1521							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    307  1521							; fine adjustment value. This table is on a page boundary to guarantee the processor
    308  1521							; will cross a page boundary and waste a cycle in order to be at the precise position
    309  1521							; for a RESP0,x write
    310  1521
    311  1521				   fineAdjustBegin
    312  1521
    313  1521		       70		      DC.B	%01110000	; Left 7
    314  1522		       60		      DC.B	%01100000	; Left 6
    315  1523		       50		      DC.B	%01010000	; Left 5
    316  1524		       40		      DC.B	%01000000	; Left 4
    317  1525		       30		      DC.B	%00110000	; Left 3
    318  1526		       20		      DC.B	%00100000	; Left 2
    319  1527		       10		      DC.B	%00010000	; Left 1
    320  1528		       00		      DC.B	%00000000	; No movement.
    321  1529		       f0		      DC.B	%11110000	; Right 1
    322  152a		       e0		      DC.B	%11100000	; Right 2
    323  152b		       d0		      DC.B	%11010000	; Right 3
    324  152c		       c0		      DC.B	%11000000	; Right 4
    325  152d		       b0		      DC.B	%10110000	; Right 5
    326  152e		       a0		      DC.B	%10100000	; Right 6
    327  152f		       90		      DC.B	%10010000	; Right 7
    328  1530
    329  1530		       f4 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    330  1530
    331  1530
      0  1530					      ALLOCATE	colToPixel, 8
      1  1530
      2  1530				   .NAME      SETSTR	colToPixel
      0  1530					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  1530
      2  1530				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  1530				  -.EARLY_LOCATION SET	*
      4  1530				  -	      ALIGN	256
      5  1530				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  1530					      ENDIF
      0  1530					      DEF	colToPixel
      1  1530				   SLOT_colToPixel SET	_BANK_SLOT
      2  1530				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  1530				   colToPixel
      4  1530				   TEMPORARY_VAR SET	Overlay
      5  1530				   TEMPORARY_OFFSET SET	0
      6  1530				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  1530				   FUNCTION_NAME SET	colToPixel
      5  1530
    333  1530		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    334  1538
    335  1538
    336  1538							;---------------------------------------------------------------------------------------------------
    337  1538
      0  1538					      DEF	aiMarchToTargetA
      1  1538				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  1538				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  1538				   aiMarchToTargetA
      4  1538				   TEMPORARY_VAR SET	Overlay
      5  1538				   TEMPORARY_OFFSET SET	0
      6  1538				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  1538				   FUNCTION_NAME SET	aiMarchToTargetA
    339  1538					      SUBROUTINE
    340  1538
      0  1538					      REF	AiStateMachine
      1  1538					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1538					      ENDIF
    342  1538
      0  1538					      VAR	__fromRow, 1
      1  1538		       00 a9	   __fromRow  =	TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1538
      4  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1538					      ENDIF
      8  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1538				  -VNAME      SETSTR	__fromRow
     10  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1538				  -	      ERR
     12  1538					      ENDIF
      0  1538					      VAR	__boardIndex, 1
      1  1538		       00 aa	   __boardIndex =	TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1538
      4  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1538					      ENDIF
      8  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1538				  -VNAME      SETSTR	__boardIndex
     10  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1538				  -	      ERR
     12  1538					      ENDIF
      0  1538					      VAR	__fromCol, 1
      1  1538		       00 ab	   __fromCol  =	TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1538
      4  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1538					      ENDIF
      8  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1538				  -VNAME      SETSTR	__fromCol
     10  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1538				  -	      ERR
     12  1538					      ENDIF
      0  1538					      VAR	__toCol, 1
      1  1538		       00 ac	   __toCol    =	TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1538
      4  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1538					      ENDIF
      8  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1538				  -VNAME      SETSTR	__toCol
     10  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1538				  -	      ERR
     12  1538					      ENDIF
    347  1538
      0  1538					      VEND	aiMarchToTargetA
      1  1538
      2  1538
      3  1538		       00 ad	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
      4  1538
    349  1538
    350  1538
    351  1538		       a5 83		      lda	drawDelay
    352  153a		       f0 03		      beq	.nodelay
    353  153c		       c6 83		      dec	drawDelay
    354  153e		       60		      rts
    355  153f				   .nodelay
    356  153f
    357  153f							; Now we calculate move to new square
    358  153f
    359  153f		       a5 86		      lda	fromX12
    360  1541		       c5 87		      cmp	toX12
    361  1543		       f0 44		      beq	.unmovedx
    362  1545		       85 84		      sta	lastSquareX12
    363  1547
    364  1547		       38		      sec
    365  1548		       a2 fd		      ldx	#-3
    366  154a		       e9 0a	   .sub10     sbc	#10
    367  154c		       e8		      inx
    368  154d		       b0 fb		      bcs	.sub10
    369  154f		       69 08		      adc	#8
    370  1551		       85 ab		      sta	__fromCol
    371  1553		       86 a9		      stx	__fromRow
    372  1555
    373  1555		       a5 87		      lda	toX12
    374  1557		       38		      sec
    375  1558		       a2 fd		      ldx	#-3
    376  155a		       e9 0a	   .sub10b    sbc	#10
    377  155c		       e8		      inx
    378  155d		       b0 fb		      bcs	.sub10b
    379  155f		       69 08		      adc	#8
    380  1561		       85 ac		      sta	__toCol
    381  1563
    382  1563
    383  1563		       e4 a9		      cpx	__fromRow
    384  1565		       f0 13		      beq	.rowDone
    385  1567
    386  1567		       b0 0a		      bcs	.incRow
    387  1569
    388  1569		       38		      sec
    389  156a		       a5 86		      lda	fromX12
    390  156c		       e9 0a		      sbc	#10
    391  156e		       85 86		      sta	fromX12
    392  1570		       4c 7a f5 	      jmp	.rowDone
    393  1573
    394  1573		       18	   .incRow    clc
    395  1574		       a5 86		      lda	fromX12
    396  1576		       69 0a		      adc	#10
    397  1578		       85 86		      sta	fromX12
    398  157a
    399  157a				   .rowDone
    400  157a
    401  157a		       a5 ac		      lda	__toCol
    402  157c		       c5 ab		      cmp	__fromCol
    403  157e		       f0 09		      beq	.colDone
    404  1580
    405  1580		       b0 05		      bcs	.incCol
    406  1582
    407  1582		       c6 86		      dec	fromX12
    408  1584		       4c 89 f5 	      jmp	.colDone
    409  1587
    410  1587		       e6 86	   .incCol    inc	fromX12
    411  1589				   .colDone
    412  1589				   .unmovedx
    413  1589
    414  1589		       a5 88		      lda	originX12
    415  158b		       85 89		      sta	cursorX12
    416  158d
      0  158d					      PHASE	MarchA2
      1  158d		       a9 17		      lda	#AI_MarchA2
      2  158f		       85 8c		      sta	aiState
    418  1591		       60		      rts
    419  1592
    420  1592
    421  1592							;---------------------------------------------------------------------------------------------------
    422  1592
      0  1592					      DEF	aiFinalFlash
      1  1592				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  1592				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  1592				   aiFinalFlash
      4  1592				   TEMPORARY_VAR SET	Overlay
      5  1592				   TEMPORARY_OFFSET SET	0
      6  1592				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  1592				   FUNCTION_NAME SET	aiFinalFlash
    424  1592					      SUBROUTINE
    425  1592
      0  1592					      REF	Variable_PieceShapeBuffer
      1  1592					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1592				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1592					      ENDIF
      0  1592					      REF	AiStateMachine
      1  1592				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1592				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1592					      ENDIF
      0  1592					      VEND	aiFinalFlash
      1  1592
      2  1592
      3  1592		       00 ef	   VAREND_aiFinalFlash =	TEMPORARY_VAR
      4  1592
    429  1592
    430  1592							; Piece has finished the animated move and is now in destination square.
    431  1592							; Flash the piece
    432  1592
    433  1592
    434  1592							; TODO: if en-passant, we can remove the piece being taken
    435  1592							; check movePiece for enPassant flag set (x)
    436  1592
    437  1592
    438  1592		       a5 83		      lda	drawDelay
    439  1594		       f0 03		      beq	.deCount
    440  1596		       c6 83		      dec	drawDelay
    441  1598		       60		      rts
    442  1599
    443  1599		       a5 85	   .deCount   lda	drawCount
    444  159b		       f0 0e		      beq	.flashDone2
    445  159d		       c6 85		      dec	drawCount
    446  159f
    447  159f		       a9 0a		      lda	#10
    448  15a1		       85 83		      sta	drawDelay	; "getting ready to move" flash
    449  15a3
    450  15a3		       a5 86		      lda	fromX12
    451  15a5		       85 81		      sta	squareToDraw
    452  15a7
    453  15a7							; WARNING - local variables will not survive the following call...!
    454  15a7		       20 c8 f0 	      jsr	CopySinglePiece	;@0
    455  15aa		       60		      rts
    456  15ab
    457  15ab				   .flashDone2
    458  15ab
    459  15ab		       a9 64		      lda	#100
    460  15ad		       85 8d		      sta	aiFlashDelay
    461  15af
      0  15af					      PHASE	SpecialMoveFixup
      1  15af		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  15b1		       85 8c		      sta	aiState
    463  15b3		       60		      rts
    464  15b4
    465  15b4
    466  15b4							;---------------------------------------------------------------------------------------------------
    467  15b4
      0  15b4					      DEF	aiStartSquareSelected
      1  15b4				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  15b4				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  15b4				   aiStartSquareSelected
      4  15b4				   TEMPORARY_VAR SET	Overlay
      5  15b4				   TEMPORARY_OFFSET SET	0
      6  15b4				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  15b4				   FUNCTION_NAME SET	aiStartSquareSelected
    469  15b4					      SUBROUTINE
    470  15b4
      0  15b4					      REF	AiStateMachine
      1  15b4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  15b4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  15b4					      ENDIF
      0  15b4					      VEND	aiStartSquareSelected
      1  15b4
      2  15b4
      3  15b4		       00 a9	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
      4  15b4
    473  15b4
    474  15b4
    475  15b4							; Mark all the valid moves for the selected piece on the board
    476  15b4							; and then start pulsing the piece
    477  15b4							; AND start choosing for selection of TO square
    478  15b4
    479  15b4							; Iterate the movelist and for all from squares which = drawPieceNumber
    480  15b4							; then draw a BLANK at that square
    481  15b4							; do 1 by one, when none found then increment state
    482  15b4
    483  15b4
      0  15b4					      SPEAK	SAY_how_about
      1  15b4
      2  15b4		       a9 8b		      lda	#<SAY_how_about
      3  15b6		       85 9a		      sta	speech_addr
      4  15b8		       a9 f9		      lda	#>SAY_how_about
      5  15ba		       85 9b		      sta	speech_addr+1
      6  15bc
    485  15bc
    486  15bc		       a5 89		      lda	cursorX12
    487  15be		       85 81		      sta	squareToDraw
    488  15c0
    489  15c0		       a9 0a		      lda	#10
    490  15c2		       85 8d		      sta	aiFlashDelay
    491  15c4
    492  15c4		       a9 00		      lda	#0
    493  15c6		       85 87		      sta	toX12	;aiToSquareX12
    494  15c8		       85 8f		      sta	aiFlashPhase	; for debounce exit timing
    495  15ca
    496  15ca		       a9 ff		      lda	#-1
    497  15cc		       85 8e		      sta	aiMoveIndex
    498  15ce
    499  15ce		       a9 28		      lda	#HOLD_DELAY
    500  15d0		       85 8a		      sta	mdelay	; hold-down delay before moves are shown
    501  15d2
      0  15d2					      PHASE	DrawMoves
      1  15d2		       a9 04		      lda	#AI_DrawMoves
      2  15d4		       85 8c		      sta	aiState
    503  15d6		       60		      rts
    504  15d7
    505  15d7
    506  15d7							;---------------------------------------------------------------------------------------------------
    507  15d7
      0  15d7					      DEF	aiWriteStartPieceBlank
      1  15d7				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  15d7				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  15d7				   aiWriteStartPieceBlank
      4  15d7				   TEMPORARY_VAR SET	Overlay
      5  15d7				   TEMPORARY_OFFSET SET	0
      6  15d7				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  15d7				   FUNCTION_NAME SET	aiWriteStartPieceBlank
    509  15d7					      SUBROUTINE
    510  15d7
      0  15d7					      REF	Variable_PieceShapeBuffer
      1  15d7					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  15d7				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  15d7					      ENDIF
      0  15d7					      REF	AiStateMachine
      1  15d7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  15d7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  15d7					      ENDIF
      0  15d7					      VEND	aiWriteStartPieceBlank
      1  15d7
      2  15d7
      3  15d7		       00 ef	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
      4  15d7
    514  15d7
    515  15d7							; Flash the piece in-place preparatory to moving it.
    516  15d7							; drawDelay = flash speed
    517  15d7							; drawCount = # of flashes
    518  15d7
    519  15d7
    520  15d7		       a9 04		      lda	#%100
    521  15d9		       85 4a		      sta	CTRLPF
    522  15db
    523  15db		       a6 a5		      ldx	platform
    524  15dd		       bd e9 f5 	      lda	startCol,x
    525  15e0		       85 46		      sta	COLUP0
    526  15e2
    527  15e2
    528  15e2		       a5 83		      lda	drawDelay
    529  15e4		       f0 05		      beq	deCount
    530  15e6		       c6 83		      dec	drawDelay
    531  15e8		       60		      rts
    532  15e9
    533  15e9				   startCol
    534  15e9		       44 66		      .byte.b	NTSC_COLOUR_LINE_2-2, PAL_COLOUR_LINE_2-2
    535  15eb
    536  15eb
    537  15eb
    538  15eb				   deCount
    539  15eb
    540  15eb		       a5 85		      lda	drawCount
    541  15ed		       f0 0d		      beq	flashDone
    542  15ef		       c6 85		      dec	drawCount
    543  15f1
    544  15f1		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    545  15f3		       85 83		      sta	drawDelay	; "getting ready to move" flash
    546  15f5
    547  15f5		       a5 86		      lda	fromX12
    548  15f7		       85 81		      sta	squareToDraw
    549  15f9
    550  15f9							; WARNING - local variables will not survive the following call...!
    551  15f9		       4c c8 f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
    552  15fc
    553  15fc				   flashDone
    554  15fc
    555  15fc							;lda #2
    556  15fc							;sta drawDelay
      0  15fc					      PHASE	MarchToTargetA
      1  15fc		       a9 16		      lda	#AI_MarchToTargetA
      2  15fe		       85 8c		      sta	aiState
    558  1600		       60		      rts
    559  1601
    560  1601
    561  1601							;---------------------------------------------------------------------------------------------------
    562  1601
      0  1601					      DEF	aiEPHandler
      1  1601				   SLOT_aiEPHandler SET	_BANK_SLOT
      2  1601				   BANK_aiEPHandler SET	SLOT_aiEPHandler + _CURRENT_BANK
      3  1601				   aiEPHandler
      4  1601				   TEMPORARY_VAR SET	Overlay
      5  1601				   TEMPORARY_OFFSET SET	0
      6  1601				   VAR_BOUNDARY_aiEPHandler SET	TEMPORARY_OFFSET
      7  1601				   FUNCTION_NAME SET	aiEPHandler
    564  1601					      SUBROUTINE
    565  1601
    566  1601							;CALL EnPassantFixupDraw	  ; set enPassantPawn
    567  1601
    568  1601
    569  1601		       a5 97		      lda	fromPiece
    570  1603		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    571  1605		       c9 60		      cmp	#FLAG_ENPASSANT|FLAG_MOVED
    572  1607		       d0 1a		      bne	.exit
    573  1609
    574  1609							; we have deteced a piece DOING an en passant capture
    575  1609							; so do the actual removal of the captured pawn...
    576  1609							; calculate the captured pawn's square based on piece colour
    577  1609
    578  1609		       a9 f6		      lda	#-10
    579  160b		       a6 97		      ldx	fromPiece
    580  160d		       10 02		      bpl	.white
    581  160f		       a9 0a		      lda	#10
    582  1611				   .white
    583  1611		       18		      clc
    584  1612		       65 86		      adc	fromX12	; attacker destination square
    585  1614		       85 94		      sta	enPassantPawn	; now this is the pawn to ERASE
    586  1616
    587  1616		       a9 05		      lda	#5	; on/off count (leave undrawn)
    588  1618		       85 85		      sta	drawCount	; flashing for piece about to move
    589  161a		       a9 00		      lda	#0
    590  161c		       85 83		      sta	drawDelay
    591  161e
      0  161e					      PHASE	EPFlash
      1  161e		       a9 2a		      lda	#AI_EPFlash
      2  1620		       85 8c		      sta	aiState
    593  1622		       60		      rts
    594  1623
    595  1623
    596  1623				   .exit
    597  1623
    598  1623		       a9 04		      lda	#4	; on/off count (leave undrawn)
    599  1625		       85 85		      sta	drawCount	; flashing for piece about to move
    600  1627		       a9 00		      lda	#0
    601  1629		       85 83		      sta	drawDelay
    602  162b
      0  162b					      PHASE	FinalFlash
      1  162b		       a9 1b		      lda	#AI_FinalFlash
      2  162d		       85 8c		      sta	aiState
    604  162f		       60		      rts
    605  1630
    606  1630
    607  1630							;---------------------------------------------------------------------------------------------------
    608  1630
      0  1630					      END_BANK
      1  1630				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  1630				  -	      CHECK_RAM_BANK_SIZE
      3  1630					      ELSE
      0  1630					      CHECK_BANK_SIZE
      1  1630		       02 30	   .TEMP      =	* - _BANK_START
 ROM bank # 6 STATEMACHINE2 size = $230 free = 463
      2  1630					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  1630				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1630				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  1630				  -	      ERR
      6  1630					      ENDIF
      5  1630					      ENDIF
    610  1630
    611  1630							;---------------------------------------------------------------------------------------------------
    612  1630							; EOF
------- FILE ./chess.asm
------- FILE @1 PIECE HANDLER #1.asm LEVEL 2 PASS 4
      0  1630					      include	"@1 PIECE HANDLER #1.asm"
      1  1630							;---------------------------------------------------------------------------------------------------
      2  1630							; @1 PIECE HANDLER #1.asm
      3  1630
      4  1630							; Atari 2600 Chess
      5  1630							; Copyright (c) 2019-2020 Andrew Davie
      6  1630							; andrew@taswegian.com
      7  1630
      8  1630
      9  1630							;---------------------------------------------------------------------------------------------------
     10  1630
      0  1630					      SLOT	1
      1  1630
      2  1630				  -	      IF	(1 < 0) || (1 > 3)
      3  1630				  -	      ECHO	"Illegal bank address/segment location", 1
      4  1630				  -	      ERR
      5  1630					      ENDIF
      6  1630
      7  1630				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  1630				   _BANK_SLOT SET	1 * 64
      9  1630
      0  1630					      ROMBANK	PIECE_HANDLER_1
      1  1ac4 ????				      SEG	ROM_PIECE_HANDLER_1
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   PIECE_HANDLER_1_START SET	*
      6  1800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1800				   ROMBANK_PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1800				   _LAST_BANK SETSTR	PIECE_HANDLER_1
     10  1800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1800
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  1800					      include	"PIECE_PAWN.asm"
      1  1800							; Copyright (C)2020 Andrew Davie
      2  1800							; Pawn move handlers
      3  1800
      4  1800							;---------------------------------------------------------------------------------------------------
      5  1800							; WHITE PAWN
      6  1800							;---------------------------------------------------------------------------------------------------
      7  1800
      8  1800		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  1800		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  1800
     11  1800							;---------------------------------------------------------------------------------------------------
     12  1800
     13  1800					      MAC	en_passant
     14  1800					      SUBROUTINE
     15  1800							; {1} = _LEFT or _RIGHT
     16  1800
     17  1800					      ldx	currentSquare
     18  1800					      ldy	ValidSquare+{1},x
     19  1800					      cpy	enPassantPawn
     20  1800					      bne	.invalid
     21  1800					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  1800					      lda	Board,y
     23  1800					      bne	.invalid
     24  1800					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  1800				   .invalid
     26  1800					      ENDM
     27  1800
     28  1800							;---------------------------------------------------------------------------------------------------
     29  1800
     30  1800					      MAC	promote_pawn
     31  1800							;SUBROUTINE
     32  1800
     33  1800							;{1} = BLACK or WHITE
     34  1800
     35  1800
     36  1800					      sty	__temp
     37  1800					      lda	#{1}|QUEEN
     38  1800					      sta	currentPiece
     39  1800					      jsr	AddMove
     40  1800
     41  1800					      lda	#{1}|ROOK
     42  1800					      sta	currentPiece
     43  1800					      ldy	__temp
     44  1800					      jsr	AddMove
     45  1800
     46  1800					      lda	#{1}|BISHOP
     47  1800					      sta	currentPiece
     48  1800					      ldy	__temp
     49  1800					      jsr	AddMove
     50  1800
     51  1800					      lda	#{1}|KNIGHT
     52  1800					      sta	currentPiece
     53  1800					      ldy	__temp
     54  1800					      jsr	AddMove
     55  1800
     56  1800					      IF	{1} = WHITE
     57  1800					      lda	#WHITE|WP
     58  1800					      ENDIF
     59  1800					      IF	{1} = BLACK
     60  1800					      lda	#BLACK|BP
     61  1800					      ENDIF
     62  1800					      sta	currentPiece
     63  1800					      ENDM
     64  1800
     65  1800							;---------------------------------------------------------------------------------------------------
     66  1800
     67  1800					      MAC	move_or_promote_pawn
     68  1800							;SUBROUTINE
     69  1800							; {1} = BLACK or WHITE
     70  1800
     71  1800					      IF	{1} = WHITE
     72  1800					      cpy	#90	; last rank?
     73  1800					      bcc	.standard
     74  1800					      jsr	PromoteWhitePawn
     75  1800					      jmp	.pMoved
     76  1800					      ENDIF
     77  1800
     78  1800					      IF	{1} = BLACK
     79  1800					      cpy	#30	; last rank?
     80  1800					      bcs	.standard
     81  1800					      jsr	PromoteBlackPawn
     82  1800					      jmp	.pMoved
     83  1800					      ENDIF
     84  1800
     85  1800				   .standard  jsr	AddMove	; add +1UP move
     86  1800				   .pMoved
     87  1800
     88  1800					      ENDM
     89  1800
     90  1800							;---------------------------------------------------------------------------------------------------
     91  1800
     92  1800					      MAC	take
     93  1800							;SUBROUTINE
     94  1800							; {1} = capture square offset
     95  1800
     96  1800					      ldx	currentSquare
     97  1800					      ldy	ValidSquare+{1},x
     98  1800					      bmi	.invalid2
     99  1800					      lda	Board,y
    100  1800					      beq	.invalid2	; square empty
    101  1800					      sta	capture
    102  1800					      eor	currentPiece
    103  1800					      bpl	.invalid	; same colour
    104  1800
    105  1800					      MOVE_OR_PROMOTE_PAWN	{2}
    106  1800
    107  1800					      jmp	.invalid2
    108  1800				   .invalid		;inc protecting ???
    109  1800				   .invalid2
    110  1800					      ENDM
    111  1800
    112  1800							;---------------------------------------------------------------------------------------------------
    113  1800
      0  1800					      DEF	PromoteWhitePawn
      1  1800				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  1800				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  1800				   PromoteWhitePawn
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	PromoteWhitePawn
    115  1800					      SUBROUTINE
    116  1800
      0  1800					      REF	Handle_WHITE_PAWN
      1  1800					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  1800				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  1800					      ENDIF
      0  1800					      VAR	__temp, 1
      1  1800		       00 bb	   __temp     =	TEMPORARY_VAR
      2  1800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1800
      4  1800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1800					      ENDIF
      8  1800				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1800				  -VNAME      SETSTR	__temp
     10  1800				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1800				  -	      ERR
     12  1800					      ENDIF
      0  1800					      VEND	PromoteWhitePawn
      1  1800
      2  1800
      3  1800		       00 bc	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
      4  1800
    120  1800
      0  1800					      PROMOTE_PAWN	WHITE
      1  1800
      2  1800
      3  1800
      4  1800
      5  1800
      6  1800		       84 bb		      sty	__temp
      7  1802		       a9 06		      lda	#WHITE|QUEEN
      8  1804		       85 92		      sta	currentPiece
      9  1806		       20 70 f2 	      jsr	AddMove
     10  1809
     11  1809		       a9 05		      lda	#WHITE|ROOK
     12  180b		       85 92		      sta	currentPiece
     13  180d		       a4 bb		      ldy	__temp
     14  180f		       20 70 f2 	      jsr	AddMove
     15  1812
     16  1812		       a9 04		      lda	#WHITE|BISHOP
     17  1814		       85 92		      sta	currentPiece
     18  1816		       a4 bb		      ldy	__temp
     19  1818		       20 70 f2 	      jsr	AddMove
     20  181b
     21  181b		       a9 03		      lda	#WHITE|KNIGHT
     22  181d		       85 92		      sta	currentPiece
     23  181f		       a4 bb		      ldy	__temp
     24  1821		       20 70 f2 	      jsr	AddMove
     25  1824
     26  1824					      IF	WHITE = WHITE
     27  1824		       a9 01		      lda	#WHITE|WP
     28  1826					      ENDIF
     29  1826				  -	      IF	WHITE = BLACK
     30  1826				  -	      lda	#BLACK|BP
     31  1826					      ENDIF
     32  1826		       85 92		      sta	currentPiece
    122  1828		       60		      rts
    123  1829
    124  1829							;---------------------------------------------------------------------------------------------------
    125  1829
      0  1829					      DEF	Handle_WHITE_PAWN
      1  1829				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  1829				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  1829				   Handle_WHITE_PAWN
      4  1829				   TEMPORARY_VAR SET	Overlay
      5  1829				   TEMPORARY_OFFSET SET	0
      6  1829				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  1829				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  1829					      SUBROUTINE
    128  1829
      0  1829					      REF	GenerateAllMoves
      1  1829					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1829				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1829					      ENDIF
      0  1829					      VEND	Handle_WHITE_PAWN
      1  1829
      2  1829
      3  1829		       00 bb	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
      4  1829
    131  1829
    132  1829		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  182c		       b9 79 fc 	      lda	Board,y
    134  182f		       d0 26		      bne	.pMoved	; occupied
    135  1831		       85 a0		      sta	capture
    136  1833
    137  1833							; we may need to promote the pawn
    138  1833							; All possibilites (Q/R/B/N) are added as individual moves
    139  1833
      0  1833					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  1833
      2  1833
      3  1833
      4  1833					      IF	WHITE = WHITE
      5  1833		       c0 5a		      cpy	#90
      6  1835		       90 06		      bcc	.standard
      7  1837		       20 00 f4 	      jsr	PromoteWhitePawn
      8  183a		       4c 40 f4 	      jmp	.pMoved
      9  183d					      ENDIF
     10  183d
     11  183d				  -	      IF	WHITE = BLACK
     12  183d				  -	      cpy	#30
     13  183d				  -	      bcs	.standard
     14  183d				  -	      jsr	PromoteBlackPawn
     15  183d				  -	      jmp	.pMoved
     16  183d					      ENDIF
     17  183d
     18  183d		       20 70 f2    .standard  jsr	AddMove
     19  1840				   .pMoved
     20  1840
    141  1840
    142  1840							; the +2 move off the home rank...
    143  1840
    144  1840		       a6 93		      ldx	currentSquare
    145  1842		       e0 28		      cpx	#WHITE_HOME_ROW
    146  1844		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  1846		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  1849		       b9 79 fc 	      lda	Board,y
    149  184c		       d0 09		      bne	.pMoved	; destination square occupied
    150  184e
    151  184e		       a5 92		      lda	currentPiece
    152  1850		       09 20		      ora	#FLAG_ENPASSANT
    153  1852		       85 92		      sta	currentPiece	; GENERATE en-passant opportunity
    154  1854
    155  1854		       20 70 f2 	      jsr	AddMove	; add the +2UP move off home row
    156  1857
    157  1857				   .pMoved
    158  1857
    159  1857							; regular captures...
    160  1857
      0  1857					      TAKE	_UP+_LEFT, WHITE
      1  1857
      2  1857
      3  1857
      4  1857		       a6 93		      ldx	currentSquare
      5  1859		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  185c		       30 1b		      bmi	.invalid2
      7  185e		       b9 79 fc 	      lda	Board,y
      8  1861		       f0 16		      beq	.invalid2
      9  1863		       85 a0		      sta	capture
     10  1865		       45 92		      eor	currentPiece
     11  1867		       10 10		      bpl	.invalid
     12  1869
      0  1869					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  1869
      2  1869
      3  1869
      4  1869					      IF	WHITE = WHITE
      5  1869		       c0 5a		      cpy	#90
      6  186b		       90 06		      bcc	.standard
      7  186d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  1870		       4c 76 f4 	      jmp	.pMoved
      9  1873					      ENDIF
     10  1873
     11  1873				  -	      IF	WHITE = BLACK
     12  1873				  -	      cpy	#30
     13  1873				  -	      bcs	.standard
     14  1873				  -	      jsr	PromoteBlackPawn
     15  1873				  -	      jmp	.pMoved
     16  1873					      ENDIF
     17  1873
     18  1873		       20 70 f2    .standard  jsr	AddMove
     19  1876				   .pMoved
     20  1876
     14  1876
     15  1876		       4c 79 f4 	      jmp	.invalid2
     16  1879				   .invalid
     17  1879				   .invalid2
      0  1879					      TAKE	_UP+_RIGHT, WHITE
      1  1879
      2  1879
      3  1879
      4  1879		       a6 93		      ldx	currentSquare
      5  187b		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  187e		       30 1b		      bmi	.invalid2
      7  1880		       b9 79 fc 	      lda	Board,y
      8  1883		       f0 16		      beq	.invalid2
      9  1885		       85 a0		      sta	capture
     10  1887		       45 92		      eor	currentPiece
     11  1889		       10 10		      bpl	.invalid
     12  188b
      0  188b					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  188b
      2  188b
      3  188b
      4  188b					      IF	WHITE = WHITE
      5  188b		       c0 5a		      cpy	#90
      6  188d		       90 06		      bcc	.standard
      7  188f		       20 00 f4 	      jsr	PromoteWhitePawn
      8  1892		       4c 98 f4 	      jmp	.pMoved
      9  1895					      ENDIF
     10  1895
     11  1895				  -	      IF	WHITE = BLACK
     12  1895				  -	      cpy	#30
     13  1895				  -	      bcs	.standard
     14  1895				  -	      jsr	PromoteBlackPawn
     15  1895				  -	      jmp	.pMoved
     16  1895					      ENDIF
     17  1895
     18  1895		       20 70 f2    .standard  jsr	AddMove
     19  1898				   .pMoved
     20  1898
     14  1898
     15  1898		       4c 9b f4 	      jmp	.invalid2
     16  189b				   .invalid
     17  189b				   .invalid2
    163  189b
    164  189b
    165  189b					      IF	ENPASSANT_ENABLED
    166  189b							; en-passant captures...
    167  189b
    168  189b		       a5 94		      lda	enPassantPawn
    169  189d		       f0 2e		      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  189f
    171  189f		       a5 92		      lda	currentPiece
    172  18a1		       09 20		      ora	#FLAG_ENPASSANT
    173  18a3		       85 92		      sta	currentPiece	; CONSUME en-passant opportunity
    174  18a5
      0  18a5					      EN_PASSANT	_LEFT, _UP
      1  18a5					      SUBROUTINE
      2  18a5
      3  18a5
      4  18a5		       a6 93		      ldx	currentSquare
      5  18a7		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  18aa		       c4 94		      cpy	enPassantPawn
      7  18ac		       d0 0b		      bne	.invalid
      8  18ae		       bc 1e fc 	      ldy	ValidSquare+_LEFT+_UP,x
      9  18b1		       b9 79 fc 	      lda	Board,y
     10  18b4		       d0 03		      bne	.invalid
     11  18b6		       20 70 f2 	      jsr	AddMove
     12  18b9				   .invalid
      0  18b9					      EN_PASSANT	_RIGHT, _UP
      1  18b9					      SUBROUTINE
      2  18b9
      3  18b9
      4  18b9		       a6 93		      ldx	currentSquare
      5  18bb		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  18be		       c4 94		      cpy	enPassantPawn
      7  18c0		       d0 0b		      bne	.invalid
      8  18c2		       bc 20 fc 	      ldy	ValidSquare+_RIGHT+_UP,x
      9  18c5		       b9 79 fc 	      lda	Board,y
     10  18c8		       d0 03		      bne	.invalid
     11  18ca		       20 70 f2 	      jsr	AddMove
     12  18cd				   .invalid
    177  18cd
    178  18cd				   .noEnPassant
    179  18cd					      ENDIF
    180  18cd
    181  18cd		       4c e9 f1 	      jmp	MoveReturn
    182  18d0
    183  18d0
    184  18d0							;---------------------------------------------------------------------------------------------------
    185  18d0							; BLACK PAWN
    186  18d0							;---------------------------------------------------------------------------------------------------
    187  18d0
      0  18d0					      DEF	PromoteBlackPawn
      1  18d0				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  18d0				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  18d0				   PromoteBlackPawn
      4  18d0				   TEMPORARY_VAR SET	Overlay
      5  18d0				   TEMPORARY_OFFSET SET	0
      6  18d0				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  18d0				   FUNCTION_NAME SET	PromoteBlackPawn
    189  18d0					      SUBROUTINE
    190  18d0
      0  18d0					      REF	Handle_BLACK_PAWN
      1  18d0					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  18d0				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  18d0					      ENDIF
      0  18d0					      VAR	__temp, 1
      1  18d0		       00 bb	   __temp     =	TEMPORARY_VAR
      2  18d0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  18d0
      4  18d0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  18d0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  18d0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  18d0					      ENDIF
      8  18d0				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  18d0				  -VNAME      SETSTR	__temp
     10  18d0				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  18d0				  -	      ERR
     12  18d0					      ENDIF
      0  18d0					      VEND	PromoteBlackPawn
      1  18d0
      2  18d0
      3  18d0		       00 bc	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
      4  18d0
    194  18d0
      0  18d0					      PROMOTE_PAWN	BLACK
      1  18d0
      2  18d0
      3  18d0
      4  18d0
      5  18d0
      6  18d0		       84 bb		      sty	__temp
      7  18d2		       a9 86		      lda	#BLACK|QUEEN
      8  18d4		       85 92		      sta	currentPiece
      9  18d6		       20 70 f2 	      jsr	AddMove
     10  18d9
     11  18d9		       a9 85		      lda	#BLACK|ROOK
     12  18db		       85 92		      sta	currentPiece
     13  18dd		       a4 bb		      ldy	__temp
     14  18df		       20 70 f2 	      jsr	AddMove
     15  18e2
     16  18e2		       a9 84		      lda	#BLACK|BISHOP
     17  18e4		       85 92		      sta	currentPiece
     18  18e6		       a4 bb		      ldy	__temp
     19  18e8		       20 70 f2 	      jsr	AddMove
     20  18eb
     21  18eb		       a9 83		      lda	#BLACK|KNIGHT
     22  18ed		       85 92		      sta	currentPiece
     23  18ef		       a4 bb		      ldy	__temp
     24  18f1		       20 70 f2 	      jsr	AddMove
     25  18f4
     26  18f4				  -	      IF	BLACK = WHITE
     27  18f4				  -	      lda	#WHITE|WP
     28  18f4					      ENDIF
     29  18f4					      IF	BLACK = BLACK
     30  18f4		       a9 82		      lda	#BLACK|BP
     31  18f6					      ENDIF
     32  18f6		       85 92		      sta	currentPiece
    196  18f8		       60		      rts
    197  18f9
      0  18f9					      DEF	Handle_BLACK_PAWN
      1  18f9				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  18f9				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  18f9				   Handle_BLACK_PAWN
      4  18f9				   TEMPORARY_VAR SET	Overlay
      5  18f9				   TEMPORARY_OFFSET SET	0
      6  18f9				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  18f9				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  18f9					      SUBROUTINE
    200  18f9
      0  18f9					      REF	GenerateAllMoves
      1  18f9					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  18f9				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  18f9					      ENDIF
      0  18f9					      VEND	Handle_BLACK_PAWN
      1  18f9
      2  18f9
      3  18f9		       00 bb	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
      4  18f9
    203  18f9
    204  18f9		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  18fc		       b9 79 fc 	      lda	Board,y
    206  18ff		       d0 26		      bne	.pMoved	; occupied
    207  1901		       85 a0		      sta	capture
    208  1903
    209  1903							; we may need to promote the pawn
    210  1903							; All possibilites (Q/R/B/N) are added as individual moves
    211  1903
      0  1903					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  1903
      2  1903
      3  1903
      4  1903				  -	      IF	BLACK = WHITE
      5  1903				  -	      cpy	#90
      6  1903				  -	      bcc	.standard
      7  1903				  -	      jsr	PromoteWhitePawn
      8  1903				  -	      jmp	.pMoved
      9  1903					      ENDIF
     10  1903
     11  1903					      IF	BLACK = BLACK
     12  1903		       c0 1e		      cpy	#30
     13  1905		       b0 06		      bcs	.standard
     14  1907		       20 d0 f4 	      jsr	PromoteBlackPawn
     15  190a		       4c 10 f5 	      jmp	.pMoved
     16  190d					      ENDIF
     17  190d
     18  190d		       20 70 f2    .standard  jsr	AddMove
     19  1910				   .pMoved
     20  1910
    213  1910
    214  1910							; the +2 move off the home rank...
    215  1910
    216  1910		       a6 93		      ldx	currentSquare
    217  1912		       e0 52		      cpx	#BLACK_HOME_ROW
    218  1914		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  1916
    220  1916
    221  1916		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  1919		       b9 79 fc 	      lda	Board,y
    223  191c		       d0 09		      bne	.pMoved	; destination square occupied
    224  191e
    225  191e		       a5 92		      lda	currentPiece
    226  1920		       09 20		      ora	#FLAG_ENPASSANT
    227  1922		       85 92		      sta	currentPiece	; CAN en-passant
    228  1924
    229  1924		       20 70 f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  1927
    231  1927				   .pMoved
    232  1927
    233  1927							; regular captures... (with promotion)
    234  1927
      0  1927					      TAKE	_DOWN+_LEFT, BLACK
      1  1927
      2  1927
      3  1927
      4  1927		       a6 93		      ldx	currentSquare
      5  1929		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  192c		       30 1b		      bmi	.invalid2
      7  192e		       b9 79 fc 	      lda	Board,y
      8  1931		       f0 16		      beq	.invalid2
      9  1933		       85 a0		      sta	capture
     10  1935		       45 92		      eor	currentPiece
     11  1937		       10 10		      bpl	.invalid
     12  1939
      0  1939					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  1939
      2  1939
      3  1939
      4  1939				  -	      IF	BLACK = WHITE
      5  1939				  -	      cpy	#90
      6  1939				  -	      bcc	.standard
      7  1939				  -	      jsr	PromoteWhitePawn
      8  1939				  -	      jmp	.pMoved
      9  1939					      ENDIF
     10  1939
     11  1939					      IF	BLACK = BLACK
     12  1939		       c0 1e		      cpy	#30
     13  193b		       b0 06		      bcs	.standard
     14  193d		       20 d0 f4 	      jsr	PromoteBlackPawn
     15  1940		       4c 46 f5 	      jmp	.pMoved
     16  1943					      ENDIF
     17  1943
     18  1943		       20 70 f2    .standard  jsr	AddMove
     19  1946				   .pMoved
     20  1946
     14  1946
     15  1946		       4c 49 f5 	      jmp	.invalid2
     16  1949				   .invalid
     17  1949				   .invalid2
      0  1949					      TAKE	_DOWN+_RIGHT, BLACK
      1  1949
      2  1949
      3  1949
      4  1949		       a6 93		      ldx	currentSquare
      5  194b		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  194e		       30 1b		      bmi	.invalid2
      7  1950		       b9 79 fc 	      lda	Board,y
      8  1953		       f0 16		      beq	.invalid2
      9  1955		       85 a0		      sta	capture
     10  1957		       45 92		      eor	currentPiece
     11  1959		       10 10		      bpl	.invalid
     12  195b
      0  195b					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  195b
      2  195b
      3  195b
      4  195b				  -	      IF	BLACK = WHITE
      5  195b				  -	      cpy	#90
      6  195b				  -	      bcc	.standard
      7  195b				  -	      jsr	PromoteWhitePawn
      8  195b				  -	      jmp	.pMoved
      9  195b					      ENDIF
     10  195b
     11  195b					      IF	BLACK = BLACK
     12  195b		       c0 1e		      cpy	#30
     13  195d		       b0 06		      bcs	.standard
     14  195f		       20 d0 f4 	      jsr	PromoteBlackPawn
     15  1962		       4c 68 f5 	      jmp	.pMoved
     16  1965					      ENDIF
     17  1965
     18  1965		       20 70 f2    .standard  jsr	AddMove
     19  1968				   .pMoved
     20  1968
     14  1968
     15  1968		       4c 6b f5 	      jmp	.invalid2
     16  196b				   .invalid
     17  196b				   .invalid2
    237  196b
    238  196b
    239  196b					      IF	ENPASSANT_ENABLED
    240  196b							; en-passant captures...
    241  196b
    242  196b		       a5 94		      lda	enPassantPawn
    243  196d		       f0 2e		      beq	.noEnPassant	; was last move en-passantable?
    244  196f
    245  196f		       a5 92		      lda	currentPiece
    246  1971		       09 20		      ora	#FLAG_ENPASSANT
    247  1973		       85 92		      sta	currentPiece	; any en-passant move added will have flag set
    248  1975
      0  1975					      EN_PASSANT	_LEFT, _DOWN
      1  1975					      SUBROUTINE
      2  1975
      3  1975
      4  1975		       a6 93		      ldx	currentSquare
      5  1977		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  197a		       c4 94		      cpy	enPassantPawn
      7  197c		       d0 0b		      bne	.invalid
      8  197e		       bc 0a fc 	      ldy	ValidSquare+_LEFT+_DOWN,x
      9  1981		       b9 79 fc 	      lda	Board,y
     10  1984		       d0 03		      bne	.invalid
     11  1986		       20 70 f2 	      jsr	AddMove
     12  1989				   .invalid
      0  1989					      EN_PASSANT	_RIGHT, _DOWN
      1  1989					      SUBROUTINE
      2  1989
      3  1989
      4  1989		       a6 93		      ldx	currentSquare
      5  198b		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  198e		       c4 94		      cpy	enPassantPawn
      7  1990		       d0 0b		      bne	.invalid
      8  1992		       bc 0c fc 	      ldy	ValidSquare+_RIGHT+_DOWN,x
      9  1995		       b9 79 fc 	      lda	Board,y
     10  1998		       d0 03		      bne	.invalid
     11  199a		       20 70 f2 	      jsr	AddMove
     12  199d				   .invalid
    251  199d
    252  199d				   .noEnPassant
    253  199d					      ENDIF
    254  199d
    255  199d		       4c e9 f1 	      jmp	MoveReturn
    256  19a0
    257  19a0							; EOF
------- FILE @1 PIECE HANDLER #1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  19a0					      include	"PIECE_KNIGHT.asm"
      1  19a0							; Copyright (C)2020 Andrew Davie
      2  19a0							; Knight move handler
      3  19a0
      4  19a0							;---------------------------------------------------------------------------------------------------
      5  19a0							; KNIGHT
      6  19a0							;---------------------------------------------------------------------------------------------------
      7  19a0
      0  19a0					      DEF	Handle_KNIGHT
      1  19a0				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  19a0				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  19a0				   Handle_KNIGHT
      4  19a0				   TEMPORARY_VAR SET	Overlay
      5  19a0				   TEMPORARY_OFFSET SET	0
      6  19a0				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  19a0				   FUNCTION_NAME SET	Handle_KNIGHT
      9  19a0					      SUBROUTINE
     10  19a0
      0  19a0					      REF	GenerateAllMoves	;✅
      1  19a0					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  19a0				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  19a0					      ENDIF
      0  19a0					      VEND	Handle_KNIGHT
      1  19a0
      2  19a0
      3  19a0		       00 bb	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
      4  19a0
     13  19a0
     14  19a0							; x = currentSquare (square the piece is on)
     15  19a0							; currentPiece (with flags/colour attached)
     16  19a0
      0  19a0					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  19a0					      SUBROUTINE
      2  19a0
      3  19a0		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      4  19a3		       30 0e		      bmi	.invalid
      5  19a5		       b9 79 fc 	      lda	Board,y
      6  19a8		       85 a0		      sta	capture
      7  19aa		       f0 04		      beq	.squareEmpty
      8  19ac		       45 92		      eor	currentPiece
      9  19ae		       10 03		      bpl	.invalid
     10  19b0		       20 70 f2    .squareEmpty jsr	AddMove
     11  19b3				   .invalid
     12  19b3
      0  19b3					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  19b3		       a6 93		      ldx	currentSquare
      0  19b5					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  19b5					      SUBROUTINE
      2  19b5
      3  19b5		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      4  19b8		       30 0e		      bmi	.invalid
      5  19ba		       b9 79 fc 	      lda	Board,y
      6  19bd		       85 a0		      sta	capture
      7  19bf		       f0 04		      beq	.squareEmpty
      8  19c1		       45 92		      eor	currentPiece
      9  19c3		       10 03		      bpl	.invalid
     10  19c5		       20 70 f2    .squareEmpty jsr	AddMove
     11  19c8				   .invalid
     12  19c8
      0  19c8					      MOVE_TO_X	_UP+_UP+_LEFT
      1  19c8		       a6 93		      ldx	currentSquare
      0  19ca					      MOVE_TO	_UP+_UP+_LEFT
      1  19ca					      SUBROUTINE
      2  19ca
      3  19ca		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      4  19cd		       30 0e		      bmi	.invalid
      5  19cf		       b9 79 fc 	      lda	Board,y
      6  19d2		       85 a0		      sta	capture
      7  19d4		       f0 04		      beq	.squareEmpty
      8  19d6		       45 92		      eor	currentPiece
      9  19d8		       10 03		      bpl	.invalid
     10  19da		       20 70 f2    .squareEmpty jsr	AddMove
     11  19dd				   .invalid
     12  19dd
      0  19dd					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  19dd		       a6 93		      ldx	currentSquare
      0  19df					      MOVE_TO	_UP+_UP+_RIGHT
      1  19df					      SUBROUTINE
      2  19df
      3  19df		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      4  19e2		       30 0e		      bmi	.invalid
      5  19e4		       b9 79 fc 	      lda	Board,y
      6  19e7		       85 a0		      sta	capture
      7  19e9		       f0 04		      beq	.squareEmpty
      8  19eb		       45 92		      eor	currentPiece
      9  19ed		       10 03		      bpl	.invalid
     10  19ef		       20 70 f2    .squareEmpty jsr	AddMove
     11  19f2				   .invalid
     12  19f2
     21  19f2
      0  19f2					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  19f2		       a6 93		      ldx	currentSquare
      0  19f4					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  19f4					      SUBROUTINE
      2  19f4
      3  19f4		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      4  19f7		       30 0e		      bmi	.invalid
      5  19f9		       b9 79 fc 	      lda	Board,y
      6  19fc		       85 a0		      sta	capture
      7  19fe		       f0 04		      beq	.squareEmpty
      8  1a00		       45 92		      eor	currentPiece
      9  1a02		       10 03		      bpl	.invalid
     10  1a04		       20 70 f2    .squareEmpty jsr	AddMove
     11  1a07				   .invalid
     12  1a07
      0  1a07					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  1a07		       a6 93		      ldx	currentSquare
      0  1a09					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  1a09					      SUBROUTINE
      2  1a09
      3  1a09		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      4  1a0c		       30 0e		      bmi	.invalid
      5  1a0e		       b9 79 fc 	      lda	Board,y
      6  1a11		       85 a0		      sta	capture
      7  1a13		       f0 04		      beq	.squareEmpty
      8  1a15		       45 92		      eor	currentPiece
      9  1a17		       10 03		      bpl	.invalid
     10  1a19		       20 70 f2    .squareEmpty jsr	AddMove
     11  1a1c				   .invalid
     12  1a1c
      0  1a1c					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  1a1c		       a6 93		      ldx	currentSquare
      0  1a1e					      MOVE_TO	_UP+_LEFT+_LEFT
      1  1a1e					      SUBROUTINE
      2  1a1e
      3  1a1e		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      4  1a21		       30 0e		      bmi	.invalid
      5  1a23		       b9 79 fc 	      lda	Board,y
      6  1a26		       85 a0		      sta	capture
      7  1a28		       f0 04		      beq	.squareEmpty
      8  1a2a		       45 92		      eor	currentPiece
      9  1a2c		       10 03		      bpl	.invalid
     10  1a2e		       20 70 f2    .squareEmpty jsr	AddMove
     11  1a31				   .invalid
     12  1a31
      0  1a31					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  1a31		       a6 93		      ldx	currentSquare
      0  1a33					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  1a33					      SUBROUTINE
      2  1a33
      3  1a33		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      4  1a36		       30 0e		      bmi	.invalid
      5  1a38		       b9 79 fc 	      lda	Board,y
      6  1a3b		       85 a0		      sta	capture
      7  1a3d		       f0 04		      beq	.squareEmpty
      8  1a3f		       45 92		      eor	currentPiece
      9  1a41		       10 03		      bpl	.invalid
     10  1a43		       20 70 f2    .squareEmpty jsr	AddMove
     11  1a46				   .invalid
     12  1a46
     26  1a46
     27  1a46		       4c e9 f1 	      jmp	MoveReturn
     28  1a49
     29  1a49							; EOF
------- FILE @1 PIECE HANDLER #1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  1a49					      include	"PIECE_BISHOP.asm"
      1  1a49							; Copyright (C)2020 Andrew Davie
      2  1a49
      3  1a49							;---------------------------------------------------------------------------------------------------
      4  1a49							; BISHOP
      5  1a49							;---------------------------------------------------------------------------------------------------
      6  1a49
      0  1a49					      DEF	Handle_BISHOP
      1  1a49				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  1a49				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  1a49				   Handle_BISHOP
      4  1a49				   TEMPORARY_VAR SET	Overlay
      5  1a49				   TEMPORARY_OFFSET SET	0
      6  1a49				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  1a49				   FUNCTION_NAME SET	Handle_BISHOP
      8  1a49					      SUBROUTINE
      9  1a49
      0  1a49					      REF	GenerateAllMoves	;✅
      1  1a49					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1a49				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1a49					      ENDIF
      0  1a49					      VEND	Handle_BISHOP
      1  1a49
      2  1a49
      3  1a49		       00 bb	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
      4  1a49
     12  1a49
     13  1a49							; x = currentSquare (square the piece is on)
     14  1a49							; currentPiece (with flags/colour attached)
     15  1a49
      0  1a49					      MOVE_TOWARDS	_DOWN+_LEFT
      1  1a49					      SUBROUTINE
      2  1a49
      3  1a49
      4  1a49
      5  1a49		       a9 00		      lda	#0
      6  1a4b		       85 a0		      sta	capture
      7  1a4d
      8  1a4d		       a6 93		      ldx	currentSquare
      9  1a4f		       d0 03		      bne	.project
     10  1a51
     11  1a51		       20 70 f2    .empty     jsr	AddMove
     12  1a54		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  1a57		       30 0e		      bmi	.invalid
     14  1a59		       b9 79 fc 	      lda	Board,y
     15  1a5c		       f0 f3		      beq	.empty
     16  1a5e		       85 a0		      sta	capture
     17  1a60		       45 92		      eor	currentPiece
     18  1a62		       10 03		      bpl	.invalid
     19  1a64		       20 70 f2 	      jsr	AddMove
     20  1a67
     21  1a67				   .invalid
     22  1a67
      0  1a67					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  1a67					      SUBROUTINE
      2  1a67
      3  1a67
      4  1a67
      5  1a67		       a9 00		      lda	#0
      6  1a69		       85 a0		      sta	capture
      7  1a6b
      8  1a6b		       a6 93		      ldx	currentSquare
      9  1a6d		       d0 03		      bne	.project
     10  1a6f
     11  1a6f		       20 70 f2    .empty     jsr	AddMove
     12  1a72		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  1a75		       30 0e		      bmi	.invalid
     14  1a77		       b9 79 fc 	      lda	Board,y
     15  1a7a		       f0 f3		      beq	.empty
     16  1a7c		       85 a0		      sta	capture
     17  1a7e		       45 92		      eor	currentPiece
     18  1a80		       10 03		      bpl	.invalid
     19  1a82		       20 70 f2 	      jsr	AddMove
     20  1a85
     21  1a85				   .invalid
     22  1a85
      0  1a85					      MOVE_TOWARDS	_UP+_LEFT
      1  1a85					      SUBROUTINE
      2  1a85
      3  1a85
      4  1a85
      5  1a85		       a9 00		      lda	#0
      6  1a87		       85 a0		      sta	capture
      7  1a89
      8  1a89		       a6 93		      ldx	currentSquare
      9  1a8b		       d0 03		      bne	.project
     10  1a8d
     11  1a8d		       20 70 f2    .empty     jsr	AddMove
     12  1a90		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  1a93		       30 0e		      bmi	.invalid
     14  1a95		       b9 79 fc 	      lda	Board,y
     15  1a98		       f0 f3		      beq	.empty
     16  1a9a		       85 a0		      sta	capture
     17  1a9c		       45 92		      eor	currentPiece
     18  1a9e		       10 03		      bpl	.invalid
     19  1aa0		       20 70 f2 	      jsr	AddMove
     20  1aa3
     21  1aa3				   .invalid
     22  1aa3
      0  1aa3					      MOVE_TOWARDS	_UP+_RIGHT
      1  1aa3					      SUBROUTINE
      2  1aa3
      3  1aa3
      4  1aa3
      5  1aa3		       a9 00		      lda	#0
      6  1aa5		       85 a0		      sta	capture
      7  1aa7
      8  1aa7		       a6 93		      ldx	currentSquare
      9  1aa9		       d0 03		      bne	.project
     10  1aab
     11  1aab		       20 70 f2    .empty     jsr	AddMove
     12  1aae		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  1ab1		       30 0e		      bmi	.invalid
     14  1ab3		       b9 79 fc 	      lda	Board,y
     15  1ab6		       f0 f3		      beq	.empty
     16  1ab8		       85 a0		      sta	capture
     17  1aba		       45 92		      eor	currentPiece
     18  1abc		       10 03		      bpl	.invalid
     19  1abe		       20 70 f2 	      jsr	AddMove
     20  1ac1
     21  1ac1				   .invalid
     22  1ac1
     20  1ac1
     21  1ac1		       4c e9 f1 	      jmp	MoveReturn
     22  1ac4
     23  1ac4							;---------------------------------------------------------------------------------------------------
     24  1ac4							; EOF
------- FILE @1 PIECE HANDLER #1.asm
     17  1ac4
     18  1ac4							;---------------------------------------------------------------------------------------------------
     19  1ac4
      0  1ac4					      END_BANK
      1  1ac4				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  1ac4				  -	      CHECK_RAM_BANK_SIZE
      3  1ac4					      ELSE
      0  1ac4					      CHECK_BANK_SIZE
      1  1ac4		       02 c4	   .TEMP      =	* - _BANK_START
 ROM bank # 7 PIECE_HANDLER_1 size = $2c4 free = 315
      2  1ac4					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  1ac4				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1ac4				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  1ac4				  -	      ERR
      6  1ac4					      ENDIF
      5  1ac4					      ENDIF
     21  1ac4
     22  1ac4							;---------------------------------------------------------------------------------------------------
     23  1ac4							; EOF
------- FILE ./chess.asm
------- FILE @1 PIECE HANDLER #2.asm LEVEL 2 PASS 4
      0  1ac4					      include	"@1 PIECE HANDLER #2.asm"
      1  1ac4							;---------------------------------------------------------------------------------------------------
      2  1ac4							; @1 PIECE HANDLER #2.asm
      3  1ac4
      4  1ac4							; Atari 2600 Chess
      5  1ac4							; Copyright (c) 2019-2020 Andrew Davie
      6  1ac4							; andrew@taswegian.com
      7  1ac4
      8  1ac4
      9  1ac4							;---------------------------------------------------------------------------------------------------
     10  1ac4
      0  1ac4					      SLOT	1
      1  1ac4
      2  1ac4				  -	      IF	(1 < 0) || (1 > 3)
      3  1ac4				  -	      ECHO	"Illegal bank address/segment location", 1
      4  1ac4				  -	      ERR
      5  1ac4					      ENDIF
      6  1ac4
      7  1ac4				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  1ac4				   _BANK_SLOT SET	1 * 64
      9  1ac4
      0  1ac4					      ROMBANK	PIECE_HANDLER_2
      1  1e5c ????				      SEG	ROM_PIECE_HANDLER_2
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   PIECE_HANDLER_2_START SET	*
      6  1c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1c00				   ROMBANK_PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1c00				   _LAST_BANK SETSTR	PIECE_HANDLER_2
     10  1c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1c00
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  1c00					      include	"PIECE_ROOK.asm"
      1  1c00							; Copyright (C)2020 Andrew Davie
      2  1c00							; Rook move handler
      3  1c00
      4  1c00							;---------------------------------------------------------------------------------------------------
      5  1c00							; ROOK
      6  1c00							;---------------------------------------------------------------------------------------------------
      7  1c00
      0  1c00					      DEF	Handle_ROOK
      1  1c00				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  1c00				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  1c00				   Handle_ROOK
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	Handle_ROOK
      9  1c00					      SUBROUTINE
     10  1c00
      0  1c00					      REF	GenerateAllMoves	;✅
      1  1c00					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1c00				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1c00					      ENDIF
      0  1c00					      VEND	Handle_ROOK
      1  1c00
      2  1c00
      3  1c00		       00 bb	   VAREND_Handle_ROOK =	TEMPORARY_VAR
      4  1c00
     13  1c00
     14  1c00							; Pass...
     15  1c00							; x = currentSquare (square the piece is on)
     16  1c00							; currentPiece (with flags/colour attached)
     17  1c00
     18  1c00
      0  1c00					      MOVE_TOWARDS	_DOWN
      1  1c00					      SUBROUTINE
      2  1c00
      3  1c00
      4  1c00
      5  1c00		       a9 00		      lda	#0
      6  1c02		       85 a0		      sta	capture
      7  1c04
      8  1c04		       a6 93		      ldx	currentSquare
      9  1c06		       d0 03		      bne	.project
     10  1c08
     11  1c08		       20 70 f2    .empty     jsr	AddMove
     12  1c0b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  1c0e		       30 0e		      bmi	.invalid
     14  1c10		       b9 79 fc 	      lda	Board,y
     15  1c13		       f0 f3		      beq	.empty
     16  1c15		       85 a0		      sta	capture
     17  1c17		       45 92		      eor	currentPiece
     18  1c19		       10 03		      bpl	.invalid
     19  1c1b		       20 70 f2 	      jsr	AddMove
     20  1c1e
     21  1c1e				   .invalid
     22  1c1e
      0  1c1e					      MOVE_TOWARDS	_RIGHT
      1  1c1e					      SUBROUTINE
      2  1c1e
      3  1c1e
      4  1c1e
      5  1c1e		       a9 00		      lda	#0
      6  1c20		       85 a0		      sta	capture
      7  1c22
      8  1c22		       a6 93		      ldx	currentSquare
      9  1c24		       d0 03		      bne	.project
     10  1c26
     11  1c26		       20 70 f2    .empty     jsr	AddMove
     12  1c29		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  1c2c		       30 0e		      bmi	.invalid
     14  1c2e		       b9 79 fc 	      lda	Board,y
     15  1c31		       f0 f3		      beq	.empty
     16  1c33		       85 a0		      sta	capture
     17  1c35		       45 92		      eor	currentPiece
     18  1c37		       10 03		      bpl	.invalid
     19  1c39		       20 70 f2 	      jsr	AddMove
     20  1c3c
     21  1c3c				   .invalid
     22  1c3c
      0  1c3c					      MOVE_TOWARDS	_UP
      1  1c3c					      SUBROUTINE
      2  1c3c
      3  1c3c
      4  1c3c
      5  1c3c		       a9 00		      lda	#0
      6  1c3e		       85 a0		      sta	capture
      7  1c40
      8  1c40		       a6 93		      ldx	currentSquare
      9  1c42		       d0 03		      bne	.project
     10  1c44
     11  1c44		       20 70 f2    .empty     jsr	AddMove
     12  1c47		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  1c4a		       30 0e		      bmi	.invalid
     14  1c4c		       b9 79 fc 	      lda	Board,y
     15  1c4f		       f0 f3		      beq	.empty
     16  1c51		       85 a0		      sta	capture
     17  1c53		       45 92		      eor	currentPiece
     18  1c55		       10 03		      bpl	.invalid
     19  1c57		       20 70 f2 	      jsr	AddMove
     20  1c5a
     21  1c5a				   .invalid
     22  1c5a
      0  1c5a					      MOVE_TOWARDS	_LEFT
      1  1c5a					      SUBROUTINE
      2  1c5a
      3  1c5a
      4  1c5a
      5  1c5a		       a9 00		      lda	#0
      6  1c5c		       85 a0		      sta	capture
      7  1c5e
      8  1c5e		       a6 93		      ldx	currentSquare
      9  1c60		       d0 03		      bne	.project
     10  1c62
     11  1c62		       20 70 f2    .empty     jsr	AddMove
     12  1c65		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  1c68		       30 0e		      bmi	.invalid
     14  1c6a		       b9 79 fc 	      lda	Board,y
     15  1c6d		       f0 f3		      beq	.empty
     16  1c6f		       85 a0		      sta	capture
     17  1c71		       45 92		      eor	currentPiece
     18  1c73		       10 03		      bpl	.invalid
     19  1c75		       20 70 f2 	      jsr	AddMove
     20  1c78
     21  1c78				   .invalid
     22  1c78
     23  1c78
     24  1c78		       4c e9 f1 	      jmp	MoveReturn
     25  1c7b
     26  1c7b							;---------------------------------------------------------------------------------------------------
     27  1c7b							; EOF
------- FILE @1 PIECE HANDLER #2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  1c7b					      include	"PIECE_QUEEN.asm"
      1  1c7b							; Copyright (C)2020 Andrew Davie
      2  1c7b
      3  1c7b							;---------------------------------------------------------------------------------------------------
      4  1c7b							; QUEEN
      5  1c7b							;---------------------------------------------------------------------------------------------------
      6  1c7b
      0  1c7b					      DEF	Handle_QUEEN
      1  1c7b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  1c7b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  1c7b				   Handle_QUEEN
      4  1c7b				   TEMPORARY_VAR SET	Overlay
      5  1c7b				   TEMPORARY_OFFSET SET	0
      6  1c7b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  1c7b				   FUNCTION_NAME SET	Handle_QUEEN
      8  1c7b					      SUBROUTINE
      9  1c7b
      0  1c7b					      REF	GenerateAllMoves	;✅
      1  1c7b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1c7b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1c7b					      ENDIF
      0  1c7b					      VEND	Handle_QUEEN
      1  1c7b
      2  1c7b
      3  1c7b		       00 bb	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
      4  1c7b
     12  1c7b
     13  1c7b							; Pass...
     14  1c7b							; x = currentSquare (square the piece is on)
     15  1c7b							; currentPiece (with flags/colour attached)
     16  1c7b
      0  1c7b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  1c7b					      SUBROUTINE
      2  1c7b
      3  1c7b
      4  1c7b
      5  1c7b		       a9 00		      lda	#0
      6  1c7d		       85 a0		      sta	capture
      7  1c7f
      8  1c7f		       a6 93		      ldx	currentSquare
      9  1c81		       d0 03		      bne	.project
     10  1c83
     11  1c83		       20 70 f2    .empty     jsr	AddMove
     12  1c86		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  1c89		       30 0e		      bmi	.invalid
     14  1c8b		       b9 79 fc 	      lda	Board,y
     15  1c8e		       f0 f3		      beq	.empty
     16  1c90		       85 a0		      sta	capture
     17  1c92		       45 92		      eor	currentPiece
     18  1c94		       10 03		      bpl	.invalid
     19  1c96		       20 70 f2 	      jsr	AddMove
     20  1c99
     21  1c99				   .invalid
     22  1c99
      0  1c99					      MOVE_TOWARDS	_DOWN
      1  1c99					      SUBROUTINE
      2  1c99
      3  1c99
      4  1c99
      5  1c99		       a9 00		      lda	#0
      6  1c9b		       85 a0		      sta	capture
      7  1c9d
      8  1c9d		       a6 93		      ldx	currentSquare
      9  1c9f		       d0 03		      bne	.project
     10  1ca1
     11  1ca1		       20 70 f2    .empty     jsr	AddMove
     12  1ca4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  1ca7		       30 0e		      bmi	.invalid
     14  1ca9		       b9 79 fc 	      lda	Board,y
     15  1cac		       f0 f3		      beq	.empty
     16  1cae		       85 a0		      sta	capture
     17  1cb0		       45 92		      eor	currentPiece
     18  1cb2		       10 03		      bpl	.invalid
     19  1cb4		       20 70 f2 	      jsr	AddMove
     20  1cb7
     21  1cb7				   .invalid
     22  1cb7
      0  1cb7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  1cb7					      SUBROUTINE
      2  1cb7
      3  1cb7
      4  1cb7
      5  1cb7		       a9 00		      lda	#0
      6  1cb9		       85 a0		      sta	capture
      7  1cbb
      8  1cbb		       a6 93		      ldx	currentSquare
      9  1cbd		       d0 03		      bne	.project
     10  1cbf
     11  1cbf		       20 70 f2    .empty     jsr	AddMove
     12  1cc2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  1cc5		       30 0e		      bmi	.invalid
     14  1cc7		       b9 79 fc 	      lda	Board,y
     15  1cca		       f0 f3		      beq	.empty
     16  1ccc		       85 a0		      sta	capture
     17  1cce		       45 92		      eor	currentPiece
     18  1cd0		       10 03		      bpl	.invalid
     19  1cd2		       20 70 f2 	      jsr	AddMove
     20  1cd5
     21  1cd5				   .invalid
     22  1cd5
      0  1cd5					      MOVE_TOWARDS	_RIGHT
      1  1cd5					      SUBROUTINE
      2  1cd5
      3  1cd5
      4  1cd5
      5  1cd5		       a9 00		      lda	#0
      6  1cd7		       85 a0		      sta	capture
      7  1cd9
      8  1cd9		       a6 93		      ldx	currentSquare
      9  1cdb		       d0 03		      bne	.project
     10  1cdd
     11  1cdd		       20 70 f2    .empty     jsr	AddMove
     12  1ce0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  1ce3		       30 0e		      bmi	.invalid
     14  1ce5		       b9 79 fc 	      lda	Board,y
     15  1ce8		       f0 f3		      beq	.empty
     16  1cea		       85 a0		      sta	capture
     17  1cec		       45 92		      eor	currentPiece
     18  1cee		       10 03		      bpl	.invalid
     19  1cf0		       20 70 f2 	      jsr	AddMove
     20  1cf3
     21  1cf3				   .invalid
     22  1cf3
      0  1cf3					      MOVE_TOWARDS	_UP+_RIGHT
      1  1cf3					      SUBROUTINE
      2  1cf3
      3  1cf3
      4  1cf3
      5  1cf3		       a9 00		      lda	#0
      6  1cf5		       85 a0		      sta	capture
      7  1cf7
      8  1cf7		       a6 93		      ldx	currentSquare
      9  1cf9		       d0 03		      bne	.project
     10  1cfb
     11  1cfb		       20 70 f2    .empty     jsr	AddMove
     12  1cfe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  1d01		       30 0e		      bmi	.invalid
     14  1d03		       b9 79 fc 	      lda	Board,y
     15  1d06		       f0 f3		      beq	.empty
     16  1d08		       85 a0		      sta	capture
     17  1d0a		       45 92		      eor	currentPiece
     18  1d0c		       10 03		      bpl	.invalid
     19  1d0e		       20 70 f2 	      jsr	AddMove
     20  1d11
     21  1d11				   .invalid
     22  1d11
      0  1d11					      MOVE_TOWARDS	_UP
      1  1d11					      SUBROUTINE
      2  1d11
      3  1d11
      4  1d11
      5  1d11		       a9 00		      lda	#0
      6  1d13		       85 a0		      sta	capture
      7  1d15
      8  1d15		       a6 93		      ldx	currentSquare
      9  1d17		       d0 03		      bne	.project
     10  1d19
     11  1d19		       20 70 f2    .empty     jsr	AddMove
     12  1d1c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  1d1f		       30 0e		      bmi	.invalid
     14  1d21		       b9 79 fc 	      lda	Board,y
     15  1d24		       f0 f3		      beq	.empty
     16  1d26		       85 a0		      sta	capture
     17  1d28		       45 92		      eor	currentPiece
     18  1d2a		       10 03		      bpl	.invalid
     19  1d2c		       20 70 f2 	      jsr	AddMove
     20  1d2f
     21  1d2f				   .invalid
     22  1d2f
      0  1d2f					      MOVE_TOWARDS	_UP+_LEFT
      1  1d2f					      SUBROUTINE
      2  1d2f
      3  1d2f
      4  1d2f
      5  1d2f		       a9 00		      lda	#0
      6  1d31		       85 a0		      sta	capture
      7  1d33
      8  1d33		       a6 93		      ldx	currentSquare
      9  1d35		       d0 03		      bne	.project
     10  1d37
     11  1d37		       20 70 f2    .empty     jsr	AddMove
     12  1d3a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  1d3d		       30 0e		      bmi	.invalid
     14  1d3f		       b9 79 fc 	      lda	Board,y
     15  1d42		       f0 f3		      beq	.empty
     16  1d44		       85 a0		      sta	capture
     17  1d46		       45 92		      eor	currentPiece
     18  1d48		       10 03		      bpl	.invalid
     19  1d4a		       20 70 f2 	      jsr	AddMove
     20  1d4d
     21  1d4d				   .invalid
     22  1d4d
      0  1d4d					      MOVE_TOWARDS	_LEFT
      1  1d4d					      SUBROUTINE
      2  1d4d
      3  1d4d
      4  1d4d
      5  1d4d		       a9 00		      lda	#0
      6  1d4f		       85 a0		      sta	capture
      7  1d51
      8  1d51		       a6 93		      ldx	currentSquare
      9  1d53		       d0 03		      bne	.project
     10  1d55
     11  1d55		       20 70 f2    .empty     jsr	AddMove
     12  1d58		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  1d5b		       30 0e		      bmi	.invalid
     14  1d5d		       b9 79 fc 	      lda	Board,y
     15  1d60		       f0 f3		      beq	.empty
     16  1d62		       85 a0		      sta	capture
     17  1d64		       45 92		      eor	currentPiece
     18  1d66		       10 03		      bpl	.invalid
     19  1d68		       20 70 f2 	      jsr	AddMove
     20  1d6b
     21  1d6b				   .invalid
     22  1d6b
     25  1d6b
     26  1d6b		       4c e9 f1 	      jmp	MoveReturn
     27  1d6e
     28  1d6e							; EOF
------- FILE @1 PIECE HANDLER #2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  1d6e					      include	"PIECE_KING.asm"
      1  1d6e							; Copyright (C)2020 Andrew Davie
      2  1d6e
      3  1d6e							;---------------------------------------------------------------------------------------------------
      4  1d6e							; KING
      5  1d6e							; This is the move handler for a KING
      6  1d6e							; "Check" is detected in the next ply of the search.
      7  1d6e
      8  1d6e
      9  1d6e							;---------------------------------------------------------------------------------------------------
     10  1d6e
     11  1d6e							; MACRO - Castling
     12  1d6e
     13  1d6e		       00 03	   KINGSIDE   =	3
     14  1d6e		       ff ff ff fc QUEENSIDE  =	-4
     15  1d6e
     16  1d6e					      MAC	castle
     17  1d6e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  1d6e
     19  1d6e					      ldx	currentSquare
     20  1d6e					      lda	Board+{1},x	; kingside/queenside R position
     21  1d6e					      and	#PIECE_MASK|FLAG_MOVED
     22  1d6e					      cmp	#ROOK
     23  1d6e					      bne	.noCastle	; not a R that hasn't moved
     24  1d6e
     25  1d6e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  1d6e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  1d6e
     28  1d6e					      IF	{1} = QUEENSIDE
     29  1d6e					      lda	Board-3,x	; N pos
     30  1d6e					      ora	Board-2,x	; B pos
     31  1d6e					      ora	Board-1,x	; Q pos
     32  1d6e					      bne	.noCastle	; not vacant?
     33  1d6e
     34  1d6e					      ENDIF
     35  1d6e
     36  1d6e					      IF	{1} = KINGSIDE
     37  1d6e					      lda	Board+2,x	; N pos
     38  1d6e					      ora	Board+1,x	; B pos
     39  1d6e					      bne	.noCastle	; not vacant?
     40  1d6e					      ENDIF
     41  1d6e
     42  1d6e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  1d6e
     44  1d6e							; FINALLY -- king can castle
     45  1d6e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  1d6e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  1d6e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  1d6e
     49  1d6e					      lda	currentPiece
     50  1d6e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  1d6e					      sta	currentPiece
     52  1d6e
     53  1d6e					      IF	{1} = KINGSIDE
     54  1d6e					      ldy	ValidSquare+2,x
     55  1d6e					      ENDIF
     56  1d6e
     57  1d6e					      IF	{1} = QUEENSIDE
     58  1d6e					      ldy	ValidSquare-2,x
     59  1d6e					      ENDIF
     60  1d6e
     61  1d6e
     62  1d6e					      jsr	AddMove	; 57
     63  1d6e				   .noCastle
     64  1d6e					      ENDM
     65  1d6e
     66  1d6e
     67  1d6e							;---------------------------------------------------------------------------------------------------
     68  1d6e
      0  1d6e					      DEF	Handle_KING
      1  1d6e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  1d6e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  1d6e				   Handle_KING
      4  1d6e				   TEMPORARY_VAR SET	Overlay
      5  1d6e				   TEMPORARY_OFFSET SET	0
      6  1d6e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  1d6e				   FUNCTION_NAME SET	Handle_KING
     70  1d6e					      SUBROUTINE
     71  1d6e
      0  1d6e					      REF	GenerateAllMoves	;✅
      1  1d6e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1d6e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1d6e					      ENDIF
      0  1d6e					      VEND	Handle_KING
      1  1d6e
      2  1d6e
      3  1d6e		       00 bb	   VAREND_Handle_KING =	TEMPORARY_VAR
      4  1d6e
     74  1d6e
     75  1d6e							; x = currentSquare (square the KING is on)
     76  1d6e							; currentPiece (KING of course, but with flags/colour attached)
     77  1d6e
     78  1d6e
      0  1d6e					      MOVE_TO	_DOWN+_LEFT
      1  1d6e					      SUBROUTINE
      2  1d6e
      3  1d6e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      4  1d71		       30 0e		      bmi	.invalid
      5  1d73		       b9 79 fc 	      lda	Board,y
      6  1d76		       85 a0		      sta	capture
      7  1d78		       f0 04		      beq	.squareEmpty
      8  1d7a		       45 92		      eor	currentPiece
      9  1d7c		       10 03		      bpl	.invalid
     10  1d7e		       20 70 f2    .squareEmpty jsr	AddMove
     11  1d81				   .invalid
     12  1d81
     80  1d81					      IF	1
      0  1d81					      MOVE_TO_X	_DOWN
      1  1d81		       a6 93		      ldx	currentSquare
      0  1d83					      MOVE_TO	_DOWN
      1  1d83					      SUBROUTINE
      2  1d83
      3  1d83		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      4  1d86		       30 0e		      bmi	.invalid
      5  1d88		       b9 79 fc 	      lda	Board,y
      6  1d8b		       85 a0		      sta	capture
      7  1d8d		       f0 04		      beq	.squareEmpty
      8  1d8f		       45 92		      eor	currentPiece
      9  1d91		       10 03		      bpl	.invalid
     10  1d93		       20 70 f2    .squareEmpty jsr	AddMove
     11  1d96				   .invalid
     12  1d96
      0  1d96					      MOVE_TO_X	_DOWN+_RIGHT
      1  1d96		       a6 93		      ldx	currentSquare
      0  1d98					      MOVE_TO	_DOWN+_RIGHT
      1  1d98					      SUBROUTINE
      2  1d98
      3  1d98		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      4  1d9b		       30 0e		      bmi	.invalid
      5  1d9d		       b9 79 fc 	      lda	Board,y
      6  1da0		       85 a0		      sta	capture
      7  1da2		       f0 04		      beq	.squareEmpty
      8  1da4		       45 92		      eor	currentPiece
      9  1da6		       10 03		      bpl	.invalid
     10  1da8		       20 70 f2    .squareEmpty jsr	AddMove
     11  1dab				   .invalid
     12  1dab
      0  1dab					      MOVE_TO_X	_RIGHT
      1  1dab		       a6 93		      ldx	currentSquare
      0  1dad					      MOVE_TO	_RIGHT
      1  1dad					      SUBROUTINE
      2  1dad
      3  1dad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      4  1db0		       30 0e		      bmi	.invalid
      5  1db2		       b9 79 fc 	      lda	Board,y
      6  1db5		       85 a0		      sta	capture
      7  1db7		       f0 04		      beq	.squareEmpty
      8  1db9		       45 92		      eor	currentPiece
      9  1dbb		       10 03		      bpl	.invalid
     10  1dbd		       20 70 f2    .squareEmpty jsr	AddMove
     11  1dc0				   .invalid
     12  1dc0
      0  1dc0					      MOVE_TO_X	_UP+_RIGHT
      1  1dc0		       a6 93		      ldx	currentSquare
      0  1dc2					      MOVE_TO	_UP+_RIGHT
      1  1dc2					      SUBROUTINE
      2  1dc2
      3  1dc2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      4  1dc5		       30 0e		      bmi	.invalid
      5  1dc7		       b9 79 fc 	      lda	Board,y
      6  1dca		       85 a0		      sta	capture
      7  1dcc		       f0 04		      beq	.squareEmpty
      8  1dce		       45 92		      eor	currentPiece
      9  1dd0		       10 03		      bpl	.invalid
     10  1dd2		       20 70 f2    .squareEmpty jsr	AddMove
     11  1dd5				   .invalid
     12  1dd5
      0  1dd5					      MOVE_TO_X	_UP
      1  1dd5		       a6 93		      ldx	currentSquare
      0  1dd7					      MOVE_TO	_UP
      1  1dd7					      SUBROUTINE
      2  1dd7
      3  1dd7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      4  1dda		       30 0e		      bmi	.invalid
      5  1ddc		       b9 79 fc 	      lda	Board,y
      6  1ddf		       85 a0		      sta	capture
      7  1de1		       f0 04		      beq	.squareEmpty
      8  1de3		       45 92		      eor	currentPiece
      9  1de5		       10 03		      bpl	.invalid
     10  1de7		       20 70 f2    .squareEmpty jsr	AddMove
     11  1dea				   .invalid
     12  1dea
      0  1dea					      MOVE_TO_X	_UP+_LEFT
      1  1dea		       a6 93		      ldx	currentSquare
      0  1dec					      MOVE_TO	_UP+_LEFT
      1  1dec					      SUBROUTINE
      2  1dec
      3  1dec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      4  1def		       30 0e		      bmi	.invalid
      5  1df1		       b9 79 fc 	      lda	Board,y
      6  1df4		       85 a0		      sta	capture
      7  1df6		       f0 04		      beq	.squareEmpty
      8  1df8		       45 92		      eor	currentPiece
      9  1dfa		       10 03		      bpl	.invalid
     10  1dfc		       20 70 f2    .squareEmpty jsr	AddMove
     11  1dff				   .invalid
     12  1dff
      0  1dff					      MOVE_TO_X	_LEFT
      1  1dff		       a6 93		      ldx	currentSquare
      0  1e01					      MOVE_TO	_LEFT
      1  1e01					      SUBROUTINE
      2  1e01
      3  1e01		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      4  1e04		       30 0e		      bmi	.invalid
      5  1e06		       b9 79 fc 	      lda	Board,y
      6  1e09		       85 a0		      sta	capture
      7  1e0b		       f0 04		      beq	.squareEmpty
      8  1e0d		       45 92		      eor	currentPiece
      9  1e0f		       10 03		      bpl	.invalid
     10  1e11		       20 70 f2    .squareEmpty jsr	AddMove
     11  1e14				   .invalid
     12  1e14
     88  1e14					      ENDIF
     89  1e14
     90  1e14					      IF	CASTLING_ENABLED
     91  1e14
     92  1e14		       24 92		      bit	currentPiece
     93  1e16		       70 41		      bvs	.exit	; king has moved, so no castling
     94  1e18
      0  1e18					      CASTLE	KINGSIDE
      1  1e18
      2  1e18
      3  1e18		       a6 93		      ldx	currentSquare
      4  1e1a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  1e1d		       29 47		      and	#PIECE_MASK|FLAG_MOVED
      6  1e1f		       c9 05		      cmp	#ROOK
      7  1e21		       d0 14		      bne	.noCastle
      8  1e23
      9  1e23
     10  1e23
     11  1e23
     12  1e23				  -	      IF	KINGSIDE = QUEENSIDE
     13  1e23				  -	      lda	Board-3,x
     14  1e23				  -	      ora	Board-2,x
     15  1e23				  -	      ora	Board-1,x
     16  1e23				  -	      bne	.noCastle
     17  1e23				  -
     18  1e23					      ENDIF
     19  1e23
     20  1e23					      IF	KINGSIDE = KINGSIDE
     21  1e23		       bd 7b fc 	      lda	Board+2,x
     22  1e26		       1d 7a fc 	      ora	Board+1,x
     23  1e29		       d0 0c		      bne	.noCastle
     24  1e2b					      ENDIF
     25  1e2b
     26  1e2b
     27  1e2b
     28  1e2b
     29  1e2b
     30  1e2b
     31  1e2b
     32  1e2b
     33  1e2b		       a5 92		      lda	currentPiece
     34  1e2d		       09 10		      ora	#FLAG_CASTLE
     35  1e2f		       85 92		      sta	currentPiece
     36  1e31
     37  1e31					      IF	KINGSIDE = KINGSIDE
     38  1e31		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  1e34					      ENDIF
     40  1e34
     41  1e34				  -	      IF	KINGSIDE = QUEENSIDE
     42  1e34				  -	      ldy	ValidSquare-2,x
     43  1e34					      ENDIF
     44  1e34
     45  1e34
     46  1e34		       20 70 f2 	      jsr	AddMove
     47  1e37				   .noCastle
      0  1e37					      CASTLE	QUEENSIDE
      1  1e37
      2  1e37
      3  1e37		       a6 93		      ldx	currentSquare
      4  1e39		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  1e3c		       29 47		      and	#PIECE_MASK|FLAG_MOVED
      6  1e3e		       c9 05		      cmp	#ROOK
      7  1e40		       d0 17		      bne	.noCastle
      8  1e42
      9  1e42
     10  1e42
     11  1e42
     12  1e42					      IF	QUEENSIDE = QUEENSIDE
     13  1e42		       bd 76 fc 	      lda	Board-3,x
     14  1e45		       1d 77 fc 	      ora	Board-2,x
     15  1e48		       1d 78 fc 	      ora	Board-1,x
     16  1e4b		       d0 0c		      bne	.noCastle
     17  1e4d
     18  1e4d					      ENDIF
     19  1e4d
     20  1e4d				  -	      IF	QUEENSIDE = KINGSIDE
     21  1e4d				  -	      lda	Board+2,x
     22  1e4d				  -	      ora	Board+1,x
     23  1e4d				  -	      bne	.noCastle
     24  1e4d					      ENDIF
     25  1e4d
     26  1e4d
     27  1e4d
     28  1e4d
     29  1e4d
     30  1e4d
     31  1e4d
     32  1e4d
     33  1e4d		       a5 92		      lda	currentPiece
     34  1e4f		       09 10		      ora	#FLAG_CASTLE
     35  1e51		       85 92		      sta	currentPiece
     36  1e53
     37  1e53				  -	      IF	QUEENSIDE = KINGSIDE
     38  1e53				  -	      ldy	ValidSquare+2,x
     39  1e53					      ENDIF
     40  1e53
     41  1e53					      IF	QUEENSIDE = QUEENSIDE
     42  1e53		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  1e56					      ENDIF
     44  1e56
     45  1e56
     46  1e56		       20 70 f2 	      jsr	AddMove
     47  1e59				   .noCastle
     97  1e59
     98  1e59					      ENDIF
     99  1e59
    100  1e59
    101  1e59		       4c e9 f1    .exit      jmp	MoveReturn
    102  1e5c
    103  1e5c							;---------------------------------------------------------------------------------------------------
    104  1e5c							; EOF
------- FILE @1 PIECE HANDLER #2.asm
     17  1e5c
     18  1e5c							;---------------------------------------------------------------------------------------------------
     19  1e5c
      0  1e5c					      END_BANK
      1  1e5c				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  1e5c				  -	      CHECK_RAM_BANK_SIZE
      3  1e5c					      ELSE
      0  1e5c					      CHECK_BANK_SIZE
      1  1e5c		       02 5c	   .TEMP      =	* - _BANK_START
 ROM bank # 8 PIECE_HANDLER_2 size = $25c free = 419
      2  1e5c					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  1e5c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1e5c				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  1e5c				  -	      ERR
      6  1e5c					      ENDIF
      5  1e5c					      ENDIF
     21  1e5c
     22  1e5c							;---------------------------------------------------------------------------------------------------
     23  1e5c							; EOF
------- FILE ./chess.asm
    199  1e5c
------- FILE @2 SCREEN RAM.asm LEVEL 2 PASS 4
      0  1e5c					      include	"@2 SCREEN RAM.asm"
      1  1e5c							;---------------------------------------------------------------------------------------------------
      2  1e5c							; @2 SCREEN RAM.asm
      3  1e5c
      4  1e5c							; Atari 2600 Chess
      5  1e5c							; Copyright (c) 2019-2020 Andrew Davie
      6  1e5c							; andrew@taswegian.com
      7  1e5c
      8  1e5c
      9  1e5c							;---------------------------------------------------------------------------------------------------
     10  1e5c
      0  1e5c					      SLOT	2
      1  1e5c
      2  1e5c				  -	      IF	(2 < 0) || (2 > 3)
      3  1e5c				  -	      ECHO	"Illegal bank address/segment location", 2
      4  1e5c				  -	      ERR
      5  1e5c					      ENDIF
      6  1e5c
      7  1e5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  1e5c				   _BANK_SLOT SET	2 * 64
      9  1e5c
     12  1e5c					      REPEAT	CHESSBOARD_ROWS
      0  1e5c					      RAMBANK	CHESSBOARDROW
      1  1e5c
      2 U0e00 ????				      SEG.U	RAM_CHESSBOARDROW
      3 U0000					      ORG	ORIGIN_RAM
      4 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0000				   _BANK_START SET	*
      6 U0000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0000				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0000				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0000					      END_BANK
      1 U0000					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0000					      CHECK_RAM_BANK_SIZE
      1 U0000		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 1 CHESSBOARDROW size =  $0 free = $1ff
      2 U0000					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0000				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0000				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0000				  -	      ERR
      6 U0000					      ENDIF
      3 U0000				  -	      ELSE
      4 U0000				  -	      CHECK_BANK_SIZE
      5 U0000					      ENDIF
     12 U0000					      REPEND
      0 U0000					      RAMBANK	CHESSBOARDROW
      1 U0000
      2 U0000					      SEG.U	RAM_CHESSBOARDROW
      3 U0200					      ORG	ORIGIN_RAM
      4 U0200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0200				   _BANK_START SET	*
      6 U0200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0200				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0200				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0200					      END_BANK
      1 U0200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0200					      CHECK_RAM_BANK_SIZE
      1 U0200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 2 CHESSBOARDROW size =  $0 free = $1ff
      2 U0200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0200				  -	      ERR
      6 U0200					      ENDIF
      3 U0200				  -	      ELSE
      4 U0200				  -	      CHECK_BANK_SIZE
      5 U0200					      ENDIF
     12 U0200					      REPEND
      0 U0200					      RAMBANK	CHESSBOARDROW
      1 U0200
      2 U0200					      SEG.U	RAM_CHESSBOARDROW
      3 U0400					      ORG	ORIGIN_RAM
      4 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0400				   _BANK_START SET	*
      6 U0400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0400				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0400				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0400					      END_BANK
      1 U0400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0400					      CHECK_RAM_BANK_SIZE
      1 U0400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 3 CHESSBOARDROW size =  $0 free = $1ff
      2 U0400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0400				  -	      ERR
      6 U0400					      ENDIF
      3 U0400				  -	      ELSE
      4 U0400				  -	      CHECK_BANK_SIZE
      5 U0400					      ENDIF
     12 U0400					      REPEND
      0 U0400					      RAMBANK	CHESSBOARDROW
      1 U0400
      2 U0400					      SEG.U	RAM_CHESSBOARDROW
      3 U0600					      ORG	ORIGIN_RAM
      4 U0600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0600				   _BANK_START SET	*
      6 U0600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0600				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0600				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0600					      END_BANK
      1 U0600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0600					      CHECK_RAM_BANK_SIZE
      1 U0600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 4 CHESSBOARDROW size =  $0 free = $1ff
      2 U0600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0600				  -	      ERR
      6 U0600					      ENDIF
      3 U0600				  -	      ELSE
      4 U0600				  -	      CHECK_BANK_SIZE
      5 U0600					      ENDIF
     12 U0600					      REPEND
      0 U0600					      RAMBANK	CHESSBOARDROW
      1 U0600
      2 U0600					      SEG.U	RAM_CHESSBOARDROW
      3 U0800					      ORG	ORIGIN_RAM
      4 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0800				   _BANK_START SET	*
      6 U0800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0800				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0800				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0800				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0800					      END_BANK
      1 U0800					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0800					      CHECK_RAM_BANK_SIZE
      1 U0800		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 5 CHESSBOARDROW size =  $0 free = $1ff
      2 U0800					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0800				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0800				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0800				  -	      ERR
      6 U0800					      ENDIF
      3 U0800				  -	      ELSE
      4 U0800				  -	      CHECK_BANK_SIZE
      5 U0800					      ENDIF
     12 U0800					      REPEND
      0 U0800					      RAMBANK	CHESSBOARDROW
      1 U0800
      2 U0800					      SEG.U	RAM_CHESSBOARDROW
      3 U0a00					      ORG	ORIGIN_RAM
      4 U0a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0a00				   _BANK_START SET	*
      6 U0a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0a00				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0a00				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0a00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0a00					      END_BANK
      1 U0a00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0a00					      CHECK_RAM_BANK_SIZE
      1 U0a00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 6 CHESSBOARDROW size =  $0 free = $1ff
      2 U0a00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0a00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0a00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0a00				  -	      ERR
      6 U0a00					      ENDIF
      3 U0a00				  -	      ELSE
      4 U0a00				  -	      CHECK_BANK_SIZE
      5 U0a00					      ENDIF
     12 U0a00					      REPEND
      0 U0a00					      RAMBANK	CHESSBOARDROW
      1 U0a00
      2 U0a00					      SEG.U	RAM_CHESSBOARDROW
      3 U0c00					      ORG	ORIGIN_RAM
      4 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0c00				   _BANK_START SET	*
      6 U0c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0c00				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0c00				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0c00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0c00					      END_BANK
      1 U0c00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0c00					      CHECK_RAM_BANK_SIZE
      1 U0c00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 7 CHESSBOARDROW size =  $0 free = $1ff
      2 U0c00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0c00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0c00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0c00				  -	      ERR
      6 U0c00					      ENDIF
      3 U0c00				  -	      ELSE
      4 U0c00				  -	      CHECK_BANK_SIZE
      5 U0c00					      ENDIF
     12 U0c00					      REPEND
      0 U0c00					      RAMBANK	CHESSBOARDROW
      1 U0c00
      2 U0c00					      SEG.U	RAM_CHESSBOARDROW
      3 U0e00					      ORG	ORIGIN_RAM
      4 U0e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0e00				   _BANK_START SET	*
      6 U0e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0e00				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0e00				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0e00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0e00					      END_BANK
      1 U0e00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0e00					      CHECK_RAM_BANK_SIZE
      1 U0e00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 8 CHESSBOARDROW size =  $0 free = $1ff
      2 U0e00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0e00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0e00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0e00				  -	      ERR
      6 U0e00					      ENDIF
      3 U0e00				  -	      ELSE
      4 U0e00				  -	      CHECK_BANK_SIZE
      5 U0e00					      ENDIF
     15 U0e00					      REPEND
     16 U0e00
     17 U0e00
     18 U0e00							;---------------------------------------------------------------------------------------------------
     19 U0e00
     20 U0e00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
     21 U0e00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
     22 U0e00							; The variable definitions are also in that ROM bank (even though they're RAM :)
     23 U0e00
     24 U0e00							; Now we have the actual graphics data for each of the rows.  This consists of an
     25 U0e00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
     26 U0e00							; character shapes are masked/copied. The depth of the character shapes may be
     27 U0e00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
     28 U0e00							; a multiple of 3, so that the RGB scanlines match at character joins.
     29 U0e00
     30 U0e00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
     31 U0e00							; accessed via the above labels but with the appropriate bank switched in.
     32 U0e00
      0 U0e00					      ROMBANK	BITMAP
      1  21d9 ????				      SEG	ROM_BITMAP
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   BITMAP_START SET	*
      6  2000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2000				   ROMBANK_BITMAP SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2000				   _LAST_BANK SETSTR	BITMAP
     10  2000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     34  2000
     35  2000							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
     36  2000
     37  2000		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
     38  2000
     39  2000		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     40  2000		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     41  2000		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     42  2000		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     43  2000		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     44  2000		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     45  2000
     46  2000							; Template bank for a SINGLE ROW of the chessboard display.
     47  2000							; There are 8x of these.
     48  2000							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     49  2000							; The bank is copied from ROM into RAM at startup.
     50  2000							; The draw switches between consecutive row banks, with the last returning
     51  2000							; we effectively have 1K
     52  2000							;---------------------------------------------------------------------------------------------------
     53  2000
     54  2000							; NTSC
     55  2000
     56  2000		       00 00	   BW	      =	0
     57  2000		       00 01	   NTSC       =	1
     58  2000		       00 02	   PAL	      =	2
     59  2000
     60  2000
     61  2000
     62  2000		       00 02	   COL_TYPE   =	PAL
     63  2000
     64  2000
     65  2000
     66  2000				  -	      IF	COL_TYPE = NTSC
     67  2000				  -COLOUR_LINE_1 =	$84
     68  2000				  -COLOUR_LINE_2 =	$44
     69  2000				  -COLOUR_LINE_3 =	$D6
     70  2000					      ENDIF
     71  2000
     72  2000					      IF	COL_TYPE = PAL
     73  2000		       00 d4	   COLOUR_LINE_1 =	$D4	;86
     74  2000		       00 64	   COLOUR_LINE_2 =	$64	;46
     75  2000		       00 36	   COLOUR_LINE_3 =	$36	;D8
     76  2000					      ENDIF
     77  2000
     78  2000
     79  2000				  -	      IF	COL_TYPE = BW
     80  2000				  -COLOUR_LINE_1 =	$24	;86
     81  2000				  -COLOUR_LINE_2 =	$A2	;46
     82  2000				  -COLOUR_LINE_3 =	$94	;D8
     83  2000					      ENDIF
     84  2000
     85  2000
     86  2000		       00 00	   BACKGCOL   =	$0
     87  2000
     88  2000		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     89  2000
     90  2000
      0  2000					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      1  2000
      2  2000				   .NAME      SETSTR	SHADOW_ChessBitmap
      0  2000					      OPTIONAL_PAGEBREAK	.NAME, ROW_BITMAP_SIZE
      1  2000
      2  2000				  -	      IF	(>( * + ROW_BITMAP_SIZE -1 )) > ( >* )
      3  2000				  -.EARLY_LOCATION SET	*
      4  2000				  -	      ALIGN	256
      5  2000				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2000					      ENDIF
      0  2000					      DEF	SHADOW_ChessBitmap
      1  2000				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  2000				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  2000				   SHADOW_ChessBitmap
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	SHADOW_ChessBitmap
      5  2000
     92  2000		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     93  2018		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     94  2030		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     95  2048		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     96  2060		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     97  2078		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     98  2090
      0  2090					      ALLOCATE	BlankSprite, 8
      1  2090
      2  2090				   .NAME      SETSTR	BlankSprite
      0  2090					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  2090
      2  2090				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  2090				  -.EARLY_LOCATION SET	*
      4  2090				  -	      ALIGN	256
      5  2090				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2090					      ENDIF
      0  2090					      DEF	BlankSprite
      1  2090				   SLOT_BlankSprite SET	_BANK_SLOT
      2  2090				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  2090				   BlankSprite
      4  2090				   TEMPORARY_VAR SET	Overlay
      5  2090				   TEMPORARY_OFFSET SET	0
      6  2090				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  2090				   FUNCTION_NAME SET	BlankSprite
      5  2090
    100  2090		       00 00 00 00*	      ds	8, 0
    101  2098
      0  2098					      ALLOCATE	SpriteBuffer, 8
      1  2098
      2  2098				   .NAME      SETSTR	SpriteBuffer
      0  2098					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  2098
      2  2098				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  2098				  -.EARLY_LOCATION SET	*
      4  2098				  -	      ALIGN	256
      5  2098				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2098					      ENDIF
      0  2098					      DEF	SpriteBuffer
      1  2098				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  2098				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  2098				   SpriteBuffer
      4  2098				   TEMPORARY_VAR SET	Overlay
      5  2098				   TEMPORARY_OFFSET SET	0
      6  2098				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  2098				   FUNCTION_NAME SET	SpriteBuffer
      5  2098
    103  2098				   SpriteBuffer2
    104  2098		       f8		      .byte.b	%11111000
    105  2099		       f8		      .byte.b	%11111000
    106  209a		       f8		      .byte.b	%11111000
    107  209b		       f8		      .byte.b	%11111000
    108  209c		       f8		      .byte.b	%11111000
    109  209d		       f8		      .byte.b	%11111000
    110  209e		       f8		      .byte.b	%11111000
    111  209f		       f8		      .byte.b	%11111000
    112  20a0
    113  20a0							;---------------------------------------------------------------------------------------------------
    114  20a0
    115  20a0							;ALIGN 256
    116  20a0					      SUBROUTINE
    117  20a0
      0  20a0					      REF	StartupBankReset
      1  20a0				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  20a0				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  20a0					      ENDIF
    119  20a0							;__dummy
    120  20a0							;    VEND __dummy
    121  20a0
    122  20a0							; x = row # (and bank#)
    123  20a0
    124  20a0				   .endline
    125  20a0
    126  20a0							;@59
    127  20a0
    128  20a0							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
    129  20a0							; Note that the other 7 row banks are unmodified (keeping the 'inx')
    130  20a0				   SELFMOD_RTS_ON_LAST_ROW
    131  20a0
    132  20a0		       e8		      inx		; 2
    133  20a1		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
    134  20a3
      0  20a3					      DEF	DrawRow
      1  20a3				   SLOT_DrawRow SET	_BANK_SLOT
      2  20a3				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  20a3				   DrawRow
      4  20a3				   TEMPORARY_VAR SET	Overlay
      5  20a3				   TEMPORARY_OFFSET SET	0
      6  20a3				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  20a3				   FUNCTION_NAME SET	DrawRow
    136  20a3
    137  20a3
    138  20a3
    139  20a3							;@64
    140  20a3		       a0 07		      ldy	#7	; 2
    141  20a5		       10 3e		      bpl	.dl2	; 3   (must be 69 here)
    142  20a7
    143  20a7							;@58...
    144  20a7
    145  20a7				   .l3
    146  20a7
    147  20a7		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
    148  20aa		       85 5b		      sta	GRP0	; 3
    149  20ac		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
    150  20af		       85 5c		      sta	GRP1	; 3
    151  20b1
    152  20b1							;@-4
    153  20b1
    154  20b1		       a9 d4	   SMCOL1     lda	#COLOUR_LINE_1	;#$94			  ; 2
    155  20b3		       85 48		      sta	COLUPF	; 3 @1
    156  20b5		       29 f0		      and	#$F0
    157  20b7		       a9 00		      lda	#$0	;A0
    158  20b9		       85 49		      sta	COLUBK
    159  20bb
    160  20bb		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    161  20be		       85 4d		      sta	PF0	; 3
    162  20c0		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    163  20c3		       85 4e		      sta	PF1	; 3
    164  20c5		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    165  20c8		       85 4f		      sta	PF2	; 3 @22
    166  20ca
    167  20ca							;SLEEP 6		      ; 6 @28
    168  20ca
    169  20ca		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    170  20cd		       85 4d		      sta	PF0	; 3
    171  20cf		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    172  20d2		       85 4e		      sta	PF1	; 3
    173  20d4		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    174  20d7		       8d 4f 00 	      sta.w	PF2	; 4 @50
    175  20da
      0  20da					      SLEEP	3	; 4
      1  20da				   .CYCLES    SET	3
      2  20da
      3  20da				  -	      IF	.CYCLES < 2
      4  20da				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20da				  -	      ERR
      6  20da					      ENDIF
      7  20da
      8  20da					      IF	.CYCLES & 1
      9  20da					      IFNCONST	NO_ILLEGAL_OPCODES
     10  20da		       04 00		      nop	0
     11  20dc				  -	      ELSE
     12  20dc				  -	      bit	VSYNC
     13  20dc					      ENDIF
     14  20dc				   .CYCLES    SET	.CYCLES - 3
     15  20dc					      ENDIF
     16  20dc
     17  20dc				  -	      REPEAT	.CYCLES / 2
     18  20dc				  -	      nop
     19  20dc					      REPEND
    177  20dc
    178  20dc		       88		      dey		; 2
    179  20dd		       30 c1		      bmi	.endline	; 2 (3)
    180  20df
    181  20df							;@57
    182  20df				   .drawLine
    183  20df
      0  20df					      SLEEP	11
      1  20df				   .CYCLES    SET	11
      2  20df
      3  20df				  -	      IF	.CYCLES < 2
      4  20df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20df				  -	      ERR
      6  20df					      ENDIF
      7  20df
      8  20df					      IF	.CYCLES & 1
      9  20df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  20df		       04 00		      nop	0
     11  20e1				  -	      ELSE
     12  20e1				  -	      bit	VSYNC
     13  20e1					      ENDIF
     14  20e1				   .CYCLES    SET	.CYCLES - 3
     15  20e1					      ENDIF
     16  20e1
     17  20e1					      REPEAT	.CYCLES / 2
     18  20e1		       ea		      nop
     17  20e1					      REPEND
     18  20e2		       ea		      nop
     17  20e2					      REPEND
     18  20e3		       ea		      nop
     17  20e3					      REPEND
     18  20e4		       ea		      nop
     19  20e5					      REPEND
    185  20e5
    186  20e5				   .dl2
    187  20e5		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    188  20e8		       85 5b		      sta	GRP0	; 3
    189  20ea		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    190  20ed		       85 5c		      sta	GRP1	; 3
    191  20ef
    192  20ef							;@7
    193  20ef
    194  20ef		       a9 64	   SMCOL2     lda	#COLOUR_LINE_2	;#$4A			  ; 2
    195  20f1		       85 48		      sta	COLUPF	; 3 @12
    196  20f3
    197  20f3		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    198  20f6		       85 4d		      sta	PF0	; 3
    199  20f8		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    200  20fb		       85 4e		      sta	PF1	; 3
    201  20fd		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    202  2100		       85 4f		      sta	PF2	; 3 @33
    203  2102
      0  2102					      SLEEP	3	; 3 @36
      1  2102				   .CYCLES    SET	3
      2  2102
      3  2102				  -	      IF	.CYCLES < 2
      4  2102				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2102				  -	      ERR
      6  2102					      ENDIF
      7  2102
      8  2102					      IF	.CYCLES & 1
      9  2102					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2102		       04 00		      nop	0
     11  2104				  -	      ELSE
     12  2104				  -	      bit	VSYNC
     13  2104					      ENDIF
     14  2104				   .CYCLES    SET	.CYCLES - 3
     15  2104					      ENDIF
     16  2104
     17  2104				  -	      REPEAT	.CYCLES / 2
     18  2104				  -	      nop
     19  2104					      REPEND
    205  2104
    206  2104		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    207  2107		       85 4d		      sta	PF0	; 3
    208  2109		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    209  210c		       85 4e		      sta	PF1	; 3
    210  210e		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    211  2111		       85 4f		      sta	PF2	; 3 @57
    212  2113
      0  2113					      SLEEP	5
      1  2113				   .CYCLES    SET	5
      2  2113
      3  2113				  -	      IF	.CYCLES < 2
      4  2113				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2113				  -	      ERR
      6  2113					      ENDIF
      7  2113
      8  2113					      IF	.CYCLES & 1
      9  2113					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2113		       04 00		      nop	0
     11  2115				  -	      ELSE
     12  2115				  -	      bit	VSYNC
     13  2115					      ENDIF
     14  2115				   .CYCLES    SET	.CYCLES - 3
     15  2115					      ENDIF
     16  2115
     17  2115					      REPEAT	.CYCLES / 2
     18  2115		       ea		      nop
     19  2116					      REPEND
    214  2116
    215  2116		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    216  2119		       85 5b		      sta	GRP0	; 3
    217  211b		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    218  211e		       85 5c		      sta	GRP1	; 3
    219  2120
    220  2120							;@0
    221  2120		       a9 36	   SMCOL3     lda	#COLOUR_LINE_3	;#$28			  ; 2
    222  2122		       85 48		      sta	COLUPF	; 3 @5
    223  2124
    224  2124		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    225  2127		       85 4d		      sta	PF0	; 3
    226  2129		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    227  212c		       85 4e		      sta	PF1	; 3
    228  212e		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    229  2131		       85 4f		      sta	PF2	; 3 @26
    230  2133
      0  2133					      SLEEP	8	; 6 @34
      1  2133				   .CYCLES    SET	8
      2  2133
      3  2133				  -	      IF	.CYCLES < 2
      4  2133				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2133				  -	      ERR
      6  2133					      ENDIF
      7  2133
      8  2133				  -	      IF	.CYCLES & 1
      9  2133				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2133				  -	      nop	0
     11  2133				  -	      ELSE
     12  2133				  -	      bit	VSYNC
     13  2133				  -	      ENDIF
     14  2133				  -.CYCLES    SET	.CYCLES - 3
     15  2133					      ENDIF
     16  2133
     17  2133					      REPEAT	.CYCLES / 2
     18  2133		       ea		      nop
     17  2133					      REPEND
     18  2134		       ea		      nop
     17  2134					      REPEND
     18  2135		       ea		      nop
     17  2135					      REPEND
     18  2136		       ea		      nop
     19  2137					      REPEND
    232  2137
    233  2137		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    234  213a		       85 4d		      sta	PF0	; 3
    235  213c		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    236  213f		       85 4e		      sta	PF1	; 3
    237  2141		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    238  2144		       85 4f		      sta	PF2	; 3 @55
    239  2146
    240  2146		       4c a7 f8 	      jmp	.l3	; 3 @58
    241  2149
    242  2149
    243  2149							;---------------------------------------------------------------------------------------------------
    244  2149
      0  2149					      DEF	BackupBitmap
      1  2149				   SLOT_BackupBitmap SET	_BANK_SLOT
      2  2149				   BANK_BackupBitmap SET	SLOT_BackupBitmap + _CURRENT_BANK
      3  2149				   BackupBitmap
      4  2149				   TEMPORARY_VAR SET	Overlay
      5  2149				   TEMPORARY_OFFSET SET	0
      6  2149				   VAR_BOUNDARY_BackupBitmap SET	TEMPORARY_OFFSET
      7  2149				   FUNCTION_NAME SET	BackupBitmap
    246  2149		       00 00 00 00*	      ds	ROW_BITMAP_SIZE, 0
    247  21d9
    248  21d9
    249  21d9							;---------------------------------------------------------------------------------------------------
    250  21d9
      0  21d9					      CHECK_RAM_BANK_SIZE
      1  21d9		       01 d9	   .TEMP      =	* - _BANK_START
 RAM bank # 8 BITMAP size =  $1d9 free = $26
      2  21d9					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3  21d9				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  21d9				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5  21d9				  -	      ERR
      6  21d9					      ENDIF
    252  21d9
    253  21d9							;---------------------------------------------------------------------------------------------------
    254  21d9							;EOF
------- FILE ./chess.asm
------- FILE @2 PLY.asm LEVEL 2 PASS 4
      0  21d9					      include	"@2 PLY.asm"
      1  21d9							;---------------------------------------------------------------------------------------------------
      2  21d9							; @2 PLY.asm
      3  21d9
      4  21d9							; Atari 2600 Chess
      5  21d9							; Copyright (c) 2019-2020 Andrew Davie
      6  21d9							; andrew@taswegian.com
      7  21d9
      8  21d9
      9  21d9							;---------------------------------------------------------------------------------------------------
     10  21d9							; Define the RAM banks
     11  21d9							; A "PLY" bank represents all the data required on any single ply of the search tree.
     12  21d9							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     13  21d9							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     14  21d9							; they act as independant switchable banks usable for data on each ply during the search.
     15  21d9							; A ply will hold the move list for that position
     16  21d9
     17  21d9
      0  21d9					      SLOT	2
      1  21d9
      2  21d9				  -	      IF	(2 < 0) || (2 > 3)
      3  21d9				  -	      ECHO	"Illegal bank address/segment location", 2
      4  21d9				  -	      ERR
      5  21d9					      ENDIF
      6  21d9
      7  21d9				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  21d9				   _BANK_SLOT SET	2 * 64
      9  21d9
      0  21d9					      RAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  21d9
      2 U11dd ????				      SEG.U	RAM_PLY
      3 U1000					      ORG	ORIGIN_RAM
      4 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1000				   _BANK_START SET	*
      6 U1000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1000				   RAMBANK_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1000				   _LAST_BANK SETSTR	PLY
     10 U1000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
     20 U1000
     21 U1000							;---------------------------------------------------------------------------------------------------
     22 U1000
     23 U1000		       00 64	   MAX_MOVES  =	100	; big is good
     24 U1000
      0 U1000					      VARIABLE	MoveFrom, MAX_MOVES
      1 U1000
      2 U1000				   .NAME      SETSTR	MoveFrom
      0 U1000					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1000
      2 U1000				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1000				  -.EARLY_LOCATION SET	*
      4 U1000				  -	      ALIGN	256
      5 U1000				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1000					      ENDIF
      4 U1000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      5 U1064
      0 U1064					      VARIABLE	MoveTo, MAX_MOVES
      1 U1064
      2 U1064				   .NAME      SETSTR	MoveTo
      0 U1064					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1064
      2 U1064				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1064				  -.EARLY_LOCATION SET	*
      4 U1064				  -	      ALIGN	256
      5 U1064				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1064					      ENDIF
      4 U1064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      5 U10c8
      0 U10c8					      VARIABLE	MovePiece, MAX_MOVES
      1 U10c8
      2 U10c8				   .NAME      SETSTR	MovePiece
      0 U10c8					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U10c8
      2 U10c8					      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U10c8				   .EARLY_LOCATION SET	*
      4 U1100		       00 00 00 00*	      ALIGN	256
 Page break for wasted 56 bytes
      5 U1100					      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1100					      ENDIF
      4 U1100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      5 U1164
      0 U1164					      VARIABLE	MoveCapture, MAX_MOVES
      1 U1164
      2 U1164				   .NAME      SETSTR	MoveCapture
      0 U1164					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1164
      2 U1164				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1164				  -.EARLY_LOCATION SET	*
      4 U1164				  -	      ALIGN	256
      5 U1164				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1164					      ENDIF
      4 U1164		       00 00 00 00*MoveCapture ds	MAX_MOVES
      5 U11c8
     29 U11c8
     30 U11c8
     31 U11c8							;---------------------------------------------------------------------------------------------------
     32 U11c8
     33 U11c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     34 U11c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     35 U11c8
      0 U11c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      1 U11c8
      2 U11c8				   .NAME      SETSTR	savedEvaluation
      0 U11c8					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11c8
      2 U11c8				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11c8				  -.EARLY_LOCATION SET	*
      4 U11c8				  -	      ALIGN	256
      5 U11c8				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11c8					      ENDIF
      4 U11c8		       00 00	   savedEvaluation ds	2
      5 U11ca
      0 U11ca					      VARIABLE	enPassantSquare, 1
      1 U11ca
      2 U11ca				   .NAME      SETSTR	enPassantSquare
      0 U11ca					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11ca
      2 U11ca				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11ca				  -.EARLY_LOCATION SET	*
      4 U11ca				  -	      ALIGN	256
      5 U11ca				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11ca					      ENDIF
      4 U11ca		       00	   enPassantSquare ds	1
      5 U11cb
      0 U11cb					      VARIABLE	capturedPiece, 1
      1 U11cb
      2 U11cb				   .NAME      SETSTR	capturedPiece
      0 U11cb					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cb
      2 U11cb				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cb				  -.EARLY_LOCATION SET	*
      4 U11cb				  -	      ALIGN	256
      5 U11cb				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cb					      ENDIF
      4 U11cb		       00	   capturedPiece ds	1
      5 U11cc
     39 U11cc							;VARIABLE originalPiece, 1
      0 U11cc					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      1 U11cc
      2 U11cc				   .NAME      SETSTR	secondaryPiece
      0 U11cc					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cc
      2 U11cc				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cc				  -.EARLY_LOCATION SET	*
      4 U11cc				  -	      ALIGN	256
      5 U11cc				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cc					      ENDIF
      4 U11cc		       00	   secondaryPiece ds	1
      5 U11cd
      0 U11cd					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      1 U11cd
      2 U11cd				   .NAME      SETSTR	secondarySquare
      0 U11cd					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cd
      2 U11cd				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cd				  -.EARLY_LOCATION SET	*
      4 U11cd				  -	      ALIGN	256
      5 U11cd				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cd					      ENDIF
      4 U11cd		       00	   secondarySquare ds	1
      5 U11ce
      0 U11ce					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      1 U11ce
      2 U11ce				   .NAME      SETSTR	secondaryBlank
      0 U11ce					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11ce
      2 U11ce				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11ce				  -.EARLY_LOCATION SET	*
      4 U11ce				  -	      ALIGN	256
      5 U11ce				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11ce					      ENDIF
      4 U11ce		       00	   secondaryBlank ds	1
      5 U11cf
      0 U11cf					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      1 U11cf
      2 U11cf				   .NAME      SETSTR	moveIndex
      0 U11cf					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cf
      2 U11cf				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cf				  -.EARLY_LOCATION SET	*
      4 U11cf				  -	      ALIGN	256
      5 U11cf				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cf					      ENDIF
      4 U11cf		       00	   moveIndex  ds	1
      5 U11d0
      0 U11d0					      VARIABLE	movePtr, 1
      1 U11d0
      2 U11d0				   .NAME      SETSTR	movePtr
      0 U11d0					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d0
      2 U11d0				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d0				  -.EARLY_LOCATION SET	*
      4 U11d0				  -	      ALIGN	256
      5 U11d0				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d0					      ENDIF
      4 U11d0		       00	   movePtr    ds	1
      5 U11d1
      0 U11d1					      VARIABLE	bestMove, 1
      1 U11d1
      2 U11d1				   .NAME      SETSTR	bestMove
      0 U11d1					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d1
      2 U11d1				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d1				  -.EARLY_LOCATION SET	*
      4 U11d1				  -	      ALIGN	256
      5 U11d1				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d1					      ENDIF
      4 U11d1		       00	   bestMove   ds	1
      5 U11d2
      0 U11d2					      VARIABLE	alpha, 2
      1 U11d2
      2 U11d2				   .NAME      SETSTR	alpha
      0 U11d2					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11d2
      2 U11d2				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11d2				  -.EARLY_LOCATION SET	*
      4 U11d2				  -	      ALIGN	256
      5 U11d2				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d2					      ENDIF
      4 U11d2		       00 00	   alpha      ds	2
      5 U11d4
      0 U11d4					      VARIABLE	beta, 2
      1 U11d4
      2 U11d4				   .NAME      SETSTR	beta
      0 U11d4					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11d4
      2 U11d4				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11d4				  -.EARLY_LOCATION SET	*
      4 U11d4				  -	      ALIGN	256
      5 U11d4				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d4					      ENDIF
      4 U11d4		       00 00	   beta       ds	2
      5 U11d6
      0 U11d6					      VARIABLE	value, 2
      1 U11d6
      2 U11d6				   .NAME      SETSTR	value
      0 U11d6					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11d6
      2 U11d6				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11d6				  -.EARLY_LOCATION SET	*
      4 U11d6				  -	      ALIGN	256
      5 U11d6				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d6					      ENDIF
      4 U11d6		       00 00	   value      ds	2
      5 U11d8
      0 U11d8					      VARIABLE	depthLeft, 1
      1 U11d8
      2 U11d8				   .NAME      SETSTR	depthLeft
      0 U11d8					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d8
      2 U11d8				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d8				  -.EARLY_LOCATION SET	*
      4 U11d8				  -	      ALIGN	256
      5 U11d8				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d8					      ENDIF
      4 U11d8		       00	   depthLeft  ds	1
      5 U11d9
      0 U11d9					      VARIABLE	restorePiece, 1
      1 U11d9
      2 U11d9				   .NAME      SETSTR	restorePiece
      0 U11d9					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d9
      2 U11d9				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d9				  -.EARLY_LOCATION SET	*
      4 U11d9				  -	      ALIGN	256
      5 U11d9				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d9					      ENDIF
      4 U11d9		       00	   restorePiece ds	1
      5 U11da
      0 U11da					      VARIABLE	virtualKingSquare, 2	; traversing squares for castle/check
      1 U11da
      2 U11da				   .NAME      SETSTR	virtualKingSquare
      0 U11da					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11da
      2 U11da				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11da				  -.EARLY_LOCATION SET	*
      4 U11da				  -	      ALIGN	256
      5 U11da				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11da					      ENDIF
      4 U11da		       00 00	   virtualKingSquare ds	2
      5 U11dc
      0 U11dc					      VARIABLE	inCheck, 1
      1 U11dc
      2 U11dc				   .NAME      SETSTR	inCheck
      0 U11dc					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11dc
      2 U11dc				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11dc				  -.EARLY_LOCATION SET	*
      4 U11dc				  -	      ALIGN	256
      5 U11dc				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11dc					      ENDIF
      4 U11dc		       00	   inCheck    ds	1
      5 U11dd
     53 U11dd
      0 U11dd					      END_BANK
      1 U11dd					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U11dd					      CHECK_RAM_BANK_SIZE
      1 U11dd		       01 dd	   .TEMP      =	* - _BANK_START
 RAM bank # 9 PLY size =  $1dd free = $22
      2 U11dd					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U11dd				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U11dd				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U11dd				  -	      ERR
      6 U11dd					      ENDIF
      3 U11dd				  -	      ELSE
      4 U11dd				  -	      CHECK_BANK_SIZE
      5 U11dd					      ENDIF
     55 U11dd
     56 U11dd
     57 U11dd					      REPEAT	PLY_BANKS-1
      0 U11dd					      RAMBANK	.DUMMY_PLY
      1 U11dd
      2 U4200 ????				      SEG.U	RAM_.DUMMY_PLY
      3 U1200					      ORG	ORIGIN_RAM
      4 U1200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1200				   _BANK_START SET	*
      6 U1200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1200				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1200					      END_BANK
      1 U1200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1200					      CHECK_RAM_BANK_SIZE
      1 U1200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 10 .DUMMY_PLY size =  $0 free = $1ff
      2 U1200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1200				  -	      ERR
      6 U1200					      ENDIF
      3 U1200				  -	      ELSE
      4 U1200				  -	      CHECK_BANK_SIZE
      5 U1200					      ENDIF
     57 U1200					      REPEND
      0 U1200					      RAMBANK	.DUMMY_PLY
      1 U1200
      2 U1200					      SEG.U	RAM_.DUMMY_PLY
      3 U1400					      ORG	ORIGIN_RAM
      4 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1400				   _BANK_START SET	*
      6 U1400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1400				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1400					      END_BANK
      1 U1400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1400					      CHECK_RAM_BANK_SIZE
      1 U1400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 11 .DUMMY_PLY size =  $0 free = $1ff
      2 U1400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1400				  -	      ERR
      6 U1400					      ENDIF
      3 U1400				  -	      ELSE
      4 U1400				  -	      CHECK_BANK_SIZE
      5 U1400					      ENDIF
     57 U1400					      REPEND
      0 U1400					      RAMBANK	.DUMMY_PLY
      1 U1400
      2 U1400					      SEG.U	RAM_.DUMMY_PLY
      3 U1600					      ORG	ORIGIN_RAM
      4 U1600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1600				   _BANK_START SET	*
      6 U1600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1600				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1600				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1600					      END_BANK
      1 U1600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1600					      CHECK_RAM_BANK_SIZE
      1 U1600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 12 .DUMMY_PLY size =  $0 free = $1ff
      2 U1600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1600				  -	      ERR
      6 U1600					      ENDIF
      3 U1600				  -	      ELSE
      4 U1600				  -	      CHECK_BANK_SIZE
      5 U1600					      ENDIF
     57 U1600					      REPEND
      0 U1600					      RAMBANK	.DUMMY_PLY
      1 U1600
      2 U1600					      SEG.U	RAM_.DUMMY_PLY
      3 U1800					      ORG	ORIGIN_RAM
      4 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1800				   _BANK_START SET	*
      6 U1800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1800				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1800				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1800					      END_BANK
      1 U1800					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1800					      CHECK_RAM_BANK_SIZE
      1 U1800		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 13 .DUMMY_PLY size =  $0 free = $1ff
      2 U1800					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1800				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1800				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1800				  -	      ERR
      6 U1800					      ENDIF
      3 U1800				  -	      ELSE
      4 U1800				  -	      CHECK_BANK_SIZE
      5 U1800					      ENDIF
     57 U1800					      REPEND
      0 U1800					      RAMBANK	.DUMMY_PLY
      1 U1800
      2 U1800					      SEG.U	RAM_.DUMMY_PLY
      3 U1a00					      ORG	ORIGIN_RAM
      4 U1a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1a00				   _BANK_START SET	*
      6 U1a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1a00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1a00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1a00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1a00					      END_BANK
      1 U1a00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1a00					      CHECK_RAM_BANK_SIZE
      1 U1a00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 14 .DUMMY_PLY size =  $0 free = $1ff
      2 U1a00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1a00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1a00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1a00				  -	      ERR
      6 U1a00					      ENDIF
      3 U1a00				  -	      ELSE
      4 U1a00				  -	      CHECK_BANK_SIZE
      5 U1a00					      ENDIF
     57 U1a00					      REPEND
      0 U1a00					      RAMBANK	.DUMMY_PLY
      1 U1a00
      2 U1a00					      SEG.U	RAM_.DUMMY_PLY
      3 U1c00					      ORG	ORIGIN_RAM
      4 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1c00				   _BANK_START SET	*
      6 U1c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1c00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1c00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1c00					      END_BANK
      1 U1c00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1c00					      CHECK_RAM_BANK_SIZE
      1 U1c00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 15 .DUMMY_PLY size =  $0 free = $1ff
      2 U1c00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1c00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1c00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1c00				  -	      ERR
      6 U1c00					      ENDIF
      3 U1c00				  -	      ELSE
      4 U1c00				  -	      CHECK_BANK_SIZE
      5 U1c00					      ENDIF
     57 U1c00					      REPEND
      0 U1c00					      RAMBANK	.DUMMY_PLY
      1 U1c00
      2 U1c00					      SEG.U	RAM_.DUMMY_PLY
      3 U1e00					      ORG	ORIGIN_RAM
      4 U1e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1e00				   _BANK_START SET	*
      6 U1e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1e00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1e00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1e00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1e00					      END_BANK
      1 U1e00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1e00					      CHECK_RAM_BANK_SIZE
      1 U1e00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 16 .DUMMY_PLY size =  $0 free = $1ff
      2 U1e00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1e00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1e00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1e00				  -	      ERR
      6 U1e00					      ENDIF
      3 U1e00				  -	      ELSE
      4 U1e00				  -	      CHECK_BANK_SIZE
      5 U1e00					      ENDIF
     57 U1e00					      REPEND
      0 U1e00					      RAMBANK	.DUMMY_PLY
      1 U1e00
      2 U1e00					      SEG.U	RAM_.DUMMY_PLY
      3 U2000					      ORG	ORIGIN_RAM
      4 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2000				   _BANK_START SET	*
      6 U2000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2000				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2000					      END_BANK
      1 U2000					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2000					      CHECK_RAM_BANK_SIZE
      1 U2000		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 17 .DUMMY_PLY size =  $0 free = $1ff
      2 U2000					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2000				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2000				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2000				  -	      ERR
      6 U2000					      ENDIF
      3 U2000				  -	      ELSE
      4 U2000				  -	      CHECK_BANK_SIZE
      5 U2000					      ENDIF
     57 U2000					      REPEND
      0 U2000					      RAMBANK	.DUMMY_PLY
      1 U2000
      2 U2000					      SEG.U	RAM_.DUMMY_PLY
      3 U2200					      ORG	ORIGIN_RAM
      4 U2200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2200				   _BANK_START SET	*
      6 U2200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2200				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2200					      END_BANK
      1 U2200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2200					      CHECK_RAM_BANK_SIZE
      1 U2200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 18 .DUMMY_PLY size =  $0 free = $1ff
      2 U2200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2200				  -	      ERR
      6 U2200					      ENDIF
      3 U2200				  -	      ELSE
      4 U2200				  -	      CHECK_BANK_SIZE
      5 U2200					      ENDIF
     57 U2200					      REPEND
      0 U2200					      RAMBANK	.DUMMY_PLY
      1 U2200
      2 U2200					      SEG.U	RAM_.DUMMY_PLY
      3 U2400					      ORG	ORIGIN_RAM
      4 U2400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2400				   _BANK_START SET	*
      6 U2400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2400				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2400					      END_BANK
      1 U2400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2400					      CHECK_RAM_BANK_SIZE
      1 U2400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 19 .DUMMY_PLY size =  $0 free = $1ff
      2 U2400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2400				  -	      ERR
      6 U2400					      ENDIF
      3 U2400				  -	      ELSE
      4 U2400				  -	      CHECK_BANK_SIZE
      5 U2400					      ENDIF
     57 U2400					      REPEND
      0 U2400					      RAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400					      SEG.U	RAM_.DUMMY_PLY
      3 U2600					      ORG	ORIGIN_RAM
      4 U2600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2600				   _BANK_START SET	*
      6 U2600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2600				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2600				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2600					      END_BANK
      1 U2600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2600					      CHECK_RAM_BANK_SIZE
      1 U2600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 20 .DUMMY_PLY size =  $0 free = $1ff
      2 U2600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2600				  -	      ERR
      6 U2600					      ENDIF
      3 U2600				  -	      ELSE
      4 U2600				  -	      CHECK_BANK_SIZE
      5 U2600					      ENDIF
     57 U2600					      REPEND
      0 U2600					      RAMBANK	.DUMMY_PLY
      1 U2600
      2 U2600					      SEG.U	RAM_.DUMMY_PLY
      3 U2800					      ORG	ORIGIN_RAM
      4 U2800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2800				   _BANK_START SET	*
      6 U2800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2800				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2800				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2800					      END_BANK
      1 U2800					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2800					      CHECK_RAM_BANK_SIZE
      1 U2800		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 21 .DUMMY_PLY size =  $0 free = $1ff
      2 U2800					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2800				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2800				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2800				  -	      ERR
      6 U2800					      ENDIF
      3 U2800				  -	      ELSE
      4 U2800				  -	      CHECK_BANK_SIZE
      5 U2800					      ENDIF
     60 U2800					      REPEND
     61 U2800
     62 U2800
     63 U2800							;---------------------------------------------------------------------------------------------------
     64 U2800							; EOF
------- FILE ./chess.asm
------- FILE @2 PLY2.asm LEVEL 2 PASS 4
      0 U2800					      include	"@2 PLY2.asm"
      0 U2800					      SLOT	2
      1 U2800
      2 U2800				  -	      IF	(2 < 0) || (2 > 3)
      3 U2800				  -	      ECHO	"Illegal bank address/segment location", 2
      4 U2800				  -	      ERR
      5 U2800					      ENDIF
      6 U2800
      7 U2800				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8 U2800				   _BANK_SLOT SET	2 * 64
      9 U2800
      0 U2800					      RAMBANK	SORT
      1 U2800
      2 U2ac8 ????				      SEG.U	RAM_SORT
      3 U2a00					      ORG	ORIGIN_RAM
      4 U2a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2a00				   _BANK_START SET	*
      6 U2a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2a00				   RAMBANK_SORT SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2a00				   _LAST_BANK SETSTR	SORT
     10 U2a00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      3 U2a00
      4 U2a00							;---------------------------------------------------------------------------------------------------
      5 U2a00
      0 U2a00					      VARIABLE	MoveValueLO, MAX_MOVES
      1 U2a00
      2 U2a00				   .NAME      SETSTR	MoveValueLO
      0 U2a00					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U2a00
      2 U2a00				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U2a00				  -.EARLY_LOCATION SET	*
      4 U2a00				  -	      ALIGN	256
      5 U2a00				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U2a00					      ENDIF
      4 U2a00		       00 00 00 00*MoveValueLO ds	MAX_MOVES
      5 U2a64
      0 U2a64					      VARIABLE	MoveValueHI, MAX_MOVES
      1 U2a64
      2 U2a64				   .NAME      SETSTR	MoveValueHI
      0 U2a64					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U2a64
      2 U2a64				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U2a64				  -.EARLY_LOCATION SET	*
      4 U2a64				  -	      ALIGN	256
      5 U2a64				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U2a64					      ENDIF
      4 U2a64		       00 00 00 00*MoveValueHI ds	MAX_MOVES
      5 U2ac8
      8 U2ac8
      9 U2ac8							;---------------------------------------------------------------------------------------------------
     10 U2ac8
      0 U2ac8					      END_BANK
      1 U2ac8					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2ac8					      CHECK_RAM_BANK_SIZE
      1 U2ac8		       00 c8	   .TEMP      =	* - _BANK_START
 RAM bank # 22 SORT size =  $c8 free = $137
      2 U2ac8					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2ac8				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2ac8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2ac8				  -	      ERR
      6 U2ac8					      ENDIF
      3 U2ac8				  -	      ELSE
      4 U2ac8				  -	      CHECK_BANK_SIZE
      5 U2ac8					      ENDIF
     12 U2ac8
     13 U2ac8							;---------------------------------------------------------------------------------------------------
     14 U2ac8
     15 U2ac8					      REPEAT	PLY_BANKS-1
      0 U2ac8					      RAMBANK	.DUMMY_PLY
      1 U2ac8
      2 U2800					      SEG.U	RAM_.DUMMY_PLY
      3 U2c00					      ORG	ORIGIN_RAM
      4 U2c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2c00				   _BANK_START SET	*
      6 U2c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2c00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2c00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2c00					      END_BANK
      1 U2c00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2c00					      CHECK_RAM_BANK_SIZE
      1 U2c00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 23 .DUMMY_PLY size =  $0 free = $1ff
      2 U2c00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2c00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2c00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2c00				  -	      ERR
      6 U2c00					      ENDIF
      3 U2c00				  -	      ELSE
      4 U2c00				  -	      CHECK_BANK_SIZE
      5 U2c00					      ENDIF
     15 U2c00					      REPEND
      0 U2c00					      RAMBANK	.DUMMY_PLY
      1 U2c00
      2 U2c00					      SEG.U	RAM_.DUMMY_PLY
      3 U2e00					      ORG	ORIGIN_RAM
      4 U2e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2e00				   _BANK_START SET	*
      6 U2e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2e00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2e00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2e00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2e00					      END_BANK
      1 U2e00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2e00					      CHECK_RAM_BANK_SIZE
      1 U2e00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 24 .DUMMY_PLY size =  $0 free = $1ff
      2 U2e00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2e00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2e00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2e00				  -	      ERR
      6 U2e00					      ENDIF
      3 U2e00				  -	      ELSE
      4 U2e00				  -	      CHECK_BANK_SIZE
      5 U2e00					      ENDIF
     15 U2e00					      REPEND
      0 U2e00					      RAMBANK	.DUMMY_PLY
      1 U2e00
      2 U2e00					      SEG.U	RAM_.DUMMY_PLY
      3 U3000					      ORG	ORIGIN_RAM
      4 U3000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U3000				   _BANK_START SET	*
      6 U3000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U3000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U3000				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U3000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U3000					      END_BANK
      1 U3000					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U3000					      CHECK_RAM_BANK_SIZE
      1 U3000		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 25 .DUMMY_PLY size =  $0 free = $1ff
      2 U3000					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U3000				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U3000				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U3000				  -	      ERR
      6 U3000					      ENDIF
      3 U3000				  -	      ELSE
      4 U3000				  -	      CHECK_BANK_SIZE
      5 U3000					      ENDIF
     15 U3000					      REPEND
      0 U3000					      RAMBANK	.DUMMY_PLY
      1 U3000
      2 U3000					      SEG.U	RAM_.DUMMY_PLY
      3 U3200					      ORG	ORIGIN_RAM
      4 U3200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U3200				   _BANK_START SET	*
      6 U3200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U3200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U3200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U3200				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U3200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U3200					      END_BANK
      1 U3200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U3200					      CHECK_RAM_BANK_SIZE
      1 U3200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 26 .DUMMY_PLY size =  $0 free = $1ff
      2 U3200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U3200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U3200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U3200				  -	      ERR
      6 U3200					      ENDIF
      3 U3200				  -	      ELSE
      4 U3200				  -	      CHECK_BANK_SIZE
      5 U3200					      ENDIF
     15 U3200					      REPEND
      0 U3200					      RAMBANK	.DUMMY_PLY
      1 U3200
      2 U3200					      SEG.U	RAM_.DUMMY_PLY
      3 U3400					      ORG	ORIGIN_RAM
      4 U3400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U3400				   _BANK_START SET	*
      6 U3400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U3400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U3400				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U3400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U3400					      END_BANK
      1 U3400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U3400					      CHECK_RAM_BANK_SIZE
      1 U3400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 27 .DUMMY_PLY size =  $0 free = $1ff
      2 U3400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U3400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U3400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U3400				  -	      ERR
      6 U3400					      ENDIF
      3 U3400				  -	      ELSE
      4 U3400				  -	      CHECK_BANK_SIZE
      5 U3400					      ENDIF
     15 U3400					      REPEND
      0 U3400					      RAMBANK	.DUMMY_PLY
      1 U3400
      2 U3400					      SEG.U	RAM_.DUMMY_PLY
      3 U3600					      ORG	ORIGIN_RAM
      4 U3600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U3600				   _BANK_START SET	*
      6 U3600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U3600				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U3600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U3600				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U3600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U3600					      END_BANK
      1 U3600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U3600					      CHECK_RAM_BANK_SIZE
      1 U3600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 28 .DUMMY_PLY size =  $0 free = $1ff
      2 U3600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U3600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U3600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U3600				  -	      ERR
      6 U3600					      ENDIF
      3 U3600				  -	      ELSE
      4 U3600				  -	      CHECK_BANK_SIZE
      5 U3600					      ENDIF
     15 U3600					      REPEND
      0 U3600					      RAMBANK	.DUMMY_PLY
      1 U3600
      2 U3600					      SEG.U	RAM_.DUMMY_PLY
      3 U3800					      ORG	ORIGIN_RAM
      4 U3800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U3800				   _BANK_START SET	*
      6 U3800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U3800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U3800				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U3800				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U3800					      END_BANK
      1 U3800					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U3800					      CHECK_RAM_BANK_SIZE
      1 U3800		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 29 .DUMMY_PLY size =  $0 free = $1ff
      2 U3800					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U3800				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U3800				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U3800				  -	      ERR
      6 U3800					      ENDIF
      3 U3800				  -	      ELSE
      4 U3800				  -	      CHECK_BANK_SIZE
      5 U3800					      ENDIF
     15 U3800					      REPEND
      0 U3800					      RAMBANK	.DUMMY_PLY
      1 U3800
      2 U3800					      SEG.U	RAM_.DUMMY_PLY
      3 U3a00					      ORG	ORIGIN_RAM
      4 U3a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U3a00				   _BANK_START SET	*
      6 U3a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U3a00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U3a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U3a00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U3a00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U3a00					      END_BANK
      1 U3a00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U3a00					      CHECK_RAM_BANK_SIZE
      1 U3a00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 30 .DUMMY_PLY size =  $0 free = $1ff
      2 U3a00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U3a00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U3a00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U3a00				  -	      ERR
      6 U3a00					      ENDIF
      3 U3a00				  -	      ELSE
      4 U3a00				  -	      CHECK_BANK_SIZE
      5 U3a00					      ENDIF
     15 U3a00					      REPEND
      0 U3a00					      RAMBANK	.DUMMY_PLY
      1 U3a00
      2 U3a00					      SEG.U	RAM_.DUMMY_PLY
      3 U3c00					      ORG	ORIGIN_RAM
      4 U3c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U3c00				   _BANK_START SET	*
      6 U3c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U3c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U3c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U3c00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U3c00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U3c00					      END_BANK
      1 U3c00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U3c00					      CHECK_RAM_BANK_SIZE
      1 U3c00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 31 .DUMMY_PLY size =  $0 free = $1ff
      2 U3c00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U3c00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U3c00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U3c00				  -	      ERR
      6 U3c00					      ENDIF
      3 U3c00				  -	      ELSE
      4 U3c00				  -	      CHECK_BANK_SIZE
      5 U3c00					      ENDIF
     15 U3c00					      REPEND
      0 U3c00					      RAMBANK	.DUMMY_PLY
      1 U3c00
      2 U3c00					      SEG.U	RAM_.DUMMY_PLY
      3 U3e00					      ORG	ORIGIN_RAM
      4 U3e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U3e00				   _BANK_START SET	*
      6 U3e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U3e00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U3e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U3e00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U3e00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U3e00					      END_BANK
      1 U3e00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U3e00					      CHECK_RAM_BANK_SIZE
      1 U3e00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 32 .DUMMY_PLY size =  $0 free = $1ff
      2 U3e00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U3e00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U3e00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U3e00				  -	      ERR
      6 U3e00					      ENDIF
      3 U3e00				  -	      ELSE
      4 U3e00				  -	      CHECK_BANK_SIZE
      5 U3e00					      ENDIF
     15 U3e00					      REPEND
      0 U3e00					      RAMBANK	.DUMMY_PLY
      1 U3e00
      2 U3e00					      SEG.U	RAM_.DUMMY_PLY
      3 U4000					      ORG	ORIGIN_RAM
      4 U4000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U4000				   _BANK_START SET	*
      6 U4000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U4000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U4000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U4000				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U4000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U4000					      END_BANK
      1 U4000					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U4000					      CHECK_RAM_BANK_SIZE
      1 U4000		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 33 .DUMMY_PLY size =  $0 free = $1ff
      2 U4000					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U4000				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U4000				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U4000				  -	      ERR
      6 U4000					      ENDIF
      3 U4000				  -	      ELSE
      4 U4000				  -	      CHECK_BANK_SIZE
      5 U4000					      ENDIF
     15 U4000					      REPEND
      0 U4000					      RAMBANK	.DUMMY_PLY
      1 U4000
      2 U4000					      SEG.U	RAM_.DUMMY_PLY
      3 U4200					      ORG	ORIGIN_RAM
      4 U4200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U4200				   _BANK_START SET	*
      6 U4200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U4200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U4200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U4200				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U4200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U4200					      END_BANK
      1 U4200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U4200					      CHECK_RAM_BANK_SIZE
      1 U4200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 34 .DUMMY_PLY size =  $0 free = $1ff
      2 U4200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U4200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U4200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U4200				  -	      ERR
      6 U4200					      ENDIF
      3 U4200				  -	      ELSE
      4 U4200				  -	      CHECK_BANK_SIZE
      5 U4200					      ENDIF
     18 U4200					      REPEND
     19 U4200
     20 U4200
     21 U4200							;---------------------------------------------------------------------------------------------------
     22 U4200							; EOF
     23 U4200
------- FILE ./chess.asm
------- FILE @2 GENERIC #3.asm LEVEL 2 PASS 4
      0 U4200					      include	"@2 GENERIC #3.asm"
      1 U4200							;---------------------------------------------------------------------------------------------------
      2 U4200							; @2 GENERIC #3.asm
      3 U4200
      4 U4200							; Atari 2600 Chess
      5 U4200							; Copyright (c) 2019-2020 Andrew Davie
      6 U4200							; andrew@taswegian.com
      7 U4200
      8 U4200
      9 U4200							;---------------------------------------------------------------------------------------------------
     10 U4200
      0 U4200					      SLOT	2
      1 U4200
      2 U4200				  -	      IF	(2 < 0) || (2 > 3)
      3 U4200				  -	      ECHO	"Illegal bank address/segment location", 2
      4 U4200				  -	      ERR
      5 U4200					      ENDIF
      6 U4200
      7 U4200				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8 U4200				   _BANK_SLOT SET	2 * 64
      9 U4200
      0 U4200					      ROMBANK	GENERIC_BANK@2#1
      1  2799 ????				      SEG	ROM_GENERIC_BANK@2#1
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   GENERIC_BANK@2#1_START SET	*
      6  2400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2400				   ROMBANK_GENERIC_BANK@2#1 SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2400				   _LAST_BANK SETSTR	GENERIC_BANK@2#1
     10  2400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  2400
     14  2400							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
     15  2400
     16  2400				  -	      IF	PLUSCART = YES
     17  2400				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     18  2400				  -	      .byte	"pluscart.firmaplus.de", #0
     19  2400					      ENDIF
     20  2400
     21  2400		       54 4a 33 45 STELLA_AUTODETECT dc	"TJ3E"	; 3E+ autodetect
     22  2404
     23  2404
     24  2404							;---------------------------------------------------------------------------------------------------
     25  2404
      0  2404					      DEF	tidySc
      1  2404				   SLOT_tidySc SET	_BANK_SLOT
      2  2404				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  2404				   tidySc
      4  2404				   TEMPORARY_VAR SET	Overlay
      5  2404				   TEMPORARY_OFFSET SET	0
      6  2404				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  2404				   FUNCTION_NAME SET	tidySc
     27  2404					      SUBROUTINE
     28  2404
      0  2404					      REF	StartupBankReset	;✅
      1  2404				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  2404				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  2404					      ENDIF
      0  2404					      VEND	tidySc
      1  2404
      2  2404
      3  2404		       00 a7	   VAREND_tidySc =	TEMPORARY_VAR
      4  2404
     31  2404
     32  2404		       a9 00		      lda	#0
     33  2406		       85 4d		      sta	PF0
     34  2408		       85 4e		      sta	PF1
     35  240a		       85 4f		      sta	PF2
     36  240c		       85 5b		      sta	GRP0
     37  240e		       85 49		      sta	COLUBK
     38  2410
     39  2410		       a9 42		      lda	#%01000010	; bit6 is not required
     40  2412							;sta VBLANK			  ; end of screen - enter blanking
     41  2412
     42  2412							; END OF VISIBLE SCREEN
     43  2412							; HERE'S SOME TIME TO DO STUFF
     44  2412
     45  2412							;		      lda #TIME_PART_2
     46  2412							;		      sta TIM64T
     47  2412
     48  2412		       a6 a5		      ldx	platform
     49  2414		       bd 1b f8 	      lda	time64b,x
     50  2417		       8d 96 02 	      sta	TIM64T
     51  241a		       60		      rts
     52  241b
     53  241b				   time64b
     54  241b		       2e 38		      .byte.b	TIME_PART_2, TIME_PART_2_PAL
     55  241d
     56  241d
     57  241d							;---------------------------------------------------------------------------------------------------
     58  241d
      0  241d					      DEF	longD
      1  241d				   SLOT_longD SET	_BANK_SLOT
      2  241d				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  241d				   longD
      4  241d				   TEMPORARY_VAR SET	Overlay
      5  241d				   TEMPORARY_OFFSET SET	0
      6  241d				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  241d				   FUNCTION_NAME SET	longD
     60  241d					      SUBROUTINE
     61  241d
      0  241d					      REF	StartupBankReset	;✅
      1  241d				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  241d				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  241d					      ENDIF
      0  241d					      VEND	longD
      1  241d
      2  241d
      3  241d		       00 a7	   VAREND_longD =	TEMPORARY_VAR
      4  241d
     64  241d
     65  241d		       85 42		      sta	WSYNC
     66  241f
     67  241f		       20 30 f8 	      jsr	_rts
     68  2422		       20 30 f8 	      jsr	_rts
     69  2425		       20 30 f8 	      jsr	_rts
      0  2428					      SLEEP	7
      1  2428				   .CYCLES    SET	7
      2  2428
      3  2428				  -	      IF	.CYCLES < 2
      4  2428				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2428				  -	      ERR
      6  2428					      ENDIF
      7  2428
      8  2428					      IF	.CYCLES & 1
      9  2428					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2428		       04 00		      nop	0
     11  242a				  -	      ELSE
     12  242a				  -	      bit	VSYNC
     13  242a					      ENDIF
     14  242a				   .CYCLES    SET	.CYCLES - 3
     15  242a					      ENDIF
     16  242a
     17  242a					      REPEAT	.CYCLES / 2
     18  242a		       ea		      nop
     17  242a					      REPEND
     18  242b		       ea		      nop
     19  242c					      REPEND
     71  242c
     72  242c		       a2 00		      ldx	#0
     73  242e		       86 41		      stx	VBLANK
     74  2430		       60	   _rts       rts
     75  2431
     76  2431
     77  2431							;---------------------------------------------------------------------------------------------------
     78  2431
      0  2431					      DEF	aiStartClearBoard
      1  2431				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  2431				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  2431				   aiStartClearBoard
      4  2431				   TEMPORARY_VAR SET	Overlay
      5  2431				   TEMPORARY_OFFSET SET	0
      6  2431				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  2431				   FUNCTION_NAME SET	aiStartClearBoard
     80  2431					      SUBROUTINE
     81  2431
      0  2431					      REF	AiStateMachine	;✅
      1  2431					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2431				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2431					      ENDIF
      0  2431					      VEND	aiStartClearBoard
      1  2431
      2  2431
      3  2431		       00 a9	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
      4  2431
     84  2431
     85  2431		       a2 08		      ldx	#8
     86  2433		       86 85		      stx	drawCount	; = bank
     87  2435
     88  2435		       a9 ff		      lda	#-1
     89  2437		       85 89		      sta	cursorX12
     90  2439
      0  2439					      PHASE	ClearEachRow
      1  2439		       a9 0e		      lda	#AI_ClearEachRow
      2  243b		       85 8c		      sta	aiState
     92  243d		       60		      rts
     93  243e
     94  243e
     95  243e							;---------------------------------------------------------------------------------------------------
     96  243e
      0  243e					      DEF	aiClearEachRow
      1  243e				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  243e				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  243e				   aiClearEachRow
      4  243e				   TEMPORARY_VAR SET	Overlay
      5  243e				   TEMPORARY_OFFSET SET	0
      6  243e				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  243e				   FUNCTION_NAME SET	aiClearEachRow
     98  243e					      SUBROUTINE
     99  243e
      0  243e					      REF	AiStateMachine	;✅
      1  243e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  243e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  243e					      ENDIF
      0  243e					      VEND	aiClearEachRow
      1  243e
      2  243e
      3  243e		       00 a9	   VAREND_aiClearEachRow =	TEMPORARY_VAR
      4  243e
    102  243e
    103  243e		       c6 85		      dec	drawCount
    104  2440		       30 0e		      bmi	.bitmapCleared
    105  2442
    106  2442							; switch in RAM bank for ROW
    107  2442
    108  2442		       a5 85		      lda	drawCount
    109  2444		       09 40		      ora	#SLOT1
    110  2446		       85 3e		      sta	SET_BANK_RAM	;@1
    111  2448
      0  2448					      CALL	ClearRowBitmap	;@3
      1  2448				  -	      IF	SLOT_ClearRowBitmap == _BANK_SLOT
      2  2448				  -FNAME      SETSTR	ClearRowBitmap
      3  2448				  -	      ECHO	""
      4  2448				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  2448				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  2448				  -	      ERR
      7  2448					      ENDIF
      8  2448		       a9 da		      lda	#BANK_ClearRowBitmap
      9  244a		       85 3f		      sta	SET_BANK
     10  244c		       20 00 fc 	      jsr	ClearRowBitmap
    113  244f		       60		      rts
    114  2450
    115  2450				   .bitmapCleared
    116  2450
    117  2450
    118  2450		       a9 63		      lda	#99
    119  2452		       85 81		      sta	squareToDraw
    120  2454
      0  2454					      PHASE	DrawEntireBoard
      1  2454		       a9 0f		      lda	#AI_DrawEntireBoard
      2  2456		       85 8c		      sta	aiState
    122  2458		       60		      rts
    123  2459
    124  2459
    125  2459							;---------------------------------------------------------------------------------------------------
    126  2459
      0  2459					      DEF	aiMoveIsSelected
      1  2459				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  2459				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  2459				   aiMoveIsSelected
      4  2459				   TEMPORARY_VAR SET	Overlay
      5  2459				   TEMPORARY_OFFSET SET	0
      6  2459				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  2459				   FUNCTION_NAME SET	aiMoveIsSelected
    128  2459					      SUBROUTINE
    129  2459
      0  2459					      REF	COMMON_VARS
      1  2459					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  2459				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  2459					      ENDIF
      0  2459					      REF	AiStateMachine	;✅
      1  2459				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2459				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2459					      ENDIF
      0  2459					      VEND	aiMoveIsSelected
      1  2459
      2  2459
      3  2459		       00 b7	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
      4  2459
    133  2459
    134  2459
    135  2459							; Both computer and human have now seleted a move, and converge here
    136  2459
    137  2459
    138  2459							; fromPiece	 piece doing the move
    139  2459							; fromX12	 current square X12
    140  2459							; originX12	 starting square X12
    141  2459							; toX12	 ending square X12
    142  2459
    143  2459		       20 80 f8 	      jsr	EnPassantFixupDraw
    144  245c
    145  245c							; get the piece types from the board
    146  245c
    147  245c		       a9 e3		      lda	#RAMBANK_BOARD
    148  245e		       85 3e		      sta	SET_BANK_RAM	;@3
    149  2460		       a4 88		      ldy	originX12
    150  2462		       b9 79 fc 	      lda	Board,y
    151  2465		       85 b3		      sta	__originalPiece
    152  2467		       a4 87		      ldy	toX12
    153  2469		       b9 79 fc 	      lda	Board,y
    154  246c		       85 b4		      sta	__capturedPiece
    155  246e
    156  246e							;TODO: what about castling...?
    157  246e
    158  246e		       20 ea f8 	      jsr	AdjustMaterialPositionalValue	;@this
    159  2471
    160  2471
    161  2471
    162  2471		       a9 00		      lda	#0
    163  2473		       85 99		      sta	previousPiece
    164  2475		       85 83		      sta	drawDelay
    165  2477
    166  2477		       a9 0a		      lda	#10	; on/off count
    167  2479		       85 85		      sta	drawCount	; flashing for piece about to move
    168  247b
      0  247b					      PHASE	WriteStartPieceBlank
      1  247b		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  247d		       85 8c		      sta	aiState
    170  247f		       60	   .idleErase rts
    171  2480
    172  2480
    173  2480							;---------------------------------------------------------------------------------------------------
    174  2480
      0  2480					      DEF	EnPassantFixupDraw
      1  2480				   SLOT_EnPassantFixupDraw SET	_BANK_SLOT
      2  2480				   BANK_EnPassantFixupDraw SET	SLOT_EnPassantFixupDraw + _CURRENT_BANK
      3  2480				   EnPassantFixupDraw
      4  2480				   TEMPORARY_VAR SET	Overlay
      5  2480				   TEMPORARY_OFFSET SET	0
      6  2480				   VAR_BOUNDARY_EnPassantFixupDraw SET	TEMPORARY_OFFSET
      7  2480				   FUNCTION_NAME SET	EnPassantFixupDraw
    176  2480					      SUBROUTINE
    177  2480
    178  2480							; {
    179  2480							; With en-passant flag, it is essentially dual-use.
    180  2480							; First, it marks if the move is *involved* somehow in an en-passant
    181  2480							; if the piece has MOVED already, then it's an en-passant capture
    182  2480							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    183  2480
    184  2480		       a2 00		      ldx	#0	; (probably) NO en-passant this time
    185  2482
    186  2482		       a5 97		      lda	fromPiece
    187  2484		       a8		      tay
    188  2485
    189  2485		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    190  2487		       c9 20		      cmp	#FLAG_ENPASSANT
    191  2489		       d0 11		      bne	.noep	; HAS moved, or not en-passant
    192  248b
    193  248b		       45 97		      eor	fromPiece	; clear FLAG_ENPASSANT
    194  248d		       85 97		      sta	fromPiece
    195  248f
    196  248f		       a6 87		      ldx	toX12	; this IS an en-passantable opening, so record the square
    197  2491
    198  2491							; set the secondary piece movement info - this allows move/unmakemove to work for enpassant
    199  2491
    200  2491		       a9 00		      lda	#0
      0  2493					      sta@PLY	secondaryBlank
      1  2493		       8d ce fb 	      sta	[RAM]+secondaryBlank
      0  2496					      stx@PLY	secondarySquare
      1  2496		       8e cd fb 	      stx	[RAM]+secondarySquare
      0  2499					      sty@PLY	secondaryPiece
      1  2499		       8c cc fb 	      sty	[RAM]+secondaryPiece
    204  249c
    205  249c				   .noep
    206  249c		       86 94		      stx	enPassantPawn	; capturable square for en-passant move (or none)
    207  249e							; }
    208  249e
    209  249e		       60		      rts
    210  249f
    211  249f							;---------------------------------------------------------------------------------------------------
    212  249f
      0  249f					      DEF	CopySetup
      1  249f				   SLOT_CopySetup SET	_BANK_SLOT
      2  249f				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  249f				   CopySetup
      4  249f				   TEMPORARY_VAR SET	Overlay
      5  249f				   TEMPORARY_OFFSET SET	0
      6  249f				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  249f				   FUNCTION_NAME SET	CopySetup
    214  249f					      SUBROUTINE
    215  249f
      0  249f					      REF	CopySinglePiece	;✅
      1  249f					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  249f				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  249f					      ENDIF
    217  249f
      0  249f					      VAR	__tmp, 1
      1  249f		       00 ef	   __tmp      =	TEMPORARY_VAR
      2  249f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  249f
      4  249f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  249f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  249f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  249f					      ENDIF
      8  249f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  249f				  -VNAME      SETSTR	__tmp
     10  249f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  249f				  -	      ERR
     12  249f					      ENDIF
      0  249f					      VAR	__shiftx, 1
      1  249f		       00 f0	   __shiftx   =	TEMPORARY_VAR
      2  249f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  249f
      4  249f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  249f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  249f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  249f					      ENDIF
      8  249f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  249f				  -VNAME      SETSTR	__shiftx
     10  249f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  249f				  -	      ERR
     12  249f					      ENDIF
      0  249f					      VAR	__pieceColour2, 1
      1  249f		       00 f1	   __pieceColour2 =	TEMPORARY_VAR
      2  249f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  249f
      4  249f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  249f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  249f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  249f					      ENDIF
      8  249f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  249f				  -VNAME      SETSTR	__pieceColour2
     10  249f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  249f				  -	      ERR
     12  249f					      ENDIF
    221  249f
      0  249f					      VEND	CopySetup
      1  249f
      2  249f
      3  249f		       00 f2	   VAREND_CopySetup =	TEMPORARY_VAR
      4  249f
    223  249f
    224  249f							; figure colouration of square
    225  249f
    226  249f		       a5 81		      lda	squareToDraw
    227  24a1
    228  24a1				  -	      IF	DIAGNOSTICS
    229  24a1				  -			; Catch out-of-range piece square
    230  24a1				  -			; will not catch off left/right edge
    231  24a1				  -
    232  24a1				  -.fail      cmp	#100
    233  24a1				  -	      bcs	.fail
    234  24a1				  -	      cmp	#22
    235  24a1				  -	      bcc	.fail
    236  24a1					      ENDIF
    237  24a1
    238  24a1
    239  24a1		       a2 0a		      ldx	#10
    240  24a3		       38		      sec
    241  24a4		       e9 0a	   .sub10     sbc	#10
    242  24a6		       ca		      dex
    243  24a7		       b0 fb		      bcs	.sub10
    244  24a9		       69 08		      adc	#8
    245  24ab		       85 f0		      sta	__shiftx
    246  24ad				  -	      IF	DIAGNOSTICS
    247  24ad				  -.fail2     cmp	#8
    248  24ad				  -	      bcs	.fail2
    249  24ad				  -	      cpx	#8
    250  24ad				  -	      bcs	.fail2
    251  24ad					      ENDIF
    252  24ad		       86 ef		      stx	__tmp
    253  24af		       65 ef		      adc	__tmp
    254  24b1
    255  24b1
    256  24b1		       29 01		      and	#1
    257  24b3		       49 01		      eor	#1
    258  24b5		       f0 02		      beq	.white
    259  24b7		       a9 24		      lda	#36
    260  24b9				   .white
    261  24b9		       85 f1		      sta	__pieceColour2	; actually SQUARE black/white
    262  24bb
    263  24bb							; PieceColour = 0 for white square, 36 for black square
    264  24bb
    265  24bb		       a9 e3		      lda	#RAMBANK_BOARD
    266  24bd		       85 3e		      sta	SET_BANK_RAM	;@3
    267  24bf
    268  24bf		       a4 81		      ldy	squareToDraw
    269  24c1		       b9 79 fc 	      lda	Board,y
    270  24c4							;and #$87
    271  24c4		       0a		      asl
    272  24c5		       90 02		      bcc	.blackAdjust
    273  24c7		       09 10		      ora	#16	; switch white pieces
    274  24c9		       4a	   .blackAdjust lsr
    275  24ca		       29 0f		      and	#%1111
    276  24cc		       aa		      tax
    277  24cd
    278  24cd		       a5 f0		      lda	__shiftx
    279  24cf		       29 03		      and	#3	; shift position in P
    280  24d1
    281  24d1		       18		      clc
    282  24d2		       7d da f8 	      adc	PieceToShape,x
    283  24d5		       18		      clc
    284  24d6		       65 f1		      adc	__pieceColour2
    285  24d8		       a8		      tay
    286  24d9		       60		      rts
    287  24da
    288  24da				   PieceToShape
    289  24da
    290  24da		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    291  24db		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    292  24dc		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    293  24dd		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    294  24de		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    295  24df		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    296  24e0		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    297  24e1		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    298  24e2
    299  24e2		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    300  24e3		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    301  24e4		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    302  24e5		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    303  24e6		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    304  24e7		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    305  24e8		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    306  24e9		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    307  24ea
    308  24ea
    309  24ea							;---------------------------------------------------------------------------------------------------
    310  24ea
      0  24ea					      DEF	AdjustMaterialPositionalValue
      1  24ea				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  24ea				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  24ea				   AdjustMaterialPositionalValue
      4  24ea				   TEMPORARY_VAR SET	Overlay
      5  24ea				   TEMPORARY_OFFSET SET	0
      6  24ea				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  24ea				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    312  24ea					      SUBROUTINE
    313  24ea
    314  24ea							; A move is about to be made, so  adjust material and positional values based on from/to and
    315  24ea							; capture.
    316  24ea
    317  24ea							; First, nominate referencing subroutines so that local variables can be adjusted properly
    318  24ea
      0  24ea					      REF	COMMON_VARS
      1  24ea					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  24ea				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  24ea					      ENDIF
      0  24ea					      REF	MakeMove	;✅
      1  24ea					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  24ea				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  24ea					      ENDIF
      0  24ea					      REF	aiMoveIsSelected	;✅
      1  24ea				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  24ea				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  24ea					      ENDIF
      0  24ea					      VEND	AdjustMaterialPositionalValue
      1  24ea
      2  24ea
      3  24ea		       00 b9	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
      4  24ea
    323  24ea
    324  24ea							; fromPiece	 piece doing the move (promoted type)
    325  24ea							; fromX12	 current square
    326  24ea							; originX12	 starting square
    327  24ea							; toX12	 ending square
    328  24ea
    329  24ea
    330  24ea							; {
    331  24ea							;   adjust the positional value  (originX12 --> fromX12)
    332  24ea
    333  24ea		       a4 87		      ldy	toX12	; already loaded
    334  24ec		       a5 97		      lda	fromPiece
    335  24ee		       20 59 f9 	      jsr	AddPiecePositionValue	; add pos value for new position
    336  24f1
    337  24f1
    338  24f1		       a5 b3		      lda	__originalPiece
    339  24f3		       45 97		      eor	fromPiece	; the new piece
    340  24f5		       29 07		      and	#PIECE_MASK
    341  24f7		       f0 05		      beq	.same1	; unchanged, so skip
    342  24f9
    343  24f9		       a5 97		      lda	fromPiece	; new piece
    344  24fb		       20 36 f9 	      jsr	AddPieceMaterialValue
    345  24fe
    346  24fe				   .same1
    347  24fe
    348  24fe							; and now the 'subtracts'
    349  24fe
      0  24fe					      NEGEVAL
      1  24fe
      2  24fe		       38		      sec
      3  24ff		       a9 00		      lda	#0
      4  2501		       e5 90		      sbc	Evaluation
      5  2503		       85 90		      sta	Evaluation
      6  2505		       a9 00		      lda	#0
      7  2507		       e5 91		      sbc	Evaluation+1
      8  2509		       85 91		      sta	Evaluation+1
      9  250b
    351  250b
    352  250b		       a4 88		      ldy	originX12
    353  250d		       a5 b3		      lda	__originalPiece
    354  250f		       20 59 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    355  2512
    356  2512
    357  2512		       a5 b3		      lda	__originalPiece
    358  2514		       45 97		      eor	fromPiece	; the new piece
    359  2516		       29 07		      and	#PIECE_MASK
    360  2518		       f0 05		      beq	.same2	; unchanged, so skip
    361  251a
    362  251a		       a5 b3		      lda	__originalPiece
    363  251c		       20 36 f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    364  251f				   .same2
    365  251f
      0  251f					      NEGEVAL
      1  251f
      2  251f		       38		      sec
      3  2520		       a9 00		      lda	#0
      4  2522		       e5 90		      sbc	Evaluation
      5  2524		       85 90		      sta	Evaluation
      6  2526		       a9 00		      lda	#0
      7  2528		       e5 91		      sbc	Evaluation+1
      8  252a		       85 91		      sta	Evaluation+1
      9  252c
    367  252c
    368  252c							; If there's a capture, we adjust the material value
    369  252c
    370  252c							;		      lda __capturedPiece
    371  252c							;		      eor __originalPiece
    372  252c							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    373  252c
    374  252c
    375  252c		       a5 b4		      lda	__capturedPiece
    376  252e		       29 07		      and	#PIECE_MASK
    377  2530		       f0 03		      beq	.noCapture
    378  2532		       20 36 f9 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    379  2535				   .noCapture
    380  2535
    381  2535							; }
    382  2535		       60		      rts
    383  2536
    384  2536
    385  2536							;---------------------------------------------------------------------------------------------------
    386  2536
      0  2536					      DEF	AddPieceMaterialValue
      1  2536				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  2536				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  2536				   AddPieceMaterialValue
      4  2536				   TEMPORARY_VAR SET	Overlay
      5  2536				   TEMPORARY_OFFSET SET	0
      6  2536				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  2536				   FUNCTION_NAME SET	AddPieceMaterialValue
    388  2536					      SUBROUTINE
    389  2536
      0  2536					      REF	COMMON_VARS
      1  2536					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  2536				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  2536					      ENDIF
      0  2536					      REF	InitialisePieceSquares	;✅
      1  2536					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  2536				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  2536					      ENDIF
      0  2536					      REF	AdjustMaterialPositionalValue	;✅
      1  2536				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  2536				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  2536					      ENDIF
    393  2536							;REF EnPassantRemovePiece ;✅
      0  2536					      VEND	AddPieceMaterialValue
      1  2536
      2  2536
      3  2536		       00 bb	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
      4  2536
    395  2536
    396  2536							; Adjust the material score based on the piece
    397  2536							; a = piece type + flags
    398  2536
    399  2536		       29 07		      and	#PIECE_MASK
    400  2538		       a8		      tay
    401  2539
    402  2539		       18		      clc
    403  253a		       b9 49 f9 	      lda	PieceValueLO,y
    404  253d		       65 90		      adc	Evaluation
    405  253f		       85 90		      sta	Evaluation
    406  2541		       b9 51 f9 	      lda	PieceValueHI,y
    407  2544		       65 91		      adc	Evaluation+1
    408  2546		       85 91		      sta	Evaluation+1
    409  2548		       60		      rts
    410  2549
    411  2549
    412  2549
    413  2549					      MAC	valuetable
    414  2549					      .byte	{1}(0)	; blank
    415  2549					      .byte	{1}(100)	; white P
    416  2549					      .byte	{1}(100)	; black P !!
    417  2549					      .byte	{1}(320)	; N
    418  2549					      .byte	{1}(375)	; B
    419  2549					      .byte	{1}(575)	; R
    420  2549					      .byte	{1}(900)	; Q
    421  2549					      .byte	{1}(10000)	; K
    422  2549					      ENDM
    423  2549
    424  2549				   PieceValueLO
      0  2549					      VALUETABLE	<
      1  2549		       00		      .byte.b	<(0)
      2  254a		       64		      .byte.b	<(100)
      3  254b		       64		      .byte.b	<(100)
      4  254c		       40		      .byte.b	<(320)
      5  254d		       77		      .byte.b	<(375)
      6  254e		       3f		      .byte.b	<(575)
      7  254f		       84		      .byte.b	<(900)
      8  2550		       10		      .byte.b	<(10000)
    426  2551
    427  2551				   PieceValueHI
      0  2551					      VALUETABLE	>
      1  2551		       00		      .byte.b	>(0)
      2  2552		       00		      .byte.b	>(100)
      3  2553		       00		      .byte.b	>(100)
      4  2554		       01		      .byte.b	>(320)
      5  2555		       01		      .byte.b	>(375)
      6  2556		       02		      .byte.b	>(575)
      7  2557		       03		      .byte.b	>(900)
      8  2558		       27		      .byte.b	>(10000)
    429  2559
    430  2559
    431  2559							;---------------------------------------------------------------------------------------------------
    432  2559
      0  2559					      DEF	AddPiecePositionValue
      1  2559				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  2559				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  2559				   AddPiecePositionValue
      4  2559				   TEMPORARY_VAR SET	Overlay
      5  2559				   TEMPORARY_OFFSET SET	0
      6  2559				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  2559				   FUNCTION_NAME SET	AddPiecePositionValue
    434  2559					      SUBROUTINE
    435  2559
      0  2559					      REF	InitialisePieceSquares	;✅
      1  2559					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  2559				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  2559					      ENDIF
      0  2559					      REF	AdjustMaterialPositionalValue	;✅
      1  2559				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  2559				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  2559					      ENDIF
    438  2559							;REF EnPassantRemovePiece ;✅
      0  2559					      VAR	__valPtr, 2
      1  2559		       00 bb	   __valPtr   =	TEMPORARY_VAR
      2  2559				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  2559
      4  2559				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2559				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2559				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2559					      ENDIF
      8  2559				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  2559				  -VNAME      SETSTR	__valPtr
     10  2559				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  2559				  -	      ERR
     12  2559					      ENDIF
      0  2559					      VEND	AddPiecePositionValue
      1  2559
      2  2559
      3  2559		       00 bd	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
      4  2559
    441  2559
    442  2559
    443  2559							; adds value of square piece is on to the evaluation
    444  2559							; note to do the subtraction as -( -x + val) == x - val
    445  2559
    446  2559							; y = square
    447  2559							; a = piece type (+flags)
    448  2559
    449  2559
    450  2559
    451  2559		       c9 80		      cmp	#128	; black = CS
    452  255b		       29 07		      and	#PIECE_MASK
    453  255d		       aa		      tax
    454  255e
    455  255e		       a9 db		      lda	#ROMBANK_EVALUATE
    456  2560		       85 3f		      sta	SET_BANK	;@3
    457  2562
    458  2562							; black pieces flip rows so we can use the same eval tables
    459  2562
    460  2562		       98		      tya
    461  2563		       90 03		      bcc	.white
    462  2565		       b9 85 f9 	      lda	FlipSquareIndex,y
    463  2568							;clc
    464  2568				   .white
    465  2568		       7d 00 fc 	      adc	PosValVecLO,x
    466  256b		       85 bb		      sta	__valPtr
    467  256d		       bd 08 fc 	      lda	PosValVecHI,x
    468  2570		       69 00		      adc	#0
    469  2572		       85 bc		      sta	__valPtr+1
    470  2574
    471  2574		       a0 00		      ldy	#0
    472  2576		       b1 bb		      lda	(__valPtr),y
    473  2578		       10 01		      bpl	.sum
    474  257a		       88		      dey
    475  257b
    476  257b				   .sum 		;clc
    477  257b		       65 90		      adc	Evaluation
    478  257d		       85 90		      sta	Evaluation
    479  257f		       98		      tya
    480  2580		       65 91		      adc	Evaluation+1
    481  2582		       85 91		      sta	Evaluation+1
    482  2584		       60		      rts
    483  2585
    484  2585
    485  2585				   FlipSquareIndex
    486  2585
    487  2585		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    488  258f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    489  2599
    490  2599				   .SQBASE    SET	90-1
    491  2599					      REPEAT	8
    492  2599		       00 00		      .byte.b	0,0
    493  2599				   .SQX       SET	2
    494  259b					      REPEAT	8
    495  259b		       5b		      .byte.b	(.SQBASE+.SQX)
    496  259b				   .SQX       SET	.SQX + 1
    494  259b					      REPEND
    495  259c		       5c		      .byte.b	(.SQBASE+.SQX)
    496  259c				   .SQX       SET	.SQX + 1
    494  259c					      REPEND
    495  259d		       5d		      .byte.b	(.SQBASE+.SQX)
    496  259d				   .SQX       SET	.SQX + 1
    494  259d					      REPEND
    495  259e		       5e		      .byte.b	(.SQBASE+.SQX)
    496  259e				   .SQX       SET	.SQX + 1
    494  259e					      REPEND
    495  259f		       5f		      .byte.b	(.SQBASE+.SQX)
    496  259f				   .SQX       SET	.SQX + 1
    494  259f					      REPEND
    495  25a0		       60		      .byte.b	(.SQBASE+.SQX)
    496  25a0				   .SQX       SET	.SQX + 1
    494  25a0					      REPEND
    495  25a1		       61		      .byte.b	(.SQBASE+.SQX)
    496  25a1				   .SQX       SET	.SQX + 1
    494  25a1					      REPEND
    495  25a2		       62		      .byte.b	(.SQBASE+.SQX)
    496  25a2				   .SQX       SET	.SQX + 1
    497  25a3					      REPEND
    498  25a3				   .SQBASE    SET	.SQBASE - 10
    491  25a3					      REPEND
    492  25a3		       00 00		      .byte.b	0,0
    493  25a3				   .SQX       SET	2
    494  25a5					      REPEAT	8
    495  25a5		       51		      .byte.b	(.SQBASE+.SQX)
    496  25a5				   .SQX       SET	.SQX + 1
    494  25a5					      REPEND
    495  25a6		       52		      .byte.b	(.SQBASE+.SQX)
    496  25a6				   .SQX       SET	.SQX + 1
    494  25a6					      REPEND
    495  25a7		       53		      .byte.b	(.SQBASE+.SQX)
    496  25a7				   .SQX       SET	.SQX + 1
    494  25a7					      REPEND
    495  25a8		       54		      .byte.b	(.SQBASE+.SQX)
    496  25a8				   .SQX       SET	.SQX + 1
    494  25a8					      REPEND
    495  25a9		       55		      .byte.b	(.SQBASE+.SQX)
    496  25a9				   .SQX       SET	.SQX + 1
    494  25a9					      REPEND
    495  25aa		       56		      .byte.b	(.SQBASE+.SQX)
    496  25aa				   .SQX       SET	.SQX + 1
    494  25aa					      REPEND
    495  25ab		       57		      .byte.b	(.SQBASE+.SQX)
    496  25ab				   .SQX       SET	.SQX + 1
    494  25ab					      REPEND
    495  25ac		       58		      .byte.b	(.SQBASE+.SQX)
    496  25ac				   .SQX       SET	.SQX + 1
    497  25ad					      REPEND
    498  25ad				   .SQBASE    SET	.SQBASE - 10
    491  25ad					      REPEND
    492  25ad		       00 00		      .byte.b	0,0
    493  25ad				   .SQX       SET	2
    494  25af					      REPEAT	8
    495  25af		       47		      .byte.b	(.SQBASE+.SQX)
    496  25af				   .SQX       SET	.SQX + 1
    494  25af					      REPEND
    495  25b0		       48		      .byte.b	(.SQBASE+.SQX)
    496  25b0				   .SQX       SET	.SQX + 1
    494  25b0					      REPEND
    495  25b1		       49		      .byte.b	(.SQBASE+.SQX)
    496  25b1				   .SQX       SET	.SQX + 1
    494  25b1					      REPEND
    495  25b2		       4a		      .byte.b	(.SQBASE+.SQX)
    496  25b2				   .SQX       SET	.SQX + 1
    494  25b2					      REPEND
    495  25b3		       4b		      .byte.b	(.SQBASE+.SQX)
    496  25b3				   .SQX       SET	.SQX + 1
    494  25b3					      REPEND
    495  25b4		       4c		      .byte.b	(.SQBASE+.SQX)
    496  25b4				   .SQX       SET	.SQX + 1
    494  25b4					      REPEND
    495  25b5		       4d		      .byte.b	(.SQBASE+.SQX)
    496  25b5				   .SQX       SET	.SQX + 1
    494  25b5					      REPEND
    495  25b6		       4e		      .byte.b	(.SQBASE+.SQX)
    496  25b6				   .SQX       SET	.SQX + 1
    497  25b7					      REPEND
    498  25b7				   .SQBASE    SET	.SQBASE - 10
    491  25b7					      REPEND
    492  25b7		       00 00		      .byte.b	0,0
    493  25b7				   .SQX       SET	2
    494  25b9					      REPEAT	8
    495  25b9		       3d		      .byte.b	(.SQBASE+.SQX)
    496  25b9				   .SQX       SET	.SQX + 1
    494  25b9					      REPEND
    495  25ba		       3e		      .byte.b	(.SQBASE+.SQX)
    496  25ba				   .SQX       SET	.SQX + 1
    494  25ba					      REPEND
    495  25bb		       3f		      .byte.b	(.SQBASE+.SQX)
    496  25bb				   .SQX       SET	.SQX + 1
    494  25bb					      REPEND
    495  25bc		       40		      .byte.b	(.SQBASE+.SQX)
    496  25bc				   .SQX       SET	.SQX + 1
    494  25bc					      REPEND
    495  25bd		       41		      .byte.b	(.SQBASE+.SQX)
    496  25bd				   .SQX       SET	.SQX + 1
    494  25bd					      REPEND
    495  25be		       42		      .byte.b	(.SQBASE+.SQX)
    496  25be				   .SQX       SET	.SQX + 1
    494  25be					      REPEND
    495  25bf		       43		      .byte.b	(.SQBASE+.SQX)
    496  25bf				   .SQX       SET	.SQX + 1
    494  25bf					      REPEND
    495  25c0		       44		      .byte.b	(.SQBASE+.SQX)
    496  25c0				   .SQX       SET	.SQX + 1
    497  25c1					      REPEND
    498  25c1				   .SQBASE    SET	.SQBASE - 10
    491  25c1					      REPEND
    492  25c1		       00 00		      .byte.b	0,0
    493  25c1				   .SQX       SET	2
    494  25c3					      REPEAT	8
    495  25c3		       33		      .byte.b	(.SQBASE+.SQX)
    496  25c3				   .SQX       SET	.SQX + 1
    494  25c3					      REPEND
    495  25c4		       34		      .byte.b	(.SQBASE+.SQX)
    496  25c4				   .SQX       SET	.SQX + 1
    494  25c4					      REPEND
    495  25c5		       35		      .byte.b	(.SQBASE+.SQX)
    496  25c5				   .SQX       SET	.SQX + 1
    494  25c5					      REPEND
    495  25c6		       36		      .byte.b	(.SQBASE+.SQX)
    496  25c6				   .SQX       SET	.SQX + 1
    494  25c6					      REPEND
    495  25c7		       37		      .byte.b	(.SQBASE+.SQX)
    496  25c7				   .SQX       SET	.SQX + 1
    494  25c7					      REPEND
    495  25c8		       38		      .byte.b	(.SQBASE+.SQX)
    496  25c8				   .SQX       SET	.SQX + 1
    494  25c8					      REPEND
    495  25c9		       39		      .byte.b	(.SQBASE+.SQX)
    496  25c9				   .SQX       SET	.SQX + 1
    494  25c9					      REPEND
    495  25ca		       3a		      .byte.b	(.SQBASE+.SQX)
    496  25ca				   .SQX       SET	.SQX + 1
    497  25cb					      REPEND
    498  25cb				   .SQBASE    SET	.SQBASE - 10
    491  25cb					      REPEND
    492  25cb		       00 00		      .byte.b	0,0
    493  25cb				   .SQX       SET	2
    494  25cd					      REPEAT	8
    495  25cd		       29		      .byte.b	(.SQBASE+.SQX)
    496  25cd				   .SQX       SET	.SQX + 1
    494  25cd					      REPEND
    495  25ce		       2a		      .byte.b	(.SQBASE+.SQX)
    496  25ce				   .SQX       SET	.SQX + 1
    494  25ce					      REPEND
    495  25cf		       2b		      .byte.b	(.SQBASE+.SQX)
    496  25cf				   .SQX       SET	.SQX + 1
    494  25cf					      REPEND
    495  25d0		       2c		      .byte.b	(.SQBASE+.SQX)
    496  25d0				   .SQX       SET	.SQX + 1
    494  25d0					      REPEND
    495  25d1		       2d		      .byte.b	(.SQBASE+.SQX)
    496  25d1				   .SQX       SET	.SQX + 1
    494  25d1					      REPEND
    495  25d2		       2e		      .byte.b	(.SQBASE+.SQX)
    496  25d2				   .SQX       SET	.SQX + 1
    494  25d2					      REPEND
    495  25d3		       2f		      .byte.b	(.SQBASE+.SQX)
    496  25d3				   .SQX       SET	.SQX + 1
    494  25d3					      REPEND
    495  25d4		       30		      .byte.b	(.SQBASE+.SQX)
    496  25d4				   .SQX       SET	.SQX + 1
    497  25d5					      REPEND
    498  25d5				   .SQBASE    SET	.SQBASE - 10
    491  25d5					      REPEND
    492  25d5		       00 00		      .byte.b	0,0
    493  25d5				   .SQX       SET	2
    494  25d7					      REPEAT	8
    495  25d7		       1f		      .byte.b	(.SQBASE+.SQX)
    496  25d7				   .SQX       SET	.SQX + 1
    494  25d7					      REPEND
    495  25d8		       20		      .byte.b	(.SQBASE+.SQX)
    496  25d8				   .SQX       SET	.SQX + 1
    494  25d8					      REPEND
    495  25d9		       21		      .byte.b	(.SQBASE+.SQX)
    496  25d9				   .SQX       SET	.SQX + 1
    494  25d9					      REPEND
    495  25da		       22		      .byte.b	(.SQBASE+.SQX)
    496  25da				   .SQX       SET	.SQX + 1
    494  25da					      REPEND
    495  25db		       23		      .byte.b	(.SQBASE+.SQX)
    496  25db				   .SQX       SET	.SQX + 1
    494  25db					      REPEND
    495  25dc		       24		      .byte.b	(.SQBASE+.SQX)
    496  25dc				   .SQX       SET	.SQX + 1
    494  25dc					      REPEND
    495  25dd		       25		      .byte.b	(.SQBASE+.SQX)
    496  25dd				   .SQX       SET	.SQX + 1
    494  25dd					      REPEND
    495  25de		       26		      .byte.b	(.SQBASE+.SQX)
    496  25de				   .SQX       SET	.SQX + 1
    497  25df					      REPEND
    498  25df				   .SQBASE    SET	.SQBASE - 10
    491  25df					      REPEND
    492  25df		       00 00		      .byte.b	0,0
    493  25df				   .SQX       SET	2
    494  25e1					      REPEAT	8
    495  25e1		       15		      .byte.b	(.SQBASE+.SQX)
    496  25e1				   .SQX       SET	.SQX + 1
    494  25e1					      REPEND
    495  25e2		       16		      .byte.b	(.SQBASE+.SQX)
    496  25e2				   .SQX       SET	.SQX + 1
    494  25e2					      REPEND
    495  25e3		       17		      .byte.b	(.SQBASE+.SQX)
    496  25e3				   .SQX       SET	.SQX + 1
    494  25e3					      REPEND
    495  25e4		       18		      .byte.b	(.SQBASE+.SQX)
    496  25e4				   .SQX       SET	.SQX + 1
    494  25e4					      REPEND
    495  25e5		       19		      .byte.b	(.SQBASE+.SQX)
    496  25e5				   .SQX       SET	.SQX + 1
    494  25e5					      REPEND
    495  25e6		       1a		      .byte.b	(.SQBASE+.SQX)
    496  25e6				   .SQX       SET	.SQX + 1
    494  25e6					      REPEND
    495  25e7		       1b		      .byte.b	(.SQBASE+.SQX)
    496  25e7				   .SQX       SET	.SQX + 1
    494  25e7					      REPEND
    495  25e8		       1c		      .byte.b	(.SQBASE+.SQX)
    496  25e8				   .SQX       SET	.SQX + 1
    497  25e9					      REPEND
    498  25e9				   .SQBASE    SET	.SQBASE - 10
    499  25e9					      REPEND
    500  25e9
    501  25e9
    502  25e9							;---------------------------------------------------------------------------------------------------
    503  25e9
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  25e9					      include	"piece_vectors.asm"
      1  25e9							; Created by ConvertChessPieces.py
      0  25e9					      DEF	PIECE_VECTOR_LO
      1  25e9				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  25e9				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  25e9				   PIECE_VECTOR_LO
      4  25e9				   TEMPORARY_VAR SET	Overlay
      5  25e9				   TEMPORARY_OFFSET SET	0
      6  25e9				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  25e9				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  25e9		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  25ea		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  25eb		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  25ec		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  25ed		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  25ee		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  25ef		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  25f0		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  25f1		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  25f2		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  25f3		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  25f4		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  25f5		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  25f6		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  25f7		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  25f8		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  25f9		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  25fa		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  25fb		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  25fc		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  25fd		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  25fe		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  25ff		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  2600		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  2601		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  2602		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  2603		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  2604		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  2605		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  2606		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  2607		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  2608		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  2609		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  260a		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  260b		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  260c		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  260d		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  260e		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  260f		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  2610		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  2611		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  2612		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  2613		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  2614		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  2615		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  2616		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  2617		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  2618		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  2619		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  261a		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  261b		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  261c		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  261d		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  261e		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  261f		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  2620		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  2621		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  2622		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  2623		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  2624		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  2625		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  2626		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  2627		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  2628		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  2629		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  262a		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  262b		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  262c		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  262d		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  262e		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  262f		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  2630		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  2631		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  2632		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  2633		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  2634		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  2635		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  2636		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  2637		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  2638		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  2639		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  263a		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  263b		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  263c		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  263d		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  263e		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  263f		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  2640		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  2641		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  2642		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  2643		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  2644		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  2645		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  2646		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  2647		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  2648		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  2649		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  264a		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  264b		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  264c		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  264d		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  264e		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  264f		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  2650		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  2651		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  2652		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  2653		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  2654		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  2655		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  2656		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  2657		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  2658		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  2659		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  265a		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  265b		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  265c		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  265d		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  265e		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  265f		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  2660		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  2661		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  2662		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  2663		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  2664		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  2665		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  2666		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  2667		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  2668		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  2669		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  266a		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  266b		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  266c		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  266d		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  266e		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  266f		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  2670		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  2671		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  2672		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  2673		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  2674		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  2675		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  2676		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  2677		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  2678		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  2679					      DEF	PIECE_VECTOR_HI
      1  2679				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  2679				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  2679				   PIECE_VECTOR_HI
      4  2679				   TEMPORARY_VAR SET	Overlay
      5  2679				   TEMPORARY_OFFSET SET	0
      6  2679				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  2679				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  2679		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  267a		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  267b		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  267c		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  267d		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  267e		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  267f		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  2680		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  2681		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  2682		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  2683		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  2684		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  2685		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  2686		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  2687		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  2688		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  2689		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  268a		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  268b		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  268c		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  268d		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  268e		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  268f		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  2690		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  2691		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  2692		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  2693		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  2694		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  2695		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  2696		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  2697		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  2698		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  2699		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  269a		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  269b		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  269c		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  269d		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  269e		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  269f		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  26a0		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  26a1		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  26a2		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  26a3		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  26a4		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  26a5		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  26a6		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  26a7		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  26a8		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  26a9		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  26aa		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  26ab		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  26ac		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  26ad		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  26ae		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  26af		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  26b0		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  26b1		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  26b2		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  26b3		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  26b4		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  26b5		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  26b6		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  26b7		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  26b8		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  26b9		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  26ba		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  26bb		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  26bc		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  26bd		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  26be		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  26bf		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  26c0		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  26c1		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  26c2		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  26c3		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  26c4		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  26c5		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  26c6		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  26c7		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  26c8		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  26c9		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  26ca		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  26cb		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  26cc		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  26cd		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  26ce		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  26cf		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  26d0		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  26d1		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  26d2		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  26d3		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  26d4		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  26d5		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  26d6		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  26d7		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  26d8		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  26d9		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  26da		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  26db		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  26dc		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  26dd		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  26de		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  26df		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  26e0		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  26e1		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  26e2		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  26e3		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  26e4		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  26e5		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  26e6		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  26e7		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  26e8		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  26e9		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  26ea		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  26eb		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  26ec		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  26ed		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  26ee		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  26ef		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  26f0		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  26f1		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  26f2		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  26f3		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  26f4		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  26f5		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  26f6		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  26f7		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  26f8		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  26f9		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  26fa		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  26fb		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  26fc		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  26fd		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  26fe		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  26ff		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  2700		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  2701		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  2702		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  2703		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  2704		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  2705		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  2706		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  2707		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  2708		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  2709					      DEF	PIECE_VECTOR_BANK
      1  2709				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  2709				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  2709				   PIECE_VECTOR_BANK
      4  2709				   TEMPORARY_VAR SET	Overlay
      5  2709				   TEMPORARY_OFFSET SET	0
      6  2709				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  2709				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  2709		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  270a		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  270b		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  270c		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  270d		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  270e		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  270f		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  2710		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  2711		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  2712		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  2713		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  2714		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  2715		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  2716		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  2717		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  2718		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  2719		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  271a		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  271b		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  271c		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  271d		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  271e		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  271f		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  2720		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  2721		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  2722		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  2723		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  2724		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  2725		       8c		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  2726		       8c		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  2727		       8c		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  2728		       8d		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  2729		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  272a		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  272b		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  272c		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  272d		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  272e		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  272f		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  2730		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  2731		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  2732		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  2733		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  2734		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  2735		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  2736		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  2737		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  2738		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  2739		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  273a		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  273b		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  273c		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  273d		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  273e		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  273f		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  2740		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  2741		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  2742		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  2743		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  2744		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  2745		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  2746		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  2747		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  2748		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  2749		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  274a		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  274b		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  274c		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  274d		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  274e		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  274f		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  2750		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  2751		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  2752		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  2753		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  2754		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  2755		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  2756		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  2757		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  2758		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  2759		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  275a		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  275b		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  275c		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  275d		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  275e		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  275f		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  2760		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  2761		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  2762		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  2763		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  2764		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  2765		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  2766		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  2767		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  2768		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  2769		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  276a		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  276b		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  276c		       96		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  276d		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  276e		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  276f		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  2770		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  2771		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  2772		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  2773		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  2774		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  2775		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  2776		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  2777		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  2778		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  2779		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  277a		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  277b		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  277c		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  277d		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  277e		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  277f		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  2780		       97		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  2781		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  2782		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  2783		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  2784		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  2785		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  2786		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  2787		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  2788		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  2789		       8c		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  278a		       8d		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  278b		       8d		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  278c		       8d		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  278d		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  278e		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  278f		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  2790		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  2791		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  2792		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  2793		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  2794		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  2795		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  2796		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  2797		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  2798		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  2799
    438  2799							; piece index equates...
    439  2799		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  2799		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  2799		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  2799		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  2799		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  2799		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  2799		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  2799		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  2799		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  2799		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  2799		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  2799		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  2799		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  2799		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  2799		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  2799		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  2799		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  2799		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  2799		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  2799		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  2799		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  2799		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  2799		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  2799		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  2799		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  2799		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  2799		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  2799		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  2799		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  2799		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  2799		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  2799		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  2799		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  2799		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  2799		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  2799		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  2799		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  2799		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  2799		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  2799		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  2799		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  2799		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  2799		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  2799		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  2799		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  2799		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  2799		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  2799		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  2799		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  2799		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  2799		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  2799		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  2799		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  2799		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  2799		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  2799		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  2799		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  2799		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  2799		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  2799		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  2799		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  2799		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  2799		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  2799		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  2799		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  2799		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  2799		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  2799		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  2799		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  2799		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  2799		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  2799		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  2799		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  2799		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  2799		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  2799		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  2799		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  2799		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  2799		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  2799		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  2799		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  2799		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  2799		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  2799		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  2799		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  2799		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  2799		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  2799		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  2799		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  2799		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  2799		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  2799		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  2799		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  2799		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  2799		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  2799		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  2799		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  2799		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  2799		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  2799		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  2799		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  2799		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  2799		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  2799		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  2799		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  2799		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  2799		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  2799		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  2799		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  2799		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  2799		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  2799		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  2799		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  2799		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  2799		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  2799		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  2799		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  2799		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  2799		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  2799		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  2799		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  2799		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  2799		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  2799		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  2799		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  2799		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  2799		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  2799		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  2799		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  2799		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  2799		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  2799		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  2799		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  2799		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  2799		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  2799		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  2799		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  2799		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  2799		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  2799		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  2799		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  2799		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  2799		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  2799		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE @2 GENERIC #3.asm
    505  2799
    506  2799
    507  2799							;---------------------------------------------------------------------------------------------------
    508  2799
      0  2799					      END_BANK
      1  2799				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  2799				  -	      CHECK_RAM_BANK_SIZE
      3  2799					      ELSE
      0  2799					      CHECK_BANK_SIZE
      1  2799		       03 99	   .TEMP      =	* - _BANK_START
 ROM bank # 10 GENERIC_BANK@2#1 size = $399 free = 102
      2  2799					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  2799				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2799				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  2799				  -	      ERR
      6  2799					      ENDIF
      5  2799					      ENDIF
    510  2799
    511  2799							;---------------------------------------------------------------------------------------------------
    512  2799							;EOF
------- FILE ./chess.asm
------- FILE @2 GENERIC #4.asm LEVEL 2 PASS 4
      0  2799					      include	"@2 GENERIC #4.asm"
      1  2799							;---------------------------------------------------------------------------------------------------
      2  2799							; @2 GENERIC #4.asm
      3  2799
      4  2799							; Atari 2600 Chess
      5  2799							; Copyright (c) 2019-2020 Andrew Davie
      6  2799							; andrew@taswegian.com
      7  2799
      8  2799
      9  2799							;---------------------------------------------------------------------------------------------------
     10  2799
      0  2799					      SLOT	2
      1  2799
      2  2799				  -	      IF	(2 < 0) || (2 > 3)
      3  2799				  -	      ECHO	"Illegal bank address/segment location", 2
      4  2799				  -	      ERR
      5  2799					      ENDIF
      6  2799
      7  2799				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  2799				   _BANK_SLOT SET	2 * 64
      9  2799
      0  2799					      ROMBANK	GENERIC_BANK@2#2
      1  2885 ????				      SEG	ROM_GENERIC_BANK@2#2
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   GENERIC_BANK@2#2_START SET	*
      6  2800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2800				   ROMBANK_GENERIC_BANK@2#2 SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2800				   _LAST_BANK SETSTR	GENERIC_BANK@2#2
     10  2800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  2800
     14  2800
     15  2800							;---------------------------------------------------------------------------------------------------
     16  2800
      0  2800					      DEF	moveCursor
      1  2800				   SLOT_moveCursor SET	_BANK_SLOT
      2  2800				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  2800				   moveCursor
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	moveCursor
     18  2800					      SUBROUTINE
     19  2800
      0  2800					      REF	aiSelectStartSquare
      1  2800					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  2800				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  2800					      ENDIF
      0  2800					      REF	aiSelectDestinationSquare
      1  2800					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  2800				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  2800					      ENDIF
     22  2800
      0  2800					      VAR	__newCursor, 1
      1  2800		       00 ef	   __newCursor =	TEMPORARY_VAR
      2  2800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2800
      4  2800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2800					      ENDIF
      8  2800				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  2800				  -VNAME      SETSTR	__newCursor
     10  2800				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  2800				  -	      ERR
     12  2800					      ENDIF
     24  2800
      0  2800					      VEND	moveCursor
      1  2800
      2  2800
      3  2800		       00 f0	   VAREND_moveCursor =	TEMPORARY_VAR
      4  2800
     26  2800
     27  2800							; Part (a) move cursor around the board waiting for joystick press
     28  2800
     29  2800		       a2 00		      ldx	#0	; delay
     30  2802
     31  2802		       ad 80 02 	      lda	SWCHA
     32  2805		       4a		      lsr
     33  2806		       4a		      lsr
     34  2807		       4a		      lsr
     35  2808		       4a		      lsr
     36  2809		       a8		      tay
     37  280a
     38  280a		       c9 0f		      cmp	#15
     39  280c		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
     40  280e
     41  280e		       c6 8a		      dec	mdelay
     42  2810		       10 1f		      bpl	.delaym
     43  2812
     44  2812		       18		      clc
     45  2813		       a5 89		      lda	cursorX12
     46  2815		       79 75 f8 	      adc	JoyMoveCursor,y
     47  2818		       85 ef		      sta	__newCursor
     48  281a		       a8		      tay
     49  281b
     50  281b		       a9 e3		      lda	#RAMBANK_BOARD
     51  281d		       85 3e		      sta	SET_BANK_RAM	;@3
     52  281f		       b9 15 fc 	      lda	ValidSquare,y
     53  2822		       c9 ff		      cmp	#-1
     54  2824		       f0 04		      beq	.invalid
     55  2826		       a5 ef		      lda	__newCursor
     56  2828		       85 89		      sta	cursorX12
     57  282a				   .invalid
     58  282a
     59  282a		       a2 10		      ldx	#CURSOR_MOVE_SPEED
     60  282c		       86 8a	   .cursor    stx	mdelay
     61  282e		       20 32 f8 	      jsr	setCursorPriority
     62  2831		       60	   .delaym    rts
     63  2832
     64  2832
     65  2832							;---------------------------------------------------------------------------------------------------
     66  2832
      0  2832					      DEF	setCursorPriority
      1  2832				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  2832				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  2832				   setCursorPriority
      4  2832				   TEMPORARY_VAR SET	Overlay
      5  2832				   TEMPORARY_OFFSET SET	0
      6  2832				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  2832				   FUNCTION_NAME SET	setCursorPriority
     68  2832					      SUBROUTINE
     69  2832
      0  2832					      REF	moveCursor
      1  2832					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  2832				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  2832					      ENDIF
      0  2832					      VEND	setCursorPriority
      1  2832
      2  2832
      3  2832		       00 f0	   VAREND_setCursorPriority =	TEMPORARY_VAR
      4  2832
     72  2832
     73  2832		       98		      tya
     74  2833		       48		      pha
     75  2834
     76  2834		       a2 04		      ldx	#%100
     77  2836
     78  2836		       a4 89		      ldy	cursorX12
     79  2838		       30 0b		      bmi	.under
     80  283a
     81  283a		       a9 e3		      lda	#RAMBANK_BOARD
     82  283c		       85 3e		      sta	SET_BANK_RAM	;@3
     83  283e		       b9 79 fc 	      lda	Board,y
     84  2841		       d0 02		      bne	.under
     85  2843		       a2 00		      ldx	#0
     86  2845		       86 4a	   .under     stx	CTRLPF	; UNDER
     87  2847
     88  2847		       68		      pla
     89  2848		       a8		      tay
     90  2849		       60		      rts
     91  284a
     92  284a
     93  284a							;---------------------------------------------------------------------------------------------------
     94  284a
      0  284a					      DEF	setCursorColours
      1  284a				   SLOT_setCursorColours SET	_BANK_SLOT
      2  284a				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  284a				   setCursorColours
      4  284a				   TEMPORARY_VAR SET	Overlay
      5  284a				   TEMPORARY_OFFSET SET	0
      6  284a				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  284a				   FUNCTION_NAME SET	setCursorColours
     96  284a					      SUBROUTINE
     97  284a
      0  284a					      REF	aiSelectStartSquare
      1  284a					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  284a				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  284a					      ENDIF
      0  284a					      REF	aiDrawMoves
      1  284a				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  284a					      ENDIF
      0  284a					      REF	aiUnDrawTargetSquares
      1  284a				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  284a					      ENDIF
      0  284a					      REF	aiShowMoveCaptures
      1  284a				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  284a					      ENDIF
      0  284a					      REF	aiSlowFlash
      1  284a				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  284a					      ENDIF
      0  284a					      REF	aiSelectDestinationSquare
      1  284a					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  284a				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  284a					      ENDIF
      0  284a					      VEND	setCursorColours
      1  284a
      2  284a
      3  284a		       00 ef	   VAREND_setCursorColours =	TEMPORARY_VAR
      4  284a
    105  284a
    106  284a							; pass y=-1 if move is NOT in the movelist
    107  284a							; preserve y
    108  284a
    109  284a		       a6 a5		      ldx	platform
    110  284c		       bd 61 f8 	      lda	redCol,x
    111  284f
    112  284f		       c0 ff		      cpy	#-1
    113  2851		       f0 0b		      beq	.writeCursorCol	; NOT in the movelist
    114  2853
    115  2853		       a5 8b		      lda	ccur
    116  2855		       4a		      lsr
    117  2856		       4a		      lsr
    118  2857		       4a		      lsr
    119  2858		       29 06		      and	#6
    120  285a		       18		      clc
    121  285b
    122  285b		       7d 63 f8 	      adc	greenCol,x
    123  285e
    124  285e		       85 46	   .writeCursorCol sta	COLUP0
    125  2860		       60		      rts
    126  2861
    127  2861
    128  2861				   redCol
    129  2861		       44 64		      .byte.b	NTSC_COLOUR_LINE_2 - 2, (PAL_COLOUR_LINE_2&$F0)+4
    130  2863				   greenCol
    131  2863		       d2 32		      .byte.b	(NTSC_COLOUR_LINE_3&$F0)+2, (PAL_COLOUR_LINE_3&$F0)+2
    132  2865
    133  2865							;---------------------------------------------------------------------------------------------------
    134  2865
    135  2865							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    136  2865							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    137  2865
      0  2865					      ALLOCATE	JoyCombined, 16
      1  2865
      2  2865				   .NAME      SETSTR	JoyCombined
      0  2865					      OPTIONAL_PAGEBREAK	.NAME, 16
      1  2865
      2  2865				  -	      IF	(>( * + 16 -1 )) > ( >* )
      3  2865				  -.EARLY_LOCATION SET	*
      4  2865				  -	      ALIGN	256
      5  2865				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2865					      ENDIF
      0  2865					      DEF	JoyCombined
      1  2865				   SLOT_JoyCombined SET	_BANK_SLOT
      2  2865				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  2865				   JoyCombined
      4  2865				   TEMPORARY_VAR SET	Overlay
      5  2865				   TEMPORARY_OFFSET SET	0
      6  2865				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  2865				   FUNCTION_NAME SET	JoyCombined
      5  2865
    139  2865		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    140  2875
      0  2875					      ALLOCATE	JoyMoveCursor, 16
      1  2875
      2  2875				   .NAME      SETSTR	JoyMoveCursor
      0  2875					      OPTIONAL_PAGEBREAK	.NAME, 16
      1  2875
      2  2875				  -	      IF	(>( * + 16 -1 )) > ( >* )
      3  2875				  -.EARLY_LOCATION SET	*
      4  2875				  -	      ALIGN	256
      5  2875				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2875					      ENDIF
      0  2875					      DEF	JoyMoveCursor
      1  2875				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  2875				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  2875				   JoyMoveCursor
      4  2875				   TEMPORARY_VAR SET	Overlay
      5  2875				   TEMPORARY_OFFSET SET	0
      6  2875				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  2875				   FUNCTION_NAME SET	JoyMoveCursor
      5  2875
    142  2875		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    143  2885
    144  2885
    145  2885							;---------------------------------------------------------------------------------------------------
    146  2885
      0  2885					      END_BANK
      1  2885				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  2885				  -	      CHECK_RAM_BANK_SIZE
      3  2885					      ELSE
      0  2885					      CHECK_BANK_SIZE
      1  2885		       00 85	   .TEMP      =	* - _BANK_START
 ROM bank # 11 GENERIC_BANK@2#2 size = $85 free = 890
      2  2885					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  2885				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2885				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  2885				  -	      ERR
      6  2885					      ENDIF
      5  2885					      ENDIF
    148  2885
    149  2885							;---------------------------------------------------------------------------------------------------
    150  2885							;EOF
------- FILE ./chess.asm
------- FILE @2 GRAPHICS DATA.asm LEVEL 2 PASS 4
      0  2885					      include	"@2 GRAPHICS DATA.asm"
      1  2885							;---------------------------------------------------------------------------------------------------
      2  2885							; @2 GRAPHICS DATA.asm
      3  2885
      4  2885							; Atari 2600 Chess
      5  2885							; Copyright (c) 2019-2020 Andrew Davie
      6  2885							; andrew@taswegian.com
      7  2885
      8  2885
      9  2885							;---------------------------------------------------------------------------------------------------
     10  2885
      0  2885					      SLOT	2
      1  2885
      2  2885				  -	      IF	(2 < 0) || (2 > 3)
      3  2885				  -	      ECHO	"Illegal bank address/segment location", 2
      4  2885				  -	      ERR
      5  2885					      ENDIF
      6  2885
      7  2885				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  2885				   _BANK_SLOT SET	2 * 64
      9  2885
     12  2885
     13  2885
     14  2885							;---------------------------------------------------------------------------------------------------
     15  2885
      0  2885					      ROMBANK	GFX1
      1  2fd8 ????				      SEG	ROM_GFX1
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   GFX1_START SET	*
      6  2c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2c00				   ROMBANK_GFX1 SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2c00				   _LAST_BANK SETSTR	GFX1
     10  2c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     17  2c00
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
      1  2c00
      2  2c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2c00				  -.EARLY_LOCATION SET	*
      4  2c00				  -	      ALIGN	256
      5  2c00				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2c00					      ENDIF
      0  2c00					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  2c00				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2c00				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  2c00		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
      1  2c48
      2  2c48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2c48				  -.EARLY_LOCATION SET	*
      4  2c48				  -	      ALIGN	256
      5  2c48				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2c48					      ENDIF
      0  2c48					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  2c48				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2c48				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
      1  2c90
      2  2c90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2c90				  -.EARLY_LOCATION SET	*
      4  2c90				  -	      ALIGN	256
      5  2c90				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2c90					      ENDIF
      0  2c90					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  2c90				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2c90				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2cc0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
      1  2cd8
      2  2cd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  2cd8				   .EARLY_LOCATION SET	*
      4  2d00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PROMOTE_on_BLACK_SQUARE_3 wasted 40 bytes
      5  2d00					      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2d00					      ENDIF
      0  2d00					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  2d00				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2d00				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
      1  2d48
      2  2d48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2d48				  -.EARLY_LOCATION SET	*
      4  2d48				  -	      ALIGN	256
      5  2d48				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2d48					      ENDIF
      0  2d48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  2d48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2d48				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  2d48		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  2d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
      1  2d90
      2  2d90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2d90				  -.EARLY_LOCATION SET	*
      4  2d90				  -	      ALIGN	256
      5  2d90				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2d90					      ENDIF
      0  2d90					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  2d90				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2d90				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
      1  2dd8
      2  2dd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  2dd8				   .EARLY_LOCATION SET	*
      4  2e00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PROMOTE_on_WHITE_SQUARE_2 wasted 40 bytes
      5  2e00					      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2e00					      ENDIF
      0  2e00					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  2e00				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2e00				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  2e30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
      1  2e48
      2  2e48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2e48				  -.EARLY_LOCATION SET	*
      4  2e48				  -	      ALIGN	256
      5  2e48				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2e48					      ENDIF
      0  2e48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  2e48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2e48				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
      1  2e90
      2  2e90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2e90				  -.EARLY_LOCATION SET	*
      4  2e90				  -	      ALIGN	256
      5  2e90				  -	      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2e90					      ENDIF
      0  2e90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  2e90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  2e90		       00 40 e0 e0*	      .byte.b	$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  2ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
      1  2ed8
      2  2ed8					      IF	(>( * + 72 -1 )) > ( >* )
      3  2ed8				   .EARLY_LOCATION SET	*
      4  2f00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_MARKER_on_BLACK_SQUARE_1 wasted 40 bytes
      5  2f00					      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2f00					      ENDIF
      0  2f00					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  2f00				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       00 10 38 38*	      .byte.b	$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
      1  2f48
      2  2f48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2f48				  -.EARLY_LOCATION SET	*
      4  2f48				  -	      ALIGN	256
      5  2f48				  -	      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2f48					      ENDIF
      0  2f48					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  2f48				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       00 00 01 01*	      .byte.b	$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  2f78		       00 01 03 03*	      .byte.b	$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
      1  2f90
      2  2f90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2f90				  -.EARLY_LOCATION SET	*
      4  2f90				  -	      ALIGN	256
      5  2f90				  -	      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2f90					      ENDIF
      0  2f90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  2f90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       00 20 70 70*	      .byte.b	$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     30  2fd8
      0  2fd8					      END_BANK
      1  2fd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  2fd8				  -	      CHECK_RAM_BANK_SIZE
      3  2fd8					      ELSE
      0  2fd8					      CHECK_BANK_SIZE
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 12 GFX1 size = $3d8 free = 39
      2  2fd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      5  2fd8					      ENDIF
     32  2fd8
     33  2fd8
     34  2fd8							;---------------------------------------------------------------------------------------------------
     35  2fd8
      0  2fd8					      ROMBANK	GFX2
      1  33d8 ????				      SEG	ROM_GFX2
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   GFX2_START SET	*
      6  3000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3000				   ROMBANK_GFX2 SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3000				   _LAST_BANK SETSTR	GFX2
     10  3000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     37  3000
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
      1  3000
      2  3000				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3000				  -.EARLY_LOCATION SET	*
      4  3000				  -	      ALIGN	256
      5  3000				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3000					      ENDIF
      0  3000					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  3000				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  3000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
      1  3048
      2  3048				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3048				  -.EARLY_LOCATION SET	*
      4  3048				  -	      ALIGN	256
      5  3048				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3048					      ENDIF
      0  3048					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  3048				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
      1  3090
      2  3090				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3090				  -.EARLY_LOCATION SET	*
      4  3090				  -	      ALIGN	256
      5  3090				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3090					      ENDIF
      0  3090					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  3090				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  30c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
      1  30d8
      2  30d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  30d8				   .EARLY_LOCATION SET	*
      4  3100		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BISHOP_on_BLACK_SQUARE_0 wasted 40 bytes
      5  3100					      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3100					      ENDIF
      0  3100					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  3100				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3100				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3100				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  3100		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  3118		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
      1  3148
      2  3148				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3148				  -.EARLY_LOCATION SET	*
      4  3148				  -	      ALIGN	256
      5  3148				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3148					      ENDIF
      0  3148					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  3148				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3148				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3148				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  3148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3160		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
      1  3190
      2  3190				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3190				  -.EARLY_LOCATION SET	*
      4  3190				  -	      ALIGN	256
      5  3190				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3190					      ENDIF
      0  3190					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  3190				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3190				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3190				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  31c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
      1  31d8
      2  31d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  31d8				   .EARLY_LOCATION SET	*
      4  3200		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BISHOP_on_BLACK_SQUARE_3 wasted 40 bytes
      5  3200					      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3200					      ENDIF
      0  3200					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  3200				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3200				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3200				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3230		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
      1  3248
      2  3248				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3248				  -.EARLY_LOCATION SET	*
      4  3248				  -	      ALIGN	256
      5  3248				  -	      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3248					      ENDIF
      0  3248					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  3248				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3248				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3248				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  3248		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  3260		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
      1  3290
      2  3290				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3290				  -.EARLY_LOCATION SET	*
      4  3290				  -	      ALIGN	256
      5  3290				  -	      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3290					      ENDIF
      0  3290					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  3290				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3290				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3290				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  3290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  32a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
      1  32d8
      2  32d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  32d8				   .EARLY_LOCATION SET	*
      4  3300		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_ROOK_on_BLACK_SQUARE_2 wasted 40 bytes
      5  3300					      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3300					      ENDIF
      0  3300					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  3300				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3300				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3300				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  3330		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
      1  3348
      2  3348				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3348				  -.EARLY_LOCATION SET	*
      4  3348				  -	      ALIGN	256
      5  3348				  -	      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3348					      ENDIF
      0  3348					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  3348				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3348				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3348				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3378		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
      1  3390
      2  3390				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3390				  -.EARLY_LOCATION SET	*
      4  3390				  -	      ALIGN	256
      5  3390				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3390					      ENDIF
      0  3390					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  3390				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3390				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3390				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  3390		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$50,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     50  33d8
      0  33d8					      END_BANK
      1  33d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  33d8				  -	      CHECK_RAM_BANK_SIZE
      3  33d8					      ELSE
      0  33d8					      CHECK_BANK_SIZE
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 13 GFX2 size = $3d8 free = 39
      2  33d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      5  33d8					      ENDIF
     52  33d8
     53  33d8
     54  33d8							;---------------------------------------------------------------------------------------------------
     55  33d8
      0  33d8					      ROMBANK	GFX3
      1  37d8 ????				      SEG	ROM_GFX3
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   GFX3_START SET	*
      6  3400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3400				   ROMBANK_GFX3 SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3400				   _LAST_BANK SETSTR	GFX3
     10  3400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     57  3400
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
      1  3400
      2  3400				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3400				  -.EARLY_LOCATION SET	*
      4  3400				  -	      ALIGN	256
      5  3400				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3400					      ENDIF
      0  3400					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  3400				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3400				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3400				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  3400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3418		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$54,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
      1  3448
      2  3448				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3448				  -.EARLY_LOCATION SET	*
      4  3448				  -	      ALIGN	256
      5  3448				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3448					      ENDIF
      0  3448					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  3448				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3448				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3448				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$02,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3478		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$05,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
      1  3490
      2  3490				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3490				  -.EARLY_LOCATION SET	*
      4  3490				  -	      ALIGN	256
      5  3490				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3490					      ENDIF
      0  3490					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  3490				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3490				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3490				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  34c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$a8,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
      1  34d8
      2  34d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  34d8				   .EARLY_LOCATION SET	*
      4  3500		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KING_on_BLACK_SQUARE_0 wasted 40 bytes
      5  3500					      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3500					      ENDIF
      0  3500					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  3500				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3500				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3500				   BLACK_KING_on_BLACK_SQUARE_0
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  3500		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
      1  3548
      2  3548				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3548				  -.EARLY_LOCATION SET	*
      4  3548				  -	      ALIGN	256
      5  3548				  -	      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3548					      ENDIF
      0  3548					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  3548				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3548				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3548				   BLACK_KING_on_BLACK_SQUARE_1
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  3548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3560		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
      1  3590
      2  3590				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3590				  -.EARLY_LOCATION SET	*
      4  3590				  -	      ALIGN	256
      5  3590				  -	      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3590					      ENDIF
      0  3590					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  3590				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3590				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3590				   BLACK_KING_on_BLACK_SQUARE_2
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  35c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
      1  35d8
      2  35d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  35d8				   .EARLY_LOCATION SET	*
      4  3600		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KING_on_BLACK_SQUARE_3 wasted 40 bytes
      5  3600					      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3600					      ENDIF
      0  3600					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  3600				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3600				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3600				   BLACK_KING_on_BLACK_SQUARE_3
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3630		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
      1  3648
      2  3648				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3648				  -.EARLY_LOCATION SET	*
      4  3648				  -	      ALIGN	256
      5  3648				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3648					      ENDIF
      0  3648					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  3648				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3648				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
      1  3690
      2  3690				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3690				  -.EARLY_LOCATION SET	*
      4  3690				  -	      ALIGN	256
      5  3690				  -	      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3690					      ENDIF
      0  3690					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  3690				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3690				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  3690		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  36a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
      1  36d8
      2  36d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  36d8				   .EARLY_LOCATION SET	*
      4  3700		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_MARKER_on_BLACK_SQUARE_1 wasted 40 bytes
      5  3700					      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3700					      ENDIF
      0  3700					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  3700				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3700				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
      1  3748
      2  3748				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3748				  -.EARLY_LOCATION SET	*
      4  3748				  -	      ALIGN	256
      5  3748				  -	      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3748					      ENDIF
      0  3748					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  3748				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3748				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3778		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
      1  3790
      2  3790				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3790				  -.EARLY_LOCATION SET	*
      4  3790				  -	      ALIGN	256
      5  3790				  -	      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3790					      ENDIF
      0  3790					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  3790				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3790				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     70  37d8
      0  37d8					      END_BANK
      1  37d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  37d8				  -	      CHECK_RAM_BANK_SIZE
      3  37d8					      ELSE
      0  37d8					      CHECK_BANK_SIZE
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 14 GFX3 size = $3d8 free = 39
      2  37d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      5  37d8					      ENDIF
     72  37d8
     73  37d8
     74  37d8							;---------------------------------------------------------------------------------------------------
     75  37d8
      0  37d8					      ROMBANK	GFX4
      1  3bd8 ????				      SEG	ROM_GFX4
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   GFX4_START SET	*
      6  3800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3800				   ROMBANK_GFX4 SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3800				   _LAST_BANK SETSTR	GFX4
     10  3800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     77  3800
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
      1  3800
      2  3800				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3800				  -.EARLY_LOCATION SET	*
      4  3800				  -	      ALIGN	256
      5  3800				  -	      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3800					      ENDIF
      0  3800					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  3800				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3800				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  3800		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  3818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
      1  3848
      2  3848				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3848				  -.EARLY_LOCATION SET	*
      4  3848				  -	      ALIGN	256
      5  3848				  -	      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3848					      ENDIF
      0  3848					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  3848				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3848				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
      1  3890
      2  3890				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3890				  -.EARLY_LOCATION SET	*
      4  3890				  -	      ALIGN	256
      5  3890				  -	      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3890					      ENDIF
      0  3890					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  3890				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3890				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  38c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
      1  38d8
      2  38d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  38d8				   .EARLY_LOCATION SET	*
      4  3900		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_MARKER_on_WHITE_SQUARE_3 wasted 40 bytes
      5  3900					      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3900					      ENDIF
      0  3900					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  3900				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3900				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
      1  3948
      2  3948				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3948				  -.EARLY_LOCATION SET	*
      4  3948				  -	      ALIGN	256
      5  3948				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3948					      ENDIF
      0  3948					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  3948				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3948				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  3948		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  3960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
      1  3990
      2  3990				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3990				  -.EARLY_LOCATION SET	*
      4  3990				  -	      ALIGN	256
      5  3990				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3990					      ENDIF
      0  3990					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  3990				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3990				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
      1  39d8
      2  39d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  39d8				   .EARLY_LOCATION SET	*
      4  3a00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PROMOTE_on_BLACK_SQUARE_2 wasted 40 bytes
      5  3a00					      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3a00					      ENDIF
      0  3a00					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  3a00				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3a00				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  3a30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
      1  3a48
      2  3a48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3a48				  -.EARLY_LOCATION SET	*
      4  3a48				  -	      ALIGN	256
      5  3a48				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3a48					      ENDIF
      0  3a48					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  3a48				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3a48				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
      1  3a90
      2  3a90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3a90				  -.EARLY_LOCATION SET	*
      4  3a90				  -	      ALIGN	256
      5  3a90				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3a90					      ENDIF
      0  3a90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  3a90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3a90				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  3a90		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
      1  3ad8
      2  3ad8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3ad8				   .EARLY_LOCATION SET	*
      4  3b00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PROMOTE_on_WHITE_SQUARE_1 wasted 40 bytes
      5  3b00					      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3b00					      ENDIF
      0  3b00					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  3b00				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3b00				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
      1  3b48
      2  3b48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3b48				  -.EARLY_LOCATION SET	*
      4  3b48				  -	      ALIGN	256
      5  3b48				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3b48					      ENDIF
      0  3b48					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  3b48				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3b48				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3b78		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3b90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  3b90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
      1  3b90
      2  3b90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3b90				  -.EARLY_LOCATION SET	*
      4  3b90				  -	      ALIGN	256
      5  3b90				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3b90					      ENDIF
      0  3b90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  3b90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3b90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3b90				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  3b90				   TEMPORARY_VAR SET	Overlay
      5  3b90				   TEMPORARY_OFFSET SET	0
      6  3b90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3b90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  3b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3bc0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     90  3bd8
      0  3bd8					      END_BANK
      1  3bd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  3bd8				  -	      CHECK_RAM_BANK_SIZE
      3  3bd8					      ELSE
      0  3bd8					      CHECK_BANK_SIZE
      1  3bd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 15 GFX4 size = $3d8 free = 39
      2  3bd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  3bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3bd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  3bd8				  -	      ERR
      6  3bd8					      ENDIF
      5  3bd8					      ENDIF
     92  3bd8
     93  3bd8
     94  3bd8							;---------------------------------------------------------------------------------------------------
     95  3bd8
      0  3bd8					      ROMBANK	PIECES_0
      1  3fd8 ????				      SEG	ROM_PIECES_0
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECES_0_START SET	*
      6  3c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3c00				   ROMBANK_PIECES_0 SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3c00				   _LAST_BANK SETSTR	PIECES_0
     10  3c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     97  3c00
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
      1  3c00
      2  3c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3c00				  -.EARLY_LOCATION SET	*
      4  3c00				  -	      ALIGN	256
      5  3c00				  -	      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3c00					      ENDIF
      0  3c00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  3c00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3c00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3c00				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  3c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  3c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  3c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
      1  3c48
      2  3c48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3c48				  -.EARLY_LOCATION SET	*
      4  3c48				  -	      ALIGN	256
      5  3c48				  -	      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3c48					      ENDIF
      0  3c48					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  3c48				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3c48				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3c48				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
      1  3c90
      2  3c90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3c90				  -.EARLY_LOCATION SET	*
      4  3c90				  -	      ALIGN	256
      5  3c90				  -	      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3c90					      ENDIF
      0  3c90					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  3c90				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3c90				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3c90				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
      1  3cd8
      2  3cd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3cd8				   .EARLY_LOCATION SET	*
      4  3d00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BLANK_on_WHITE_SQUARE_3 wasted 40 bytes
      5  3d00					      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3d00					      ENDIF
      0  3d00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  3d00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3d00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3d00				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
      1  3d48
      2  3d48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3d48				  -.EARLY_LOCATION SET	*
      4  3d48				  -	      ALIGN	256
      5  3d48				  -	      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3d48					      ENDIF
      0  3d48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  3d48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3d48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3d48				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  3d48		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
      1  3d90
      2  3d90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3d90				  -.EARLY_LOCATION SET	*
      4  3d90				  -	      ALIGN	256
      5  3d90				  -	      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3d90					      ENDIF
      0  3d90					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  3d90				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3d90				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3d90				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  3d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
      1  3dd8
      2  3dd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3dd8				   .EARLY_LOCATION SET	*
      4  3e00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PAWN_on_WHITE_SQUARE_2 wasted 40 bytes
      5  3e00					      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3e00					      ENDIF
      0  3e00					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  3e00				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3e00				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3e00				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e30		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
      1  3e48
      2  3e48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3e48				  -.EARLY_LOCATION SET	*
      4  3e48				  -	      ALIGN	256
      5  3e48				  -	      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3e48					      ENDIF
      0  3e48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  3e48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3e48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3e48				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
      1  3e90
      2  3e90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3e90				  -.EARLY_LOCATION SET	*
      4  3e90				  -	      ALIGN	256
      5  3e90				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3e90					      ENDIF
      0  3e90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  3e90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3e90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3e90				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  3e90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ea8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
      1  3ed8
      2  3ed8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3ed8				   .EARLY_LOCATION SET	*
      4  3f00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KNIGHT_on_WHITE_SQUARE_1 wasted 40 bytes
      5  3f00					      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3f00					      ENDIF
      0  3f00					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  3f00				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3f00				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3f00				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  3f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
      1  3f48
      2  3f48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3f48				  -.EARLY_LOCATION SET	*
      4  3f48				  -	      ALIGN	256
      5  3f48				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3f48					      ENDIF
      0  3f48					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  3f48				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3f48				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3f48				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
      1  3f90
      2  3f90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3f90				  -.EARLY_LOCATION SET	*
      4  3f90				  -	      ALIGN	256
      5  3f90				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3f90					      ENDIF
      0  3f90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  3f90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3f90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3f90				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    110  3fd8
      0  3fd8					      END_BANK
      1  3fd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  3fd8				  -	      CHECK_RAM_BANK_SIZE
      3  3fd8					      ELSE
      0  3fd8					      CHECK_BANK_SIZE
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 16 PIECES_0 size = $3d8 free = 39
      2  3fd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      5  3fd8					      ENDIF
    112  3fd8
    113  3fd8
    114  3fd8							;---------------------------------------------------------------------------------------------------
    115  3fd8
      0  3fd8					      ROMBANK	PIECES_1
      1  43d8 ????				      SEG	ROM_PIECES_1
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECES_1_START SET	*
      6  4000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4000				   ROMBANK_PIECES_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4000				   _LAST_BANK SETSTR	PIECES_1
     10  4000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    117  4000
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
      1  4000
      2  4000				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4000				  -.EARLY_LOCATION SET	*
      4  4000				  -	      ALIGN	256
      5  4000				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4000					      ENDIF
      0  4000					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  4000				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4000				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4000				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  4000		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  4018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4048					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  4048					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
      1  4048
      2  4048				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4048				  -.EARLY_LOCATION SET	*
      4  4048				  -	      ALIGN	256
      5  4048				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4048					      ENDIF
      0  4048					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  4048				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4048				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4048				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  4048				   TEMPORARY_VAR SET	Overlay
      5  4048				   TEMPORARY_OFFSET SET	0
      6  4048				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4048				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  4048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4060		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  4078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4090					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  4090					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
      1  4090
      2  4090				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4090				  -.EARLY_LOCATION SET	*
      4  4090				  -	      ALIGN	256
      5  4090				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4090					      ENDIF
      0  4090					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  4090				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4090				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4090				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  4090				   TEMPORARY_VAR SET	Overlay
      5  4090				   TEMPORARY_OFFSET SET	0
      6  4090				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4090				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  4090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  40a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  40c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  40d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  40d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
      1  40d8
      2  40d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  40d8				   .EARLY_LOCATION SET	*
      4  4100		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BISHOP_on_WHITE_SQUARE_3 wasted 40 bytes
      5  4100					      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4100					      ENDIF
      0  4100					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  4100				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4100				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4100				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  4100				   TEMPORARY_VAR SET	Overlay
      5  4100				   TEMPORARY_OFFSET SET	0
      6  4100				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4100				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  4100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4130		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4148					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  4148					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
      1  4148
      2  4148				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4148				  -.EARLY_LOCATION SET	*
      4  4148				  -	      ALIGN	256
      5  4148				  -	      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4148					      ENDIF
      0  4148					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  4148				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4148				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4148				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  4148				   TEMPORARY_VAR SET	Overlay
      5  4148				   TEMPORARY_OFFSET SET	0
      6  4148				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4148				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  4148		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4160		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4190					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  4190					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
      1  4190
      2  4190				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4190				  -.EARLY_LOCATION SET	*
      4  4190				  -	      ALIGN	256
      5  4190				  -	      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4190					      ENDIF
      0  4190					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  4190				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4190				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4190				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  4190				   TEMPORARY_VAR SET	Overlay
      5  4190				   TEMPORARY_OFFSET SET	0
      6  4190				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4190				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  4190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  41a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  41c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  41d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  41d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
      1  41d8
      2  41d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  41d8				   .EARLY_LOCATION SET	*
      4  4200		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_ROOK_on_WHITE_SQUARE_2 wasted 40 bytes
      5  4200					      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4200					      ENDIF
      0  4200					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  4200				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4200				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4200				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  4200				   TEMPORARY_VAR SET	Overlay
      5  4200				   TEMPORARY_OFFSET SET	0
      6  4200				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4200				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  4200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4218		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4230		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4248					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  4248					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
      1  4248
      2  4248				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4248				  -.EARLY_LOCATION SET	*
      4  4248				  -	      ALIGN	256
      5  4248				  -	      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4248					      ENDIF
      0  4248					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  4248				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4248				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4248				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  4248				   TEMPORARY_VAR SET	Overlay
      5  4248				   TEMPORARY_OFFSET SET	0
      6  4248				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4248				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  4248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4278		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4290					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  4290					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
      1  4290
      2  4290				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4290				  -.EARLY_LOCATION SET	*
      4  4290				  -	      ALIGN	256
      5  4290				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4290					      ENDIF
      0  4290					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  4290				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4290				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4290				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  4290				   TEMPORARY_VAR SET	Overlay
      5  4290				   TEMPORARY_OFFSET SET	0
      6  4290				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4290				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  4290		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$50,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  42a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  42c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  42d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  42d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
      1  42d8
      2  42d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  42d8				   .EARLY_LOCATION SET	*
      4  4300		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_QUEEN_on_WHITE_SQUARE_1 wasted 40 bytes
      5  4300					      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4300					      ENDIF
      0  4300					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  4300				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4300				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4300				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  4300				   TEMPORARY_VAR SET	Overlay
      5  4300				   TEMPORARY_OFFSET SET	0
      6  4300				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4300				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  4300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4318		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$54,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4348					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  4348					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
      1  4348
      2  4348				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4348				  -.EARLY_LOCATION SET	*
      4  4348				  -	      ALIGN	256
      5  4348				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4348					      ENDIF
      0  4348					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  4348				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4348				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4348				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  4348				   TEMPORARY_VAR SET	Overlay
      5  4348				   TEMPORARY_OFFSET SET	0
      6  4348				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4348				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  4348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4360		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$02,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4378		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$05,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4390					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  4390					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
      1  4390
      2  4390				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4390				  -.EARLY_LOCATION SET	*
      4  4390				  -	      ALIGN	256
      5  4390				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4390					      ENDIF
      0  4390					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  4390				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4390				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4390				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  4390				   TEMPORARY_VAR SET	Overlay
      5  4390				   TEMPORARY_OFFSET SET	0
      6  4390				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4390				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  4390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  43a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  43c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$a8,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    130  43d8
      0  43d8					      END_BANK
      1  43d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  43d8				  -	      CHECK_RAM_BANK_SIZE
      3  43d8					      ELSE
      0  43d8					      CHECK_BANK_SIZE
      1  43d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 17 PIECES_1 size = $3d8 free = 39
      2  43d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  43d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  43d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  43d8				  -	      ERR
      6  43d8					      ENDIF
      5  43d8					      ENDIF
    132  43d8
    133  43d8
    134  43d8							;---------------------------------------------------------------------------------------------------
    135  43d8
      0  43d8					      ROMBANK	PIECES_2
      1  47d8 ????				      SEG	ROM_PIECES_2
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   PIECES_2_START SET	*
      6  4400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4400				   ROMBANK_PIECES_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4400				   _LAST_BANK SETSTR	PIECES_2
     10  4400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    137  4400
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4400					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  4400					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
      1  4400
      2  4400				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4400				  -.EARLY_LOCATION SET	*
      4  4400				  -	      ALIGN	256
      5  4400				  -	      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4400					      ENDIF
      0  4400					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  4400				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4400				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4400				   WHITE_KING_on_WHITE_SQUARE_0
      4  4400				   TEMPORARY_VAR SET	Overlay
      5  4400				   TEMPORARY_OFFSET SET	0
      6  4400				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4400				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  4400		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  4418		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4448					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  4448					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
      1  4448
      2  4448				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4448				  -.EARLY_LOCATION SET	*
      4  4448				  -	      ALIGN	256
      5  4448				  -	      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4448					      ENDIF
      0  4448					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  4448				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4448				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4448				   WHITE_KING_on_WHITE_SQUARE_1
      4  4448				   TEMPORARY_VAR SET	Overlay
      5  4448				   TEMPORARY_OFFSET SET	0
      6  4448				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4448				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  4448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4460		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  4478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4490					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  4490					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
      1  4490
      2  4490				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4490				  -.EARLY_LOCATION SET	*
      4  4490				  -	      ALIGN	256
      5  4490				  -	      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4490					      ENDIF
      0  4490					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  4490				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4490				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4490				   WHITE_KING_on_WHITE_SQUARE_2
      4  4490				   TEMPORARY_VAR SET	Overlay
      5  4490				   TEMPORARY_OFFSET SET	0
      6  4490				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4490				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  4490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  44a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  44c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  44d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  44d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
      1  44d8
      2  44d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  44d8				   .EARLY_LOCATION SET	*
      4  4500		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KING_on_WHITE_SQUARE_3 wasted 40 bytes
      5  4500					      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4500					      ENDIF
      0  4500					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  4500				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4500				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4500				   WHITE_KING_on_WHITE_SQUARE_3
      4  4500				   TEMPORARY_VAR SET	Overlay
      5  4500				   TEMPORARY_OFFSET SET	0
      6  4500				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4500				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  4500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4530		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4548					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  4548					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
      1  4548
      2  4548				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4548				  -.EARLY_LOCATION SET	*
      4  4548				  -	      ALIGN	256
      5  4548				  -	      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4548					      ENDIF
      0  4548					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  4548				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4548				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4548				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  4548				   TEMPORARY_VAR SET	Overlay
      5  4548				   TEMPORARY_OFFSET SET	0
      6  4548				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4548				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  4548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4590					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  4590					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
      1  4590
      2  4590				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4590				  -.EARLY_LOCATION SET	*
      4  4590				  -	      ALIGN	256
      5  4590				  -	      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4590					      ENDIF
      0  4590					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  4590				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4590				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4590				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  4590				   TEMPORARY_VAR SET	Overlay
      5  4590				   TEMPORARY_OFFSET SET	0
      6  4590				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4590				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  4590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  45a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  45c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  45d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  45d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
      1  45d8
      2  45d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  45d8				   .EARLY_LOCATION SET	*
      4  4600		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BLANK_on_BLACK_SQUARE_2 wasted 40 bytes
      5  4600					      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4600					      ENDIF
      0  4600					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  4600				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4600				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4600				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  4600				   TEMPORARY_VAR SET	Overlay
      5  4600				   TEMPORARY_OFFSET SET	0
      6  4600				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4600				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  4600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4648					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  4648					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
      1  4648
      2  4648				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4648				  -.EARLY_LOCATION SET	*
      4  4648				  -	      ALIGN	256
      5  4648				  -	      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4648					      ENDIF
      0  4648					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  4648				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4648				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4648				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  4648				   TEMPORARY_VAR SET	Overlay
      5  4648				   TEMPORARY_OFFSET SET	0
      6  4648				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4648				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  4648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4690					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  4690					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
      1  4690
      2  4690				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4690				  -.EARLY_LOCATION SET	*
      4  4690				  -	      ALIGN	256
      5  4690				  -	      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4690					      ENDIF
      0  4690					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  4690				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4690				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4690				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  4690				   TEMPORARY_VAR SET	Overlay
      5  4690				   TEMPORARY_OFFSET SET	0
      6  4690				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4690				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  4690		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  46a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  46c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  46d8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  46d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
      1  46d8
      2  46d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  46d8				   .EARLY_LOCATION SET	*
      4  4700		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PAWN_on_BLACK_SQUARE_1 wasted 40 bytes
      5  4700					      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4700					      ENDIF
      0  4700					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  4700				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4700				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4700				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  4700				   TEMPORARY_VAR SET	Overlay
      5  4700				   TEMPORARY_OFFSET SET	0
      6  4700				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4700				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  4700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4718		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  4730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4748					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  4748					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
      1  4748
      2  4748				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4748				  -.EARLY_LOCATION SET	*
      4  4748				  -	      ALIGN	256
      5  4748				  -	      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4748					      ENDIF
      0  4748					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  4748				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4748				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4748				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  4748				   TEMPORARY_VAR SET	Overlay
      5  4748				   TEMPORARY_OFFSET SET	0
      6  4748				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4748				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  4748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4760		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  4778		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4790					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  4790					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
      1  4790
      2  4790				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4790				  -.EARLY_LOCATION SET	*
      4  4790				  -	      ALIGN	256
      5  4790				  -	      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4790					      ENDIF
      0  4790					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  4790				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4790				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4790				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  4790				   TEMPORARY_VAR SET	Overlay
      5  4790				   TEMPORARY_OFFSET SET	0
      6  4790				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4790				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  4790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  47a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  47c0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    150  47d8
      0  47d8					      END_BANK
      1  47d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  47d8				  -	      CHECK_RAM_BANK_SIZE
      3  47d8					      ELSE
      0  47d8					      CHECK_BANK_SIZE
      1  47d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 18 PIECES_2 size = $3d8 free = 39
      2  47d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  47d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  47d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  47d8				  -	      ERR
      6  47d8					      ENDIF
      5  47d8					      ENDIF
    152  47d8
    153  47d8
    154  47d8							;---------------------------------------------------------------------------------------------------
    155  47d8
      0  47d8					      ROMBANK	PIECES_3
      1  4bd8 ????				      SEG	ROM_PIECES_3
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   PIECES_3_START SET	*
      6  4800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4800				   ROMBANK_PIECES_3 SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4800				   _LAST_BANK SETSTR	PIECES_3
     10  4800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    157  4800
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
      1  4800
      2  4800				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4800				  -.EARLY_LOCATION SET	*
      4  4800				  -	      ALIGN	256
      5  4800				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4800					      ENDIF
      0  4800					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  4800				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4800				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4800				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  4800		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  4818		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  4830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4848					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  4848					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
      1  4848
      2  4848				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4848				  -.EARLY_LOCATION SET	*
      4  4848				  -	      ALIGN	256
      5  4848				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4848					      ENDIF
      0  4848					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  4848				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4848				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4848				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  4848				   TEMPORARY_VAR SET	Overlay
      5  4848				   TEMPORARY_OFFSET SET	0
      6  4848				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4848				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  4848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4860		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  4878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4890					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  4890					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
      1  4890
      2  4890				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4890				  -.EARLY_LOCATION SET	*
      4  4890				  -	      ALIGN	256
      5  4890				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4890					      ENDIF
      0  4890					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  4890				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4890				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4890				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  4890				   TEMPORARY_VAR SET	Overlay
      5  4890				   TEMPORARY_OFFSET SET	0
      6  4890				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4890				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  4890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  48a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  48c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  48d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  48d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
      1  48d8
      2  48d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  48d8				   .EARLY_LOCATION SET	*
      4  4900		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KNIGHT_on_BLACK_SQUARE_3 wasted 40 bytes
      5  4900					      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4900					      ENDIF
      0  4900					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  4900				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4900				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4900				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  4900				   TEMPORARY_VAR SET	Overlay
      5  4900				   TEMPORARY_OFFSET SET	0
      6  4900				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4900				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  4900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4930		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4948					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  4948					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
      1  4948
      2  4948				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4948				  -.EARLY_LOCATION SET	*
      4  4948				  -	      ALIGN	256
      5  4948				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4948					      ENDIF
      0  4948					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  4948				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4948				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4948				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  4948				   TEMPORARY_VAR SET	Overlay
      5  4948				   TEMPORARY_OFFSET SET	0
      6  4948				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4948				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  4948		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  4960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  4978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4990					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  4990					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
      1  4990
      2  4990				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4990				  -.EARLY_LOCATION SET	*
      4  4990				  -	      ALIGN	256
      5  4990				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4990					      ENDIF
      0  4990					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  4990				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4990				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4990				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  4990				   TEMPORARY_VAR SET	Overlay
      5  4990				   TEMPORARY_OFFSET SET	0
      6  4990				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4990				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  4990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  49a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  49c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  49d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  49d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
      1  49d8
      2  49d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  49d8				   .EARLY_LOCATION SET	*
      4  4a00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BISHOP_on_BLACK_SQUARE_2 wasted 40 bytes
      5  4a00					      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4a00					      ENDIF
      0  4a00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  4a00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4a00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4a00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  4a00				   TEMPORARY_VAR SET	Overlay
      5  4a00				   TEMPORARY_OFFSET SET	0
      6  4a00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4a00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  4a30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4a48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
      1  4a48
      2  4a48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4a48				  -.EARLY_LOCATION SET	*
      4  4a48				  -	      ALIGN	256
      5  4a48				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4a48					      ENDIF
      0  4a48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  4a48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4a48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4a48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  4a48				   TEMPORARY_VAR SET	Overlay
      5  4a48				   TEMPORARY_OFFSET SET	0
      6  4a48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4a48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4a90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
      1  4a90
      2  4a90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4a90				  -.EARLY_LOCATION SET	*
      4  4a90				  -	      ALIGN	256
      5  4a90				  -	      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4a90					      ENDIF
      0  4a90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  4a90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4a90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4a90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  4a90				   TEMPORARY_VAR SET	Overlay
      5  4a90				   TEMPORARY_OFFSET SET	0
      6  4a90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4a90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  4a90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  4aa8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  4ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ad8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
      1  4ad8
      2  4ad8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4ad8				   .EARLY_LOCATION SET	*
      4  4b00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_ROOK_on_BLACK_SQUARE_1 wasted 40 bytes
      5  4b00					      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4b00					      ENDIF
      0  4b00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  4b00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4b00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4b00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  4b00				   TEMPORARY_VAR SET	Overlay
      5  4b00				   TEMPORARY_OFFSET SET	0
      6  4b00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4b00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  4b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4b48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
      1  4b48
      2  4b48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4b48				  -.EARLY_LOCATION SET	*
      4  4b48				  -	      ALIGN	256
      5  4b48				  -	      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4b48					      ENDIF
      0  4b48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  4b48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4b48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4b48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  4b48				   TEMPORARY_VAR SET	Overlay
      5  4b48				   TEMPORARY_OFFSET SET	0
      6  4b48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4b48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  4b78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4b90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
      1  4b90
      2  4b90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4b90				  -.EARLY_LOCATION SET	*
      4  4b90				  -	      ALIGN	256
      5  4b90				  -	      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4b90					      ENDIF
      0  4b90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  4b90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4b90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4b90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  4b90				   TEMPORARY_VAR SET	Overlay
      5  4b90				   TEMPORARY_OFFSET SET	0
      6  4b90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4b90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4bc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    170  4bd8
      0  4bd8					      END_BANK
      1  4bd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  4bd8				  -	      CHECK_RAM_BANK_SIZE
      3  4bd8					      ELSE
      0  4bd8					      CHECK_BANK_SIZE
      1  4bd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 19 PIECES_3 size = $3d8 free = 39
      2  4bd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  4bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4bd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  4bd8				  -	      ERR
      6  4bd8					      ENDIF
      5  4bd8					      ENDIF
    172  4bd8
    173  4bd8
    174  4bd8							;---------------------------------------------------------------------------------------------------
    175  4bd8
      0  4bd8					      ROMBANK	PIECE_4
      1  4fd8 ????				      SEG	ROM_PIECE_4
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   PIECE_4_START SET	*
      6  4c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4c00				   ROMBANK_PIECE_4 SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4c00				   _LAST_BANK SETSTR	PIECE_4
     10  4c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    177  4c00
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
      1  4c00
      2  4c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4c00				  -.EARLY_LOCATION SET	*
      4  4c00				  -	      ALIGN	256
      5  4c00				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4c00					      ENDIF
      0  4c00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  4c00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4c00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4c00				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  4c00		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$50,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$50,$50,$00	;PF0
      4  4c18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$80,$80,$00	;PF1
      5  4c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4c48					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
      1  4c48
      2  4c48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4c48				  -.EARLY_LOCATION SET	*
      4  4c48				  -	      ALIGN	256
      5  4c48				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4c48					      ENDIF
      0  4c48					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  4c48				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4c48				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4c48				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  4c48				   TEMPORARY_VAR SET	Overlay
      5  4c48				   TEMPORARY_OFFSET SET	0
      6  4c48				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4c48				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  4c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$54,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$54,$54,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4c90					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
      1  4c90
      2  4c90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4c90				  -.EARLY_LOCATION SET	*
      4  4c90				  -	      ALIGN	256
      5  4c90				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4c90					      ENDIF
      0  4c90					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  4c90				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4c90				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4c90				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  4c90				   TEMPORARY_VAR SET	Overlay
      5  4c90				   TEMPORARY_OFFSET SET	0
      6  4c90				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4c90				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$02,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$02,$02,$00	;PF1
      5  4cc0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$05,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$05,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4cd8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
      1  4cd8
      2  4cd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4cd8				   .EARLY_LOCATION SET	*
      4  4d00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_QUEEN_on_BLACK_SQUARE_3 wasted 40 bytes
      5  4d00					      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4d00					      ENDIF
      0  4d00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  4d00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4d00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4d00				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  4d00				   TEMPORARY_VAR SET	Overlay
      5  4d00				   TEMPORARY_OFFSET SET	0
      6  4d00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4d00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  4d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$a8,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$a8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4d48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
      1  4d48
      2  4d48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4d48				  -.EARLY_LOCATION SET	*
      4  4d48				  -	      ALIGN	256
      5  4d48				  -	      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4d48					      ENDIF
      0  4d48					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  4d48				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4d48				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4d48				   WHITE_KING_on_BLACK_SQUARE_0
      4  4d48				   TEMPORARY_VAR SET	Overlay
      5  4d48				   TEMPORARY_OFFSET SET	0
      6  4d48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4d48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  4d48		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  4d60		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  4d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4d90					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
      1  4d90
      2  4d90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4d90				  -.EARLY_LOCATION SET	*
      4  4d90				  -	      ALIGN	256
      5  4d90				  -	      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4d90					      ENDIF
      0  4d90					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  4d90				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4d90				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4d90				   WHITE_KING_on_BLACK_SQUARE_1
      4  4d90				   TEMPORARY_VAR SET	Overlay
      5  4d90				   TEMPORARY_OFFSET SET	0
      6  4d90				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4d90				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  4d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4da8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  4dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4dd8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
      1  4dd8
      2  4dd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4dd8				   .EARLY_LOCATION SET	*
      4  4e00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KING_on_BLACK_SQUARE_2 wasted 40 bytes
      5  4e00					      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4e00					      ENDIF
      0  4e00					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  4e00				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4e00				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4e00				   WHITE_KING_on_BLACK_SQUARE_2
      4  4e00				   TEMPORARY_VAR SET	Overlay
      5  4e00				   TEMPORARY_OFFSET SET	0
      6  4e00				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4e00				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  4e30		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4e48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
      1  4e48
      2  4e48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4e48				  -.EARLY_LOCATION SET	*
      4  4e48				  -	      ALIGN	256
      5  4e48				  -	      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4e48					      ENDIF
      0  4e48					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  4e48				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4e48				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4e48				   WHITE_KING_on_BLACK_SQUARE_3
      4  4e48				   TEMPORARY_VAR SET	Overlay
      5  4e48				   TEMPORARY_OFFSET SET	0
      6  4e48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4e48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  4e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e78		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4e90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
      1  4e90
      2  4e90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4e90				  -.EARLY_LOCATION SET	*
      4  4e90				  -	      ALIGN	256
      5  4e90				  -	      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4e90					      ENDIF
      0  4e90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  4e90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4e90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4e90				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  4e90				   TEMPORARY_VAR SET	Overlay
      5  4e90				   TEMPORARY_OFFSET SET	0
      6  4e90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4e90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  4ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  4ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ed8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
      1  4ed8
      2  4ed8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4ed8				   .EARLY_LOCATION SET	*
      4  4f00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BLANK_on_WHITE_SQUARE_1 wasted 40 bytes
      5  4f00					      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4f00					      ENDIF
      0  4f00					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  4f00				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4f00				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4f00				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  4f00				   TEMPORARY_VAR SET	Overlay
      5  4f00				   TEMPORARY_OFFSET SET	0
      6  4f00				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4f00				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  4f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4f48					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  4f48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
      1  4f48
      2  4f48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4f48				  -.EARLY_LOCATION SET	*
      4  4f48				  -	      ALIGN	256
      5  4f48				  -	      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4f48					      ENDIF
      0  4f48					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  4f48				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4f48				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4f48				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  4f48				   TEMPORARY_VAR SET	Overlay
      5  4f48				   TEMPORARY_OFFSET SET	0
      6  4f48				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4f48				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  4f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  4f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4f90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  4f90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
      1  4f90
      2  4f90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4f90				  -.EARLY_LOCATION SET	*
      4  4f90				  -	      ALIGN	256
      5  4f90				  -	      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4f90					      ENDIF
      0  4f90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  4f90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4f90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4f90				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  4f90				   TEMPORARY_VAR SET	Overlay
      5  4f90				   TEMPORARY_OFFSET SET	0
      6  4f90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4f90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  4f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE @2 GRAPHICS DATA.asm
    190  4fd8
      0  4fd8					      END_BANK
      1  4fd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  4fd8				  -	      CHECK_RAM_BANK_SIZE
      3  4fd8					      ELSE
      0  4fd8					      CHECK_BANK_SIZE
      1  4fd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 20 PIECE_4 size = $3d8 free = 39
      2  4fd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  4fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4fd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  4fd8				  -	      ERR
      6  4fd8					      ENDIF
      5  4fd8					      ENDIF
    192  4fd8
    193  4fd8
    194  4fd8							;---------------------------------------------------------------------------------------------------
    195  4fd8
      0  4fd8					      ROMBANK	PIECE_5
      1  53d8 ????				      SEG	ROM_PIECE_5
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   PIECE_5_START SET	*
      6  5000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5000				   ROMBANK_PIECE_5 SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5000				   _LAST_BANK SETSTR	PIECE_5
     10  5000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    197  5000
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5000					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  5000					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
      1  5000
      2  5000				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5000				  -.EARLY_LOCATION SET	*
      4  5000				  -	      ALIGN	256
      5  5000				  -	      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5000					      ENDIF
      0  5000					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  5000				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5000				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5000				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  5000		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  5018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5048					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  5048					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
      1  5048
      2  5048				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5048				  -.EARLY_LOCATION SET	*
      4  5048				  -	      ALIGN	256
      5  5048				  -	      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5048					      ENDIF
      0  5048					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  5048				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5048				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5048				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  5048				   TEMPORARY_VAR SET	Overlay
      5  5048				   TEMPORARY_OFFSET SET	0
      6  5048				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5048				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  5048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5060		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  5078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5090					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  5090					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
      1  5090
      2  5090				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5090				  -.EARLY_LOCATION SET	*
      4  5090				  -	      ALIGN	256
      5  5090				  -	      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5090					      ENDIF
      0  5090					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  5090				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5090				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5090				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  5090				   TEMPORARY_VAR SET	Overlay
      5  5090				   TEMPORARY_OFFSET SET	0
      6  5090				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5090				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  5090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  50a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  50c0		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  50d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  50d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
      1  50d8
      2  50d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  50d8				   .EARLY_LOCATION SET	*
      4  5100		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PAWN_on_WHITE_SQUARE_3 wasted 40 bytes
      5  5100					      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5100					      ENDIF
      0  5100					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  5100				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5100				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5100				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  5100				   TEMPORARY_VAR SET	Overlay
      5  5100				   TEMPORARY_OFFSET SET	0
      6  5100				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5100				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  5100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5130		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5148					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  5148					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
      1  5148
      2  5148				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5148				  -.EARLY_LOCATION SET	*
      4  5148				  -	      ALIGN	256
      5  5148				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5148					      ENDIF
      0  5148					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  5148				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5148				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5148				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  5148				   TEMPORARY_VAR SET	Overlay
      5  5148				   TEMPORARY_OFFSET SET	0
      6  5148				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5148				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  5148		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  5160		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  5178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5190					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  5190					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
      1  5190
      2  5190				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5190				  -.EARLY_LOCATION SET	*
      4  5190				  -	      ALIGN	256
      5  5190				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5190					      ENDIF
      0  5190					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  5190				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5190				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5190				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  5190				   TEMPORARY_VAR SET	Overlay
      5  5190				   TEMPORARY_OFFSET SET	0
      6  5190				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5190				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  5190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  51a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  51c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  51d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  51d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
      1  51d8
      2  51d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  51d8				   .EARLY_LOCATION SET	*
      4  5200		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KNIGHT_on_WHITE_SQUARE_2 wasted 40 bytes
      5  5200					      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5200					      ENDIF
      0  5200					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  5200				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5200				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5200				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  5200				   TEMPORARY_VAR SET	Overlay
      5  5200				   TEMPORARY_OFFSET SET	0
      6  5200				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5200				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  5200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5218		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  5230		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5248					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  5248					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
      1  5248
      2  5248				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5248				  -.EARLY_LOCATION SET	*
      4  5248				  -	      ALIGN	256
      5  5248				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5248					      ENDIF
      0  5248					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  5248				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5248				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5248				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  5248				   TEMPORARY_VAR SET	Overlay
      5  5248				   TEMPORARY_OFFSET SET	0
      6  5248				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5248				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  5248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5278		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5290					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  5290					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
      1  5290
      2  5290				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5290				  -.EARLY_LOCATION SET	*
      4  5290				  -	      ALIGN	256
      5  5290				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5290					      ENDIF
      0  5290					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  5290				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5290				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5290				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  5290				   TEMPORARY_VAR SET	Overlay
      5  5290				   TEMPORARY_OFFSET SET	0
      6  5290				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5290				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  5290		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  52a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  52c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  52d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  52d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
      1  52d8
      2  52d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  52d8				   .EARLY_LOCATION SET	*
      4  5300		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BISHOP_on_WHITE_SQUARE_1 wasted 40 bytes
      5  5300					      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5300					      ENDIF
      0  5300					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  5300				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5300				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5300				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  5300				   TEMPORARY_VAR SET	Overlay
      5  5300				   TEMPORARY_OFFSET SET	0
      6  5300				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5300				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  5300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5318		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  5330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5348					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  5348					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
      1  5348
      2  5348				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5348				  -.EARLY_LOCATION SET	*
      4  5348				  -	      ALIGN	256
      5  5348				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5348					      ENDIF
      0  5348					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  5348				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5348				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5348				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  5348				   TEMPORARY_VAR SET	Overlay
      5  5348				   TEMPORARY_OFFSET SET	0
      6  5348				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5348				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  5348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5360		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  5378		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5390					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  5390					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
      1  5390
      2  5390				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5390				  -.EARLY_LOCATION SET	*
      4  5390				  -	      ALIGN	256
      5  5390				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5390					      ENDIF
      0  5390					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  5390				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5390				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5390				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  5390				   TEMPORARY_VAR SET	Overlay
      5  5390				   TEMPORARY_OFFSET SET	0
      6  5390				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5390				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  5390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  53a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
    210  53d8
      0  53d8					      END_BANK
      1  53d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  53d8				  -	      CHECK_RAM_BANK_SIZE
      3  53d8					      ELSE
      0  53d8					      CHECK_BANK_SIZE
      1  53d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 21 PIECE_5 size = $3d8 free = 39
      2  53d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  53d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  53d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  53d8				  -	      ERR
      6  53d8					      ENDIF
      5  53d8					      ENDIF
    212  53d8
    213  53d8
    214  53d8							;---------------------------------------------------------------------------------------------------
    215  53d8
      0  53d8					      ROMBANK	PIECE_6
      1  5790 ????				      SEG	ROM_PIECE_6
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   PIECE_6_START SET	*
      6  5400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5400				   ROMBANK_PIECE_6 SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5400				   _LAST_BANK SETSTR	PIECE_6
     10  5400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    217  5400
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
      1  5400
      2  5400				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5400				  -.EARLY_LOCATION SET	*
      4  5400				  -	      ALIGN	256
      5  5400				  -	      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5400					      ENDIF
      0  5400					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  5400				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5400				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5400				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  5400		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  5418		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
      1  5448
      2  5448				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5448				  -.EARLY_LOCATION SET	*
      4  5448				  -	      ALIGN	256
      5  5448				  -	      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5448					      ENDIF
      0  5448					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  5448				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5448				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5448				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
      1  5490
      2  5490				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5490				  -.EARLY_LOCATION SET	*
      4  5490				  -	      ALIGN	256
      5  5490				  -	      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5490					      ENDIF
      0  5490					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  5490				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5490				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5490				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  54c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
      1  54d8
      2  54d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  54d8				   .EARLY_LOCATION SET	*
      4  5500		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_ROOK_on_WHITE_SQUARE_3 wasted 40 bytes
      5  5500					      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5500					      ENDIF
      0  5500					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  5500				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5500				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  5500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
      1  5548
      2  5548				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5548				  -.EARLY_LOCATION SET	*
      4  5548				  -	      ALIGN	256
      5  5548				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5548					      ENDIF
      0  5548					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  5548				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5548				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5548				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  5548		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$50,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$50,$50,$00	;PF0
      4  5560		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
      1  5590
      2  5590				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5590				  -.EARLY_LOCATION SET	*
      4  5590				  -	      ALIGN	256
      5  5590				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5590					      ENDIF
      0  5590					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  5590				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5590				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5590				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$54,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$54,$54,$00	;PF1
      5  55c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
      1  55d8
      2  55d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  55d8				   .EARLY_LOCATION SET	*
      4  5600		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_QUEEN_on_WHITE_SQUARE_2 wasted 40 bytes
      5  5600					      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5600					      ENDIF
      0  5600					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  5600				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5600				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5600				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$02,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$02,$02,$00	;PF1
      5  5630		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$05,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$05,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
      1  5648
      2  5648				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5648				  -.EARLY_LOCATION SET	*
      4  5648				  -	      ALIGN	256
      5  5648				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5648					      ENDIF
      0  5648					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  5648				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5648				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5648				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$a8,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$a8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
      1  5690
      2  5690				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5690				  -.EARLY_LOCATION SET	*
      4  5690				  -	      ALIGN	256
      5  5690				  -	      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5690					      ENDIF
      0  5690					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  5690				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5690				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5690				   BLACK_KING_on_WHITE_SQUARE_0
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  5690		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  56a8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
      1  56d8
      2  56d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  56d8				   .EARLY_LOCATION SET	*
      4  5700		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KING_on_WHITE_SQUARE_1 wasted 40 bytes
      5  5700					      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5700					      ENDIF
      0  5700					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  5700				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5700				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5700				   BLACK_KING_on_WHITE_SQUARE_1
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  5730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
      1  5748
      2  5748				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5748				  -.EARLY_LOCATION SET	*
      4  5748				  -	      ALIGN	256
      5  5748				  -	      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5748					      ENDIF
      0  5748					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  5748				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5748				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5748				   BLACK_KING_on_WHITE_SQUARE_2
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  5778		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
    229  5790
      0  5790					      END_BANK
      1  5790				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  5790				  -	      CHECK_RAM_BANK_SIZE
      3  5790					      ELSE
      0  5790					      CHECK_BANK_SIZE
      1  5790		       03 90	   .TEMP      =	* - _BANK_START
 ROM bank # 22 PIECE_6 size = $390 free = 111
      2  5790					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  5790				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5790				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  5790				  -	      ERR
      6  5790					      ENDIF
      5  5790					      ENDIF
    231  5790
    232  5790
    233  5790							;---------------------------------------------------------------------------------------------------
    234  5790
      0  5790					      ROMBANK	PIECE_7
      1  5bd8 ????				      SEG	ROM_PIECE_7
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   PIECE_7_START SET	*
      6  5800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5800				   ROMBANK_PIECE_7 SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5800				   _LAST_BANK SETSTR	PIECE_7
     10  5800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    236  5800
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5800					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  5800					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
      1  5800
      2  5800				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5800				  -.EARLY_LOCATION SET	*
      4  5800				  -	      ALIGN	256
      5  5800				  -	      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5800					      ENDIF
      0  5800					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  5800				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5800				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5800				   BLACK_KING_on_WHITE_SQUARE_3
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  5800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5830		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5848					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  5848					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
      1  5848
      2  5848				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5848				  -.EARLY_LOCATION SET	*
      4  5848				  -	      ALIGN	256
      5  5848				  -	      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5848					      ENDIF
      0  5848					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  5848				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5848				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5848				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  5848				   TEMPORARY_VAR SET	Overlay
      5  5848				   TEMPORARY_OFFSET SET	0
      6  5848				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5848				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  5848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5890					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  5890					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
      1  5890
      2  5890				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5890				  -.EARLY_LOCATION SET	*
      4  5890				  -	      ALIGN	256
      5  5890				  -	      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5890					      ENDIF
      0  5890					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  5890				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5890				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5890				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  5890				   TEMPORARY_VAR SET	Overlay
      5  5890				   TEMPORARY_OFFSET SET	0
      6  5890				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5890				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  5890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  58a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  58c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  58d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  58d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
      1  58d8
      2  58d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  58d8				   .EARLY_LOCATION SET	*
      4  5900		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BLANK_on_BLACK_SQUARE_2 wasted 40 bytes
      5  5900					      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5900					      ENDIF
      0  5900					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  5900				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5900				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5900				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  5900				   TEMPORARY_VAR SET	Overlay
      5  5900				   TEMPORARY_OFFSET SET	0
      6  5900				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5900				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  5900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5948					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  5948					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
      1  5948
      2  5948				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5948				  -.EARLY_LOCATION SET	*
      4  5948				  -	      ALIGN	256
      5  5948				  -	      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5948					      ENDIF
      0  5948					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  5948				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5948				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5948				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  5948				   TEMPORARY_VAR SET	Overlay
      5  5948				   TEMPORARY_OFFSET SET	0
      6  5948				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5948				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  5948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5990					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  5990					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
      1  5990
      2  5990				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5990				  -.EARLY_LOCATION SET	*
      4  5990				  -	      ALIGN	256
      5  5990				  -	      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5990					      ENDIF
      0  5990					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  5990				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5990				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5990				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  5990				   TEMPORARY_VAR SET	Overlay
      5  5990				   TEMPORARY_OFFSET SET	0
      6  5990				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5990				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  5990		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  59a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  59c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  59d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  59d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
      1  59d8
      2  59d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  59d8				   .EARLY_LOCATION SET	*
      4  5a00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PAWN_on_BLACK_SQUARE_1 wasted 40 bytes
      5  5a00					      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5a00					      ENDIF
      0  5a00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  5a00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5a00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5a00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  5a00				   TEMPORARY_VAR SET	Overlay
      5  5a00				   TEMPORARY_OFFSET SET	0
      6  5a00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5a00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  5a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a18		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5a48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
      1  5a48
      2  5a48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5a48				  -.EARLY_LOCATION SET	*
      4  5a48				  -	      ALIGN	256
      5  5a48				  -	      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5a48					      ENDIF
      0  5a48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  5a48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5a48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5a48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  5a48				   TEMPORARY_VAR SET	Overlay
      5  5a48				   TEMPORARY_OFFSET SET	0
      6  5a48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5a48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a78		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5a90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
      1  5a90
      2  5a90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5a90				  -.EARLY_LOCATION SET	*
      4  5a90				  -	      ALIGN	256
      5  5a90				  -	      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5a90					      ENDIF
      0  5a90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  5a90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5a90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5a90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  5a90				   TEMPORARY_VAR SET	Overlay
      5  5a90				   TEMPORARY_OFFSET SET	0
      6  5a90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  5a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5ad8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
      1  5ad8
      2  5ad8					      IF	(>( * + 72 -1 )) > ( >* )
      3  5ad8				   .EARLY_LOCATION SET	*
      4  5b00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KNIGHT_on_BLACK_SQUARE_0 wasted 40 bytes
      5  5b00					      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5b00					      ENDIF
      0  5b00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  5b00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5b00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5b00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  5b00				   TEMPORARY_VAR SET	Overlay
      5  5b00				   TEMPORARY_OFFSET SET	0
      6  5b00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5b00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  5b00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  5b18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5b48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
      1  5b48
      2  5b48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5b48				  -.EARLY_LOCATION SET	*
      4  5b48				  -	      ALIGN	256
      5  5b48				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5b48					      ENDIF
      0  5b48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  5b48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5b48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5b48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  5b48				   TEMPORARY_VAR SET	Overlay
      5  5b48				   TEMPORARY_OFFSET SET	0
      6  5b48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5b48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  5b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  5b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5b90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
      1  5b90
      2  5b90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5b90				  -.EARLY_LOCATION SET	*
      4  5b90				  -	      ALIGN	256
      5  5b90				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5b90					      ENDIF
      0  5b90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  5b90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5b90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5b90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  5b90				   TEMPORARY_VAR SET	Overlay
      5  5b90				   TEMPORARY_OFFSET SET	0
      6  5b90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5b90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5bc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    249  5bd8
      0  5bd8					      END_BANK
      1  5bd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  5bd8				  -	      CHECK_RAM_BANK_SIZE
      3  5bd8					      ELSE
      0  5bd8					      CHECK_BANK_SIZE
      1  5bd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 23 PIECE_7 size = $3d8 free = 39
      2  5bd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  5bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5bd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  5bd8				  -	      ERR
      6  5bd8					      ENDIF
      5  5bd8					      ENDIF
    251  5bd8
    252  5bd8
    253  5bd8							;---------------------------------------------------------------------------------------------------
    254  5bd8
      0  5bd8					      ROMBANK	PIECE_8
      1  5c48 ????				      SEG	ROM_PIECE_8
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   PIECE_8_START SET	*
      6  5c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5c00				   ROMBANK_PIECE_8 SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5c00				   _LAST_BANK SETSTR	PIECE_8
     10  5c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    256  5c00
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5c00					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  5c00					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
      1  5c00
      2  5c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5c00				  -.EARLY_LOCATION SET	*
      4  5c00				  -	      ALIGN	256
      5  5c00				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5c00					      ENDIF
      0  5c00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  5c00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5c00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5c00				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  5c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    258  5c48
      0  5c48					      END_BANK
      1  5c48				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  5c48				  -	      CHECK_RAM_BANK_SIZE
      3  5c48					      ELSE
      0  5c48					      CHECK_BANK_SIZE
      1  5c48		       00 48	   .TEMP      =	* - _BANK_START
 ROM bank # 24 PIECE_8 size = $48 free = 951
      2  5c48					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  5c48				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5c48				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  5c48				  -	      ERR
      6  5c48					      ENDIF
      5  5c48					      ENDIF
    260  5c48
    261  5c48
    262  5c48							;---------------------------------------------------------------------------------------------------
    263  5c48							;EOF
------- FILE ./chess.asm
------- FILE @2 VOX.asm LEVEL 2 PASS 4
      0  5c48					      include	"@2 VOX.asm"
      1  5c48							;
      2  5c48							; vox_test.asm
      3  5c48							;
      4  5c48							;
      5  5c48							; By Alex Herbert, 2004
      6  5c48							;
      7  5c48
      0  5c48					      SLOT	2
      1  5c48
      2  5c48				  -	      IF	(2 < 0) || (2 > 3)
      3  5c48				  -	      ECHO	"Illegal bank address/segment location", 2
      4  5c48				  -	      ERR
      5  5c48					      ENDIF
      6  5c48
      7  5c48				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  5c48				   _BANK_SLOT SET	2 * 64
      9  5c48
      0  5c48					      ROMBANK	VOX
      1  6360 ????				      SEG	ROM_VOX
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   VOX_START  SET	*
      6  6000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6000				   ROMBANK_VOX SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6000				   _LAST_BANK SETSTR	VOX
     10  6000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     10  6000
     11  6000
     12  6000							; Speakjet Driver
     13  6000
     14  6000
     15  6000
     16  6000							; Constants
     17  6000
     18  6000
     19  6000		       00 01	   SERIAL_OUTMASK equ	$01
     20  6000		       00 02	   SERIAL_RDYMASK equ	$02
     21  6000
     22  6000
     23  6000
     24  6000							; Macros
     25  6000
     26  6000					      MACRO	spkout
     27  6000
     28  6000
     29  6000							; check buffer-full status
     30  6000
     31  6000					      lda	SWCHA
     32  6000					      and	#SERIAL_RDYMASK
     33  6000					      beq	.speech_done
     34  6000
     35  6000							; get next speech byte
     36  6000
     37  6000					      ldy	#0
     38  6000					      lda	(speech_addr),y
     39  6000
     40  6000							; invert data and check for end of string
     41  6000
     42  6000					      eor	#$ff
     43  6000					      beq	.speech_done
     44  6000					      sta	{1}
     45  6000
     46  6000							; increment speech pointer
     47  6000
     48  6000					      inc	speech_addr
     49  6000					      bne	.incaddr_skip
     50  6000					      inc	speech_addr+1
     51  6000				   .incaddr_skip
     52  6000
     53  6000							; output byte as serial data
     54  6000
     55  6000					      sec		; start bit
     56  6000				   .byteout_loop
     57  6000
     58  6000							; put carry flag into bit 0 of SWACNT, perserving other bits
     59  6000
     60  6000					      lda	SWACNT	; 4
     61  6000					      and	#$fe	; 2 6
     62  6000					      adc	#$00	; 2 8
     63  6000					      sta	SWACNT	; 4 12
     64  6000
     65  6000							; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
     66  6000
     67  6000					      cpy	#$09	; 2 14
     68  6000					      beq	.speech_done	; 2 16
     69  6000					      iny		; 2 18
     70  6000
     71  6000					      SLEEP	36
     72  6000							;		      ; waste some cycles
     73  6000							;		      ldx     #$07
     74  6000							;.delay_loop
     75  6000							;		      dex
     76  6000							;		      bne     .delay_loop     ; 36 54
     77  6000
     78  6000							; shift next data bit into carry
     79  6000					      lsr	{1}	; 5 59
     80  6000
     81  6000							; and loop (branch always taken)
     82  6000					      bpl	.byteout_loop	; 3 62 cycles for loop
     83  6000
     84  6000				   .speech_done
     85  6000
     86  6000					      IF	>.byteout_loop != >.
     87  6000					      ECHO	"byteout speak page cross"
     88  6000							;ERR
     89  6000					      ENDIF
     90  6000
     91  6000					      endm
     92  6000
     93  6000
     94  6000					      mac	speak
     95  6000
     96  6000					      lda	#<{1}
     97  6000					      sta	speech_addr
     98  6000					      lda	#>{1}
     99  6000					      sta	speech_addr+1
    100  6000
    101  6000					      endm
    102  6000
    103  6000
    104  6000
    105  6000
    106  6000
    107  6000
    108  6000
    109  6000							; Macros
    110  6000
    111  6000					      mac	wait_timint
    112  6000				   .1	      bit	TIMINT
    113  6000					      bpl	.1
    114  6000					      sta	WSYNC
    115  6000					      endm
    116  6000
    117  6000
    118  6000
    119  6000					      mac	wait_hbls
    120  6000					      ldx	{1}
    121  6000				   .1	      dex
    122  6000					      sta	WSYNC
    123  6000					      bne	.1
    124  6000					      endm
    125  6000
    126  6000
    127  6000
    128  6000
    129  6000
    130  6000							; Boot Code
    131  6000
      0  6000					      DEF	SayIt
      1  6000				   SLOT_SayIt SET	_BANK_SLOT
      2  6000				   BANK_SayIt SET	SLOT_SayIt + _CURRENT_BANK
      3  6000				   SayIt
      4  6000				   TEMPORARY_VAR SET	Overlay
      5  6000				   TEMPORARY_OFFSET SET	0
      6  6000				   VAR_BOUNDARY_SayIt SET	TEMPORARY_OFFSET
      7  6000				   FUNCTION_NAME SET	SayIt
    133  6000
    134  6000							;inc	  voxframe
    135  6000
    136  6000
      0  6000					      SPKOUT	temp
      1  6000
      2  6000
      3  6000
      4  6000
      5  6000		       ad 80 02 	      lda	SWCHA
      6  6003		       29 02		      and	#SERIAL_RDYMASK
      7  6005		       f0 36		      beq	.speech_done
      8  6007
      9  6007
     10  6007
     11  6007		       a0 00		      ldy	#0
     12  6009		       b1 9a		      lda	(speech_addr),y
     13  600b
     14  600b
     15  600b
     16  600b		       49 ff		      eor	#$ff
     17  600d		       f0 2e		      beq	.speech_done
     18  600f		       85 9d		      sta	temp
     19  6011
     20  6011
     21  6011
     22  6011		       e6 9a		      inc	speech_addr
     23  6013		       d0 02		      bne	.incaddr_skip
     24  6015		       e6 9b		      inc	speech_addr+1
     25  6017				   .incaddr_skip
     26  6017
     27  6017
     28  6017
     29  6017		       38		      sec
     30  6018				   .byteout_loop
     31  6018
     32  6018
     33  6018
     34  6018		       ad 81 02 	      lda	SWACNT
     35  601b		       29 fe		      and	#$fe
     36  601d		       69 00		      adc	#$00
     37  601f		       8d 81 02 	      sta	SWACNT
     38  6022
     39  6022
     40  6022
     41  6022		       c0 09		      cpy	#$09
     42  6024		       f0 17		      beq	.speech_done
     43  6026		       c8		      iny
     44  6027
      0  6027					      SLEEP	36
      1  6027				   .CYCLES    SET	36
      2  6027
      3  6027				  -	      IF	.CYCLES < 2
      4  6027				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6027				  -	      ERR
      6  6027					      ENDIF
      7  6027
      8  6027				  -	      IF	.CYCLES & 1
      9  6027				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  6027				  -	      nop	0
     11  6027				  -	      ELSE
     12  6027				  -	      bit	VSYNC
     13  6027				  -	      ENDIF
     14  6027				  -.CYCLES    SET	.CYCLES - 3
     15  6027					      ENDIF
     16  6027
     17  6027					      REPEAT	.CYCLES / 2
     18  6027		       ea		      nop
     17  6027					      REPEND
     18  6028		       ea		      nop
     17  6028					      REPEND
     18  6029		       ea		      nop
     17  6029					      REPEND
     18  602a		       ea		      nop
     17  602a					      REPEND
     18  602b		       ea		      nop
     17  602b					      REPEND
     18  602c		       ea		      nop
     17  602c					      REPEND
     18  602d		       ea		      nop
     17  602d					      REPEND
     18  602e		       ea		      nop
     17  602e					      REPEND
     18  602f		       ea		      nop
     17  602f					      REPEND
     18  6030		       ea		      nop
     17  6030					      REPEND
     18  6031		       ea		      nop
     17  6031					      REPEND
     18  6032		       ea		      nop
     17  6032					      REPEND
     18  6033		       ea		      nop
     17  6033					      REPEND
     18  6034		       ea		      nop
     17  6034					      REPEND
     18  6035		       ea		      nop
     17  6035					      REPEND
     18  6036		       ea		      nop
     17  6036					      REPEND
     18  6037		       ea		      nop
     17  6037					      REPEND
     18  6038		       ea		      nop
     19  6039					      REPEND
     46  6039
     47  6039
     48  6039
     49  6039
     50  6039
     51  6039
     52  6039
     53  6039		       46 9d		      lsr	temp
     54  603b
     55  603b
     56  603b		       10 db		      bpl	.byteout_loop
     57  603d
     58  603d				   .speech_done
     59  603d
     60  603d				  -	      IF	>.byteout_loop != >.
     61  603d				  -	      ECHO	"byteout speak page cross"
     62  603d				  -
     63  603d					      ENDIF
     64  603d
    138  603d		       60		      rts
    139  603e
    140  603e							; Variables
    141  603e
    142  603e
    143  603e							; Code/Data
    144  603e
    145  603e							;	  seg	  code
    146  603e							;	  org	  $f000,$ff
    147  603e
    148  603e
    149  603e							; Speech Data
    150  603e
    151  603e				   fire_speech
    152  603e		       1f fd		      dc.b	31,253
    153  6040		       ff		      dc.b	$ff
    154  6041
    155  6041				   up_speech
    156  6041		       1f bf 83 08*	      dc.b	31,191,131,8,187,191,129,143,2,2
    157  604b		       bf 83 08 bb*	      dc.b	191,131,8,187,191,129,143,2,2
    158  6054		       93 0e 88 08*	      dc.b	147,14,136,8,141,8,191,162,8,190,148,8,128,31
    159  6062		       ff		      dc.b	$ff
    160  6063				   down_speech
    161  6063		       1f 16 6e 17*	      dc.b	31,22,110,23,1,215,6
    162  606a		       ae 9a 07 8d*	      dc.b	174,154,7,141,7,165,7,151,6,215,6
    163  6075		       ae 9a 07 8d*	      dc.b	174,154,7,141,7,165,7,151,6,215,6
    164  6080		       ae 9a 07 8d*	      dc.b	174,154,7,141,7,165,7,151,31
    165  6089		       ff		      dc.b	$ff
    166  608a				   left_speech
    167  608a		       1f 15 74 17*	      dc.b	31,21,116,23,4,22,55,182,129,194,131,141
    168  6096		       02 02 08 ba*	      dc.b	2,2,8,186,7,155,4,191,6,145,7,136,7,155,196,6
    169  60a6		       9a 80 06 94*	      dc.b	154,128,6,148,7,137,7,164,18,171,136,191,31
    170  60b3		       ff		      dc.b	$ff
    171  60b4				   right_speech
    172  60b4		       1f 15 7f aa*	      dc.b	31,21,127,170,128,174,128,170,128,174,128
    173  60bf		       aa 80 ae 80*	      dc.b	170,128,174,128,170,128,174,128,170,128,174,128,31
    174  60cc		       ff		      dc.b	$ff
    175  60cd
    176  60cd				   silence_speech
    177  60cd		       1f		      dc.b	31
    178  60ce		       15 78		      .byte.b	21, SPKPITCH	; slower (default=114)
    179  60d0		       14 18		      .byte.b	20,24	; volume (default=96)
    180  60d2		       17 04		      .byte.b	23,4	; band. deep-hollow sound
    181  60d4		       ff		      dc.b	$ff
    182  60d5
    183  60d5
    184  60d5				   SAY_your_move
    185  60d5
    186  60d5							; your = \IY \OWRR
    187  60d5		       80 99		      .byte.b	128, 153
    188  60d7							; move= \MM \SLOW \UW \VV
    189  60d7		       8c 08 8b a6	      .byte.b	140, 8, 139, 166
    190  60db		       ff		      .byte.b	$FF
    191  60dc
    192  60dc
    193  60dc		       00 78	   SPKPITCH   =	120
    194  60dc
    195  60dc
    196  60dc							;"Ha ha ha"
    197  60dc
    198  60dc							;"Ha! You have fallen for my trap!"
    199  60dc
    200  60dc							;"Mate in 236 moves..."
    201  60dc
    202  60dc							;"I saw that!"
    203  60dc
    204  60dc							;"Puny human"
    205  60dc
    206  60dc							;"Don't look a gift knight in the mouth"
    207  60dc
    208  60dc							;"We all learn from our mistakes: you have infinite improvement capability"
    209  60dc
    210  60dc							;"You have a good memory for bad openings"
    211  60dc
    212  60dc							;"You play like a human"
    213  60dc
    214  60dc							;"You play like a computer"
    215  60dc
    216  60dc				   SAY_blindfold
    217  60dc							;"I was playing that one blindfolded"
    218  60dc		       14 60 15 72*	      .byte.b	20, 96, 21, 114, 22, 88, 23, 5, 157, 147, 134, 167, 169, 8, 132, 8, 191, 147, 14, 136, 8, 141
    219  60f2		       ff		      .byte.b	$FF
    220  60f3
    221  60f3				   SAY_atari
    222  60f3
    223  60f3							;"Atari! ..... whoops..... wrong game... Check!"
    224  60f3		       14 60 15 72*	      .byte.b	20, 96, 21, 114, 22, 88, 23, 5, 148, 136, 8, 144, 8, 178, 154, 140, 182, 131, 131, 196
    225  6107		       ff		      .byte.b	$FF
    226  6108
    227  6108				   SAY_feet
    228  6108
    229  6108							;"If i had feet, I'd be kicking you under the table right now"
    230  6108		       14 60 15 72*	      .byte.b	20, 96, 21, 114, 22, 88, 23, 5, 129, 186, 186, 157, 186, 128, 191, 2, 8, 160, 134, 141, 175, 151, 8, 169, 8, 128, 191, 7, 130, 7, 154, 18, 170, 7, 134, 146, 148, 7, 155, 7, 128, 191, 142, 163
    231  6134		       ff		      .byte.b	$FF
    232  6135
    233  6135				   SAY_mistake
    234  6135
    235  6135							;"I know you would make that mistake"
    236  6135		       14 60 15 72*	      .byte.b	20, 96, 21, 114, 22, 88, 23, 5, 157, 8, 160, 147, 8, 138, 177, 140, 154, 196, 169, 8, 132, 8, 191, 140, 7, 129, 187, 191, 154, 196
    237  6153		       ff		      .byte.b	$FF
    238  6154
    239  6154
    240  6154
    241  6154				   SAY_noCPU
    242  6154							;"Without a CPU i would try that move too"
    243  6154
    244  6154							;with= \WW \IH \SLOW \SLOW \TH
    245  6154		       15 78		      .byte.b	21,120
    246  6156		       93 81 08 08*	      .byte.b	147, 129, 8, 8, 190
    247  615b							;out = \AYWW \TT
    248  615b		       a3 bf		      .byte.b	163, 191
    249  615d		       15 78		      .byte.b	21, SPKPITCH
    250  615f
    251  615f							; a = \UX (mine)
    252  615f		       09 86		      .byte.b	9, 134
    253  6161
    254  6161							; CPU
    255  6161		       bb 08 80 	      .byte.b	187, 8, 128
    256  6164		       00		      .byte.b	0
    257  6165		       c6 08 80 	      .byte.b	198, 8,128
    258  6168		       00		      .byte.b	0
    259  6169		       08 a0		      .byte.b	8, 160
    260  616b
    261  616b		       02		      .byte.b	2
    262  616c
    263  616c
    264  616c		       14 60 15 72*	      .byte.b	20, 96, 21, 114, 22, 88, 23, 5, 157, 147, 8, 138, 177, 8, 191, 7, 148, 155, 169, 8, 132, 8, 191, 140, 8, 139, 166, 8, 191, 162
    265  618a		       ff		      .byte.b	$FF
    266  618b
    267  618b
    268  618b							;And I'm going to have the computer call the piece a "horsie" instead of a knight
    269  618b
    270  618b				   SAY_how_about
    271  618b				   SAY_NQB3
    272  618b
    273  618b							; horse= \HO \OWRR \SE \IY
    274  618b		       14 60 15 72*	      .byte.b	20, 96, 21, 114, 22, 88, 23, 5
    275  6193							; horsie
    276  6193							;.byte 8, 191, 162
    277  6193		       00		      .byte.b	0
    278  6194
    279  6194							; queens
    280  6194							; .byte 20, 96, 21, 114, 22, 88, 23, 5
    281  6194							; .byte 0
    282  6194
    283  6194							; bishop
    284  6194							; .byte 20, 96, 21, 114, 22, 88, 23, 5
    285  6194							; .byte 0
    286  6194
    287  6194
    288  6194							; three
    289  6194							; .byte 20, 96, 21, 114, 22, 88, 23, 5, 8, 190, 148, 8, 128
    290  6194		       ff		      .byte.b	$FF
    291  6195
    292  6195
    293  6195
    294  6195
    295  6195							;SAY_how_about
    296  6195
    297  6195							; .byte 20, 96, 21, 114, 22, 88, 23, 5, 141, 136, 191, 154, 128, 166, 150, 7, 128, 8, 179, 138, 138, 177, 140, 8, 139, 166
    298  6195							; .byte $FF
    299  6195
    300  6195							; how about a nice game of chess
    301  6195
    302  6195							;how= \HO \SLOW \AYWW
    303  6195
    304  6195							;.byte 21,120
    305  6195							;.byte 184, 8, 163
    306  6195
    307  6195		       00		      .byte.b	0
    308  6196
    309  6196							;about=\UX \OB \AYWW \TT  
    310  6196
    311  6196							;	  .byte 134, 8, 173, 163, 191
    312  6196
    313  6196
    314  6196		       09 00		      .byte.b	9,
    315  6198							;.byte 134 ;\UX
    316  6198							;.byte 21,64
    317  6198		       08 ad		      .byte.b	8,173	;\OB
    318  619a							;.byte 21,SPKPITCH
    319  619a		       a3		      .byte.b	163	;\AYWW
    320  619b		       0e		      .byte.b	14
    321  619c		       08 bf		      .byte.b	8, 191	;\TT
    322  619e		       ff		      .byte.b	$FF
    323  619f
    324  619f
    325  619f
    326  619f		       15 78		      .byte.b	21, SPKPITCH
    327  61a1							; a = \UX (mine)
    328  61a1		       09 86		      .byte.b	9, 134
    329  61a3
    330  61a3
    331  61a3							;nine =\NE \Stress \OHIH \NE	  
    332  61a3
    333  61a3		       8d 0e 9d bc	      .byte.b	141, 14, 157, 188
    334  61a7
    335  61a7							;game =\Slow \GE \EYIY \MM 
    336  61a7
    337  61a7		       08 b2 9a 08*	      .byte.b	8, 178, 154, 8,140
    338  61ac		       00		      .byte.b	0
    339  61ad
    340  61ad
    341  61ad							;of = \SLOW \UX \VV
    342  61ad		       08 86 a6 	      .byte.b	8, 134, 166
    343  61b0
    344  61b0							;chess\CH \EH \EH \SE 
    345  61b0		       b6 83 83 08*	      .byte.b	182, 131, 131, 8, 187
    346  61b5		       ff		      .byte.b	$FF
    347  61b6
    348  61b6
    349  61b6
    350  61b6				   SAY_hi_mum
    351  61b6
    352  61b6							;.byte 21, SPKPITCH	   ; slower (default=114)
    353  61b6
    354  61b6							; say= \SE \FAST \EY \EYIY
    355  61b6
    356  61b6		       bb 09 82 9a	      .byte.b	187, 9, 130, 154
    357  61ba		       04		      .byte.b	4
    358  61bb
    359  61bb							; hi= \HO \SLOW \OHIY
    360  61bb		       14 20		      .byte.b	20,32
    361  61bd		       0e b8 08 0e*	      .byte.b	14, 184, 8, 14, 155
    362  61c2		       04		      .byte.b	4
    363  61c3		       14 18		      .byte.b	20,24
    364  61c5
    365  61c5							; to = \SLOW \TT \SLOW \IHWW
    366  61c5		       08 bf 08 a2	      .byte.b	8, 191, 8, 162
    367  61c9							;.byte 4
    368  61c9
    369  61c9							; your = \IY \SLOW \OWRR
    370  61c9		       bf 08 80 99	      .byte.b	191, 8, 128, 153
    371  61cd
    372  61cd							; much= \MM \SLOW \UX \MM
    373  61cd		       08 8c 08 88	      .byte.b	8, 140, 8, 136
    374  61d1		       15 50		      .byte.b	21, 80
    375  61d3		       8c		      .byte.b	140
    376  61d4
    377  61d4
    378  61d4		       15 78		      .byte.b	21, 120
    379  61d6
    380  61d6							; for = \FF \SLOW \OWRR \SLOW \OWRR
    381  61d6		       ba 08 99 	      .byte.b	186, 8, 153
    382  61d9		       14 10		      .byte.b	20,16
    383  61db		       94		      .byte.b	148
    384  61dc		       14 18		      .byte.b	20,24
    385  61de		       15 78		      .byte.b	21, SPKPITCH
    386  61e0
    387  61e0							; me = \MM \IY \SLOW \IY
    388  61e0		       8c 80 08 80*	      .byte.b	140, 128, 8, 128, 128
    389  61e5
    390  61e5		       ff		      .byte.b	$FF
    391  61e6
    392  61e6				   SAY_you_are_a_loser
    393  61e6
    394  61e6							; you = \SLOW \IYUW
    395  61e6		       08 a0		      .byte.b	8, 160
    396  61e8
    397  61e8							; are= \AWRR
    398  61e8		       98		      .byte.b	152
    399  61e9
    400  61e9							; a = \UX (mine)
    401  61e9		       09 86		      .byte.b	9, 134
    402  61eb
    403  61eb							; lose= \LO \SLOW \UW \FAST \ZZ (R=\SLOW \RR 148)
    404  61eb		       92 08 a0 08*	      .byte.b	146, 8, 160, 8, 168, 8, 151
    405  61f2
    406  61f2		       ff		      .byte.b	$FF
    407  61f3
    408  61f3				   SAY_computer_moved
    409  61f3
    410  61f3							; your = \IY \OWRR
    411  61f3		       80 99		      .byte.b	128, 153
    412  61f5							; mistake= \MM \FAST \IH \SE \TT \EYIY \EK
    413  61f5		       8c 07 81 08*	      .byte.b	140, 7, 129, 8, 187, 191, 154, 196
    414  61fd
    415  61fd		       02		      .byte.b	2	;delay
    416  61fe
    417  61fe							; you = \SLOW \IYUW
    418  61fe		       08 a0		      .byte.b	8, 160
    419  6200							; suck = \SLOW \SE \SLOW \UX \EK
    420  6200		       08 c0 08 86*	      .byte.b	8, 192, 8, 134, 196
    421  6205		       ff		      .byte.b	$FF
    422  6206
    423  6206
    424  6206
    425  6206
    426  6206
    427  6206							; Subroutines
    428  6206
    429  6206				   read_switches
    430  6206		       a5 9e		      lda	switch_states
    431  6208		       49 ff		      eor	#$ff
    432  620a		       85 9f		      sta	switch_edges
    433  620c
    434  620c		       ad 82 02 	      lda	SWCHB
    435  620f		       09 f4		      ora	#$f4
    436  6211		       85 9e		      sta	switch_states
    437  6213		       ad 80 02 	      lda	SWCHA
    438  6216		       09 0f		      ora	#$0f
    439  6218		       25 9e		      and	switch_states
    440  621a		       24 4c		      bit	INPT4
    441  621c		       30 02		      bmi	switches_skip
    442  621e		       29 fb		      and	#$fb
    443  6220				   switches_skip
    444  6220		       49 ff		      eor	#$ff
    445  6222		       85 9e		      sta	switch_states
    446  6224		       25 9f		      and	switch_edges
    447  6226		       85 9f		      sta	switch_edges
    448  6228		       60		      rts
    449  6229
    450  6229
    451  6229
    452  6229				   speech_select
    453  6229		       a5 9f		      lda	switch_edges
    454  622b		       0a		      asl
    455  622c		       b0 31		      bcs	start_rightspeech
    456  622e		       0a		      asl
    457  622f		       b0 25		      bcs	start_leftspeech
    458  6231		       0a		      asl
    459  6232		       b0 19		      bcs	start_downspeech
    460  6234		       0a		      asl
    461  6235		       b0 0d		      bcs	start_upspeech
    462  6237		       0a		      asl
    463  6238		       30 01		      bmi	start_firespeech
    464  623a		       60		      rts
    465  623b
    466  623b				   start_firespeech
      0  623b					      SPEAK	fire_speech
      1  623b
      2  623b		       a9 3e		      lda	#<fire_speech
      3  623d		       85 9a		      sta	speech_addr
      4  623f		       a9 f8		      lda	#>fire_speech
      5  6241		       85 9b		      sta	speech_addr+1
      6  6243
    468  6243		       60		      rts
    469  6244
    470  6244				   start_upspeech
      0  6244					      SPEAK	up_speech
      1  6244
      2  6244		       a9 41		      lda	#<up_speech
      3  6246		       85 9a		      sta	speech_addr
      4  6248		       a9 f8		      lda	#>up_speech
      5  624a		       85 9b		      sta	speech_addr+1
      6  624c
    472  624c		       60		      rts
    473  624d
    474  624d				   start_downspeech
      0  624d					      SPEAK	down_speech
      1  624d
      2  624d		       a9 63		      lda	#<down_speech
      3  624f		       85 9a		      sta	speech_addr
      4  6251		       a9 f8		      lda	#>down_speech
      5  6253		       85 9b		      sta	speech_addr+1
      6  6255
    476  6255		       60		      rts
    477  6256
    478  6256				   start_leftspeech
      0  6256					      SPEAK	left_speech
      1  6256
      2  6256		       a9 8a		      lda	#<left_speech
      3  6258		       85 9a		      sta	speech_addr
      4  625a		       a9 f8		      lda	#>left_speech
      5  625c		       85 9b		      sta	speech_addr+1
      6  625e
    480  625e		       60		      rts
    481  625f
    482  625f				   start_rightspeech
      0  625f					      SPEAK	right_speech
      1  625f
      2  625f		       a9 b4		      lda	#<right_speech
      3  6261		       85 9a		      sta	speech_addr
      4  6263		       a9 f8		      lda	#>right_speech
      5  6265		       85 9b		      sta	speech_addr+1
      6  6267
    484  6267		       60		      rts
    485  6268
    486  6268
    487  6268
    488  6268							; Sprite Data
    489  6268
    490  6300		       00 00 00 00*	      align	$100
    491  6300
    492  6300				   title_sprite0
    493  6300		       00		      dc.b	%00000000
    494  6301		       00		      dc.b	%00000000
    495  6302		       00		      dc.b	%00000000
    496  6303		       00		      dc.b	%00000000
    497  6304		       00		      dc.b	%00000000
    498  6305		       00		      dc.b	%00000000
    499  6306		       00		      dc.b	%00000000
    500  6307		       00		      dc.b	0
    501  6308		       00		      dc.b	0
    502  6309		       88		      dc.b	%10001000
    503  630a		       88		      dc.b	%10001000
    504  630b		       f8		      dc.b	%11111000
    505  630c		       88		      dc.b	%10001000
    506  630d		       88		      dc.b	%10001000
    507  630e		       50		      dc.b	%01010000
    508  630f		       23		      dc.b	%00100011
    509  6310
    510  6310				   title_sprite1
    511  6310		       02		      dc.b	%00000010
    512  6311		       02		      dc.b	%00000010
    513  6312		       02		      dc.b	%00000010
    514  6313		       02		      dc.b	%00000010
    515  6314		       02		      dc.b	%00000010
    516  6315		       02		      dc.b	%00000010
    517  6316		       0f		      dc.b	%00001111
    518  6317		       00		      dc.b	0
    519  6318		       00		      dc.b	0
    520  6319		       88		      dc.b	%10001000
    521  631a		       88		      dc.b	%10001000
    522  631b		       8f		      dc.b	%10001111
    523  631c		       88		      dc.b	%10001000
    524  631d		       88		      dc.b	%10001000
    525  631e		       85		      dc.b	%10000101
    526  631f		       e2		      dc.b	%11100010
    527  6320
    528  6320				   title_sprite2
    529  6320		       3e		      dc.b	%00111110
    530  6321		       20		      dc.b	%00100000
    531  6322		       20		      dc.b	%00100000
    532  6323		       3c		      dc.b	%00111100
    533  6324		       20		      dc.b	%00100000
    534  6325		       20		      dc.b	%00100000
    535  6326		       be		      dc.b	%10111110
    536  6327		       00		      dc.b	0
    537  6328		       00		      dc.b	0
    538  6329		       a2		      dc.b	%10100010
    539  632a		       a4		      dc.b	%10100100
    540  632b		       a8		      dc.b	%10101000
    541  632c		       bc		      dc.b	%10111100
    542  632d		       a2		      dc.b	%10100010
    543  632e		       22		      dc.b	%00100010
    544  632f		       3c		      dc.b	%00111100
    545  6330
    546  6330				   title_sprite3
    547  6330		       70		      dc.b	%01110000
    548  6331		       88		      dc.b	%10001000
    549  6332		       08		      dc.b	%00001000
    550  6333		       70		      dc.b	%01110000
    551  6334		       80		      dc.b	%10000000
    552  6335		       88		      dc.b	%10001000
    553  6336		       73		      dc.b	%01110011
    554  6337		       00		      dc.b	0
    555  6338		       00		      dc.b	0
    556  6339		       70		      dc.b	%01110000
    557  633a		       21		      dc.b	%00100001
    558  633b		       22		      dc.b	%00100010
    559  633c		       22		      dc.b	%00100010
    560  633d		       22		      dc.b	%00100010
    561  633e		       22		      dc.b	%00100010
    562  633f		       72		      dc.b	%01110010
    563  6340
    564  6340				   title_sprite4
    565  6340		       80		      dc.b	%10000000
    566  6341		       80		      dc.b	%10000000
    567  6342		       80		      dc.b	%10000000
    568  6343		       80		      dc.b	%10000000
    569  6344		       80		      dc.b	%10000000
    570  6345		       80		      dc.b	%10000000
    571  6346		       e0		      dc.b	%11100000
    572  6347		       00		      dc.b	0
    573  6348		       00		      dc.b	0
    574  6349		       87		      dc.b	%10000111
    575  634a		       48		      dc.b	%01001000
    576  634b		       28		      dc.b	%00101000
    577  634c		       28		      dc.b	%00101000
    578  634d		       28		      dc.b	%00101000
    579  634e		       28		      dc.b	%00101000
    580  634f		       27		      dc.b	%00100111
    581  6350
    582  6350				   title_sprite5
    583  6350		       00		      dc.b	%00000000
    584  6351		       00		      dc.b	%00000000
    585  6352		       00		      dc.b	%00000000
    586  6353		       00		      dc.b	%00000000
    587  6354		       00		      dc.b	%00000000
    588  6355		       00		      dc.b	%00000000
    589  6356		       00		      dc.b	%00000000
    590  6357		       00		      dc.b	0
    591  6358		       00		      dc.b	0
    592  6359		       22		      dc.b	%00100010
    593  635a		       a2		      dc.b	%10100010
    594  635b		       94		      dc.b	%10010100
    595  635c		       88		      dc.b	%10001000
    596  635d		       94		      dc.b	%10010100
    597  635e		       a2		      dc.b	%10100010
    598  635f		       22		      dc.b	%00100010
    599  6360
    600  6360
    601  6360
    602  6360
    603  6360
      0  6360					      END_BANK
      1  6360				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  6360				  -	      CHECK_RAM_BANK_SIZE
      3  6360					      ELSE
      0  6360					      CHECK_BANK_SIZE
      1  6360		       03 60	   .TEMP      =	* - _BANK_START
 ROM bank # 25 VOX size = $360 free = 159
      2  6360					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  6360				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6360				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  6360				  -	      ERR
      6  6360					      ENDIF
      5  6360					      ENDIF
------- FILE ./chess.asm
    207  6360
------- FILE @3 GENERIC #2.asm LEVEL 2 PASS 4
      0  6360					      include	"@3 GENERIC #2.asm"
      1  6360							;---------------------------------------------------------------------------------------------------
      2  6360							; @3 GENERIC #2.asm
      3  6360
      4  6360							; Atari 2600 Chess
      5  6360							; Copyright (c) 2019-2020 Andrew Davie
      6  6360							; andrew@taswegian.com
      7  6360
      8  6360
      9  6360							;---------------------------------------------------------------------------------------------------
     10  6360
      0  6360					      SLOT	3
      1  6360
      2  6360				  -	      IF	(3 < 0) || (3 > 3)
      3  6360				  -	      ECHO	"Illegal bank address/segment location", 3
      4  6360				  -	      ERR
      5  6360					      ENDIF
      6  6360
      7  6360				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  6360				   _BANK_SLOT SET	3 * 64
      9  6360
      0  6360					      ROMBANK	THREE
      1  6573 ????				      SEG	ROM_THREE
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   THREE_START SET	*
      6  6400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6400				   ROMBANK_THREE SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6400				   _LAST_BANK SETSTR	THREE
     10  6400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  6400
      0  6400					      DEF	Breaker
      1  6400				   SLOT_Breaker SET	_BANK_SLOT
      2  6400				   BANK_Breaker SET	SLOT_Breaker + _CURRENT_BANK
      3  6400				   Breaker
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_Breaker SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	Breaker
     15  6400		       00		      brk
     16  6401
     17  6401
     18  6401							;---------------------------------------------------------------------------------------------------
     19  6401
      0  6401					      DEF	GetPiece
      1  6401				   SLOT_GetPiece SET	_BANK_SLOT
      2  6401				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  6401				   GetPiece
      4  6401				   TEMPORARY_VAR SET	Overlay
      5  6401				   TEMPORARY_OFFSET SET	0
      6  6401				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  6401				   FUNCTION_NAME SET	GetPiece
     21  6401					      SUBROUTINE
     22  6401
      0  6401					      REF	aiSelectDestinationSquare	;✅
      1  6401					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  6401				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  6401					      ENDIF
      0  6401					      REF	aiQuiescent	;✅
      1  6401				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  6401				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  6401					      ENDIF
      0  6401					      VEND	GetPiece
      1  6401
      2  6401
      3  6401		       00 ef	   VAREND_GetPiece =	TEMPORARY_VAR
      4  6401
     26  6401
     27  6401							; Retrieve the piece+flags from the movelist, given from/to squares
     28  6401							; Required as moves have different flags but same origin squares (e.g., castling)
     29  6401
     30  6401		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
     31  6403							;lda currentPly
     32  6403		       85 3e		      sta	SET_BANK_RAM	;@2
     33  6405
     34  6405							; returns piece in A+fromPiece
     35  6405							; or Y=-1 if not found
     36  6405
     37  6405							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     38  6405							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     39  6405							; This fixes the move with/without castle flag
     40  6405
     41  6405
      0  6405					      ldy@PLY	moveIndex
      1  6405		       ac cf f9 	      ldy	moveIndex
     43  6408		       30 11		      bmi	.fail	; shouldn't happen
     44  640a
     45  640a		       a5 86	   .scan      lda	fromX12
      0  640c					      cmp@PLY	MoveFrom,y
      1  640c		       d9 00 f8 	      cmp	MoveFrom,y
     47  640f		       d0 07		      bne	.next
     48  6411		       a5 87		      lda	toX12
      0  6413					      cmp@PLY	MoveTo,y
      1  6413		       d9 64 f8 	      cmp	MoveTo,y
     50  6416		       f0 04		      beq	.found
     51  6418		       88	   .next      dey
     52  6419		       10 ef		      bpl	.scan
     53  641b		       60	   .fail      rts
     54  641c
      0  641c				   .found     lda@PLY	MovePiece,y
      1  641c		       b9 00 f9 	      lda	MovePiece,y
     56  641f		       85 97		      sta	fromPiece
     57  6421
     58  6421		       60		      rts
     59  6422
     60  6422
     61  6422							;---------------------------------------------------------------------------------------------------
     62  6422
      0  6422					      DEF	GenCastleMoveForRook
      1  6422				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  6422				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  6422				   GenCastleMoveForRook
      4  6422				   TEMPORARY_VAR SET	Overlay
      5  6422				   TEMPORARY_OFFSET SET	0
      6  6422				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  6422				   FUNCTION_NAME SET	GenCastleMoveForRook
     64  6422					      SUBROUTINE
     65  6422
      0  6422					      REF	MakeMove	;✅
      1  6422					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  6422					      ENDIF
      0  6422					      REF	CastleFixupDraw	;✅
      1  6422				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  6422				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  6422					      ENDIF
      0  6422					      VEND	GenCastleMoveForRook
      1  6422
      2  6422
      3  6422		       00 b9	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
      4  6422
     69  6422
     70  6422							; Generate secondary move for the rook, involved in a castling move
     71  6422							; Returns:
     72  6422							;   CC --> not a castle/secondary
     73  6422							;   CS --> secondary move valid
     74  6422
     75  6422
     76  6422		       18		      clc
     77  6423
     78  6423		       a5 97		      lda	fromPiece
     79  6425		       29 10		      and	#FLAG_CASTLE
     80  6427		       f0 2d		      beq	.exit	; NOT involved in castle!
     81  6429
     82  6429		       a2 04		      ldx	#4
     83  642b		       a5 87		      lda	toX12	; *destination*
     84  642d		       18	   .findCast  clc
     85  642e		       ca		      dex
     86  642f		       30 25		      bmi	.exit
     87  6431		       dd 57 fc 	      cmp	KSquare,x
     88  6434		       d0 f7		      bne	.findCast
     89  6436
     90  6436		       bd 5f fc 	      lda	RSquareEnd,x
     91  6439		       85 87		      sta	toX12
      0  643b					      sta@PLY	secondaryBlank
      1  643b		       8d ce fb 	      sta	[RAM]+secondaryBlank
     93  643e		       bc 5b fc 	      ldy	RSquareStart,x
     94  6441		       84 86		      sty	fromX12
     95  6443		       84 88		      sty	originX12
      0  6445					      sty@PLY	secondarySquare
      1  6445		       8c cd fb 	      sty	[RAM]+secondarySquare
     97  6448
     98  6448		       a5 97		      lda	fromPiece
     99  644a		       29 80		      and	#128	; colour bit
    100  644c		       09 05		      ora	#ROOK	; preserve colour
    101  644e		       85 97		      sta	fromPiece
    102  6450		       85 b3		      sta	__originalPiece
      0  6452					      sta@PLY	secondaryPiece
      1  6452		       8d cc fb 	      sta	[RAM]+secondaryPiece
    104  6455
    105  6455		       38		      sec
    106  6456		       60	   .exit      rts
    107  6457
    108  6457
    109  6457		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    110  645b		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    111  645f		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    112  6463		       19 1b 5f 61 virtualSquare1 .byte.b	25,27,95,97
    113  6467							;virtualSquare2      .byte 26,26,96,96
    114  6467
    115  6467							;---------------------------------------------------------------------------------------------------
    116  6467
    117  6467							; DEF GenEnPassantMove
    118  6467							; SUBROUTINE
    119  6467
    120  6467							;     REF EnPassantCheck
    121  6467							;     REF MakeMove
    122  6467							;     VEND GenEnPassantMove
    123  6467
    124  6467
    125  6467							;		   rts
    126  6467
    127  6467
    128  6467
    129  6467							; The reset vectors
    130  6467							; these must live in the fixed bank (bank 0 in 3E+ format)
    131  6467
    132  6467							;    ORG $63FC
    133  6467							;    RORG $FFFC
    134  6467
    135  6467							;		      .word StartCartridge	      ; RESET
    136  6467							;		      .word StartCartridge	      ; IRQ	   (not used)
    137  6467
    138  6467
    139  6467							;---------------------------------------------------------------------------------------------------
    140  6467
      0  6467					      DEF	InterlaceFrame
      1  6467				   SLOT_InterlaceFrame SET	_BANK_SLOT
      2  6467				   BANK_InterlaceFrame SET	SLOT_InterlaceFrame + _CURRENT_BANK
      3  6467				   InterlaceFrame
      4  6467				   TEMPORARY_VAR SET	Overlay
      5  6467				   TEMPORARY_OFFSET SET	0
      6  6467				   VAR_BOUNDARY_InterlaceFrame SET	TEMPORARY_OFFSET
      7  6467				   FUNCTION_NAME SET	InterlaceFrame
    142  6467
    143  6467
    144  6467							; START OF FRAME
    145  6467
    146  6467
    147  6467				  -	      IF	0
    148  6467				  -
    149  6467				  -	      lda	SWCHB
    150  6467				  -	      bmi	.normal	; RIGHT difficulty switches on/off
    151  6467				  -
    152  6467				  -	      dec	framenum
    153  6467				  -	      lda	framenum
    154  6467				  -	      lsr
    155  6467				  -	      bcs	.normal
    156  6467				  -
    157  6467				  -	      SLEEP	36
    158  6467				  -
    159  6467				  -.normal    lda	#2
    160  6467				  -	      sta	WSYNC
    161  6467				  -	      sta	VSYNC
    162  6467				  -
    163  6467				  -	      sta	WSYNC	; line 1 of VSYNC
    164  6467				  -	      sta	WSYNC	; line 2 of VSYNC
    165  6467				  -
    166  6467				  -	      lda	#0
    167  6467				  -	      sta	WSYNC	; line 3 of VSYNC
    168  6467				  -	      sta	VSYNC	; @0
    169  6467				  -
    170  6467				  -
    171  6467				  -	      sta	VBLANK
    172  6467				  -
    173  6467					      ENDIF
    174  6467
    175  6467
    176  6467
    177  6467					      IF	1
    178  6467
    179  6467
    180  6467				   frame
    181  6467							;Vertical sync
    182  6467							;dec	framenum
    183  6467
    184  6467							;lda	interlaced		;see if we are in interlaced mode
    185  6467							;beq	non_interlaced
    186  6467
    187  6467		       ad 82 02 	      lda	SWCHB
    188  646a		       30 1b		      bmi	even_sync
    189  646c
    190  646c		       c6 80		      dec	framenum
    191  646e		       a5 80		      lda	framenum
    192  6470		       29 01		      and	#1
    193  6472		       f0 13		      beq	even_sync
    194  6474
    195  6474				   non_interlaced		;entry point for non-interlaced
    196  6474							;this is the vertical sync for the first field of an interlaced frame
    197  6474							;or just a normal non-interlaced vertical sync
    198  6474		       a9 02		      lda	#2
    199  6476		       85 42		      sta	WSYNC
    200  6478		       85 40		      sta	VSYNC	; Begin vertical sync.
    201  647a
    202  647a		       85 42		      sta	WSYNC	; First line of VSYNC
    203  647c		       85 42		      sta	WSYNC	; Second line of VSYNC.
    204  647e		       a9 00		      lda	#0
    205  6480		       85 42		      sta	WSYNC	; Third line of VSYNC.
    206  6482		       85 40		      sta	VSYNC	; (0)
    207  6484
    208  6484		       4c a9 fc 	      jmp	done_sync
    209  6487				   even_sync
    210  6487							;this is the vertical sync for the second field of an interlaced fram
    211  6487		       85 42		      sta	WSYNC
    212  6489							;need 40 cycles until the start of vertical sync
    213  6489
      0  6489					      SLEEP	36
      1  6489				   .CYCLES    SET	36
      2  6489
      3  6489				  -	      IF	.CYCLES < 2
      4  6489				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6489				  -	      ERR
      6  6489					      ENDIF
      7  6489
      8  6489				  -	      IF	.CYCLES & 1
      9  6489				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  6489				  -	      nop	0
     11  6489				  -	      ELSE
     12  6489				  -	      bit	VSYNC
     13  6489				  -	      ENDIF
     14  6489				  -.CYCLES    SET	.CYCLES - 3
     15  6489					      ENDIF
     16  6489
     17  6489					      REPEAT	.CYCLES / 2
     18  6489		       ea		      nop
     17  6489					      REPEND
     18  648a		       ea		      nop
     17  648a					      REPEND
     18  648b		       ea		      nop
     17  648b					      REPEND
     18  648c		       ea		      nop
     17  648c					      REPEND
     18  648d		       ea		      nop
     17  648d					      REPEND
     18  648e		       ea		      nop
     17  648e					      REPEND
     18  648f		       ea		      nop
     17  648f					      REPEND
     18  6490		       ea		      nop
     17  6490					      REPEND
     18  6491		       ea		      nop
     17  6491					      REPEND
     18  6492		       ea		      nop
     17  6492					      REPEND
     18  6493		       ea		      nop
     17  6493					      REPEND
     18  6494		       ea		      nop
     17  6494					      REPEND
     18  6495		       ea		      nop
     17  6495					      REPEND
     18  6496		       ea		      nop
     17  6496					      REPEND
     18  6497		       ea		      nop
     17  6497					      REPEND
     18  6498		       ea		      nop
     17  6498					      REPEND
     18  6499		       ea		      nop
     17  6499					      REPEND
     18  649a		       ea		      nop
     19  649b					      REPEND
    215  649b
    216  649b
    217  649b		       a9 02		      lda	#2	;40
    218  649d
    219  649d		       85 40		      sta	VSYNC	; Begin vertical sync.
    220  649f		       85 42		      sta	WSYNC	; First line of VSYNC
    221  64a1		       85 42		      sta	WSYNC	; Second line of VSYNC.
    222  64a3
    223  64a3		       85 42		      sta	WSYNC	; Third line of VSYNC.
    224  64a5							;need 33 cycles until the end of VSYNC
    225  64a5
    226  64a5
    227  64a5							;SLEEP 10
    228  64a5
    229  64a5
    230  64a5
    231  64a5		       a9 00		      lda	#0	;33
    232  64a7		       85 40		      sta	VSYNC
    233  64a9
    234  64a9				   done_sync
    235  64a9
    236  64a9							;	LDA #40		;timer for 34 lines of blanking
    237  64a9							;	STA TIM64T
    238  64a9					      ENDIF
    239  64a9
    240  64a9
    241  64a9							;		      lda #%1110		      ; VSYNC ON
    242  64a9							;.loopVSync3	      sta WSYNC
    243  64a9							;		      sta VSYNC
    244  64a9							;		      lsr
    245  64a9							;		      bne .loopVSync3		      ; branch until VYSNC has been reset
    246  64a9
    247  64a9							;		      sta VBLANK
    248  64a9
    249  64a9		       60		      rts
    250  64aa
    251  64aa
    252  64aa							;---------------------------------------------------------------------------------------------------
    253  64aa
      0  64aa					      DEF	BubbleSort
      1  64aa				   SLOT_BubbleSort SET	_BANK_SLOT
      2  64aa				   BANK_BubbleSort SET	SLOT_BubbleSort + _CURRENT_BANK
      3  64aa				   BubbleSort
      4  64aa				   TEMPORARY_VAR SET	Overlay
      5  64aa				   TEMPORARY_OFFSET SET	0
      6  64aa				   VAR_BOUNDARY_BubbleSort SET	TEMPORARY_OFFSET
      7  64aa				   FUNCTION_NAME SET	BubbleSort
    255  64aa					      SUBROUTINE
    256  64aa
    257  64aa		       60		      rts		;tmp
    258  64ab					      IF	1
    259  64ab							;{
    260  64ab
    261  64ab							; This MUST be called at the start of a new ply
    262  64ab							; It initialises the movelist to empty
    263  64ab							; x must be preserved
    264  64ab
    265  64ab							; note that 'alpha' and 'beta' are set externally!!
    266  64ab
    267  64ab		       a9 ff		      lda	#-1
      0  64ad					      sta@PLY	bestMove
      1  64ad		       8d d1 fb 	      sta	[RAM]+bestMove
    269  64b0
    270  64b0		       a5 94		      lda	enPassantPawn	; flag/square from last actual move made
      0  64b2					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  64b2		       8d ca fb 	      sta	[RAM]+enPassantSquare
    272  64b5
    273  64b5		       a5 a3		      lda	vkSquare
      0  64b7					      sta@PLY	virtualKingSquare
      1  64b7		       8d da fb 	      sta	[RAM]+virtualKingSquare
    275  64ba		       a5 a4		      lda	vkSquare+1
      0  64bc					      sta@PLY	virtualKingSquare+1	; traversal squares of king for castling
      1  64bc		       8d db fb 	      sta	[RAM]+virtualKingSquare+1
    277  64bf
    278  64bf							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    279  64bf							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    280  64bf							; start of each new ply.
    281  64bf
    282  64bf		       a5 90		      lda	Evaluation
      0  64c1					      sta@PLY	savedEvaluation
      1  64c1		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    284  64c4		       a5 91		      lda	Evaluation+1
      0  64c6					      sta@PLY	savedEvaluation+1
      1  64c6		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    286  64c9							;}
    287  64c9					      ENDIF
    288  64c9
    289  64c9
    290  64c9		       18		      clc
    291  64ca		       a5 95		      lda	currentPly
    292  64cc		       69 0d		      adc	#RAMBANK_SORT-RAMBANK_PLY
    293  64ce		       85 bf		      sta	__bank2
    294  64d0
    295  64d0
      0  64d0					      lda@PLY	moveIndex
      1  64d0		       ad cf f9 	      lda	moveIndex
    297  64d3		       10 01		      bpl	.start	; no moves - no sorting
    298  64d5		       60		      rts
    299  64d6
    300  64d6				   .start
    301  64d6
    302  64d6		       85 bc		      sta	__n
    303  64d8		       e6 bc		      inc	__n	; n := length(A)
    304  64da
    305  64da		       a9 00	   .bubble    lda	#0
    306  64dc		       85 bd		      sta	__newn
    307  64de
    308  64de		       a9 01		      lda	#1
    309  64e0		       85 be		      sta	__i
    310  64e2
    311  64e2		       a5 be	   .bubbleLoop lda	__i
    312  64e4		       c5 bc		      cmp	__n
    313  64e6		       f0 7b		      beq	.exitBubble
    314  64e8
    315  64e8		       aa		      tax		; A
    316  64e9		       a8		      tay
    317  64ea		       88		      dey		; B i-1
    318  64eb
    319  64eb		       a5 bf		      lda	__bank2
    320  64ed		       85 3e		      sta	SET_BANK_RAM	;@2
    321  64ef
    322  64ef		       38		      sec
    323  64f0		       bd 00 f8 	      lda	MoveValueLO,x
    324  64f3		       f9 00 f8 	      sbc	MoveValueLO,y
    325  64f6		       bd 64 f8 	      lda	MoveValueHI,x
    326  64f9		       f9 64 f8 	      sbc	MoveValueHI,y
    327  64fc		       50 02		      bvc	.cmp16bit
    328  64fe		       49 80		      eor	#$80
    329  6500		       30 5c	   .cmp16bit  bmi	.lessThan	; sort small to large
    330  6502
    331  6502							; swap!
      0  6502					      XCHG	MoveValueLO
      0  6502					      lda@PLY	MoveValueLO,x
      1  6502		       bd 00 f8 	      lda	MoveValueLO,x
      2  6505		       48		      pha
      0  6506					      lda@PLY	MoveValueLO,y
      1  6506		       b9 00 f8 	      lda	MoveValueLO,y
      0  6509					      sta@PLY	MoveValueLO,x
      1  6509		       9d 00 fa 	      sta	[RAM]+MoveValueLO,x
      5  650c		       68		      pla
      0  650d					      sta@PLY	MoveValueLO,y
      1  650d		       99 00 fa 	      sta	[RAM]+MoveValueLO,y
      0  6510					      XCHG	MoveValueHI
      0  6510					      lda@PLY	MoveValueHI,x
      1  6510		       bd 64 f8 	      lda	MoveValueHI,x
      2  6513		       48		      pha
      0  6514					      lda@PLY	MoveValueHI,y
      1  6514		       b9 64 f8 	      lda	MoveValueHI,y
      0  6517					      sta@PLY	MoveValueHI,x
      1  6517		       9d 64 fa 	      sta	[RAM]+MoveValueHI,x
      5  651a		       68		      pla
      0  651b					      sta@PLY	MoveValueHI,y
      1  651b		       99 64 fa 	      sta	[RAM]+MoveValueHI,y
    334  651e
    335  651e		       a5 95		      lda	currentPly
    336  6520		       85 3e		      sta	SET_BANK_RAM	;@2
    337  6522
      0  6522					      XCHG	MoveFrom
      0  6522					      lda@PLY	MoveFrom,x
      1  6522		       bd 00 f8 	      lda	MoveFrom,x
      2  6525		       48		      pha
      0  6526					      lda@PLY	MoveFrom,y
      1  6526		       b9 00 f8 	      lda	MoveFrom,y
      0  6529					      sta@PLY	MoveFrom,x
      1  6529		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  652c		       68		      pla
      0  652d					      sta@PLY	MoveFrom,y
      1  652d		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  6530					      XCHG	MoveTo
      0  6530					      lda@PLY	MoveTo,x
      1  6530		       bd 64 f8 	      lda	MoveTo,x
      2  6533		       48		      pha
      0  6534					      lda@PLY	MoveTo,y
      1  6534		       b9 64 f8 	      lda	MoveTo,y
      0  6537					      sta@PLY	MoveTo,x
      1  6537		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  653a		       68		      pla
      0  653b					      sta@PLY	MoveTo,y
      1  653b		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  653e					      XCHG	MovePiece
      0  653e					      lda@PLY	MovePiece,x
      1  653e		       bd 00 f9 	      lda	MovePiece,x
      2  6541		       48		      pha
      0  6542					      lda@PLY	MovePiece,y
      1  6542		       b9 00 f9 	      lda	MovePiece,y
      0  6545					      sta@PLY	MovePiece,x
      1  6545		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  6548		       68		      pla
      0  6549					      sta@PLY	MovePiece,y
      1  6549		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  654c					      XCHG	MoveCapture
      0  654c					      lda@PLY	MoveCapture,x
      1  654c		       bd 64 f9 	      lda	MoveCapture,x
      2  654f		       48		      pha
      0  6550					      lda@PLY	MoveCapture,y
      1  6550		       b9 64 f9 	      lda	MoveCapture,y
      0  6553					      sta@PLY	MoveCapture,x
      1  6553		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  6556		       68		      pla
      0  6557					      sta@PLY	MoveCapture,y
      1  6557		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    342  655a
    343  655a		       a5 be		      lda	__i
    344  655c		       85 bd		      sta	__newn
    345  655e
    346  655e		       e6 be	   .lessThan  inc	__i
    347  6560		       4c e2 fc 	      jmp	.bubbleLoop
    348  6563
    349  6563		       a5 bd	   .exitBubble lda	__newn
    350  6565		       85 bc		      sta	__n
    351  6567
    352  6567		       c9 02		      cmp	#2
    353  6569		       90 03		      bcc	.exitLoop
    354  656b		       4c da fc 	      jmp	.bubble
    355  656e
    356  656e		       a5 95	   .exitLoop  lda	currentPly
    357  6570		       85 3e		      sta	SET_BANK_RAM
    358  6572
    359  6572		       60		      rts
    360  6573
    361  6573
    362  6573							;---------------------------------------------------------------------------------------------------
    363  6573
      0  6573					      END_BANK
      1  6573				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  6573				  -	      CHECK_RAM_BANK_SIZE
      3  6573					      ELSE
      0  6573					      CHECK_BANK_SIZE
      1  6573		       01 73	   .TEMP      =	* - _BANK_START
 ROM bank # 26 THREE size = $173 free = 652
      2  6573					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  6573				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6573				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  6573				  -	      ERR
      6  6573					      ENDIF
      5  6573					      ENDIF
    365  6573
    366  6573							;---------------------------------------------------------------------------------------------------
    367  6573							; EOF
------- FILE ./chess.asm
------- FILE @3 SCREEN ROM.asm LEVEL 2 PASS 4
      0  6573					      include	"@3 SCREEN ROM.asm"
      1  6573
      0  6573					      SLOT	3
      1  6573
      2  6573				  -	      IF	(3 < 0) || (3 > 3)
      3  6573				  -	      ECHO	"Illegal bank address/segment location", 3
      4  6573				  -	      ERR
      5  6573					      ENDIF
      6  6573
      7  6573				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  6573				   _BANK_SLOT SET	3 * 64
      9  6573
      0  6573					      ROMBANK	ROM_SCREEN
      1  6ac6 ????				      SEG	ROM_ROM_SCREEN
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   ROM_SCREEN_START SET	*
      6  6800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6800				   ROMBANK_ROM_SCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6800				   _LAST_BANK SETSTR	ROM_SCREEN
     10  6800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      4  6800
      5  6800							;---------------------------------------------------------------------------------------------------
      6  6800
      0  6800					      DEF	ClearRowBitmap
      1  6800				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  6800				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  6800				   ClearRowBitmap
      4  6800				   TEMPORARY_VAR SET	Overlay
      5  6800				   TEMPORARY_OFFSET SET	0
      6  6800				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  6800				   FUNCTION_NAME SET	ClearRowBitmap
      8  6800					      SUBROUTINE
      9  6800
      0  6800					      REF	aiClearEachRow
      1  6800					      IF	VAREND_aiClearEachRow > TEMPORARY_VAR
      2  6800				   TEMPORARY_VAR SET	VAREND_aiClearEachRow
      3  6800					      ENDIF
      0  6800					      VEND	ClearRowBitmap
      1  6800
      2  6800
      3  6800		       00 a9	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
      4  6800
     12  6800
     13  6800							; No transient variable dependencies/calls
     14  6800
     15  6800		       a9 00		      lda	#0
     16  6802		       a8		      tay
      0  6803				   .clearRow  sta@RAM	ChessBitmap,y
      1  6803		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
     18  6806		       c8		      iny
     19  6807		       c0 90		      cpy	#ROW_BITMAP_SIZE
     20  6809		       d0 f8		      bne	.clearRow
     21  680b		       60		      rts
     22  680c
     23  680c
     24  680c							;---------------------------------------------------------------------------------------------------
     25  680c
      0  680c					      DEF	WriteBlank
      1  680c				   SLOT_WriteBlank SET	_BANK_SLOT
      2  680c				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  680c				   WriteBlank
      4  680c				   TEMPORARY_VAR SET	Overlay
      5  680c				   TEMPORARY_OFFSET SET	0
      6  680c				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  680c				   FUNCTION_NAME SET	WriteBlank
     27  680c					      SUBROUTINE
     28  680c
      0  680c					      REF	StartupBankReset	;✅
      1  680c				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  680c				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  680c					      ENDIF
      0  680c					      VEND	WriteBlank
      1  680c
      2  680c
      3  680c		       00 a7	   VAREND_WriteBlank =	TEMPORARY_VAR
      4  680c
     31  680c
     32  680c		       a9 90		      lda	#<BlankSprite
      0  680e					      sta@RAM	SMSPRITE0_0+1
      1  680e		       8d e6 fa 	      sta	[RAM]+SMSPRITE0_0+1
      0  6811					      sta@RAM	SMSPRITE8_0+1
      1  6811		       8d 17 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  6814					      sta@RAM	SMSPRITE16_0+1
      1  6814		       8d a8 fa 	      sta	[RAM]+SMSPRITE16_0+1
      0  6817					      sta@RAM	SMSPRITE0_1+1
      1  6817		       8d eb fa 	      sta	[RAM]+SMSPRITE0_1+1
      0  681a					      sta@RAM	SMSPRITE8_1+1
      1  681a		       8d 1c fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  681d					      sta@RAM	SMSPRITE16_1+1
      1  681d		       8d ad fa 	      sta	[RAM]+SMSPRITE16_1+1
     39  6820
     40  6820		       a9 f8		      lda	#>BlankSprite
      0  6822					      sta@RAM	SMSPRITE0_0+2
      1  6822		       8d e7 fa 	      sta	[RAM]+SMSPRITE0_0+2
      0  6825					      sta@RAM	SMSPRITE8_0+2
      1  6825		       8d 18 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  6828					      sta@RAM	SMSPRITE16_0+2
      1  6828		       8d a9 fa 	      sta	[RAM]+SMSPRITE16_0+2
      0  682b					      sta@RAM	SMSPRITE0_1+2
      1  682b		       8d ec fa 	      sta	[RAM]+SMSPRITE0_1+2
      0  682e					      sta@RAM	SMSPRITE8_1+2
      1  682e		       8d 1d fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  6831					      sta@RAM	SMSPRITE16_1+2
      1  6831		       8d ae fa 	      sta	[RAM]+SMSPRITE16_1+2
     47  6834
     48  6834		       60		      rts
     49  6835
     50  6835
     51  6835							;---------------------------------------------------------------------------------------------------
     52  6835
      0  6835					      DEF	WriteCursor
      1  6835				   SLOT_WriteCursor SET	_BANK_SLOT
      2  6835				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  6835				   WriteCursor
      4  6835				   TEMPORARY_VAR SET	Overlay
      5  6835				   TEMPORARY_OFFSET SET	0
      6  6835				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  6835				   FUNCTION_NAME SET	WriteCursor
     54  6835					      SUBROUTINE
     55  6835
      0  6835					      REF	StartupBankReset	;✅
      1  6835				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  6835				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  6835					      ENDIF
      0  6835					      VEND	WriteCursor
      1  6835
      2  6835
      3  6835		       00 a7	   VAREND_WriteCursor =	TEMPORARY_VAR
      4  6835
     58  6835
     59  6835		       38		      sec
     60  6836		       a5 89		      lda	cursorX12
     61  6838		       30 22		      bmi	.exit
     62  683a		       a2 0a		      ldx	#10
     63  683c		       e9 0a	   .sub10     sbc	#10
     64  683e		       ca		      dex
     65  683f		       b0 fb		      bcs	.sub10
     66  6841
     67  6841		       8a		      txa
     68  6842		       69 80		      adc	#SLOT_DrawRow	;cc implied
     69  6844		       85 3e		      sta	SET_BANK_RAM
     70  6846
     71  6846		       a9 98		      lda	#<SpriteBuffer
      0  6848					      sta@RAM	SMSPRITE0_0+1
      1  6848		       8d e6 fa 	      sta	[RAM]+SMSPRITE0_0+1
      0  684b					      sta@RAM	SMSPRITE8_0+1
      1  684b		       8d 17 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  684e					      sta@RAM	SMSPRITE16_0+1
      1  684e		       8d a8 fa 	      sta	[RAM]+SMSPRITE16_0+1
     75  6851		       a9 f8		      lda	#>SpriteBuffer
      0  6853					      sta@RAM	SMSPRITE0_0+2
      1  6853		       8d e7 fa 	      sta	[RAM]+SMSPRITE0_0+2
      0  6856					      sta@RAM	SMSPRITE8_0+2
      1  6856		       8d 18 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  6859					      sta@RAM	SMSPRITE16_0+2
      1  6859		       8d a9 fa 	      sta	[RAM]+SMSPRITE16_0+2
     79  685c
     80  685c		       60	   .exit      rts
     81  685d
     82  685d
     83  685d							;---------------------------------------------------------------------------------------------------
     84  685d
      0  685d					      DEF	BackupBitmaps
      1  685d				   SLOT_BackupBitmaps SET	_BANK_SLOT
      2  685d				   BANK_BackupBitmaps SET	SLOT_BackupBitmaps + _CURRENT_BANK
      3  685d				   BackupBitmaps
      4  685d				   TEMPORARY_VAR SET	Overlay
      5  685d				   TEMPORARY_OFFSET SET	0
      6  685d				   VAR_BOUNDARY_BackupBitmaps SET	TEMPORARY_OFFSET
      7  685d				   FUNCTION_NAME SET	BackupBitmaps
     86  685d					      SUBROUTINE
     87  685d
     88  685d							; drawCount = ROW# (0-7)
     89  685d
      0  685d					      REF	aiInCheckBackup
      1  685d					      IF	VAREND_aiInCheckBackup > TEMPORARY_VAR
      2  685d				   TEMPORARY_VAR SET	VAREND_aiInCheckBackup
      3  685d					      ENDIF
      0  685d					      VEND	BackupBitmaps
      1  685d
      2  685d
      3  685d		       00 a9	   VAREND_BackupBitmaps =	TEMPORARY_VAR
      4  685d
     92  685d
     93  685d							; switch in in ROW bitmap to RAM
     94  685d
     95  685d		       a5 85		      lda	drawCount
     96  685f		       09 80		      ora	#SLOT2
     97  6861		       85 3e		      sta	SET_BANK_RAM	;@2
     98  6863
     99  6863							; save bitmap data to backup
    100  6863
    101  6863		       a0 00		      ldy	#0
      0  6865				   .fromTo    lda@RAM	ChessBitmap,y
      1  6865		       b9 00 f8 	      lda	ChessBitmap,y
      0  6868					      sta@RAM	BackupBitmap,y
      1  6868		       99 49 fb 	      sta	[RAM]+BackupBitmap,y
    104  686b
    105  686b							;lda #255
    106  686b							;sta@RAM ChessBitmap,y
    107  686b
    108  686b		       c8		      iny
    109  686c		       c0 90		      cpy	#ROW_BITMAP_SIZE
    110  686e		       d0 f5		      bne	.fromTo
    111  6870		       60		      rts
    112  6871
    113  6871
    114  6871							;---------------------------------------------------------------------------------------------------
    115  6871
      0  6871					      DEF	RestoreBitmaps
      1  6871				   SLOT_RestoreBitmaps SET	_BANK_SLOT
      2  6871				   BANK_RestoreBitmaps SET	SLOT_RestoreBitmaps + _CURRENT_BANK
      3  6871				   RestoreBitmaps
      4  6871				   TEMPORARY_VAR SET	Overlay
      5  6871				   TEMPORARY_OFFSET SET	0
      6  6871				   VAR_BOUNDARY_RestoreBitmaps SET	TEMPORARY_OFFSET
      7  6871				   FUNCTION_NAME SET	RestoreBitmaps
    117  6871					      SUBROUTINE
    118  6871
      0  6871					      VEND	RestoreBitmaps
      1  6871
      2  6871
      3  6871		       00 a7	   VAREND_RestoreBitmaps =	TEMPORARY_VAR
      4  6871
    120  6871
    121  6871							; switch in in ROW bitmap to RAM
    122  6871
    123  6871		       a5 85		      lda	drawCount
    124  6873		       09 80		      ora	#SLOT2
    125  6875		       85 3e		      sta	SET_BANK_RAM	;@2
    126  6877
    127  6877							; copy backup bitmap back to origin
    128  6877
    129  6877		       a0 00		      ldy	#0
      0  6879				   .fromTo    lda@RAM	BackupBitmap,y
      1  6879		       b9 49 f9 	      lda	BackupBitmap,y
      0  687c					      sta@RAM	ChessBitmap,y
      1  687c		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    132  687f		       c8		      iny
    133  6880		       c0 90		      cpy	#ROW_BITMAP_SIZE
    134  6882		       d0 f5		      bne	.fromTo
    135  6884
    136  6884		       60		      rts
    137  6885
    138  6885
    139  6885							;---------------------------------------------------------------------------------------------------
    140  6885
    141  6885				  -	      IF	0
    142  6885				  -
    143  6885				  -	      DEF	CopyTextToRowBitmap
    144  6885				  -	      SUBROUTINE
    145  6885				  -
    146  6885				  -	      VEND	CopyTextToRowBitmap
    147  6885				  -
    148  6885				  -			; An OR-draw, used for placing matricies/text onscreen
    149  6885				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    150  6885				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    151  6885				  -			; in original state once text disappears
    152  6885				  -
    153  6885				  -	      ldy	#PIECE_SHAPE_SIZE-1
    154  6885				  -	      bcs	.rightSide
    155  6885				  -
    156  6885				  -.copy      lda	__pieceShapeBuffer,y
    157  6885				  -	      ora	ChessBitmap,y
    158  6885				  -	      sta@RAM	ChessBitmap,y
    159  6885				  -	      dey
    160  6885				  -	      bpl	.copy
    161  6885				  -
    162  6885				  -	      rts
    163  6885				  -
    164  6885				  -.rightSide
    165  6885				  -
    166  6885				  -	      SUBROUTINE
    167  6885				  -
    168  6885				  -.copy      lda	__pieceShapeBuffer,y
    169  6885				  -	      ora	ChessBitmap+PIECE_SHAPE_SIZE,y
    170  6885				  -	      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE,y
    171  6885				  -	      dey
    172  6885				  -	      bpl	.copy
    173  6885				  -
    174  6885				  -	      rts
    175  6885				  -
    176  6885					      ENDIF
    177  6885
    178  6885							;---------------------------------------------------------------------------------------------------
    179  6885
      0  6885					      DEF	aiMaskBitmapBackground
      1  6885				   SLOT_aiMaskBitmapBackground SET	_BANK_SLOT
      2  6885				   BANK_aiMaskBitmapBackground SET	SLOT_aiMaskBitmapBackground + _CURRENT_BANK
      3  6885				   aiMaskBitmapBackground
      4  6885				   TEMPORARY_VAR SET	Overlay
      5  6885				   TEMPORARY_OFFSET SET	0
      6  6885				   VAR_BOUNDARY_aiMaskBitmapBackground SET	TEMPORARY_OFFSET
      7  6885				   FUNCTION_NAME SET	aiMaskBitmapBackground
    181  6885					      SUBROUTINE
    182  6885
    183  6885							; Remove any unwanted background via mask
    184  6885
      0  6885					      REF	AiStateMachine
      1  6885					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  6885				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  6885					      ENDIF
      0  6885					      VAR	_tt,1
      1  6885		       00 a9	   _tt	      =	TEMPORARY_VAR
      2  6885				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6885
      4  6885				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6885				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6885				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6885					      ENDIF
      8  6885				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  6885				  -VNAME      SETSTR	_tt
     10  6885				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  6885				  -	      ERR
     12  6885					      ENDIF
      0  6885					      VAR	_mask, 2
      1  6885		       00 aa	   _mask      =	TEMPORARY_VAR
      2  6885				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6885
      4  6885				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6885				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6885				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6885					      ENDIF
      8  6885				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  6885				  -VNAME      SETSTR	_mask
     10  6885				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  6885				  -	      ERR
     12  6885					      ENDIF
      0  6885					      VAR	_mask2, 2
      1  6885		       00 ac	   _mask2     =	TEMPORARY_VAR
      2  6885				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6885
      4  6885				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6885				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6885				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6885					      ENDIF
      8  6885				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  6885				  -VNAME      SETSTR	_mask2
     10  6885				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  6885				  -	      ERR
     12  6885					      ENDIF
      0  6885					      VEND	aiMaskBitmapBackground
      1  6885
      2  6885
      3  6885		       00 ae	   VAREND_aiMaskBitmapBackground =	TEMPORARY_VAR
      4  6885
    190  6885
    191  6885		       c6 85		      dec	drawCount
    192  6887		       30 34		      bmi	.next
    193  6889
    194  6889		       a5 85		      lda	drawCount
    195  688b		       09 80		      ora	#SLOT2
    196  688d		       85 3e		      sta	SET_BANK_RAM
    197  688f
    198  688f		       a9 9c		      lda	#BANK_BitmapShapeLO
    199  6891		       85 3f		      sta	SET_BANK	;@2
    200  6893
    201  6893		       a0 00		      ldy	#0	; hardwired bitmap shape #
    202  6895
    203  6895		       b9 00 f8 	      lda	BitmapShapeLO,y
    204  6898		       85 aa		      sta	_mask
    205  689a		       b9 02 f8 	      lda	BitmapShapeHI,y
    206  689d		       85 ab		      sta	_mask+1
    207  689f
    208  689f		       a4 85		      ldy	drawCount	; row
    209  68a1		       b1 aa		      lda	(_mask),y
    210  68a3		       c9 ff		      cmp	#-1
    211  68a5		       f0 15		      beq	.exit	; no mask for this row
    212  68a7
    213  68a7
    214  68a7
    215  68a7		       a9 16		      lda	#<SampleBitmap
    216  68a9		       85 aa		      sta	_mask
    217  68ab		       a9 fd		      lda	#>SampleBitmap
    218  68ad		       85 ab		      sta	_mask+1
    219  68af
    220  68af		       a0 8f		      ldy	#ROW_BITMAP_SIZE-1
    221  68b1		       b1 aa	   .draw      lda	(_mask),y
      0  68b3					      and@RAM	ChessBitmap,y
      1  68b3		       39 00 f8 	      and	ChessBitmap,y
      0  68b6					      sta@RAM	ChessBitmap,y
      1  68b6		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    224  68b9
    225  68b9		       88		      dey
    226  68ba		       10 f5		      bpl	.draw
    227  68bc		       60	   .exit      rts
    228  68bd
    229  68bd
    230  68bd				   .next
    231  68bd		       a9 08		      lda	#8
    232  68bf		       85 85		      sta	drawCount	; ROW
    233  68c1
      0  68c1				   .noButton  PHASE	DrawBitmap2
      1  68c1		       a9 30		      lda	#AI_DrawBitmap2
      2  68c3		       85 8c		      sta	aiState
    235  68c5		       60		      rts
    236  68c6
      0  68c6				   pwb	      PHASE	WaitBitmap
      1  68c6		       a9 2e		      lda	#AI_WaitBitmap
      2  68c8		       85 8c		      sta	aiState
    238  68ca		       60		      rts
    239  68cb
    240  68cb
      0  68cb					      DEF	aiDrawBitmap2
      1  68cb				   SLOT_aiDrawBitmap2 SET	_BANK_SLOT
      2  68cb				   BANK_aiDrawBitmap2 SET	SLOT_aiDrawBitmap2 + _CURRENT_BANK
      3  68cb				   aiDrawBitmap2
      4  68cb				   TEMPORARY_VAR SET	Overlay
      5  68cb				   TEMPORARY_OFFSET SET	0
      6  68cb				   VAR_BOUNDARY_aiDrawBitmap2 SET	TEMPORARY_OFFSET
      7  68cb				   FUNCTION_NAME SET	aiDrawBitmap2
    242  68cb					      SUBROUTINE
    243  68cb
      0  68cb					      REF	AiStateMachine
      1  68cb					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  68cb				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  68cb					      ENDIF
      0  68cb					      VEND	aiDrawBitmap2
      1  68cb
      2  68cb
      3  68cb		       00 a9	   VAREND_aiDrawBitmap2 =	TEMPORARY_VAR
      4  68cb
    246  68cb
    247  68cb		       c6 85		      dec	drawCount
    248  68cd		       30 1e		      bmi	.next
    249  68cf
    250  68cf		       a5 85		      lda	drawCount
    251  68d1		       09 80		      ora	#SLOT2
    252  68d3		       85 3e		      sta	SET_BANK_RAM
    253  68d5
    254  68d5
    255  68d5		       a2 47		      ldx	#ROW_BITMAP_SIZE/2-1
    256  68d7
    257  68d7		       bd a6 fd    .draw      lda	SampleBitmap2,x
      0  68da					      ora@RAM	ChessBitmap,x
      1  68da		       1d 00 f8 	      ora	ChessBitmap,x
      0  68dd					      sta@RAM	ChessBitmap,x
      1  68dd		       9d 00 fa 	      sta	[RAM]+ChessBitmap,x
    260  68e0
    261  68e0		       bd ee fd 	      lda	SampleBitmap2+ROW_BITMAP_SIZE/2,x
      0  68e3					      ora@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  68e3		       1d 48 f8 	      ora	ChessBitmap+ROW_BITMAP_SIZE/2,x
      0  68e6					      sta@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  68e6		       9d 48 fa 	      sta	[RAM]+ChessBitmap+ROW_BITMAP_SIZE/2,x
    264  68e9
    265  68e9		       ca		      dex
    266  68ea		       10 eb		      bpl	.draw
    267  68ec		       60		      rts
    268  68ed
      0  68ed				   .next      PHASE	WaitBitmap
      1  68ed		       a9 2e		      lda	#AI_WaitBitmap
      2  68ef		       85 8c		      sta	aiState
    270  68f1		       60		      rts
    271  68f2
      0  68f2					      DEF	aiDrawBitmap3
      1  68f2				   SLOT_aiDrawBitmap3 SET	_BANK_SLOT
      2  68f2				   BANK_aiDrawBitmap3 SET	SLOT_aiDrawBitmap3 + _CURRENT_BANK
      3  68f2				   aiDrawBitmap3
      4  68f2				   TEMPORARY_VAR SET	Overlay
      5  68f2				   TEMPORARY_OFFSET SET	0
      6  68f2				   VAR_BOUNDARY_aiDrawBitmap3 SET	TEMPORARY_OFFSET
      7  68f2				   FUNCTION_NAME SET	aiDrawBitmap3
    273  68f2					      SUBROUTINE
    274  68f2
      0  68f2					      REF	AiStateMachine
      1  68f2					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  68f2				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  68f2					      ENDIF
      0  68f2					      VEND	aiDrawBitmap3
      1  68f2
      2  68f2
      3  68f2		       00 a9	   VAREND_aiDrawBitmap3 =	TEMPORARY_VAR
      4  68f2
    277  68f2
    278  68f2
    279  68f2		       a9 84		      lda	#SLOT2|4
    280  68f4		       85 3e		      sta	SET_BANK_RAM
    281  68f6
    282  68f6
    283  68f6		       a2 47		      ldx	#ROW_BITMAP_SIZE/2-1
    284  68f8
    285  68f8		       bd a6 fd    .draw      lda	SampleBitmap3,x
      0  68fb					      ora@RAM	ChessBitmap,x
      1  68fb		       1d 00 f8 	      ora	ChessBitmap,x
      0  68fe					      sta@RAM	ChessBitmap,x
      1  68fe		       9d 00 fa 	      sta	[RAM]+ChessBitmap,x
    288  6901
    289  6901		       bd ee fd 	      lda	SampleBitmap3+ROW_BITMAP_SIZE/2,x
      0  6904					      ora@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  6904		       1d 48 f8 	      ora	ChessBitmap+ROW_BITMAP_SIZE/2,x
      0  6907					      sta@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  6907		       9d 48 fa 	      sta	[RAM]+ChessBitmap+ROW_BITMAP_SIZE/2,x
    292  690a
    293  690a							;		      lda SampleBitmap,y
    294  690a							;		      ora@RAM ChessBitmap+6,x
    295  690a							;		      sta@RAM ChessBitmap+6,x
    296  690a
    297  690a							;		      lda SampleBitmap,y
    298  690a							;		      ora@RAM ChessBitmap+12,x
    299  690a							;		      sta@RAM ChessBitmap+12,x
    300  690a
    301  690a							;		      iny
    302  690a
    303  690a		       ca		      dex
    304  690b		       10 eb		      bpl	.draw
    305  690d
    306  690d
    307  690d
      0  690d					      PHASE	WaitBitmap
      1  690d		       a9 2e		      lda	#AI_WaitBitmap
      2  690f		       85 8c		      sta	aiState
    309  6911							;PHASE DrawBitmap
    310  6911		       60		      rts
    311  6912
    312  6912
      0  6912					      DEF	Phaser
      1  6912				   SLOT_Phaser SET	_BANK_SLOT
      2  6912				   BANK_Phaser SET	SLOT_Phaser + _CURRENT_BANK
      3  6912				   Phaser
      4  6912				   TEMPORARY_VAR SET	Overlay
      5  6912				   TEMPORARY_OFFSET SET	0
      6  6912				   VAR_BOUNDARY_Phaser SET	TEMPORARY_OFFSET
      7  6912				   FUNCTION_NAME SET	Phaser
    314  6912		       00 01 02 03	      .byte.b	0, 1, 2, 3
    315  6916
    316  6916
      0  6916					      DEF	SampleBitmap
      1  6916				   SLOT_SampleBitmap SET	_BANK_SLOT
      2  6916				   BANK_SampleBitmap SET	SLOT_SampleBitmap + _CURRENT_BANK
      3  6916				   SampleBitmap
      4  6916				   TEMPORARY_VAR SET	Overlay
      5  6916				   TEMPORARY_OFFSET SET	0
      6  6916				   VAR_BOUNDARY_SampleBitmap SET	TEMPORARY_OFFSET
      7  6916				   FUNCTION_NAME SET	SampleBitmap
    318  6916
    319  6916
    320  6916							; line 7,6,5,4,3,2,1,0
    321  6916							; R/G/B on successive lines
    322  6916							; PF0/PF1/PF2/PF0/PF1/PF2
    323  6916							; x axis goes downwards
    324  6916
    325  6916
    326  6916		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    327  691c		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    328  6922		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    329  6928		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    330  692e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    331  6934		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    332  693a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    333  6940		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    334  6946		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    335  694c		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    336  6952		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    337  6958		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    338  695e		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    339  6964		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    340  696a		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    341  6970		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    342  6976		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    343  697c		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    344  6982		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    345  6988		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    346  698e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    347  6994		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    348  699a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    349  69a0		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    350  69a6
    351  69a6
    352  69a6
    353  69a6
      0  69a6					      DEF	SampleBitmap2
      1  69a6				   SLOT_SampleBitmap2 SET	_BANK_SLOT
      2  69a6				   BANK_SampleBitmap2 SET	SLOT_SampleBitmap2 + _CURRENT_BANK
      3  69a6				   SampleBitmap2
      4  69a6				   TEMPORARY_VAR SET	Overlay
      5  69a6				   TEMPORARY_OFFSET SET	0
      6  69a6				   VAR_BOUNDARY_SampleBitmap2 SET	TEMPORARY_OFFSET
      7  69a6				   FUNCTION_NAME SET	SampleBitmap2
      0  69a6					      DEF	SampleBitmap3
      1  69a6				   SLOT_SampleBitmap3 SET	_BANK_SLOT
      2  69a6				   BANK_SampleBitmap3 SET	SLOT_SampleBitmap3 + _CURRENT_BANK
      3  69a6				   SampleBitmap3
      4  69a6				   TEMPORARY_VAR SET	Overlay
      5  69a6				   TEMPORARY_OFFSET SET	0
      6  69a6				   VAR_BOUNDARY_SampleBitmap3 SET	TEMPORARY_OFFSET
      7  69a6				   FUNCTION_NAME SET	SampleBitmap3
    356  69a6
    357  69a6							; line 7,6,5,4,3,2,1,0
    358  69a6							; R/G/B on successive lines
    359  69a6							; PF0/PF1/PF2/PF0/PF1/PF2
    360  69a6							; x axis goes downwards
    361  69a6
    362  69a6							;     7	 6	   5	     4	       3	 2	   1	     0
    363  69a6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R PF0 left
    364  69ae		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    365  69b6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
    366  69be
    367  69be		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    368  69c6		       64 94 84 84*	      .byte.b	%01100100,%10010100,%10000100,%10000100,%10000111,%10000100,%10010100,%01100100	;B
    369  69ce		       64 94 84 84*	      .byte.b	%01100100,%10010100,%10000100,%10000100,%10000111,%10000100,%10010100,%01100100	;B
    370  69d6
    371  69d6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    372  69de		       3d 85 85 85*	      .byte.b	%00111101,%10000101,%10000101,%10000101,%10011101,%10000101,%10000101,%00111101
    373  69e6		       3d 85 85 85*	      .byte.b	%00111101,%10000101,%10000101,%10000101,%10011101,%10000101,%10000101,%00111101
    374  69ee
    375  69ee		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    376  69f6		       30 01 81 01*	      .byte.b	%00110000,%00000001,%10000001,%00000001,%00000001,%00000001,%00001111,%00110000
    377  69fe		       30 01 81 01*	      .byte.b	%00110000,%00000001,%10000001,%00000001,%00000001,%00000001,%00001111,%00110000
    378  6a06
    379  6a06		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    380  6a0e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    381  6a16		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    382  6a1e
    383  6a1e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    384  6a26		       81 00 81 01*	      .byte.b	%10000001,%00000000,%10000001,%00000001,%00000001,%00000001,%00000001,%00000001
    385  6a2e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    386  6a36
    387  6a36
    388  6a36
    389  6a36							; line 7,6,5,4,3,2,1,0
    390  6a36							; R/G/B on successive lines
    391  6a36							; PF0/PF1/PF2/PF0/PF1/PF2
    392  6a36							; x axis goes downwards
    393  6a36
    394  6a36							;     7	 6	   5	     4	       3	 2	   1	     0
    395  6a36		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R PF0 left
    396  6a3e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    397  6a46		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
    398  6a4e
    399  6a4e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    400  6a56		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    401  6a5e		       64 94 84 84*	      .byte.b	%01100100,%10010100,%10000100,%10000100,%10000111,%10000100,%10010100,%01100100	;B
    402  6a66
    403  6a66		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    404  6a6e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    405  6a76		       3d 85 85 85*	      .byte.b	%00111101,%10000101,%10000101,%10000101,%10011101,%10000101,%10000101,%00111101
    406  6a7e
    407  6a7e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    408  6a86		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    409  6a8e		       30 01 81 01*	      .byte.b	%00110000,%00000001,%10000001,%00000001,%00000001,%00000001,%00001111,%00110000
    410  6a96
    411  6a96		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    412  6a9e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    413  6aa6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    414  6aae
    415  6aae		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    416  6ab6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    417  6abe		       81 00 81 01*	      .byte.b	%10000001,%00000000,%10000001,%00000001,%00000001,%00000001,%00000001,%00000001
    418  6ac6
    419  6ac6
    420  6ac6
    421  6ac6
    422  6ac6
    423  6ac6
    424  6ac6							;---------------------------------------------------------------------------------------------------
    425  6ac6
      0  6ac6					      END_BANK
      1  6ac6				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  6ac6				  -	      CHECK_RAM_BANK_SIZE
      3  6ac6					      ELSE
      0  6ac6					      CHECK_BANK_SIZE
      1  6ac6		       02 c6	   .TEMP      =	* - _BANK_START
 ROM bank # 27 ROM_SCREEN size = $2c6 free = 313
      2  6ac6					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  6ac6				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6ac6				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  6ac6				  -	      ERR
      6  6ac6					      ENDIF
      5  6ac6					      ENDIF
    427  6ac6
    428  6ac6							;---------------------------------------------------------------------------------------------------
    429  6ac6							;EOF
------- FILE ./chess.asm
------- FILE @3 EVALUATE.asm LEVEL 2 PASS 4
      0  6ac6					      include	"@3 EVALUATE.asm"
      1  6ac6							;---------------------------------------------------------------------------------------------------
      2  6ac6							; @3 EVALUATE.asm
      3  6ac6
      4  6ac6							; Atari 2600 Chess
      5  6ac6							; Copyright (c) 2019-2020 Andrew Davie
      6  6ac6							; andrew@taswegian.com
      7  6ac6
      8  6ac6
      9  6ac6							;---------------------------------------------------------------------------------------------------
     10  6ac6
      0  6ac6					      SLOT	3
      1  6ac6
      2  6ac6				  -	      IF	(3 < 0) || (3 > 3)
      3  6ac6				  -	      ECHO	"Illegal bank address/segment location", 3
      4  6ac6				  -	      ERR
      5  6ac6					      ENDIF
      6  6ac6
      7  6ac6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  6ac6				   _BANK_SLOT SET	3 * 64
      9  6ac6
      0  6ac6					      RAMBANK	EVALUATE
      1  6ac6
      2 U4400 ????				      SEG.U	RAM_EVALUATE
      3 U4400					      ORG	ORIGIN_RAM
      4 U4400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U4400				   _BANK_START SET	*
      6 U4400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U4400				   RAMBANK_EVALUATE SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U4400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U4400				   _LAST_BANK SETSTR	EVALUATE
     10 U4400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U4400					      END_BANK
      1 U4400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U4400					      CHECK_RAM_BANK_SIZE
      1 U4400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 35 EVALUATE size =  $0 free = $1ff
      2 U4400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U4400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U4400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U4400				  -	      ERR
      6 U4400					      ENDIF
      3 U4400				  -	      ELSE
      4 U4400				  -	      CHECK_BANK_SIZE
      5 U4400					      ENDIF
     14 U4400
     15 U4400
     16 U4400							;---------------------------------------------------------------------------------------------------
     17 U4400
      0 U4400					      ROMBANK	EVALUATE
      1  6e40 ????				      SEG	ROM_EVALUATE
      2  6c00					      ORG	_ORIGIN
      3  6c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  6c00				   _BANK_START SET	*
      5  6c00				   EVALUATE_START SET	*
      6  6c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6c00				   ROMBANK_EVALUATE SET	_BANK_SLOT + _CURRENT_BANK
      8  6c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6c00				   _LAST_BANK SETSTR	EVALUATE
     10  6c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     19  6c00
     20  6c00
     21  6c00							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     22  6c00
     23  6c00
     24  6c00							;ds 22
     25  6c00
     26  6c00							;---------------------------------------------------------------------------------------------------
     27  6c00							; Vectors to the position value tables for each piece
     28  6c00
     29  6c00							;---------------------------------------------------------------------------------------------------
     30  6c00							; Vectors to the position value tables for each piece
     31  6c00
     32  6c00					      MAC	posval
     33  6c00					      .byte	0
     34  6c00					      .byte	{1}(PositionalValue_PAWN - 22)
     35  6c00					      .byte	{1}(PositionalValue_PAWN - 22)
     36  6c00					      .byte	{1}(PositionalValue_KNIGHT - 22)
     37  6c00					      .byte	{1}(PositionalValue_BISHOP - 22)
     38  6c00					      .byte	{1}(PositionalValue_ROOK - 22)
     39  6c00					      .byte	{1}(PositionalValue_QUEEN - 22)
     40  6c00					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
     41  6c00					      ENDM
     42  6c00
      0  6c00					      ALLOCATE	PosValVecLO, 8
      1  6c00
      2  6c00				   .NAME      SETSTR	PosValVecLO
      0  6c00					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  6c00
      2  6c00				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  6c00				  -.EARLY_LOCATION SET	*
      4  6c00				  -	      ALIGN	256
      5  6c00				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  6c00					      ENDIF
      0  6c00					      DEF	PosValVecLO
      1  6c00				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  6c00				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  6c00				   PosValVecLO
      4  6c00				   TEMPORARY_VAR SET	Overlay
      5  6c00				   TEMPORARY_OFFSET SET	0
      6  6c00				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  6c00				   FUNCTION_NAME SET	PosValVecLO
      5  6c00
      0  6c00					      POSVAL	<
      1  6c00		       00		      .byte.b	0
      2  6c01		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      3  6c02		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      4  6c03		       4a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  6c04		       9a		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  6c05		       ea		      .byte.b	<(PositionalValue_ROOK - 22)
      7  6c06		       3a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  6c07		       8a		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  6c08					      ALLOCATE	PosValVecHI, 8
      1  6c08
      2  6c08				   .NAME      SETSTR	PosValVecHI
      0  6c08					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  6c08
      2  6c08				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  6c08				  -.EARLY_LOCATION SET	*
      4  6c08				  -	      ALIGN	256
      5  6c08				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  6c08					      ENDIF
      0  6c08					      DEF	PosValVecHI
      1  6c08				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  6c08				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  6c08				   PosValVecHI
      4  6c08				   TEMPORARY_VAR SET	Overlay
      5  6c08				   TEMPORARY_OFFSET SET	0
      6  6c08				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  6c08				   FUNCTION_NAME SET	PosValVecHI
      5  6c08
      0  6c08					      POSVAL	>
      1  6c08		       00		      .byte.b	0
      2  6c09		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      3  6c0a		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      4  6c0b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  6c0c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  6c0d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  6c0e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  6c0f		       fd		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
     47  6c10
     48  6c10
     49  6c10					      MAC	eval8
     50  6c10					      IF	({1} > 127) || ({1} < -128)
     51  6c10					      ECHO	"Erroneous position value", {1}
     52  6c10					      ERR
     53  6c10					      ENDIF
     54  6c10					      .byte	{1}
     55  6c10					      ENDM
     56  6c10
     57  6c10
     58  6c10					      MAC	pval
     59  6c10					      EVAL8	{1}
     60  6c10					      EVAL8	{2}
     61  6c10					      EVAL8	{3}
     62  6c10					      EVAL8	{4}
     63  6c10					      EVAL8	{5}
     64  6c10					      EVAL8	{6}
     65  6c10					      EVAL8	{7}
     66  6c10					      EVAL8	{8}
     67  6c10					      EVAL8	0
     68  6c10					      EVAL8	0
     69  6c10					      ENDM		;{ 10 entries }
     70  6c10
     71  6c10
     72  6c10							;---------------------------------------------------------------------------------------------------
     73  6c10
     74  6c10				   PositionalValue_PAWN
     75  6c10
      0  6c10					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  6c10					      EVAL8	0
      1  6c10				  -	      IF	(0 > 127) || (0 < -128)
      2  6c10				  -	      ECHO	"Erroneous position value", 0
      3  6c10				  -	      ERR
      4  6c10					      ENDIF
      5  6c10		       00		      .byte.b	0
      0  6c11					      EVAL8	0
      1  6c11				  -	      IF	(0 > 127) || (0 < -128)
      2  6c11				  -	      ECHO	"Erroneous position value", 0
      3  6c11				  -	      ERR
      4  6c11					      ENDIF
      5  6c11		       00		      .byte.b	0
      0  6c12					      EVAL8	0
      1  6c12				  -	      IF	(0 > 127) || (0 < -128)
      2  6c12				  -	      ECHO	"Erroneous position value", 0
      3  6c12				  -	      ERR
      4  6c12					      ENDIF
      5  6c12		       00		      .byte.b	0
      0  6c13					      EVAL8	0
      1  6c13				  -	      IF	(0 > 127) || (0 < -128)
      2  6c13				  -	      ECHO	"Erroneous position value", 0
      3  6c13				  -	      ERR
      4  6c13					      ENDIF
      5  6c13		       00		      .byte.b	0
      0  6c14					      EVAL8	0
      1  6c14				  -	      IF	(0 > 127) || (0 < -128)
      2  6c14				  -	      ECHO	"Erroneous position value", 0
      3  6c14				  -	      ERR
      4  6c14					      ENDIF
      5  6c14		       00		      .byte.b	0
      0  6c15					      EVAL8	0
      1  6c15				  -	      IF	(0 > 127) || (0 < -128)
      2  6c15				  -	      ECHO	"Erroneous position value", 0
      3  6c15				  -	      ERR
      4  6c15					      ENDIF
      5  6c15		       00		      .byte.b	0
      0  6c16					      EVAL8	0
      1  6c16				  -	      IF	(0 > 127) || (0 < -128)
      2  6c16				  -	      ECHO	"Erroneous position value", 0
      3  6c16				  -	      ERR
      4  6c16					      ENDIF
      5  6c16		       00		      .byte.b	0
      0  6c17					      EVAL8	0
      1  6c17				  -	      IF	(0 > 127) || (0 < -128)
      2  6c17				  -	      ECHO	"Erroneous position value", 0
      3  6c17				  -	      ERR
      4  6c17					      ENDIF
      5  6c17		       00		      .byte.b	0
      0  6c18					      EVAL8	0
      1  6c18				  -	      IF	(0 > 127) || (0 < -128)
      2  6c18				  -	      ECHO	"Erroneous position value", 0
      3  6c18				  -	      ERR
      4  6c18					      ENDIF
      5  6c18		       00		      .byte.b	0
      0  6c19					      EVAL8	0
      1  6c19				  -	      IF	(0 > 127) || (0 < -128)
      2  6c19				  -	      ECHO	"Erroneous position value", 0
      3  6c19				  -	      ERR
      4  6c19					      ENDIF
      5  6c19		       00		      .byte.b	0
      0  6c1a					      PVAL	15, 20, 0, -10, -10, 0, 20, 15
      0  6c1a					      EVAL8	15
      1  6c1a				  -	      IF	(15 > 127) || (15 < -128)
      2  6c1a				  -	      ECHO	"Erroneous position value", 15
      3  6c1a				  -	      ERR
      4  6c1a					      ENDIF
      5  6c1a		       0f		      .byte.b	15
      0  6c1b					      EVAL8	20
      1  6c1b				  -	      IF	(20 > 127) || (20 < -128)
      2  6c1b				  -	      ECHO	"Erroneous position value", 20
      3  6c1b				  -	      ERR
      4  6c1b					      ENDIF
      5  6c1b		       14		      .byte.b	20
      0  6c1c					      EVAL8	0
      1  6c1c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c1c				  -	      ECHO	"Erroneous position value", 0
      3  6c1c				  -	      ERR
      4  6c1c					      ENDIF
      5  6c1c		       00		      .byte.b	0
      0  6c1d					      EVAL8	-10
      1  6c1d				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6c1d				  -	      ECHO	"Erroneous position value", -10
      3  6c1d				  -	      ERR
      4  6c1d					      ENDIF
      5  6c1d		       f6		      .byte.b	-10
      0  6c1e					      EVAL8	-10
      1  6c1e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6c1e				  -	      ECHO	"Erroneous position value", -10
      3  6c1e				  -	      ERR
      4  6c1e					      ENDIF
      5  6c1e		       f6		      .byte.b	-10
      0  6c1f					      EVAL8	0
      1  6c1f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c1f				  -	      ECHO	"Erroneous position value", 0
      3  6c1f				  -	      ERR
      4  6c1f					      ENDIF
      5  6c1f		       00		      .byte.b	0
      0  6c20					      EVAL8	20
      1  6c20				  -	      IF	(20 > 127) || (20 < -128)
      2  6c20				  -	      ECHO	"Erroneous position value", 20
      3  6c20				  -	      ERR
      4  6c20					      ENDIF
      5  6c20		       14		      .byte.b	20
      0  6c21					      EVAL8	15
      1  6c21				  -	      IF	(15 > 127) || (15 < -128)
      2  6c21				  -	      ECHO	"Erroneous position value", 15
      3  6c21				  -	      ERR
      4  6c21					      ENDIF
      5  6c21		       0f		      .byte.b	15
      0  6c22					      EVAL8	0
      1  6c22				  -	      IF	(0 > 127) || (0 < -128)
      2  6c22				  -	      ECHO	"Erroneous position value", 0
      3  6c22				  -	      ERR
      4  6c22					      ENDIF
      5  6c22		       00		      .byte.b	0
      0  6c23					      EVAL8	0
      1  6c23				  -	      IF	(0 > 127) || (0 < -128)
      2  6c23				  -	      ECHO	"Erroneous position value", 0
      3  6c23				  -	      ERR
      4  6c23					      ENDIF
      5  6c23		       00		      .byte.b	0
      0  6c24					      PVAL	5, -5, 20, 0, 0, 20, -5, 5
      0  6c24					      EVAL8	5
      1  6c24				  -	      IF	(5 > 127) || (5 < -128)
      2  6c24				  -	      ECHO	"Erroneous position value", 5
      3  6c24				  -	      ERR
      4  6c24					      ENDIF
      5  6c24		       05		      .byte.b	5
      0  6c25					      EVAL8	-5
      1  6c25				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6c25				  -	      ECHO	"Erroneous position value", -5
      3  6c25				  -	      ERR
      4  6c25					      ENDIF
      5  6c25		       fb		      .byte.b	-5
      0  6c26					      EVAL8	20
      1  6c26				  -	      IF	(20 > 127) || (20 < -128)
      2  6c26				  -	      ECHO	"Erroneous position value", 20
      3  6c26				  -	      ERR
      4  6c26					      ENDIF
      5  6c26		       14		      .byte.b	20
      0  6c27					      EVAL8	0
      1  6c27				  -	      IF	(0 > 127) || (0 < -128)
      2  6c27				  -	      ECHO	"Erroneous position value", 0
      3  6c27				  -	      ERR
      4  6c27					      ENDIF
      5  6c27		       00		      .byte.b	0
      0  6c28					      EVAL8	0
      1  6c28				  -	      IF	(0 > 127) || (0 < -128)
      2  6c28				  -	      ECHO	"Erroneous position value", 0
      3  6c28				  -	      ERR
      4  6c28					      ENDIF
      5  6c28		       00		      .byte.b	0
      0  6c29					      EVAL8	20
      1  6c29				  -	      IF	(20 > 127) || (20 < -128)
      2  6c29				  -	      ECHO	"Erroneous position value", 20
      3  6c29				  -	      ERR
      4  6c29					      ENDIF
      5  6c29		       14		      .byte.b	20
      0  6c2a					      EVAL8	-5
      1  6c2a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6c2a				  -	      ECHO	"Erroneous position value", -5
      3  6c2a				  -	      ERR
      4  6c2a					      ENDIF
      5  6c2a		       fb		      .byte.b	-5
      0  6c2b					      EVAL8	5
      1  6c2b				  -	      IF	(5 > 127) || (5 < -128)
      2  6c2b				  -	      ECHO	"Erroneous position value", 5
      3  6c2b				  -	      ERR
      4  6c2b					      ENDIF
      5  6c2b		       05		      .byte.b	5
      0  6c2c					      EVAL8	0
      1  6c2c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c2c				  -	      ECHO	"Erroneous position value", 0
      3  6c2c				  -	      ERR
      4  6c2c					      ENDIF
      5  6c2c		       00		      .byte.b	0
      0  6c2d					      EVAL8	0
      1  6c2d				  -	      IF	(0 > 127) || (0 < -128)
      2  6c2d				  -	      ECHO	"Erroneous position value", 0
      3  6c2d				  -	      ERR
      4  6c2d					      ENDIF
      5  6c2d		       00		      .byte.b	0
      0  6c2e					      PVAL	5, 5, 10, 20, 40, 20, 5, 5
      0  6c2e					      EVAL8	5
      1  6c2e				  -	      IF	(5 > 127) || (5 < -128)
      2  6c2e				  -	      ECHO	"Erroneous position value", 5
      3  6c2e				  -	      ERR
      4  6c2e					      ENDIF
      5  6c2e		       05		      .byte.b	5
      0  6c2f					      EVAL8	5
      1  6c2f				  -	      IF	(5 > 127) || (5 < -128)
      2  6c2f				  -	      ECHO	"Erroneous position value", 5
      3  6c2f				  -	      ERR
      4  6c2f					      ENDIF
      5  6c2f		       05		      .byte.b	5
      0  6c30					      EVAL8	10
      1  6c30				  -	      IF	(10 > 127) || (10 < -128)
      2  6c30				  -	      ECHO	"Erroneous position value", 10
      3  6c30				  -	      ERR
      4  6c30					      ENDIF
      5  6c30		       0a		      .byte.b	10
      0  6c31					      EVAL8	20
      1  6c31				  -	      IF	(20 > 127) || (20 < -128)
      2  6c31				  -	      ECHO	"Erroneous position value", 20
      3  6c31				  -	      ERR
      4  6c31					      ENDIF
      5  6c31		       14		      .byte.b	20
      0  6c32					      EVAL8	40
      1  6c32				  -	      IF	(40 > 127) || (40 < -128)
      2  6c32				  -	      ECHO	"Erroneous position value", 40
      3  6c32				  -	      ERR
      4  6c32					      ENDIF
      5  6c32		       28		      .byte.b	40
      0  6c33					      EVAL8	20
      1  6c33				  -	      IF	(20 > 127) || (20 < -128)
      2  6c33				  -	      ECHO	"Erroneous position value", 20
      3  6c33				  -	      ERR
      4  6c33					      ENDIF
      5  6c33		       14		      .byte.b	20
      0  6c34					      EVAL8	5
      1  6c34				  -	      IF	(5 > 127) || (5 < -128)
      2  6c34				  -	      ECHO	"Erroneous position value", 5
      3  6c34				  -	      ERR
      4  6c34					      ENDIF
      5  6c34		       05		      .byte.b	5
      0  6c35					      EVAL8	5
      1  6c35				  -	      IF	(5 > 127) || (5 < -128)
      2  6c35				  -	      ECHO	"Erroneous position value", 5
      3  6c35				  -	      ERR
      4  6c35					      ENDIF
      5  6c35		       05		      .byte.b	5
      0  6c36					      EVAL8	0
      1  6c36				  -	      IF	(0 > 127) || (0 < -128)
      2  6c36				  -	      ECHO	"Erroneous position value", 0
      3  6c36				  -	      ERR
      4  6c36					      ENDIF
      5  6c36		       00		      .byte.b	0
      0  6c37					      EVAL8	0
      1  6c37				  -	      IF	(0 > 127) || (0 < -128)
      2  6c37				  -	      ECHO	"Erroneous position value", 0
      3  6c37				  -	      ERR
      4  6c37					      ENDIF
      5  6c37		       00		      .byte.b	0
      0  6c38					      PVAL	15, 25, 50, 40, 50, 20, 25, 15
      0  6c38					      EVAL8	15
      1  6c38				  -	      IF	(15 > 127) || (15 < -128)
      2  6c38				  -	      ECHO	"Erroneous position value", 15
      3  6c38				  -	      ERR
      4  6c38					      ENDIF
      5  6c38		       0f		      .byte.b	15
      0  6c39					      EVAL8	25
      1  6c39				  -	      IF	(25 > 127) || (25 < -128)
      2  6c39				  -	      ECHO	"Erroneous position value", 25
      3  6c39				  -	      ERR
      4  6c39					      ENDIF
      5  6c39		       19		      .byte.b	25
      0  6c3a					      EVAL8	50
      1  6c3a				  -	      IF	(50 > 127) || (50 < -128)
      2  6c3a				  -	      ECHO	"Erroneous position value", 50
      3  6c3a				  -	      ERR
      4  6c3a					      ENDIF
      5  6c3a		       32		      .byte.b	50
      0  6c3b					      EVAL8	40
      1  6c3b				  -	      IF	(40 > 127) || (40 < -128)
      2  6c3b				  -	      ECHO	"Erroneous position value", 40
      3  6c3b				  -	      ERR
      4  6c3b					      ENDIF
      5  6c3b		       28		      .byte.b	40
      0  6c3c					      EVAL8	50
      1  6c3c				  -	      IF	(50 > 127) || (50 < -128)
      2  6c3c				  -	      ECHO	"Erroneous position value", 50
      3  6c3c				  -	      ERR
      4  6c3c					      ENDIF
      5  6c3c		       32		      .byte.b	50
      0  6c3d					      EVAL8	20
      1  6c3d				  -	      IF	(20 > 127) || (20 < -128)
      2  6c3d				  -	      ECHO	"Erroneous position value", 20
      3  6c3d				  -	      ERR
      4  6c3d					      ENDIF
      5  6c3d		       14		      .byte.b	20
      0  6c3e					      EVAL8	25
      1  6c3e				  -	      IF	(25 > 127) || (25 < -128)
      2  6c3e				  -	      ECHO	"Erroneous position value", 25
      3  6c3e				  -	      ERR
      4  6c3e					      ENDIF
      5  6c3e		       19		      .byte.b	25
      0  6c3f					      EVAL8	15
      1  6c3f				  -	      IF	(15 > 127) || (15 < -128)
      2  6c3f				  -	      ECHO	"Erroneous position value", 15
      3  6c3f				  -	      ERR
      4  6c3f					      ENDIF
      5  6c3f		       0f		      .byte.b	15
      0  6c40					      EVAL8	0
      1  6c40				  -	      IF	(0 > 127) || (0 < -128)
      2  6c40				  -	      ECHO	"Erroneous position value", 0
      3  6c40				  -	      ERR
      4  6c40					      ENDIF
      5  6c40		       00		      .byte.b	0
      0  6c41					      EVAL8	0
      1  6c41				  -	      IF	(0 > 127) || (0 < -128)
      2  6c41				  -	      ECHO	"Erroneous position value", 0
      3  6c41				  -	      ERR
      4  6c41					      ENDIF
      5  6c41		       00		      .byte.b	0
      0  6c42					      PVAL	60, 60, 80, 80, 80, 80, 60, 60
      0  6c42					      EVAL8	60
      1  6c42				  -	      IF	(60 > 127) || (60 < -128)
      2  6c42				  -	      ECHO	"Erroneous position value", 60
      3  6c42				  -	      ERR
      4  6c42					      ENDIF
      5  6c42		       3c		      .byte.b	60
      0  6c43					      EVAL8	60
      1  6c43				  -	      IF	(60 > 127) || (60 < -128)
      2  6c43				  -	      ECHO	"Erroneous position value", 60
      3  6c43				  -	      ERR
      4  6c43					      ENDIF
      5  6c43		       3c		      .byte.b	60
      0  6c44					      EVAL8	80
      1  6c44				  -	      IF	(80 > 127) || (80 < -128)
      2  6c44				  -	      ECHO	"Erroneous position value", 80
      3  6c44				  -	      ERR
      4  6c44					      ENDIF
      5  6c44		       50		      .byte.b	80
      0  6c45					      EVAL8	80
      1  6c45				  -	      IF	(80 > 127) || (80 < -128)
      2  6c45				  -	      ECHO	"Erroneous position value", 80
      3  6c45				  -	      ERR
      4  6c45					      ENDIF
      5  6c45		       50		      .byte.b	80
      0  6c46					      EVAL8	80
      1  6c46				  -	      IF	(80 > 127) || (80 < -128)
      2  6c46				  -	      ECHO	"Erroneous position value", 80
      3  6c46				  -	      ERR
      4  6c46					      ENDIF
      5  6c46		       50		      .byte.b	80
      0  6c47					      EVAL8	80
      1  6c47				  -	      IF	(80 > 127) || (80 < -128)
      2  6c47				  -	      ECHO	"Erroneous position value", 80
      3  6c47				  -	      ERR
      4  6c47					      ENDIF
      5  6c47		       50		      .byte.b	80
      0  6c48					      EVAL8	60
      1  6c48				  -	      IF	(60 > 127) || (60 < -128)
      2  6c48				  -	      ECHO	"Erroneous position value", 60
      3  6c48				  -	      ERR
      4  6c48					      ENDIF
      5  6c48		       3c		      .byte.b	60
      0  6c49					      EVAL8	60
      1  6c49				  -	      IF	(60 > 127) || (60 < -128)
      2  6c49				  -	      ECHO	"Erroneous position value", 60
      3  6c49				  -	      ERR
      4  6c49					      ENDIF
      5  6c49		       3c		      .byte.b	60
      0  6c4a					      EVAL8	0
      1  6c4a				  -	      IF	(0 > 127) || (0 < -128)
      2  6c4a				  -	      ECHO	"Erroneous position value", 0
      3  6c4a				  -	      ERR
      4  6c4a					      ENDIF
      5  6c4a		       00		      .byte.b	0
      0  6c4b					      EVAL8	0
      1  6c4b				  -	      IF	(0 > 127) || (0 < -128)
      2  6c4b				  -	      ECHO	"Erroneous position value", 0
      3  6c4b				  -	      ERR
      4  6c4b					      ENDIF
      5  6c4b		       00		      .byte.b	0
      0  6c4c					      PVAL	100, 100, 120, 120, 120, 120, 100, 100
      0  6c4c					      EVAL8	100
      1  6c4c				  -	      IF	(100 > 127) || (100 < -128)
      2  6c4c				  -	      ECHO	"Erroneous position value", 100
      3  6c4c				  -	      ERR
      4  6c4c					      ENDIF
      5  6c4c		       64		      .byte.b	100
      0  6c4d					      EVAL8	100
      1  6c4d				  -	      IF	(100 > 127) || (100 < -128)
      2  6c4d				  -	      ECHO	"Erroneous position value", 100
      3  6c4d				  -	      ERR
      4  6c4d					      ENDIF
      5  6c4d		       64		      .byte.b	100
      0  6c4e					      EVAL8	120
      1  6c4e				  -	      IF	(120 > 127) || (120 < -128)
      2  6c4e				  -	      ECHO	"Erroneous position value", 120
      3  6c4e				  -	      ERR
      4  6c4e					      ENDIF
      5  6c4e		       78		      .byte.b	120
      0  6c4f					      EVAL8	120
      1  6c4f				  -	      IF	(120 > 127) || (120 < -128)
      2  6c4f				  -	      ECHO	"Erroneous position value", 120
      3  6c4f				  -	      ERR
      4  6c4f					      ENDIF
      5  6c4f		       78		      .byte.b	120
      0  6c50					      EVAL8	120
      1  6c50				  -	      IF	(120 > 127) || (120 < -128)
      2  6c50				  -	      ECHO	"Erroneous position value", 120
      3  6c50				  -	      ERR
      4  6c50					      ENDIF
      5  6c50		       78		      .byte.b	120
      0  6c51					      EVAL8	120
      1  6c51				  -	      IF	(120 > 127) || (120 < -128)
      2  6c51				  -	      ECHO	"Erroneous position value", 120
      3  6c51				  -	      ERR
      4  6c51					      ENDIF
      5  6c51		       78		      .byte.b	120
      0  6c52					      EVAL8	100
      1  6c52				  -	      IF	(100 > 127) || (100 < -128)
      2  6c52				  -	      ECHO	"Erroneous position value", 100
      3  6c52				  -	      ERR
      4  6c52					      ENDIF
      5  6c52		       64		      .byte.b	100
      0  6c53					      EVAL8	100
      1  6c53				  -	      IF	(100 > 127) || (100 < -128)
      2  6c53				  -	      ECHO	"Erroneous position value", 100
      3  6c53				  -	      ERR
      4  6c53					      ENDIF
      5  6c53		       64		      .byte.b	100
      0  6c54					      EVAL8	0
      1  6c54				  -	      IF	(0 > 127) || (0 < -128)
      2  6c54				  -	      ECHO	"Erroneous position value", 0
      3  6c54				  -	      ERR
      4  6c54					      ENDIF
      5  6c54		       00		      .byte.b	0
      0  6c55					      EVAL8	0
      1  6c55				  -	      IF	(0 > 127) || (0 < -128)
      2  6c55				  -	      ECHO	"Erroneous position value", 0
      3  6c55				  -	      ERR
      4  6c55					      ENDIF
      5  6c55		       00		      .byte.b	0
      0  6c56					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  6c56					      EVAL8	0
      1  6c56				  -	      IF	(0 > 127) || (0 < -128)
      2  6c56				  -	      ECHO	"Erroneous position value", 0
      3  6c56				  -	      ERR
      4  6c56					      ENDIF
      5  6c56		       00		      .byte.b	0
      0  6c57					      EVAL8	0
      1  6c57				  -	      IF	(0 > 127) || (0 < -128)
      2  6c57				  -	      ECHO	"Erroneous position value", 0
      3  6c57				  -	      ERR
      4  6c57					      ENDIF
      5  6c57		       00		      .byte.b	0
      0  6c58					      EVAL8	0
      1  6c58				  -	      IF	(0 > 127) || (0 < -128)
      2  6c58				  -	      ECHO	"Erroneous position value", 0
      3  6c58				  -	      ERR
      4  6c58					      ENDIF
      5  6c58		       00		      .byte.b	0
      0  6c59					      EVAL8	0
      1  6c59				  -	      IF	(0 > 127) || (0 < -128)
      2  6c59				  -	      ECHO	"Erroneous position value", 0
      3  6c59				  -	      ERR
      4  6c59					      ENDIF
      5  6c59		       00		      .byte.b	0
      0  6c5a					      EVAL8	0
      1  6c5a				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5a				  -	      ECHO	"Erroneous position value", 0
      3  6c5a				  -	      ERR
      4  6c5a					      ENDIF
      5  6c5a		       00		      .byte.b	0
      0  6c5b					      EVAL8	0
      1  6c5b				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5b				  -	      ECHO	"Erroneous position value", 0
      3  6c5b				  -	      ERR
      4  6c5b					      ENDIF
      5  6c5b		       00		      .byte.b	0
      0  6c5c					      EVAL8	0
      1  6c5c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5c				  -	      ECHO	"Erroneous position value", 0
      3  6c5c				  -	      ERR
      4  6c5c					      ENDIF
      5  6c5c		       00		      .byte.b	0
      0  6c5d					      EVAL8	0
      1  6c5d				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5d				  -	      ECHO	"Erroneous position value", 0
      3  6c5d				  -	      ERR
      4  6c5d					      ENDIF
      5  6c5d		       00		      .byte.b	0
      0  6c5e					      EVAL8	0
      1  6c5e				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5e				  -	      ECHO	"Erroneous position value", 0
      3  6c5e				  -	      ERR
      4  6c5e					      ENDIF
      5  6c5e		       00		      .byte.b	0
      0  6c5f					      EVAL8	0
      1  6c5f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5f				  -	      ECHO	"Erroneous position value", 0
      3  6c5f				  -	      ERR
      4  6c5f					      ENDIF
      5  6c5f		       00		      .byte.b	0
     84  6c60
     85  6c60							;---------------------------------------------------------------------------------------------------
     86  6c60
     87  6c60				   PositionalValue_KNIGHT
     88  6c60
      0  6c60					      PVAL	-50, -30, -30, -30, -30, -30, -22, -50
      0  6c60					      EVAL8	-50
      1  6c60				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6c60				  -	      ECHO	"Erroneous position value", -50
      3  6c60				  -	      ERR
      4  6c60					      ENDIF
      5  6c60		       ce		      .byte.b	-50
      0  6c61					      EVAL8	-30
      1  6c61				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c61				  -	      ECHO	"Erroneous position value", -30
      3  6c61				  -	      ERR
      4  6c61					      ENDIF
      5  6c61		       e2		      .byte.b	-30
      0  6c62					      EVAL8	-30
      1  6c62				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c62				  -	      ECHO	"Erroneous position value", -30
      3  6c62				  -	      ERR
      4  6c62					      ENDIF
      5  6c62		       e2		      .byte.b	-30
      0  6c63					      EVAL8	-30
      1  6c63				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c63				  -	      ECHO	"Erroneous position value", -30
      3  6c63				  -	      ERR
      4  6c63					      ENDIF
      5  6c63		       e2		      .byte.b	-30
      0  6c64					      EVAL8	-30
      1  6c64				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c64				  -	      ECHO	"Erroneous position value", -30
      3  6c64				  -	      ERR
      4  6c64					      ENDIF
      5  6c64		       e2		      .byte.b	-30
      0  6c65					      EVAL8	-30
      1  6c65				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c65				  -	      ECHO	"Erroneous position value", -30
      3  6c65				  -	      ERR
      4  6c65					      ENDIF
      5  6c65		       e2		      .byte.b	-30
      0  6c66					      EVAL8	-22
      1  6c66				  -	      IF	(-22 > 127) || (-22 < -128)
      2  6c66				  -	      ECHO	"Erroneous position value", -22
      3  6c66				  -	      ERR
      4  6c66					      ENDIF
      5  6c66		       ea		      .byte.b	-22
      0  6c67					      EVAL8	-50
      1  6c67				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6c67				  -	      ECHO	"Erroneous position value", -50
      3  6c67				  -	      ERR
      4  6c67					      ENDIF
      5  6c67		       ce		      .byte.b	-50
      0  6c68					      EVAL8	0
      1  6c68				  -	      IF	(0 > 127) || (0 < -128)
      2  6c68				  -	      ECHO	"Erroneous position value", 0
      3  6c68				  -	      ERR
      4  6c68					      ENDIF
      5  6c68		       00		      .byte.b	0
      0  6c69					      EVAL8	0
      1  6c69				  -	      IF	(0 > 127) || (0 < -128)
      2  6c69				  -	      ECHO	"Erroneous position value", 0
      3  6c69				  -	      ERR
      4  6c69					      ENDIF
      5  6c69		       00		      .byte.b	0
      0  6c6a					      PVAL	-40, -20, 0, -5, -25, 0, -20, -40
      0  6c6a					      EVAL8	-40
      1  6c6a				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c6a				  -	      ECHO	"Erroneous position value", -40
      3  6c6a				  -	      ERR
      4  6c6a					      ENDIF
      5  6c6a		       d8		      .byte.b	-40
      0  6c6b					      EVAL8	-20
      1  6c6b				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6c6b				  -	      ECHO	"Erroneous position value", -20
      3  6c6b				  -	      ERR
      4  6c6b					      ENDIF
      5  6c6b		       ec		      .byte.b	-20
      0  6c6c					      EVAL8	0
      1  6c6c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c6c				  -	      ECHO	"Erroneous position value", 0
      3  6c6c				  -	      ERR
      4  6c6c					      ENDIF
      5  6c6c		       00		      .byte.b	0
      0  6c6d					      EVAL8	-5
      1  6c6d				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6c6d				  -	      ECHO	"Erroneous position value", -5
      3  6c6d				  -	      ERR
      4  6c6d					      ENDIF
      5  6c6d		       fb		      .byte.b	-5
      0  6c6e					      EVAL8	-25
      1  6c6e				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6c6e				  -	      ECHO	"Erroneous position value", -25
      3  6c6e				  -	      ERR
      4  6c6e					      ENDIF
      5  6c6e		       e7		      .byte.b	-25
      0  6c6f					      EVAL8	0
      1  6c6f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c6f				  -	      ECHO	"Erroneous position value", 0
      3  6c6f				  -	      ERR
      4  6c6f					      ENDIF
      5  6c6f		       00		      .byte.b	0
      0  6c70					      EVAL8	-20
      1  6c70				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6c70				  -	      ECHO	"Erroneous position value", -20
      3  6c70				  -	      ERR
      4  6c70					      ENDIF
      5  6c70		       ec		      .byte.b	-20
      0  6c71					      EVAL8	-40
      1  6c71				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c71				  -	      ECHO	"Erroneous position value", -40
      3  6c71				  -	      ERR
      4  6c71					      ENDIF
      5  6c71		       d8		      .byte.b	-40
      0  6c72					      EVAL8	0
      1  6c72				  -	      IF	(0 > 127) || (0 < -128)
      2  6c72				  -	      ECHO	"Erroneous position value", 0
      3  6c72				  -	      ERR
      4  6c72					      ENDIF
      5  6c72		       00		      .byte.b	0
      0  6c73					      EVAL8	0
      1  6c73				  -	      IF	(0 > 127) || (0 < -128)
      2  6c73				  -	      ECHO	"Erroneous position value", 0
      3  6c73				  -	      ERR
      4  6c73					      ENDIF
      5  6c73		       00		      .byte.b	0
      0  6c74					      PVAL	-30, 0, 18, 15, 15, 18, 0, -30
      0  6c74					      EVAL8	-30
      1  6c74				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c74				  -	      ECHO	"Erroneous position value", -30
      3  6c74				  -	      ERR
      4  6c74					      ENDIF
      5  6c74		       e2		      .byte.b	-30
      0  6c75					      EVAL8	0
      1  6c75				  -	      IF	(0 > 127) || (0 < -128)
      2  6c75				  -	      ECHO	"Erroneous position value", 0
      3  6c75				  -	      ERR
      4  6c75					      ENDIF
      5  6c75		       00		      .byte.b	0
      0  6c76					      EVAL8	18
      1  6c76				  -	      IF	(18 > 127) || (18 < -128)
      2  6c76				  -	      ECHO	"Erroneous position value", 18
      3  6c76				  -	      ERR
      4  6c76					      ENDIF
      5  6c76		       12		      .byte.b	18
      0  6c77					      EVAL8	15
      1  6c77				  -	      IF	(15 > 127) || (15 < -128)
      2  6c77				  -	      ECHO	"Erroneous position value", 15
      3  6c77				  -	      ERR
      4  6c77					      ENDIF
      5  6c77		       0f		      .byte.b	15
      0  6c78					      EVAL8	15
      1  6c78				  -	      IF	(15 > 127) || (15 < -128)
      2  6c78				  -	      ECHO	"Erroneous position value", 15
      3  6c78				  -	      ERR
      4  6c78					      ENDIF
      5  6c78		       0f		      .byte.b	15
      0  6c79					      EVAL8	18
      1  6c79				  -	      IF	(18 > 127) || (18 < -128)
      2  6c79				  -	      ECHO	"Erroneous position value", 18
      3  6c79				  -	      ERR
      4  6c79					      ENDIF
      5  6c79		       12		      .byte.b	18
      0  6c7a					      EVAL8	0
      1  6c7a				  -	      IF	(0 > 127) || (0 < -128)
      2  6c7a				  -	      ECHO	"Erroneous position value", 0
      3  6c7a				  -	      ERR
      4  6c7a					      ENDIF
      5  6c7a		       00		      .byte.b	0
      0  6c7b					      EVAL8	-30
      1  6c7b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c7b				  -	      ECHO	"Erroneous position value", -30
      3  6c7b				  -	      ERR
      4  6c7b					      ENDIF
      5  6c7b		       e2		      .byte.b	-30
      0  6c7c					      EVAL8	0
      1  6c7c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c7c				  -	      ECHO	"Erroneous position value", 0
      3  6c7c				  -	      ERR
      4  6c7c					      ENDIF
      5  6c7c		       00		      .byte.b	0
      0  6c7d					      EVAL8	0
      1  6c7d				  -	      IF	(0 > 127) || (0 < -128)
      2  6c7d				  -	      ECHO	"Erroneous position value", 0
      3  6c7d				  -	      ERR
      4  6c7d					      ENDIF
      5  6c7d		       00		      .byte.b	0
      0  6c7e					      PVAL	-40, 0, 15, 30, 30, 15, 0, -40
      0  6c7e					      EVAL8	-40
      1  6c7e				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c7e				  -	      ECHO	"Erroneous position value", -40
      3  6c7e				  -	      ERR
      4  6c7e					      ENDIF
      5  6c7e		       d8		      .byte.b	-40
      0  6c7f					      EVAL8	0
      1  6c7f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c7f				  -	      ECHO	"Erroneous position value", 0
      3  6c7f				  -	      ERR
      4  6c7f					      ENDIF
      5  6c7f		       00		      .byte.b	0
      0  6c80					      EVAL8	15
      1  6c80				  -	      IF	(15 > 127) || (15 < -128)
      2  6c80				  -	      ECHO	"Erroneous position value", 15
      3  6c80				  -	      ERR
      4  6c80					      ENDIF
      5  6c80		       0f		      .byte.b	15
      0  6c81					      EVAL8	30
      1  6c81				  -	      IF	(30 > 127) || (30 < -128)
      2  6c81				  -	      ECHO	"Erroneous position value", 30
      3  6c81				  -	      ERR
      4  6c81					      ENDIF
      5  6c81		       1e		      .byte.b	30
      0  6c82					      EVAL8	30
      1  6c82				  -	      IF	(30 > 127) || (30 < -128)
      2  6c82				  -	      ECHO	"Erroneous position value", 30
      3  6c82				  -	      ERR
      4  6c82					      ENDIF
      5  6c82		       1e		      .byte.b	30
      0  6c83					      EVAL8	15
      1  6c83				  -	      IF	(15 > 127) || (15 < -128)
      2  6c83				  -	      ECHO	"Erroneous position value", 15
      3  6c83				  -	      ERR
      4  6c83					      ENDIF
      5  6c83		       0f		      .byte.b	15
      0  6c84					      EVAL8	0
      1  6c84				  -	      IF	(0 > 127) || (0 < -128)
      2  6c84				  -	      ECHO	"Erroneous position value", 0
      3  6c84				  -	      ERR
      4  6c84					      ENDIF
      5  6c84		       00		      .byte.b	0
      0  6c85					      EVAL8	-40
      1  6c85				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c85				  -	      ECHO	"Erroneous position value", -40
      3  6c85				  -	      ERR
      4  6c85					      ENDIF
      5  6c85		       d8		      .byte.b	-40
      0  6c86					      EVAL8	0
      1  6c86				  -	      IF	(0 > 127) || (0 < -128)
      2  6c86				  -	      ECHO	"Erroneous position value", 0
      3  6c86				  -	      ERR
      4  6c86					      ENDIF
      5  6c86		       00		      .byte.b	0
      0  6c87					      EVAL8	0
      1  6c87				  -	      IF	(0 > 127) || (0 < -128)
      2  6c87				  -	      ECHO	"Erroneous position value", 0
      3  6c87				  -	      ERR
      4  6c87					      ENDIF
      5  6c87		       00		      .byte.b	0
      0  6c88					      PVAL	-40, 5, 15, 30, 30, 15, 5, -40
      0  6c88					      EVAL8	-40
      1  6c88				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c88				  -	      ECHO	"Erroneous position value", -40
      3  6c88				  -	      ERR
      4  6c88					      ENDIF
      5  6c88		       d8		      .byte.b	-40
      0  6c89					      EVAL8	5
      1  6c89				  -	      IF	(5 > 127) || (5 < -128)
      2  6c89				  -	      ECHO	"Erroneous position value", 5
      3  6c89				  -	      ERR
      4  6c89					      ENDIF
      5  6c89		       05		      .byte.b	5
      0  6c8a					      EVAL8	15
      1  6c8a				  -	      IF	(15 > 127) || (15 < -128)
      2  6c8a				  -	      ECHO	"Erroneous position value", 15
      3  6c8a				  -	      ERR
      4  6c8a					      ENDIF
      5  6c8a		       0f		      .byte.b	15
      0  6c8b					      EVAL8	30
      1  6c8b				  -	      IF	(30 > 127) || (30 < -128)
      2  6c8b				  -	      ECHO	"Erroneous position value", 30
      3  6c8b				  -	      ERR
      4  6c8b					      ENDIF
      5  6c8b		       1e		      .byte.b	30
      0  6c8c					      EVAL8	30
      1  6c8c				  -	      IF	(30 > 127) || (30 < -128)
      2  6c8c				  -	      ECHO	"Erroneous position value", 30
      3  6c8c				  -	      ERR
      4  6c8c					      ENDIF
      5  6c8c		       1e		      .byte.b	30
      0  6c8d					      EVAL8	15
      1  6c8d				  -	      IF	(15 > 127) || (15 < -128)
      2  6c8d				  -	      ECHO	"Erroneous position value", 15
      3  6c8d				  -	      ERR
      4  6c8d					      ENDIF
      5  6c8d		       0f		      .byte.b	15
      0  6c8e					      EVAL8	5
      1  6c8e				  -	      IF	(5 > 127) || (5 < -128)
      2  6c8e				  -	      ECHO	"Erroneous position value", 5
      3  6c8e				  -	      ERR
      4  6c8e					      ENDIF
      5  6c8e		       05		      .byte.b	5
      0  6c8f					      EVAL8	-40
      1  6c8f				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c8f				  -	      ECHO	"Erroneous position value", -40
      3  6c8f				  -	      ERR
      4  6c8f					      ENDIF
      5  6c8f		       d8		      .byte.b	-40
      0  6c90					      EVAL8	0
      1  6c90				  -	      IF	(0 > 127) || (0 < -128)
      2  6c90				  -	      ECHO	"Erroneous position value", 0
      3  6c90				  -	      ERR
      4  6c90					      ENDIF
      5  6c90		       00		      .byte.b	0
      0  6c91					      EVAL8	0
      1  6c91				  -	      IF	(0 > 127) || (0 < -128)
      2  6c91				  -	      ECHO	"Erroneous position value", 0
      3  6c91				  -	      ERR
      4  6c91					      ENDIF
      5  6c91		       00		      .byte.b	0
      0  6c92					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      0  6c92					      EVAL8	-30
      1  6c92				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c92				  -	      ECHO	"Erroneous position value", -30
      3  6c92				  -	      ERR
      4  6c92					      ENDIF
      5  6c92		       e2		      .byte.b	-30
      0  6c93					      EVAL8	0
      1  6c93				  -	      IF	(0 > 127) || (0 < -128)
      2  6c93				  -	      ECHO	"Erroneous position value", 0
      3  6c93				  -	      ERR
      4  6c93					      ENDIF
      5  6c93		       00		      .byte.b	0
      0  6c94					      EVAL8	10
      1  6c94				  -	      IF	(10 > 127) || (10 < -128)
      2  6c94				  -	      ECHO	"Erroneous position value", 10
      3  6c94				  -	      ERR
      4  6c94					      ENDIF
      5  6c94		       0a		      .byte.b	10
      0  6c95					      EVAL8	15
      1  6c95				  -	      IF	(15 > 127) || (15 < -128)
      2  6c95				  -	      ECHO	"Erroneous position value", 15
      3  6c95				  -	      ERR
      4  6c95					      ENDIF
      5  6c95		       0f		      .byte.b	15
      0  6c96					      EVAL8	15
      1  6c96				  -	      IF	(15 > 127) || (15 < -128)
      2  6c96				  -	      ECHO	"Erroneous position value", 15
      3  6c96				  -	      ERR
      4  6c96					      ENDIF
      5  6c96		       0f		      .byte.b	15
      0  6c97					      EVAL8	10
      1  6c97				  -	      IF	(10 > 127) || (10 < -128)
      2  6c97				  -	      ECHO	"Erroneous position value", 10
      3  6c97				  -	      ERR
      4  6c97					      ENDIF
      5  6c97		       0a		      .byte.b	10
      0  6c98					      EVAL8	0
      1  6c98				  -	      IF	(0 > 127) || (0 < -128)
      2  6c98				  -	      ECHO	"Erroneous position value", 0
      3  6c98				  -	      ERR
      4  6c98					      ENDIF
      5  6c98		       00		      .byte.b	0
      0  6c99					      EVAL8	-30
      1  6c99				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c99				  -	      ECHO	"Erroneous position value", -30
      3  6c99				  -	      ERR
      4  6c99					      ENDIF
      5  6c99		       e2		      .byte.b	-30
      0  6c9a					      EVAL8	0
      1  6c9a				  -	      IF	(0 > 127) || (0 < -128)
      2  6c9a				  -	      ECHO	"Erroneous position value", 0
      3  6c9a				  -	      ERR
      4  6c9a					      ENDIF
      5  6c9a		       00		      .byte.b	0
      0  6c9b					      EVAL8	0
      1  6c9b				  -	      IF	(0 > 127) || (0 < -128)
      2  6c9b				  -	      ECHO	"Erroneous position value", 0
      3  6c9b				  -	      ERR
      4  6c9b					      ENDIF
      5  6c9b		       00		      .byte.b	0
      0  6c9c					      PVAL	-40, -20, 30, 0, 0, 80, -20, -40
      0  6c9c					      EVAL8	-40
      1  6c9c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c9c				  -	      ECHO	"Erroneous position value", -40
      3  6c9c				  -	      ERR
      4  6c9c					      ENDIF
      5  6c9c		       d8		      .byte.b	-40
      0  6c9d					      EVAL8	-20
      1  6c9d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6c9d				  -	      ECHO	"Erroneous position value", -20
      3  6c9d				  -	      ERR
      4  6c9d					      ENDIF
      5  6c9d		       ec		      .byte.b	-20
      0  6c9e					      EVAL8	30
      1  6c9e				  -	      IF	(30 > 127) || (30 < -128)
      2  6c9e				  -	      ECHO	"Erroneous position value", 30
      3  6c9e				  -	      ERR
      4  6c9e					      ENDIF
      5  6c9e		       1e		      .byte.b	30
      0  6c9f					      EVAL8	0
      1  6c9f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c9f				  -	      ECHO	"Erroneous position value", 0
      3  6c9f				  -	      ERR
      4  6c9f					      ENDIF
      5  6c9f		       00		      .byte.b	0
      0  6ca0					      EVAL8	0
      1  6ca0				  -	      IF	(0 > 127) || (0 < -128)
      2  6ca0				  -	      ECHO	"Erroneous position value", 0
      3  6ca0				  -	      ERR
      4  6ca0					      ENDIF
      5  6ca0		       00		      .byte.b	0
      0  6ca1					      EVAL8	80
      1  6ca1				  -	      IF	(80 > 127) || (80 < -128)
      2  6ca1				  -	      ECHO	"Erroneous position value", 80
      3  6ca1				  -	      ERR
      4  6ca1					      ENDIF
      5  6ca1		       50		      .byte.b	80
      0  6ca2					      EVAL8	-20
      1  6ca2				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6ca2				  -	      ECHO	"Erroneous position value", -20
      3  6ca2				  -	      ERR
      4  6ca2					      ENDIF
      5  6ca2		       ec		      .byte.b	-20
      0  6ca3					      EVAL8	-40
      1  6ca3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6ca3				  -	      ECHO	"Erroneous position value", -40
      3  6ca3				  -	      ERR
      4  6ca3					      ENDIF
      5  6ca3		       d8		      .byte.b	-40
      0  6ca4					      EVAL8	0
      1  6ca4				  -	      IF	(0 > 127) || (0 < -128)
      2  6ca4				  -	      ECHO	"Erroneous position value", 0
      3  6ca4				  -	      ERR
      4  6ca4					      ENDIF
      5  6ca4		       00		      .byte.b	0
      0  6ca5					      EVAL8	0
      1  6ca5				  -	      IF	(0 > 127) || (0 < -128)
      2  6ca5				  -	      ECHO	"Erroneous position value", 0
      3  6ca5				  -	      ERR
      4  6ca5					      ENDIF
      5  6ca5		       00		      .byte.b	0
      0  6ca6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      0  6ca6					      EVAL8	-50
      1  6ca6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6ca6				  -	      ECHO	"Erroneous position value", -50
      3  6ca6				  -	      ERR
      4  6ca6					      ENDIF
      5  6ca6		       ce		      .byte.b	-50
      0  6ca7					      EVAL8	-20
      1  6ca7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6ca7				  -	      ECHO	"Erroneous position value", -20
      3  6ca7				  -	      ERR
      4  6ca7					      ENDIF
      5  6ca7		       ec		      .byte.b	-20
      0  6ca8					      EVAL8	-30
      1  6ca8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6ca8				  -	      ECHO	"Erroneous position value", -30
      3  6ca8				  -	      ERR
      4  6ca8					      ENDIF
      5  6ca8		       e2		      .byte.b	-30
      0  6ca9					      EVAL8	-30
      1  6ca9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6ca9				  -	      ECHO	"Erroneous position value", -30
      3  6ca9				  -	      ERR
      4  6ca9					      ENDIF
      5  6ca9		       e2		      .byte.b	-30
      0  6caa					      EVAL8	-30
      1  6caa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6caa				  -	      ECHO	"Erroneous position value", -30
      3  6caa				  -	      ERR
      4  6caa					      ENDIF
      5  6caa		       e2		      .byte.b	-30
      0  6cab					      EVAL8	-30
      1  6cab				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6cab				  -	      ECHO	"Erroneous position value", -30
      3  6cab				  -	      ERR
      4  6cab					      ENDIF
      5  6cab		       e2		      .byte.b	-30
      0  6cac					      EVAL8	-20
      1  6cac				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cac				  -	      ECHO	"Erroneous position value", -20
      3  6cac				  -	      ERR
      4  6cac					      ENDIF
      5  6cac		       ec		      .byte.b	-20
      0  6cad					      EVAL8	-50
      1  6cad				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6cad				  -	      ECHO	"Erroneous position value", -50
      3  6cad				  -	      ERR
      4  6cad					      ENDIF
      5  6cad		       ce		      .byte.b	-50
      0  6cae					      EVAL8	0
      1  6cae				  -	      IF	(0 > 127) || (0 < -128)
      2  6cae				  -	      ECHO	"Erroneous position value", 0
      3  6cae				  -	      ERR
      4  6cae					      ENDIF
      5  6cae		       00		      .byte.b	0
      0  6caf					      EVAL8	0
      1  6caf				  -	      IF	(0 > 127) || (0 < -128)
      2  6caf				  -	      ECHO	"Erroneous position value", 0
      3  6caf				  -	      ERR
      4  6caf					      ENDIF
      5  6caf		       00		      .byte.b	0
     97  6cb0
     98  6cb0
     99  6cb0							;---------------------------------------------------------------------------------------------------
    100  6cb0
    101  6cb0				   PositionalValue_BISHOP
    102  6cb0
      0  6cb0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      0  6cb0					      EVAL8	-20
      1  6cb0				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cb0				  -	      ECHO	"Erroneous position value", -20
      3  6cb0				  -	      ERR
      4  6cb0					      ENDIF
      5  6cb0		       ec		      .byte.b	-20
      0  6cb1					      EVAL8	-10
      1  6cb1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cb1				  -	      ECHO	"Erroneous position value", -10
      3  6cb1				  -	      ERR
      4  6cb1					      ENDIF
      5  6cb1		       f6		      .byte.b	-10
      0  6cb2					      EVAL8	-50
      1  6cb2				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6cb2				  -	      ECHO	"Erroneous position value", -50
      3  6cb2				  -	      ERR
      4  6cb2					      ENDIF
      5  6cb2		       ce		      .byte.b	-50
      0  6cb3					      EVAL8	-10
      1  6cb3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cb3				  -	      ECHO	"Erroneous position value", -10
      3  6cb3				  -	      ERR
      4  6cb3					      ENDIF
      5  6cb3		       f6		      .byte.b	-10
      0  6cb4					      EVAL8	-10
      1  6cb4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cb4				  -	      ECHO	"Erroneous position value", -10
      3  6cb4				  -	      ERR
      4  6cb4					      ENDIF
      5  6cb4		       f6		      .byte.b	-10
      0  6cb5					      EVAL8	-50
      1  6cb5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6cb5				  -	      ECHO	"Erroneous position value", -50
      3  6cb5				  -	      ERR
      4  6cb5					      ENDIF
      5  6cb5		       ce		      .byte.b	-50
      0  6cb6					      EVAL8	-10
      1  6cb6				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cb6				  -	      ECHO	"Erroneous position value", -10
      3  6cb6				  -	      ERR
      4  6cb6					      ENDIF
      5  6cb6		       f6		      .byte.b	-10
      0  6cb7					      EVAL8	-20
      1  6cb7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cb7				  -	      ECHO	"Erroneous position value", -20
      3  6cb7				  -	      ERR
      4  6cb7					      ENDIF
      5  6cb7		       ec		      .byte.b	-20
      0  6cb8					      EVAL8	0
      1  6cb8				  -	      IF	(0 > 127) || (0 < -128)
      2  6cb8				  -	      ECHO	"Erroneous position value", 0
      3  6cb8				  -	      ERR
      4  6cb8					      ENDIF
      5  6cb8		       00		      .byte.b	0
      0  6cb9					      EVAL8	0
      1  6cb9				  -	      IF	(0 > 127) || (0 < -128)
      2  6cb9				  -	      ECHO	"Erroneous position value", 0
      3  6cb9				  -	      ERR
      4  6cb9					      ENDIF
      5  6cb9		       00		      .byte.b	0
      0  6cba					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      0  6cba					      EVAL8	-10
      1  6cba				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cba				  -	      ECHO	"Erroneous position value", -10
      3  6cba				  -	      ERR
      4  6cba					      ENDIF
      5  6cba		       f6		      .byte.b	-10
      0  6cbb					      EVAL8	5
      1  6cbb				  -	      IF	(5 > 127) || (5 < -128)
      2  6cbb				  -	      ECHO	"Erroneous position value", 5
      3  6cbb				  -	      ERR
      4  6cbb					      ENDIF
      5  6cbb		       05		      .byte.b	5
      0  6cbc					      EVAL8	0
      1  6cbc				  -	      IF	(0 > 127) || (0 < -128)
      2  6cbc				  -	      ECHO	"Erroneous position value", 0
      3  6cbc				  -	      ERR
      4  6cbc					      ENDIF
      5  6cbc		       00		      .byte.b	0
      0  6cbd					      EVAL8	0
      1  6cbd				  -	      IF	(0 > 127) || (0 < -128)
      2  6cbd				  -	      ECHO	"Erroneous position value", 0
      3  6cbd				  -	      ERR
      4  6cbd					      ENDIF
      5  6cbd		       00		      .byte.b	0
      0  6cbe					      EVAL8	0
      1  6cbe				  -	      IF	(0 > 127) || (0 < -128)
      2  6cbe				  -	      ECHO	"Erroneous position value", 0
      3  6cbe				  -	      ERR
      4  6cbe					      ENDIF
      5  6cbe		       00		      .byte.b	0
      0  6cbf					      EVAL8	0
      1  6cbf				  -	      IF	(0 > 127) || (0 < -128)
      2  6cbf				  -	      ECHO	"Erroneous position value", 0
      3  6cbf				  -	      ERR
      4  6cbf					      ENDIF
      5  6cbf		       00		      .byte.b	0
      0  6cc0					      EVAL8	5
      1  6cc0				  -	      IF	(5 > 127) || (5 < -128)
      2  6cc0				  -	      ECHO	"Erroneous position value", 5
      3  6cc0				  -	      ERR
      4  6cc0					      ENDIF
      5  6cc0		       05		      .byte.b	5
      0  6cc1					      EVAL8	-10
      1  6cc1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cc1				  -	      ECHO	"Erroneous position value", -10
      3  6cc1				  -	      ERR
      4  6cc1					      ENDIF
      5  6cc1		       f6		      .byte.b	-10
      0  6cc2					      EVAL8	0
      1  6cc2				  -	      IF	(0 > 127) || (0 < -128)
      2  6cc2				  -	      ECHO	"Erroneous position value", 0
      3  6cc2				  -	      ERR
      4  6cc2					      ENDIF
      5  6cc2		       00		      .byte.b	0
      0  6cc3					      EVAL8	0
      1  6cc3				  -	      IF	(0 > 127) || (0 < -128)
      2  6cc3				  -	      ECHO	"Erroneous position value", 0
      3  6cc3				  -	      ERR
      4  6cc3					      ENDIF
      5  6cc3		       00		      .byte.b	0
      0  6cc4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      0  6cc4					      EVAL8	-10
      1  6cc4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cc4				  -	      ECHO	"Erroneous position value", -10
      3  6cc4				  -	      ERR
      4  6cc4					      ENDIF
      5  6cc4		       f6		      .byte.b	-10
      0  6cc5					      EVAL8	10
      1  6cc5				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc5				  -	      ECHO	"Erroneous position value", 10
      3  6cc5				  -	      ERR
      4  6cc5					      ENDIF
      5  6cc5		       0a		      .byte.b	10
      0  6cc6					      EVAL8	10
      1  6cc6				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc6				  -	      ECHO	"Erroneous position value", 10
      3  6cc6				  -	      ERR
      4  6cc6					      ENDIF
      5  6cc6		       0a		      .byte.b	10
      0  6cc7					      EVAL8	10
      1  6cc7				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc7				  -	      ECHO	"Erroneous position value", 10
      3  6cc7				  -	      ERR
      4  6cc7					      ENDIF
      5  6cc7		       0a		      .byte.b	10
      0  6cc8					      EVAL8	10
      1  6cc8				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc8				  -	      ECHO	"Erroneous position value", 10
      3  6cc8				  -	      ERR
      4  6cc8					      ENDIF
      5  6cc8		       0a		      .byte.b	10
      0  6cc9					      EVAL8	10
      1  6cc9				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc9				  -	      ECHO	"Erroneous position value", 10
      3  6cc9				  -	      ERR
      4  6cc9					      ENDIF
      5  6cc9		       0a		      .byte.b	10
      0  6cca					      EVAL8	10
      1  6cca				  -	      IF	(10 > 127) || (10 < -128)
      2  6cca				  -	      ECHO	"Erroneous position value", 10
      3  6cca				  -	      ERR
      4  6cca					      ENDIF
      5  6cca		       0a		      .byte.b	10
      0  6ccb					      EVAL8	-10
      1  6ccb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6ccb				  -	      ECHO	"Erroneous position value", -10
      3  6ccb				  -	      ERR
      4  6ccb					      ENDIF
      5  6ccb		       f6		      .byte.b	-10
      0  6ccc					      EVAL8	0
      1  6ccc				  -	      IF	(0 > 127) || (0 < -128)
      2  6ccc				  -	      ECHO	"Erroneous position value", 0
      3  6ccc				  -	      ERR
      4  6ccc					      ENDIF
      5  6ccc		       00		      .byte.b	0
      0  6ccd					      EVAL8	0
      1  6ccd				  -	      IF	(0 > 127) || (0 < -128)
      2  6ccd				  -	      ECHO	"Erroneous position value", 0
      3  6ccd				  -	      ERR
      4  6ccd					      ENDIF
      5  6ccd		       00		      .byte.b	0
      0  6cce					      PVAL	-10, 0, 60, 20, 20, 10, 0, -10
      0  6cce					      EVAL8	-10
      1  6cce				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cce				  -	      ECHO	"Erroneous position value", -10
      3  6cce				  -	      ERR
      4  6cce					      ENDIF
      5  6cce		       f6		      .byte.b	-10
      0  6ccf					      EVAL8	0
      1  6ccf				  -	      IF	(0 > 127) || (0 < -128)
      2  6ccf				  -	      ECHO	"Erroneous position value", 0
      3  6ccf				  -	      ERR
      4  6ccf					      ENDIF
      5  6ccf		       00		      .byte.b	0
      0  6cd0					      EVAL8	60
      1  6cd0				  -	      IF	(60 > 127) || (60 < -128)
      2  6cd0				  -	      ECHO	"Erroneous position value", 60
      3  6cd0				  -	      ERR
      4  6cd0					      ENDIF
      5  6cd0		       3c		      .byte.b	60
      0  6cd1					      EVAL8	20
      1  6cd1				  -	      IF	(20 > 127) || (20 < -128)
      2  6cd1				  -	      ECHO	"Erroneous position value", 20
      3  6cd1				  -	      ERR
      4  6cd1					      ENDIF
      5  6cd1		       14		      .byte.b	20
      0  6cd2					      EVAL8	20
      1  6cd2				  -	      IF	(20 > 127) || (20 < -128)
      2  6cd2				  -	      ECHO	"Erroneous position value", 20
      3  6cd2				  -	      ERR
      4  6cd2					      ENDIF
      5  6cd2		       14		      .byte.b	20
      0  6cd3					      EVAL8	10
      1  6cd3				  -	      IF	(10 > 127) || (10 < -128)
      2  6cd3				  -	      ECHO	"Erroneous position value", 10
      3  6cd3				  -	      ERR
      4  6cd3					      ENDIF
      5  6cd3		       0a		      .byte.b	10
      0  6cd4					      EVAL8	0
      1  6cd4				  -	      IF	(0 > 127) || (0 < -128)
      2  6cd4				  -	      ECHO	"Erroneous position value", 0
      3  6cd4				  -	      ERR
      4  6cd4					      ENDIF
      5  6cd4		       00		      .byte.b	0
      0  6cd5					      EVAL8	-10
      1  6cd5				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cd5				  -	      ECHO	"Erroneous position value", -10
      3  6cd5				  -	      ERR
      4  6cd5					      ENDIF
      5  6cd5		       f6		      .byte.b	-10
      0  6cd6					      EVAL8	0
      1  6cd6				  -	      IF	(0 > 127) || (0 < -128)
      2  6cd6				  -	      ECHO	"Erroneous position value", 0
      3  6cd6				  -	      ERR
      4  6cd6					      ENDIF
      5  6cd6		       00		      .byte.b	0
      0  6cd7					      EVAL8	0
      1  6cd7				  -	      IF	(0 > 127) || (0 < -128)
      2  6cd7				  -	      ECHO	"Erroneous position value", 0
      3  6cd7				  -	      ERR
      4  6cd7					      ENDIF
      5  6cd7		       00		      .byte.b	0
      0  6cd8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      0  6cd8					      EVAL8	-10
      1  6cd8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cd8				  -	      ECHO	"Erroneous position value", -10
      3  6cd8				  -	      ERR
      4  6cd8					      ENDIF
      5  6cd8		       f6		      .byte.b	-10
      0  6cd9					      EVAL8	5
      1  6cd9				  -	      IF	(5 > 127) || (5 < -128)
      2  6cd9				  -	      ECHO	"Erroneous position value", 5
      3  6cd9				  -	      ERR
      4  6cd9					      ENDIF
      5  6cd9		       05		      .byte.b	5
      0  6cda					      EVAL8	5
      1  6cda				  -	      IF	(5 > 127) || (5 < -128)
      2  6cda				  -	      ECHO	"Erroneous position value", 5
      3  6cda				  -	      ERR
      4  6cda					      ENDIF
      5  6cda		       05		      .byte.b	5
      0  6cdb					      EVAL8	20
      1  6cdb				  -	      IF	(20 > 127) || (20 < -128)
      2  6cdb				  -	      ECHO	"Erroneous position value", 20
      3  6cdb				  -	      ERR
      4  6cdb					      ENDIF
      5  6cdb		       14		      .byte.b	20
      0  6cdc					      EVAL8	20
      1  6cdc				  -	      IF	(20 > 127) || (20 < -128)
      2  6cdc				  -	      ECHO	"Erroneous position value", 20
      3  6cdc				  -	      ERR
      4  6cdc					      ENDIF
      5  6cdc		       14		      .byte.b	20
      0  6cdd					      EVAL8	5
      1  6cdd				  -	      IF	(5 > 127) || (5 < -128)
      2  6cdd				  -	      ECHO	"Erroneous position value", 5
      3  6cdd				  -	      ERR
      4  6cdd					      ENDIF
      5  6cdd		       05		      .byte.b	5
      0  6cde					      EVAL8	5
      1  6cde				  -	      IF	(5 > 127) || (5 < -128)
      2  6cde				  -	      ECHO	"Erroneous position value", 5
      3  6cde				  -	      ERR
      4  6cde					      ENDIF
      5  6cde		       05		      .byte.b	5
      0  6cdf					      EVAL8	-10
      1  6cdf				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cdf				  -	      ECHO	"Erroneous position value", -10
      3  6cdf				  -	      ERR
      4  6cdf					      ENDIF
      5  6cdf		       f6		      .byte.b	-10
      0  6ce0					      EVAL8	0
      1  6ce0				  -	      IF	(0 > 127) || (0 < -128)
      2  6ce0				  -	      ECHO	"Erroneous position value", 0
      3  6ce0				  -	      ERR
      4  6ce0					      ENDIF
      5  6ce0		       00		      .byte.b	0
      0  6ce1					      EVAL8	0
      1  6ce1				  -	      IF	(0 > 127) || (0 < -128)
      2  6ce1				  -	      ECHO	"Erroneous position value", 0
      3  6ce1				  -	      ERR
      4  6ce1					      ENDIF
      5  6ce1		       00		      .byte.b	0
      0  6ce2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      0  6ce2					      EVAL8	-10
      1  6ce2				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6ce2				  -	      ECHO	"Erroneous position value", -10
      3  6ce2				  -	      ERR
      4  6ce2					      ENDIF
      5  6ce2		       f6		      .byte.b	-10
      0  6ce3					      EVAL8	0
      1  6ce3				  -	      IF	(0 > 127) || (0 < -128)
      2  6ce3				  -	      ECHO	"Erroneous position value", 0
      3  6ce3				  -	      ERR
      4  6ce3					      ENDIF
      5  6ce3		       00		      .byte.b	0
      0  6ce4					      EVAL8	5
      1  6ce4				  -	      IF	(5 > 127) || (5 < -128)
      2  6ce4				  -	      ECHO	"Erroneous position value", 5
      3  6ce4				  -	      ERR
      4  6ce4					      ENDIF
      5  6ce4		       05		      .byte.b	5
      0  6ce5					      EVAL8	10
      1  6ce5				  -	      IF	(10 > 127) || (10 < -128)
      2  6ce5				  -	      ECHO	"Erroneous position value", 10
      3  6ce5				  -	      ERR
      4  6ce5					      ENDIF
      5  6ce5		       0a		      .byte.b	10
      0  6ce6					      EVAL8	10
      1  6ce6				  -	      IF	(10 > 127) || (10 < -128)
      2  6ce6				  -	      ECHO	"Erroneous position value", 10
      3  6ce6				  -	      ERR
      4  6ce6					      ENDIF
      5  6ce6		       0a		      .byte.b	10
      0  6ce7					      EVAL8	5
      1  6ce7				  -	      IF	(5 > 127) || (5 < -128)
      2  6ce7				  -	      ECHO	"Erroneous position value", 5
      3  6ce7				  -	      ERR
      4  6ce7					      ENDIF
      5  6ce7		       05		      .byte.b	5
      0  6ce8					      EVAL8	0
      1  6ce8				  -	      IF	(0 > 127) || (0 < -128)
      2  6ce8				  -	      ECHO	"Erroneous position value", 0
      3  6ce8				  -	      ERR
      4  6ce8					      ENDIF
      5  6ce8		       00		      .byte.b	0
      0  6ce9					      EVAL8	-10
      1  6ce9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6ce9				  -	      ECHO	"Erroneous position value", -10
      3  6ce9				  -	      ERR
      4  6ce9					      ENDIF
      5  6ce9		       f6		      .byte.b	-10
      0  6cea					      EVAL8	0
      1  6cea				  -	      IF	(0 > 127) || (0 < -128)
      2  6cea				  -	      ECHO	"Erroneous position value", 0
      3  6cea				  -	      ERR
      4  6cea					      ENDIF
      5  6cea		       00		      .byte.b	0
      0  6ceb					      EVAL8	0
      1  6ceb				  -	      IF	(0 > 127) || (0 < -128)
      2  6ceb				  -	      ECHO	"Erroneous position value", 0
      3  6ceb				  -	      ERR
      4  6ceb					      ENDIF
      5  6ceb		       00		      .byte.b	0
      0  6cec					      PVAL	-10, 0, 0, 0, 0, 80, 0, -10
      0  6cec					      EVAL8	-10
      1  6cec				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cec				  -	      ECHO	"Erroneous position value", -10
      3  6cec				  -	      ERR
      4  6cec					      ENDIF
      5  6cec		       f6		      .byte.b	-10
      0  6ced					      EVAL8	0
      1  6ced				  -	      IF	(0 > 127) || (0 < -128)
      2  6ced				  -	      ECHO	"Erroneous position value", 0
      3  6ced				  -	      ERR
      4  6ced					      ENDIF
      5  6ced		       00		      .byte.b	0
      0  6cee					      EVAL8	0
      1  6cee				  -	      IF	(0 > 127) || (0 < -128)
      2  6cee				  -	      ECHO	"Erroneous position value", 0
      3  6cee				  -	      ERR
      4  6cee					      ENDIF
      5  6cee		       00		      .byte.b	0
      0  6cef					      EVAL8	0
      1  6cef				  -	      IF	(0 > 127) || (0 < -128)
      2  6cef				  -	      ECHO	"Erroneous position value", 0
      3  6cef				  -	      ERR
      4  6cef					      ENDIF
      5  6cef		       00		      .byte.b	0
      0  6cf0					      EVAL8	0
      1  6cf0				  -	      IF	(0 > 127) || (0 < -128)
      2  6cf0				  -	      ECHO	"Erroneous position value", 0
      3  6cf0				  -	      ERR
      4  6cf0					      ENDIF
      5  6cf0		       00		      .byte.b	0
      0  6cf1					      EVAL8	80
      1  6cf1				  -	      IF	(80 > 127) || (80 < -128)
      2  6cf1				  -	      ECHO	"Erroneous position value", 80
      3  6cf1				  -	      ERR
      4  6cf1					      ENDIF
      5  6cf1		       50		      .byte.b	80
      0  6cf2					      EVAL8	0
      1  6cf2				  -	      IF	(0 > 127) || (0 < -128)
      2  6cf2				  -	      ECHO	"Erroneous position value", 0
      3  6cf2				  -	      ERR
      4  6cf2					      ENDIF
      5  6cf2		       00		      .byte.b	0
      0  6cf3					      EVAL8	-10
      1  6cf3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cf3				  -	      ECHO	"Erroneous position value", -10
      3  6cf3				  -	      ERR
      4  6cf3					      ENDIF
      5  6cf3		       f6		      .byte.b	-10
      0  6cf4					      EVAL8	0
      1  6cf4				  -	      IF	(0 > 127) || (0 < -128)
      2  6cf4				  -	      ECHO	"Erroneous position value", 0
      3  6cf4				  -	      ERR
      4  6cf4					      ENDIF
      5  6cf4		       00		      .byte.b	0
      0  6cf5					      EVAL8	0
      1  6cf5				  -	      IF	(0 > 127) || (0 < -128)
      2  6cf5				  -	      ECHO	"Erroneous position value", 0
      3  6cf5				  -	      ERR
      4  6cf5					      ENDIF
      5  6cf5		       00		      .byte.b	0
      0  6cf6					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      0  6cf6					      EVAL8	-20
      1  6cf6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cf6				  -	      ECHO	"Erroneous position value", -20
      3  6cf6				  -	      ERR
      4  6cf6					      ENDIF
      5  6cf6		       ec		      .byte.b	-20
      0  6cf7					      EVAL8	-10
      1  6cf7				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cf7				  -	      ECHO	"Erroneous position value", -10
      3  6cf7				  -	      ERR
      4  6cf7					      ENDIF
      5  6cf7		       f6		      .byte.b	-10
      0  6cf8					      EVAL8	-10
      1  6cf8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cf8				  -	      ECHO	"Erroneous position value", -10
      3  6cf8				  -	      ERR
      4  6cf8					      ENDIF
      5  6cf8		       f6		      .byte.b	-10
      0  6cf9					      EVAL8	-10
      1  6cf9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cf9				  -	      ECHO	"Erroneous position value", -10
      3  6cf9				  -	      ERR
      4  6cf9					      ENDIF
      5  6cf9		       f6		      .byte.b	-10
      0  6cfa					      EVAL8	-10
      1  6cfa				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cfa				  -	      ECHO	"Erroneous position value", -10
      3  6cfa				  -	      ERR
      4  6cfa					      ENDIF
      5  6cfa		       f6		      .byte.b	-10
      0  6cfb					      EVAL8	-10
      1  6cfb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cfb				  -	      ECHO	"Erroneous position value", -10
      3  6cfb				  -	      ERR
      4  6cfb					      ENDIF
      5  6cfb		       f6		      .byte.b	-10
      0  6cfc					      EVAL8	-10
      1  6cfc				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cfc				  -	      ECHO	"Erroneous position value", -10
      3  6cfc				  -	      ERR
      4  6cfc					      ENDIF
      5  6cfc		       f6		      .byte.b	-10
      0  6cfd					      EVAL8	-20
      1  6cfd				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cfd				  -	      ECHO	"Erroneous position value", -20
      3  6cfd				  -	      ERR
      4  6cfd					      ENDIF
      5  6cfd		       ec		      .byte.b	-20
      0  6cfe					      EVAL8	0
      1  6cfe				  -	      IF	(0 > 127) || (0 < -128)
      2  6cfe				  -	      ECHO	"Erroneous position value", 0
      3  6cfe				  -	      ERR
      4  6cfe					      ENDIF
      5  6cfe		       00		      .byte.b	0
      0  6cff					      EVAL8	0
      1  6cff				  -	      IF	(0 > 127) || (0 < -128)
      2  6cff				  -	      ECHO	"Erroneous position value", 0
      3  6cff				  -	      ERR
      4  6cff					      ENDIF
      5  6cff		       00		      .byte.b	0
    111  6d00
    112  6d00
    113  6d00							;---------------------------------------------------------------------------------------------------
    114  6d00
    115  6d00				   PositionalValue_ROOK
    116  6d00
      0  6d00					      PVAL	-25, -25, 10, 20, 10, 10, -25, -25
      0  6d00					      EVAL8	-25
      1  6d00				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6d00				  -	      ECHO	"Erroneous position value", -25
      3  6d00				  -	      ERR
      4  6d00					      ENDIF
      5  6d00		       e7		      .byte.b	-25
      0  6d01					      EVAL8	-25
      1  6d01				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6d01				  -	      ECHO	"Erroneous position value", -25
      3  6d01				  -	      ERR
      4  6d01					      ENDIF
      5  6d01		       e7		      .byte.b	-25
      0  6d02					      EVAL8	10
      1  6d02				  -	      IF	(10 > 127) || (10 < -128)
      2  6d02				  -	      ECHO	"Erroneous position value", 10
      3  6d02				  -	      ERR
      4  6d02					      ENDIF
      5  6d02		       0a		      .byte.b	10
      0  6d03					      EVAL8	20
      1  6d03				  -	      IF	(20 > 127) || (20 < -128)
      2  6d03				  -	      ECHO	"Erroneous position value", 20
      3  6d03				  -	      ERR
      4  6d03					      ENDIF
      5  6d03		       14		      .byte.b	20
      0  6d04					      EVAL8	10
      1  6d04				  -	      IF	(10 > 127) || (10 < -128)
      2  6d04				  -	      ECHO	"Erroneous position value", 10
      3  6d04				  -	      ERR
      4  6d04					      ENDIF
      5  6d04		       0a		      .byte.b	10
      0  6d05					      EVAL8	10
      1  6d05				  -	      IF	(10 > 127) || (10 < -128)
      2  6d05				  -	      ECHO	"Erroneous position value", 10
      3  6d05				  -	      ERR
      4  6d05					      ENDIF
      5  6d05		       0a		      .byte.b	10
      0  6d06					      EVAL8	-25
      1  6d06				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6d06				  -	      ECHO	"Erroneous position value", -25
      3  6d06				  -	      ERR
      4  6d06					      ENDIF
      5  6d06		       e7		      .byte.b	-25
      0  6d07					      EVAL8	-25
      1  6d07				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6d07				  -	      ECHO	"Erroneous position value", -25
      3  6d07				  -	      ERR
      4  6d07					      ENDIF
      5  6d07		       e7		      .byte.b	-25
      0  6d08					      EVAL8	0
      1  6d08				  -	      IF	(0 > 127) || (0 < -128)
      2  6d08				  -	      ECHO	"Erroneous position value", 0
      3  6d08				  -	      ERR
      4  6d08					      ENDIF
      5  6d08		       00		      .byte.b	0
      0  6d09					      EVAL8	0
      1  6d09				  -	      IF	(0 > 127) || (0 < -128)
      2  6d09				  -	      ECHO	"Erroneous position value", 0
      3  6d09				  -	      ERR
      4  6d09					      ENDIF
      5  6d09		       00		      .byte.b	0
      0  6d0a					      PVAL	-120, 0, 0, 0, 0, 0, 0, -128
      0  6d0a					      EVAL8	-120
      1  6d0a				  -	      IF	(-120 > 127) || (-120 < -128)
      2  6d0a				  -	      ECHO	"Erroneous position value", -120
      3  6d0a				  -	      ERR
      4  6d0a					      ENDIF
      5  6d0a		       88		      .byte.b	-120
      0  6d0b					      EVAL8	0
      1  6d0b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0b				  -	      ECHO	"Erroneous position value", 0
      3  6d0b				  -	      ERR
      4  6d0b					      ENDIF
      5  6d0b		       00		      .byte.b	0
      0  6d0c					      EVAL8	0
      1  6d0c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0c				  -	      ECHO	"Erroneous position value", 0
      3  6d0c				  -	      ERR
      4  6d0c					      ENDIF
      5  6d0c		       00		      .byte.b	0
      0  6d0d					      EVAL8	0
      1  6d0d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0d				  -	      ECHO	"Erroneous position value", 0
      3  6d0d				  -	      ERR
      4  6d0d					      ENDIF
      5  6d0d		       00		      .byte.b	0
      0  6d0e					      EVAL8	0
      1  6d0e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0e				  -	      ECHO	"Erroneous position value", 0
      3  6d0e				  -	      ERR
      4  6d0e					      ENDIF
      5  6d0e		       00		      .byte.b	0
      0  6d0f					      EVAL8	0
      1  6d0f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0f				  -	      ECHO	"Erroneous position value", 0
      3  6d0f				  -	      ERR
      4  6d0f					      ENDIF
      5  6d0f		       00		      .byte.b	0
      0  6d10					      EVAL8	0
      1  6d10				  -	      IF	(0 > 127) || (0 < -128)
      2  6d10				  -	      ECHO	"Erroneous position value", 0
      3  6d10				  -	      ERR
      4  6d10					      ENDIF
      5  6d10		       00		      .byte.b	0
      0  6d11					      EVAL8	-128
      1  6d11				  -	      IF	(-128 > 127) || (-128 < -128)
      2  6d11				  -	      ECHO	"Erroneous position value", -128
      3  6d11				  -	      ERR
      4  6d11					      ENDIF
      5  6d11		       80		      .byte.b	-128
      0  6d12					      EVAL8	0
      1  6d12				  -	      IF	(0 > 127) || (0 < -128)
      2  6d12				  -	      ECHO	"Erroneous position value", 0
      3  6d12				  -	      ERR
      4  6d12					      ENDIF
      5  6d12		       00		      .byte.b	0
      0  6d13					      EVAL8	0
      1  6d13				  -	      IF	(0 > 127) || (0 < -128)
      2  6d13				  -	      ECHO	"Erroneous position value", 0
      3  6d13				  -	      ERR
      4  6d13					      ENDIF
      5  6d13		       00		      .byte.b	0
      0  6d14					      PVAL	30, 0, 0, 0, 0, 0, 0, 30
      0  6d14					      EVAL8	30
      1  6d14				  -	      IF	(30 > 127) || (30 < -128)
      2  6d14				  -	      ECHO	"Erroneous position value", 30
      3  6d14				  -	      ERR
      4  6d14					      ENDIF
      5  6d14		       1e		      .byte.b	30
      0  6d15					      EVAL8	0
      1  6d15				  -	      IF	(0 > 127) || (0 < -128)
      2  6d15				  -	      ECHO	"Erroneous position value", 0
      3  6d15				  -	      ERR
      4  6d15					      ENDIF
      5  6d15		       00		      .byte.b	0
      0  6d16					      EVAL8	0
      1  6d16				  -	      IF	(0 > 127) || (0 < -128)
      2  6d16				  -	      ECHO	"Erroneous position value", 0
      3  6d16				  -	      ERR
      4  6d16					      ENDIF
      5  6d16		       00		      .byte.b	0
      0  6d17					      EVAL8	0
      1  6d17				  -	      IF	(0 > 127) || (0 < -128)
      2  6d17				  -	      ECHO	"Erroneous position value", 0
      3  6d17				  -	      ERR
      4  6d17					      ENDIF
      5  6d17		       00		      .byte.b	0
      0  6d18					      EVAL8	0
      1  6d18				  -	      IF	(0 > 127) || (0 < -128)
      2  6d18				  -	      ECHO	"Erroneous position value", 0
      3  6d18				  -	      ERR
      4  6d18					      ENDIF
      5  6d18		       00		      .byte.b	0
      0  6d19					      EVAL8	0
      1  6d19				  -	      IF	(0 > 127) || (0 < -128)
      2  6d19				  -	      ECHO	"Erroneous position value", 0
      3  6d19				  -	      ERR
      4  6d19					      ENDIF
      5  6d19		       00		      .byte.b	0
      0  6d1a					      EVAL8	0
      1  6d1a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d1a				  -	      ECHO	"Erroneous position value", 0
      3  6d1a				  -	      ERR
      4  6d1a					      ENDIF
      5  6d1a		       00		      .byte.b	0
      0  6d1b					      EVAL8	30
      1  6d1b				  -	      IF	(30 > 127) || (30 < -128)
      2  6d1b				  -	      ECHO	"Erroneous position value", 30
      3  6d1b				  -	      ERR
      4  6d1b					      ENDIF
      5  6d1b		       1e		      .byte.b	30
      0  6d1c					      EVAL8	0
      1  6d1c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d1c				  -	      ECHO	"Erroneous position value", 0
      3  6d1c				  -	      ERR
      4  6d1c					      ENDIF
      5  6d1c		       00		      .byte.b	0
      0  6d1d					      EVAL8	0
      1  6d1d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d1d				  -	      ECHO	"Erroneous position value", 0
      3  6d1d				  -	      ERR
      4  6d1d					      ENDIF
      5  6d1d		       00		      .byte.b	0
      0  6d1e					      PVAL	40, 0, 0, 0, 0, 0, 0, 40
      0  6d1e					      EVAL8	40
      1  6d1e				  -	      IF	(40 > 127) || (40 < -128)
      2  6d1e				  -	      ECHO	"Erroneous position value", 40
      3  6d1e				  -	      ERR
      4  6d1e					      ENDIF
      5  6d1e		       28		      .byte.b	40
      0  6d1f					      EVAL8	0
      1  6d1f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d1f				  -	      ECHO	"Erroneous position value", 0
      3  6d1f				  -	      ERR
      4  6d1f					      ENDIF
      5  6d1f		       00		      .byte.b	0
      0  6d20					      EVAL8	0
      1  6d20				  -	      IF	(0 > 127) || (0 < -128)
      2  6d20				  -	      ECHO	"Erroneous position value", 0
      3  6d20				  -	      ERR
      4  6d20					      ENDIF
      5  6d20		       00		      .byte.b	0
      0  6d21					      EVAL8	0
      1  6d21				  -	      IF	(0 > 127) || (0 < -128)
      2  6d21				  -	      ECHO	"Erroneous position value", 0
      3  6d21				  -	      ERR
      4  6d21					      ENDIF
      5  6d21		       00		      .byte.b	0
      0  6d22					      EVAL8	0
      1  6d22				  -	      IF	(0 > 127) || (0 < -128)
      2  6d22				  -	      ECHO	"Erroneous position value", 0
      3  6d22				  -	      ERR
      4  6d22					      ENDIF
      5  6d22		       00		      .byte.b	0
      0  6d23					      EVAL8	0
      1  6d23				  -	      IF	(0 > 127) || (0 < -128)
      2  6d23				  -	      ECHO	"Erroneous position value", 0
      3  6d23				  -	      ERR
      4  6d23					      ENDIF
      5  6d23		       00		      .byte.b	0
      0  6d24					      EVAL8	0
      1  6d24				  -	      IF	(0 > 127) || (0 < -128)
      2  6d24				  -	      ECHO	"Erroneous position value", 0
      3  6d24				  -	      ERR
      4  6d24					      ENDIF
      5  6d24		       00		      .byte.b	0
      0  6d25					      EVAL8	40
      1  6d25				  -	      IF	(40 > 127) || (40 < -128)
      2  6d25				  -	      ECHO	"Erroneous position value", 40
      3  6d25				  -	      ERR
      4  6d25					      ENDIF
      5  6d25		       28		      .byte.b	40
      0  6d26					      EVAL8	0
      1  6d26				  -	      IF	(0 > 127) || (0 < -128)
      2  6d26				  -	      ECHO	"Erroneous position value", 0
      3  6d26				  -	      ERR
      4  6d26					      ENDIF
      5  6d26		       00		      .byte.b	0
      0  6d27					      EVAL8	0
      1  6d27				  -	      IF	(0 > 127) || (0 < -128)
      2  6d27				  -	      ECHO	"Erroneous position value", 0
      3  6d27				  -	      ERR
      4  6d27					      ENDIF
      5  6d27		       00		      .byte.b	0
      0  6d28					      PVAL	-50, 0, 0, 0, 0, 0, 0, -50
      0  6d28					      EVAL8	-50
      1  6d28				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6d28				  -	      ECHO	"Erroneous position value", -50
      3  6d28				  -	      ERR
      4  6d28					      ENDIF
      5  6d28		       ce		      .byte.b	-50
      0  6d29					      EVAL8	0
      1  6d29				  -	      IF	(0 > 127) || (0 < -128)
      2  6d29				  -	      ECHO	"Erroneous position value", 0
      3  6d29				  -	      ERR
      4  6d29					      ENDIF
      5  6d29		       00		      .byte.b	0
      0  6d2a					      EVAL8	0
      1  6d2a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2a				  -	      ECHO	"Erroneous position value", 0
      3  6d2a				  -	      ERR
      4  6d2a					      ENDIF
      5  6d2a		       00		      .byte.b	0
      0  6d2b					      EVAL8	0
      1  6d2b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2b				  -	      ECHO	"Erroneous position value", 0
      3  6d2b				  -	      ERR
      4  6d2b					      ENDIF
      5  6d2b		       00		      .byte.b	0
      0  6d2c					      EVAL8	0
      1  6d2c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2c				  -	      ECHO	"Erroneous position value", 0
      3  6d2c				  -	      ERR
      4  6d2c					      ENDIF
      5  6d2c		       00		      .byte.b	0
      0  6d2d					      EVAL8	0
      1  6d2d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2d				  -	      ECHO	"Erroneous position value", 0
      3  6d2d				  -	      ERR
      4  6d2d					      ENDIF
      5  6d2d		       00		      .byte.b	0
      0  6d2e					      EVAL8	0
      1  6d2e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2e				  -	      ECHO	"Erroneous position value", 0
      3  6d2e				  -	      ERR
      4  6d2e					      ENDIF
      5  6d2e		       00		      .byte.b	0
      0  6d2f					      EVAL8	-50
      1  6d2f				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6d2f				  -	      ECHO	"Erroneous position value", -50
      3  6d2f				  -	      ERR
      4  6d2f					      ENDIF
      5  6d2f		       ce		      .byte.b	-50
      0  6d30					      EVAL8	0
      1  6d30				  -	      IF	(0 > 127) || (0 < -128)
      2  6d30				  -	      ECHO	"Erroneous position value", 0
      3  6d30				  -	      ERR
      4  6d30					      ENDIF
      5  6d30		       00		      .byte.b	0
      0  6d31					      EVAL8	0
      1  6d31				  -	      IF	(0 > 127) || (0 < -128)
      2  6d31				  -	      ECHO	"Erroneous position value", 0
      3  6d31				  -	      ERR
      4  6d31					      ENDIF
      5  6d31		       00		      .byte.b	0
      0  6d32					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      0  6d32					      EVAL8	-5
      1  6d32				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d32				  -	      ECHO	"Erroneous position value", -5
      3  6d32				  -	      ERR
      4  6d32					      ENDIF
      5  6d32		       fb		      .byte.b	-5
      0  6d33					      EVAL8	0
      1  6d33				  -	      IF	(0 > 127) || (0 < -128)
      2  6d33				  -	      ECHO	"Erroneous position value", 0
      3  6d33				  -	      ERR
      4  6d33					      ENDIF
      5  6d33		       00		      .byte.b	0
      0  6d34					      EVAL8	30
      1  6d34				  -	      IF	(30 > 127) || (30 < -128)
      2  6d34				  -	      ECHO	"Erroneous position value", 30
      3  6d34				  -	      ERR
      4  6d34					      ENDIF
      5  6d34		       1e		      .byte.b	30
      0  6d35					      EVAL8	30
      1  6d35				  -	      IF	(30 > 127) || (30 < -128)
      2  6d35				  -	      ECHO	"Erroneous position value", 30
      3  6d35				  -	      ERR
      4  6d35					      ENDIF
      5  6d35		       1e		      .byte.b	30
      0  6d36					      EVAL8	30
      1  6d36				  -	      IF	(30 > 127) || (30 < -128)
      2  6d36				  -	      ECHO	"Erroneous position value", 30
      3  6d36				  -	      ERR
      4  6d36					      ENDIF
      5  6d36		       1e		      .byte.b	30
      0  6d37					      EVAL8	30
      1  6d37				  -	      IF	(30 > 127) || (30 < -128)
      2  6d37				  -	      ECHO	"Erroneous position value", 30
      3  6d37				  -	      ERR
      4  6d37					      ENDIF
      5  6d37		       1e		      .byte.b	30
      0  6d38					      EVAL8	0
      1  6d38				  -	      IF	(0 > 127) || (0 < -128)
      2  6d38				  -	      ECHO	"Erroneous position value", 0
      3  6d38				  -	      ERR
      4  6d38					      ENDIF
      5  6d38		       00		      .byte.b	0
      0  6d39					      EVAL8	-5
      1  6d39				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d39				  -	      ECHO	"Erroneous position value", -5
      3  6d39				  -	      ERR
      4  6d39					      ENDIF
      5  6d39		       fb		      .byte.b	-5
      0  6d3a					      EVAL8	0
      1  6d3a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d3a				  -	      ECHO	"Erroneous position value", 0
      3  6d3a				  -	      ERR
      4  6d3a					      ENDIF
      5  6d3a		       00		      .byte.b	0
      0  6d3b					      EVAL8	0
      1  6d3b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d3b				  -	      ECHO	"Erroneous position value", 0
      3  6d3b				  -	      ERR
      4  6d3b					      ENDIF
      5  6d3b		       00		      .byte.b	0
      0  6d3c					      PVAL	55, 80, 90, 90, 90, 90, 80, 55
      0  6d3c					      EVAL8	55
      1  6d3c				  -	      IF	(55 > 127) || (55 < -128)
      2  6d3c				  -	      ECHO	"Erroneous position value", 55
      3  6d3c				  -	      ERR
      4  6d3c					      ENDIF
      5  6d3c		       37		      .byte.b	55
      0  6d3d					      EVAL8	80
      1  6d3d				  -	      IF	(80 > 127) || (80 < -128)
      2  6d3d				  -	      ECHO	"Erroneous position value", 80
      3  6d3d				  -	      ERR
      4  6d3d					      ENDIF
      5  6d3d		       50		      .byte.b	80
      0  6d3e					      EVAL8	90
      1  6d3e				  -	      IF	(90 > 127) || (90 < -128)
      2  6d3e				  -	      ECHO	"Erroneous position value", 90
      3  6d3e				  -	      ERR
      4  6d3e					      ENDIF
      5  6d3e		       5a		      .byte.b	90
      0  6d3f					      EVAL8	90
      1  6d3f				  -	      IF	(90 > 127) || (90 < -128)
      2  6d3f				  -	      ECHO	"Erroneous position value", 90
      3  6d3f				  -	      ERR
      4  6d3f					      ENDIF
      5  6d3f		       5a		      .byte.b	90
      0  6d40					      EVAL8	90
      1  6d40				  -	      IF	(90 > 127) || (90 < -128)
      2  6d40				  -	      ECHO	"Erroneous position value", 90
      3  6d40				  -	      ERR
      4  6d40					      ENDIF
      5  6d40		       5a		      .byte.b	90
      0  6d41					      EVAL8	90
      1  6d41				  -	      IF	(90 > 127) || (90 < -128)
      2  6d41				  -	      ECHO	"Erroneous position value", 90
      3  6d41				  -	      ERR
      4  6d41					      ENDIF
      5  6d41		       5a		      .byte.b	90
      0  6d42					      EVAL8	80
      1  6d42				  -	      IF	(80 > 127) || (80 < -128)
      2  6d42				  -	      ECHO	"Erroneous position value", 80
      3  6d42				  -	      ERR
      4  6d42					      ENDIF
      5  6d42		       50		      .byte.b	80
      0  6d43					      EVAL8	55
      1  6d43				  -	      IF	(55 > 127) || (55 < -128)
      2  6d43				  -	      ECHO	"Erroneous position value", 55
      3  6d43				  -	      ERR
      4  6d43					      ENDIF
      5  6d43		       37		      .byte.b	55
      0  6d44					      EVAL8	0
      1  6d44				  -	      IF	(0 > 127) || (0 < -128)
      2  6d44				  -	      ECHO	"Erroneous position value", 0
      3  6d44				  -	      ERR
      4  6d44					      ENDIF
      5  6d44		       00		      .byte.b	0
      0  6d45					      EVAL8	0
      1  6d45				  -	      IF	(0 > 127) || (0 < -128)
      2  6d45				  -	      ECHO	"Erroneous position value", 0
      3  6d45				  -	      ERR
      4  6d45					      ENDIF
      5  6d45		       00		      .byte.b	0
      0  6d46					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  6d46					      EVAL8	0
      1  6d46				  -	      IF	(0 > 127) || (0 < -128)
      2  6d46				  -	      ECHO	"Erroneous position value", 0
      3  6d46				  -	      ERR
      4  6d46					      ENDIF
      5  6d46		       00		      .byte.b	0
      0  6d47					      EVAL8	0
      1  6d47				  -	      IF	(0 > 127) || (0 < -128)
      2  6d47				  -	      ECHO	"Erroneous position value", 0
      3  6d47				  -	      ERR
      4  6d47					      ENDIF
      5  6d47		       00		      .byte.b	0
      0  6d48					      EVAL8	0
      1  6d48				  -	      IF	(0 > 127) || (0 < -128)
      2  6d48				  -	      ECHO	"Erroneous position value", 0
      3  6d48				  -	      ERR
      4  6d48					      ENDIF
      5  6d48		       00		      .byte.b	0
      0  6d49					      EVAL8	0
      1  6d49				  -	      IF	(0 > 127) || (0 < -128)
      2  6d49				  -	      ECHO	"Erroneous position value", 0
      3  6d49				  -	      ERR
      4  6d49					      ENDIF
      5  6d49		       00		      .byte.b	0
      0  6d4a					      EVAL8	0
      1  6d4a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4a				  -	      ECHO	"Erroneous position value", 0
      3  6d4a				  -	      ERR
      4  6d4a					      ENDIF
      5  6d4a		       00		      .byte.b	0
      0  6d4b					      EVAL8	0
      1  6d4b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4b				  -	      ECHO	"Erroneous position value", 0
      3  6d4b				  -	      ERR
      4  6d4b					      ENDIF
      5  6d4b		       00		      .byte.b	0
      0  6d4c					      EVAL8	0
      1  6d4c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4c				  -	      ECHO	"Erroneous position value", 0
      3  6d4c				  -	      ERR
      4  6d4c					      ENDIF
      5  6d4c		       00		      .byte.b	0
      0  6d4d					      EVAL8	0
      1  6d4d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4d				  -	      ECHO	"Erroneous position value", 0
      3  6d4d				  -	      ERR
      4  6d4d					      ENDIF
      5  6d4d		       00		      .byte.b	0
      0  6d4e					      EVAL8	0
      1  6d4e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4e				  -	      ECHO	"Erroneous position value", 0
      3  6d4e				  -	      ERR
      4  6d4e					      ENDIF
      5  6d4e		       00		      .byte.b	0
      0  6d4f					      EVAL8	0
      1  6d4f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4f				  -	      ECHO	"Erroneous position value", 0
      3  6d4f				  -	      ERR
      4  6d4f					      ENDIF
      5  6d4f		       00		      .byte.b	0
    125  6d50
    126  6d50
    127  6d50							;---------------------------------------------------------------------------------------------------
    128  6d50
    129  6d50				   PositionalValue_QUEEN
    130  6d50
      0  6d50					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      0  6d50					      EVAL8	-20
      1  6d50				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6d50				  -	      ECHO	"Erroneous position value", -20
      3  6d50				  -	      ERR
      4  6d50					      ENDIF
      5  6d50		       ec		      .byte.b	-20
      0  6d51					      EVAL8	-10
      1  6d51				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d51				  -	      ECHO	"Erroneous position value", -10
      3  6d51				  -	      ERR
      4  6d51					      ENDIF
      5  6d51		       f6		      .byte.b	-10
      0  6d52					      EVAL8	-5
      1  6d52				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d52				  -	      ECHO	"Erroneous position value", -5
      3  6d52				  -	      ERR
      4  6d52					      ENDIF
      5  6d52		       fb		      .byte.b	-5
      0  6d53					      EVAL8	-5
      1  6d53				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d53				  -	      ECHO	"Erroneous position value", -5
      3  6d53				  -	      ERR
      4  6d53					      ENDIF
      5  6d53		       fb		      .byte.b	-5
      0  6d54					      EVAL8	-5
      1  6d54				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d54				  -	      ECHO	"Erroneous position value", -5
      3  6d54				  -	      ERR
      4  6d54					      ENDIF
      5  6d54		       fb		      .byte.b	-5
      0  6d55					      EVAL8	-10
      1  6d55				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d55				  -	      ECHO	"Erroneous position value", -10
      3  6d55				  -	      ERR
      4  6d55					      ENDIF
      5  6d55		       f6		      .byte.b	-10
      0  6d56					      EVAL8	-10
      1  6d56				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d56				  -	      ECHO	"Erroneous position value", -10
      3  6d56				  -	      ERR
      4  6d56					      ENDIF
      5  6d56		       f6		      .byte.b	-10
      0  6d57					      EVAL8	-20
      1  6d57				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6d57				  -	      ECHO	"Erroneous position value", -20
      3  6d57				  -	      ERR
      4  6d57					      ENDIF
      5  6d57		       ec		      .byte.b	-20
      0  6d58					      EVAL8	0
      1  6d58				  -	      IF	(0 > 127) || (0 < -128)
      2  6d58				  -	      ECHO	"Erroneous position value", 0
      3  6d58				  -	      ERR
      4  6d58					      ENDIF
      5  6d58		       00		      .byte.b	0
      0  6d59					      EVAL8	0
      1  6d59				  -	      IF	(0 > 127) || (0 < -128)
      2  6d59				  -	      ECHO	"Erroneous position value", 0
      3  6d59				  -	      ERR
      4  6d59					      ENDIF
      5  6d59		       00		      .byte.b	0
      0  6d5a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      0  6d5a					      EVAL8	-10
      1  6d5a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d5a				  -	      ECHO	"Erroneous position value", -10
      3  6d5a				  -	      ERR
      4  6d5a					      ENDIF
      5  6d5a		       f6		      .byte.b	-10
      0  6d5b					      EVAL8	0
      1  6d5b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d5b				  -	      ECHO	"Erroneous position value", 0
      3  6d5b				  -	      ERR
      4  6d5b					      ENDIF
      5  6d5b		       00		      .byte.b	0
      0  6d5c					      EVAL8	5
      1  6d5c				  -	      IF	(5 > 127) || (5 < -128)
      2  6d5c				  -	      ECHO	"Erroneous position value", 5
      3  6d5c				  -	      ERR
      4  6d5c					      ENDIF
      5  6d5c		       05		      .byte.b	5
      0  6d5d					      EVAL8	0
      1  6d5d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d5d				  -	      ECHO	"Erroneous position value", 0
      3  6d5d				  -	      ERR
      4  6d5d					      ENDIF
      5  6d5d		       00		      .byte.b	0
      0  6d5e					      EVAL8	0
      1  6d5e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d5e				  -	      ECHO	"Erroneous position value", 0
      3  6d5e				  -	      ERR
      4  6d5e					      ENDIF
      5  6d5e		       00		      .byte.b	0
      0  6d5f					      EVAL8	0
      1  6d5f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d5f				  -	      ECHO	"Erroneous position value", 0
      3  6d5f				  -	      ERR
      4  6d5f					      ENDIF
      5  6d5f		       00		      .byte.b	0
      0  6d60					      EVAL8	0
      1  6d60				  -	      IF	(0 > 127) || (0 < -128)
      2  6d60				  -	      ECHO	"Erroneous position value", 0
      3  6d60				  -	      ERR
      4  6d60					      ENDIF
      5  6d60		       00		      .byte.b	0
      0  6d61					      EVAL8	-10
      1  6d61				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d61				  -	      ECHO	"Erroneous position value", -10
      3  6d61				  -	      ERR
      4  6d61					      ENDIF
      5  6d61		       f6		      .byte.b	-10
      0  6d62					      EVAL8	0
      1  6d62				  -	      IF	(0 > 127) || (0 < -128)
      2  6d62				  -	      ECHO	"Erroneous position value", 0
      3  6d62				  -	      ERR
      4  6d62					      ENDIF
      5  6d62		       00		      .byte.b	0
      0  6d63					      EVAL8	0
      1  6d63				  -	      IF	(0 > 127) || (0 < -128)
      2  6d63				  -	      ECHO	"Erroneous position value", 0
      3  6d63				  -	      ERR
      4  6d63					      ENDIF
      5  6d63		       00		      .byte.b	0
      0  6d64					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      0  6d64					      EVAL8	-10
      1  6d64				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d64				  -	      ECHO	"Erroneous position value", -10
      3  6d64				  -	      ERR
      4  6d64					      ENDIF
      5  6d64		       f6		      .byte.b	-10
      0  6d65					      EVAL8	5
      1  6d65				  -	      IF	(5 > 127) || (5 < -128)
      2  6d65				  -	      ECHO	"Erroneous position value", 5
      3  6d65				  -	      ERR
      4  6d65					      ENDIF
      5  6d65		       05		      .byte.b	5
      0  6d66					      EVAL8	5
      1  6d66				  -	      IF	(5 > 127) || (5 < -128)
      2  6d66				  -	      ECHO	"Erroneous position value", 5
      3  6d66				  -	      ERR
      4  6d66					      ENDIF
      5  6d66		       05		      .byte.b	5
      0  6d67					      EVAL8	5
      1  6d67				  -	      IF	(5 > 127) || (5 < -128)
      2  6d67				  -	      ECHO	"Erroneous position value", 5
      3  6d67				  -	      ERR
      4  6d67					      ENDIF
      5  6d67		       05		      .byte.b	5
      0  6d68					      EVAL8	5
      1  6d68				  -	      IF	(5 > 127) || (5 < -128)
      2  6d68				  -	      ECHO	"Erroneous position value", 5
      3  6d68				  -	      ERR
      4  6d68					      ENDIF
      5  6d68		       05		      .byte.b	5
      0  6d69					      EVAL8	25
      1  6d69				  -	      IF	(25 > 127) || (25 < -128)
      2  6d69				  -	      ECHO	"Erroneous position value", 25
      3  6d69				  -	      ERR
      4  6d69					      ENDIF
      5  6d69		       19		      .byte.b	25
      0  6d6a					      EVAL8	0
      1  6d6a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d6a				  -	      ECHO	"Erroneous position value", 0
      3  6d6a				  -	      ERR
      4  6d6a					      ENDIF
      5  6d6a		       00		      .byte.b	0
      0  6d6b					      EVAL8	-10
      1  6d6b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d6b				  -	      ECHO	"Erroneous position value", -10
      3  6d6b				  -	      ERR
      4  6d6b					      ENDIF
      5  6d6b		       f6		      .byte.b	-10
      0  6d6c					      EVAL8	0
      1  6d6c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d6c				  -	      ECHO	"Erroneous position value", 0
      3  6d6c				  -	      ERR
      4  6d6c					      ENDIF
      5  6d6c		       00		      .byte.b	0
      0  6d6d					      EVAL8	0
      1  6d6d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d6d				  -	      ECHO	"Erroneous position value", 0
      3  6d6d				  -	      ERR
      4  6d6d					      ENDIF
      5  6d6d		       00		      .byte.b	0
      0  6d6e					      PVAL	-10, 0, 25, 25, 25, 25, 0, -10
      0  6d6e					      EVAL8	-10
      1  6d6e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d6e				  -	      ECHO	"Erroneous position value", -10
      3  6d6e				  -	      ERR
      4  6d6e					      ENDIF
      5  6d6e		       f6		      .byte.b	-10
      0  6d6f					      EVAL8	0
      1  6d6f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d6f				  -	      ECHO	"Erroneous position value", 0
      3  6d6f				  -	      ERR
      4  6d6f					      ENDIF
      5  6d6f		       00		      .byte.b	0
      0  6d70					      EVAL8	25
      1  6d70				  -	      IF	(25 > 127) || (25 < -128)
      2  6d70				  -	      ECHO	"Erroneous position value", 25
      3  6d70				  -	      ERR
      4  6d70					      ENDIF
      5  6d70		       19		      .byte.b	25
      0  6d71					      EVAL8	25
      1  6d71				  -	      IF	(25 > 127) || (25 < -128)
      2  6d71				  -	      ECHO	"Erroneous position value", 25
      3  6d71				  -	      ERR
      4  6d71					      ENDIF
      5  6d71		       19		      .byte.b	25
      0  6d72					      EVAL8	25
      1  6d72				  -	      IF	(25 > 127) || (25 < -128)
      2  6d72				  -	      ECHO	"Erroneous position value", 25
      3  6d72				  -	      ERR
      4  6d72					      ENDIF
      5  6d72		       19		      .byte.b	25
      0  6d73					      EVAL8	25
      1  6d73				  -	      IF	(25 > 127) || (25 < -128)
      2  6d73				  -	      ECHO	"Erroneous position value", 25
      3  6d73				  -	      ERR
      4  6d73					      ENDIF
      5  6d73		       19		      .byte.b	25
      0  6d74					      EVAL8	0
      1  6d74				  -	      IF	(0 > 127) || (0 < -128)
      2  6d74				  -	      ECHO	"Erroneous position value", 0
      3  6d74				  -	      ERR
      4  6d74					      ENDIF
      5  6d74		       00		      .byte.b	0
      0  6d75					      EVAL8	-10
      1  6d75				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d75				  -	      ECHO	"Erroneous position value", -10
      3  6d75				  -	      ERR
      4  6d75					      ENDIF
      5  6d75		       f6		      .byte.b	-10
      0  6d76					      EVAL8	0
      1  6d76				  -	      IF	(0 > 127) || (0 < -128)
      2  6d76				  -	      ECHO	"Erroneous position value", 0
      3  6d76				  -	      ERR
      4  6d76					      ENDIF
      5  6d76		       00		      .byte.b	0
      0  6d77					      EVAL8	0
      1  6d77				  -	      IF	(0 > 127) || (0 < -128)
      2  6d77				  -	      ECHO	"Erroneous position value", 0
      3  6d77				  -	      ERR
      4  6d77					      ENDIF
      5  6d77		       00		      .byte.b	0
      0  6d78					      PVAL	-5, 0, 60, 55, 55, 55, 0, -5
      0  6d78					      EVAL8	-5
      1  6d78				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d78				  -	      ECHO	"Erroneous position value", -5
      3  6d78				  -	      ERR
      4  6d78					      ENDIF
      5  6d78		       fb		      .byte.b	-5
      0  6d79					      EVAL8	0
      1  6d79				  -	      IF	(0 > 127) || (0 < -128)
      2  6d79				  -	      ECHO	"Erroneous position value", 0
      3  6d79				  -	      ERR
      4  6d79					      ENDIF
      5  6d79		       00		      .byte.b	0
      0  6d7a					      EVAL8	60
      1  6d7a				  -	      IF	(60 > 127) || (60 < -128)
      2  6d7a				  -	      ECHO	"Erroneous position value", 60
      3  6d7a				  -	      ERR
      4  6d7a					      ENDIF
      5  6d7a		       3c		      .byte.b	60
      0  6d7b					      EVAL8	55
      1  6d7b				  -	      IF	(55 > 127) || (55 < -128)
      2  6d7b				  -	      ECHO	"Erroneous position value", 55
      3  6d7b				  -	      ERR
      4  6d7b					      ENDIF
      5  6d7b		       37		      .byte.b	55
      0  6d7c					      EVAL8	55
      1  6d7c				  -	      IF	(55 > 127) || (55 < -128)
      2  6d7c				  -	      ECHO	"Erroneous position value", 55
      3  6d7c				  -	      ERR
      4  6d7c					      ENDIF
      5  6d7c		       37		      .byte.b	55
      0  6d7d					      EVAL8	55
      1  6d7d				  -	      IF	(55 > 127) || (55 < -128)
      2  6d7d				  -	      ECHO	"Erroneous position value", 55
      3  6d7d				  -	      ERR
      4  6d7d					      ENDIF
      5  6d7d		       37		      .byte.b	55
      0  6d7e					      EVAL8	0
      1  6d7e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d7e				  -	      ECHO	"Erroneous position value", 0
      3  6d7e				  -	      ERR
      4  6d7e					      ENDIF
      5  6d7e		       00		      .byte.b	0
      0  6d7f					      EVAL8	-5
      1  6d7f				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d7f				  -	      ECHO	"Erroneous position value", -5
      3  6d7f				  -	      ERR
      4  6d7f					      ENDIF
      5  6d7f		       fb		      .byte.b	-5
      0  6d80					      EVAL8	0
      1  6d80				  -	      IF	(0 > 127) || (0 < -128)
      2  6d80				  -	      ECHO	"Erroneous position value", 0
      3  6d80				  -	      ERR
      4  6d80					      ENDIF
      5  6d80		       00		      .byte.b	0
      0  6d81					      EVAL8	0
      1  6d81				  -	      IF	(0 > 127) || (0 < -128)
      2  6d81				  -	      ECHO	"Erroneous position value", 0
      3  6d81				  -	      ERR
      4  6d81					      ENDIF
      5  6d81		       00		      .byte.b	0
      0  6d82					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      0  6d82					      EVAL8	-10
      1  6d82				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d82				  -	      ECHO	"Erroneous position value", -10
      3  6d82				  -	      ERR
      4  6d82					      ENDIF
      5  6d82		       f6		      .byte.b	-10
      0  6d83					      EVAL8	0
      1  6d83				  -	      IF	(0 > 127) || (0 < -128)
      2  6d83				  -	      ECHO	"Erroneous position value", 0
      3  6d83				  -	      ERR
      4  6d83					      ENDIF
      5  6d83		       00		      .byte.b	0
      0  6d84					      EVAL8	25
      1  6d84				  -	      IF	(25 > 127) || (25 < -128)
      2  6d84				  -	      ECHO	"Erroneous position value", 25
      3  6d84				  -	      ERR
      4  6d84					      ENDIF
      5  6d84		       19		      .byte.b	25
      0  6d85					      EVAL8	75
      1  6d85				  -	      IF	(75 > 127) || (75 < -128)
      2  6d85				  -	      ECHO	"Erroneous position value", 75
      3  6d85				  -	      ERR
      4  6d85					      ENDIF
      5  6d85		       4b		      .byte.b	75
      0  6d86					      EVAL8	75
      1  6d86				  -	      IF	(75 > 127) || (75 < -128)
      2  6d86				  -	      ECHO	"Erroneous position value", 75
      3  6d86				  -	      ERR
      4  6d86					      ENDIF
      5  6d86		       4b		      .byte.b	75
      0  6d87					      EVAL8	75
      1  6d87				  -	      IF	(75 > 127) || (75 < -128)
      2  6d87				  -	      ECHO	"Erroneous position value", 75
      3  6d87				  -	      ERR
      4  6d87					      ENDIF
      5  6d87		       4b		      .byte.b	75
      0  6d88					      EVAL8	0
      1  6d88				  -	      IF	(0 > 127) || (0 < -128)
      2  6d88				  -	      ECHO	"Erroneous position value", 0
      3  6d88				  -	      ERR
      4  6d88					      ENDIF
      5  6d88		       00		      .byte.b	0
      0  6d89					      EVAL8	-10
      1  6d89				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d89				  -	      ECHO	"Erroneous position value", -10
      3  6d89				  -	      ERR
      4  6d89					      ENDIF
      5  6d89		       f6		      .byte.b	-10
      0  6d8a					      EVAL8	0
      1  6d8a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8a				  -	      ECHO	"Erroneous position value", 0
      3  6d8a				  -	      ERR
      4  6d8a					      ENDIF
      5  6d8a		       00		      .byte.b	0
      0  6d8b					      EVAL8	0
      1  6d8b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8b				  -	      ECHO	"Erroneous position value", 0
      3  6d8b				  -	      ERR
      4  6d8b					      ENDIF
      5  6d8b		       00		      .byte.b	0
      0  6d8c					      PVAL	-10, 0, 0, 0, 0, 80, 0, -10
      0  6d8c					      EVAL8	-10
      1  6d8c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d8c				  -	      ECHO	"Erroneous position value", -10
      3  6d8c				  -	      ERR
      4  6d8c					      ENDIF
      5  6d8c		       f6		      .byte.b	-10
      0  6d8d					      EVAL8	0
      1  6d8d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8d				  -	      ECHO	"Erroneous position value", 0
      3  6d8d				  -	      ERR
      4  6d8d					      ENDIF
      5  6d8d		       00		      .byte.b	0
      0  6d8e					      EVAL8	0
      1  6d8e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8e				  -	      ECHO	"Erroneous position value", 0
      3  6d8e				  -	      ERR
      4  6d8e					      ENDIF
      5  6d8e		       00		      .byte.b	0
      0  6d8f					      EVAL8	0
      1  6d8f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8f				  -	      ECHO	"Erroneous position value", 0
      3  6d8f				  -	      ERR
      4  6d8f					      ENDIF
      5  6d8f		       00		      .byte.b	0
      0  6d90					      EVAL8	0
      1  6d90				  -	      IF	(0 > 127) || (0 < -128)
      2  6d90				  -	      ECHO	"Erroneous position value", 0
      3  6d90				  -	      ERR
      4  6d90					      ENDIF
      5  6d90		       00		      .byte.b	0
      0  6d91					      EVAL8	80
      1  6d91				  -	      IF	(80 > 127) || (80 < -128)
      2  6d91				  -	      ECHO	"Erroneous position value", 80
      3  6d91				  -	      ERR
      4  6d91					      ENDIF
      5  6d91		       50		      .byte.b	80
      0  6d92					      EVAL8	0
      1  6d92				  -	      IF	(0 > 127) || (0 < -128)
      2  6d92				  -	      ECHO	"Erroneous position value", 0
      3  6d92				  -	      ERR
      4  6d92					      ENDIF
      5  6d92		       00		      .byte.b	0
      0  6d93					      EVAL8	-10
      1  6d93				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d93				  -	      ECHO	"Erroneous position value", -10
      3  6d93				  -	      ERR
      4  6d93					      ENDIF
      5  6d93		       f6		      .byte.b	-10
      0  6d94					      EVAL8	0
      1  6d94				  -	      IF	(0 > 127) || (0 < -128)
      2  6d94				  -	      ECHO	"Erroneous position value", 0
      3  6d94				  -	      ERR
      4  6d94					      ENDIF
      5  6d94		       00		      .byte.b	0
      0  6d95					      EVAL8	0
      1  6d95				  -	      IF	(0 > 127) || (0 < -128)
      2  6d95				  -	      ECHO	"Erroneous position value", 0
      3  6d95				  -	      ERR
      4  6d95					      ENDIF
      5  6d95		       00		      .byte.b	0
      0  6d96					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      0  6d96					      EVAL8	-20
      1  6d96				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6d96				  -	      ECHO	"Erroneous position value", -20
      3  6d96				  -	      ERR
      4  6d96					      ENDIF
      5  6d96		       ec		      .byte.b	-20
      0  6d97					      EVAL8	-10
      1  6d97				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d97				  -	      ECHO	"Erroneous position value", -10
      3  6d97				  -	      ERR
      4  6d97					      ENDIF
      5  6d97		       f6		      .byte.b	-10
      0  6d98					      EVAL8	-10
      1  6d98				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d98				  -	      ECHO	"Erroneous position value", -10
      3  6d98				  -	      ERR
      4  6d98					      ENDIF
      5  6d98		       f6		      .byte.b	-10
      0  6d99					      EVAL8	-5
      1  6d99				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d99				  -	      ECHO	"Erroneous position value", -5
      3  6d99				  -	      ERR
      4  6d99					      ENDIF
      5  6d99		       fb		      .byte.b	-5
      0  6d9a					      EVAL8	-5
      1  6d9a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d9a				  -	      ECHO	"Erroneous position value", -5
      3  6d9a				  -	      ERR
      4  6d9a					      ENDIF
      5  6d9a		       fb		      .byte.b	-5
      0  6d9b					      EVAL8	-10
      1  6d9b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d9b				  -	      ECHO	"Erroneous position value", -10
      3  6d9b				  -	      ERR
      4  6d9b					      ENDIF
      5  6d9b		       f6		      .byte.b	-10
      0  6d9c					      EVAL8	-10
      1  6d9c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d9c				  -	      ECHO	"Erroneous position value", -10
      3  6d9c				  -	      ERR
      4  6d9c					      ENDIF
      5  6d9c		       f6		      .byte.b	-10
      0  6d9d					      EVAL8	-20
      1  6d9d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6d9d				  -	      ECHO	"Erroneous position value", -20
      3  6d9d				  -	      ERR
      4  6d9d					      ENDIF
      5  6d9d		       ec		      .byte.b	-20
      0  6d9e					      EVAL8	0
      1  6d9e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d9e				  -	      ECHO	"Erroneous position value", 0
      3  6d9e				  -	      ERR
      4  6d9e					      ENDIF
      5  6d9e		       00		      .byte.b	0
      0  6d9f					      EVAL8	0
      1  6d9f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d9f				  -	      ECHO	"Erroneous position value", 0
      3  6d9f				  -	      ERR
      4  6d9f					      ENDIF
      5  6d9f		       00		      .byte.b	0
    139  6da0
    140  6da0
    141  6da0							;---------------------------------------------------------------------------------------------------
    142  6da0
    143  6da0				   PositionalValue_KING_MIDGAME
    144  6da0
      0  6da0					      PVAL	0, 0, 20, -40, -40, -20, 20, 0
      0  6da0					      EVAL8	0
      1  6da0				  -	      IF	(0 > 127) || (0 < -128)
      2  6da0				  -	      ECHO	"Erroneous position value", 0
      3  6da0				  -	      ERR
      4  6da0					      ENDIF
      5  6da0		       00		      .byte.b	0
      0  6da1					      EVAL8	0
      1  6da1				  -	      IF	(0 > 127) || (0 < -128)
      2  6da1				  -	      ECHO	"Erroneous position value", 0
      3  6da1				  -	      ERR
      4  6da1					      ENDIF
      5  6da1		       00		      .byte.b	0
      0  6da2					      EVAL8	20
      1  6da2				  -	      IF	(20 > 127) || (20 < -128)
      2  6da2				  -	      ECHO	"Erroneous position value", 20
      3  6da2				  -	      ERR
      4  6da2					      ENDIF
      5  6da2		       14		      .byte.b	20
      0  6da3					      EVAL8	-40
      1  6da3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6da3				  -	      ECHO	"Erroneous position value", -40
      3  6da3				  -	      ERR
      4  6da3					      ENDIF
      5  6da3		       d8		      .byte.b	-40
      0  6da4					      EVAL8	-40
      1  6da4				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6da4				  -	      ECHO	"Erroneous position value", -40
      3  6da4				  -	      ERR
      4  6da4					      ENDIF
      5  6da4		       d8		      .byte.b	-40
      0  6da5					      EVAL8	-20
      1  6da5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6da5				  -	      ECHO	"Erroneous position value", -20
      3  6da5				  -	      ERR
      4  6da5					      ENDIF
      5  6da5		       ec		      .byte.b	-20
      0  6da6					      EVAL8	20
      1  6da6				  -	      IF	(20 > 127) || (20 < -128)
      2  6da6				  -	      ECHO	"Erroneous position value", 20
      3  6da6				  -	      ERR
      4  6da6					      ENDIF
      5  6da6		       14		      .byte.b	20
      0  6da7					      EVAL8	0
      1  6da7				  -	      IF	(0 > 127) || (0 < -128)
      2  6da7				  -	      ECHO	"Erroneous position value", 0
      3  6da7				  -	      ERR
      4  6da7					      ENDIF
      5  6da7		       00		      .byte.b	0
      0  6da8					      EVAL8	0
      1  6da8				  -	      IF	(0 > 127) || (0 < -128)
      2  6da8				  -	      ECHO	"Erroneous position value", 0
      3  6da8				  -	      ERR
      4  6da8					      ENDIF
      5  6da8		       00		      .byte.b	0
      0  6da9					      EVAL8	0
      1  6da9				  -	      IF	(0 > 127) || (0 < -128)
      2  6da9				  -	      ECHO	"Erroneous position value", 0
      3  6da9				  -	      ERR
      4  6da9					      ENDIF
      5  6da9		       00		      .byte.b	0
      0  6daa					      PVAL	0, 0, -80, -80, -70, -70, 0, 0
      0  6daa					      EVAL8	0
      1  6daa				  -	      IF	(0 > 127) || (0 < -128)
      2  6daa				  -	      ECHO	"Erroneous position value", 0
      3  6daa				  -	      ERR
      4  6daa					      ENDIF
      5  6daa		       00		      .byte.b	0
      0  6dab					      EVAL8	0
      1  6dab				  -	      IF	(0 > 127) || (0 < -128)
      2  6dab				  -	      ECHO	"Erroneous position value", 0
      3  6dab				  -	      ERR
      4  6dab					      ENDIF
      5  6dab		       00		      .byte.b	0
      0  6dac					      EVAL8	-80
      1  6dac				  -	      IF	(-80 > 127) || (-80 < -128)
      2  6dac				  -	      ECHO	"Erroneous position value", -80
      3  6dac				  -	      ERR
      4  6dac					      ENDIF
      5  6dac		       b0		      .byte.b	-80
      0  6dad					      EVAL8	-80
      1  6dad				  -	      IF	(-80 > 127) || (-80 < -128)
      2  6dad				  -	      ECHO	"Erroneous position value", -80
      3  6dad				  -	      ERR
      4  6dad					      ENDIF
      5  6dad		       b0		      .byte.b	-80
      0  6dae					      EVAL8	-70
      1  6dae				  -	      IF	(-70 > 127) || (-70 < -128)
      2  6dae				  -	      ECHO	"Erroneous position value", -70
      3  6dae				  -	      ERR
      4  6dae					      ENDIF
      5  6dae		       ba		      .byte.b	-70
      0  6daf					      EVAL8	-70
      1  6daf				  -	      IF	(-70 > 127) || (-70 < -128)
      2  6daf				  -	      ECHO	"Erroneous position value", -70
      3  6daf				  -	      ERR
      4  6daf					      ENDIF
      5  6daf		       ba		      .byte.b	-70
      0  6db0					      EVAL8	0
      1  6db0				  -	      IF	(0 > 127) || (0 < -128)
      2  6db0				  -	      ECHO	"Erroneous position value", 0
      3  6db0				  -	      ERR
      4  6db0					      ENDIF
      5  6db0		       00		      .byte.b	0
      0  6db1					      EVAL8	0
      1  6db1				  -	      IF	(0 > 127) || (0 < -128)
      2  6db1				  -	      ECHO	"Erroneous position value", 0
      3  6db1				  -	      ERR
      4  6db1					      ENDIF
      5  6db1		       00		      .byte.b	0
      0  6db2					      EVAL8	0
      1  6db2				  -	      IF	(0 > 127) || (0 < -128)
      2  6db2				  -	      ECHO	"Erroneous position value", 0
      3  6db2				  -	      ERR
      4  6db2					      ENDIF
      5  6db2		       00		      .byte.b	0
      0  6db3					      EVAL8	0
      1  6db3				  -	      IF	(0 > 127) || (0 < -128)
      2  6db3				  -	      ECHO	"Erroneous position value", 0
      3  6db3				  -	      ERR
      4  6db3					      ENDIF
      5  6db3		       00		      .byte.b	0
      0  6db4					      PVAL	-10, -20, -20, -50, -60, -60, -20, -10
      0  6db4					      EVAL8	-10
      1  6db4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6db4				  -	      ECHO	"Erroneous position value", -10
      3  6db4				  -	      ERR
      4  6db4					      ENDIF
      5  6db4		       f6		      .byte.b	-10
      0  6db5					      EVAL8	-20
      1  6db5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6db5				  -	      ECHO	"Erroneous position value", -20
      3  6db5				  -	      ERR
      4  6db5					      ENDIF
      5  6db5		       ec		      .byte.b	-20
      0  6db6					      EVAL8	-20
      1  6db6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6db6				  -	      ECHO	"Erroneous position value", -20
      3  6db6				  -	      ERR
      4  6db6					      ENDIF
      5  6db6		       ec		      .byte.b	-20
      0  6db7					      EVAL8	-50
      1  6db7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6db7				  -	      ECHO	"Erroneous position value", -50
      3  6db7				  -	      ERR
      4  6db7					      ENDIF
      5  6db7		       ce		      .byte.b	-50
      0  6db8					      EVAL8	-60
      1  6db8				  -	      IF	(-60 > 127) || (-60 < -128)
      2  6db8				  -	      ECHO	"Erroneous position value", -60
      3  6db8				  -	      ERR
      4  6db8					      ENDIF
      5  6db8		       c4		      .byte.b	-60
      0  6db9					      EVAL8	-60
      1  6db9				  -	      IF	(-60 > 127) || (-60 < -128)
      2  6db9				  -	      ECHO	"Erroneous position value", -60
      3  6db9				  -	      ERR
      4  6db9					      ENDIF
      5  6db9		       c4		      .byte.b	-60
      0  6dba					      EVAL8	-20
      1  6dba				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6dba				  -	      ECHO	"Erroneous position value", -20
      3  6dba				  -	      ERR
      4  6dba					      ENDIF
      5  6dba		       ec		      .byte.b	-20
      0  6dbb					      EVAL8	-10
      1  6dbb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6dbb				  -	      ECHO	"Erroneous position value", -10
      3  6dbb				  -	      ERR
      4  6dbb					      ENDIF
      5  6dbb		       f6		      .byte.b	-10
      0  6dbc					      EVAL8	0
      1  6dbc				  -	      IF	(0 > 127) || (0 < -128)
      2  6dbc				  -	      ECHO	"Erroneous position value", 0
      3  6dbc				  -	      ERR
      4  6dbc					      ENDIF
      5  6dbc		       00		      .byte.b	0
      0  6dbd					      EVAL8	0
      1  6dbd				  -	      IF	(0 > 127) || (0 < -128)
      2  6dbd				  -	      ECHO	"Erroneous position value", 0
      3  6dbd				  -	      ERR
      4  6dbd					      ENDIF
      5  6dbd		       00		      .byte.b	0
      0  6dbe					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      0  6dbe					      EVAL8	-20
      1  6dbe				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6dbe				  -	      ECHO	"Erroneous position value", -20
      3  6dbe				  -	      ERR
      4  6dbe					      ENDIF
      5  6dbe		       ec		      .byte.b	-20
      0  6dbf					      EVAL8	-30
      1  6dbf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dbf				  -	      ECHO	"Erroneous position value", -30
      3  6dbf				  -	      ERR
      4  6dbf					      ENDIF
      5  6dbf		       e2		      .byte.b	-30
      0  6dc0					      EVAL8	-30
      1  6dc0				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dc0				  -	      ECHO	"Erroneous position value", -30
      3  6dc0				  -	      ERR
      4  6dc0					      ENDIF
      5  6dc0		       e2		      .byte.b	-30
      0  6dc1					      EVAL8	-40
      1  6dc1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dc1				  -	      ECHO	"Erroneous position value", -40
      3  6dc1				  -	      ERR
      4  6dc1					      ENDIF
      5  6dc1		       d8		      .byte.b	-40
      0  6dc2					      EVAL8	-40
      1  6dc2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dc2				  -	      ECHO	"Erroneous position value", -40
      3  6dc2				  -	      ERR
      4  6dc2					      ENDIF
      5  6dc2		       d8		      .byte.b	-40
      0  6dc3					      EVAL8	-30
      1  6dc3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dc3				  -	      ECHO	"Erroneous position value", -30
      3  6dc3				  -	      ERR
      4  6dc3					      ENDIF
      5  6dc3		       e2		      .byte.b	-30
      0  6dc4					      EVAL8	-30
      1  6dc4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dc4				  -	      ECHO	"Erroneous position value", -30
      3  6dc4				  -	      ERR
      4  6dc4					      ENDIF
      5  6dc4		       e2		      .byte.b	-30
      0  6dc5					      EVAL8	-20
      1  6dc5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6dc5				  -	      ECHO	"Erroneous position value", -20
      3  6dc5				  -	      ERR
      4  6dc5					      ENDIF
      5  6dc5		       ec		      .byte.b	-20
      0  6dc6					      EVAL8	0
      1  6dc6				  -	      IF	(0 > 127) || (0 < -128)
      2  6dc6				  -	      ECHO	"Erroneous position value", 0
      3  6dc6				  -	      ERR
      4  6dc6					      ENDIF
      5  6dc6		       00		      .byte.b	0
      0  6dc7					      EVAL8	0
      1  6dc7				  -	      IF	(0 > 127) || (0 < -128)
      2  6dc7				  -	      ECHO	"Erroneous position value", 0
      3  6dc7				  -	      ERR
      4  6dc7					      ENDIF
      5  6dc7		       00		      .byte.b	0
      0  6dc8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  6dc8					      EVAL8	-30
      1  6dc8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dc8				  -	      ECHO	"Erroneous position value", -30
      3  6dc8				  -	      ERR
      4  6dc8					      ENDIF
      5  6dc8		       e2		      .byte.b	-30
      0  6dc9					      EVAL8	-40
      1  6dc9				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dc9				  -	      ECHO	"Erroneous position value", -40
      3  6dc9				  -	      ERR
      4  6dc9					      ENDIF
      5  6dc9		       d8		      .byte.b	-40
      0  6dca					      EVAL8	-40
      1  6dca				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dca				  -	      ECHO	"Erroneous position value", -40
      3  6dca				  -	      ERR
      4  6dca					      ENDIF
      5  6dca		       d8		      .byte.b	-40
      0  6dcb					      EVAL8	-50
      1  6dcb				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dcb				  -	      ECHO	"Erroneous position value", -50
      3  6dcb				  -	      ERR
      4  6dcb					      ENDIF
      5  6dcb		       ce		      .byte.b	-50
      0  6dcc					      EVAL8	-50
      1  6dcc				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dcc				  -	      ECHO	"Erroneous position value", -50
      3  6dcc				  -	      ERR
      4  6dcc					      ENDIF
      5  6dcc		       ce		      .byte.b	-50
      0  6dcd					      EVAL8	-40
      1  6dcd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dcd				  -	      ECHO	"Erroneous position value", -40
      3  6dcd				  -	      ERR
      4  6dcd					      ENDIF
      5  6dcd		       d8		      .byte.b	-40
      0  6dce					      EVAL8	-40
      1  6dce				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dce				  -	      ECHO	"Erroneous position value", -40
      3  6dce				  -	      ERR
      4  6dce					      ENDIF
      5  6dce		       d8		      .byte.b	-40
      0  6dcf					      EVAL8	-30
      1  6dcf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dcf				  -	      ECHO	"Erroneous position value", -30
      3  6dcf				  -	      ERR
      4  6dcf					      ENDIF
      5  6dcf		       e2		      .byte.b	-30
      0  6dd0					      EVAL8	0
      1  6dd0				  -	      IF	(0 > 127) || (0 < -128)
      2  6dd0				  -	      ECHO	"Erroneous position value", 0
      3  6dd0				  -	      ERR
      4  6dd0					      ENDIF
      5  6dd0		       00		      .byte.b	0
      0  6dd1					      EVAL8	0
      1  6dd1				  -	      IF	(0 > 127) || (0 < -128)
      2  6dd1				  -	      ECHO	"Erroneous position value", 0
      3  6dd1				  -	      ERR
      4  6dd1					      ENDIF
      5  6dd1		       00		      .byte.b	0
      0  6dd2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  6dd2					      EVAL8	-30
      1  6dd2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dd2				  -	      ECHO	"Erroneous position value", -30
      3  6dd2				  -	      ERR
      4  6dd2					      ENDIF
      5  6dd2		       e2		      .byte.b	-30
      0  6dd3					      EVAL8	-40
      1  6dd3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dd3				  -	      ECHO	"Erroneous position value", -40
      3  6dd3				  -	      ERR
      4  6dd3					      ENDIF
      5  6dd3		       d8		      .byte.b	-40
      0  6dd4					      EVAL8	-40
      1  6dd4				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dd4				  -	      ECHO	"Erroneous position value", -40
      3  6dd4				  -	      ERR
      4  6dd4					      ENDIF
      5  6dd4		       d8		      .byte.b	-40
      0  6dd5					      EVAL8	-50
      1  6dd5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dd5				  -	      ECHO	"Erroneous position value", -50
      3  6dd5				  -	      ERR
      4  6dd5					      ENDIF
      5  6dd5		       ce		      .byte.b	-50
      0  6dd6					      EVAL8	-50
      1  6dd6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dd6				  -	      ECHO	"Erroneous position value", -50
      3  6dd6				  -	      ERR
      4  6dd6					      ENDIF
      5  6dd6		       ce		      .byte.b	-50
      0  6dd7					      EVAL8	-40
      1  6dd7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dd7				  -	      ECHO	"Erroneous position value", -40
      3  6dd7				  -	      ERR
      4  6dd7					      ENDIF
      5  6dd7		       d8		      .byte.b	-40
      0  6dd8					      EVAL8	-40
      1  6dd8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dd8				  -	      ECHO	"Erroneous position value", -40
      3  6dd8				  -	      ERR
      4  6dd8					      ENDIF
      5  6dd8		       d8		      .byte.b	-40
      0  6dd9					      EVAL8	-30
      1  6dd9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dd9				  -	      ECHO	"Erroneous position value", -30
      3  6dd9				  -	      ERR
      4  6dd9					      ENDIF
      5  6dd9		       e2		      .byte.b	-30
      0  6dda					      EVAL8	0
      1  6dda				  -	      IF	(0 > 127) || (0 < -128)
      2  6dda				  -	      ECHO	"Erroneous position value", 0
      3  6dda				  -	      ERR
      4  6dda					      ENDIF
      5  6dda		       00		      .byte.b	0
      0  6ddb					      EVAL8	0
      1  6ddb				  -	      IF	(0 > 127) || (0 < -128)
      2  6ddb				  -	      ECHO	"Erroneous position value", 0
      3  6ddb				  -	      ERR
      4  6ddb					      ENDIF
      5  6ddb		       00		      .byte.b	0
      0  6ddc					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  6ddc					      EVAL8	-30
      1  6ddc				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6ddc				  -	      ECHO	"Erroneous position value", -30
      3  6ddc				  -	      ERR
      4  6ddc					      ENDIF
      5  6ddc		       e2		      .byte.b	-30
      0  6ddd					      EVAL8	-40
      1  6ddd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6ddd				  -	      ECHO	"Erroneous position value", -40
      3  6ddd				  -	      ERR
      4  6ddd					      ENDIF
      5  6ddd		       d8		      .byte.b	-40
      0  6dde					      EVAL8	-40
      1  6dde				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dde				  -	      ECHO	"Erroneous position value", -40
      3  6dde				  -	      ERR
      4  6dde					      ENDIF
      5  6dde		       d8		      .byte.b	-40
      0  6ddf					      EVAL8	-50
      1  6ddf				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6ddf				  -	      ECHO	"Erroneous position value", -50
      3  6ddf				  -	      ERR
      4  6ddf					      ENDIF
      5  6ddf		       ce		      .byte.b	-50
      0  6de0					      EVAL8	-50
      1  6de0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6de0				  -	      ECHO	"Erroneous position value", -50
      3  6de0				  -	      ERR
      4  6de0					      ENDIF
      5  6de0		       ce		      .byte.b	-50
      0  6de1					      EVAL8	-40
      1  6de1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6de1				  -	      ECHO	"Erroneous position value", -40
      3  6de1				  -	      ERR
      4  6de1					      ENDIF
      5  6de1		       d8		      .byte.b	-40
      0  6de2					      EVAL8	-40
      1  6de2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6de2				  -	      ECHO	"Erroneous position value", -40
      3  6de2				  -	      ERR
      4  6de2					      ENDIF
      5  6de2		       d8		      .byte.b	-40
      0  6de3					      EVAL8	-30
      1  6de3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6de3				  -	      ECHO	"Erroneous position value", -30
      3  6de3				  -	      ERR
      4  6de3					      ENDIF
      5  6de3		       e2		      .byte.b	-30
      0  6de4					      EVAL8	0
      1  6de4				  -	      IF	(0 > 127) || (0 < -128)
      2  6de4				  -	      ECHO	"Erroneous position value", 0
      3  6de4				  -	      ERR
      4  6de4					      ENDIF
      5  6de4		       00		      .byte.b	0
      0  6de5					      EVAL8	0
      1  6de5				  -	      IF	(0 > 127) || (0 < -128)
      2  6de5				  -	      ECHO	"Erroneous position value", 0
      3  6de5				  -	      ERR
      4  6de5					      ENDIF
      5  6de5		       00		      .byte.b	0
      0  6de6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  6de6					      EVAL8	-30
      1  6de6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6de6				  -	      ECHO	"Erroneous position value", -30
      3  6de6				  -	      ERR
      4  6de6					      ENDIF
      5  6de6		       e2		      .byte.b	-30
      0  6de7					      EVAL8	-40
      1  6de7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6de7				  -	      ECHO	"Erroneous position value", -40
      3  6de7				  -	      ERR
      4  6de7					      ENDIF
      5  6de7		       d8		      .byte.b	-40
      0  6de8					      EVAL8	-40
      1  6de8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6de8				  -	      ECHO	"Erroneous position value", -40
      3  6de8				  -	      ERR
      4  6de8					      ENDIF
      5  6de8		       d8		      .byte.b	-40
      0  6de9					      EVAL8	-50
      1  6de9				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6de9				  -	      ECHO	"Erroneous position value", -50
      3  6de9				  -	      ERR
      4  6de9					      ENDIF
      5  6de9		       ce		      .byte.b	-50
      0  6dea					      EVAL8	-50
      1  6dea				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dea				  -	      ECHO	"Erroneous position value", -50
      3  6dea				  -	      ERR
      4  6dea					      ENDIF
      5  6dea		       ce		      .byte.b	-50
      0  6deb					      EVAL8	-40
      1  6deb				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6deb				  -	      ECHO	"Erroneous position value", -40
      3  6deb				  -	      ERR
      4  6deb					      ENDIF
      5  6deb		       d8		      .byte.b	-40
      0  6dec					      EVAL8	-40
      1  6dec				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dec				  -	      ECHO	"Erroneous position value", -40
      3  6dec				  -	      ERR
      4  6dec					      ENDIF
      5  6dec		       d8		      .byte.b	-40
      0  6ded					      EVAL8	-30
      1  6ded				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6ded				  -	      ECHO	"Erroneous position value", -30
      3  6ded				  -	      ERR
      4  6ded					      ENDIF
      5  6ded		       e2		      .byte.b	-30
      0  6dee					      EVAL8	0
      1  6dee				  -	      IF	(0 > 127) || (0 < -128)
      2  6dee				  -	      ECHO	"Erroneous position value", 0
      3  6dee				  -	      ERR
      4  6dee					      ENDIF
      5  6dee		       00		      .byte.b	0
      0  6def					      EVAL8	0
      1  6def				  -	      IF	(0 > 127) || (0 < -128)
      2  6def				  -	      ECHO	"Erroneous position value", 0
      3  6def				  -	      ERR
      4  6def					      ENDIF
      5  6def		       00		      .byte.b	0
    153  6df0
    154  6df0
    155  6df0							;---------------------------------------------------------------------------------------------------
    156  6df0
    157  6df0				   PositionalValue_KING_ENDGAME
    158  6df0
      0  6df0					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      0  6df0					      EVAL8	-50
      1  6df0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6df0				  -	      ECHO	"Erroneous position value", -50
      3  6df0				  -	      ERR
      4  6df0					      ENDIF
      5  6df0		       ce		      .byte.b	-50
      0  6df1					      EVAL8	-30
      1  6df1				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df1				  -	      ECHO	"Erroneous position value", -30
      3  6df1				  -	      ERR
      4  6df1					      ENDIF
      5  6df1		       e2		      .byte.b	-30
      0  6df2					      EVAL8	-30
      1  6df2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df2				  -	      ECHO	"Erroneous position value", -30
      3  6df2				  -	      ERR
      4  6df2					      ENDIF
      5  6df2		       e2		      .byte.b	-30
      0  6df3					      EVAL8	-30
      1  6df3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df3				  -	      ECHO	"Erroneous position value", -30
      3  6df3				  -	      ERR
      4  6df3					      ENDIF
      5  6df3		       e2		      .byte.b	-30
      0  6df4					      EVAL8	-30
      1  6df4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df4				  -	      ECHO	"Erroneous position value", -30
      3  6df4				  -	      ERR
      4  6df4					      ENDIF
      5  6df4		       e2		      .byte.b	-30
      0  6df5					      EVAL8	-30
      1  6df5				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df5				  -	      ECHO	"Erroneous position value", -30
      3  6df5				  -	      ERR
      4  6df5					      ENDIF
      5  6df5		       e2		      .byte.b	-30
      0  6df6					      EVAL8	-30
      1  6df6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df6				  -	      ECHO	"Erroneous position value", -30
      3  6df6				  -	      ERR
      4  6df6					      ENDIF
      5  6df6		       e2		      .byte.b	-30
      0  6df7					      EVAL8	-50
      1  6df7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6df7				  -	      ECHO	"Erroneous position value", -50
      3  6df7				  -	      ERR
      4  6df7					      ENDIF
      5  6df7		       ce		      .byte.b	-50
      0  6df8					      EVAL8	0
      1  6df8				  -	      IF	(0 > 127) || (0 < -128)
      2  6df8				  -	      ECHO	"Erroneous position value", 0
      3  6df8				  -	      ERR
      4  6df8					      ENDIF
      5  6df8		       00		      .byte.b	0
      0  6df9					      EVAL8	0
      1  6df9				  -	      IF	(0 > 127) || (0 < -128)
      2  6df9				  -	      ECHO	"Erroneous position value", 0
      3  6df9				  -	      ERR
      4  6df9					      ENDIF
      5  6df9		       00		      .byte.b	0
      0  6dfa					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      0  6dfa					      EVAL8	-30
      1  6dfa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dfa				  -	      ECHO	"Erroneous position value", -30
      3  6dfa				  -	      ERR
      4  6dfa					      ENDIF
      5  6dfa		       e2		      .byte.b	-30
      0  6dfb					      EVAL8	-30
      1  6dfb				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dfb				  -	      ECHO	"Erroneous position value", -30
      3  6dfb				  -	      ERR
      4  6dfb					      ENDIF
      5  6dfb		       e2		      .byte.b	-30
      0  6dfc					      EVAL8	0
      1  6dfc				  -	      IF	(0 > 127) || (0 < -128)
      2  6dfc				  -	      ECHO	"Erroneous position value", 0
      3  6dfc				  -	      ERR
      4  6dfc					      ENDIF
      5  6dfc		       00		      .byte.b	0
      0  6dfd					      EVAL8	0
      1  6dfd				  -	      IF	(0 > 127) || (0 < -128)
      2  6dfd				  -	      ECHO	"Erroneous position value", 0
      3  6dfd				  -	      ERR
      4  6dfd					      ENDIF
      5  6dfd		       00		      .byte.b	0
      0  6dfe					      EVAL8	0
      1  6dfe				  -	      IF	(0 > 127) || (0 < -128)
      2  6dfe				  -	      ECHO	"Erroneous position value", 0
      3  6dfe				  -	      ERR
      4  6dfe					      ENDIF
      5  6dfe		       00		      .byte.b	0
      0  6dff					      EVAL8	0
      1  6dff				  -	      IF	(0 > 127) || (0 < -128)
      2  6dff				  -	      ECHO	"Erroneous position value", 0
      3  6dff				  -	      ERR
      4  6dff					      ENDIF
      5  6dff		       00		      .byte.b	0
      0  6e00					      EVAL8	-30
      1  6e00				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e00				  -	      ECHO	"Erroneous position value", -30
      3  6e00				  -	      ERR
      4  6e00					      ENDIF
      5  6e00		       e2		      .byte.b	-30
      0  6e01					      EVAL8	-30
      1  6e01				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e01				  -	      ECHO	"Erroneous position value", -30
      3  6e01				  -	      ERR
      4  6e01					      ENDIF
      5  6e01		       e2		      .byte.b	-30
      0  6e02					      EVAL8	0
      1  6e02				  -	      IF	(0 > 127) || (0 < -128)
      2  6e02				  -	      ECHO	"Erroneous position value", 0
      3  6e02				  -	      ERR
      4  6e02					      ENDIF
      5  6e02		       00		      .byte.b	0
      0  6e03					      EVAL8	0
      1  6e03				  -	      IF	(0 > 127) || (0 < -128)
      2  6e03				  -	      ECHO	"Erroneous position value", 0
      3  6e03				  -	      ERR
      4  6e03					      ENDIF
      5  6e03		       00		      .byte.b	0
      0  6e04					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  6e04					      EVAL8	-30
      1  6e04				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e04				  -	      ECHO	"Erroneous position value", -30
      3  6e04				  -	      ERR
      4  6e04					      ENDIF
      5  6e04		       e2		      .byte.b	-30
      0  6e05					      EVAL8	-10
      1  6e05				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e05				  -	      ECHO	"Erroneous position value", -10
      3  6e05				  -	      ERR
      4  6e05					      ENDIF
      5  6e05		       f6		      .byte.b	-10
      0  6e06					      EVAL8	20
      1  6e06				  -	      IF	(20 > 127) || (20 < -128)
      2  6e06				  -	      ECHO	"Erroneous position value", 20
      3  6e06				  -	      ERR
      4  6e06					      ENDIF
      5  6e06		       14		      .byte.b	20
      0  6e07					      EVAL8	30
      1  6e07				  -	      IF	(30 > 127) || (30 < -128)
      2  6e07				  -	      ECHO	"Erroneous position value", 30
      3  6e07				  -	      ERR
      4  6e07					      ENDIF
      5  6e07		       1e		      .byte.b	30
      0  6e08					      EVAL8	30
      1  6e08				  -	      IF	(30 > 127) || (30 < -128)
      2  6e08				  -	      ECHO	"Erroneous position value", 30
      3  6e08				  -	      ERR
      4  6e08					      ENDIF
      5  6e08		       1e		      .byte.b	30
      0  6e09					      EVAL8	20
      1  6e09				  -	      IF	(20 > 127) || (20 < -128)
      2  6e09				  -	      ECHO	"Erroneous position value", 20
      3  6e09				  -	      ERR
      4  6e09					      ENDIF
      5  6e09		       14		      .byte.b	20
      0  6e0a					      EVAL8	-10
      1  6e0a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e0a				  -	      ECHO	"Erroneous position value", -10
      3  6e0a				  -	      ERR
      4  6e0a					      ENDIF
      5  6e0a		       f6		      .byte.b	-10
      0  6e0b					      EVAL8	-30
      1  6e0b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e0b				  -	      ECHO	"Erroneous position value", -30
      3  6e0b				  -	      ERR
      4  6e0b					      ENDIF
      5  6e0b		       e2		      .byte.b	-30
      0  6e0c					      EVAL8	0
      1  6e0c				  -	      IF	(0 > 127) || (0 < -128)
      2  6e0c				  -	      ECHO	"Erroneous position value", 0
      3  6e0c				  -	      ERR
      4  6e0c					      ENDIF
      5  6e0c		       00		      .byte.b	0
      0  6e0d					      EVAL8	0
      1  6e0d				  -	      IF	(0 > 127) || (0 < -128)
      2  6e0d				  -	      ECHO	"Erroneous position value", 0
      3  6e0d				  -	      ERR
      4  6e0d					      ENDIF
      5  6e0d		       00		      .byte.b	0
      0  6e0e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  6e0e					      EVAL8	-30
      1  6e0e				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e0e				  -	      ECHO	"Erroneous position value", -30
      3  6e0e				  -	      ERR
      4  6e0e					      ENDIF
      5  6e0e		       e2		      .byte.b	-30
      0  6e0f					      EVAL8	-10
      1  6e0f				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e0f				  -	      ECHO	"Erroneous position value", -10
      3  6e0f				  -	      ERR
      4  6e0f					      ENDIF
      5  6e0f		       f6		      .byte.b	-10
      0  6e10					      EVAL8	30
      1  6e10				  -	      IF	(30 > 127) || (30 < -128)
      2  6e10				  -	      ECHO	"Erroneous position value", 30
      3  6e10				  -	      ERR
      4  6e10					      ENDIF
      5  6e10		       1e		      .byte.b	30
      0  6e11					      EVAL8	40
      1  6e11				  -	      IF	(40 > 127) || (40 < -128)
      2  6e11				  -	      ECHO	"Erroneous position value", 40
      3  6e11				  -	      ERR
      4  6e11					      ENDIF
      5  6e11		       28		      .byte.b	40
      0  6e12					      EVAL8	40
      1  6e12				  -	      IF	(40 > 127) || (40 < -128)
      2  6e12				  -	      ECHO	"Erroneous position value", 40
      3  6e12				  -	      ERR
      4  6e12					      ENDIF
      5  6e12		       28		      .byte.b	40
      0  6e13					      EVAL8	30
      1  6e13				  -	      IF	(30 > 127) || (30 < -128)
      2  6e13				  -	      ECHO	"Erroneous position value", 30
      3  6e13				  -	      ERR
      4  6e13					      ENDIF
      5  6e13		       1e		      .byte.b	30
      0  6e14					      EVAL8	-10
      1  6e14				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e14				  -	      ECHO	"Erroneous position value", -10
      3  6e14				  -	      ERR
      4  6e14					      ENDIF
      5  6e14		       f6		      .byte.b	-10
      0  6e15					      EVAL8	-30
      1  6e15				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e15				  -	      ECHO	"Erroneous position value", -30
      3  6e15				  -	      ERR
      4  6e15					      ENDIF
      5  6e15		       e2		      .byte.b	-30
      0  6e16					      EVAL8	0
      1  6e16				  -	      IF	(0 > 127) || (0 < -128)
      2  6e16				  -	      ECHO	"Erroneous position value", 0
      3  6e16				  -	      ERR
      4  6e16					      ENDIF
      5  6e16		       00		      .byte.b	0
      0  6e17					      EVAL8	0
      1  6e17				  -	      IF	(0 > 127) || (0 < -128)
      2  6e17				  -	      ECHO	"Erroneous position value", 0
      3  6e17				  -	      ERR
      4  6e17					      ENDIF
      5  6e17		       00		      .byte.b	0
      0  6e18					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  6e18					      EVAL8	-30
      1  6e18				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e18				  -	      ECHO	"Erroneous position value", -30
      3  6e18				  -	      ERR
      4  6e18					      ENDIF
      5  6e18		       e2		      .byte.b	-30
      0  6e19					      EVAL8	-10
      1  6e19				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e19				  -	      ECHO	"Erroneous position value", -10
      3  6e19				  -	      ERR
      4  6e19					      ENDIF
      5  6e19		       f6		      .byte.b	-10
      0  6e1a					      EVAL8	30
      1  6e1a				  -	      IF	(30 > 127) || (30 < -128)
      2  6e1a				  -	      ECHO	"Erroneous position value", 30
      3  6e1a				  -	      ERR
      4  6e1a					      ENDIF
      5  6e1a		       1e		      .byte.b	30
      0  6e1b					      EVAL8	40
      1  6e1b				  -	      IF	(40 > 127) || (40 < -128)
      2  6e1b				  -	      ECHO	"Erroneous position value", 40
      3  6e1b				  -	      ERR
      4  6e1b					      ENDIF
      5  6e1b		       28		      .byte.b	40
      0  6e1c					      EVAL8	40
      1  6e1c				  -	      IF	(40 > 127) || (40 < -128)
      2  6e1c				  -	      ECHO	"Erroneous position value", 40
      3  6e1c				  -	      ERR
      4  6e1c					      ENDIF
      5  6e1c		       28		      .byte.b	40
      0  6e1d					      EVAL8	30
      1  6e1d				  -	      IF	(30 > 127) || (30 < -128)
      2  6e1d				  -	      ECHO	"Erroneous position value", 30
      3  6e1d				  -	      ERR
      4  6e1d					      ENDIF
      5  6e1d		       1e		      .byte.b	30
      0  6e1e					      EVAL8	-10
      1  6e1e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e1e				  -	      ECHO	"Erroneous position value", -10
      3  6e1e				  -	      ERR
      4  6e1e					      ENDIF
      5  6e1e		       f6		      .byte.b	-10
      0  6e1f					      EVAL8	-30
      1  6e1f				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e1f				  -	      ECHO	"Erroneous position value", -30
      3  6e1f				  -	      ERR
      4  6e1f					      ENDIF
      5  6e1f		       e2		      .byte.b	-30
      0  6e20					      EVAL8	0
      1  6e20				  -	      IF	(0 > 127) || (0 < -128)
      2  6e20				  -	      ECHO	"Erroneous position value", 0
      3  6e20				  -	      ERR
      4  6e20					      ENDIF
      5  6e20		       00		      .byte.b	0
      0  6e21					      EVAL8	0
      1  6e21				  -	      IF	(0 > 127) || (0 < -128)
      2  6e21				  -	      ECHO	"Erroneous position value", 0
      3  6e21				  -	      ERR
      4  6e21					      ENDIF
      5  6e21		       00		      .byte.b	0
      0  6e22					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  6e22					      EVAL8	-30
      1  6e22				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e22				  -	      ECHO	"Erroneous position value", -30
      3  6e22				  -	      ERR
      4  6e22					      ENDIF
      5  6e22		       e2		      .byte.b	-30
      0  6e23					      EVAL8	-10
      1  6e23				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e23				  -	      ECHO	"Erroneous position value", -10
      3  6e23				  -	      ERR
      4  6e23					      ENDIF
      5  6e23		       f6		      .byte.b	-10
      0  6e24					      EVAL8	20
      1  6e24				  -	      IF	(20 > 127) || (20 < -128)
      2  6e24				  -	      ECHO	"Erroneous position value", 20
      3  6e24				  -	      ERR
      4  6e24					      ENDIF
      5  6e24		       14		      .byte.b	20
      0  6e25					      EVAL8	30
      1  6e25				  -	      IF	(30 > 127) || (30 < -128)
      2  6e25				  -	      ECHO	"Erroneous position value", 30
      3  6e25				  -	      ERR
      4  6e25					      ENDIF
      5  6e25		       1e		      .byte.b	30
      0  6e26					      EVAL8	30
      1  6e26				  -	      IF	(30 > 127) || (30 < -128)
      2  6e26				  -	      ECHO	"Erroneous position value", 30
      3  6e26				  -	      ERR
      4  6e26					      ENDIF
      5  6e26		       1e		      .byte.b	30
      0  6e27					      EVAL8	20
      1  6e27				  -	      IF	(20 > 127) || (20 < -128)
      2  6e27				  -	      ECHO	"Erroneous position value", 20
      3  6e27				  -	      ERR
      4  6e27					      ENDIF
      5  6e27		       14		      .byte.b	20
      0  6e28					      EVAL8	-10
      1  6e28				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e28				  -	      ECHO	"Erroneous position value", -10
      3  6e28				  -	      ERR
      4  6e28					      ENDIF
      5  6e28		       f6		      .byte.b	-10
      0  6e29					      EVAL8	-30
      1  6e29				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e29				  -	      ECHO	"Erroneous position value", -30
      3  6e29				  -	      ERR
      4  6e29					      ENDIF
      5  6e29		       e2		      .byte.b	-30
      0  6e2a					      EVAL8	0
      1  6e2a				  -	      IF	(0 > 127) || (0 < -128)
      2  6e2a				  -	      ECHO	"Erroneous position value", 0
      3  6e2a				  -	      ERR
      4  6e2a					      ENDIF
      5  6e2a		       00		      .byte.b	0
      0  6e2b					      EVAL8	0
      1  6e2b				  -	      IF	(0 > 127) || (0 < -128)
      2  6e2b				  -	      ECHO	"Erroneous position value", 0
      3  6e2b				  -	      ERR
      4  6e2b					      ENDIF
      5  6e2b		       00		      .byte.b	0
      0  6e2c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      0  6e2c					      EVAL8	-30
      1  6e2c				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e2c				  -	      ECHO	"Erroneous position value", -30
      3  6e2c				  -	      ERR
      4  6e2c					      ENDIF
      5  6e2c		       e2		      .byte.b	-30
      0  6e2d					      EVAL8	-20
      1  6e2d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6e2d				  -	      ECHO	"Erroneous position value", -20
      3  6e2d				  -	      ERR
      4  6e2d					      ENDIF
      5  6e2d		       ec		      .byte.b	-20
      0  6e2e					      EVAL8	-10
      1  6e2e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e2e				  -	      ECHO	"Erroneous position value", -10
      3  6e2e				  -	      ERR
      4  6e2e					      ENDIF
      5  6e2e		       f6		      .byte.b	-10
      0  6e2f					      EVAL8	0
      1  6e2f				  -	      IF	(0 > 127) || (0 < -128)
      2  6e2f				  -	      ECHO	"Erroneous position value", 0
      3  6e2f				  -	      ERR
      4  6e2f					      ENDIF
      5  6e2f		       00		      .byte.b	0
      0  6e30					      EVAL8	0
      1  6e30				  -	      IF	(0 > 127) || (0 < -128)
      2  6e30				  -	      ECHO	"Erroneous position value", 0
      3  6e30				  -	      ERR
      4  6e30					      ENDIF
      5  6e30		       00		      .byte.b	0
      0  6e31					      EVAL8	-10
      1  6e31				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e31				  -	      ECHO	"Erroneous position value", -10
      3  6e31				  -	      ERR
      4  6e31					      ENDIF
      5  6e31		       f6		      .byte.b	-10
      0  6e32					      EVAL8	-20
      1  6e32				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6e32				  -	      ECHO	"Erroneous position value", -20
      3  6e32				  -	      ERR
      4  6e32					      ENDIF
      5  6e32		       ec		      .byte.b	-20
      0  6e33					      EVAL8	-30
      1  6e33				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e33				  -	      ECHO	"Erroneous position value", -30
      3  6e33				  -	      ERR
      4  6e33					      ENDIF
      5  6e33		       e2		      .byte.b	-30
      0  6e34					      EVAL8	0
      1  6e34				  -	      IF	(0 > 127) || (0 < -128)
      2  6e34				  -	      ECHO	"Erroneous position value", 0
      3  6e34				  -	      ERR
      4  6e34					      ENDIF
      5  6e34		       00		      .byte.b	0
      0  6e35					      EVAL8	0
      1  6e35				  -	      IF	(0 > 127) || (0 < -128)
      2  6e35				  -	      ECHO	"Erroneous position value", 0
      3  6e35				  -	      ERR
      4  6e35					      ENDIF
      5  6e35		       00		      .byte.b	0
      0  6e36					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      0  6e36					      EVAL8	-50
      1  6e36				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6e36				  -	      ECHO	"Erroneous position value", -50
      3  6e36				  -	      ERR
      4  6e36					      ENDIF
      5  6e36		       ce		      .byte.b	-50
      0  6e37					      EVAL8	-40
      1  6e37				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6e37				  -	      ECHO	"Erroneous position value", -40
      3  6e37				  -	      ERR
      4  6e37					      ENDIF
      5  6e37		       d8		      .byte.b	-40
      0  6e38					      EVAL8	-30
      1  6e38				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e38				  -	      ECHO	"Erroneous position value", -30
      3  6e38				  -	      ERR
      4  6e38					      ENDIF
      5  6e38		       e2		      .byte.b	-30
      0  6e39					      EVAL8	-20
      1  6e39				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6e39				  -	      ECHO	"Erroneous position value", -20
      3  6e39				  -	      ERR
      4  6e39					      ENDIF
      5  6e39		       ec		      .byte.b	-20
      0  6e3a					      EVAL8	- 20
      1  6e3a				  -	      IF	(- 20 > 127) || (- 20 < -128)
      2  6e3a				  -	      ECHO	"Erroneous position value", - 20
      3  6e3a				  -	      ERR
      4  6e3a					      ENDIF
      5  6e3a		       ec		      .byte.b	- 20
      0  6e3b					      EVAL8	-30
      1  6e3b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e3b				  -	      ECHO	"Erroneous position value", -30
      3  6e3b				  -	      ERR
      4  6e3b					      ENDIF
      5  6e3b		       e2		      .byte.b	-30
      0  6e3c					      EVAL8	-40
      1  6e3c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6e3c				  -	      ECHO	"Erroneous position value", -40
      3  6e3c				  -	      ERR
      4  6e3c					      ENDIF
      5  6e3c		       d8		      .byte.b	-40
      0  6e3d					      EVAL8	-50
      1  6e3d				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6e3d				  -	      ECHO	"Erroneous position value", -50
      3  6e3d				  -	      ERR
      4  6e3d					      ENDIF
      5  6e3d		       ce		      .byte.b	-50
      0  6e3e					      EVAL8	0
      1  6e3e				  -	      IF	(0 > 127) || (0 < -128)
      2  6e3e				  -	      ECHO	"Erroneous position value", 0
      3  6e3e				  -	      ERR
      4  6e3e					      ENDIF
      5  6e3e		       00		      .byte.b	0
      0  6e3f					      EVAL8	0
      1  6e3f				  -	      IF	(0 > 127) || (0 < -128)
      2  6e3f				  -	      ECHO	"Erroneous position value", 0
      3  6e3f				  -	      ERR
      4  6e3f					      ENDIF
      5  6e3f		       00		      .byte.b	0
    167  6e40
    168  6e40
    169  6e40							;---------------------------------------------------------------------------------------------------
    170  6e40
      0  6e40					      END_BANK
      1  6e40				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  6e40				  -	      CHECK_RAM_BANK_SIZE
      3  6e40					      ELSE
      0  6e40					      CHECK_BANK_SIZE
      1  6e40		       02 40	   .TEMP      =	* - _BANK_START
 ROM bank # 28 EVALUATE size = $240 free = 447
      2  6e40					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  6e40				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6e40				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  6e40				  -	      ERR
      6  6e40					      ENDIF
      5  6e40					      ENDIF
    172  6e40
    173  6e40							;---------------------------------------------------------------------------------------------------
    174  6e40							; EOF
------- FILE ./chess.asm
------- FILE @2 WORDS.asm LEVEL 2 PASS 4
      0  6e40					      include	"@2 WORDS.asm"
      1  6e40
      0  6e40					      SLOT	2
      1  6e40
      2  6e40				  -	      IF	(2 < 0) || (2 > 3)
      3  6e40				  -	      ECHO	"Illegal bank address/segment location", 2
      4  6e40				  -	      ERR
      5  6e40					      ENDIF
      6  6e40
      7  6e40				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  6e40				   _BANK_SLOT SET	2 * 64
      9  6e40
      0  6e40					      ROMBANK	WORDS
      1  726e ????				      SEG	ROM_WORDS
      2  7000					      ORG	_ORIGIN
      3  7000					      RORG	_BANK_ADDRESS_ORIGIN
      4  7000				   _BANK_START SET	*
      5  7000				   WORDS_START SET	*
      6  7000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7000				   ROMBANK_WORDS SET	_BANK_SLOT + _CURRENT_BANK
      8  7000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7000				   _LAST_BANK SETSTR	WORDS
     10  7000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      4  7000
      5  7000
      6  7000							;---------------------------------------------------------------------------------------------------
      7  7000
      8  7000							; 'shape' indexes into tables
      9  7000
     10  7000
     11  7000
     12  7000					      MAC	bmlo
     13  7000					      .byte	<{1}
     14  7000					      ENDM
     15  7000
     16  7000					      MAC	bmhi
     17  7000					      .byte	>{1}
     18  7000					      ENDM
     19  7000
     20  7000
     21  7000					      MAC	shapevec
     22  7000					      {1}	Shape1
     23  7000					      {1}	Shape2
     24  7000					      ENDM
     25  7000
     26  7000
      0  7000					      DEF	BitmapShapeLO
      1  7000				   SLOT_BitmapShapeLO SET	_BANK_SLOT
      2  7000				   BANK_BitmapShapeLO SET	SLOT_BitmapShapeLO + _CURRENT_BANK
      3  7000				   BitmapShapeLO
      4  7000				   TEMPORARY_VAR SET	Overlay
      5  7000				   TEMPORARY_OFFSET SET	0
      6  7000				   VAR_BOUNDARY_BitmapShapeLO SET	TEMPORARY_OFFSET
      7  7000				   FUNCTION_NAME SET	BitmapShapeLO
      0  7000					      SHAPEVEC	BMLO
      0  7000					      BMLO	Shape1
      1  7000		       04		      .byte.b	<Shape1
      0  7001					      BMLO	Shape2
      1  7001		       14		      .byte.b	<Shape2
     29  7002
      0  7002					      DEF	BitmapShapeHI
      1  7002				   SLOT_BitmapShapeHI SET	_BANK_SLOT
      2  7002				   BANK_BitmapShapeHI SET	SLOT_BitmapShapeHI + _CURRENT_BANK
      3  7002				   BitmapShapeHI
      4  7002				   TEMPORARY_VAR SET	Overlay
      5  7002				   TEMPORARY_OFFSET SET	0
      6  7002				   VAR_BOUNDARY_BitmapShapeHI SET	TEMPORARY_OFFSET
      7  7002				   FUNCTION_NAME SET	BitmapShapeHI
      0  7002					      SHAPEVEC	BMHI
      0  7002					      BMHI	Shape1
      1  7002		       f8		      .byte.b	>Shape1
      0  7003					      BMHI	Shape2
      1  7003		       f8		      .byte.b	>Shape2
     32  7004
     33  7004
     34  7004
     35  7004
     36  7004				   Shape1
     37  7004							; 8 bytes --> mask ptr (-1 = none)
     38  7004							; 8 bytes --> shape ptr (-1 = none)
     39  7004
     40  7004		       ff ff ff ff*	      .byte.b	-1,-1,-1,-1,-1,-1,-1,-1	; mask (i.e., none)
     41  700c		       00 ff ff ff*	      .byte.b	0,-1,-1,-1,-1,-1,-1,-1	; shape
     42  7014
     43  7014				   Shape2
     44  7014		       00 01 ff ff*	      .byte.b	0,1,-1,-1,-1,-1,-1,-1	; mask
     45  701c		       01 02 ff ff*	      .byte.b	1,2,-1,-1,-1,-1,-1,-1	; shape
     46  7024
     47  7024
     48  7024				   MaskVector
     49  7024		       28 f8		      .word.w	Mask1
     50  7026		       28 f8		      .word.w	Mask2
     51  7028							; ...
     52  7028
     53  7028				   Mask1
     54  7028				   Mask2
     55  7028		       00 00 00 00*	      ds	ROW_BITMAP_SIZE, 0
     56  70b8
     57  70b8				   ShapeVector
     58  70b8		       be f8		      .word.w	Shape0Row0
     59  70ba		       4e f9		      .word.w	Shape1Row0
     60  70bc		       de f9		      .word.w	Shape1Row1
     61  70be							;....
     62  70be
     63  70be				   Shape0Row0
     64  70be		       ff ff ff ff*	      ds	ROW_BITMAP_SIZE, 255
     65  714e
     66  714e				   Shape1Row0
     67  714e		       ff ff ff ff*	      ds	ROW_BITMAP_SIZE, 255
     68  71de
     69  71de				   Shape1Row1
     70  71de		       ff ff ff ff*	      ds	ROW_BITMAP_SIZE, 255
     71  726e
     72  726e							;this gives 256 total, about 32 shapes max
     73  726e
     74  726e
     75  726e							;---------------------------------------------------------------------------------------------------
     76  726e
      0  726e					      END_BANK
      1  726e				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  726e				  -	      CHECK_RAM_BANK_SIZE
      3  726e					      ELSE
      0  726e					      CHECK_BANK_SIZE
      1  726e		       02 6e	   .TEMP      =	* - _BANK_START
 ROM bank # 29 WORDS size = $26e free = 401
      2  726e					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  726e				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  726e				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  726e				  -	      ERR
      6  726e					      ENDIF
      5  726e					      ENDIF
     78  726e
     79  726e							;---------------------------------------------------------------------------------------------------
     80  726e							; EOF
------- FILE ./chess.asm
    212  726e
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0  726e					      include	"SHADOW_BOARD.asm"
      1  726e							; Copyright (C)2020 Andrew Davie
      2  726e
      3  726e
      4  726e							;---------------------------------------------------------------------------------------------------
      5  726e
      0  726e					      SLOT	3
      1  726e
      2  726e				  -	      IF	(3 < 0) || (3 > 3)
      3  726e				  -	      ECHO	"Illegal bank address/segment location", 3
      4  726e				  -	      ERR
      5  726e					      ENDIF
      6  726e
      7  726e				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  726e				   _BANK_SLOT SET	3 * 64
      9  726e
      0  726e					      RAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1  726e
      2 U4600 ????				      SEG.U	RAM_BOARD
      3 U4600					      ORG	ORIGIN_RAM
      4 U4600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U4600				   _BANK_START SET	*
      6 U4600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U4600				   RAMBANK_BOARD SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U4600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U4600				   _LAST_BANK SETSTR	BOARD
     10 U4600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      8 U4600
      9 U4600		       fc 15	   ValidSquare =	ShadowValidSquare + $400
     10 U4600		       fc 79	   Board      =	ShadowBoard + $400
     11 U4600
      0 U4600					      END_BANK
      1 U4600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U4600					      CHECK_RAM_BANK_SIZE
      1 U4600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 36 BOARD size =  $0 free = $1ff
      2 U4600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U4600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U4600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U4600				  -	      ERR
      6 U4600					      ENDIF
      3 U4600				  -	      ELSE
      4 U4600				  -	      CHECK_BANK_SIZE
      5 U4600					      ENDIF
     13 U4600
     14 U4600
     15 U4600							;---------------------------------------------------------------------------------------------------
     16 U4600
      0 U4600					      SLOT	2
      1 U4600
      2 U4600				  -	      IF	(2 < 0) || (2 > 3)
      3 U4600				  -	      ECHO	"Illegal bank address/segment location", 2
      4 U4600				  -	      ERR
      5 U4600					      ENDIF
      6 U4600
      7 U4600				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8 U4600				   _BANK_SLOT SET	2 * 64
      9 U4600
      0 U4600					      ROMBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  74dd ????				      SEG	ROM_SHADOW_BOARD
      2  7400					      ORG	_ORIGIN
      3  7400					      RORG	_BANK_ADDRESS_ORIGIN
      4  7400				   _BANK_START SET	*
      5  7400				   SHADOW_BOARD_START SET	*
      6  7400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7400				   ROMBANK_SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  7400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7400				   _LAST_BANK SETSTR	SHADOW_BOARD
     10  7400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     19  7400
     20  7400							; Board is a 10 x 12 object which simplifies the generation of moves
     21  7400							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     22  7400							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     23  7400
     24  7400							;     X12 numbering
     25  7400							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     26  7400							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     27  7400							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     28  7400							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     29  7400							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     30  7400							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     31  7400							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     32  7400							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     33  7400							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     34  7400							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     35  7400							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     36  7400							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     37  7400							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     38  7400							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     39  7400							;	0   1	2   3	4   5	6   7	8   9
     40  7400							;		A   B	C   D	E   F	G   H
     41  7400
     42  7400							;     HEX X12
     43  7400							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     44  7400							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     45  7400							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     46  7400							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     47  7400							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     48  7400							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     49  7400							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     50  7400							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     51  7400							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     52  7400							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     53  7400							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     54  7400							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     55  7400							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     56  7400							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     57  7400							;	0   1	2   3	4   5	6   7	8   9
     58  7400							;		A   B	C   D	E   F	G   H
     59  7400
     60  7400
     61  7400							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     62  7400							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     63  7400							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     64  7400							; be re-used for something else - we just need to guarantee there are 21 of them there
     65  7400
      0  7400					      ALLOCATE	Valid, 120 + 80 + 21
      1  7400
      2  7400				   .NAME      SETSTR	Valid
      0  7400					      OPTIONAL_PAGEBREAK	.NAME, 120 + 80 + 21
      1  7400
      2  7400				  -	      IF	(>( * + 120 + 80 + 21 -1 )) > ( >* )
      3  7400				  -.EARLY_LOCATION SET	*
      4  7400				  -	      ALIGN	256
      5  7400				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  7400					      ENDIF
      0  7400					      DEF	Valid
      1  7400				   SLOT_Valid SET	_BANK_SLOT
      2  7400				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  7400				   Valid
      4  7400				   TEMPORARY_VAR SET	Overlay
      5  7400				   TEMPORARY_OFFSET SET	0
      6  7400				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  7400				   FUNCTION_NAME SET	Valid
      5  7400
     67  7400		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     68  7415							; Note, we will never index INTO the above bytes - x will always be >= 21
     69  7415							; We just need to make sure that the actual indexing will not have an address before
     70  7415							; the index of outside the page.
     71  7415
      0  7415					      DEF	ShadowValidSquare
      1  7415				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  7415				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  7415				   ShadowValidSquare
      4  7415				   TEMPORARY_VAR SET	Overlay
      5  7415				   TEMPORARY_OFFSET SET	0
      6  7415				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  7415				   FUNCTION_NAME SET	ShadowValidSquare
     73  7415
     74  7415
     75  7415							; Use this table to
     76  7415							;   a) Determine if a square is valid (-1 = NO)
     77  7415							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     78  7415							;	if a white pawn on square "x" can move "up" the board.
     79  7415
     80  7415		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     81  741f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     82  7429		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     83  7433		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     84  743d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     85  7447		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     86  7451		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     87  745b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     88  7465		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     89  746f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     90  7479
      0  7479					      DEF	ShadowBoard
      1  7479				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  7479				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  7479				   ShadowBoard
      4  7479				   TEMPORARY_VAR SET	Overlay
      5  7479				   TEMPORARY_OFFSET SET	0
      6  7479				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  7479				   FUNCTION_NAME SET	ShadowBoard
     92  7479
     93  7479							; A 10X10... we should never write using invalid square
     94  7479							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     95  7479							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     96  7479
     97  7479		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     98  7483		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     99  748d
    100  748d					      REPEAT	8
    101  748d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  748d					      REPEND
    101  7497		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  7497					      REPEND
    101  74a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74a1					      REPEND
    101  74ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74ab					      REPEND
    101  74b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74b5					      REPEND
    101  74bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74bf					      REPEND
    101  74c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74c9					      REPEND
    101  74d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    102  74dd					      REPEND
    103  74dd
    104  74dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
    105  74dd
    106  74dd
    107  74dd							;---------------------------------------------------------------------------------------------------
    108  74dd							; EOF
------- FILE ./chess.asm
    214  74dd
    215  74dd
    216  74dd
------- FILE TitleScreen.asm LEVEL 2 PASS 4
      0  74dd					      include	"TitleScreen.asm"
      0  74dd					      SLOT	1
      1  74dd
      2  74dd				  -	      IF	(1 < 0) || (1 > 3)
      3  74dd				  -	      ECHO	"Illegal bank address/segment location", 1
      4  74dd				  -	      ERR
      5  74dd					      ENDIF
      6  74dd
      7  74dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  74dd				   _BANK_SLOT SET	1 * 64
      9  74dd
      0  74dd					      ROMBANK	TITLESCREEN
      1  7ab0 ????				      SEG	ROM_TITLESCREEN
      2  7800					      ORG	_ORIGIN
      3  7800					      RORG	_BANK_ADDRESS_ORIGIN
      4  7800				   _BANK_START SET	*
      5  7800				   TITLESCREEN_START SET	*
      6  7800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7800				   ROMBANK_TITLESCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  7800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7800				   _LAST_BANK SETSTR	TITLESCREEN
     10  7800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      3  7800
      4  7800
      5  7800							;---------------------------------------------------------------------------------------------------
      6  7800
      7  7800				   OverscanTime2
      8  7800		       27 1a		      .byte.b	39, 26
      9  7802		       10 20		      .byte.b	16, 32
     10  7804
     11  7804							;colvec
     12  7804							;    .word colr_ntsc2, colr_pal
     13  7804
     14  7804
     15  7804		       2a 32	   VBlankTime .byte.b	42,50
     16  7806
      0  7806					      DEF	TitleScreen
      1  7806				   SLOT_TitleScreen SET	_BANK_SLOT
      2  7806				   BANK_TitleScreen SET	SLOT_TitleScreen + _CURRENT_BANK
      3  7806				   TitleScreen
      4  7806				   TEMPORARY_VAR SET	Overlay
      5  7806				   TEMPORARY_OFFSET SET	0
      6  7806				   VAR_BOUNDARY_TitleScreen SET	TEMPORARY_OFFSET
      7  7806				   FUNCTION_NAME SET	TitleScreen
     18  7806					      SUBROUTINE
     19  7806
      0  7806					      VAR	__colour_table, 2
      1  7806		       00 a7	   __colour_table =	TEMPORARY_VAR
      2  7806				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7806
      4  7806				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7806				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7806				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7806					      ENDIF
      8  7806				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  7806				  -VNAME      SETSTR	__colour_table
     10  7806				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  7806				  -	      ERR
     12  7806					      ENDIF
     21  7806
     22  7806							; Start of new frame
     23  7806
     24  7806							; Start of vertical blank processing
     25  7806
     26  7806				   TitleSequence
     27  7806
     28  7806
     29  7806		       a9 9f		      lda	#BANK_TitleData
     30  7808		       85 3f		      sta	SET_BANK
     31  780a
     32  780a
     33  780a		       a9 00		      lda	#%00000000
     34  780c		       85 4a		      sta	CTRLPF
     35  780e
     36  780e		       a9 c0		      lda	#$C0
     37  7810		       85 49		      sta	COLUBK
     38  7812
     39  7812		       a2 00		      ldx	#0	;Platform
     40  7814		       a9 00		      lda	#<colr_ntsc2	;colvec,x
     41  7816		       85 a7		      sta	__colour_table
     42  7818		       a9 f5		      lda	#>colr_ntsc2	;colvec+1,x
     43  781a		       85 a8		      sta	__colour_table+1
     44  781c
     45  781c							;		  sta rndHi
     46  781c							;		  sta rnd
     47  781c
     48  781c
     49  781c				  -	      IF	0
     50  781c				  -	      lda	#0
     51  781c				  -	      sta	digit
     52  781c				  -	      lda	#$10
     53  781c				  -	      sta	digit+1
     54  781c				  -	      lda	#$20
     55  781c				  -	      sta	digit+2
     56  781c					      ENDIF
     57  781c
     58  781c
     59  781c
     60  781c
     61  781c							;RESYNC
     62  781c
     63  781c				   RestartFrame0
     64  781c
     65  781c				  -	      IF	0
     66  781c				  -	      ldx	#2
     67  781c				  -rollcols   clc
     68  781c				  -	      lda	digit+2
     69  781c				  -	      adc	#$10
     70  781c				  -	      sta	digit+2
     71  781c				  -	      bcc	finxc
     72  781c				  -	      dex
     73  781c				  -	      bpl	rollcols
     74  781c				  -finxc
     75  781c					      ENDIF
     76  781c
      0  781c					      DEF	RestartFrame
      1  781c				   SLOT_RestartFrame SET	_BANK_SLOT
      2  781c				   BANK_RestartFrame SET	SLOT_RestartFrame + _CURRENT_BANK
      3  781c				   RestartFrame
      4  781c				   TEMPORARY_VAR SET	Overlay
      5  781c				   TEMPORARY_OFFSET SET	0
      6  781c				   VAR_BOUNDARY_RestartFrame SET	TEMPORARY_OFFSET
      7  781c				   FUNCTION_NAME SET	RestartFrame
     78  781c		       a9 00		      LDA	#0
     79  781e		       a9 0e		      lda	#%1110	; VSYNC ON
     80  7820		       85 42	   .loopVSync2 sta	WSYNC
     81  7822		       85 40		      sta	VSYNC
     82  7824		       4a		      lsr
     83  7825		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     84  7827
     85  7827							;------------------------------------------------------------------
     86  7827
     87  7827		       a2 00		      ldx	#0	;Platform
     88  7829		       bc 04 f4 	      ldy	VBlankTime,x
     89  782c		       8c 96 02 	      sty	TIM64T
     90  782f
     91  782f
     92  782f				  -	      IF	0
     93  782f				  -	      lda	SWCHB
     94  782f				  -	      rol
     95  782f				  -	      rol
     96  782f				  -	      rol
     97  782f				  -	      and	#%11
     98  782f				  -	      eor	#PAL
     99  782f				  -	      cmp	#0	;Platform
    100  782f				  -	      beq	platOK
    101  782f				  -			;sta Platform
    102  782f				  -	      jmp	TitleSequence
    103  782f				  -platOK
    104  782f					      ENDIF
    105  782f
    106  782f		       e6 82	   k2	      inc	rnd
    107  7831		       f0 fc		      beq	k2
    108  7833
    109  7833
    110  7833		       85 42	   VerticalBlank sta	WSYNC
    111  7835		       ad 84 02 	      lda	INTIM
    112  7838		       d0 f9		      bne	VerticalBlank
    113  783a		       85 41		      sta	VBLANK
    114  783c
    115  783c		       a9 00		      lda	#$0
    116  783e		       85 49		      sta	COLUBK
    117  7840
    118  7840							;------------------------------------------------------------------
    119  7840
    120  7840							; Do X scanlines of color-changing (our picture)
    121  7840
    122  7840		       a0 c9		      ldy	#67*3	; this counts our scanline number
    123  7842				   SokoLogo
    124  7842
    125  7842
    126  7842		       a9 24		      lda	#$24
    127  7844
    128  7844		       85 42		      sta	WSYNC
    129  7846		       85 48		      sta	COLUPF	; 3
    130  7848
    131  7848		       b9 00 f8 	      lda	COL_0,y	; 5
    132  784b		       85 4d		      sta	PF0	; 3   @11
    133  784d		       b9 cc f8 	      lda	COL_1,y	; 5
    134  7850		       85 4e		      sta	PF1	; 3   @19
    135  7852		       b9 98 f9 	      lda	COL_2,y	; 5
    136  7855		       85 4f		      sta	PF2	; 3   @27
    137  7857
    138  7857		       b9 00 f8 	      lda	COL_0,y	; 5
    139  785a		       0a		      asl
    140  785b		       0a		      asl
    141  785c		       0a		      asl
    142  785d		       0a		      asl
    143  785e		       85 4d		      sta	PF0	; 3   @35
    144  7860							;		  SLEEP 2      ; @37
    145  7860		       b9 64 fa 	      lda	COL_3,y	; 5
    146  7863		       85 4e		      sta	PF1	; 3   @45
    147  7865							;		  SLEEP 3      ; @45
    148  7865		       b9 30 fb 	      lda	COL_4,y	; 5
    149  7868		       85 4f		      sta	PF2	; 3
    150  786a
    151  786a		       88		      dey
    152  786b
    153  786b		       a9 68		      lda	#$68
    154  786d
    155  786d		       85 42		      sta	WSYNC
    156  786f		       85 48		      sta	COLUPF	; 3
    157  7871
    158  7871		       b9 00 f8 	      lda	COL_0,y	; 5
    159  7874		       85 4d		      sta	PF0	; 3   @11
    160  7876		       b9 cc f8 	      lda	COL_1,y	; 5
    161  7879		       85 4e		      sta	PF1	; 3   @19
    162  787b		       b9 98 f9 	      lda	COL_2,y	; 5
    163  787e		       85 4f		      sta	PF2	; 3   @27
    164  7880
    165  7880		       b9 00 f8 	      lda	COL_0,y	; 5
    166  7883		       0a		      asl
    167  7884		       0a		      asl
    168  7885		       0a		      asl
    169  7886		       0a		      asl
    170  7887		       85 4d		      sta	PF0	; 3   @35
    171  7889							;		  SLEEP 2      ; @37
    172  7889		       b9 64 fa 	      lda	COL_3,y	; 5
    173  788c		       85 4e		      sta	PF1	; 3   @45
    174  788e							;		  SLEEP 3      ; @45
    175  788e		       b9 30 fb 	      lda	COL_4,y	; 5
    176  7891		       85 4f		      sta	PF2	; 3
    177  7893
    178  7893		       88		      dey
    179  7894
    180  7894
    181  7894		       a9 d6		      lda	#$D6
    182  7896
    183  7896		       85 42		      sta	WSYNC
    184  7898		       85 48		      sta	COLUPF	; 3
    185  789a
    186  789a		       b9 00 f8 	      lda	COL_0,y	; 5
    187  789d		       85 4d		      sta	PF0	; 3   @11
    188  789f		       b9 cc f8 	      lda	COL_1,y	; 5
    189  78a2		       85 4e		      sta	PF1	; 3   @19
    190  78a4		       b9 98 f9 	      lda	COL_2,y	; 5
    191  78a7		       85 4f		      sta	PF2	; 3   @27
    192  78a9
    193  78a9		       b9 00 f8 	      lda	COL_0,y	; 5
    194  78ac		       0a		      asl
    195  78ad		       0a		      asl
    196  78ae		       0a		      asl
    197  78af		       0a		      asl
    198  78b0		       85 4d		      sta	PF0	; 3   @35
    199  78b2							;		  SLEEP 2      ; @37
    200  78b2		       b9 64 fa 	      lda	COL_3,y	; 5
    201  78b5		       85 4e		      sta	PF1	; 3   @45
    202  78b7							;		  SLEEP 3      ; @45
    203  78b7		       b9 30 fb 	      lda	COL_4,y	; 5
    204  78ba		       85 4f		      sta	PF2	; 3
    205  78bc
    206  78bc
    207  78bc
    208  78bc		       88		      dey		; 2
    209  78bd		       d0 83		      bne	SokoLogo	; 2(3)
    210  78bf
    211  78bf							;lda #0
    212  78bf							;sta PF0
    213  78bf							;sta PF1
    214  78bf							;sta PF2
    215  78bf
    216  78bf		       a2 00		      ldx	#0	;Platform
    217  78c1		       86 4d		      stx	PF0
    218  78c3		       86 4e		      stx	PF1
    219  78c5		       86 4f		      stx	PF2
    220  78c7
    221  78c7		       85 42		      sta	WSYNC
    222  78c9		       85 42		      sta	WSYNC
    223  78cb		       85 42		      sta	WSYNC
    224  78cd		       85 42		      sta	WSYNC
    225  78cf
    226  78cf		       86 49		      stx	COLUBK
    227  78d1		       bd 00 f4 	      lda	OverscanTime2,x
    228  78d4		       8d 96 02 	      sta	TIM64T
    229  78d7
    230  78d7				  -	      IF	0
    231  78d7				  -	      sta	WSYNC
    232  78d7				  -	      sta	WSYNC
    233  78d7				  -	      sta	WSYNC
    234  78d7				  -	      sta	WSYNC
    235  78d7				  -	      sta	WSYNC
    236  78d7				  -	      SLEEP	8
    237  78d7				  -	      jsr	SokoScreen
    238  78d7				  -
    239  78d7				  -	      lda	#0
    240  78d7				  -	      sta	BoardScrollX
    241  78d7				  -	      sta	BoardScrollY
    242  78d7					      ENDIF
    243  78d7
    244  78d7							;		ldy #63
    245  78d7							;bot2		 sta WSYNC
    246  78d7							;		dey
    247  78d7							;		bpl bot2
    248  78d7
    249  78d7							;--------------------------------------------------------------------------
    250  78d7
    251  78d7		       a9 00		      lda	#0
    252  78d9		       85 4d		      sta	PF0
    253  78db		       85 4e		      sta	PF1
    254  78dd		       85 4f		      sta	PF2
    255  78df
    256  78df
      0  78df					      NEXT_RANDOM
      1  78df
      2  78df		       a5 82		      lda	rnd
      3  78e1		       4a		      lsr
      4  78e2		       90 02		      bcc	.skipEOR
      5  78e4		       49 b4		      eor	#RND_EOR_VAL
      6  78e6		       85 82	   .skipEOR   sta	rnd
      7  78e8
    258  78e8
    259  78e8							; D1 VBLANK turns off beam
    260  78e8							; It needs to be turned on 37 scanlines later
    261  78e8
    262  78e8				   oscan
    263  78e8		       ad 84 02 	      lda	INTIM
    264  78eb		       d0 fb		      bne	oscan
    265  78ed
    266  78ed		       a9 42		      lda	#%01000010	; bit6 is not required
    267  78ef		       85 41		      sta	VBLANK	; end of screen - enter blanking
    268  78f1
    269  78f1				  -	      IF	0
    270  78f1				  -	      inc	rnd
    271  78f1				  -	      bne	rdd
    272  78f1				  -	      inc	rndHi
    273  78f1				  -rdd
    274  78f1				  -
    275  78f1				  -	      dec	digitick
    276  78f1				  -	      bpl	ret2
    277  78f1				  -	      lda	#40
    278  78f1				  -	      sta	digitick
    279  78f1				  -
    280  78f1				  -	      jsr	Random
    281  78f1				  -	      and	#3
    282  78f1				  -	      beq	ret2
    283  78f1				  -	      tax
    284  78f1				  -	      jsr	Random
    285  78f1				  -	      and	#$F0
    286  78f1				  -	      sta	digit-1,x
    287  78f1				  -	      jmp	RestartFrame0
    288  78f1				  -
    289  78f1				  -ret2
    290  78f1					      ENDIF
    291  78f1
    292  78f1
    293  78f1		       a5 4c		      lda	INPT4
    294  78f3		       10 03		      bpl	ret
    295  78f5
    296  78f5		       4c 1c f4 	      jmp	RestartFrame
    297  78f8
    298  78f8				   ret
    299  78f8		       60		      rts
    300  78f9
    301  78f9
    302  78f9
    303  78f9					      MAC	lumtable
    304  78f9							; {4} MIN LUM 1
    305  78f9							; {5} MIN LUM 2
    306  78f9							; {6} MIN LUM 3
    307  78f9
    308  78f9				   .LUM1      SET	{4}*256
    309  78f9				   .LUM2      SET	{5}*256
    310  78f9				   .LUM3      SET	{6}*256
    311  78f9
    312  78f9				   .STEP1     =	(256*({7}-{4}))/72
    313  78f9				   .STEP2     =	(256*({8}-{5}))/72
    314  78f9				   .STEP3     =	(256*({9}-{6}))/72
    315  78f9
    316  78f9					      REPEAT	72
    317  78f9					      .byte	{1}+(.LUM1/256)
    318  78f9					      .byte	{2}+(.LUM2/256)
    319  78f9					      .byte	{3}+(.LUM3/256)
    320  78f9
    321  78f9							;    ECHO {1}+(.LUM1/256)
    322  78f9							;    ECHO {2}+(.LUM1/256)
    323  78f9							;    ECHO {3}+(.LUM1/256)
    324  78f9
    325  78f9				   .LUM1      SET	.LUM1 + .STEP1
    326  78f9				   .LUM2      SET	.LUM2 + .STEP2
    327  78f9				   .LUM3      SET	.LUM3 + .STEP3
    328  78f9					      REPEND
    329  78f9					      ENDM		;{1}{2}{3} base colours
    330  78f9
    331  78f9							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    332  78f9							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    333  78f9
    334  7900		       00 00 00 00*	      align	256
    335  7900							;    ECHO "NTSC LUMS"
    336  7900				   colr_ntsc2
      0  7900					      LUMTABLE	$90,$10,$20,$4,$6,$8,$4,$6,$8
      1  7900
      2  7900
      3  7900
      4  7900
      5  7900				   .LUM1      SET	$4*256
      6  7900				   .LUM2      SET	$6*256
      7  7900				   .LUM3      SET	$8*256
      8  7900
      9  7900		       00 00	   .STEP1     =	(256*($4-$4))/72
     10  7900		       00 00	   .STEP2     =	(256*($6-$6))/72
     11  7900		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  7900
     13  7900					      REPEAT	72
     14  7900		       94		      .byte.b	$90+(.LUM1/256)
     15  7901		       16		      .byte.b	$10+(.LUM2/256)
     16  7902		       28		      .byte.b	$20+(.LUM3/256)
     17  7903
     18  7903
     19  7903
     20  7903
     21  7903
     22  7903				   .LUM1      SET	.LUM1 + .STEP1
     23  7903				   .LUM2      SET	.LUM2 + .STEP2
     24  7903				   .LUM3      SET	.LUM3 + .STEP3
     13  7903					      REPEND
     14  7903		       94		      .byte.b	$90+(.LUM1/256)
     15  7904		       16		      .byte.b	$10+(.LUM2/256)
     16  7905		       28		      .byte.b	$20+(.LUM3/256)
     17  7906
     18  7906
     19  7906
     20  7906
     21  7906
     22  7906				   .LUM1      SET	.LUM1 + .STEP1
     23  7906				   .LUM2      SET	.LUM2 + .STEP2
     24  7906				   .LUM3      SET	.LUM3 + .STEP3
     13  7906					      REPEND
     14  7906		       94		      .byte.b	$90+(.LUM1/256)
     15  7907		       16		      .byte.b	$10+(.LUM2/256)
     16  7908		       28		      .byte.b	$20+(.LUM3/256)
     17  7909
     18  7909
     19  7909
     20  7909
     21  7909
     22  7909				   .LUM1      SET	.LUM1 + .STEP1
     23  7909				   .LUM2      SET	.LUM2 + .STEP2
     24  7909				   .LUM3      SET	.LUM3 + .STEP3
     13  7909					      REPEND
     14  7909		       94		      .byte.b	$90+(.LUM1/256)
     15  790a		       16		      .byte.b	$10+(.LUM2/256)
     16  790b		       28		      .byte.b	$20+(.LUM3/256)
     17  790c
     18  790c
     19  790c
     20  790c
     21  790c
     22  790c				   .LUM1      SET	.LUM1 + .STEP1
     23  790c				   .LUM2      SET	.LUM2 + .STEP2
     24  790c				   .LUM3      SET	.LUM3 + .STEP3
     13  790c					      REPEND
     14  790c		       94		      .byte.b	$90+(.LUM1/256)
     15  790d		       16		      .byte.b	$10+(.LUM2/256)
     16  790e		       28		      .byte.b	$20+(.LUM3/256)
     17  790f
     18  790f
     19  790f
     20  790f
     21  790f
     22  790f				   .LUM1      SET	.LUM1 + .STEP1
     23  790f				   .LUM2      SET	.LUM2 + .STEP2
     24  790f				   .LUM3      SET	.LUM3 + .STEP3
     13  790f					      REPEND
     14  790f		       94		      .byte.b	$90+(.LUM1/256)
     15  7910		       16		      .byte.b	$10+(.LUM2/256)
     16  7911		       28		      .byte.b	$20+(.LUM3/256)
     17  7912
     18  7912
     19  7912
     20  7912
     21  7912
     22  7912				   .LUM1      SET	.LUM1 + .STEP1
     23  7912				   .LUM2      SET	.LUM2 + .STEP2
     24  7912				   .LUM3      SET	.LUM3 + .STEP3
     13  7912					      REPEND
     14  7912		       94		      .byte.b	$90+(.LUM1/256)
     15  7913		       16		      .byte.b	$10+(.LUM2/256)
     16  7914		       28		      .byte.b	$20+(.LUM3/256)
     17  7915
     18  7915
     19  7915
     20  7915
     21  7915
     22  7915				   .LUM1      SET	.LUM1 + .STEP1
     23  7915				   .LUM2      SET	.LUM2 + .STEP2
     24  7915				   .LUM3      SET	.LUM3 + .STEP3
     13  7915					      REPEND
     14  7915		       94		      .byte.b	$90+(.LUM1/256)
     15  7916		       16		      .byte.b	$10+(.LUM2/256)
     16  7917		       28		      .byte.b	$20+(.LUM3/256)
     17  7918
     18  7918
     19  7918
     20  7918
     21  7918
     22  7918				   .LUM1      SET	.LUM1 + .STEP1
     23  7918				   .LUM2      SET	.LUM2 + .STEP2
     24  7918				   .LUM3      SET	.LUM3 + .STEP3
     13  7918					      REPEND
     14  7918		       94		      .byte.b	$90+(.LUM1/256)
     15  7919		       16		      .byte.b	$10+(.LUM2/256)
     16  791a		       28		      .byte.b	$20+(.LUM3/256)
     17  791b
     18  791b
     19  791b
     20  791b
     21  791b
     22  791b				   .LUM1      SET	.LUM1 + .STEP1
     23  791b				   .LUM2      SET	.LUM2 + .STEP2
     24  791b				   .LUM3      SET	.LUM3 + .STEP3
     13  791b					      REPEND
     14  791b		       94		      .byte.b	$90+(.LUM1/256)
     15  791c		       16		      .byte.b	$10+(.LUM2/256)
     16  791d		       28		      .byte.b	$20+(.LUM3/256)
     17  791e
     18  791e
     19  791e
     20  791e
     21  791e
     22  791e				   .LUM1      SET	.LUM1 + .STEP1
     23  791e				   .LUM2      SET	.LUM2 + .STEP2
     24  791e				   .LUM3      SET	.LUM3 + .STEP3
     13  791e					      REPEND
     14  791e		       94		      .byte.b	$90+(.LUM1/256)
     15  791f		       16		      .byte.b	$10+(.LUM2/256)
     16  7920		       28		      .byte.b	$20+(.LUM3/256)
     17  7921
     18  7921
     19  7921
     20  7921
     21  7921
     22  7921				   .LUM1      SET	.LUM1 + .STEP1
     23  7921				   .LUM2      SET	.LUM2 + .STEP2
     24  7921				   .LUM3      SET	.LUM3 + .STEP3
     13  7921					      REPEND
     14  7921		       94		      .byte.b	$90+(.LUM1/256)
     15  7922		       16		      .byte.b	$10+(.LUM2/256)
     16  7923		       28		      .byte.b	$20+(.LUM3/256)
     17  7924
     18  7924
     19  7924
     20  7924
     21  7924
     22  7924				   .LUM1      SET	.LUM1 + .STEP1
     23  7924				   .LUM2      SET	.LUM2 + .STEP2
     24  7924				   .LUM3      SET	.LUM3 + .STEP3
     13  7924					      REPEND
     14  7924		       94		      .byte.b	$90+(.LUM1/256)
     15  7925		       16		      .byte.b	$10+(.LUM2/256)
     16  7926		       28		      .byte.b	$20+(.LUM3/256)
     17  7927
     18  7927
     19  7927
     20  7927
     21  7927
     22  7927				   .LUM1      SET	.LUM1 + .STEP1
     23  7927				   .LUM2      SET	.LUM2 + .STEP2
     24  7927				   .LUM3      SET	.LUM3 + .STEP3
     13  7927					      REPEND
     14  7927		       94		      .byte.b	$90+(.LUM1/256)
     15  7928		       16		      .byte.b	$10+(.LUM2/256)
     16  7929		       28		      .byte.b	$20+(.LUM3/256)
     17  792a
     18  792a
     19  792a
     20  792a
     21  792a
     22  792a				   .LUM1      SET	.LUM1 + .STEP1
     23  792a				   .LUM2      SET	.LUM2 + .STEP2
     24  792a				   .LUM3      SET	.LUM3 + .STEP3
     13  792a					      REPEND
     14  792a		       94		      .byte.b	$90+(.LUM1/256)
     15  792b		       16		      .byte.b	$10+(.LUM2/256)
     16  792c		       28		      .byte.b	$20+(.LUM3/256)
     17  792d
     18  792d
     19  792d
     20  792d
     21  792d
     22  792d				   .LUM1      SET	.LUM1 + .STEP1
     23  792d				   .LUM2      SET	.LUM2 + .STEP2
     24  792d				   .LUM3      SET	.LUM3 + .STEP3
     13  792d					      REPEND
     14  792d		       94		      .byte.b	$90+(.LUM1/256)
     15  792e		       16		      .byte.b	$10+(.LUM2/256)
     16  792f		       28		      .byte.b	$20+(.LUM3/256)
     17  7930
     18  7930
     19  7930
     20  7930
     21  7930
     22  7930				   .LUM1      SET	.LUM1 + .STEP1
     23  7930				   .LUM2      SET	.LUM2 + .STEP2
     24  7930				   .LUM3      SET	.LUM3 + .STEP3
     13  7930					      REPEND
     14  7930		       94		      .byte.b	$90+(.LUM1/256)
     15  7931		       16		      .byte.b	$10+(.LUM2/256)
     16  7932		       28		      .byte.b	$20+(.LUM3/256)
     17  7933
     18  7933
     19  7933
     20  7933
     21  7933
     22  7933				   .LUM1      SET	.LUM1 + .STEP1
     23  7933				   .LUM2      SET	.LUM2 + .STEP2
     24  7933				   .LUM3      SET	.LUM3 + .STEP3
     13  7933					      REPEND
     14  7933		       94		      .byte.b	$90+(.LUM1/256)
     15  7934		       16		      .byte.b	$10+(.LUM2/256)
     16  7935		       28		      .byte.b	$20+(.LUM3/256)
     17  7936
     18  7936
     19  7936
     20  7936
     21  7936
     22  7936				   .LUM1      SET	.LUM1 + .STEP1
     23  7936				   .LUM2      SET	.LUM2 + .STEP2
     24  7936				   .LUM3      SET	.LUM3 + .STEP3
     13  7936					      REPEND
     14  7936		       94		      .byte.b	$90+(.LUM1/256)
     15  7937		       16		      .byte.b	$10+(.LUM2/256)
     16  7938		       28		      .byte.b	$20+(.LUM3/256)
     17  7939
     18  7939
     19  7939
     20  7939
     21  7939
     22  7939				   .LUM1      SET	.LUM1 + .STEP1
     23  7939				   .LUM2      SET	.LUM2 + .STEP2
     24  7939				   .LUM3      SET	.LUM3 + .STEP3
     13  7939					      REPEND
     14  7939		       94		      .byte.b	$90+(.LUM1/256)
     15  793a		       16		      .byte.b	$10+(.LUM2/256)
     16  793b		       28		      .byte.b	$20+(.LUM3/256)
     17  793c
     18  793c
     19  793c
     20  793c
     21  793c
     22  793c				   .LUM1      SET	.LUM1 + .STEP1
     23  793c				   .LUM2      SET	.LUM2 + .STEP2
     24  793c				   .LUM3      SET	.LUM3 + .STEP3
     13  793c					      REPEND
     14  793c		       94		      .byte.b	$90+(.LUM1/256)
     15  793d		       16		      .byte.b	$10+(.LUM2/256)
     16  793e		       28		      .byte.b	$20+(.LUM3/256)
     17  793f
     18  793f
     19  793f
     20  793f
     21  793f
     22  793f				   .LUM1      SET	.LUM1 + .STEP1
     23  793f				   .LUM2      SET	.LUM2 + .STEP2
     24  793f				   .LUM3      SET	.LUM3 + .STEP3
     13  793f					      REPEND
     14  793f		       94		      .byte.b	$90+(.LUM1/256)
     15  7940		       16		      .byte.b	$10+(.LUM2/256)
     16  7941		       28		      .byte.b	$20+(.LUM3/256)
     17  7942
     18  7942
     19  7942
     20  7942
     21  7942
     22  7942				   .LUM1      SET	.LUM1 + .STEP1
     23  7942				   .LUM2      SET	.LUM2 + .STEP2
     24  7942				   .LUM3      SET	.LUM3 + .STEP3
     13  7942					      REPEND
     14  7942		       94		      .byte.b	$90+(.LUM1/256)
     15  7943		       16		      .byte.b	$10+(.LUM2/256)
     16  7944		       28		      .byte.b	$20+(.LUM3/256)
     17  7945
     18  7945
     19  7945
     20  7945
     21  7945
     22  7945				   .LUM1      SET	.LUM1 + .STEP1
     23  7945				   .LUM2      SET	.LUM2 + .STEP2
     24  7945				   .LUM3      SET	.LUM3 + .STEP3
     13  7945					      REPEND
     14  7945		       94		      .byte.b	$90+(.LUM1/256)
     15  7946		       16		      .byte.b	$10+(.LUM2/256)
     16  7947		       28		      .byte.b	$20+(.LUM3/256)
     17  7948
     18  7948
     19  7948
     20  7948
     21  7948
     22  7948				   .LUM1      SET	.LUM1 + .STEP1
     23  7948				   .LUM2      SET	.LUM2 + .STEP2
     24  7948				   .LUM3      SET	.LUM3 + .STEP3
     13  7948					      REPEND
     14  7948		       94		      .byte.b	$90+(.LUM1/256)
     15  7949		       16		      .byte.b	$10+(.LUM2/256)
     16  794a		       28		      .byte.b	$20+(.LUM3/256)
     17  794b
     18  794b
     19  794b
     20  794b
     21  794b
     22  794b				   .LUM1      SET	.LUM1 + .STEP1
     23  794b				   .LUM2      SET	.LUM2 + .STEP2
     24  794b				   .LUM3      SET	.LUM3 + .STEP3
     13  794b					      REPEND
     14  794b		       94		      .byte.b	$90+(.LUM1/256)
     15  794c		       16		      .byte.b	$10+(.LUM2/256)
     16  794d		       28		      .byte.b	$20+(.LUM3/256)
     17  794e
     18  794e
     19  794e
     20  794e
     21  794e
     22  794e				   .LUM1      SET	.LUM1 + .STEP1
     23  794e				   .LUM2      SET	.LUM2 + .STEP2
     24  794e				   .LUM3      SET	.LUM3 + .STEP3
     13  794e					      REPEND
     14  794e		       94		      .byte.b	$90+(.LUM1/256)
     15  794f		       16		      .byte.b	$10+(.LUM2/256)
     16  7950		       28		      .byte.b	$20+(.LUM3/256)
     17  7951
     18  7951
     19  7951
     20  7951
     21  7951
     22  7951				   .LUM1      SET	.LUM1 + .STEP1
     23  7951				   .LUM2      SET	.LUM2 + .STEP2
     24  7951				   .LUM3      SET	.LUM3 + .STEP3
     13  7951					      REPEND
     14  7951		       94		      .byte.b	$90+(.LUM1/256)
     15  7952		       16		      .byte.b	$10+(.LUM2/256)
     16  7953		       28		      .byte.b	$20+(.LUM3/256)
     17  7954
     18  7954
     19  7954
     20  7954
     21  7954
     22  7954				   .LUM1      SET	.LUM1 + .STEP1
     23  7954				   .LUM2      SET	.LUM2 + .STEP2
     24  7954				   .LUM3      SET	.LUM3 + .STEP3
     13  7954					      REPEND
     14  7954		       94		      .byte.b	$90+(.LUM1/256)
     15  7955		       16		      .byte.b	$10+(.LUM2/256)
     16  7956		       28		      .byte.b	$20+(.LUM3/256)
     17  7957
     18  7957
     19  7957
     20  7957
     21  7957
     22  7957				   .LUM1      SET	.LUM1 + .STEP1
     23  7957				   .LUM2      SET	.LUM2 + .STEP2
     24  7957				   .LUM3      SET	.LUM3 + .STEP3
     13  7957					      REPEND
     14  7957		       94		      .byte.b	$90+(.LUM1/256)
     15  7958		       16		      .byte.b	$10+(.LUM2/256)
     16  7959		       28		      .byte.b	$20+(.LUM3/256)
     17  795a
     18  795a
     19  795a
     20  795a
     21  795a
     22  795a				   .LUM1      SET	.LUM1 + .STEP1
     23  795a				   .LUM2      SET	.LUM2 + .STEP2
     24  795a				   .LUM3      SET	.LUM3 + .STEP3
     13  795a					      REPEND
     14  795a		       94		      .byte.b	$90+(.LUM1/256)
     15  795b		       16		      .byte.b	$10+(.LUM2/256)
     16  795c		       28		      .byte.b	$20+(.LUM3/256)
     17  795d
     18  795d
     19  795d
     20  795d
     21  795d
     22  795d				   .LUM1      SET	.LUM1 + .STEP1
     23  795d				   .LUM2      SET	.LUM2 + .STEP2
     24  795d				   .LUM3      SET	.LUM3 + .STEP3
     13  795d					      REPEND
     14  795d		       94		      .byte.b	$90+(.LUM1/256)
     15  795e		       16		      .byte.b	$10+(.LUM2/256)
     16  795f		       28		      .byte.b	$20+(.LUM3/256)
     17  7960
     18  7960
     19  7960
     20  7960
     21  7960
     22  7960				   .LUM1      SET	.LUM1 + .STEP1
     23  7960				   .LUM2      SET	.LUM2 + .STEP2
     24  7960				   .LUM3      SET	.LUM3 + .STEP3
     13  7960					      REPEND
     14  7960		       94		      .byte.b	$90+(.LUM1/256)
     15  7961		       16		      .byte.b	$10+(.LUM2/256)
     16  7962		       28		      .byte.b	$20+(.LUM3/256)
     17  7963
     18  7963
     19  7963
     20  7963
     21  7963
     22  7963				   .LUM1      SET	.LUM1 + .STEP1
     23  7963				   .LUM2      SET	.LUM2 + .STEP2
     24  7963				   .LUM3      SET	.LUM3 + .STEP3
     13  7963					      REPEND
     14  7963		       94		      .byte.b	$90+(.LUM1/256)
     15  7964		       16		      .byte.b	$10+(.LUM2/256)
     16  7965		       28		      .byte.b	$20+(.LUM3/256)
     17  7966
     18  7966
     19  7966
     20  7966
     21  7966
     22  7966				   .LUM1      SET	.LUM1 + .STEP1
     23  7966				   .LUM2      SET	.LUM2 + .STEP2
     24  7966				   .LUM3      SET	.LUM3 + .STEP3
     13  7966					      REPEND
     14  7966		       94		      .byte.b	$90+(.LUM1/256)
     15  7967		       16		      .byte.b	$10+(.LUM2/256)
     16  7968		       28		      .byte.b	$20+(.LUM3/256)
     17  7969
     18  7969
     19  7969
     20  7969
     21  7969
     22  7969				   .LUM1      SET	.LUM1 + .STEP1
     23  7969				   .LUM2      SET	.LUM2 + .STEP2
     24  7969				   .LUM3      SET	.LUM3 + .STEP3
     13  7969					      REPEND
     14  7969		       94		      .byte.b	$90+(.LUM1/256)
     15  796a		       16		      .byte.b	$10+(.LUM2/256)
     16  796b		       28		      .byte.b	$20+(.LUM3/256)
     17  796c
     18  796c
     19  796c
     20  796c
     21  796c
     22  796c				   .LUM1      SET	.LUM1 + .STEP1
     23  796c				   .LUM2      SET	.LUM2 + .STEP2
     24  796c				   .LUM3      SET	.LUM3 + .STEP3
     13  796c					      REPEND
     14  796c		       94		      .byte.b	$90+(.LUM1/256)
     15  796d		       16		      .byte.b	$10+(.LUM2/256)
     16  796e		       28		      .byte.b	$20+(.LUM3/256)
     17  796f
     18  796f
     19  796f
     20  796f
     21  796f
     22  796f				   .LUM1      SET	.LUM1 + .STEP1
     23  796f				   .LUM2      SET	.LUM2 + .STEP2
     24  796f				   .LUM3      SET	.LUM3 + .STEP3
     13  796f					      REPEND
     14  796f		       94		      .byte.b	$90+(.LUM1/256)
     15  7970		       16		      .byte.b	$10+(.LUM2/256)
     16  7971		       28		      .byte.b	$20+(.LUM3/256)
     17  7972
     18  7972
     19  7972
     20  7972
     21  7972
     22  7972				   .LUM1      SET	.LUM1 + .STEP1
     23  7972				   .LUM2      SET	.LUM2 + .STEP2
     24  7972				   .LUM3      SET	.LUM3 + .STEP3
     13  7972					      REPEND
     14  7972		       94		      .byte.b	$90+(.LUM1/256)
     15  7973		       16		      .byte.b	$10+(.LUM2/256)
     16  7974		       28		      .byte.b	$20+(.LUM3/256)
     17  7975
     18  7975
     19  7975
     20  7975
     21  7975
     22  7975				   .LUM1      SET	.LUM1 + .STEP1
     23  7975				   .LUM2      SET	.LUM2 + .STEP2
     24  7975				   .LUM3      SET	.LUM3 + .STEP3
     13  7975					      REPEND
     14  7975		       94		      .byte.b	$90+(.LUM1/256)
     15  7976		       16		      .byte.b	$10+(.LUM2/256)
     16  7977		       28		      .byte.b	$20+(.LUM3/256)
     17  7978
     18  7978
     19  7978
     20  7978
     21  7978
     22  7978				   .LUM1      SET	.LUM1 + .STEP1
     23  7978				   .LUM2      SET	.LUM2 + .STEP2
     24  7978				   .LUM3      SET	.LUM3 + .STEP3
     13  7978					      REPEND
     14  7978		       94		      .byte.b	$90+(.LUM1/256)
     15  7979		       16		      .byte.b	$10+(.LUM2/256)
     16  797a		       28		      .byte.b	$20+(.LUM3/256)
     17  797b
     18  797b
     19  797b
     20  797b
     21  797b
     22  797b				   .LUM1      SET	.LUM1 + .STEP1
     23  797b				   .LUM2      SET	.LUM2 + .STEP2
     24  797b				   .LUM3      SET	.LUM3 + .STEP3
     13  797b					      REPEND
     14  797b		       94		      .byte.b	$90+(.LUM1/256)
     15  797c		       16		      .byte.b	$10+(.LUM2/256)
     16  797d		       28		      .byte.b	$20+(.LUM3/256)
     17  797e
     18  797e
     19  797e
     20  797e
     21  797e
     22  797e				   .LUM1      SET	.LUM1 + .STEP1
     23  797e				   .LUM2      SET	.LUM2 + .STEP2
     24  797e				   .LUM3      SET	.LUM3 + .STEP3
     13  797e					      REPEND
     14  797e		       94		      .byte.b	$90+(.LUM1/256)
     15  797f		       16		      .byte.b	$10+(.LUM2/256)
     16  7980		       28		      .byte.b	$20+(.LUM3/256)
     17  7981
     18  7981
     19  7981
     20  7981
     21  7981
     22  7981				   .LUM1      SET	.LUM1 + .STEP1
     23  7981				   .LUM2      SET	.LUM2 + .STEP2
     24  7981				   .LUM3      SET	.LUM3 + .STEP3
     13  7981					      REPEND
     14  7981		       94		      .byte.b	$90+(.LUM1/256)
     15  7982		       16		      .byte.b	$10+(.LUM2/256)
     16  7983		       28		      .byte.b	$20+(.LUM3/256)
     17  7984
     18  7984
     19  7984
     20  7984
     21  7984
     22  7984				   .LUM1      SET	.LUM1 + .STEP1
     23  7984				   .LUM2      SET	.LUM2 + .STEP2
     24  7984				   .LUM3      SET	.LUM3 + .STEP3
     13  7984					      REPEND
     14  7984		       94		      .byte.b	$90+(.LUM1/256)
     15  7985		       16		      .byte.b	$10+(.LUM2/256)
     16  7986		       28		      .byte.b	$20+(.LUM3/256)
     17  7987
     18  7987
     19  7987
     20  7987
     21  7987
     22  7987				   .LUM1      SET	.LUM1 + .STEP1
     23  7987				   .LUM2      SET	.LUM2 + .STEP2
     24  7987				   .LUM3      SET	.LUM3 + .STEP3
     13  7987					      REPEND
     14  7987		       94		      .byte.b	$90+(.LUM1/256)
     15  7988		       16		      .byte.b	$10+(.LUM2/256)
     16  7989		       28		      .byte.b	$20+(.LUM3/256)
     17  798a
     18  798a
     19  798a
     20  798a
     21  798a
     22  798a				   .LUM1      SET	.LUM1 + .STEP1
     23  798a				   .LUM2      SET	.LUM2 + .STEP2
     24  798a				   .LUM3      SET	.LUM3 + .STEP3
     13  798a					      REPEND
     14  798a		       94		      .byte.b	$90+(.LUM1/256)
     15  798b		       16		      .byte.b	$10+(.LUM2/256)
     16  798c		       28		      .byte.b	$20+(.LUM3/256)
     17  798d
     18  798d
     19  798d
     20  798d
     21  798d
     22  798d				   .LUM1      SET	.LUM1 + .STEP1
     23  798d				   .LUM2      SET	.LUM2 + .STEP2
     24  798d				   .LUM3      SET	.LUM3 + .STEP3
     13  798d					      REPEND
     14  798d		       94		      .byte.b	$90+(.LUM1/256)
     15  798e		       16		      .byte.b	$10+(.LUM2/256)
     16  798f		       28		      .byte.b	$20+(.LUM3/256)
     17  7990
     18  7990
     19  7990
     20  7990
     21  7990
     22  7990				   .LUM1      SET	.LUM1 + .STEP1
     23  7990				   .LUM2      SET	.LUM2 + .STEP2
     24  7990				   .LUM3      SET	.LUM3 + .STEP3
     13  7990					      REPEND
     14  7990		       94		      .byte.b	$90+(.LUM1/256)
     15  7991		       16		      .byte.b	$10+(.LUM2/256)
     16  7992		       28		      .byte.b	$20+(.LUM3/256)
     17  7993
     18  7993
     19  7993
     20  7993
     21  7993
     22  7993				   .LUM1      SET	.LUM1 + .STEP1
     23  7993				   .LUM2      SET	.LUM2 + .STEP2
     24  7993				   .LUM3      SET	.LUM3 + .STEP3
     13  7993					      REPEND
     14  7993		       94		      .byte.b	$90+(.LUM1/256)
     15  7994		       16		      .byte.b	$10+(.LUM2/256)
     16  7995		       28		      .byte.b	$20+(.LUM3/256)
     17  7996
     18  7996
     19  7996
     20  7996
     21  7996
     22  7996				   .LUM1      SET	.LUM1 + .STEP1
     23  7996				   .LUM2      SET	.LUM2 + .STEP2
     24  7996				   .LUM3      SET	.LUM3 + .STEP3
     13  7996					      REPEND
     14  7996		       94		      .byte.b	$90+(.LUM1/256)
     15  7997		       16		      .byte.b	$10+(.LUM2/256)
     16  7998		       28		      .byte.b	$20+(.LUM3/256)
     17  7999
     18  7999
     19  7999
     20  7999
     21  7999
     22  7999				   .LUM1      SET	.LUM1 + .STEP1
     23  7999				   .LUM2      SET	.LUM2 + .STEP2
     24  7999				   .LUM3      SET	.LUM3 + .STEP3
     13  7999					      REPEND
     14  7999		       94		      .byte.b	$90+(.LUM1/256)
     15  799a		       16		      .byte.b	$10+(.LUM2/256)
     16  799b		       28		      .byte.b	$20+(.LUM3/256)
     17  799c
     18  799c
     19  799c
     20  799c
     21  799c
     22  799c				   .LUM1      SET	.LUM1 + .STEP1
     23  799c				   .LUM2      SET	.LUM2 + .STEP2
     24  799c				   .LUM3      SET	.LUM3 + .STEP3
     13  799c					      REPEND
     14  799c		       94		      .byte.b	$90+(.LUM1/256)
     15  799d		       16		      .byte.b	$10+(.LUM2/256)
     16  799e		       28		      .byte.b	$20+(.LUM3/256)
     17  799f
     18  799f
     19  799f
     20  799f
     21  799f
     22  799f				   .LUM1      SET	.LUM1 + .STEP1
     23  799f				   .LUM2      SET	.LUM2 + .STEP2
     24  799f				   .LUM3      SET	.LUM3 + .STEP3
     13  799f					      REPEND
     14  799f		       94		      .byte.b	$90+(.LUM1/256)
     15  79a0		       16		      .byte.b	$10+(.LUM2/256)
     16  79a1		       28		      .byte.b	$20+(.LUM3/256)
     17  79a2
     18  79a2
     19  79a2
     20  79a2
     21  79a2
     22  79a2				   .LUM1      SET	.LUM1 + .STEP1
     23  79a2				   .LUM2      SET	.LUM2 + .STEP2
     24  79a2				   .LUM3      SET	.LUM3 + .STEP3
     13  79a2					      REPEND
     14  79a2		       94		      .byte.b	$90+(.LUM1/256)
     15  79a3		       16		      .byte.b	$10+(.LUM2/256)
     16  79a4		       28		      .byte.b	$20+(.LUM3/256)
     17  79a5
     18  79a5
     19  79a5
     20  79a5
     21  79a5
     22  79a5				   .LUM1      SET	.LUM1 + .STEP1
     23  79a5				   .LUM2      SET	.LUM2 + .STEP2
     24  79a5				   .LUM3      SET	.LUM3 + .STEP3
     13  79a5					      REPEND
     14  79a5		       94		      .byte.b	$90+(.LUM1/256)
     15  79a6		       16		      .byte.b	$10+(.LUM2/256)
     16  79a7		       28		      .byte.b	$20+(.LUM3/256)
     17  79a8
     18  79a8
     19  79a8
     20  79a8
     21  79a8
     22  79a8				   .LUM1      SET	.LUM1 + .STEP1
     23  79a8				   .LUM2      SET	.LUM2 + .STEP2
     24  79a8				   .LUM3      SET	.LUM3 + .STEP3
     13  79a8					      REPEND
     14  79a8		       94		      .byte.b	$90+(.LUM1/256)
     15  79a9		       16		      .byte.b	$10+(.LUM2/256)
     16  79aa		       28		      .byte.b	$20+(.LUM3/256)
     17  79ab
     18  79ab
     19  79ab
     20  79ab
     21  79ab
     22  79ab				   .LUM1      SET	.LUM1 + .STEP1
     23  79ab				   .LUM2      SET	.LUM2 + .STEP2
     24  79ab				   .LUM3      SET	.LUM3 + .STEP3
     13  79ab					      REPEND
     14  79ab		       94		      .byte.b	$90+(.LUM1/256)
     15  79ac		       16		      .byte.b	$10+(.LUM2/256)
     16  79ad		       28		      .byte.b	$20+(.LUM3/256)
     17  79ae
     18  79ae
     19  79ae
     20  79ae
     21  79ae
     22  79ae				   .LUM1      SET	.LUM1 + .STEP1
     23  79ae				   .LUM2      SET	.LUM2 + .STEP2
     24  79ae				   .LUM3      SET	.LUM3 + .STEP3
     13  79ae					      REPEND
     14  79ae		       94		      .byte.b	$90+(.LUM1/256)
     15  79af		       16		      .byte.b	$10+(.LUM2/256)
     16  79b0		       28		      .byte.b	$20+(.LUM3/256)
     17  79b1
     18  79b1
     19  79b1
     20  79b1
     21  79b1
     22  79b1				   .LUM1      SET	.LUM1 + .STEP1
     23  79b1				   .LUM2      SET	.LUM2 + .STEP2
     24  79b1				   .LUM3      SET	.LUM3 + .STEP3
     13  79b1					      REPEND
     14  79b1		       94		      .byte.b	$90+(.LUM1/256)
     15  79b2		       16		      .byte.b	$10+(.LUM2/256)
     16  79b3		       28		      .byte.b	$20+(.LUM3/256)
     17  79b4
     18  79b4
     19  79b4
     20  79b4
     21  79b4
     22  79b4				   .LUM1      SET	.LUM1 + .STEP1
     23  79b4				   .LUM2      SET	.LUM2 + .STEP2
     24  79b4				   .LUM3      SET	.LUM3 + .STEP3
     13  79b4					      REPEND
     14  79b4		       94		      .byte.b	$90+(.LUM1/256)
     15  79b5		       16		      .byte.b	$10+(.LUM2/256)
     16  79b6		       28		      .byte.b	$20+(.LUM3/256)
     17  79b7
     18  79b7
     19  79b7
     20  79b7
     21  79b7
     22  79b7				   .LUM1      SET	.LUM1 + .STEP1
     23  79b7				   .LUM2      SET	.LUM2 + .STEP2
     24  79b7				   .LUM3      SET	.LUM3 + .STEP3
     13  79b7					      REPEND
     14  79b7		       94		      .byte.b	$90+(.LUM1/256)
     15  79b8		       16		      .byte.b	$10+(.LUM2/256)
     16  79b9		       28		      .byte.b	$20+(.LUM3/256)
     17  79ba
     18  79ba
     19  79ba
     20  79ba
     21  79ba
     22  79ba				   .LUM1      SET	.LUM1 + .STEP1
     23  79ba				   .LUM2      SET	.LUM2 + .STEP2
     24  79ba				   .LUM3      SET	.LUM3 + .STEP3
     13  79ba					      REPEND
     14  79ba		       94		      .byte.b	$90+(.LUM1/256)
     15  79bb		       16		      .byte.b	$10+(.LUM2/256)
     16  79bc		       28		      .byte.b	$20+(.LUM3/256)
     17  79bd
     18  79bd
     19  79bd
     20  79bd
     21  79bd
     22  79bd				   .LUM1      SET	.LUM1 + .STEP1
     23  79bd				   .LUM2      SET	.LUM2 + .STEP2
     24  79bd				   .LUM3      SET	.LUM3 + .STEP3
     13  79bd					      REPEND
     14  79bd		       94		      .byte.b	$90+(.LUM1/256)
     15  79be		       16		      .byte.b	$10+(.LUM2/256)
     16  79bf		       28		      .byte.b	$20+(.LUM3/256)
     17  79c0
     18  79c0
     19  79c0
     20  79c0
     21  79c0
     22  79c0				   .LUM1      SET	.LUM1 + .STEP1
     23  79c0				   .LUM2      SET	.LUM2 + .STEP2
     24  79c0				   .LUM3      SET	.LUM3 + .STEP3
     13  79c0					      REPEND
     14  79c0		       94		      .byte.b	$90+(.LUM1/256)
     15  79c1		       16		      .byte.b	$10+(.LUM2/256)
     16  79c2		       28		      .byte.b	$20+(.LUM3/256)
     17  79c3
     18  79c3
     19  79c3
     20  79c3
     21  79c3
     22  79c3				   .LUM1      SET	.LUM1 + .STEP1
     23  79c3				   .LUM2      SET	.LUM2 + .STEP2
     24  79c3				   .LUM3      SET	.LUM3 + .STEP3
     13  79c3					      REPEND
     14  79c3		       94		      .byte.b	$90+(.LUM1/256)
     15  79c4		       16		      .byte.b	$10+(.LUM2/256)
     16  79c5		       28		      .byte.b	$20+(.LUM3/256)
     17  79c6
     18  79c6
     19  79c6
     20  79c6
     21  79c6
     22  79c6				   .LUM1      SET	.LUM1 + .STEP1
     23  79c6				   .LUM2      SET	.LUM2 + .STEP2
     24  79c6				   .LUM3      SET	.LUM3 + .STEP3
     13  79c6					      REPEND
     14  79c6		       94		      .byte.b	$90+(.LUM1/256)
     15  79c7		       16		      .byte.b	$10+(.LUM2/256)
     16  79c8		       28		      .byte.b	$20+(.LUM3/256)
     17  79c9
     18  79c9
     19  79c9
     20  79c9
     21  79c9
     22  79c9				   .LUM1      SET	.LUM1 + .STEP1
     23  79c9				   .LUM2      SET	.LUM2 + .STEP2
     24  79c9				   .LUM3      SET	.LUM3 + .STEP3
     13  79c9					      REPEND
     14  79c9		       94		      .byte.b	$90+(.LUM1/256)
     15  79ca		       16		      .byte.b	$10+(.LUM2/256)
     16  79cb		       28		      .byte.b	$20+(.LUM3/256)
     17  79cc
     18  79cc
     19  79cc
     20  79cc
     21  79cc
     22  79cc				   .LUM1      SET	.LUM1 + .STEP1
     23  79cc				   .LUM2      SET	.LUM2 + .STEP2
     24  79cc				   .LUM3      SET	.LUM3 + .STEP3
     13  79cc					      REPEND
     14  79cc		       94		      .byte.b	$90+(.LUM1/256)
     15  79cd		       16		      .byte.b	$10+(.LUM2/256)
     16  79ce		       28		      .byte.b	$20+(.LUM3/256)
     17  79cf
     18  79cf
     19  79cf
     20  79cf
     21  79cf
     22  79cf				   .LUM1      SET	.LUM1 + .STEP1
     23  79cf				   .LUM2      SET	.LUM2 + .STEP2
     24  79cf				   .LUM3      SET	.LUM3 + .STEP3
     13  79cf					      REPEND
     14  79cf		       94		      .byte.b	$90+(.LUM1/256)
     15  79d0		       16		      .byte.b	$10+(.LUM2/256)
     16  79d1		       28		      .byte.b	$20+(.LUM3/256)
     17  79d2
     18  79d2
     19  79d2
     20  79d2
     21  79d2
     22  79d2				   .LUM1      SET	.LUM1 + .STEP1
     23  79d2				   .LUM2      SET	.LUM2 + .STEP2
     24  79d2				   .LUM3      SET	.LUM3 + .STEP3
     13  79d2					      REPEND
     14  79d2		       94		      .byte.b	$90+(.LUM1/256)
     15  79d3		       16		      .byte.b	$10+(.LUM2/256)
     16  79d4		       28		      .byte.b	$20+(.LUM3/256)
     17  79d5
     18  79d5
     19  79d5
     20  79d5
     21  79d5
     22  79d5				   .LUM1      SET	.LUM1 + .STEP1
     23  79d5				   .LUM2      SET	.LUM2 + .STEP2
     24  79d5				   .LUM3      SET	.LUM3 + .STEP3
     13  79d5					      REPEND
     14  79d5		       94		      .byte.b	$90+(.LUM1/256)
     15  79d6		       16		      .byte.b	$10+(.LUM2/256)
     16  79d7		       28		      .byte.b	$20+(.LUM3/256)
     17  79d8
     18  79d8
     19  79d8
     20  79d8
     21  79d8
     22  79d8				   .LUM1      SET	.LUM1 + .STEP1
     23  79d8				   .LUM2      SET	.LUM2 + .STEP2
     24  79d8				   .LUM3      SET	.LUM3 + .STEP3
     25  79d8					      REPEND
    338  79d8							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    339  79d8
    340  79d8							;    ECHO "PAL LUMS"
    341  79d8							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
      0  79d8				   colr_pal   LUMTABLE	$60, $80, $10, $6,$4,$8,$6,$4,$8
      1  79d8
      2  79d8
      3  79d8
      4  79d8
      5  79d8				   .LUM1      SET	$6*256
      6  79d8				   .LUM2      SET	$4*256
      7  79d8				   .LUM3      SET	$8*256
      8  79d8
      9  79d8		       00 00	   .STEP1     =	(256*($6-$6))/72
     10  79d8		       00 00	   .STEP2     =	(256*($4-$4))/72
     11  79d8		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  79d8
     13  79d8					      REPEAT	72
     14  79d8		       66		      .byte.b	$60+(.LUM1/256)
     15  79d9		       84		      .byte.b	$80+(.LUM2/256)
     16  79da		       18		      .byte.b	$10+(.LUM3/256)
     17  79db
     18  79db
     19  79db
     20  79db
     21  79db
     22  79db				   .LUM1      SET	.LUM1 + .STEP1
     23  79db				   .LUM2      SET	.LUM2 + .STEP2
     24  79db				   .LUM3      SET	.LUM3 + .STEP3
     13  79db					      REPEND
     14  79db		       66		      .byte.b	$60+(.LUM1/256)
     15  79dc		       84		      .byte.b	$80+(.LUM2/256)
     16  79dd		       18		      .byte.b	$10+(.LUM3/256)
     17  79de
     18  79de
     19  79de
     20  79de
     21  79de
     22  79de				   .LUM1      SET	.LUM1 + .STEP1
     23  79de				   .LUM2      SET	.LUM2 + .STEP2
     24  79de				   .LUM3      SET	.LUM3 + .STEP3
     13  79de					      REPEND
     14  79de		       66		      .byte.b	$60+(.LUM1/256)
     15  79df		       84		      .byte.b	$80+(.LUM2/256)
     16  79e0		       18		      .byte.b	$10+(.LUM3/256)
     17  79e1
     18  79e1
     19  79e1
     20  79e1
     21  79e1
     22  79e1				   .LUM1      SET	.LUM1 + .STEP1
     23  79e1				   .LUM2      SET	.LUM2 + .STEP2
     24  79e1				   .LUM3      SET	.LUM3 + .STEP3
     13  79e1					      REPEND
     14  79e1		       66		      .byte.b	$60+(.LUM1/256)
     15  79e2		       84		      .byte.b	$80+(.LUM2/256)
     16  79e3		       18		      .byte.b	$10+(.LUM3/256)
     17  79e4
     18  79e4
     19  79e4
     20  79e4
     21  79e4
     22  79e4				   .LUM1      SET	.LUM1 + .STEP1
     23  79e4				   .LUM2      SET	.LUM2 + .STEP2
     24  79e4				   .LUM3      SET	.LUM3 + .STEP3
     13  79e4					      REPEND
     14  79e4		       66		      .byte.b	$60+(.LUM1/256)
     15  79e5		       84		      .byte.b	$80+(.LUM2/256)
     16  79e6		       18		      .byte.b	$10+(.LUM3/256)
     17  79e7
     18  79e7
     19  79e7
     20  79e7
     21  79e7
     22  79e7				   .LUM1      SET	.LUM1 + .STEP1
     23  79e7				   .LUM2      SET	.LUM2 + .STEP2
     24  79e7				   .LUM3      SET	.LUM3 + .STEP3
     13  79e7					      REPEND
     14  79e7		       66		      .byte.b	$60+(.LUM1/256)
     15  79e8		       84		      .byte.b	$80+(.LUM2/256)
     16  79e9		       18		      .byte.b	$10+(.LUM3/256)
     17  79ea
     18  79ea
     19  79ea
     20  79ea
     21  79ea
     22  79ea				   .LUM1      SET	.LUM1 + .STEP1
     23  79ea				   .LUM2      SET	.LUM2 + .STEP2
     24  79ea				   .LUM3      SET	.LUM3 + .STEP3
     13  79ea					      REPEND
     14  79ea		       66		      .byte.b	$60+(.LUM1/256)
     15  79eb		       84		      .byte.b	$80+(.LUM2/256)
     16  79ec		       18		      .byte.b	$10+(.LUM3/256)
     17  79ed
     18  79ed
     19  79ed
     20  79ed
     21  79ed
     22  79ed				   .LUM1      SET	.LUM1 + .STEP1
     23  79ed				   .LUM2      SET	.LUM2 + .STEP2
     24  79ed				   .LUM3      SET	.LUM3 + .STEP3
     13  79ed					      REPEND
     14  79ed		       66		      .byte.b	$60+(.LUM1/256)
     15  79ee		       84		      .byte.b	$80+(.LUM2/256)
     16  79ef		       18		      .byte.b	$10+(.LUM3/256)
     17  79f0
     18  79f0
     19  79f0
     20  79f0
     21  79f0
     22  79f0				   .LUM1      SET	.LUM1 + .STEP1
     23  79f0				   .LUM2      SET	.LUM2 + .STEP2
     24  79f0				   .LUM3      SET	.LUM3 + .STEP3
     13  79f0					      REPEND
     14  79f0		       66		      .byte.b	$60+(.LUM1/256)
     15  79f1		       84		      .byte.b	$80+(.LUM2/256)
     16  79f2		       18		      .byte.b	$10+(.LUM3/256)
     17  79f3
     18  79f3
     19  79f3
     20  79f3
     21  79f3
     22  79f3				   .LUM1      SET	.LUM1 + .STEP1
     23  79f3				   .LUM2      SET	.LUM2 + .STEP2
     24  79f3				   .LUM3      SET	.LUM3 + .STEP3
     13  79f3					      REPEND
     14  79f3		       66		      .byte.b	$60+(.LUM1/256)
     15  79f4		       84		      .byte.b	$80+(.LUM2/256)
     16  79f5		       18		      .byte.b	$10+(.LUM3/256)
     17  79f6
     18  79f6
     19  79f6
     20  79f6
     21  79f6
     22  79f6				   .LUM1      SET	.LUM1 + .STEP1
     23  79f6				   .LUM2      SET	.LUM2 + .STEP2
     24  79f6				   .LUM3      SET	.LUM3 + .STEP3
     13  79f6					      REPEND
     14  79f6		       66		      .byte.b	$60+(.LUM1/256)
     15  79f7		       84		      .byte.b	$80+(.LUM2/256)
     16  79f8		       18		      .byte.b	$10+(.LUM3/256)
     17  79f9
     18  79f9
     19  79f9
     20  79f9
     21  79f9
     22  79f9				   .LUM1      SET	.LUM1 + .STEP1
     23  79f9				   .LUM2      SET	.LUM2 + .STEP2
     24  79f9				   .LUM3      SET	.LUM3 + .STEP3
     13  79f9					      REPEND
     14  79f9		       66		      .byte.b	$60+(.LUM1/256)
     15  79fa		       84		      .byte.b	$80+(.LUM2/256)
     16  79fb		       18		      .byte.b	$10+(.LUM3/256)
     17  79fc
     18  79fc
     19  79fc
     20  79fc
     21  79fc
     22  79fc				   .LUM1      SET	.LUM1 + .STEP1
     23  79fc				   .LUM2      SET	.LUM2 + .STEP2
     24  79fc				   .LUM3      SET	.LUM3 + .STEP3
     13  79fc					      REPEND
     14  79fc		       66		      .byte.b	$60+(.LUM1/256)
     15  79fd		       84		      .byte.b	$80+(.LUM2/256)
     16  79fe		       18		      .byte.b	$10+(.LUM3/256)
     17  79ff
     18  79ff
     19  79ff
     20  79ff
     21  79ff
     22  79ff				   .LUM1      SET	.LUM1 + .STEP1
     23  79ff				   .LUM2      SET	.LUM2 + .STEP2
     24  79ff				   .LUM3      SET	.LUM3 + .STEP3
     13  79ff					      REPEND
     14  79ff		       66		      .byte.b	$60+(.LUM1/256)
     15  7a00		       84		      .byte.b	$80+(.LUM2/256)
     16  7a01		       18		      .byte.b	$10+(.LUM3/256)
     17  7a02
     18  7a02
     19  7a02
     20  7a02
     21  7a02
     22  7a02				   .LUM1      SET	.LUM1 + .STEP1
     23  7a02				   .LUM2      SET	.LUM2 + .STEP2
     24  7a02				   .LUM3      SET	.LUM3 + .STEP3
     13  7a02					      REPEND
     14  7a02		       66		      .byte.b	$60+(.LUM1/256)
     15  7a03		       84		      .byte.b	$80+(.LUM2/256)
     16  7a04		       18		      .byte.b	$10+(.LUM3/256)
     17  7a05
     18  7a05
     19  7a05
     20  7a05
     21  7a05
     22  7a05				   .LUM1      SET	.LUM1 + .STEP1
     23  7a05				   .LUM2      SET	.LUM2 + .STEP2
     24  7a05				   .LUM3      SET	.LUM3 + .STEP3
     13  7a05					      REPEND
     14  7a05		       66		      .byte.b	$60+(.LUM1/256)
     15  7a06		       84		      .byte.b	$80+(.LUM2/256)
     16  7a07		       18		      .byte.b	$10+(.LUM3/256)
     17  7a08
     18  7a08
     19  7a08
     20  7a08
     21  7a08
     22  7a08				   .LUM1      SET	.LUM1 + .STEP1
     23  7a08				   .LUM2      SET	.LUM2 + .STEP2
     24  7a08				   .LUM3      SET	.LUM3 + .STEP3
     13  7a08					      REPEND
     14  7a08		       66		      .byte.b	$60+(.LUM1/256)
     15  7a09		       84		      .byte.b	$80+(.LUM2/256)
     16  7a0a		       18		      .byte.b	$10+(.LUM3/256)
     17  7a0b
     18  7a0b
     19  7a0b
     20  7a0b
     21  7a0b
     22  7a0b				   .LUM1      SET	.LUM1 + .STEP1
     23  7a0b				   .LUM2      SET	.LUM2 + .STEP2
     24  7a0b				   .LUM3      SET	.LUM3 + .STEP3
     13  7a0b					      REPEND
     14  7a0b		       66		      .byte.b	$60+(.LUM1/256)
     15  7a0c		       84		      .byte.b	$80+(.LUM2/256)
     16  7a0d		       18		      .byte.b	$10+(.LUM3/256)
     17  7a0e
     18  7a0e
     19  7a0e
     20  7a0e
     21  7a0e
     22  7a0e				   .LUM1      SET	.LUM1 + .STEP1
     23  7a0e				   .LUM2      SET	.LUM2 + .STEP2
     24  7a0e				   .LUM3      SET	.LUM3 + .STEP3
     13  7a0e					      REPEND
     14  7a0e		       66		      .byte.b	$60+(.LUM1/256)
     15  7a0f		       84		      .byte.b	$80+(.LUM2/256)
     16  7a10		       18		      .byte.b	$10+(.LUM3/256)
     17  7a11
     18  7a11
     19  7a11
     20  7a11
     21  7a11
     22  7a11				   .LUM1      SET	.LUM1 + .STEP1
     23  7a11				   .LUM2      SET	.LUM2 + .STEP2
     24  7a11				   .LUM3      SET	.LUM3 + .STEP3
     13  7a11					      REPEND
     14  7a11		       66		      .byte.b	$60+(.LUM1/256)
     15  7a12		       84		      .byte.b	$80+(.LUM2/256)
     16  7a13		       18		      .byte.b	$10+(.LUM3/256)
     17  7a14
     18  7a14
     19  7a14
     20  7a14
     21  7a14
     22  7a14				   .LUM1      SET	.LUM1 + .STEP1
     23  7a14				   .LUM2      SET	.LUM2 + .STEP2
     24  7a14				   .LUM3      SET	.LUM3 + .STEP3
     13  7a14					      REPEND
     14  7a14		       66		      .byte.b	$60+(.LUM1/256)
     15  7a15		       84		      .byte.b	$80+(.LUM2/256)
     16  7a16		       18		      .byte.b	$10+(.LUM3/256)
     17  7a17
     18  7a17
     19  7a17
     20  7a17
     21  7a17
     22  7a17				   .LUM1      SET	.LUM1 + .STEP1
     23  7a17				   .LUM2      SET	.LUM2 + .STEP2
     24  7a17				   .LUM3      SET	.LUM3 + .STEP3
     13  7a17					      REPEND
     14  7a17		       66		      .byte.b	$60+(.LUM1/256)
     15  7a18		       84		      .byte.b	$80+(.LUM2/256)
     16  7a19		       18		      .byte.b	$10+(.LUM3/256)
     17  7a1a
     18  7a1a
     19  7a1a
     20  7a1a
     21  7a1a
     22  7a1a				   .LUM1      SET	.LUM1 + .STEP1
     23  7a1a				   .LUM2      SET	.LUM2 + .STEP2
     24  7a1a				   .LUM3      SET	.LUM3 + .STEP3
     13  7a1a					      REPEND
     14  7a1a		       66		      .byte.b	$60+(.LUM1/256)
     15  7a1b		       84		      .byte.b	$80+(.LUM2/256)
     16  7a1c		       18		      .byte.b	$10+(.LUM3/256)
     17  7a1d
     18  7a1d
     19  7a1d
     20  7a1d
     21  7a1d
     22  7a1d				   .LUM1      SET	.LUM1 + .STEP1
     23  7a1d				   .LUM2      SET	.LUM2 + .STEP2
     24  7a1d				   .LUM3      SET	.LUM3 + .STEP3
     13  7a1d					      REPEND
     14  7a1d		       66		      .byte.b	$60+(.LUM1/256)
     15  7a1e		       84		      .byte.b	$80+(.LUM2/256)
     16  7a1f		       18		      .byte.b	$10+(.LUM3/256)
     17  7a20
     18  7a20
     19  7a20
     20  7a20
     21  7a20
     22  7a20				   .LUM1      SET	.LUM1 + .STEP1
     23  7a20				   .LUM2      SET	.LUM2 + .STEP2
     24  7a20				   .LUM3      SET	.LUM3 + .STEP3
     13  7a20					      REPEND
     14  7a20		       66		      .byte.b	$60+(.LUM1/256)
     15  7a21		       84		      .byte.b	$80+(.LUM2/256)
     16  7a22		       18		      .byte.b	$10+(.LUM3/256)
     17  7a23
     18  7a23
     19  7a23
     20  7a23
     21  7a23
     22  7a23				   .LUM1      SET	.LUM1 + .STEP1
     23  7a23				   .LUM2      SET	.LUM2 + .STEP2
     24  7a23				   .LUM3      SET	.LUM3 + .STEP3
     13  7a23					      REPEND
     14  7a23		       66		      .byte.b	$60+(.LUM1/256)
     15  7a24		       84		      .byte.b	$80+(.LUM2/256)
     16  7a25		       18		      .byte.b	$10+(.LUM3/256)
     17  7a26
     18  7a26
     19  7a26
     20  7a26
     21  7a26
     22  7a26				   .LUM1      SET	.LUM1 + .STEP1
     23  7a26				   .LUM2      SET	.LUM2 + .STEP2
     24  7a26				   .LUM3      SET	.LUM3 + .STEP3
     13  7a26					      REPEND
     14  7a26		       66		      .byte.b	$60+(.LUM1/256)
     15  7a27		       84		      .byte.b	$80+(.LUM2/256)
     16  7a28		       18		      .byte.b	$10+(.LUM3/256)
     17  7a29
     18  7a29
     19  7a29
     20  7a29
     21  7a29
     22  7a29				   .LUM1      SET	.LUM1 + .STEP1
     23  7a29				   .LUM2      SET	.LUM2 + .STEP2
     24  7a29				   .LUM3      SET	.LUM3 + .STEP3
     13  7a29					      REPEND
     14  7a29		       66		      .byte.b	$60+(.LUM1/256)
     15  7a2a		       84		      .byte.b	$80+(.LUM2/256)
     16  7a2b		       18		      .byte.b	$10+(.LUM3/256)
     17  7a2c
     18  7a2c
     19  7a2c
     20  7a2c
     21  7a2c
     22  7a2c				   .LUM1      SET	.LUM1 + .STEP1
     23  7a2c				   .LUM2      SET	.LUM2 + .STEP2
     24  7a2c				   .LUM3      SET	.LUM3 + .STEP3
     13  7a2c					      REPEND
     14  7a2c		       66		      .byte.b	$60+(.LUM1/256)
     15  7a2d		       84		      .byte.b	$80+(.LUM2/256)
     16  7a2e		       18		      .byte.b	$10+(.LUM3/256)
     17  7a2f
     18  7a2f
     19  7a2f
     20  7a2f
     21  7a2f
     22  7a2f				   .LUM1      SET	.LUM1 + .STEP1
     23  7a2f				   .LUM2      SET	.LUM2 + .STEP2
     24  7a2f				   .LUM3      SET	.LUM3 + .STEP3
     13  7a2f					      REPEND
     14  7a2f		       66		      .byte.b	$60+(.LUM1/256)
     15  7a30		       84		      .byte.b	$80+(.LUM2/256)
     16  7a31		       18		      .byte.b	$10+(.LUM3/256)
     17  7a32
     18  7a32
     19  7a32
     20  7a32
     21  7a32
     22  7a32				   .LUM1      SET	.LUM1 + .STEP1
     23  7a32				   .LUM2      SET	.LUM2 + .STEP2
     24  7a32				   .LUM3      SET	.LUM3 + .STEP3
     13  7a32					      REPEND
     14  7a32		       66		      .byte.b	$60+(.LUM1/256)
     15  7a33		       84		      .byte.b	$80+(.LUM2/256)
     16  7a34		       18		      .byte.b	$10+(.LUM3/256)
     17  7a35
     18  7a35
     19  7a35
     20  7a35
     21  7a35
     22  7a35				   .LUM1      SET	.LUM1 + .STEP1
     23  7a35				   .LUM2      SET	.LUM2 + .STEP2
     24  7a35				   .LUM3      SET	.LUM3 + .STEP3
     13  7a35					      REPEND
     14  7a35		       66		      .byte.b	$60+(.LUM1/256)
     15  7a36		       84		      .byte.b	$80+(.LUM2/256)
     16  7a37		       18		      .byte.b	$10+(.LUM3/256)
     17  7a38
     18  7a38
     19  7a38
     20  7a38
     21  7a38
     22  7a38				   .LUM1      SET	.LUM1 + .STEP1
     23  7a38				   .LUM2      SET	.LUM2 + .STEP2
     24  7a38				   .LUM3      SET	.LUM3 + .STEP3
     13  7a38					      REPEND
     14  7a38		       66		      .byte.b	$60+(.LUM1/256)
     15  7a39		       84		      .byte.b	$80+(.LUM2/256)
     16  7a3a		       18		      .byte.b	$10+(.LUM3/256)
     17  7a3b
     18  7a3b
     19  7a3b
     20  7a3b
     21  7a3b
     22  7a3b				   .LUM1      SET	.LUM1 + .STEP1
     23  7a3b				   .LUM2      SET	.LUM2 + .STEP2
     24  7a3b				   .LUM3      SET	.LUM3 + .STEP3
     13  7a3b					      REPEND
     14  7a3b		       66		      .byte.b	$60+(.LUM1/256)
     15  7a3c		       84		      .byte.b	$80+(.LUM2/256)
     16  7a3d		       18		      .byte.b	$10+(.LUM3/256)
     17  7a3e
     18  7a3e
     19  7a3e
     20  7a3e
     21  7a3e
     22  7a3e				   .LUM1      SET	.LUM1 + .STEP1
     23  7a3e				   .LUM2      SET	.LUM2 + .STEP2
     24  7a3e				   .LUM3      SET	.LUM3 + .STEP3
     13  7a3e					      REPEND
     14  7a3e		       66		      .byte.b	$60+(.LUM1/256)
     15  7a3f		       84		      .byte.b	$80+(.LUM2/256)
     16  7a40		       18		      .byte.b	$10+(.LUM3/256)
     17  7a41
     18  7a41
     19  7a41
     20  7a41
     21  7a41
     22  7a41				   .LUM1      SET	.LUM1 + .STEP1
     23  7a41				   .LUM2      SET	.LUM2 + .STEP2
     24  7a41				   .LUM3      SET	.LUM3 + .STEP3
     13  7a41					      REPEND
     14  7a41		       66		      .byte.b	$60+(.LUM1/256)
     15  7a42		       84		      .byte.b	$80+(.LUM2/256)
     16  7a43		       18		      .byte.b	$10+(.LUM3/256)
     17  7a44
     18  7a44
     19  7a44
     20  7a44
     21  7a44
     22  7a44				   .LUM1      SET	.LUM1 + .STEP1
     23  7a44				   .LUM2      SET	.LUM2 + .STEP2
     24  7a44				   .LUM3      SET	.LUM3 + .STEP3
     13  7a44					      REPEND
     14  7a44		       66		      .byte.b	$60+(.LUM1/256)
     15  7a45		       84		      .byte.b	$80+(.LUM2/256)
     16  7a46		       18		      .byte.b	$10+(.LUM3/256)
     17  7a47
     18  7a47
     19  7a47
     20  7a47
     21  7a47
     22  7a47				   .LUM1      SET	.LUM1 + .STEP1
     23  7a47				   .LUM2      SET	.LUM2 + .STEP2
     24  7a47				   .LUM3      SET	.LUM3 + .STEP3
     13  7a47					      REPEND
     14  7a47		       66		      .byte.b	$60+(.LUM1/256)
     15  7a48		       84		      .byte.b	$80+(.LUM2/256)
     16  7a49		       18		      .byte.b	$10+(.LUM3/256)
     17  7a4a
     18  7a4a
     19  7a4a
     20  7a4a
     21  7a4a
     22  7a4a				   .LUM1      SET	.LUM1 + .STEP1
     23  7a4a				   .LUM2      SET	.LUM2 + .STEP2
     24  7a4a				   .LUM3      SET	.LUM3 + .STEP3
     13  7a4a					      REPEND
     14  7a4a		       66		      .byte.b	$60+(.LUM1/256)
     15  7a4b		       84		      .byte.b	$80+(.LUM2/256)
     16  7a4c		       18		      .byte.b	$10+(.LUM3/256)
     17  7a4d
     18  7a4d
     19  7a4d
     20  7a4d
     21  7a4d
     22  7a4d				   .LUM1      SET	.LUM1 + .STEP1
     23  7a4d				   .LUM2      SET	.LUM2 + .STEP2
     24  7a4d				   .LUM3      SET	.LUM3 + .STEP3
     13  7a4d					      REPEND
     14  7a4d		       66		      .byte.b	$60+(.LUM1/256)
     15  7a4e		       84		      .byte.b	$80+(.LUM2/256)
     16  7a4f		       18		      .byte.b	$10+(.LUM3/256)
     17  7a50
     18  7a50
     19  7a50
     20  7a50
     21  7a50
     22  7a50				   .LUM1      SET	.LUM1 + .STEP1
     23  7a50				   .LUM2      SET	.LUM2 + .STEP2
     24  7a50				   .LUM3      SET	.LUM3 + .STEP3
     13  7a50					      REPEND
     14  7a50		       66		      .byte.b	$60+(.LUM1/256)
     15  7a51		       84		      .byte.b	$80+(.LUM2/256)
     16  7a52		       18		      .byte.b	$10+(.LUM3/256)
     17  7a53
     18  7a53
     19  7a53
     20  7a53
     21  7a53
     22  7a53				   .LUM1      SET	.LUM1 + .STEP1
     23  7a53				   .LUM2      SET	.LUM2 + .STEP2
     24  7a53				   .LUM3      SET	.LUM3 + .STEP3
     13  7a53					      REPEND
     14  7a53		       66		      .byte.b	$60+(.LUM1/256)
     15  7a54		       84		      .byte.b	$80+(.LUM2/256)
     16  7a55		       18		      .byte.b	$10+(.LUM3/256)
     17  7a56
     18  7a56
     19  7a56
     20  7a56
     21  7a56
     22  7a56				   .LUM1      SET	.LUM1 + .STEP1
     23  7a56				   .LUM2      SET	.LUM2 + .STEP2
     24  7a56				   .LUM3      SET	.LUM3 + .STEP3
     13  7a56					      REPEND
     14  7a56		       66		      .byte.b	$60+(.LUM1/256)
     15  7a57		       84		      .byte.b	$80+(.LUM2/256)
     16  7a58		       18		      .byte.b	$10+(.LUM3/256)
     17  7a59
     18  7a59
     19  7a59
     20  7a59
     21  7a59
     22  7a59				   .LUM1      SET	.LUM1 + .STEP1
     23  7a59				   .LUM2      SET	.LUM2 + .STEP2
     24  7a59				   .LUM3      SET	.LUM3 + .STEP3
     13  7a59					      REPEND
     14  7a59		       66		      .byte.b	$60+(.LUM1/256)
     15  7a5a		       84		      .byte.b	$80+(.LUM2/256)
     16  7a5b		       18		      .byte.b	$10+(.LUM3/256)
     17  7a5c
     18  7a5c
     19  7a5c
     20  7a5c
     21  7a5c
     22  7a5c				   .LUM1      SET	.LUM1 + .STEP1
     23  7a5c				   .LUM2      SET	.LUM2 + .STEP2
     24  7a5c				   .LUM3      SET	.LUM3 + .STEP3
     13  7a5c					      REPEND
     14  7a5c		       66		      .byte.b	$60+(.LUM1/256)
     15  7a5d		       84		      .byte.b	$80+(.LUM2/256)
     16  7a5e		       18		      .byte.b	$10+(.LUM3/256)
     17  7a5f
     18  7a5f
     19  7a5f
     20  7a5f
     21  7a5f
     22  7a5f				   .LUM1      SET	.LUM1 + .STEP1
     23  7a5f				   .LUM2      SET	.LUM2 + .STEP2
     24  7a5f				   .LUM3      SET	.LUM3 + .STEP3
     13  7a5f					      REPEND
     14  7a5f		       66		      .byte.b	$60+(.LUM1/256)
     15  7a60		       84		      .byte.b	$80+(.LUM2/256)
     16  7a61		       18		      .byte.b	$10+(.LUM3/256)
     17  7a62
     18  7a62
     19  7a62
     20  7a62
     21  7a62
     22  7a62				   .LUM1      SET	.LUM1 + .STEP1
     23  7a62				   .LUM2      SET	.LUM2 + .STEP2
     24  7a62				   .LUM3      SET	.LUM3 + .STEP3
     13  7a62					      REPEND
     14  7a62		       66		      .byte.b	$60+(.LUM1/256)
     15  7a63		       84		      .byte.b	$80+(.LUM2/256)
     16  7a64		       18		      .byte.b	$10+(.LUM3/256)
     17  7a65
     18  7a65
     19  7a65
     20  7a65
     21  7a65
     22  7a65				   .LUM1      SET	.LUM1 + .STEP1
     23  7a65				   .LUM2      SET	.LUM2 + .STEP2
     24  7a65				   .LUM3      SET	.LUM3 + .STEP3
     13  7a65					      REPEND
     14  7a65		       66		      .byte.b	$60+(.LUM1/256)
     15  7a66		       84		      .byte.b	$80+(.LUM2/256)
     16  7a67		       18		      .byte.b	$10+(.LUM3/256)
     17  7a68
     18  7a68
     19  7a68
     20  7a68
     21  7a68
     22  7a68				   .LUM1      SET	.LUM1 + .STEP1
     23  7a68				   .LUM2      SET	.LUM2 + .STEP2
     24  7a68				   .LUM3      SET	.LUM3 + .STEP3
     13  7a68					      REPEND
     14  7a68		       66		      .byte.b	$60+(.LUM1/256)
     15  7a69		       84		      .byte.b	$80+(.LUM2/256)
     16  7a6a		       18		      .byte.b	$10+(.LUM3/256)
     17  7a6b
     18  7a6b
     19  7a6b
     20  7a6b
     21  7a6b
     22  7a6b				   .LUM1      SET	.LUM1 + .STEP1
     23  7a6b				   .LUM2      SET	.LUM2 + .STEP2
     24  7a6b				   .LUM3      SET	.LUM3 + .STEP3
     13  7a6b					      REPEND
     14  7a6b		       66		      .byte.b	$60+(.LUM1/256)
     15  7a6c		       84		      .byte.b	$80+(.LUM2/256)
     16  7a6d		       18		      .byte.b	$10+(.LUM3/256)
     17  7a6e
     18  7a6e
     19  7a6e
     20  7a6e
     21  7a6e
     22  7a6e				   .LUM1      SET	.LUM1 + .STEP1
     23  7a6e				   .LUM2      SET	.LUM2 + .STEP2
     24  7a6e				   .LUM3      SET	.LUM3 + .STEP3
     13  7a6e					      REPEND
     14  7a6e		       66		      .byte.b	$60+(.LUM1/256)
     15  7a6f		       84		      .byte.b	$80+(.LUM2/256)
     16  7a70		       18		      .byte.b	$10+(.LUM3/256)
     17  7a71
     18  7a71
     19  7a71
     20  7a71
     21  7a71
     22  7a71				   .LUM1      SET	.LUM1 + .STEP1
     23  7a71				   .LUM2      SET	.LUM2 + .STEP2
     24  7a71				   .LUM3      SET	.LUM3 + .STEP3
     13  7a71					      REPEND
     14  7a71		       66		      .byte.b	$60+(.LUM1/256)
     15  7a72		       84		      .byte.b	$80+(.LUM2/256)
     16  7a73		       18		      .byte.b	$10+(.LUM3/256)
     17  7a74
     18  7a74
     19  7a74
     20  7a74
     21  7a74
     22  7a74				   .LUM1      SET	.LUM1 + .STEP1
     23  7a74				   .LUM2      SET	.LUM2 + .STEP2
     24  7a74				   .LUM3      SET	.LUM3 + .STEP3
     13  7a74					      REPEND
     14  7a74		       66		      .byte.b	$60+(.LUM1/256)
     15  7a75		       84		      .byte.b	$80+(.LUM2/256)
     16  7a76		       18		      .byte.b	$10+(.LUM3/256)
     17  7a77
     18  7a77
     19  7a77
     20  7a77
     21  7a77
     22  7a77				   .LUM1      SET	.LUM1 + .STEP1
     23  7a77				   .LUM2      SET	.LUM2 + .STEP2
     24  7a77				   .LUM3      SET	.LUM3 + .STEP3
     13  7a77					      REPEND
     14  7a77		       66		      .byte.b	$60+(.LUM1/256)
     15  7a78		       84		      .byte.b	$80+(.LUM2/256)
     16  7a79		       18		      .byte.b	$10+(.LUM3/256)
     17  7a7a
     18  7a7a
     19  7a7a
     20  7a7a
     21  7a7a
     22  7a7a				   .LUM1      SET	.LUM1 + .STEP1
     23  7a7a				   .LUM2      SET	.LUM2 + .STEP2
     24  7a7a				   .LUM3      SET	.LUM3 + .STEP3
     13  7a7a					      REPEND
     14  7a7a		       66		      .byte.b	$60+(.LUM1/256)
     15  7a7b		       84		      .byte.b	$80+(.LUM2/256)
     16  7a7c		       18		      .byte.b	$10+(.LUM3/256)
     17  7a7d
     18  7a7d
     19  7a7d
     20  7a7d
     21  7a7d
     22  7a7d				   .LUM1      SET	.LUM1 + .STEP1
     23  7a7d				   .LUM2      SET	.LUM2 + .STEP2
     24  7a7d				   .LUM3      SET	.LUM3 + .STEP3
     13  7a7d					      REPEND
     14  7a7d		       66		      .byte.b	$60+(.LUM1/256)
     15  7a7e		       84		      .byte.b	$80+(.LUM2/256)
     16  7a7f		       18		      .byte.b	$10+(.LUM3/256)
     17  7a80
     18  7a80
     19  7a80
     20  7a80
     21  7a80
     22  7a80				   .LUM1      SET	.LUM1 + .STEP1
     23  7a80				   .LUM2      SET	.LUM2 + .STEP2
     24  7a80				   .LUM3      SET	.LUM3 + .STEP3
     13  7a80					      REPEND
     14  7a80		       66		      .byte.b	$60+(.LUM1/256)
     15  7a81		       84		      .byte.b	$80+(.LUM2/256)
     16  7a82		       18		      .byte.b	$10+(.LUM3/256)
     17  7a83
     18  7a83
     19  7a83
     20  7a83
     21  7a83
     22  7a83				   .LUM1      SET	.LUM1 + .STEP1
     23  7a83				   .LUM2      SET	.LUM2 + .STEP2
     24  7a83				   .LUM3      SET	.LUM3 + .STEP3
     13  7a83					      REPEND
     14  7a83		       66		      .byte.b	$60+(.LUM1/256)
     15  7a84		       84		      .byte.b	$80+(.LUM2/256)
     16  7a85		       18		      .byte.b	$10+(.LUM3/256)
     17  7a86
     18  7a86
     19  7a86
     20  7a86
     21  7a86
     22  7a86				   .LUM1      SET	.LUM1 + .STEP1
     23  7a86				   .LUM2      SET	.LUM2 + .STEP2
     24  7a86				   .LUM3      SET	.LUM3 + .STEP3
     13  7a86					      REPEND
     14  7a86		       66		      .byte.b	$60+(.LUM1/256)
     15  7a87		       84		      .byte.b	$80+(.LUM2/256)
     16  7a88		       18		      .byte.b	$10+(.LUM3/256)
     17  7a89
     18  7a89
     19  7a89
     20  7a89
     21  7a89
     22  7a89				   .LUM1      SET	.LUM1 + .STEP1
     23  7a89				   .LUM2      SET	.LUM2 + .STEP2
     24  7a89				   .LUM3      SET	.LUM3 + .STEP3
     13  7a89					      REPEND
     14  7a89		       66		      .byte.b	$60+(.LUM1/256)
     15  7a8a		       84		      .byte.b	$80+(.LUM2/256)
     16  7a8b		       18		      .byte.b	$10+(.LUM3/256)
     17  7a8c
     18  7a8c
     19  7a8c
     20  7a8c
     21  7a8c
     22  7a8c				   .LUM1      SET	.LUM1 + .STEP1
     23  7a8c				   .LUM2      SET	.LUM2 + .STEP2
     24  7a8c				   .LUM3      SET	.LUM3 + .STEP3
     13  7a8c					      REPEND
     14  7a8c		       66		      .byte.b	$60+(.LUM1/256)
     15  7a8d		       84		      .byte.b	$80+(.LUM2/256)
     16  7a8e		       18		      .byte.b	$10+(.LUM3/256)
     17  7a8f
     18  7a8f
     19  7a8f
     20  7a8f
     21  7a8f
     22  7a8f				   .LUM1      SET	.LUM1 + .STEP1
     23  7a8f				   .LUM2      SET	.LUM2 + .STEP2
     24  7a8f				   .LUM3      SET	.LUM3 + .STEP3
     13  7a8f					      REPEND
     14  7a8f		       66		      .byte.b	$60+(.LUM1/256)
     15  7a90		       84		      .byte.b	$80+(.LUM2/256)
     16  7a91		       18		      .byte.b	$10+(.LUM3/256)
     17  7a92
     18  7a92
     19  7a92
     20  7a92
     21  7a92
     22  7a92				   .LUM1      SET	.LUM1 + .STEP1
     23  7a92				   .LUM2      SET	.LUM2 + .STEP2
     24  7a92				   .LUM3      SET	.LUM3 + .STEP3
     13  7a92					      REPEND
     14  7a92		       66		      .byte.b	$60+(.LUM1/256)
     15  7a93		       84		      .byte.b	$80+(.LUM2/256)
     16  7a94		       18		      .byte.b	$10+(.LUM3/256)
     17  7a95
     18  7a95
     19  7a95
     20  7a95
     21  7a95
     22  7a95				   .LUM1      SET	.LUM1 + .STEP1
     23  7a95				   .LUM2      SET	.LUM2 + .STEP2
     24  7a95				   .LUM3      SET	.LUM3 + .STEP3
     13  7a95					      REPEND
     14  7a95		       66		      .byte.b	$60+(.LUM1/256)
     15  7a96		       84		      .byte.b	$80+(.LUM2/256)
     16  7a97		       18		      .byte.b	$10+(.LUM3/256)
     17  7a98
     18  7a98
     19  7a98
     20  7a98
     21  7a98
     22  7a98				   .LUM1      SET	.LUM1 + .STEP1
     23  7a98				   .LUM2      SET	.LUM2 + .STEP2
     24  7a98				   .LUM3      SET	.LUM3 + .STEP3
     13  7a98					      REPEND
     14  7a98		       66		      .byte.b	$60+(.LUM1/256)
     15  7a99		       84		      .byte.b	$80+(.LUM2/256)
     16  7a9a		       18		      .byte.b	$10+(.LUM3/256)
     17  7a9b
     18  7a9b
     19  7a9b
     20  7a9b
     21  7a9b
     22  7a9b				   .LUM1      SET	.LUM1 + .STEP1
     23  7a9b				   .LUM2      SET	.LUM2 + .STEP2
     24  7a9b				   .LUM3      SET	.LUM3 + .STEP3
     13  7a9b					      REPEND
     14  7a9b		       66		      .byte.b	$60+(.LUM1/256)
     15  7a9c		       84		      .byte.b	$80+(.LUM2/256)
     16  7a9d		       18		      .byte.b	$10+(.LUM3/256)
     17  7a9e
     18  7a9e
     19  7a9e
     20  7a9e
     21  7a9e
     22  7a9e				   .LUM1      SET	.LUM1 + .STEP1
     23  7a9e				   .LUM2      SET	.LUM2 + .STEP2
     24  7a9e				   .LUM3      SET	.LUM3 + .STEP3
     13  7a9e					      REPEND
     14  7a9e		       66		      .byte.b	$60+(.LUM1/256)
     15  7a9f		       84		      .byte.b	$80+(.LUM2/256)
     16  7aa0		       18		      .byte.b	$10+(.LUM3/256)
     17  7aa1
     18  7aa1
     19  7aa1
     20  7aa1
     21  7aa1
     22  7aa1				   .LUM1      SET	.LUM1 + .STEP1
     23  7aa1				   .LUM2      SET	.LUM2 + .STEP2
     24  7aa1				   .LUM3      SET	.LUM3 + .STEP3
     13  7aa1					      REPEND
     14  7aa1		       66		      .byte.b	$60+(.LUM1/256)
     15  7aa2		       84		      .byte.b	$80+(.LUM2/256)
     16  7aa3		       18		      .byte.b	$10+(.LUM3/256)
     17  7aa4
     18  7aa4
     19  7aa4
     20  7aa4
     21  7aa4
     22  7aa4				   .LUM1      SET	.LUM1 + .STEP1
     23  7aa4				   .LUM2      SET	.LUM2 + .STEP2
     24  7aa4				   .LUM3      SET	.LUM3 + .STEP3
     13  7aa4					      REPEND
     14  7aa4		       66		      .byte.b	$60+(.LUM1/256)
     15  7aa5		       84		      .byte.b	$80+(.LUM2/256)
     16  7aa6		       18		      .byte.b	$10+(.LUM3/256)
     17  7aa7
     18  7aa7
     19  7aa7
     20  7aa7
     21  7aa7
     22  7aa7				   .LUM1      SET	.LUM1 + .STEP1
     23  7aa7				   .LUM2      SET	.LUM2 + .STEP2
     24  7aa7				   .LUM3      SET	.LUM3 + .STEP3
     13  7aa7					      REPEND
     14  7aa7		       66		      .byte.b	$60+(.LUM1/256)
     15  7aa8		       84		      .byte.b	$80+(.LUM2/256)
     16  7aa9		       18		      .byte.b	$10+(.LUM3/256)
     17  7aaa
     18  7aaa
     19  7aaa
     20  7aaa
     21  7aaa
     22  7aaa				   .LUM1      SET	.LUM1 + .STEP1
     23  7aaa				   .LUM2      SET	.LUM2 + .STEP2
     24  7aaa				   .LUM3      SET	.LUM3 + .STEP3
     13  7aaa					      REPEND
     14  7aaa		       66		      .byte.b	$60+(.LUM1/256)
     15  7aab		       84		      .byte.b	$80+(.LUM2/256)
     16  7aac		       18		      .byte.b	$10+(.LUM3/256)
     17  7aad
     18  7aad
     19  7aad
     20  7aad
     21  7aad
     22  7aad				   .LUM1      SET	.LUM1 + .STEP1
     23  7aad				   .LUM2      SET	.LUM2 + .STEP2
     24  7aad				   .LUM3      SET	.LUM3 + .STEP3
     13  7aad					      REPEND
     14  7aad		       66		      .byte.b	$60+(.LUM1/256)
     15  7aae		       84		      .byte.b	$80+(.LUM2/256)
     16  7aaf		       18		      .byte.b	$10+(.LUM3/256)
     17  7ab0
     18  7ab0
     19  7ab0
     20  7ab0
     21  7ab0
     22  7ab0				   .LUM1      SET	.LUM1 + .STEP1
     23  7ab0				   .LUM2      SET	.LUM2 + .STEP2
     24  7ab0				   .LUM3      SET	.LUM3 + .STEP3
     25  7ab0					      REPEND
    343  7ab0							;colr_pal	  LUMTABLE $90, $20, $60, $6,$A,$a,$C,$6,$8
    344  7ab0
    345  7ab0
    346  7ab0							;---------------------------------------------------------------------------------------------------
    347  7ab0
      0  7ab0					      END_BANK
      1  7ab0				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  7ab0				  -	      CHECK_RAM_BANK_SIZE
      3  7ab0					      ELSE
      0  7ab0					      CHECK_BANK_SIZE
      1  7ab0		       02 b0	   .TEMP      =	* - _BANK_START
 ROM bank # 31 TITLESCREEN size = $2b0 free = 335
      2  7ab0					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  7ab0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7ab0				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  7ab0				  -	      ERR
      6  7ab0					      ENDIF
      5  7ab0					      ENDIF
    349  7ab0
    350  7ab0							;---------------------------------------------------------------------------------------------------
    351  7ab0							;EOF
------- FILE ./chess.asm
------- FILE TitleScreen@2.asm LEVEL 2 PASS 4
      0  7ab0					      include	"TitleScreen@2.asm"
      0  7ab0					      SLOT	2
      1  7ab0
      2  7ab0				  -	      IF	(2 < 0) || (2 > 3)
      3  7ab0				  -	      ECHO	"Illegal bank address/segment location", 2
      4  7ab0				  -	      ERR
      5  7ab0					      ENDIF
      6  7ab0
      7  7ab0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  7ab0				   _BANK_SLOT SET	2 * 64
      9  7ab0
      0  7ab0					      ROMBANK	TITLEDATA2
      1  8000 ????				      SEG	ROM_TITLEDATA2
      2  7c00					      ORG	_ORIGIN
      3  7c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  7c00				   _BANK_START SET	*
      5  7c00				   TITLEDATA2_START SET	*
      6  7c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7c00				   ROMBANK_TITLEDATA2 SET	_BANK_SLOT + _CURRENT_BANK
      8  7c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7c00				   _LAST_BANK SETSTR	TITLEDATA2
     10  7c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      3  7c00
      0  7c00					      DEF	TitleData
      1  7c00				   SLOT_TitleData SET	_BANK_SLOT
      2  7c00				   BANK_TitleData SET	SLOT_TitleData + _CURRENT_BANK
      3  7c00				   TitleData
      4  7c00				   TEMPORARY_VAR SET	Overlay
      5  7c00				   TEMPORARY_OFFSET SET	0
      6  7c00				   VAR_BOUNDARY_TitleData SET	TEMPORARY_OFFSET
      7  7c00				   FUNCTION_NAME SET	TitleData
------- FILE titleData.asm LEVEL 3 PASS 4
      0  7c00					      include	"titleData.asm"
      1  7c00				   COL_0
      2  7c00		       07		      .byte.b	7	;R (67)
      3  7c01		       06		      .byte.b	6	;G
      4  7c02		       00		      .byte.b	0	;B
      5  7c03		       02		      .byte.b	2	;R (66)
      6  7c04		       00		      .byte.b	0	;G
      7  7c05		       00		      .byte.b	0	;B
      8  7c06		       00		      .byte.b	0	;R (65)
      9  7c07		       00		      .byte.b	0	;G
     10  7c08		       0b		      .byte.b	11	;B
     11  7c09		       00		      .byte.b	0	;R (64)
     12  7c0a		       00		      .byte.b	0	;G
     13  7c0b		       00		      .byte.b	0	;B
     14  7c0c		       00		      .byte.b	0	;R (63)
     15  7c0d		       00		      .byte.b	0	;G
     16  7c0e		       0b		      .byte.b	11	;B
     17  7c0f		       00		      .byte.b	0	;R (62)
     18  7c10		       00		      .byte.b	0	;G
     19  7c11		       08		      .byte.b	8	;B
     20  7c12		       00		      .byte.b	0	;R (61)
     21  7c13		       00		      .byte.b	0	;G
     22  7c14		       0b		      .byte.b	11	;B
     23  7c15		       00		      .byte.b	0	;R (60)
     24  7c16		       00		      .byte.b	0	;G
     25  7c17		       00		      .byte.b	0	;B
     26  7c18		       00		      .byte.b	0	;R (59)
     27  7c19		       00		      .byte.b	0	;G
     28  7c1a		       00		      .byte.b	0	;B
     29  7c1b		       04		      .byte.b	4	;R (58)
     30  7c1c		       04		      .byte.b	4	;G
     31  7c1d		       00		      .byte.b	0	;B
     32  7c1e		       0f		      .byte.b	15	;R (57)
     33  7c1f		       00		      .byte.b	0	;G
     34  7c20		       00		      .byte.b	0	;B
     35  7c21		       0f		      .byte.b	15	;R (56)
     36  7c22		       00		      .byte.b	0	;G
     37  7c23		       00		      .byte.b	0	;B
     38  7c24		       8f		      .byte.b	143	;R (55)
     39  7c25		       80		      .byte.b	128	;G
     40  7c26		       00		      .byte.b	0	;B
     41  7c27		       8f		      .byte.b	143	;R (54)
     42  7c28		       00		      .byte.b	0	;G
     43  7c29		       00		      .byte.b	0	;B
     44  7c2a		       cf		      .byte.b	207	;R (53)
     45  7c2b		       40		      .byte.b	64	;G
     46  7c2c		       00		      .byte.b	0	;B
     47  7c2d		       0f		      .byte.b	15	;R (52)
     48  7c2e		       00		      .byte.b	0	;G
     49  7c2f		       00		      .byte.b	0	;B
     50  7c30		       0f		      .byte.b	15	;R (51)
     51  7c31		       00		      .byte.b	0	;G
     52  7c32		       00		      .byte.b	0	;B
     53  7c33		       0f		      .byte.b	15	;R (50)
     54  7c34		       00		      .byte.b	0	;G
     55  7c35		       00		      .byte.b	0	;B
     56  7c36		       0f		      .byte.b	15	;R (49)
     57  7c37		       08		      .byte.b	8	;G
     58  7c38		       00		      .byte.b	0	;B
     59  7c39		       07		      .byte.b	7	;R (48)
     60  7c3a		       00		      .byte.b	0	;G
     61  7c3b		       00		      .byte.b	0	;B
     62  7c3c		       07		      .byte.b	7	;R (47)
     63  7c3d		       00		      .byte.b	0	;G
     64  7c3e		       00		      .byte.b	0	;B
     65  7c3f		       07		      .byte.b	7	;R (46)
     66  7c40		       00		      .byte.b	0	;G
     67  7c41		       00		      .byte.b	0	;B
     68  7c42		       07		      .byte.b	7	;R (45)
     69  7c43		       00		      .byte.b	0	;G
     70  7c44		       00		      .byte.b	0	;B
     71  7c45		       07		      .byte.b	7	;R (44)
     72  7c46		       00		      .byte.b	0	;G
     73  7c47		       00		      .byte.b	0	;B
     74  7c48		       07		      .byte.b	7	;R (43)
     75  7c49		       00		      .byte.b	0	;G
     76  7c4a		       00		      .byte.b	0	;B
     77  7c4b		       8f		      .byte.b	143	;R (42)
     78  7c4c		       88		      .byte.b	136	;G
     79  7c4d		       00		      .byte.b	0	;B
     80  7c4e		       cf		      .byte.b	207	;R (41)
     81  7c4f		       40		      .byte.b	64	;G
     82  7c50		       00		      .byte.b	0	;B
     83  7c51		       0f		      .byte.b	15	;R (40)
     84  7c52		       00		      .byte.b	0	;G
     85  7c53		       00		      .byte.b	0	;B
     86  7c54		       0f		      .byte.b	15	;R (39)
     87  7c55		       00		      .byte.b	0	;G
     88  7c56		       00		      .byte.b	0	;B
     89  7c57		       0f		      .byte.b	15	;R (38)
     90  7c58		       02		      .byte.b	2	;G
     91  7c59		       00		      .byte.b	0	;B
     92  7c5a		       cf		      .byte.b	207	;R (37)
     93  7c5b		       c0		      .byte.b	192	;G
     94  7c5c		       00		      .byte.b	0	;B
     95  7c5d		       ef		      .byte.b	239	;R (36)
     96  7c5e		       a0		      .byte.b	160	;G
     97  7c5f		       00		      .byte.b	0	;B
     98  7c60		       ef		      .byte.b	239	;R (35)
     99  7c61		       ea		      .byte.b	234	;G
    100  7c62		       00		      .byte.b	0	;B
    101  7c63		       6f		      .byte.b	111	;R (34)
    102  7c64		       40		      .byte.b	64	;G
    103  7c65		       00		      .byte.b	0	;B
    104  7c66		       0f		      .byte.b	15	;R (33)
    105  7c67		       0a		      .byte.b	10	;G
    106  7c68		       00		      .byte.b	0	;B
    107  7c69		       0f		      .byte.b	15	;R (32)
    108  7c6a		       00		      .byte.b	0	;G
    109  7c6b		       00		      .byte.b	0	;B
    110  7c6c		       4f		      .byte.b	79	;R (31)
    111  7c6d		       41		      .byte.b	65	;G
    112  7c6e		       00		      .byte.b	0	;B
    113  7c6f		       67		      .byte.b	103	;R (30)
    114  7c70		       63		      .byte.b	99	;G
    115  7c71		       08		      .byte.b	8	;B
    116  7c72		       6f		      .byte.b	111	;R (29)
    117  7c73		       41		      .byte.b	65	;G
    118  7c74		       00		      .byte.b	0	;B
    119  7c75		       af		      .byte.b	175	;R (28)
    120  7c76		       89		      .byte.b	137	;G
    121  7c77		       00		      .byte.b	0	;B
    122  7c78		       3f		      .byte.b	63	;R (27)
    123  7c79		       33		      .byte.b	51	;G
    124  7c7a		       00		      .byte.b	0	;B
    125  7c7b		       0f		      .byte.b	15	;R (26)
    126  7c7c		       01		      .byte.b	1	;G
    127  7c7d		       00		      .byte.b	0	;B
    128  7c7e		       cd		      .byte.b	205	;R (25)
    129  7c7f		       c9		      .byte.b	201	;G
    130  7c80		       02		      .byte.b	2	;B
    131  7c81		       cf		      .byte.b	207	;R (24)
    132  7c82		       81		      .byte.b	129	;G
    133  7c83		       00		      .byte.b	0	;B
    134  7c84		       ef		      .byte.b	239	;R (23)
    135  7c85		       e5		      .byte.b	229	;G
    136  7c86		       00		      .byte.b	0	;B
    137  7c87		       4f		      .byte.b	79	;R (22)
    138  7c88		       01		      .byte.b	1	;G
    139  7c89		       00		      .byte.b	0	;B
    140  7c8a		       4f		      .byte.b	79	;R (21)
    141  7c8b		       40		      .byte.b	64	;G
    142  7c8c		       00		      .byte.b	0	;B
    143  7c8d		       8f		      .byte.b	143	;R (20)
    144  7c8e		       8e		      .byte.b	142	;G
    145  7c8f		       00		      .byte.b	0	;B
    146  7c90		       87		      .byte.b	135	;R (19)
    147  7c91		       84		      .byte.b	132	;G
    148  7c92		       00		      .byte.b	0	;B
    149  7c93		       87		      .byte.b	135	;R (18)
    150  7c94		       04		      .byte.b	4	;G
    151  7c95		       00		      .byte.b	0	;B
    152  7c96		       8f		      .byte.b	143	;R (17)
    153  7c97		       0e		      .byte.b	14	;G
    154  7c98		       00		      .byte.b	0	;B
    155  7c99		       8a		      .byte.b	138	;R (16)
    156  7c9a		       8a		      .byte.b	138	;G
    157  7c9b		       00		      .byte.b	0	;B
    158  7c9c		       06		      .byte.b	6	;R (15)
    159  7c9d		       06		      .byte.b	6	;G
    160  7c9e		       00		      .byte.b	0	;B
    161  7c9f		       02		      .byte.b	2	;R (14)
    162  7ca0		       02		      .byte.b	2	;G
    163  7ca1		       00		      .byte.b	0	;B
    164  7ca2		       00		      .byte.b	0	;R (13)
    165  7ca3		       00		      .byte.b	0	;G
    166  7ca4		       00		      .byte.b	0	;B
    167  7ca5		       00		      .byte.b	0	;R (12)
    168  7ca6		       00		      .byte.b	0	;G
    169  7ca7		       00		      .byte.b	0	;B
    170  7ca8		       00		      .byte.b	0	;R (11)
    171  7ca9		       00		      .byte.b	0	;G
    172  7caa		       00		      .byte.b	0	;B
    173  7cab		       00		      .byte.b	0	;R (10)
    174  7cac		       00		      .byte.b	0	;G
    175  7cad		       00		      .byte.b	0	;B
    176  7cae		       00		      .byte.b	0	;R (9)
    177  7caf		       00		      .byte.b	0	;G
    178  7cb0		       00		      .byte.b	0	;B
    179  7cb1		       00		      .byte.b	0	;R (8)
    180  7cb2		       00		      .byte.b	0	;G
    181  7cb3		       07		      .byte.b	7	;B
    182  7cb4		       00		      .byte.b	0	;R (7)
    183  7cb5		       00		      .byte.b	0	;G
    184  7cb6		       05		      .byte.b	5	;B
    185  7cb7		       00		      .byte.b	0	;R (6)
    186  7cb8		       00		      .byte.b	0	;G
    187  7cb9		       05		      .byte.b	5	;B
    188  7cba		       00		      .byte.b	0	;R (5)
    189  7cbb		       00		      .byte.b	0	;G
    190  7cbc		       05		      .byte.b	5	;B
    191  7cbd		       00		      .byte.b	0	;R (4)
    192  7cbe		       00		      .byte.b	0	;G
    193  7cbf		       05		      .byte.b	5	;B
    194  7cc0		       00		      .byte.b	0	;R (3)
    195  7cc1		       00		      .byte.b	0	;G
    196  7cc2		       07		      .byte.b	7	;B
    197  7cc3		       00		      .byte.b	0	;R (2)
    198  7cc4		       00		      .byte.b	0	;G
    199  7cc5		       00		      .byte.b	0	;B
    200  7cc6		       00		      .byte.b	0	;R (1)
    201  7cc7		       00		      .byte.b	0	;G
    202  7cc8		       00		      .byte.b	0	;B
    203  7cc9		       00		      .byte.b	0	;R (0)
    204  7cca		       00		      .byte.b	0	;G
    205  7ccb		       00		      .byte.b	0	;B
    206  7ccc				   COL_1
    207  7ccc		       00		      .byte.b	0	;R (67)
    208  7ccd		       00		      .byte.b	0	;G
    209  7cce		       00		      .byte.b	0	;B
    210  7ccf		       00		      .byte.b	0	;R (66)
    211  7cd0		       00		      .byte.b	0	;G
    212  7cd1		       00		      .byte.b	0	;B
    213  7cd2		       04		      .byte.b	4	;R (65)
    214  7cd3		       00		      .byte.b	0	;G
    215  7cd4		       00		      .byte.b	0	;B
    216  7cd5		       1c		      .byte.b	28	;R (64)
    217  7cd6		       18		      .byte.b	24	;G
    218  7cd7		       01		      .byte.b	1	;B
    219  7cd8		       3c		      .byte.b	60	;R (63)
    220  7cd9		       30		      .byte.b	48	;G
    221  7cda		       01		      .byte.b	1	;B
    222  7cdb		       1c		      .byte.b	28	;R (62)
    223  7cdc		       00		      .byte.b	0	;G
    224  7cdd		       01		      .byte.b	1	;B
    225  7cde		       1c		      .byte.b	28	;R (61)
    226  7cdf		       04		      .byte.b	4	;G
    227  7ce0		       21		      .byte.b	33	;B
    228  7ce1		       1c		      .byte.b	28	;R (60)
    229  7ce2		       08		      .byte.b	8	;G
    230  7ce3		       01		      .byte.b	1	;B
    231  7ce4		       1c		      .byte.b	28	;R (59)
    232  7ce5		       00		      .byte.b	0	;G
    233  7ce6		       00		      .byte.b	0	;B
    234  7ce7		       1b		      .byte.b	27	;R (58)
    235  7ce8		       0b		      .byte.b	11	;G
    236  7ce9		       04		      .byte.b	4	;B
    237  7cea		       1f		      .byte.b	31	;R (57)
    238  7ceb		       1d		      .byte.b	29	;G
    239  7cec		       00		      .byte.b	0	;B
    240  7ced		       df		      .byte.b	223	;R (56)
    241  7cee		       d2		      .byte.b	210	;G
    242  7cef		       20		      .byte.b	32	;B
    243  7cf0		       ff		      .byte.b	255	;R (55)
    244  7cf1		       3c		      .byte.b	60	;G
    245  7cf2		       00		      .byte.b	0	;B
    246  7cf3		       ff		      .byte.b	255	;R (54)
    247  7cf4		       4f		      .byte.b	79	;G
    248  7cf5		       00		      .byte.b	0	;B
    249  7cf6		       ff		      .byte.b	255	;R (53)
    250  7cf7		       93		      .byte.b	147	;G
    251  7cf8		       00		      .byte.b	0	;B
    252  7cf9		       1f		      .byte.b	31	;R (52)
    253  7cfa		       1f		      .byte.b	31	;G
    254  7cfb		       00		      .byte.b	0	;B
    255  7cfc		       00		      .byte.b	0	;R (51)
    256  7cfd		       00		      .byte.b	0	;G
    257  7cfe		       00		      .byte.b	0	;B
    258  7cff		       00		      .byte.b	0	;R (50)
    259  7d00		       00		      .byte.b	0	;G
    260  7d01		       00		      .byte.b	0	;B
    261  7d02		       1a		      .byte.b	26	;R (49)
    262  7d03		       1a		      .byte.b	26	;G
    263  7d04		       00		      .byte.b	0	;B
    264  7d05		       38		      .byte.b	56	;R (48)
    265  7d06		       28		      .byte.b	40	;G
    266  7d07		       00		      .byte.b	0	;B
    267  7d08		       71		      .byte.b	113	;R (47)
    268  7d09		       51		      .byte.b	81	;G
    269  7d0a		       00		      .byte.b	0	;B
    270  7d0b		       0b		      .byte.b	11	;R (46)
    271  7d0c		       0b		      .byte.b	11	;G
    272  7d0d		       00		      .byte.b	0	;B
    273  7d0e		       03		      .byte.b	3	;R (45)
    274  7d0f		       03		      .byte.b	3	;G
    275  7d10		       00		      .byte.b	0	;B
    276  7d11		       ca		      .byte.b	202	;R (44)
    277  7d12		       ca		      .byte.b	202	;G
    278  7d13		       00		      .byte.b	0	;B
    279  7d14		       c8		      .byte.b	200	;R (43)
    280  7d15		       c8		      .byte.b	200	;G
    281  7d16		       00		      .byte.b	0	;B
    282  7d17		       c8		      .byte.b	200	;R (42)
    283  7d18		       40		      .byte.b	64	;G
    284  7d19		       00		      .byte.b	0	;B
    285  7d1a		       48		      .byte.b	72	;R (41)
    286  7d1b		       40		      .byte.b	64	;G
    287  7d1c		       00		      .byte.b	0	;B
    288  7d1d		       08		      .byte.b	8	;R (40)
    289  7d1e		       08		      .byte.b	8	;G
    290  7d1f		       00		      .byte.b	0	;B
    291  7d20		       a0		      .byte.b	160	;R (39)
    292  7d21		       a0		      .byte.b	160	;G
    293  7d22		       00		      .byte.b	0	;B
    294  7d23		       20		      .byte.b	32	;R (38)
    295  7d24		       00		      .byte.b	0	;G
    296  7d25		       00		      .byte.b	0	;B
    297  7d26		       20		      .byte.b	32	;R (37)
    298  7d27		       00		      .byte.b	0	;G
    299  7d28		       00		      .byte.b	0	;B
    300  7d29		       20		      .byte.b	32	;R (36)
    301  7d2a		       20		      .byte.b	32	;G
    302  7d2b		       00		      .byte.b	0	;B
    303  7d2c		       40		      .byte.b	64	;R (35)
    304  7d2d		       40		      .byte.b	64	;G
    305  7d2e		       00		      .byte.b	0	;B
    306  7d2f		       c0		      .byte.b	192	;R (34)
    307  7d30		       c0		      .byte.b	192	;G
    308  7d31		       00		      .byte.b	0	;B
    309  7d32		       40		      .byte.b	64	;R (33)
    310  7d33		       00		      .byte.b	0	;G
    311  7d34		       00		      .byte.b	0	;B
    312  7d35		       40		      .byte.b	64	;R (32)
    313  7d36		       40		      .byte.b	64	;G
    314  7d37		       00		      .byte.b	0	;B
    315  7d38		       00		      .byte.b	0	;R (31)
    316  7d39		       00		      .byte.b	0	;G
    317  7d3a		       00		      .byte.b	0	;B
    318  7d3b		       80		      .byte.b	128	;R (30)
    319  7d3c		       80		      .byte.b	128	;G
    320  7d3d		       00		      .byte.b	0	;B
    321  7d3e		       c0		      .byte.b	192	;R (29)
    322  7d3f		       40		      .byte.b	64	;G
    323  7d40		       00		      .byte.b	0	;B
    324  7d41		       c0		      .byte.b	192	;R (28)
    325  7d42		       c0		      .byte.b	192	;G
    326  7d43		       00		      .byte.b	0	;B
    327  7d44		       40		      .byte.b	64	;R (27)
    328  7d45		       40		      .byte.b	64	;G
    329  7d46		       00		      .byte.b	0	;B
    330  7d47		       00		      .byte.b	0	;R (26)
    331  7d48		       00		      .byte.b	0	;G
    332  7d49		       00		      .byte.b	0	;B
    333  7d4a		       00		      .byte.b	0	;R (25)
    334  7d4b		       00		      .byte.b	0	;G
    335  7d4c		       00		      .byte.b	0	;B
    336  7d4d		       60		      .byte.b	96	;R (24)
    337  7d4e		       20		      .byte.b	32	;G
    338  7d4f		       00		      .byte.b	0	;B
    339  7d50		       60		      .byte.b	96	;R (23)
    340  7d51		       60		      .byte.b	96	;G
    341  7d52		       00		      .byte.b	0	;B
    342  7d53		       00		      .byte.b	0	;R (22)
    343  7d54		       00		      .byte.b	0	;G
    344  7d55		       00		      .byte.b	0	;B
    345  7d56		       a0		      .byte.b	160	;R (21)
    346  7d57		       a0		      .byte.b	160	;G
    347  7d58		       00		      .byte.b	0	;B
    348  7d59		       70		      .byte.b	112	;R (20)
    349  7d5a		       50		      .byte.b	80	;G
    350  7d5b		       00		      .byte.b	0	;B
    351  7d5c		       c0		      .byte.b	192	;R (19)
    352  7d5d		       c0		      .byte.b	192	;G
    353  7d5e		       00		      .byte.b	0	;B
    354  7d5f		       80		      .byte.b	128	;R (18)
    355  7d60		       80		      .byte.b	128	;G
    356  7d61		       00		      .byte.b	0	;B
    357  7d62		       4c		      .byte.b	76	;R (17)
    358  7d63		       4c		      .byte.b	76	;G
    359  7d64		       00		      .byte.b	0	;B
    360  7d65		       5c		      .byte.b	92	;R (16)
    361  7d66		       1c		      .byte.b	28	;G
    362  7d67		       00		      .byte.b	0	;B
    363  7d68		       60		      .byte.b	96	;R (15)
    364  7d69		       60		      .byte.b	96	;G
    365  7d6a		       00		      .byte.b	0	;B
    366  7d6b		       60		      .byte.b	96	;R (14)
    367  7d6c		       20		      .byte.b	32	;G
    368  7d6d		       00		      .byte.b	0	;B
    369  7d6e		       50		      .byte.b	80	;R (13)
    370  7d6f		       50		      .byte.b	80	;G
    371  7d70		       06		      .byte.b	6	;B
    372  7d71		       40		      .byte.b	64	;R (12)
    373  7d72		       40		      .byte.b	64	;G
    374  7d73		       08		      .byte.b	8	;B
    375  7d74		       00		      .byte.b	0	;R (11)
    376  7d75		       00		      .byte.b	0	;G
    377  7d76		       08		      .byte.b	8	;B
    378  7d77		       00		      .byte.b	0	;R (10)
    379  7d78		       00		      .byte.b	0	;G
    380  7d79		       08		      .byte.b	8	;B
    381  7d7a		       00		      .byte.b	0	;R (9)
    382  7d7b		       00		      .byte.b	0	;G
    383  7d7c		       08		      .byte.b	8	;B
    384  7d7d		       00		      .byte.b	0	;R (8)
    385  7d7e		       00		      .byte.b	0	;G
    386  7d7f		       06		      .byte.b	6	;B
    387  7d80		       00		      .byte.b	0	;R (7)
    388  7d81		       00		      .byte.b	0	;G
    389  7d82		       00		      .byte.b	0	;B
    390  7d83		       00		      .byte.b	0	;R (6)
    391  7d84		       00		      .byte.b	0	;G
    392  7d85		       00		      .byte.b	0	;B
    393  7d86		       00		      .byte.b	0	;R (5)
    394  7d87		       00		      .byte.b	0	;G
    395  7d88		       00		      .byte.b	0	;B
    396  7d89		       00		      .byte.b	0	;R (4)
    397  7d8a		       00		      .byte.b	0	;G
    398  7d8b		       00		      .byte.b	0	;B
    399  7d8c		       00		      .byte.b	0	;R (3)
    400  7d8d		       00		      .byte.b	0	;G
    401  7d8e		       00		      .byte.b	0	;B
    402  7d8f		       00		      .byte.b	0	;R (2)
    403  7d90		       00		      .byte.b	0	;G
    404  7d91		       00		      .byte.b	0	;B
    405  7d92		       00		      .byte.b	0	;R (1)
    406  7d93		       00		      .byte.b	0	;G
    407  7d94		       00		      .byte.b	0	;B
    408  7d95		       00		      .byte.b	0	;R (0)
    409  7d96		       00		      .byte.b	0	;G
    410  7d97		       00		      .byte.b	0	;B
    411  7d98				   COL_2
    412  7d98		       f0		      .byte.b	240	;R (67)
    413  7d99		       f0		      .byte.b	240	;G
    414  7d9a		       00		      .byte.b	0	;B
    415  7d9b		       7f		      .byte.b	127	;R (66)
    416  7d9c		       21		      .byte.b	33	;G
    417  7d9d		       00		      .byte.b	0	;B
    418  7d9e		       00		      .byte.b	0	;R (65)
    419  7d9f		       00		      .byte.b	0	;G
    420  7da0		       a8		      .byte.b	168	;B
    421  7da1		       00		      .byte.b	0	;R (64)
    422  7da2		       00		      .byte.b	0	;G
    423  7da3		       ab		      .byte.b	171	;B
    424  7da4		       00		      .byte.b	0	;R (63)
    425  7da5		       00		      .byte.b	0	;G
    426  7da6		       b8		      .byte.b	184	;B
    427  7da7		       00		      .byte.b	0	;R (62)
    428  7da8		       00		      .byte.b	0	;G
    429  7da9		       a8		      .byte.b	168	;B
    430  7daa		       00		      .byte.b	0	;R (61)
    431  7dab		       00		      .byte.b	0	;G
    432  7dac		       a8		      .byte.b	168	;B
    433  7dad		       00		      .byte.b	0	;R (60)
    434  7dae		       00		      .byte.b	0	;G
    435  7daf		       03		      .byte.b	3	;B
    436  7db0		       01		      .byte.b	1	;R (59)
    437  7db1		       01		      .byte.b	1	;G
    438  7db2		       00		      .byte.b	0	;B
    439  7db3		       89		      .byte.b	137	;R (58)
    440  7db4		       89		      .byte.b	137	;G
    441  7db5		       00		      .byte.b	0	;B
    442  7db6		       fd		      .byte.b	253	;R (57)
    443  7db7		       00		      .byte.b	0	;G
    444  7db8		       00		      .byte.b	0	;B
    445  7db9		       fd		      .byte.b	253	;R (56)
    446  7dba		       00		      .byte.b	0	;G
    447  7dbb		       00		      .byte.b	0	;B
    448  7dbc		       fd		      .byte.b	253	;R (55)
    449  7dbd		       00		      .byte.b	0	;G
    450  7dbe		       00		      .byte.b	0	;B
    451  7dbf		       fd		      .byte.b	253	;R (54)
    452  7dc0		       00		      .byte.b	0	;G
    453  7dc1		       00		      .byte.b	0	;B
    454  7dc2		       fd		      .byte.b	253	;R (53)
    455  7dc3		       01		      .byte.b	1	;G
    456  7dc4		       00		      .byte.b	0	;B
    457  7dc5		       fe		      .byte.b	254	;R (52)
    458  7dc6		       06		      .byte.b	6	;G
    459  7dc7		       00		      .byte.b	0	;B
    460  7dc8		       f9		      .byte.b	249	;R (51)
    461  7dc9		       09		      .byte.b	9	;G
    462  7dca		       00		      .byte.b	0	;B
    463  7dcb		       f8		      .byte.b	248	;R (50)
    464  7dcc		       08		      .byte.b	8	;G
    465  7dcd		       00		      .byte.b	0	;B
    466  7dce		       f8		      .byte.b	248	;R (49)
    467  7dcf		       00		      .byte.b	0	;G
    468  7dd0		       00		      .byte.b	0	;B
    469  7dd1		       f8		      .byte.b	248	;R (48)
    470  7dd2		       00		      .byte.b	0	;G
    471  7dd3		       00		      .byte.b	0	;B
    472  7dd4		       fc		      .byte.b	252	;R (47)
    473  7dd5		       04		      .byte.b	4	;G
    474  7dd6		       00		      .byte.b	0	;B
    475  7dd7		       fc		      .byte.b	252	;R (46)
    476  7dd8		       04		      .byte.b	4	;G
    477  7dd9		       00		      .byte.b	0	;B
    478  7dda		       fc		      .byte.b	252	;R (45)
    479  7ddb		       04		      .byte.b	4	;G
    480  7ddc		       00		      .byte.b	0	;B
    481  7ddd		       fc		      .byte.b	252	;R (44)
    482  7dde		       84		      .byte.b	132	;G
    483  7ddf		       00		      .byte.b	0	;B
    484  7de0		       fc		      .byte.b	252	;R (43)
    485  7de1		       00		      .byte.b	0	;G
    486  7de2		       00		      .byte.b	0	;B
    487  7de3		       fc		      .byte.b	252	;R (42)
    488  7de4		       00		      .byte.b	0	;G
    489  7de5		       00		      .byte.b	0	;B
    490  7de6		       fc		      .byte.b	252	;R (41)
    491  7de7		       00		      .byte.b	0	;G
    492  7de8		       00		      .byte.b	0	;B
    493  7de9		       fc		      .byte.b	252	;R (40)
    494  7dea		       04		      .byte.b	4	;G
    495  7deb		       00		      .byte.b	0	;B
    496  7dec		       f8		      .byte.b	248	;R (39)
    497  7ded		       00		      .byte.b	0	;G
    498  7dee		       00		      .byte.b	0	;B
    499  7def		       f8		      .byte.b	248	;R (38)
    500  7df0		       00		      .byte.b	0	;G
    501  7df1		       00		      .byte.b	0	;B
    502  7df2		       f8		      .byte.b	248	;R (37)
    503  7df3		       08		      .byte.b	8	;G
    504  7df4		       00		      .byte.b	0	;B
    505  7df5		       f0		      .byte.b	240	;R (36)
    506  7df6		       00		      .byte.b	0	;G
    507  7df7		       00		      .byte.b	0	;B
    508  7df8		       e0		      .byte.b	224	;R (35)
    509  7df9		       20		      .byte.b	32	;G
    510  7dfa		       00		      .byte.b	0	;B
    511  7dfb		       c0		      .byte.b	192	;R (34)
    512  7dfc		       40		      .byte.b	64	;G
    513  7dfd		       00		      .byte.b	0	;B
    514  7dfe		       00		      .byte.b	0	;R (33)
    515  7dff		       00		      .byte.b	0	;G
    516  7e00		       80		      .byte.b	128	;B
    517  7e01		       02		      .byte.b	2	;R (32)
    518  7e02		       02		      .byte.b	2	;G
    519  7e03		       00		      .byte.b	0	;B
    520  7e04		       67		      .byte.b	103	;R (31)
    521  7e05		       07		      .byte.b	7	;G
    522  7e06		       10		      .byte.b	16	;B
    523  7e07		       7f		      .byte.b	127	;R (30)
    524  7e08		       0a		      .byte.b	10	;G
    525  7e09		       80		      .byte.b	128	;B
    526  7e0a		       ff		      .byte.b	255	;R (29)
    527  7e0b		       20		      .byte.b	32	;G
    528  7e0c		       00		      .byte.b	0	;B
    529  7e0d		       ff		      .byte.b	255	;R (28)
    530  7e0e		       12		      .byte.b	18	;G
    531  7e0f		       00		      .byte.b	0	;B
    532  7e10		       ff		      .byte.b	255	;R (27)
    533  7e11		       44		      .byte.b	68	;G
    534  7e12		       00		      .byte.b	0	;B
    535  7e13		       fc		      .byte.b	252	;R (26)
    536  7e14		       20		      .byte.b	32	;G
    537  7e15		       00		      .byte.b	0	;B
    538  7e16		       f8		      .byte.b	248	;R (25)
    539  7e17		       e8		      .byte.b	232	;G
    540  7e18		       00		      .byte.b	0	;B
    541  7e19		       b0		      .byte.b	176	;R (24)
    542  7e1a		       a0		      .byte.b	160	;G
    543  7e1b		       00		      .byte.b	0	;B
    544  7e1c		       40		      .byte.b	64	;R (23)
    545  7e1d		       40		      .byte.b	64	;G
    546  7e1e		       80		      .byte.b	128	;B
    547  7e1f		       e0		      .byte.b	224	;R (22)
    548  7e20		       00		      .byte.b	0	;G
    549  7e21		       00		      .byte.b	0	;B
    550  7e22		       b0		      .byte.b	176	;R (21)
    551  7e23		       10		      .byte.b	16	;G
    552  7e24		       40		      .byte.b	64	;B
    553  7e25		       e0		      .byte.b	224	;R (20)
    554  7e26		       20		      .byte.b	32	;G
    555  7e27		       00		      .byte.b	0	;B
    556  7e28		       c0		      .byte.b	192	;R (19)
    557  7e29		       c0		      .byte.b	192	;G
    558  7e2a		       00		      .byte.b	0	;B
    559  7e2b		       80		      .byte.b	128	;R (18)
    560  7e2c		       00		      .byte.b	0	;G
    561  7e2d		       00		      .byte.b	0	;B
    562  7e2e		       c0		      .byte.b	192	;R (17)
    563  7e2f		       c0		      .byte.b	192	;G
    564  7e30		       00		      .byte.b	0	;B
    565  7e31		       00		      .byte.b	0	;R (16)
    566  7e32		       00		      .byte.b	0	;G
    567  7e33		       00		      .byte.b	0	;B
    568  7e34		       00		      .byte.b	0	;R (15)
    569  7e35		       00		      .byte.b	0	;G
    570  7e36		       00		      .byte.b	0	;B
    571  7e37		       00		      .byte.b	0	;R (14)
    572  7e38		       00		      .byte.b	0	;G
    573  7e39		       00		      .byte.b	0	;B
    574  7e3a		       00		      .byte.b	0	;R (13)
    575  7e3b		       00		      .byte.b	0	;G
    576  7e3c		       00		      .byte.b	0	;B
    577  7e3d		       00		      .byte.b	0	;R (12)
    578  7e3e		       00		      .byte.b	0	;G
    579  7e3f		       00		      .byte.b	0	;B
    580  7e40		       00		      .byte.b	0	;R (11)
    581  7e41		       00		      .byte.b	0	;G
    582  7e42		       00		      .byte.b	0	;B
    583  7e43		       00		      .byte.b	0	;R (10)
    584  7e44		       00		      .byte.b	0	;G
    585  7e45		       07		      .byte.b	7	;B
    586  7e46		       00		      .byte.b	0	;R (9)
    587  7e47		       00		      .byte.b	0	;G
    588  7e48		       05		      .byte.b	5	;B
    589  7e49		       00		      .byte.b	0	;R (8)
    590  7e4a		       00		      .byte.b	0	;G
    591  7e4b		       55		      .byte.b	85	;B
    592  7e4c		       00		      .byte.b	0	;R (7)
    593  7e4d		       00		      .byte.b	0	;G
    594  7e4e		       55		      .byte.b	85	;B
    595  7e4f		       00		      .byte.b	0	;R (6)
    596  7e50		       00		      .byte.b	0	;G
    597  7e51		       35		      .byte.b	53	;B
    598  7e52		       00		      .byte.b	0	;R (5)
    599  7e53		       00		      .byte.b	0	;G
    600  7e54		       57		      .byte.b	87	;B
    601  7e55		       00		      .byte.b	0	;R (4)
    602  7e56		       00		      .byte.b	0	;G
    603  7e57		       50		      .byte.b	80	;B
    604  7e58		       00		      .byte.b	0	;R (3)
    605  7e59		       00		      .byte.b	0	;G
    606  7e5a		       30		      .byte.b	48	;B
    607  7e5b		       00		      .byte.b	0	;R (2)
    608  7e5c		       00		      .byte.b	0	;G
    609  7e5d		       00		      .byte.b	0	;B
    610  7e5e		       00		      .byte.b	0	;R (1)
    611  7e5f		       00		      .byte.b	0	;G
    612  7e60		       00		      .byte.b	0	;B
    613  7e61		       00		      .byte.b	0	;R (0)
    614  7e62		       00		      .byte.b	0	;G
    615  7e63		       00		      .byte.b	0	;B
    616  7e64				   COL_3
    617  7e64		       80		      .byte.b	128	;R (67)
    618  7e65		       80		      .byte.b	128	;G
    619  7e66		       00		      .byte.b	0	;B
    620  7e67		       78		      .byte.b	120	;R (66)
    621  7e68		       10		      .byte.b	16	;G
    622  7e69		       00		      .byte.b	0	;B
    623  7e6a		       02		      .byte.b	2	;R (65)
    624  7e6b		       02		      .byte.b	2	;G
    625  7e6c		       c0		      .byte.b	192	;B
    626  7e6d		       03		      .byte.b	3	;R (64)
    627  7e6e		       00		      .byte.b	0	;G
    628  7e6f		       5c		      .byte.b	92	;B
    629  7e70		       01		      .byte.b	1	;R (63)
    630  7e71		       00		      .byte.b	0	;G
    631  7e72		       c4		      .byte.b	196	;B
    632  7e73		       01		      .byte.b	1	;R (62)
    633  7e74		       00		      .byte.b	0	;G
    634  7e75		       1c		      .byte.b	28	;B
    635  7e76		       01		      .byte.b	1	;R (61)
    636  7e77		       00		      .byte.b	0	;G
    637  7e78		       d0		      .byte.b	208	;B
    638  7e79		       01		      .byte.b	1	;R (60)
    639  7e7a		       00		      .byte.b	0	;G
    640  7e7b		       1c		      .byte.b	28	;B
    641  7e7c		       01		      .byte.b	1	;R (59)
    642  7e7d		       00		      .byte.b	0	;G
    643  7e7e		       00		      .byte.b	0	;B
    644  7e7f		       1f		      .byte.b	31	;R (58)
    645  7e80		       1f		      .byte.b	31	;G
    646  7e81		       00		      .byte.b	0	;B
    647  7e82		       df		      .byte.b	223	;R (57)
    648  7e83		       53		      .byte.b	83	;G
    649  7e84		       00		      .byte.b	0	;B
    650  7e85		       df		      .byte.b	223	;R (56)
    651  7e86		       14		      .byte.b	20	;G
    652  7e87		       00		      .byte.b	0	;B
    653  7e88		       df		      .byte.b	223	;R (55)
    654  7e89		       13		      .byte.b	19	;G
    655  7e8a		       00		      .byte.b	0	;B
    656  7e8b		       df		      .byte.b	223	;R (54)
    657  7e8c		       1f		      .byte.b	31	;G
    658  7e8d		       00		      .byte.b	0	;B
    659  7e8e		       cf		      .byte.b	207	;R (53)
    660  7e8f		       4e		      .byte.b	78	;G
    661  7e90		       00		      .byte.b	0	;B
    662  7e91		       ef		      .byte.b	239	;R (52)
    663  7e92		       6f		      .byte.b	111	;G
    664  7e93		       00		      .byte.b	0	;B
    665  7e94		       90		      .byte.b	144	;R (51)
    666  7e95		       10		      .byte.b	16	;G
    667  7e96		       00		      .byte.b	0	;B
    668  7e97		       88		      .byte.b	136	;R (50)
    669  7e98		       88		      .byte.b	136	;G
    670  7e99		       00		      .byte.b	0	;B
    671  7e9a		       01		      .byte.b	1	;R (49)
    672  7e9b		       01		      .byte.b	1	;G
    673  7e9c		       00		      .byte.b	0	;B
    674  7e9d		       03		      .byte.b	3	;R (48)
    675  7e9e		       03		      .byte.b	3	;G
    676  7e9f		       00		      .byte.b	0	;B
    677  7ea0		       09		      .byte.b	9	;R (47)
    678  7ea1		       09		      .byte.b	9	;G
    679  7ea2		       00		      .byte.b	0	;B
    680  7ea3		       08		      .byte.b	8	;R (46)
    681  7ea4		       08		      .byte.b	8	;G
    682  7ea5		       00		      .byte.b	0	;B
    683  7ea6		       0c		      .byte.b	12	;R (45)
    684  7ea7		       0c		      .byte.b	12	;G
    685  7ea8		       00		      .byte.b	0	;B
    686  7ea9		       05		      .byte.b	5	;R (44)
    687  7eaa		       05		      .byte.b	5	;G
    688  7eab		       00		      .byte.b	0	;B
    689  7eac		       01		      .byte.b	1	;R (43)
    690  7ead		       00		      .byte.b	0	;G
    691  7eae		       00		      .byte.b	0	;B
    692  7eaf		       01		      .byte.b	1	;R (42)
    693  7eb0		       00		      .byte.b	0	;G
    694  7eb1		       00		      .byte.b	0	;B
    695  7eb2		       01		      .byte.b	1	;R (41)
    696  7eb3		       00		      .byte.b	0	;G
    697  7eb4		       00		      .byte.b	0	;B
    698  7eb5		       81		      .byte.b	129	;R (40)
    699  7eb6		       81		      .byte.b	129	;G
    700  7eb7		       00		      .byte.b	0	;B
    701  7eb8		       c0		      .byte.b	192	;R (39)
    702  7eb9		       40		      .byte.b	64	;G
    703  7eba		       00		      .byte.b	0	;B
    704  7ebb		       c0		      .byte.b	192	;R (38)
    705  7ebc		       00		      .byte.b	0	;G
    706  7ebd		       00		      .byte.b	0	;B
    707  7ebe		       e0		      .byte.b	224	;R (37)
    708  7ebf		       20		      .byte.b	32	;G
    709  7ec0		       00		      .byte.b	0	;B
    710  7ec1		       e0		      .byte.b	224	;R (36)
    711  7ec2		       00		      .byte.b	0	;G
    712  7ec3		       00		      .byte.b	0	;B
    713  7ec4		       f0		      .byte.b	240	;R (35)
    714  7ec5		       10		      .byte.b	16	;G
    715  7ec6		       00		      .byte.b	0	;B
    716  7ec7		       f0		      .byte.b	240	;R (34)
    717  7ec8		       00		      .byte.b	0	;G
    718  7ec9		       00		      .byte.b	0	;B
    719  7eca		       f8		      .byte.b	248	;R (33)
    720  7ecb		       08		      .byte.b	8	;G
    721  7ecc		       00		      .byte.b	0	;B
    722  7ecd		       f8		      .byte.b	248	;R (32)
    723  7ece		       08		      .byte.b	8	;G
    724  7ecf		       00		      .byte.b	0	;B
    725  7ed0		       f0		      .byte.b	240	;R (31)
    726  7ed1		       80		      .byte.b	128	;G
    727  7ed2		       00		      .byte.b	0	;B
    728  7ed3		       f0		      .byte.b	240	;R (30)
    729  7ed4		       00		      .byte.b	0	;G
    730  7ed5		       00		      .byte.b	0	;B
    731  7ed6		       f8		      .byte.b	248	;R (29)
    732  7ed7		       88		      .byte.b	136	;G
    733  7ed8		       00		      .byte.b	0	;B
    734  7ed9		       f8		      .byte.b	248	;R (28)
    735  7eda		       08		      .byte.b	8	;G
    736  7edb		       00		      .byte.b	0	;B
    737  7edc		       f8		      .byte.b	248	;R (27)
    738  7edd		       08		      .byte.b	8	;G
    739  7ede		       00		      .byte.b	0	;B
    740  7edf		       f8		      .byte.b	248	;R (26)
    741  7ee0		       88		      .byte.b	136	;G
    742  7ee1		       00		      .byte.b	0	;B
    743  7ee2		       f8		      .byte.b	248	;R (25)
    744  7ee3		       08		      .byte.b	8	;G
    745  7ee4		       00		      .byte.b	0	;B
    746  7ee5		       f8		      .byte.b	248	;R (24)
    747  7ee6		       08		      .byte.b	8	;G
    748  7ee7		       00		      .byte.b	0	;B
    749  7ee8		       f8		      .byte.b	248	;R (23)
    750  7ee9		       08		      .byte.b	8	;G
    751  7eea		       00		      .byte.b	0	;B
    752  7eeb		       f0		      .byte.b	240	;R (22)
    753  7eec		       00		      .byte.b	0	;G
    754  7eed		       00		      .byte.b	0	;B
    755  7eee		       f0		      .byte.b	240	;R (21)
    756  7eef		       10		      .byte.b	16	;G
    757  7ef0		       00		      .byte.b	0	;B
    758  7ef1		       e0		      .byte.b	224	;R (20)
    759  7ef2		       20		      .byte.b	32	;G
    760  7ef3		       00		      .byte.b	0	;B
    761  7ef4		       c0		      .byte.b	192	;R (19)
    762  7ef5		       00		      .byte.b	0	;G
    763  7ef6		       00		      .byte.b	0	;B
    764  7ef7		       c0		      .byte.b	192	;R (18)
    765  7ef8		       40		      .byte.b	64	;G
    766  7ef9		       00		      .byte.b	0	;B
    767  7efa		       83		      .byte.b	131	;R (17)
    768  7efb		       83		      .byte.b	131	;G
    769  7efc		       00		      .byte.b	0	;B
    770  7efd		       03		      .byte.b	3	;R (16)
    771  7efe		       03		      .byte.b	3	;G
    772  7eff		       00		      .byte.b	0	;B
    773  7f00		       01		      .byte.b	1	;R (15)
    774  7f01		       01		      .byte.b	1	;G
    775  7f02		       00		      .byte.b	0	;B
    776  7f03		       00		      .byte.b	0	;R (14)
    777  7f04		       00		      .byte.b	0	;G
    778  7f05		       00		      .byte.b	0	;B
    779  7f06		       00		      .byte.b	0	;R (13)
    780  7f07		       00		      .byte.b	0	;G
    781  7f08		       0a		      .byte.b	10	;B
    782  7f09		       00		      .byte.b	0	;R (12)
    783  7f0a		       00		      .byte.b	0	;G
    784  7f0b		       0a		      .byte.b	10	;B
    785  7f0c		       00		      .byte.b	0	;R (11)
    786  7f0d		       00		      .byte.b	0	;G
    787  7f0e		       0e		      .byte.b	14	;B
    788  7f0f		       00		      .byte.b	0	;R (10)
    789  7f10		       00		      .byte.b	0	;G
    790  7f11		       aa		      .byte.b	170	;B
    791  7f12		       00		      .byte.b	0	;R (9)
    792  7f13		       00		      .byte.b	0	;G
    793  7f14		       ae		      .byte.b	174	;B
    794  7f15		       00		      .byte.b	0	;R (8)
    795  7f16		       00		      .byte.b	0	;G
    796  7f17		       a4		      .byte.b	164	;B
    797  7f18		       00		      .byte.b	0	;R (7)
    798  7f19		       00		      .byte.b	0	;G
    799  7f1a		       a0		      .byte.b	160	;B
    800  7f1b		       00		      .byte.b	0	;R (6)
    801  7f1c		       00		      .byte.b	0	;G
    802  7f1d		       a0		      .byte.b	160	;B
    803  7f1e		       00		      .byte.b	0	;R (5)
    804  7f1f		       00		      .byte.b	0	;G
    805  7f20		       c0		      .byte.b	192	;B
    806  7f21		       00		      .byte.b	0	;R (4)
    807  7f22		       00		      .byte.b	0	;G
    808  7f23		       00		      .byte.b	0	;B
    809  7f24		       00		      .byte.b	0	;R (3)
    810  7f25		       00		      .byte.b	0	;G
    811  7f26		       00		      .byte.b	0	;B
    812  7f27		       00		      .byte.b	0	;R (2)
    813  7f28		       00		      .byte.b	0	;G
    814  7f29		       00		      .byte.b	0	;B
    815  7f2a		       00		      .byte.b	0	;R (1)
    816  7f2b		       00		      .byte.b	0	;G
    817  7f2c		       00		      .byte.b	0	;B
    818  7f2d		       00		      .byte.b	0	;R (0)
    819  7f2e		       00		      .byte.b	0	;G
    820  7f2f		       00		      .byte.b	0	;B
    821  7f30				   COL_4
    822  7f30		       00		      .byte.b	0	;R (67)
    823  7f31		       00		      .byte.b	0	;G
    824  7f32		       00		      .byte.b	0	;B
    825  7f33		       00		      .byte.b	0	;R (66)
    826  7f34		       00		      .byte.b	0	;G
    827  7f35		       00		      .byte.b	0	;B
    828  7f36		       00		      .byte.b	0	;R (65)
    829  7f37		       00		      .byte.b	0	;G
    830  7f38		       00		      .byte.b	0	;B
    831  7f39		       01		      .byte.b	1	;R (64)
    832  7f3a		       01		      .byte.b	1	;G
    833  7f3b		       00		      .byte.b	0	;B
    834  7f3c		       03		      .byte.b	3	;R (63)
    835  7f3d		       02		      .byte.b	2	;G
    836  7f3e		       00		      .byte.b	0	;B
    837  7f3f		       03		      .byte.b	3	;R (62)
    838  7f40		       03		      .byte.b	3	;G
    839  7f41		       00		      .byte.b	0	;B
    840  7f42		       03		      .byte.b	3	;R (61)
    841  7f43		       02		      .byte.b	2	;G
    842  7f44		       00		      .byte.b	0	;B
    843  7f45		       03		      .byte.b	3	;R (60)
    844  7f46		       03		      .byte.b	3	;G
    845  7f47		       00		      .byte.b	0	;B
    846  7f48		       03		      .byte.b	3	;R (59)
    847  7f49		       02		      .byte.b	2	;G
    848  7f4a		       00		      .byte.b	0	;B
    849  7f4b		       03		      .byte.b	3	;R (58)
    850  7f4c		       03		      .byte.b	3	;G
    851  7f4d		       00		      .byte.b	0	;B
    852  7f4e		       03		      .byte.b	3	;R (57)
    853  7f4f		       03		      .byte.b	3	;G
    854  7f50		       00		      .byte.b	0	;B
    855  7f51		       0d		      .byte.b	13	;R (56)
    856  7f52		       0d		      .byte.b	13	;G
    857  7f53		       00		      .byte.b	0	;B
    858  7f54		       1f		      .byte.b	31	;R (55)
    859  7f55		       0b		      .byte.b	11	;G
    860  7f56		       00		      .byte.b	0	;B
    861  7f57		       3f		      .byte.b	63	;R (54)
    862  7f58		       25		      .byte.b	37	;G
    863  7f59		       00		      .byte.b	0	;B
    864  7f5a		       3f		      .byte.b	63	;R (53)
    865  7f5b		       30		      .byte.b	48	;G
    866  7f5c		       00		      .byte.b	0	;B
    867  7f5d		       21		      .byte.b	33	;R (52)
    868  7f5e		       21		      .byte.b	33	;G
    869  7f5f		       00		      .byte.b	0	;B
    870  7f60		       00		      .byte.b	0	;R (51)
    871  7f61		       00		      .byte.b	0	;G
    872  7f62		       00		      .byte.b	0	;B
    873  7f63		       00		      .byte.b	0	;R (50)
    874  7f64		       00		      .byte.b	0	;G
    875  7f65		       00		      .byte.b	0	;B
    876  7f66		       01		      .byte.b	1	;R (49)
    877  7f67		       01		      .byte.b	1	;G
    878  7f68		       00		      .byte.b	0	;B
    879  7f69		       03		      .byte.b	3	;R (48)
    880  7f6a		       02		      .byte.b	2	;G
    881  7f6b		       00		      .byte.b	0	;B
    882  7f6c		       07		      .byte.b	7	;R (47)
    883  7f6d		       07		      .byte.b	7	;G
    884  7f6e		       00		      .byte.b	0	;B
    885  7f6f		       00		      .byte.b	0	;R (46)
    886  7f70		       00		      .byte.b	0	;G
    887  7f71		       00		      .byte.b	0	;B
    888  7f72		       00		      .byte.b	0	;R (45)
    889  7f73		       00		      .byte.b	0	;G
    890  7f74		       00		      .byte.b	0	;B
    891  7f75		       06		      .byte.b	6	;R (44)
    892  7f76		       06		      .byte.b	6	;G
    893  7f77		       00		      .byte.b	0	;B
    894  7f78		       0c		      .byte.b	12	;R (43)
    895  7f79		       04		      .byte.b	4	;G
    896  7f7a		       00		      .byte.b	0	;B
    897  7f7b		       1c		      .byte.b	28	;R (42)
    898  7f7c		       1c		      .byte.b	28	;G
    899  7f7d		       00		      .byte.b	0	;B
    900  7f7e		       38		      .byte.b	56	;R (41)
    901  7f7f		       38		      .byte.b	56	;G
    902  7f80		       00		      .byte.b	0	;B
    903  7f81		       00		      .byte.b	0	;R (40)
    904  7f82		       00		      .byte.b	0	;G
    905  7f83		       00		      .byte.b	0	;B
    906  7f84		       0a		      .byte.b	10	;R (39)
    907  7f85		       0a		      .byte.b	10	;G
    908  7f86		       00		      .byte.b	0	;B
    909  7f87		       02		      .byte.b	2	;R (38)
    910  7f88		       00		      .byte.b	0	;G
    911  7f89		       00		      .byte.b	0	;B
    912  7f8a		       32		      .byte.b	50	;R (37)
    913  7f8b		       30		      .byte.b	48	;G
    914  7f8c		       00		      .byte.b	0	;B
    915  7f8d		       72		      .byte.b	114	;R (36)
    916  7f8e		       72		      .byte.b	114	;G
    917  7f8f		       00		      .byte.b	0	;B
    918  7f90		       74		      .byte.b	116	;R (35)
    919  7f91		       54		      .byte.b	84	;G
    920  7f92		       00		      .byte.b	0	;B
    921  7f93		       54		      .byte.b	84	;R (34)
    922  7f94		       10		      .byte.b	16	;G
    923  7f95		       00		      .byte.b	0	;B
    924  7f96		       04		      .byte.b	4	;R (33)
    925  7f97		       00		      .byte.b	0	;G
    926  7f98		       00		      .byte.b	0	;B
    927  7f99		       02		      .byte.b	2	;R (32)
    928  7f9a		       02		      .byte.b	2	;G
    929  7f9b		       00		      .byte.b	0	;B
    930  7f9c		       10		      .byte.b	16	;R (31)
    931  7f9d		       10		      .byte.b	16	;G
    932  7f9e		       00		      .byte.b	0	;B
    933  7f9f		       68		      .byte.b	104	;R (30)
    934  7fa0		       68		      .byte.b	104	;G
    935  7fa1		       00		      .byte.b	0	;B
    936  7fa2		       6c		      .byte.b	108	;R (29)
    937  7fa3		       24		      .byte.b	36	;G
    938  7fa4		       00		      .byte.b	0	;B
    939  7fa5		       4c		      .byte.b	76	;R (28)
    940  7fa6		       08		      .byte.b	8	;G
    941  7fa7		       00		      .byte.b	0	;B
    942  7fa8		       d4		      .byte.b	212	;R (27)
    943  7fa9		       d4		      .byte.b	212	;G
    944  7faa		       00		      .byte.b	0	;B
    945  7fab		       00		      .byte.b	0	;R (26)
    946  7fac		       00		      .byte.b	0	;G
    947  7fad		       00		      .byte.b	0	;B
    948  7fae		       2c		      .byte.b	44	;R (25)
    949  7faf		       2c		      .byte.b	44	;G
    950  7fb0		       00		      .byte.b	0	;B
    951  7fb1		       36		      .byte.b	54	;R (24)
    952  7fb2		       16		      .byte.b	22	;G
    953  7fb3		       00		      .byte.b	0	;B
    954  7fb4		       2e		      .byte.b	46	;R (23)
    955  7fb5		       0e		      .byte.b	14	;G
    956  7fb6		       00		      .byte.b	0	;B
    957  7fb7		       60		      .byte.b	96	;R (22)
    958  7fb8		       40		      .byte.b	64	;G
    959  7fb9		       00		      .byte.b	0	;B
    960  7fba		       28		      .byte.b	40	;R (21)
    961  7fbb		       28		      .byte.b	40	;G
    962  7fbc		       00		      .byte.b	0	;B
    963  7fbd		       0f		      .byte.b	15	;R (20)
    964  7fbe		       0d		      .byte.b	13	;G
    965  7fbf		       00		      .byte.b	0	;B
    966  7fc0		       1a		      .byte.b	26	;R (19)
    967  7fc1		       1a		      .byte.b	26	;G
    968  7fc2		       00		      .byte.b	0	;B
    969  7fc3		       18		      .byte.b	24	;R (18)
    970  7fc4		       08		      .byte.b	8	;G
    971  7fc5		       00		      .byte.b	0	;B
    972  7fc6		       14		      .byte.b	20	;R (17)
    973  7fc7		       04		      .byte.b	4	;G
    974  7fc8		       00		      .byte.b	0	;B
    975  7fc9		       16		      .byte.b	22	;R (16)
    976  7fca		       16		      .byte.b	22	;G
    977  7fcb		       00		      .byte.b	0	;B
    978  7fcc		       04		      .byte.b	4	;R (15)
    979  7fcd		       00		      .byte.b	0	;G
    980  7fce		       00		      .byte.b	0	;B
    981  7fcf		       06		      .byte.b	6	;R (14)
    982  7fd0		       02		      .byte.b	2	;G
    983  7fd1		       00		      .byte.b	0	;B
    984  7fd2		       05		      .byte.b	5	;R (13)
    985  7fd3		       05		      .byte.b	5	;G
    986  7fd4		       00		      .byte.b	0	;B
    987  7fd5		       05		      .byte.b	5	;R (12)
    988  7fd6		       05		      .byte.b	5	;G
    989  7fd7		       00		      .byte.b	0	;B
    990  7fd8		       00		      .byte.b	0	;R (11)
    991  7fd9		       00		      .byte.b	0	;G
    992  7fda		       00		      .byte.b	0	;B
    993  7fdb		       00		      .byte.b	0	;R (10)
    994  7fdc		       00		      .byte.b	0	;G
    995  7fdd		       00		      .byte.b	0	;B
    996  7fde		       00		      .byte.b	0	;R (9)
    997  7fdf		       00		      .byte.b	0	;G
    998  7fe0		       00		      .byte.b	0	;B
    999  7fe1		       00		      .byte.b	0	;R (8)
   1000  7fe2		       00		      .byte.b	0	;G
   1001  7fe3		       00		      .byte.b	0	;B
   1002  7fe4		       00		      .byte.b	0	;R (7)
   1003  7fe5		       00		      .byte.b	0	;G
   1004  7fe6		       00		      .byte.b	0	;B
   1005  7fe7		       00		      .byte.b	0	;R (6)
   1006  7fe8		       00		      .byte.b	0	;G
   1007  7fe9		       00		      .byte.b	0	;B
   1008  7fea		       00		      .byte.b	0	;R (5)
   1009  7feb		       00		      .byte.b	0	;G
   1010  7fec		       00		      .byte.b	0	;B
   1011  7fed		       00		      .byte.b	0	;R (4)
   1012  7fee		       00		      .byte.b	0	;G
   1013  7fef		       00		      .byte.b	0	;B
   1014  7ff0		       00		      .byte.b	0	;R (3)
   1015  7ff1		       00		      .byte.b	0	;G
   1016  7ff2		       00		      .byte.b	0	;B
   1017  7ff3		       00		      .byte.b	0	;R (2)
   1018  7ff4		       00		      .byte.b	0	;G
   1019  7ff5		       00		      .byte.b	0	;B
   1020  7ff6		       00		      .byte.b	0	;R (1)
   1021  7ff7		       00		      .byte.b	0	;G
   1022  7ff8		       00		      .byte.b	0	;B
   1023  7ff9		       00		      .byte.b	0	;R (0)
   1024  7ffa		       00		      .byte.b	0	;G
   1025  7ffb		       00		      .byte.b	0	;B
------- FILE TitleScreen@2.asm
      6  7ffc
      0  7ffc					      END_BANK
      1  7ffc				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  7ffc				  -	      CHECK_RAM_BANK_SIZE
      3  7ffc					      ELSE
      0  7ffc					      CHECK_BANK_SIZE
      1  7ffc		       03 fc	   .TEMP      =	* - _BANK_START
 ROM bank # 32 TITLEDATA2 size = $3fc free = 3
      2  7ffc					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  7ffc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7ffc				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  7ffc				  -	      ERR
      6  7ffc					      ENDIF
      5  7ffc					      ENDIF
------- FILE ./chess.asm
    219  7ffc
    220  7ffc
    221  7ffc
    222  8000		       00 00 00 00	      ALIGN	_ROM_BANK_SIZE
    223  8000
 32 ROM BANKS
    224  8000					      ECHO	[_ORIGIN/_ROM_BANK_SIZE]d, "ROM BANKS"
 36 RAM BANKS
    225  8000					      ECHO	[ORIGIN_RAM / _RAM_BANK_SIZE]d, "RAM BANKS"
    226  8000
    227  8000							;---------------------------------------------------------------------------------------------------
    228  8000							;EOF
