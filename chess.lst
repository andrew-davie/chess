------- FILE ./chess.asm LEVEL 1 PASS 4
      1  8000 ????						; Chess
      2  8000 ????						; Atari 2600 Chess display system
      3  8000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  8000 ????						; andrew@taswegian.com
      5  8000 ????
      6  8000 ????
      7  8000 ????	       00 00	   TIA_BASE_ADDRESS =	0	;$40
      8  8000 ????
      9  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0000
     82 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0000
     84 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U002d
    130 U002d							;-------------------------------------------------------------------------------
    131 U002d
    132 U000e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0000					      ORG	TIA_BASE_READ_ADDRESS
    134 U0000
    135 U0000							;											bit 7	 bit 6
    136 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U000e
    151 U000e							;-------------------------------------------------------------------------------
    152 U000e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREF RED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE _ MACROS.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"_ MACROS.asm"
      1  0000 ????						; MACROS.asm
      2  0000 ????						;---------------------------------------------------------------------------------------------------
      3  0000 ????
      4  0000 ????				      MAC	def
      5  0000 ????			   SLOT_{1}   SET	_BANK_SLOT
      6  0000 ????			   BANK_{1}   SET	SLOT_{1} + _CURRENT_BANK	; bank in which this subroutine resides
      7  0000 ????			   {1}			; entry point
      8  0000 ????			   TEMPORARY_VAR SET	Overlay
      9  0000 ????			   TEMPORARY_OFFSET SET	0
     10  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
     11  0000 ????			   FUNCTION_NAME SET	{1}
     12  0000 ????				      ENDM		; name of subroutine
     13  0000 ????
     14  0000 ????
     15  0000 ????						;---------------------------------------------------------------------------------------------------
     16  0000 ????
     17  0000 ????				      MAC	ramdef
     18  0000 ????
     19  0000 ????						; Just an alternate name for "DEF" that makes it clear the subroutine is in RAM
     20  0000 ????
     21  0000 ????				      DEF	{1}
     22  0000 ????				      ENDM		; {name of subroutine}
     23  0000 ????
     24  0000 ????
     25  0000 ????						;---------------------------------------------------------------------------------------------------
     26  0000 ????
     27  0000 ????				      MAC	slot
     28  0000 ????
     29  0000 ????				      IF	({1} < 0) || ({1} > 3)
     30  0000 ????				      ECHO	"Illegal bank address/segment location", {1}
     31  0000 ????				      ERR
     32  0000 ????				      ENDIF
     33  0000 ????
     34  0000 ????			   _BANK_ADDRESS_ORIGIN SET	$F000 + ({1} * _ROM_BANK_SIZE)
     35  0000 ????			   _BANK_SLOT SET	{1} * 64	; D7/D6 selector
     36  0000 ????
     37  0000 ????				      ENDM		; {1}
     38  0000 ????
     39  0000 ????
     40  0000 ????						;---------------------------------------------------------------------------------------------------
     41  0000 ????						; Temporary local variables
     42  0000 ????						; usage:
     43  0000 ????						;
     44  0000 ????						;   DEF fna
     45  0000 ????						;	 REF fnc
     46  0000 ????						;	 REF fnd
     47  0000 ????						;	 VAR localVar1,1
     48  0000 ????						;	 VAR ptr,2
     49  0000 ????						;	 VEND fna
     50  0000 ????						;
     51  0000 ????						; The above declares a functino named 'fna'
     52  0000 ????						; The function declares two local variables, 'localVar1' (1 byte) and 'ptr' (2 bytes)
     53  0000 ????						; These variables are given an address in the overlay area which does NOT overlap any of
     54  0000 ????						; the local variables which are declared in the referring functions 'fnc' and 'fnd'
     55  0000 ????						; Although the local variables are available to other functions (i.e., global in scope), care
     56  0000 ????						; should be taken NOT to use them in other functions unless absolutely necessary and required.
     57  0000 ????						; To share local variables between functions, they should be (re)declared in both so that they
     58  0000 ????						; have exactly the same addresses.
     59  0000 ????
     60  0000 ????
     61  0000 ????
     62  0000 ????						; The relative offset into the overlay area for the next variable declaration...
     63  0000 ????			   TEMPORARY_OFFSET SET	0
     64  0000 ????
     65  0000 ????
     66  0000 ????						;---------------------------------------------------------------------------------------------------
     67  0000 ????
     68  0000 ????						; Finalise the declaration block for local variables
     69  0000 ????						; {1} = name of the function for which this block is defined
     70  0000 ????				      MAC	vend
     71  0000 ????						; register the end of variables for this function
     72  0000 ????
     73  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
     74  0000 ????						;V2_._FUNCTION_NAME = TEMPORARY_VAR
     75  0000 ????				      ENDM
     76  0000 ????
     77  0000 ????
     78  0000 ????						;---------------------------------------------------------------------------------------------------
     79  0000 ????
     80  0000 ????						; Note a reference to this function by an external function
     81  0000 ????						; The external function's VEND block is used to guarantee that variables for
     82  0000 ????						; the function we are declaring will start AFTER all other variables in all referencing blocks
     83  0000 ????
     84  0000 ????				      MAC	ref
     85  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
     86  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
     87  0000 ????				      ENDIF
     88  0000 ????				      ENDM		; {1}
     89  0000 ????
     90  0000 ????
     91  0000 ????						;---------------------------------------------------------------------------------------------------
     92  0000 ????
     93  0000 ????						; Define a temporary variable for use in a subroutine
     94  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
     95  0000 ????
     96  0000 ????				      MAC	var
     97  0000 ????			   {1}	      =	TEMPORARY_VAR
     98  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
     99  0000 ????
    100  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    101  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    102  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    103  0000 ????				      ENDIF
    104  0000 ????				      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
    105  0000 ????			   VNAME      SETSTR	{1}
    106  0000 ????				      ECHO	"Temporary Variable", VNAME, "overflow!"
    107  0000 ????				      ERR
    108  0000 ????				      ENDIF
    109  0000 ????				      ENDM		; { name, size }
    110  0000 ????
    111  0000 ????
    112  0000 ????						;---------------------------------------------------------------------------------------------------
    113  0000 ????
    114  0000 ????				      MAC	rombank
    115  0000 ????				      SEG	ROM_{1}
    116  0000 ????				      ORG	_ORIGIN
    117  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    118  0000 ????			   _BANK_START SET	*
    119  0000 ????			   {1}_START  SET	*
    120  0000 ????			   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
    121  0000 ????			   ROMBANK_{1} SET	_BANK_SLOT + _CURRENT_BANK
    122  0000 ????			   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
    123  0000 ????			   _LAST_BANK SETSTR	{1}
    124  0000 ????			   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    125  0000 ????				      ENDM		; bank name
    126  0000 ????
    127  0000 ????
    128  0000 ????						;---------------------------------------------------------------------------------------------------
    129  0000 ????
    130  0000 ????				      MAC	check_bank_size
    131  0000 ????			   .TEMP      =	* - _BANK_START
    132  0000 ????				      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
    133  0000 ????				      IF	( .TEMP ) > _ROM_BANK_SIZE
    134  0000 ????				      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
    135  0000 ????				      ERR
    136  0000 ????				      ENDIF
    137  0000 ????				      ENDM
    138  0000 ????
    139  0000 ????
    140  0000 ????						;---------------------------------------------------------------------------------------------------
    141  0000 ????
    142  0000 ????				      MAC	check_ram_bank_size
    143  0000 ????			   .TEMP      =	* - _BANK_START
    144  0000 ????				      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
    145  0000 ????				      IF	( .TEMP ) > _RAM_BANK_SIZE
    146  0000 ????				      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
    147  0000 ????				      ERR
    148  0000 ????				      ENDIF
    149  0000 ????				      ENDM
    150  0000 ????
    151  0000 ????
    152  0000 ????						;---------------------------------------------------------------------------------------------------
    153  0000 ????
    154  0000 ????	       00 00	   _TYPE_RAM  =	0
    155  0000 ????	       00 01	   _TYPE_ROM  =	1
    156  0000 ????
    157  0000 ????				      MAC	end_bank
    158  0000 ????				      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
    159  0000 ????				      CHECK_RAM_BANK_SIZE
    160  0000 ????				      ELSE
    161  0000 ????				      CHECK_BANK_SIZE
    162  0000 ????				      ENDIF
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						;---------------------------------------------------------------------------------------------------
    167  0000 ????
    168  0000 ????				      MACRO	rambank
    169  0000 ????
    170  0000 ????				      SEG.U	RAM_{1}
    171  0000 ????				      ORG	ORIGIN_RAM
    172  0000 ????				      RORG	_BANK_ADDRESS_ORIGIN
    173  0000 ????			   _BANK_START SET	*
    174  0000 ????			   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
    175  0000 ????			   RAMBANK_{1} SET	_BANK_SLOT + _CURRENT_RAMBANK
    176  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
    177  0000 ????			   _LAST_BANK SETSTR	{1}
    178  0000 ????			   _CURRENT_BANK_TYPE SET	_TYPE_RAM
    179  0000 ????				      ENDM		; {bank name}
    180  0000 ????
    181  0000 ????
    182  0000 ????						;---------------------------------------------------------------------------------------------------
    183  0000 ????
    184  0000 ????						; Failsafe call of function in another bank
    185  0000 ????						; This will check the slot #s for current, call to make sure they're not the same!
    186  0000 ????
    187  0000 ????				      MAC	call
    188  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    189  0000 ????			   FNAME      SETSTR	{1}
    190  0000 ????				      ECHO	""
    191  0000 ????				      ECHO	"ERROR: Incompatible slot for call to function", FNAME
    192  0000 ????				      ECHO	"Cannot switch bank in use for ", FNAME
    193  0000 ????				      ERR
    194  0000 ????				      ENDIF
    195  0000 ????				      lda	#BANK_{1}
    196  0000 ????				      sta	SET_BANK
    197  0000 ????				      jsr	{1}
    198  0000 ????				      ENDM		; function name
    199  0000 ????
    200  0000 ????
    201  0000 ????						;---------------------------------------------------------------------------------------------------
    202  0000 ????
    203  0000 ????				      MAC	jump
    204  0000 ????				      IF	SLOT_{1} == _BANK_SLOT
    205  0000 ????			   FNAME      SETSTR	{1}
    206  0000 ????				      ECHO	""
    207  0000 ????				      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
    208  0000 ????				      ECHO	"Cannot switch bank in use for ", FNAME
    209  0000 ????				      ERR
    210  0000 ????				      ENDIF
    211  0000 ????				      lda	#BANK_{1}
    212  0000 ????				      sta	SET_BANK
    213  0000 ????				      jmp	{1}
    214  0000 ????				      ENDM		; function name
    215  0000 ????
    216  0000 ????
    217  0000 ????						;---------------------------------------------------------------------------------------------------
    218  0000 ????						; Macro inserts a page break if the object would overlap a page
    219  0000 ????
    220  0000 ????				      MAC	optional_pagebreak
    221  0000 ????
    222  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    223  0000 ????			   .EARLY_LOCATION SET	*
    224  0000 ????				      ALIGN	256
    225  0000 ????				      ECHO	"Page break for", {1}, "wasted", [* - .EARLY_LOCATION]d, "bytes"
    226  0000 ????				      ENDIF
    227  0000 ????				      ENDM		; { labelString, size }
    228  0000 ????
    229  0000 ????
    230  0000 ????						;---------------------------------------------------------------------------------------------------
    231  0000 ????
    232  0000 ????						; @author Fred Quimby
    233  0000 ????						; same as bAtari Basic rnd
    234  0000 ????
    235  0000 ????	       00 b4	   RND_EOR_VAL =	$B4
    236  0000 ????
    237  0000 ????				      MAC	next_random
    238  0000 ????
    239  0000 ????				      lda	rnd
    240  0000 ????				      lsr
    241  0000 ????				      bcc	.skipEOR
    242  0000 ????				      eor	#RND_EOR_VAL
    243  0000 ????			   .skipEOR   sta	rnd
    244  0000 ????
    245  0000 ????				      ENDM
    246  0000 ????
    247  0000 ????
    248  0000 ????						;---------------------------------------------------------------------------------------------------
    249  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    250  0000 ????
    251  0000 ????				      MAC	variable
    252  0000 ????
    253  0000 ????			   .NAME      SETSTR	{1}
    254  0000 ????				      OPTIONAL_PAGEBREAK	.NAME, {2}
    255  0000 ????			   {1}	      ds	{2}
    256  0000 ????
    257  0000 ????				      ENDM		; {name, size}
    258  0000 ????
    259  0000 ????
    260  0000 ????						;---------------------------------------------------------------------------------------------------
    261  0000 ????
    262  0000 ????						;TODO - check
    263  0000 ????
    264  0000 ????				      MAC	allocate
    265  0000 ????
    266  0000 ????			   .NAME      SETSTR	{1}
    267  0000 ????				      OPTIONAL_PAGEBREAK	.NAME, {2}
    268  0000 ????				      DEF	{1}
    269  0000 ????
    270  0000 ????				      ENDM		; {label}, {size}
    271  0000 ????
    272  0000 ????
    273  0000 ????						;---------------------------------------------------------------------------------------------------
    274  0000 ????
    275  0000 ????				      MAC	negeval
    276  0000 ????
    277  0000 ????				      sec
    278  0000 ????				      lda	#0
    279  0000 ????				      sbc	Evaluation
    280  0000 ????				      sta	Evaluation
    281  0000 ????				      lda	#0
    282  0000 ????				      sbc	Evaluation+1
    283  0000 ????				      sta	Evaluation+1
    284  0000 ????
    285  0000 ????				      ENDM
    286  0000 ????
    287  0000 ????
    288  0000 ????						;---------------------------------------------------------------------------------------------------
    289  0000 ????
    290  0000 ????				      MAC	swap
    291  0000 ????
    292  0000 ????				      lda	sideToMove
    293  0000 ????				      eor	#SWAP_SIDE|HUMAN
    294  0000 ????				      sta	sideToMove
    295  0000 ????
    296  0000 ????				      ENDM
    297  0000 ????
    298  0000 ????
    299  0000 ????						;---------------------------------------------------------------------------------------------------
    300  0000 ????						; RAM accessor macros
    301  0000 ????						; ALL RAM usage (reads and writes) should use these
    302  0000 ????						; They automate the write offset address addition, and make it clear what memory is being accessed
    303  0000 ????
    304  0000 ????
    305  0000 ????				      MAC	sta@ram
    306  0000 ????				      sta	[RAM]+{0}
    307  0000 ????				      ENDM		;{}
    308  0000 ????
    309  0000 ????				      MAC	stx@ram
    310  0000 ????				      stx	[RAM]+{0}
    311  0000 ????				      ENDM
    312  0000 ????
    313  0000 ????				      MAC	sty@ram
    314  0000 ????				      sty	[RAM]+{0}
    315  0000 ????				      ENDM
    316  0000 ????
    317  0000 ????				      MAC	sta@ply
    318  0000 ????				      sta	[RAM]+{0}
    319  0000 ????				      ENDM		;{}
    320  0000 ????
    321  0000 ????				      MAC	stx@ply
    322  0000 ????				      stx	[RAM]+{0}
    323  0000 ????				      ENDM
    324  0000 ????
    325  0000 ????				      MAC	sty@ply
    326  0000 ????				      sty	[RAM]+{0}
    327  0000 ????				      ENDM
    328  0000 ????
    329  0000 ????
    330  0000 ????				      MAC	lda@ram
    331  0000 ????				      lda	{0}
    332  0000 ????				      ENDM		;{}
    333  0000 ????
    334  0000 ????				      MAC	ldx@ram
    335  0000 ????				      ldx	{0}
    336  0000 ????				      ENDM		;{}
    337  0000 ????
    338  0000 ????				      MAC	ldy@ram
    339  0000 ????				      ldy	{0}
    340  0000 ????				      ENDM		;{}
    341  0000 ????
    342  0000 ????
    343  0000 ????				      MAC	lda@ply
    344  0000 ????				      lda	{0}
    345  0000 ????				      ENDM		;{}
    346  0000 ????
    347  0000 ????				      MAC	ldx@ply
    348  0000 ????				      ldx	{0}
    349  0000 ????				      ENDM		;{}
    350  0000 ????
    351  0000 ????				      MAC	ldy@ply
    352  0000 ????				      ldy	{0}
    353  0000 ????				      ENDM		;{}
    354  0000 ????
    355  0000 ????				      MAC	adc@ply
    356  0000 ????				      adc	{0}
    357  0000 ????				      ENDM		;{}
    358  0000 ????
    359  0000 ????				      MAC	sbc@ply
    360  0000 ????				      sbc	{0}
    361  0000 ????				      ENDM		;{}
    362  0000 ????
    363  0000 ????				      MAC	cmp@ply
    364  0000 ????				      cmp	{0}
    365  0000 ????				      ENDM		;{}
    366  0000 ????
    367  0000 ????				      MAC	ora@ram
    368  0000 ????				      ora	{0}
    369  0000 ????				      ENDM
    370  0000 ????
    371  0000 ????				      MAC	eor@ram
    372  0000 ????				      eor	{0}
    373  0000 ????				      ENDM
    374  0000 ????
    375  0000 ????				      MAC	and@ram
    376  0000 ????				      and	{0}
    377  0000 ????				      ENDM
    378  0000 ????
    379  0000 ????						;---------------------------------------------------------------------------------------------------
    380  0000 ????
    381  0000 ????				      MAC	set_platform
    382  0000 ????
    383  0000 ????						; 00 = NTSC
    384  0000 ????						; 01 = NTSC
    385  0000 ????						; 10 = PAL-50
    386  0000 ????						; 11 = PAL-60
    387  0000 ????				      lda	SWCHB
    388  0000 ????				      rol
    389  0000 ????				      rol
    390  0000 ????				      rol
    391  0000 ????				      and	#%11
    392  0000 ????				      eor	#PAL
    393  0000 ????				      sta	platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    394  0000 ????
    395  0000 ????				      ENDM
    396  0000 ????
    397  0000 ????
    398  0000 ????						;---------------------------------------------------------------------------------------------------
    399  0000 ????
    400  0000 ????				      MAC	timecheck
    401  0000 ????
    402  0000 ????				      lda	INTIM
    403  0000 ????				      cmp	#SPEEDOF_{1}
    404  0000 ????				      bcc	{2}
    405  0000 ????
    406  0000 ????				      ENDM		; {ident}, {branch if out of time}
    407  0000 ????
    408  0000 ????
    409  0000 ????						;---------------------------------------------------------------------------------------------------
    410  0000 ????
    411  0000 ????				      MAC	timing
    412  0000 ????
    413  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    414  0000 ????
    415  0000 ????				      ENDM		; {label}, {cycles}
    416  0000 ????
    417  0000 ????
    418  0000 ????						;---------------------------------------------------------------------------------------------------
    419  0000 ????						;EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 4
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     14  0000 ????
     15  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     16  0000 ????
     17  0000 ????			   ORIGIN     SET	0
     18  0000 ????			   ORIGIN_RAM SET	0
     19  0000 ????
     20  0000 ????						;include "segtime.asm"
     21  0000 ????
     22  0000 ????
     23  0000 ????	       00 00	   _FIRST_BANK =	0	; 3E+ 1st bank holds reset vectors
     24  0000 ????
     25  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     26  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     27  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     28  0000 ????						;FIXED_BANK		 = 31 * 2048	       ; ->> 64K
     29  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     30  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     31  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     32  0000 ????
     33  0000 ????	       00 01	   YES	      =	1
     34  0000 ????	       00 00	   NO	      =	0
     35  0000 ????	       00 40	   HUMAN      =	64
     36  0000 ????
     37  0000 ????	       7f ff	   INFINITY   =	$8000-1	;32767
     38  0000 ????
     39  0000 ????
     40  0000 ????						; assemble diagnostics. Remove for release.
     41  0000 ????
     42  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     43  0000 ????	       00 00	   DIAGNOSTICS =	0
     44  0000 ????	       00 01	   QUIESCENCE =	1
     45  0000 ????	       00 00	   ASSERTS    =	0
     46  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     47  0000 ????	       00 01	   ENPASSANT_ENABLED =	1
     48  0000 ????	       00 01	   CASTLING_ENABLED =	1
     49  0000 ????						;RAINBOW		  = 1			     ; comment out to disable
     50  0000 ????
     51  0000 ????	       00 02	   SELECT_SWITCH =	2	; (SWCHB & SELECT_SWITCH)  0 == PRESSED
     52  0000 ????
     53  0000 ????
     54  0000 ????						; NOTE: SEARCH_DEPTH cannot be < 3, because the player's moves are generated from PLY+1, and use
     55  0000 ????						; PLY+2 for computer response (thus, 3). The bank allocation gets stomped!
     56  0000 ????
     57  0000 ????
     58  0000 ????	       00 04	   SEARCH_DEPTH =	4
     59  0000 ????	       00 03	   QUIESCE_EXTRA_DEPTH =	3
     60  0000 ????
     61  0000 ????
     62  0000 ????			  -	      IF	SEARCH_DEPTH < 3
     63  0000 ????			  -	      ECHO	"ERROR: Search depth must be >= 3"
     64  0000 ????			  -	      ERR
     65  0000 ????				      ENDIF
     66  0000 ????
     67  0000 ????
     68  0000 ????
     69  0000 ????	       00 07	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     70  0000 ????	       00 07	   MAX_PLY_DEPTH_BANK =	PLY_BANKS	;TODO -- RAMBANK_PLY + PLY_BANKS
     71  0000 ????
     72  0000 ????						;IF RAMBANK_PLY + MAX_PLY_DEPTH_BANK > 31
     73  0000 ????						;    ERR "Not enough RAM for PLY banks"
     74  0000 ????						;ENDIF
     75  0000 ????
     76  0000 ????
     77  0000 ????
     78  0000 ????
     79  0000 ????	       00 80	   SWAP_SIDE  =	128	;TODO + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     80  0000 ????
     81  0000 ????
     82  0000 ????
     83  0000 ????						; DELAYS
     84  0000 ????
     85  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     86  0000 ????
     87  0000 ????						;===================================
     88  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     89  0000 ????						;===================================
     90  0000 ????
     91  0000 ????						;-------------------------------------------------------------------------------
     92  0000 ????						; The following are optional YES/NO depending on phase of the moon
     93  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     96  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     97  0000 ????			  -	      IF	FINAL_VERSION = YES
     98  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     99  0000 ????				      ENDIF
    100  0000 ????
    101  0000 ????						;-------------------------------------------------------------------------------
    102  0000 ????
    103  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    104  0000 ????
    105  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    106  0000 ????
    107  0000 ????						;------------------------------------------------------------------------------
    108  0000 ????
    109  0000 ????	       00 00	   PLUSCART   =	NO
    110  0000 ????
    111  0000 ????						;------------------------------------------------------------------------------
    112  0000 ????
    113  0000 ????
    114  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
    115  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    116  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
    117  0000 ????
    118  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    119  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    120  0000 ????
    121  0000 ????
    122  0000 ????	       04 00	   RAM_SIZE   =	$400	; address space for write AND read
    123  0000 ????	       02 00	   RAM_WRITE  =	$200	; add this to RAM address when doing writes
    124  0000 ????	       02 00	   RAM	      =	RAM_WRITE
    125  0000 ????
    126  0000 ????	       04 00	   _ROM_BANK_SIZE =	$400
    127  0000 ????	       02 00	   _RAM_BANK_SIZE =	$200
    128  0000 ????
    129  0000 ????
    130  0000 ????						; Platform constants:
    131  0000 ????	       00 02	   PAL	      =	%10
    132  0000 ????	       00 02	   PAL_50     =	PAL|0
    133  0000 ????	       00 03	   PAL_60     =	PAL|1
    134  0000 ????
    135  0000 ????	       00 86	   NTSC_COLOUR_LINE_1 =	$86	; blue
    136  0000 ????	       00 48	   NTSC_COLOUR_LINE_2 =	$48	; red
    137  0000 ????	       00 da	   NTSC_COLOUR_LINE_3 =	$DA	; green
    138  0000 ????
    139  0000 ????	       00 d6	   PAL_COLOUR_LINE_1 =	$D6	; blue
    140  0000 ????	       00 6a	   PAL_COLOUR_LINE_2 =	$6A	; red
    141  0000 ????	       00 3c	   PAL_COLOUR_LINE_3 =	$3C	; green
    142  0000 ????
    143  0000 ????
    144  0000 ????	       00 2e	   TIME_PART_2 =	46	;68
    145  0000 ????	       00 2d	   TIME_PART_1 =	45	;66
    146  0000 ????	       00 38	   TIME_PART_2_PAL =	56
    147  0000 ????	       00 4e	   TIME_PART_1_PAL =	78
    148  0000 ????
    149  0000 ????
    150  0000 ????	       00 00	   SLOT0      =	0
    151  0000 ????	       00 40	   SLOT1      =	64
    152  0000 ????	       00 80	   SLOT2      =	128
    153  0000 ????	       00 c0	   SLOT3      =	192
    154  0000 ????
    155  0000 ????
    156  0000 ????						;---------------------------------------------------------------------------------------------------
    157  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00b2 ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   framenum   ds	1
     10 U0081
     11 U0081		       00	   squareToDraw ds	1
     12 U0082		       00	   rnd	      ds	1	; random
     13 U0083		       00	   drawDelay  ds	1
     14 U0084		       00	   lastSquareX12 ds	1
     15 U0085
     16 U0085		       00	   drawCount  ds	1
     17 U0086		       00	   fromX12    ds	1
     18 U0087		       00	   toX12      ds	1
     19 U0088		       00	   originX12  ds	1
     20 U0089
     21 U0089		       00	   cursorX12  ds	1
     22 U008a
     23 U008a		       00	   mdelay     ds	1
     24 U008b		       00	   ccur       ds	1
     25 U008c		       00	   aiState    ds	1	; state
     26 U008d		       00	   aiFlashDelay ds	1
     27 U008e
     28 U008e		       00	   aiMoveIndex ds	1
     29 U008f
     30 U008f		       00	   aiFlashPhase ds	1
     31 U0090
     32 U0090		       00 00	   Evaluation ds	2	; tracks value of the board position
     33 U0092
     34 U0092		       00	   currentPiece ds	1
     35 U0093		       00	   currentSquare ds	1
     36 U0094		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     37 U0095		       00	   currentPly ds	1
     38 U0096
     39 U0096		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     40 U0097		       00	   fromPiece  ds	1
     41 U0098		       00	   lastPiece  ds	1
     42 U0099		       00	   previousPiece ds	1
     43 U009a
     44 U009a							;Platform			  ds 1		      ; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     45 U009a		       00 00	   speech_addr ds	2
     46 U009c							;bg				  ds 1
     47 U009c
     48 U009c		       00	   voxframe   ds	1
     49 U009d		       00	   temp       ds	1
     50 U009e		       00	   switch_states ds	1
     51 U009f		       00	   switch_edges ds	1
     52 U00a0
     53 U00a0
     54 U00a0
     55 U00a0
     56 U00a0		       00	   capture    ds	1
     57 U00a1
     58 U00a1				  -	      IF	DIAGNOSTICS
     59 U00a1				  -positionCount ds	3
     60 U00a1					      ENDIF
     61 U00a1
     62 U00a1							;maxPly			  ds 1
     63 U00a1		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     64 U00a2							;protecting			  ds 1
     65 U00a2		       00	   randomness ds	1
     66 U00a3							;__psb 			  ds 2
     67 U00a3
     68 U00a3		       00 00	   vkSquare   ds	2	; current move's king traversal squares during castling
     69 U00a5							;human 			  ds 1		      ; colour of human
     70 U00a5
     71 U00a5		       00	   platform   ds	1	; 0=NTSC, 1=PAL
     72 U00a6
     73 U00a6				  -	      IFCONST	RAINBOW
     74 U00a6				  -base       ds	1
     75 U00a6					      ENDIF
     76 U00a6
     77 U00a6
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 4
      0 U00a6					      include	"overlays.asm"
      1 U00a6							; Chess
      2 U00a6							; Atari 2600 Chess display system
      3 U00a6							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a6							; andrew@taswegian.com
      5 U00a6
      6 U00a6							;---------------------------------------------------------------------------------------------------
      7 U00a6							; OVERLAYS!
      8 U00a6							; These variables are overlays, and should be managed with care
      9 U00a6							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a6							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a6							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a6							; overlay #2
     13 U00a6
     14 U00a6							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a6
     16 U00a6							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a6							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a6							;---------------------------------------------------------------------------------------------------
     19 U00a6
     20 U00a6
     21 U00a6							;OVERLAY_SIZE	  SET $4C	    ; maximum size
     22 U00a6				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     23 U00a6
     24 U00a6
     25 U00a6							; This overlay variable is used for the overlay variables.  That's OK.
     26 U00a6							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     27 U00a6							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     28 U00a6							; (especially the latter ones) are only used in rare occasions.
     29 U00a6
     30 U00a6							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     31 U00a6							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     32 U00a6
      0 U00a6					      DEF	Overlay
      1 U00a6				   SLOT_Overlay SET	_BANK_SLOT
      2 U00a6				   BANK_Overlay SET	SLOT_Overlay + _CURRENT_BANK
      3 U00a6				   Overlay
      4 U00a6				   TEMPORARY_VAR SET	Overlay
      5 U00a6				   TEMPORARY_OFFSET SET	0
      6 U00a6				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      7 U00a6				   FUNCTION_NAME SET	Overlay
     34 U00a6					      ds	MAXIMUM_REQUIRED_OVERLAY_SIZE	;--> overlay (share) variables
     35 U00a6				   END_OF_OVERLAY
     36 U00a6
     37 U00a6							;---------------------------------------------------------------------------------------------------
     38 U00a6							; And now... the overlays....
     39 U00a6
 ---- OVERLAYS ( bytes ) ----
     40 U00a6					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     41 U00a6
     42 U00a6							;---------------------------------------------------------------------------------------------------
     43 U00a6
      0 U00a6					      DEF	Variable_PieceShapeBuffer
      1 U00a6				   SLOT_Variable_PieceShapeBuffer SET	_BANK_SLOT
      2 U00a6				   BANK_Variable_PieceShapeBuffer SET	SLOT_Variable_PieceShapeBuffer + _CURRENT_BANK
      3 U00a6				   Variable_PieceShapeBuffer
      4 U00a6				   TEMPORARY_VAR SET	Overlay
      5 U00a6				   TEMPORARY_OFFSET SET	0
      6 U00a6				   VAR_BOUNDARY_Variable_PieceShapeBuffer SET	TEMPORARY_OFFSET
      7 U00a6				   FUNCTION_NAME SET	Variable_PieceShapeBuffer
      0 U00a6					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00a6		       00 a6	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00a6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00a6
      4 U00a6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00a6					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00a6				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00a6					      ENDIF
      8 U00a6				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9 U00a6				  -VNAME      SETSTR	__pieceShapeBuffer
     10 U00a6				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11 U00a6				  -	      ERR
     12 U00a6					      ENDIF
      0 U00a6					      VEND	Variable_PieceShapeBuffer
      1 U00a6
      2 U00a6
      3 U00a6		       00 ee	   VAREND_Variable_PieceShapeBuffer =	TEMPORARY_VAR
      4 U00a6
     47 U00a6
     48 U00a6							;---------------------------------------------------------------------------------------------------
     49 U00a6
     50 U00a6
     51 U00a6					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     52 U00a6					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $48
     53 U00a6					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     54 U00a6
     55 U00a6							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 4
      0 U00a6					      include	"stack.asm"
      1 U00a6							; Chess
      2 U00a6							; Atari 2600 Chess display system
      3 U00a6							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a6							; andrew@taswegian.com
      5 U00a6
      6 U00a6
      7 U00a6		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00a6		       00 f3	   TOP_OF_STACK =	$FF-RESERVED_FOR_STACK
      9 U00a6
     10 U00a6		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     11 U00b2
     12 U00b2							; WARNING/NOTE - the alphabeta search violates the above size constraints
     13 U00b2							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     14 U00b2							;  but since overlay is not generally stressed during alphabeta, we're good.
     15 U00b2
     16 U00b2							; Ensure there isn't any stomping of stack/overlay excess usage
     17 U00b2
 Overlay boundary:  $ee
     18 U00b2					      ECHO	"Overlay boundary: ", Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE
 Stack boundary:  $f1
     19 U00b2					      ECHO	"Stack boundary: ", $FF- PLY_BANKS*2
     20 U00b2
     21 U00b2
     22 U00b2							; IGNORE stack stomping (sort of)
     23 U00b2							; The stack area is not used by the ply code...
     24 U00b2
     25 U00b2							;IF ($FF - PLY_BANKS*2) < (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     26 U00b2							;    ECHO "ERROR: Not enough reserved space for stack with given #PLY"
     27 U00b2							;    ERR
     28 U00b2							;ENDIF
     29 U00b2
     30 U00b2							;IF TOP_OF_STACK <= (Overlay + MAXIMUM_REQUIRED_OVERLAY_SIZE)
     31 U00b2							;    ECHO "ERROR: Not enough reserved space for stack"
     32 U00b2							;    ERR
     33 U00b2							;ENDIF
     34 U00b2
     35 U00b2
------- FILE ./chess.asm
    161 U00b2
 FREE BYTES IN ZERO PAGE =  $4d
    162 U00b2					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    163 U00b2				  -	      IF	* > $FF
    164 U00b2				  -	      ERR	"Zero Page overflow!"
    165 U00b2					      ENDIF
    166 U00b2
    167 U00b2							;------------------------------------------------------------------------------
    168 U00b2							;##############################################################################
    169 U00b2							;------------------------------------------------------------------------------
    170 U00b2
    171 U00b2							; NOW THE VERY INTERESTING '3E' RAM BANKS
    172 U00b2							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 512 bytes TOTAL ACCESSIBLE
    173 U00b2							; IN A 1K MEMORY SPACE
    174 U00b2
    175 U00b2
    176 U00b2							;---------------------------------------------------------------------------------------------------
    177 U00b2
    178 U00b2
    179 U00b2					      MAC	phase
    180 U00b2					      lda	#AI_{1}
    181 U00b2					      sta	aiState
    182 U00b2					      ENDM		;#
    183 U00b2
    184 U00b2
    185 U00b2							;--------------------------------------------------------------------------------
    186 U00b2
------- FILE _ PIECE MACROS.asm LEVEL 2 PASS 4
      0 U00b2					      include	"_ PIECE MACROS.asm"
      1 U00b2							; Copyright (C)2020 Andrew Davie
      2 U00b2							; Common macros for piece move handlers
      3 U00b2
      4 U00b2							;---------------------------------------------------------------------------------------------------
      5 U00b2							; Looks at a square offset {1} to see if piece can move to it
      6 U00b2							; Adds the square to the movelist if it can
      7 U00b2							; Keeps moving in the same direction until it's blocked/off=board
      8 U00b2
      9 U00b2					      MAC	move_towards
     10 U00b2					      SUBROUTINE
     11 U00b2
     12 U00b2							; = 76 for single square (empty/take)
     13 U00b2
     14 U00b2					      lda	#0
     15 U00b2					      sta	capture
     16 U00b2
     17 U00b2					      ldx	currentSquare	; 3
     18 U00b2					      bne	.project	; 3   unconditional
     19 U00b2
     20 U00b2				   .empty     jsr	AddMove	; 57
     21 U00b2				   .project   ldy	ValidSquare+{1},x	; 4
     22 U00b2					      bmi	.invalid	; 2/3 off board!
     23 U00b2					      lda	Board,y	; 4   piece @ destination
     24 U00b2					      beq	.empty	; 2/3
     25 U00b2					      sta	capture
     26 U00b2					      eor	currentPiece	; 3
     27 U00b2					      bpl	.invalid	; 2/3 same colour
     28 U00b2					      jsr	AddMove	; 57  and exit
     29 U00b2
     30 U00b2				   .invalid
     31 U00b2
     32 U00b2					      ENDM
     33 U00b2
     34 U00b2
     35 U00b2							;---------------------------------------------------------------------------------------------------
     36 U00b2
     37 U00b2					      MAC	move_to
     38 U00b2					      SUBROUTINE
     39 U00b2
     40 U00b2					      ldy	ValidSquare+{1},x
     41 U00b2					      bmi	.invalid	; off board!
     42 U00b2					      lda	Board,y	; piece @ destination
     43 U00b2					      sta	capture
     44 U00b2					      beq	.squareEmpty
     45 U00b2					      eor	currentPiece
     46 U00b2					      bpl	.invalid	; same colour
     47 U00b2				   .squareEmpty jsr	AddMove
     48 U00b2				   .invalid
     49 U00b2
     50 U00b2					      ENDM
     51 U00b2
     52 U00b2
     53 U00b2							;---------------------------------------------------------------------------------------------------
     54 U00b2
     55 U00b2					      MAC	move_to_x
     56 U00b2					      ldx	currentSquare
     57 U00b2					      MOVE_TO	{1}
     58 U00b2					      ENDM
     59 U00b2
     60 U00b2
     61 U00b2							;---------------------------------------------------------------------------------------------------
     62 U00b2							; EOF
------- FILE ./chess.asm
    188 U00b2
------- FILE @3 STARTBANK.asm LEVEL 2 PASS 4
      0 U00b2					      include	"@3 STARTBANK.asm"	; MUST be first ROM bank
      1 U00b2				   _ORIGIN    SET	_FIRST_BANK
      2 U00b2
      3 U00b2							; This is the first (START UP) bank for the 3E+ cartridge/scheme
      4 U00b2							; This bank is guaranteed to be mapped to SLOT 3 by the hardware implementation.
      5 U00b2							; It must contain the reset vector for the game!
      6 U00b2							; It does NOT need to be switched in for the remainder of the game!
      7 U00b2
      8 U00b2							;---------------------------------------------------------------------------------------------------
      9 U00b2
      0 U00b2					      SLOT	3
      1 U00b2
      2 U00b2				  -	      IF	(3 < 0) || (3 > 3)
      3 U00b2				  -	      ECHO	"Illegal bank address/segment location", 3
      4 U00b2				  -	      ERR
      5 U00b2					      ENDIF
      6 U00b2
      7 U00b2				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8 U00b2				   _BANK_SLOT SET	3 * 64
      9 U00b2
      0 U00b2					      ROMBANK	STARTBANK
      1  0400 ????				      SEG	ROM_STARTBANK
      2  0000					      ORG	_ORIGIN
      3  0000					      RORG	_BANK_ADDRESS_ORIGIN
      4  0000				   _BANK_START SET	*
      5  0000				   STARTBANK_START SET	*
      6  0000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0000				   ROMBANK_STARTBANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0000				   _LAST_BANK SETSTR	STARTBANK
     10  0000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0000
     13  0000
     14  0000							;---------------------------------------------------------------------------------------------------
     15  0000
      0  0000					      DEF	StartCartridge
      1  0000				   SLOT_StartCartridge SET	_BANK_SLOT
      2  0000				   BANK_StartCartridge SET	SLOT_StartCartridge + _CURRENT_BANK
      3  0000				   StartCartridge
      4  0000				   TEMPORARY_VAR SET	Overlay
      5  0000				   TEMPORARY_OFFSET SET	0
      6  0000				   VAR_BOUNDARY_StartCartridge SET	TEMPORARY_OFFSET
      7  0000				   FUNCTION_NAME SET	StartCartridge
     17  0000
      0  0000					      CLEAN_START
      1  0000		       78		      sei
      2  0001		       d8		      cld
      3  0002
      4  0002		       a2 00		      ldx	#0
      5  0004		       8a		      txa
      6  0005		       a8		      tay
      7  0006		       ca	   .CLEAR_STACK dex
      8  0007		       9a		      txs
      9  0008		       48		      pha
     10  0009		       d0 fb		      bne	.CLEAR_STACK
     11  000b
     19  000b
      0  000b					      JUMP	StartupBankReset	;@0
      1  000b				  -	      IF	SLOT_StartupBankReset == _BANK_SLOT
      2  000b				  -FNAME      SETSTR	StartupBankReset
      3  000b				  -	      ECHO	""
      4  000b				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  000b				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  000b				  -	      ERR
      7  000b					      ENDIF
      8  000b		       a9 01		      lda	#BANK_StartupBankReset
      9  000d		       85 3f		      sta	SET_BANK
     10  000f		       4c 00 f0 	      jmp	StartupBankReset
     21  0012
     22  0012							;---------------------------------------------------------------------------------------------------
     23  0012
     24  0012							; Lots of free space here
     25  0012
     26  0012							;---------------------------------------------------------------------------------------------------
     27  0012
 FREE BYTES IN STARTBANK =  $3ea
     28  0012					      ECHO	"FREE BYTES IN STARTBANK = ", $FFFC - *
     29  0012
     30  0012
     31  0012							;---------------------------------------------------------------------------------------------------
     32  0012
     33  0012							; The reset vectors
     34  0012							; these must live in the fixed bank (bank 0 in 3E+ format)
     35  0012
     36  03fc					      ORG	_FIRST_BANK + $3FC
     37  03fc					      RORG	$FFFC
      0  03fc					      DEF	InterruptVectors
      1  03fc				   SLOT_InterruptVectors SET	_BANK_SLOT
      2  03fc				   BANK_InterruptVectors SET	SLOT_InterruptVectors + _CURRENT_BANK
      3  03fc				   InterruptVectors
      4  03fc				   TEMPORARY_VAR SET	Overlay
      5  03fc				   TEMPORARY_OFFSET SET	0
      6  03fc				   VAR_BOUNDARY_InterruptVectors SET	TEMPORARY_OFFSET
      7  03fc				   FUNCTION_NAME SET	InterruptVectors
     39  03fc					      SUBROUTINE
     40  03fc
     41  03fc		       00 fc		      .word.w	StartCartridge	; RESET
     42  03fe		       00 fc		      .word.w	StartCartridge	; IRQ	      (not used)
     43  0400
     44  0400
     45  0400							;---------------------------------------------------------------------------------------------------
     46  0400
      0  0400					      END_BANK
      1  0400				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  0400				  -	      CHECK_RAM_BANK_SIZE
      3  0400					      ELSE
      0  0400					      CHECK_BANK_SIZE
      1  0400		       04 00	   .TEMP      =	* - _BANK_START
 ROM bank # 1 STARTBANK size = $400 free = -1
      2  0400					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  0400				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  0400				  -	      ERR
      6  0400					      ENDIF
      5  0400					      ENDIF
     48  0400
     49  0400							;---------------------------------------------------------------------------------------------------
     50  0400							;EOF
------- FILE ./chess.asm
    190  0400
------- FILE @0 HOME.asm LEVEL 2 PASS 4
      0  0400					      include	"@0 HOME.asm"
      1  0400							;---------------------------------------------------------------------------------------------------
      2  0400							; @0 HOME.asm
      3  0400
      4  0400							; Atari 2600 Chess
      5  0400							; Copyright (c) 2019-2020 Andrew Davie
      6  0400							; andrew@taswegian.com
      7  0400
      8  0400							;---------------------------------------------------------------------------------------------------
      9  0400
      0  0400					      SLOT	0
      1  0400
      2  0400				  -	      IF	(0 < 0) || (0 > 3)
      3  0400				  -	      ECHO	"Illegal bank address/segment location", 0
      4  0400				  -	      ERR
      5  0400					      ENDIF
      6  0400
      7  0400				   _BANK_ADDRESS_ORIGIN SET	$F000 + (0 * _ROM_BANK_SIZE)
      8  0400				   _BANK_SLOT SET	0 * 64
      9  0400
      0  0400					      ROMBANK	LOCKED_BANK
      1  07e0 ????				      SEG	ROM_LOCKED_BANK
      2  0400					      ORG	_ORIGIN
      3  0400					      RORG	_BANK_ADDRESS_ORIGIN
      4  0400				   _BANK_START SET	*
      5  0400				   LOCKED_BANK_START SET	*
      6  0400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0400				   ROMBANK_LOCKED_BANK SET	_BANK_SLOT + _CURRENT_BANK
      8  0400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0400				   _LAST_BANK SETSTR	LOCKED_BANK
     10  0400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0400
     13  0400
     14  0400							;---------------------------------------------------------------------------------------------------
     15  0400
      0  0400					      DEF	StartupBankReset
      1  0400				   SLOT_StartupBankReset SET	_BANK_SLOT
      2  0400				   BANK_StartupBankReset SET	SLOT_StartupBankReset + _CURRENT_BANK
      3  0400				   StartupBankReset
      4  0400				   TEMPORARY_VAR SET	Overlay
      5  0400				   TEMPORARY_OFFSET SET	0
      6  0400				   VAR_BOUNDARY_StartupBankReset SET	TEMPORARY_OFFSET
      7  0400				   FUNCTION_NAME SET	StartupBankReset
     17  0400					      SUBROUTINE
     18  0400
      0  0400					      VEND	StartupBankReset
      1  0400
      2  0400
      3  0400		       00 a6	   VAREND_StartupBankReset =	TEMPORARY_VAR
      4  0400
     20  0400
     21  0400
     22  0400							;CALL TitleScreen
     23  0400
      0  0400					      CALL	CartInit
      1  0400				  -	      IF	SLOT_CartInit == _BANK_SLOT
      2  0400				  -FNAME      SETSTR	CartInit
      3  0400				  -	      ECHO	""
      4  0400				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0400				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0400				  -	      ERR
      7  0400					      ENDIF
      8  0400		       a9 42		      lda	#BANK_CartInit
      9  0402		       85 3f		      sta	SET_BANK
     10  0404		       20 00 f4 	      jsr	CartInit
      0  0407					      CALL	SetupBanks
      1  0407				  -	      IF	SLOT_SetupBanks == _BANK_SLOT
      2  0407				  -FNAME      SETSTR	SetupBanks
      3  0407				  -	      ECHO	""
      4  0407				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0407				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0407				  -	      ERR
      7  0407					      ENDIF
      8  0407		       a9 42		      lda	#BANK_SetupBanks
      9  0409		       85 3f		      sta	SET_BANK
     10  040b		       20 3a f4 	      jsr	SetupBanks
      0  040e					      CALL	InitialisePieceSquares
      1  040e				  -	      IF	SLOT_InitialisePieceSquares == _BANK_SLOT
      2  040e				  -FNAME      SETSTR	InitialisePieceSquares
      3  040e				  -	      ECHO	""
      4  040e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  040e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  040e				  -	      ERR
      7  040e					      ENDIF
      8  040e		       a9 42		      lda	#BANK_InitialisePieceSquares
      9  0410		       85 3f		      sta	SET_BANK
     10  0412		       20 51 f5 	      jsr	InitialisePieceSquares
     27  0415		       20 50 f2 	      jsr	ListPlayerMoves	;@0
     28  0418
     29  0418
     30  0418				   .StartFrame
     31  0418
     32  0418
      0  0418					      CALL	InterlaceFrame
      1  0418				  -	      IF	SLOT_InterlaceFrame == _BANK_SLOT
      2  0418				  -FNAME      SETSTR	InterlaceFrame
      3  0418				  -	      ECHO	""
      4  0418				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0418				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0418				  -	      ERR
      7  0418					      ENDIF
      8  0418		       a9 d9		      lda	#BANK_InterlaceFrame
      9  041a		       85 3f		      sta	SET_BANK
     10  041c		       20 67 fc 	      jsr	InterlaceFrame
     34  041f
     35  041f
     36  041f		       a6 a5		      ldx	platform
     37  0421		       bd 7f f0 	      lda	time64a,x
     38  0424		       8d 96 02 	      sta	TIM64T
     39  0427
     40  0427							; LOTS OF PROCESSING TIME - USE IT
     41  0427
     42  0427				  -	      IFCONST	RAINBOW
     43  0427				  -	      CALL	RainBoard
     44  0427					      ENDIF
     45  0427
     46  0427		       20 92 f1 	      jsr	AiStateMachine
     47  042a
     48  042a
     49  042a				  -	      IF	ASSERTS
     50  042a				  -			; Catch timer expired already
     51  042a				  -			;		      bit TIMINT
     52  042a				  -			;.whoops	      bmi .whoops
     53  042a					      ENDIF
     54  042a
     55  042a
     56  042a		       2c 85 02    .wait      bit	TIMINT
     57  042d		       10 fb		      bpl	.wait
     58  042f
     59  042f
     60  042f							; START OF VISIBLE SCANLINES
     61  042f
     62  042f
      0  042f					      CALL	longD
      1  042f				  -	      IF	SLOT_longD == _BANK_SLOT
      2  042f				  -FNAME      SETSTR	longD
      3  042f				  -	      ECHO	""
      4  042f				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  042f				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  042f				  -	      ERR
      7  042f					      ENDIF
      8  042f		       a9 89		      lda	#BANK_longD
      9  0431		       85 3f		      sta	SET_BANK
     10  0433		       20 1d f8 	      jsr	longD
     64  0436
     65  0436
     66  0436		       a2 80		      ldx	#SLOT_DrawRow	; + BANK_DrawRow
     67  0438		       86 3e		      stx	SET_BANK_RAM
     68  043a		       20 a3 f8 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     69  043d
      0  043d					      CALL	tidySc
      1  043d				  -	      IF	SLOT_tidySc == _BANK_SLOT
      2  043d				  -FNAME      SETSTR	tidySc
      3  043d				  -	      ECHO	""
      4  043d				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  043d				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  043d				  -	      ERR
      7  043d					      ENDIF
      8  043d		       a9 89		      lda	#BANK_tidySc
      9  043f		       85 3f		      sta	SET_BANK
     10  0441		       20 04 f8 	      jsr	tidySc
     71  0444
     72  0444		       20 92 f1 	      jsr	AiStateMachine
     73  0447
     74  0447		       ad 84 02 	      lda	INTIM
     75  044a		       c9 14		      cmp	#20
     76  044c		       90 27		      bcc	.notnow
     77  044e
      0  044e					      CALL	SayIt	;GameSpeak
      1  044e				  -	      IF	SLOT_SayIt == _BANK_SLOT
      2  044e				  -FNAME      SETSTR	SayIt
      3  044e				  -	      ECHO	""
      4  044e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  044e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  044e				  -	      ERR
      7  044e					      ENDIF
      8  044e		       a9 98		      lda	#BANK_SayIt
      9  0450		       85 3f		      sta	SET_BANK
     10  0452		       20 91 f8 	      jsr	SayIt
      0  0455					      CALL	PositionSprites
      1  0455				  -	      IF	SLOT_PositionSprites == _BANK_SLOT
      2  0455				  -FNAME      SETSTR	PositionSprites
      3  0455				  -	      ECHO	""
      4  0455				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0455				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0455				  -	      ERR
      7  0455					      ENDIF
      8  0455		       a9 45		      lda	#BANK_PositionSprites
      9  0457		       85 3f		      sta	SET_BANK
     10  0459		       20 00 f5 	      jsr	PositionSprites
     80  045c
     81  045c
     82  045c					      IF	1
     83  045c							; "draw" sprite shapes into row banks
     84  045c
     85  045c		       a2 07		      ldx	#7
     86  045e		       8a	   zapem      txa
     87  045f		       18		      clc
     88  0460		       69 80		      adc	#SLOT_DrawRow
     89  0462		       85 3e		      sta	SET_BANK_RAM
      0  0464					      CALL	WriteBlank	;@3
      1  0464				  -	      IF	SLOT_WriteBlank == _BANK_SLOT
      2  0464				  -FNAME      SETSTR	WriteBlank
      3  0464				  -	      ECHO	""
      4  0464				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0464				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0464				  -	      ERR
      7  0464					      ENDIF
      8  0464		       a9 da		      lda	#BANK_WriteBlank
      9  0466		       85 3f		      sta	SET_BANK
     10  0468		       20 0c fc 	      jsr	WriteBlank
     91  046b		       ca		      dex
     92  046c		       10 f0		      bpl	zapem
     93  046e
      0  046e					      CALL	WriteCursor	;@3
      1  046e				  -	      IF	SLOT_WriteCursor == _BANK_SLOT
      2  046e				  -FNAME      SETSTR	WriteCursor
      3  046e				  -	      ECHO	""
      4  046e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  046e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  046e				  -	      ERR
      7  046e					      ENDIF
      8  046e		       a9 da		      lda	#BANK_WriteCursor
      9  0470		       85 3f		      sta	SET_BANK
     10  0472		       20 35 fc 	      jsr	WriteCursor
     95  0475					      ENDIF
     96  0475
     97  0475				   .notnow
     98  0475
     99  0475		       2c 85 02    .waitTime  bit	TIMINT
    100  0478		       10 fb		      bpl	.waitTime
    101  047a		       85 02		      sta	WSYNC
    102  047c
    103  047c
    104  047c		       4c 18 f0 	      jmp	.StartFrame
    105  047f
    106  047f				   time64a
    107  047f		       2d 4e		      .byte.b	TIME_PART_1, TIME_PART_1_PAL
    108  0481
    109  0481							;---------------------------------------------------------------------------------------------------
    110  0481
      0  0481					      DEF	COMMON_VARS
      1  0481				   SLOT_COMMON_VARS SET	_BANK_SLOT
      2  0481				   BANK_COMMON_VARS SET	SLOT_COMMON_VARS + _CURRENT_BANK
      3  0481				   COMMON_VARS
      4  0481				   TEMPORARY_VAR SET	Overlay
      5  0481				   TEMPORARY_OFFSET SET	0
      6  0481				   VAR_BOUNDARY_COMMON_VARS SET	TEMPORARY_OFFSET
      7  0481				   FUNCTION_NAME SET	COMMON_VARS
    112  0481
      0  0481					      VAR	__thinkbar, 1
      1  0481		       00 a6	   __thinkbar =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__thinkbar
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
      0  0481					      VAR	__toggle, 1
      1  0481		       00 a7	   __toggle   =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__toggle
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
    115  0481
      0  0481					      VAR	__bestMove, 1
      1  0481		       00 a8	   __bestMove =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__bestMove
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
      0  0481					      VAR	__alpha, 2
      1  0481		       00 a9	   __alpha    =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__alpha
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
      0  0481					      VAR	__beta, 2
      1  0481		       00 ab	   __beta     =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__beta
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
      0  0481					      VAR	__negaMax, 2
      1  0481		       00 ad	   __negaMax  =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__negaMax
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
      0  0481					      VAR	__value, 2
      1  0481		       00 af	   __value    =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__value
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
    121  0481
      0  0481					      VAR	__quiesceCapOnly, 1
      1  0481		       00 b1	   __quiesceCapOnly =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__quiesceCapOnly
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
    123  0481
      0  0481					      VAR	__originalPiece, 1
      1  0481		       00 b2	   __originalPiece =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__originalPiece
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
      0  0481					      VAR	__capturedPiece, 1
      1  0481		       00 b3	   __capturedPiece =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	__capturedPiece
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
    126  0481
    127  0481
      0  0481					      VAR	testzp, 2
      1  0481		       00 b4	   testzp     =	TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0481
      4  0481				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0481				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0481				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0481					      ENDIF
      8  0481				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0481				  -VNAME      SETSTR	testzp
     10  0481				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0481				  -	      ERR
     12  0481					      ENDIF
      0  0481					      VEND	COMMON_VARS
      1  0481
      2  0481
      3  0481		       00 b6	   VAREND_COMMON_VARS =	TEMPORARY_VAR
      4  0481
    130  0481
    131  0481
    132  0481							;---------------------------------------------------------------------------------------------------
    133  0481
      0  0481					      DEF	ThinkBar
      1  0481				   SLOT_ThinkBar SET	_BANK_SLOT
      2  0481				   BANK_ThinkBar SET	SLOT_ThinkBar + _CURRENT_BANK
      3  0481				   ThinkBar
      4  0481				   TEMPORARY_VAR SET	Overlay
      5  0481				   TEMPORARY_OFFSET SET	0
      6  0481				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      7  0481				   FUNCTION_NAME SET	ThinkBar
    135  0481					      SUBROUTINE
    136  0481
      0  0481					      REF	COMMON_VARS
      1  0481					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0481					      ENDIF
      0  0481					      REF	negaMax	;✅
      1  0481					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0481				   TEMPORARY_VAR SET	VAREND_negaMax
      3  0481					      ENDIF
      0  0481					      REF	quiesce	;✅
      1  0481				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0481				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  0481					      ENDIF
    140  0481
      0  0481					      VEND	ThinkBar
      1  0481
      2  0481
      3  0481		       00 b8	   VAREND_ThinkBar =	TEMPORARY_VAR
      4  0481
    142  0481
    143  0481
    144  0481							; Check timer!
    145  0481
    146  0481				  -	      IF	0
    147  0481				  -	      lda	INTIM
    148  0481				  -	      bpl	.notick
    149  0481				  -	      lda	#127
    150  0481				  -	      sta	T1024T
    151  0481				  -	      inc	testzp
    152  0481				  -			;bne .notick
    153  0481				  -	      inc	testzp+1
    154  0481				  -
    155  0481				  -	      lda	testzp+1
    156  0481				  -	      asl
    157  0481				  -	      sta	COLUBK
    158  0481				  -
    159  0481				  -
    160  0481				  -
    161  0481				  -.notick
    162  0481					      ENDIF
    163  0481
    164  0481
    165  0481				  -	      IF	DIAGNOSTICS
    166  0481				  -
    167  0481				  -	      inc	positionCount
    168  0481				  -	      bne	.p1
    169  0481				  -	      inc	positionCount+1
    170  0481				  -	      bne	.p1
    171  0481				  -	      inc	positionCount+2
    172  0481				  -.p1
    173  0481					      ENDIF
    174  0481
    175  0481							; The 'thinkbar' pattern...
    176  0481
    177  0481		       a9 00		      lda	#0
    178  0483		       a4 0c		      ldy	INPT4
    179  0485		       30 13		      bmi	.doThink
    180  0487
    181  0487		       e6 a6		      inc	__thinkbar
    182  0489		       a5 a6		      lda	__thinkbar
    183  048b		       29 0f		      and	#15
    184  048d		       a8		      tay
    185  048e		       a5 82		      lda	rnd
    186  0490		       29 06		      and	#6
    187  0492		       19 a1 f0 	      ora	TBcol,y
    188  0495		       85 08		      sta	COLUPF
    189  0497
    190  0497		       b9 b1 f0 	      lda	SynapsePattern,y
    191  049a		       85 0f	   .doThink   sta	PF2
    192  049c		       85 0e		      sta	PF1
    193  049e		       85 0d		      sta	PF0
    194  04a0		       60		      rts
    195  04a1
    196  04a1
    197  04a1				   TBcol
    198  04a1				   .TBC       SET	2
    199  04a1					      REPEAT	16
    200  04a1		       02		      .byte.b	.TBC
    201  04a1				   .TBC       SET	.TBC + 16
    199  04a1					      REPEND
    200  04a2		       12		      .byte.b	.TBC
    201  04a2				   .TBC       SET	.TBC + 16
    199  04a2					      REPEND
    200  04a3		       22		      .byte.b	.TBC
    201  04a3				   .TBC       SET	.TBC + 16
    199  04a3					      REPEND
    200  04a4		       32		      .byte.b	.TBC
    201  04a4				   .TBC       SET	.TBC + 16
    199  04a4					      REPEND
    200  04a5		       42		      .byte.b	.TBC
    201  04a5				   .TBC       SET	.TBC + 16
    199  04a5					      REPEND
    200  04a6		       52		      .byte.b	.TBC
    201  04a6				   .TBC       SET	.TBC + 16
    199  04a6					      REPEND
    200  04a7		       62		      .byte.b	.TBC
    201  04a7				   .TBC       SET	.TBC + 16
    199  04a7					      REPEND
    200  04a8		       72		      .byte.b	.TBC
    201  04a8				   .TBC       SET	.TBC + 16
    199  04a8					      REPEND
    200  04a9		       82		      .byte.b	.TBC
    201  04a9				   .TBC       SET	.TBC + 16
    199  04a9					      REPEND
    200  04aa		       92		      .byte.b	.TBC
    201  04aa				   .TBC       SET	.TBC + 16
    199  04aa					      REPEND
    200  04ab		       a2		      .byte.b	.TBC
    201  04ab				   .TBC       SET	.TBC + 16
    199  04ab					      REPEND
    200  04ac		       b2		      .byte.b	.TBC
    201  04ac				   .TBC       SET	.TBC + 16
    199  04ac					      REPEND
    200  04ad		       c2		      .byte.b	.TBC
    201  04ad				   .TBC       SET	.TBC + 16
    199  04ad					      REPEND
    200  04ae		       d2		      .byte.b	.TBC
    201  04ae				   .TBC       SET	.TBC + 16
    199  04ae					      REPEND
    200  04af		       e2		      .byte.b	.TBC
    201  04af				   .TBC       SET	.TBC + 16
    199  04af					      REPEND
    200  04b0		       f2		      .byte.b	.TBC
    201  04b0				   .TBC       SET	.TBC + 16
    202  04b1					      REPEND
    203  04b1
    204  04b1				   SynapsePattern
    205  04b1
    206  04b1		       c1		      .byte.b	%11000001
    207  04b2		       60		      .byte.b	%01100000
    208  04b3		       30		      .byte.b	%00110000
    209  04b4		       18		      .byte.b	%00011000
    210  04b5		       0c		      .byte.b	%00001100
    211  04b6		       06		      .byte.b	%00000110
    212  04b7		       83		      .byte.b	%10000011
    213  04b8		       c1		      .byte.b	%11000001
    214  04b9
    215  04b9		       83		      .byte.b	%10000011
    216  04ba		       06		      .byte.b	%00000110
    217  04bb		       0c		      .byte.b	%00001100
    218  04bc		       18		      .byte.b	%00011000
    219  04bd		       30		      .byte.b	%00110000
    220  04be		       60		      .byte.b	%01100000
    221  04bf		       c1		      .byte.b	%11000001
    222  04c0		       83		      .byte.b	%10000011
    223  04c1
    224  04c1
    225  04c1							;---------------------------------------------------------------------------------------------------
    226  04c1
      0  04c1					      DEF	CopySinglePiece
      1  04c1				   SLOT_CopySinglePiece SET	_BANK_SLOT
      2  04c1				   BANK_CopySinglePiece SET	SLOT_CopySinglePiece + _CURRENT_BANK
      3  04c1				   CopySinglePiece
      4  04c1				   TEMPORARY_VAR SET	Overlay
      5  04c1				   TEMPORARY_OFFSET SET	0
      6  04c1				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      7  04c1				   FUNCTION_NAME SET	CopySinglePiece
    228  04c1					      SUBROUTINE
    229  04c1
    230  04c1							; Common vairables...
    231  04c1							; REQUIRES calling routines to "REF Variable_PieceShapeBuffer"
    232  04c1
      0  04c1					      TIMING	CopySinglePiece, (2600)
      1  04c1
      2  04c1		       00 29	   SPEEDOF_CopySinglePiece =	((2600)/64) + 1
      3  04c1
    234  04c1
      0  04c1					      REF	Variable_PieceShapeBuffer
      1  04c1					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  04c1				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  04c1					      ENDIF
      0  04c1					      REF	showMoveCaptures	;✅
      1  04c1				  -	      IF	VAREND_showMoveCaptures > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_showMoveCaptures
      3  04c1					      ENDIF
      0  04c1					      REF	aiDrawEntireBoard	;✅
      1  04c1				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  04c1					      ENDIF
      0  04c1					      REF	aiDrawPart2	;✅
      1  04c1				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  04c1					      ENDIF
      0  04c1					      REF	aiMarchB	;✅
      1  04c1				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  04c1					      ENDIF
      0  04c1					      REF	aiFlashComputerMove	;✅
      1  04c1				  -	      IF	VAREND_aiFlashComputerMove > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiFlashComputerMove
      3  04c1					      ENDIF
      0  04c1					      REF	aiSelectDestinationSquare	;✅
      1  04c1				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  04c1					      ENDIF
      0  04c1					      REF	aiMarchA2	;✅
      1  04c1				  -	      IF	VAREND_aiMarchA2 > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchA2
      3  04c1					      ENDIF
      0  04c1					      REF	aiMarchB2	;✅
      1  04c1				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  04c1					      ENDIF
      0  04c1					      REF	aiWriteStartPieceBlank	;✅
      1  04c1				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  04c1					      ENDIF
      0  04c1					      REF	aiChoosePromotePiece	;✅
      1  04c1				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  04c1					      ENDIF
      0  04c1					      REF	aiMarchToTargetB	;✅
      1  04c1				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  04c1					      ENDIF
      0  04c1					      REF	aiPromotePawnStart	;✅
      1  04c1				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  04c1					      ENDIF
      0  04c1					      REF	aiFinalFlash	;✅
      1  04c1				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  04c1				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  04c1					      ENDIF
    249  04c1
    250  04c1
      0  04c1					      VEND	CopySinglePiece
      1  04c1
      2  04c1
      3  04c1		       00 ee	   VAREND_CopySinglePiece =	TEMPORARY_VAR
      4  04c1
    252  04c1
    253  04c1							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    254  04c1							; ALSO CAN'T USE IN THIS ROUTINE
    255  04c1							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    256  04c1							; @2150 max
    257  04c1							; = 33 TIM64T
    258  04c1
      0  04c1					      CALL	CopySetup	;@2
      1  04c1				  -	      IF	SLOT_CopySetup == _BANK_SLOT
      2  04c1				  -FNAME      SETSTR	CopySetup
      3  04c1				  -	      ECHO	""
      4  04c1				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  04c1				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  04c1				  -	      ERR
      7  04c1					      ENDIF
      8  04c1		       a9 89		      lda	#BANK_CopySetup
      9  04c3		       85 3f		      sta	SET_BANK
     10  04c5		       20 9f f8 	      jsr	CopySetup
    260  04c8
    261  04c8
      0  04c8					      DEF	InterceptMarkerCopy
      1  04c8				   SLOT_InterceptMarkerCopy SET	_BANK_SLOT
      2  04c8				   BANK_InterceptMarkerCopy SET	SLOT_InterceptMarkerCopy + _CURRENT_BANK
      3  04c8				   InterceptMarkerCopy
      4  04c8				   TEMPORARY_VAR SET	Overlay
      5  04c8				   TEMPORARY_OFFSET SET	0
      6  04c8				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      7  04c8				   FUNCTION_NAME SET	InterceptMarkerCopy
    263  04c8					      SUBROUTINE
    264  04c8
      0  04c8					      REF	CopySinglePiece	;✅
      1  04c8					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  04c8				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  04c8					      ENDIF
      0  04c8					      REF	showPromoteOptions	;✅
      1  04c8				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  04c8					      ENDIF
      0  04c8					      REF	showMoveOptions	;✅
      1  04c8				  -	      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  04c8				  -TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  04c8					      ENDIF
    268  04c8
      0  04c8					      VAR	__psb, 2
      1  04c8		       00 ee	   __psb      =	TEMPORARY_VAR
      2  04c8				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  04c8
      4  04c8				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  04c8					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  04c8				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  04c8					      ENDIF
      8  04c8				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  04c8				  -VNAME      SETSTR	__psb
     10  04c8				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  04c8				  -	      ERR
     12  04c8					      ENDIF
    270  04c8
      0  04c8					      VEND	InterceptMarkerCopy
      1  04c8
      2  04c8
      3  04c8		       00 f0	   VAREND_InterceptMarkerCopy =	TEMPORARY_VAR
      4  04c8
    272  04c8
    273  04c8							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    274  04c8							; y = piece index
    275  04c8
    276  04c8		       a9 89		      lda	#BANK_PIECE_VECTOR_BANK
    277  04ca		       85 3f		      sta	SET_BANK	;@2
    278  04cc
    279  04cc		       b9 e9 f9 	      lda	PIECE_VECTOR_LO,y
    280  04cf		       85 ee		      sta	__psb
    281  04d1		       b9 79 fa 	      lda	PIECE_VECTOR_HI,y
    282  04d4		       85 ef		      sta	__psb+1
    283  04d6		       b9 09 fb 	      lda	PIECE_VECTOR_BANK,y
    284  04d9		       85 3f		      sta	SET_BANK	;@2
    285  04db
    286  04db		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    287  04dd		       b1 ee	   .copy      lda	(__psb),y
    288  04df		       99 a6 00 	      sta	__pieceShapeBuffer,y
    289  04e2		       88		      dey
    290  04e3		       10 f8		      bpl	.copy
    291  04e5
    292  04e5		       a5 81		      lda	squareToDraw
    293  04e7		       38		      sec
    294  04e8		       a2 0a		      ldx	#10
    295  04ea		       e9 0a	   .sub10     sbc	#10
    296  04ec		       ca		      dex
    297  04ed		       b0 fb		      bcs	.sub10
    298  04ef
    299  04ef		       69 08		      adc	#8
    300  04f1		       c9 04		      cmp	#4	; CS = right side of screen
    301  04f3
    302  04f3		       8a		      txa
    303  04f4		       09 80		      ora	#[SLOT2]
    304  04f6		       85 3e		      sta	SET_BANK_RAM	;@2		 ; bank row
    305  04f8
    306  04f8		       20 50 f3 	      jsr	CopyPieceToRowBitmap	;@3
    307  04fb		       60		      rts
    308  04fc
    309  04fc
    310  04fc							;---------------------------------------------------------------------------------------------------
    311  04fc
    312  04fc				   P	      SET	0
    313  04fc					      MAC	ain
    314  04fc				   AI_{1}     SET	P
    315  04fc				   P	      SET	P+1
    316  04fc					      ENDM
    317  04fc
    318  04fc					      MAC	lo
    319  04fc					      .byte	<ai{1}
    320  04fc					      ENDM
    321  04fc
    322  04fc					      MAC	hi
    323  04fc					      .byte	>ai{1}
    324  04fc					      ENDM
    325  04fc
    326  04fc					      MAC	bk
    327  04fc					      .byte	BANK_ai{1}
    328  04fc					      ENDM
    329  04fc
    330  04fc
    331  04fc		       00 28	   ONCEPERFRAME =	40
    332  04fc
    333  04fc					      MAC	tabdef
    334  04fc
    335  04fc					      {1}	FlashComputerMove	; 0
    336  04fc					      {1}	BeginSelectMovePhase	; 1
    337  04fc					      {1}	SelectStartSquare	; 2
    338  04fc					      {1}	StartSquareSelected	; 3
    339  04fc					      {1}	DrawMoves	; 4
    340  04fc					      {1}	ShowMoveCaptures	; 5
    341  04fc					      {1}	SlowFlash	; 6
    342  04fc					      {1}	UnDrawTargetSquares	; 7
    343  04fc					      {1}	SelectDestinationSquare	; 8
    344  04fc					      {1}	Quiescent	; 9
    345  04fc					      {1}	ReselectDebounce	; 10
    346  04fc					      {1}	StartMoveGen	; 11
    347  04fc					      {1}	StepMoveGen	; 12
    348  04fc					      {1}	StartClearBoard	; 13
    349  04fc					      {1}	ClearEachRow	; 14
    350  04fc					      {1}	DrawEntireBoard	; 15
    351  04fc					      {1}	DrawPart2	; 16
    352  04fc					      {1}	DrawPart3	; 17
    353  04fc					      {1}	GenerateMoves	; 18
    354  04fc					      {1}	ComputerMove	; 19
    355  04fc					      {1}	MoveIsSelected	; 20
    356  04fc					      {1}	WriteStartPieceBlank	; 21
    357  04fc					      {1}	MarchToTargetA	; 22
    358  04fc					      {1}	MarchA2	; 23
    359  04fc					      {1}	MarchB	; 24
    360  04fc					      {1}	MarchToTargetB	; 25
    361  04fc					      {1}	MarchB2	; 26
    362  04fc					      {1}	FinalFlash	; 27
    363  04fc					      {1}	SpecialMoveFixup	; 28
    364  04fc					      {1}	InCheckBackup	; 29
    365  04fc					      {1}	InCheckDelay	; 30
    366  04fc					      {1}	PromotePawnStart	; 31
    367  04fc					      {1}	RollPromotionPiece	; 32
    368  04fc					      {1}	ChoosePromotePiece	; 33
    369  04fc					      {1}	ChooseDebounce	; 34
    370  04fc					      {1}	CheckMate	; 35
    371  04fc					      {1}	Draw	; 36
    372  04fc					      {1}	DelayAfterMove	; 37
    373  04fc					      {1}	DelayAfterMove2	; 38
    374  04fc					      {1}	DelayAfterPlaced	; 39
    375  04fc					      {1}	DelayAfterPlaced2	; 40
    376  04fc					      {1}	EPHandler	; 41
    377  04fc					      {1}	EPFlash	; 42
    378  04fc					      {1}	DebounceSelect	; 43
    379  04fc					      {1}	InCheckBackupStart	; 44
    380  04fc					      {1}	RestoreBitmaps	; 45
    381  04fc					      {1}	WaitBitmap	; 46
    382  04fc					      {1}	MaskBitmapBackground	; 47
    383  04fc					      {1}	DrawBitmap2	; 48
    384  04fc					      {1}	DrawBitmap3	; 49
    385  04fc
    386  04fc					      ENDM		; {1} = macro to use
    387  04fc
      0  04fc					      TABDEF	AIN
      1  04fc
      0  04fc					      AIN	FlashComputerMove
      1  04fc				   AI_FlashComputerMove SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	BeginSelectMovePhase
      1  04fc				   AI_BeginSelectMovePhase SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SelectStartSquare
      1  04fc				   AI_SelectStartSquare SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StartSquareSelected
      1  04fc				   AI_StartSquareSelected SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawMoves
      1  04fc				   AI_DrawMoves SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ShowMoveCaptures
      1  04fc				   AI_ShowMoveCaptures SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SlowFlash
      1  04fc				   AI_SlowFlash SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	UnDrawTargetSquares
      1  04fc				   AI_UnDrawTargetSquares SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SelectDestinationSquare
      1  04fc				   AI_SelectDestinationSquare SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	Quiescent
      1  04fc				   AI_Quiescent SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ReselectDebounce
      1  04fc				   AI_ReselectDebounce SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StartMoveGen
      1  04fc				   AI_StartMoveGen SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StepMoveGen
      1  04fc				   AI_StepMoveGen SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	StartClearBoard
      1  04fc				   AI_StartClearBoard SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ClearEachRow
      1  04fc				   AI_ClearEachRow SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawEntireBoard
      1  04fc				   AI_DrawEntireBoard SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawPart2
      1  04fc				   AI_DrawPart2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawPart3
      1  04fc				   AI_DrawPart3 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	GenerateMoves
      1  04fc				   AI_GenerateMoves SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ComputerMove
      1  04fc				   AI_ComputerMove SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MoveIsSelected
      1  04fc				   AI_MoveIsSelected SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	WriteStartPieceBlank
      1  04fc				   AI_WriteStartPieceBlank SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchToTargetA
      1  04fc				   AI_MarchToTargetA SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchA2
      1  04fc				   AI_MarchA2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchB
      1  04fc				   AI_MarchB  SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchToTargetB
      1  04fc				   AI_MarchToTargetB SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MarchB2
      1  04fc				   AI_MarchB2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	FinalFlash
      1  04fc				   AI_FinalFlash SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	SpecialMoveFixup
      1  04fc				   AI_SpecialMoveFixup SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	InCheckBackup
      1  04fc				   AI_InCheckBackup SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	InCheckDelay
      1  04fc				   AI_InCheckDelay SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	PromotePawnStart
      1  04fc				   AI_PromotePawnStart SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	RollPromotionPiece
      1  04fc				   AI_RollPromotionPiece SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ChoosePromotePiece
      1  04fc				   AI_ChoosePromotePiece SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	ChooseDebounce
      1  04fc				   AI_ChooseDebounce SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	CheckMate
      1  04fc				   AI_CheckMate SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	Draw
      1  04fc				   AI_Draw    SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterMove
      1  04fc				   AI_DelayAfterMove SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterMove2
      1  04fc				   AI_DelayAfterMove2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterPlaced
      1  04fc				   AI_DelayAfterPlaced SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DelayAfterPlaced2
      1  04fc				   AI_DelayAfterPlaced2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	EPHandler
      1  04fc				   AI_EPHandler SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	EPFlash
      1  04fc				   AI_EPFlash SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DebounceSelect
      1  04fc				   AI_DebounceSelect SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	InCheckBackupStart
      1  04fc				   AI_InCheckBackupStart SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	RestoreBitmaps
      1  04fc				   AI_RestoreBitmaps SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	WaitBitmap
      1  04fc				   AI_WaitBitmap SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	MaskBitmapBackground
      1  04fc				   AI_MaskBitmapBackground SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawBitmap2
      1  04fc				   AI_DrawBitmap2 SET	P
      2  04fc				   P	      SET	P+1
      0  04fc					      AIN	DrawBitmap3
      1  04fc				   AI_DrawBitmap3 SET	P
      2  04fc				   P	      SET	P+1
     52  04fc
    389  04fc
      0  04fc					      DEF	AiVectorLO
      1  04fc				   SLOT_AiVectorLO SET	_BANK_SLOT
      2  04fc				   BANK_AiVectorLO SET	SLOT_AiVectorLO + _CURRENT_BANK
      3  04fc				   AiVectorLO
      4  04fc				   TEMPORARY_VAR SET	Overlay
      5  04fc				   TEMPORARY_OFFSET SET	0
      6  04fc				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      7  04fc				   FUNCTION_NAME SET	AiVectorLO
      0  04fc					      TABDEF	LO
      1  04fc
      0  04fc					      LO	FlashComputerMove
      1  04fc		       7b		      .byte.b	<aiFlashComputerMove
      0  04fd					      LO	BeginSelectMovePhase
      1  04fd		       57		      .byte.b	<aiBeginSelectMovePhase
      0  04fe					      LO	SelectStartSquare
      1  04fe		       b4		      .byte.b	<aiSelectStartSquare
      0  04ff					      LO	StartSquareSelected
      1  04ff		       b4		      .byte.b	<aiStartSquareSelected
      0  0500					      LO	DrawMoves
      1  0500		       1c		      .byte.b	<aiDrawMoves
      0  0501					      LO	ShowMoveCaptures
      1  0501		       10		      .byte.b	<aiShowMoveCaptures
      0  0502					      LO	SlowFlash
      1  0502		       36		      .byte.b	<aiSlowFlash
      0  0503					      LO	UnDrawTargetSquares
      1  0503		       e6		      .byte.b	<aiUnDrawTargetSquares
      0  0504					      LO	SelectDestinationSquare
      1  0504		       5f		      .byte.b	<aiSelectDestinationSquare
      0  0505					      LO	Quiescent
      1  0505		       cc		      .byte.b	<aiQuiescent
      0  0506					      LO	ReselectDebounce
      1  0506		       14		      .byte.b	<aiReselectDebounce
      0  0507					      LO	StartMoveGen
      1  0507		       00		      .byte.b	<aiStartMoveGen
      0  0508					      LO	StepMoveGen
      1  0508		       ad		      .byte.b	<aiStepMoveGen
      0  0509					      LO	StartClearBoard
      1  0509		       31		      .byte.b	<aiStartClearBoard
      0  050a					      LO	ClearEachRow
      1  050a		       3e		      .byte.b	<aiClearEachRow
      0  050b					      LO	DrawEntireBoard
      1  050b		       57		      .byte.b	<aiDrawEntireBoard
      0  050c					      LO	DrawPart2
      1  050c		       8b		      .byte.b	<aiDrawPart2
      0  050d					      LO	DrawPart3
      1  050d		       8e		      .byte.b	<aiDrawPart3
      0  050e					      LO	GenerateMoves
      1  050e		       9a		      .byte.b	<aiGenerateMoves
      0  050f					      LO	ComputerMove
      1  050f		       00		      .byte.b	<aiComputerMove
      0  0510					      LO	MoveIsSelected
      1  0510		       59		      .byte.b	<aiMoveIsSelected
      0  0511					      LO	WriteStartPieceBlank
      1  0511		       cf		      .byte.b	<aiWriteStartPieceBlank
      0  0512					      LO	MarchToTargetA
      1  0512		       38		      .byte.b	<aiMarchToTargetA
      0  0513					      LO	MarchA2
      1  0513		       90		      .byte.b	<aiMarchA2
      0  0514					      LO	MarchB
      1  0514		       a8		      .byte.b	<aiMarchB
      0  0515					      LO	MarchToTargetB
      1  0515		       54		      .byte.b	<aiMarchToTargetB
      0  0516					      LO	MarchB2
      1  0516		       bd		      .byte.b	<aiMarchB2
      0  0517					      LO	FinalFlash
      1  0517		       92		      .byte.b	<aiFinalFlash
      0  0518					      LO	SpecialMoveFixup
      1  0518		       f2		      .byte.b	<aiSpecialMoveFixup
      0  0519					      LO	InCheckBackup
      1  0519		       0e		      .byte.b	<aiInCheckBackup
      0  051a					      LO	InCheckDelay
      1  051a		       4a		      .byte.b	<aiInCheckDelay
      0  051b					      LO	PromotePawnStart
      1  051b		       76		      .byte.b	<aiPromotePawnStart
      0  051c					      LO	RollPromotionPiece
      1  051c		       c0		      .byte.b	<aiRollPromotionPiece
      0  051d					      LO	ChoosePromotePiece
      1  051d		       13		      .byte.b	<aiChoosePromotePiece
      0  051e					      LO	ChooseDebounce
      1  051e		       00		      .byte.b	<aiChooseDebounce
      0  051f					      LO	CheckMate
      1  051f		       c2		      .byte.b	<aiCheckMate
      0  0520					      LO	Draw
      1  0520		       b8		      .byte.b	<aiDraw
      0  0521					      LO	DelayAfterMove
      1  0521		       1d		      .byte.b	<aiDelayAfterMove
      0  0522					      LO	DelayAfterMove2
      1  0522		       26		      .byte.b	<aiDelayAfterMove2
      0  0523					      LO	DelayAfterPlaced
      1  0523		       2f		      .byte.b	<aiDelayAfterPlaced
      0  0524					      LO	DelayAfterPlaced2
      1  0524		       3f		      .byte.b	<aiDelayAfterPlaced2
      0  0525					      LO	EPHandler
      1  0525		       f9		      .byte.b	<aiEPHandler
      0  0526					      LO	EPFlash
      1  0526		       0a		      .byte.b	<aiEPFlash
      0  0527					      LO	DebounceSelect
      1  0527		       fd		      .byte.b	<aiDebounceSelect
      0  0528					      LO	InCheckBackupStart
      1  0528		       05		      .byte.b	<aiInCheckBackupStart
      0  0529					      LO	RestoreBitmaps
      1  0529		       33		      .byte.b	<aiRestoreBitmaps
      0  052a					      LO	WaitBitmap
      1  052a		       22		      .byte.b	<aiWaitBitmap
      0  052b					      LO	MaskBitmapBackground
      1  052b		       85		      .byte.b	<aiMaskBitmapBackground
      0  052c					      LO	DrawBitmap2
      1  052c		       cb		      .byte.b	<aiDrawBitmap2
      0  052d					      LO	DrawBitmap3
      1  052d		       f2		      .byte.b	<aiDrawBitmap3
     52  052e
    392  052e
      0  052e					      DEF	AiVectorHI
      1  052e				   SLOT_AiVectorHI SET	_BANK_SLOT
      2  052e				   BANK_AiVectorHI SET	SLOT_AiVectorHI + _CURRENT_BANK
      3  052e				   AiVectorHI
      4  052e				   TEMPORARY_VAR SET	Overlay
      5  052e				   TEMPORARY_OFFSET SET	0
      6  052e				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      7  052e				   FUNCTION_NAME SET	AiVectorHI
      0  052e					      TABDEF	HI
      1  052e
      0  052e					      HI	FlashComputerMove
      1  052e		       f4		      .byte.b	>aiFlashComputerMove
      0  052f					      HI	BeginSelectMovePhase
      1  052f		       f4		      .byte.b	>aiBeginSelectMovePhase
      0  0530					      HI	SelectStartSquare
      1  0530		       f4		      .byte.b	>aiSelectStartSquare
      0  0531					      HI	StartSquareSelected
      1  0531		       f5		      .byte.b	>aiStartSquareSelected
      0  0532					      HI	DrawMoves
      1  0532		       f5		      .byte.b	>aiDrawMoves
      0  0533					      HI	ShowMoveCaptures
      1  0533		       f6		      .byte.b	>aiShowMoveCaptures
      0  0534					      HI	SlowFlash
      1  0534		       f6		      .byte.b	>aiSlowFlash
      0  0535					      HI	UnDrawTargetSquares
      1  0535		       f5		      .byte.b	>aiUnDrawTargetSquares
      0  0536					      HI	SelectDestinationSquare
      1  0536		       f6		      .byte.b	>aiSelectDestinationSquare
      0  0537					      HI	Quiescent
      1  0537		       f6		      .byte.b	>aiQuiescent
      0  0538					      HI	ReselectDebounce
      1  0538		       f4		      .byte.b	>aiReselectDebounce
      0  0539					      HI	StartMoveGen
      1  0539		       f4		      .byte.b	>aiStartMoveGen
      0  053a					      HI	StepMoveGen
      1  053a		       f4		      .byte.b	>aiStepMoveGen
      0  053b					      HI	StartClearBoard
      1  053b		       f8		      .byte.b	>aiStartClearBoard
      0  053c					      HI	ClearEachRow
      1  053c		       f8		      .byte.b	>aiClearEachRow
      0  053d					      HI	DrawEntireBoard
      1  053d		       f6		      .byte.b	>aiDrawEntireBoard
      0  053e					      HI	DrawPart2
      1  053e		       f6		      .byte.b	>aiDrawPart2
      0  053f					      HI	DrawPart3
      1  053f		       f6		      .byte.b	>aiDrawPart3
      0  0540					      HI	GenerateMoves
      1  0540		       f4		      .byte.b	>aiGenerateMoves
      0  0541					      HI	ComputerMove
      1  0541		       f4		      .byte.b	>aiComputerMove
      0  0542					      HI	MoveIsSelected
      1  0542		       f8		      .byte.b	>aiMoveIsSelected
      0  0543					      HI	WriteStartPieceBlank
      1  0543		       f5		      .byte.b	>aiWriteStartPieceBlank
      0  0544					      HI	MarchToTargetA
      1  0544		       f5		      .byte.b	>aiMarchToTargetA
      0  0545					      HI	MarchA2
      1  0545		       f7		      .byte.b	>aiMarchA2
      0  0546					      HI	MarchB
      1  0546		       f6		      .byte.b	>aiMarchB
      0  0547					      HI	MarchToTargetB
      1  0547		       f4		      .byte.b	>aiMarchToTargetB
      0  0548					      HI	MarchB2
      1  0548		       f7		      .byte.b	>aiMarchB2
      0  0549					      HI	FinalFlash
      1  0549		       f5		      .byte.b	>aiFinalFlash
      0  054a					      HI	SpecialMoveFixup
      1  054a		       f5		      .byte.b	>aiSpecialMoveFixup
      0  054b					      HI	InCheckBackup
      1  054b		       f4		      .byte.b	>aiInCheckBackup
      0  054c					      HI	InCheckDelay
      1  054c		       f4		      .byte.b	>aiInCheckDelay
      0  054d					      HI	PromotePawnStart
      1  054d		       f4		      .byte.b	>aiPromotePawnStart
      0  054e					      HI	RollPromotionPiece
      1  054e		       f6		      .byte.b	>aiRollPromotionPiece
      0  054f					      HI	ChoosePromotePiece
      1  054f		       f7		      .byte.b	>aiChoosePromotePiece
      0  0550					      HI	ChooseDebounce
      1  0550		       f4		      .byte.b	>aiChooseDebounce
      0  0551					      HI	CheckMate
      1  0551		       f6		      .byte.b	>aiCheckMate
      0  0552					      HI	Draw
      1  0552		       f6		      .byte.b	>aiDraw
      0  0553					      HI	DelayAfterMove
      1  0553		       f4		      .byte.b	>aiDelayAfterMove
      0  0554					      HI	DelayAfterMove2
      1  0554		       f4		      .byte.b	>aiDelayAfterMove2
      0  0555					      HI	DelayAfterPlaced
      1  0555		       f4		      .byte.b	>aiDelayAfterPlaced
      0  0556					      HI	DelayAfterPlaced2
      1  0556		       f4		      .byte.b	>aiDelayAfterPlaced2
      0  0557					      HI	EPHandler
      1  0557		       f5		      .byte.b	>aiEPHandler
      0  0558					      HI	EPFlash
      1  0558		       f6		      .byte.b	>aiEPFlash
      0  0559					      HI	DebounceSelect
      1  0559		       f4		      .byte.b	>aiDebounceSelect
      0  055a					      HI	InCheckBackupStart
      1  055a		       f4		      .byte.b	>aiInCheckBackupStart
      0  055b					      HI	RestoreBitmaps
      1  055b		       f4		      .byte.b	>aiRestoreBitmaps
      0  055c					      HI	WaitBitmap
      1  055c		       f4		      .byte.b	>aiWaitBitmap
      0  055d					      HI	MaskBitmapBackground
      1  055d		       fc		      .byte.b	>aiMaskBitmapBackground
      0  055e					      HI	DrawBitmap2
      1  055e		       fc		      .byte.b	>aiDrawBitmap2
      0  055f					      HI	DrawBitmap3
      1  055f		       fc		      .byte.b	>aiDrawBitmap3
     52  0560
    395  0560
      0  0560					      DEF	AiVectorBANK
      1  0560				   SLOT_AiVectorBANK SET	_BANK_SLOT
      2  0560				   BANK_AiVectorBANK SET	SLOT_AiVectorBANK + _CURRENT_BANK
      3  0560				   AiVectorBANK
      4  0560				   TEMPORARY_VAR SET	Overlay
      5  0560				   TEMPORARY_OFFSET SET	0
      6  0560				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      7  0560				   FUNCTION_NAME SET	AiVectorBANK
      0  0560					      TABDEF	BK
      1  0560
      0  0560					      BK	FlashComputerMove
      1  0560		       44		      .byte.b	BANK_aiFlashComputerMove
      0  0561					      BK	BeginSelectMovePhase
      1  0561		       44		      .byte.b	BANK_aiBeginSelectMovePhase
      0  0562					      BK	SelectStartSquare
      1  0562		       44		      .byte.b	BANK_aiSelectStartSquare
      0  0563					      BK	StartSquareSelected
      1  0563		       45		      .byte.b	BANK_aiStartSquareSelected
      0  0564					      BK	DrawMoves
      1  0564		       44		      .byte.b	BANK_aiDrawMoves
      0  0565					      BK	ShowMoveCaptures
      1  0565		       44		      .byte.b	BANK_aiShowMoveCaptures
      0  0566					      BK	SlowFlash
      1  0566		       44		      .byte.b	BANK_aiSlowFlash
      0  0567					      BK	UnDrawTargetSquares
      1  0567		       44		      .byte.b	BANK_aiUnDrawTargetSquares
      0  0568					      BK	SelectDestinationSquare
      1  0568		       44		      .byte.b	BANK_aiSelectDestinationSquare
      0  0569					      BK	Quiescent
      1  0569		       42		      .byte.b	BANK_aiQuiescent
      0  056a					      BK	ReselectDebounce
      1  056a		       45		      .byte.b	BANK_aiReselectDebounce
      0  056b					      BK	StartMoveGen
      1  056b		       44		      .byte.b	BANK_aiStartMoveGen
      0  056c					      BK	StepMoveGen
      1  056c		       45		      .byte.b	BANK_aiStepMoveGen
      0  056d					      BK	StartClearBoard
      1  056d		       89		      .byte.b	BANK_aiStartClearBoard
      0  056e					      BK	ClearEachRow
      1  056e		       89		      .byte.b	BANK_aiClearEachRow
      0  056f					      BK	DrawEntireBoard
      1  056f		       42		      .byte.b	BANK_aiDrawEntireBoard
      0  0570					      BK	DrawPart2
      1  0570		       42		      .byte.b	BANK_aiDrawPart2
      0  0571					      BK	DrawPart3
      1  0571		       42		      .byte.b	BANK_aiDrawPart3
      0  0572					      BK	GenerateMoves
      1  0572		       45		      .byte.b	BANK_aiGenerateMoves
      0  0573					      BK	ComputerMove
      1  0573		       43		      .byte.b	BANK_aiComputerMove
      0  0574					      BK	MoveIsSelected
      1  0574		       89		      .byte.b	BANK_aiMoveIsSelected
      0  0575					      BK	WriteStartPieceBlank
      1  0575		       45		      .byte.b	BANK_aiWriteStartPieceBlank
      0  0576					      BK	MarchToTargetA
      1  0576		       45		      .byte.b	BANK_aiMarchToTargetA
      0  0577					      BK	MarchA2
      1  0577		       44		      .byte.b	BANK_aiMarchA2
      0  0578					      BK	MarchB
      1  0578		       42		      .byte.b	BANK_aiMarchB
      0  0579					      BK	MarchToTargetB
      1  0579		       45		      .byte.b	BANK_aiMarchToTargetB
      0  057a					      BK	MarchB2
      1  057a		       44		      .byte.b	BANK_aiMarchB2
      0  057b					      BK	FinalFlash
      1  057b		       45		      .byte.b	BANK_aiFinalFlash
      0  057c					      BK	SpecialMoveFixup
      1  057c		       42		      .byte.b	BANK_aiSpecialMoveFixup
      0  057d					      BK	InCheckBackup
      1  057d		       44		      .byte.b	BANK_aiInCheckBackup
      0  057e					      BK	InCheckDelay
      1  057e		       44		      .byte.b	BANK_aiInCheckDelay
      0  057f					      BK	PromotePawnStart
      1  057f		       45		      .byte.b	BANK_aiPromotePawnStart
      0  0580					      BK	RollPromotionPiece
      1  0580		       44		      .byte.b	BANK_aiRollPromotionPiece
      0  0581					      BK	ChoosePromotePiece
      1  0581		       44		      .byte.b	BANK_aiChoosePromotePiece
      0  0582					      BK	ChooseDebounce
      1  0582		       45		      .byte.b	BANK_aiChooseDebounce
      0  0583					      BK	CheckMate
      1  0583		       42		      .byte.b	BANK_aiCheckMate
      0  0584					      BK	Draw
      1  0584		       42		      .byte.b	BANK_aiDraw
      0  0585					      BK	DelayAfterMove
      1  0585		       45		      .byte.b	BANK_aiDelayAfterMove
      0  0586					      BK	DelayAfterMove2
      1  0586		       45		      .byte.b	BANK_aiDelayAfterMove2
      0  0587					      BK	DelayAfterPlaced
      1  0587		       45		      .byte.b	BANK_aiDelayAfterPlaced
      0  0588					      BK	DelayAfterPlaced2
      1  0588		       45		      .byte.b	BANK_aiDelayAfterPlaced2
      0  0589					      BK	EPHandler
      1  0589		       45		      .byte.b	BANK_aiEPHandler
      0  058a					      BK	EPFlash
      1  058a		       42		      .byte.b	BANK_aiEPFlash
      0  058b					      BK	DebounceSelect
      1  058b		       44		      .byte.b	BANK_aiDebounceSelect
      0  058c					      BK	InCheckBackupStart
      1  058c		       44		      .byte.b	BANK_aiInCheckBackupStart
      0  058d					      BK	RestoreBitmaps
      1  058d		       44		      .byte.b	BANK_aiRestoreBitmaps
      0  058e					      BK	WaitBitmap
      1  058e		       44		      .byte.b	BANK_aiWaitBitmap
      0  058f					      BK	MaskBitmapBackground
      1  058f		       da		      .byte.b	BANK_aiMaskBitmapBackground
      0  0590					      BK	DrawBitmap2
      1  0590		       da		      .byte.b	BANK_aiDrawBitmap2
      0  0591					      BK	DrawBitmap3
      1  0591		       da		      .byte.b	BANK_aiDrawBitmap3
     52  0592
    398  0592
    399  0592
    400  0592							;---------------------------------------------------------------------------------------------------
    401  0592
      0  0592					      DEF	AiStateMachine
      1  0592				   SLOT_AiStateMachine SET	_BANK_SLOT
      2  0592				   BANK_AiStateMachine SET	SLOT_AiStateMachine + _CURRENT_BANK
      3  0592				   AiStateMachine
      4  0592				   TEMPORARY_VAR SET	Overlay
      5  0592				   TEMPORARY_OFFSET SET	0
      6  0592				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      7  0592				   FUNCTION_NAME SET	AiStateMachine
    403  0592					      SUBROUTINE
    404  0592
      0  0592					      REF	StartupBankReset	;✅
      1  0592				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0592				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0592					      ENDIF
      0  0592					      VAR	__aiVec, 2
      1  0592		       00 a6	   __aiVec    =	TEMPORARY_VAR
      2  0592				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0592
      4  0592				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0592				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0592				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0592					      ENDIF
      8  0592				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0592				  -VNAME      SETSTR	__aiVec
     10  0592				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0592				  -	      ERR
     12  0592					      ENDIF
      0  0592					      VEND	AiStateMachine
      1  0592
      2  0592
      3  0592		       00 a8	   VAREND_AiStateMachine =	TEMPORARY_VAR
      4  0592
    408  0592
    409  0592
    410  0592							; State machine vector setup - points to current routine to execute
    411  0592
    412  0592		       a6 8c		      ldx	aiState
    413  0594		       bd fc f0 	      lda	AiVectorLO,x
    414  0597		       85 a6		      sta	__aiVec
    415  0599		       bd 2e f1 	      lda	AiVectorHI,x
    416  059c		       85 a7		      sta	__aiVec+1
    417  059e
    418  059e		       bd 60 f1 	      lda	AiVectorBANK,x
    419  05a1		       85 3f		      sta	SET_BANK
    420  05a3		       6c a6 00 	      jmp	(__aiVec)	; NOTE: could branch back to squeeze cycles
    421  05a6
    422  05a6
    423  05a6							;---------------------------------------------------------------------------------------------------
    424  05a6
      0  05a6					      DEF	GenerateAllMoves
      1  05a6				   SLOT_GenerateAllMoves SET	_BANK_SLOT
      2  05a6				   BANK_GenerateAllMoves SET	SLOT_GenerateAllMoves + _CURRENT_BANK
      3  05a6				   GenerateAllMoves
      4  05a6				   TEMPORARY_VAR SET	Overlay
      5  05a6				   TEMPORARY_OFFSET SET	0
      6  05a6				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      7  05a6				   FUNCTION_NAME SET	GenerateAllMoves
    426  05a6					      SUBROUTINE
    427  05a6
      0  05a6					      REF	ListPlayerMoves	;✅
      1  05a6					      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  05a6				   TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  05a6					      ENDIF
      0  05a6					      REF	aiComputerMove	;✅
      1  05a6				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  05a6				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  05a6					      ENDIF
      0  05a6					      REF	quiesce	;✅
      1  05a6					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  05a6				   TEMPORARY_VAR SET	VAREND_quiesce
      3  05a6					      ENDIF
      0  05a6					      REF	negaMax	;✅
      1  05a6				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  05a6				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  05a6					      ENDIF
    432  05a6
      0  05a6					      VAR	__vector, 2
      1  05a6		       00 b8	   __vector   =	TEMPORARY_VAR
      2  05a6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  05a6
      4  05a6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05a6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05a6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05a6					      ENDIF
      8  05a6				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  05a6				  -VNAME      SETSTR	__vector
     10  05a6				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  05a6				  -	      ERR
     12  05a6					      ENDIF
      0  05a6					      VAR	__pieceFilter, 1
      1  05a6		       00 ba	   __pieceFilter =	TEMPORARY_VAR
      2  05a6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  05a6
      4  05a6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  05a6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  05a6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  05a6					      ENDIF
      8  05a6				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  05a6				  -VNAME      SETSTR	__pieceFilter
     10  05a6				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  05a6				  -	      ERR
     12  05a6					      ENDIF
    435  05a6
      0  05a6					      VEND	GenerateAllMoves
      1  05a6
      2  05a6
      3  05a6		       00 bb	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
      4  05a6
    437  05a6
    438  05a6							; Do the move generation in two passes - pawns then pieces
    439  05a6							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    440  05a6
    441  05a6							;{
    442  05a6
    443  05a6							; This MUST be called at the start of a new ply
    444  05a6							; It initialises the movelist to empty
    445  05a6							; x must be preserved
    446  05a6
    447  05a6		       a5 95		      lda	currentPly
    448  05a8		       85 3e		      sta	SET_BANK_RAM	;@2
    449  05aa
    450  05aa							; note that 'alpha' and 'beta' are set externally!!
    451  05aa
    452  05aa		       a9 ff		      lda	#-1
      0  05ac					      sta@PLY	moveIndex	; no valid moves
      1  05ac		       8d cf fb 	      sta	[RAM]+moveIndex
      0  05af					      sta@PLY	bestMove
      1  05af		       8d d1 fb 	      sta	[RAM]+bestMove
    455  05b2
    456  05b2		       a5 94		      lda	enPassantPawn	; flag/square from last actual move made
      0  05b4					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  05b4		       8d ca fb 	      sta	[RAM]+enPassantSquare
    458  05b7
    459  05b7		       a5 a3		      lda	vkSquare
      0  05b9					      sta@PLY	virtualKingSquare
      1  05b9		       8d da fb 	      sta	[RAM]+virtualKingSquare
    461  05bc		       a5 a4		      lda	vkSquare+1
      0  05be					      sta@PLY	virtualKingSquare+1	; traversal squares of king for castling
      1  05be		       8d db fb 	      sta	[RAM]+virtualKingSquare+1
    463  05c1
    464  05c1							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
    465  05c1							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
    466  05c1							; start of each new ply.
    467  05c1
    468  05c1		       a5 90		      lda	Evaluation
      0  05c3					      sta@PLY	savedEvaluation
      1  05c3		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    470  05c6		       a5 91		      lda	Evaluation+1
      0  05c8					      sta@PLY	savedEvaluation+1
      1  05c8		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    472  05cb							;}
    473  05cb
    474  05cb
    475  05cb
    476  05cb		       a9 08		      lda	#8	; pawns
    477  05cd		       85 ba		      sta	__pieceFilter
    478  05cf		       20 e0 f1 	      jsr	MoveGenX
    479  05d2							;lda #99
    480  05d2							;sta currentSquare
    481  05d2		       a9 00		      lda	#0
    482  05d4		       85 ba		      sta	__pieceFilter
    483  05d6		       20 e0 f1 	      jsr	MoveGenX
    484  05d9
    485  05d9		       a9 43		      lda	#BANK_Sort
    486  05db		       85 3f		      sta	SET_BANK
    487  05dd		       4c 61 f6 	      jmp	Sort	;@1
    488  05e0
    489  05e0
    490  05e0
      0  05e0					      DEF	MoveGenX
      1  05e0				   SLOT_MoveGenX SET	_BANK_SLOT
      2  05e0				   BANK_MoveGenX SET	SLOT_MoveGenX + _CURRENT_BANK
      3  05e0				   MoveGenX
      4  05e0				   TEMPORARY_VAR SET	Overlay
      5  05e0				   TEMPORARY_OFFSET SET	0
      6  05e0				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      7  05e0				   FUNCTION_NAME SET	MoveGenX
    492  05e0					      SUBROUTINE
    493  05e0
    494  05e0		       a9 d7		      lda	#RAMBANK_BOARD
    495  05e2		       85 3e		      sta	SET_BANK_RAM	;@3		 ; should be hardwired forever, right?
    496  05e4
    497  05e4		       a2 64		      ldx	#100
    498  05e6		       d0 02		      bne	.next
    499  05e8
      0  05e8					      DEF	MoveReturn
      1  05e8				   SLOT_MoveReturn SET	_BANK_SLOT
      2  05e8				   BANK_MoveReturn SET	SLOT_MoveReturn + _CURRENT_BANK
      3  05e8				   MoveReturn
      4  05e8				   TEMPORARY_VAR SET	Overlay
      5  05e8				   TEMPORARY_OFFSET SET	0
      6  05e8				   VAR_BOUNDARY_MoveReturn SET	TEMPORARY_OFFSET
      7  05e8				   FUNCTION_NAME SET	MoveReturn
    501  05e8
    502  05e8		       a6 93		      ldx	currentSquare
    503  05ea		       ca	   .next      dex
    504  05eb		       e0 16		      cpx	#22
    505  05ed		       90 2c		      bcc	.exit
    506  05ef
    507  05ef		       bd 79 fc 	      lda	Board,x
    508  05f2		       f0 f6		      beq	.next
    509  05f4		       c9 ff		      cmp	#-1
    510  05f6		       f0 f2		      beq	.next
    511  05f8		       45 96		      eor	sideToMove
    512  05fa		       30 ee		      bmi	.next
    513  05fc
    514  05fc		       86 93		      stx	currentSquare
    515  05fe
    516  05fe		       45 96		      eor	sideToMove
    517  0600		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    518  0602		       85 92		      sta	currentPiece
    519  0604		       29 0f		      and	#PIECE_MASK
    520  0606		       05 ba		      ora	__pieceFilter
    521  0608		       a8		      tay
    522  0609
    523  0609		       b9 30 f2 	      lda	HandlerVectorHI,y
    524  060c		       85 b9		      sta	__vector+1
    525  060e		       b9 20 f2 	      lda	HandlerVectorLO,y
    526  0611		       85 b8		      sta	__vector
    527  0613
    528  0613		       b9 40 f2 	      lda	HandlerVectorBANK,y
    529  0616		       85 3f		      sta	SET_BANK	;@1
    530  0618
    531  0618		       6c b8 00 	      jmp	(__vector)
    532  061b
    533  061b
    534  061b		       a9 43	   .exit      lda	#BANK_negaMax
    535  061d		       85 3f		      sta	SET_BANK
    536  061f		       60		      rts
    537  0620
    538  0620					      MAC	handlevec
    539  0620					      DEF	HandlerVector{1}
    540  0620
    541  0620					      .byte	{2}MoveReturn
    542  0620					      .byte	{2}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
    543  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
    544  0620					      .byte	{2}Handle_KNIGHT	; 3
    545  0620					      .byte	{2}Handle_BISHOP	; 4
    546  0620					      .byte	{2}Handle_ROOK	; 5
    547  0620					      .byte	{2}Handle_QUEEN	; 6
    548  0620					      .byte	{2}Handle_KING	; 7
    549  0620
    550  0620					      .byte	{2}MoveReturn
    551  0620					      .byte	{2}Handle_WHITE_PAWN	; 1
    552  0620					      .byte	{2}Handle_BLACK_PAWN	; 2
    553  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
    554  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
    555  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
    556  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
    557  0620					      .byte	{2}MoveReturn	;.byte {1}Handle_KING		    ; 7
    558  0620
    559  0620					      ENDM		; {label}, {macro}
    560  0620
    561  0620
    562  0620							;    .byte 0	  ; dummy to prevent page cross access on index 0
    563  0620
      0  0620					      HANDLEVEC	LO, <
      0  0620					      DEF	HandlerVectorLO
      1  0620				   SLOT_HandlerVectorLO SET	_BANK_SLOT
      2  0620				   BANK_HandlerVectorLO SET	SLOT_HandlerVectorLO + _CURRENT_BANK
      3  0620				   HandlerVectorLO
      4  0620				   TEMPORARY_VAR SET	Overlay
      5  0620				   TEMPORARY_OFFSET SET	0
      6  0620				   VAR_BOUNDARY_HandlerVectorLO SET	TEMPORARY_OFFSET
      7  0620				   FUNCTION_NAME SET	HandlerVectorLO
      2  0620
      3  0620		       e8		      .byte.b	<MoveReturn
      4  0621		       e8		      .byte.b	<MoveReturn
      5  0622		       e8		      .byte.b	<MoveReturn
      6  0623		       a0		      .byte.b	<Handle_KNIGHT
      7  0624		       49		      .byte.b	<Handle_BISHOP
      8  0625		       00		      .byte.b	<Handle_ROOK
      9  0626		       7b		      .byte.b	<Handle_QUEEN
     10  0627		       6e		      .byte.b	<Handle_KING
     11  0628
     12  0628		       e8		      .byte.b	<MoveReturn
     13  0629		       29		      .byte.b	<Handle_WHITE_PAWN
     14  062a		       f9		      .byte.b	<Handle_BLACK_PAWN
     15  062b		       e8		      .byte.b	<MoveReturn
     16  062c		       e8		      .byte.b	<MoveReturn
     17  062d		       e8		      .byte.b	<MoveReturn
     18  062e		       e8		      .byte.b	<MoveReturn
     19  062f		       e8		      .byte.b	<MoveReturn
     20  0630
      0  0630					      HANDLEVEC	HI, >
      0  0630					      DEF	HandlerVectorHI
      1  0630				   SLOT_HandlerVectorHI SET	_BANK_SLOT
      2  0630				   BANK_HandlerVectorHI SET	SLOT_HandlerVectorHI + _CURRENT_BANK
      3  0630				   HandlerVectorHI
      4  0630				   TEMPORARY_VAR SET	Overlay
      5  0630				   TEMPORARY_OFFSET SET	0
      6  0630				   VAR_BOUNDARY_HandlerVectorHI SET	TEMPORARY_OFFSET
      7  0630				   FUNCTION_NAME SET	HandlerVectorHI
      2  0630
      3  0630		       f1		      .byte.b	>MoveReturn
      4  0631		       f1		      .byte.b	>MoveReturn
      5  0632		       f1		      .byte.b	>MoveReturn
      6  0633		       f5		      .byte.b	>Handle_KNIGHT
      7  0634		       f6		      .byte.b	>Handle_BISHOP
      8  0635		       f4		      .byte.b	>Handle_ROOK
      9  0636		       f4		      .byte.b	>Handle_QUEEN
     10  0637		       f5		      .byte.b	>Handle_KING
     11  0638
     12  0638		       f1		      .byte.b	>MoveReturn
     13  0639		       f4		      .byte.b	>Handle_WHITE_PAWN
     14  063a		       f4		      .byte.b	>Handle_BLACK_PAWN
     15  063b		       f1		      .byte.b	>MoveReturn
     16  063c		       f1		      .byte.b	>MoveReturn
     17  063d		       f1		      .byte.b	>MoveReturn
     18  063e		       f1		      .byte.b	>MoveReturn
     19  063f		       f1		      .byte.b	>MoveReturn
     20  0640
      0  0640					      HANDLEVEC	BANK, BANK_
      0  0640					      DEF	HandlerVectorBANK
      1  0640				   SLOT_HandlerVectorBANK SET	_BANK_SLOT
      2  0640				   BANK_HandlerVectorBANK SET	SLOT_HandlerVectorBANK + _CURRENT_BANK
      3  0640				   HandlerVectorBANK
      4  0640				   TEMPORARY_VAR SET	Overlay
      5  0640				   TEMPORARY_OFFSET SET	0
      6  0640				   VAR_BOUNDARY_HandlerVectorBANK SET	TEMPORARY_OFFSET
      7  0640				   FUNCTION_NAME SET	HandlerVectorBANK
      2  0640
      3  0640		       01		      .byte.b	BANK_MoveReturn
      4  0641		       01		      .byte.b	BANK_MoveReturn
      5  0642		       01		      .byte.b	BANK_MoveReturn
      6  0643		       46		      .byte.b	BANK_Handle_KNIGHT
      7  0644		       46		      .byte.b	BANK_Handle_BISHOP
      8  0645		       47		      .byte.b	BANK_Handle_ROOK
      9  0646		       47		      .byte.b	BANK_Handle_QUEEN
     10  0647		       47		      .byte.b	BANK_Handle_KING
     11  0648
     12  0648		       01		      .byte.b	BANK_MoveReturn
     13  0649		       46		      .byte.b	BANK_Handle_WHITE_PAWN
     14  064a		       46		      .byte.b	BANK_Handle_BLACK_PAWN
     15  064b		       01		      .byte.b	BANK_MoveReturn
     16  064c		       01		      .byte.b	BANK_MoveReturn
     17  064d		       01		      .byte.b	BANK_MoveReturn
     18  064e		       01		      .byte.b	BANK_MoveReturn
     19  064f		       01		      .byte.b	BANK_MoveReturn
     20  0650
    567  0650
    568  0650
    569  0650							;---------------------------------------------------------------------------------------------------
    570  0650
      0  0650					      DEF	ListPlayerMoves
      1  0650				   SLOT_ListPlayerMoves SET	_BANK_SLOT
      2  0650				   BANK_ListPlayerMoves SET	SLOT_ListPlayerMoves + _CURRENT_BANK
      3  0650				   ListPlayerMoves
      4  0650				   TEMPORARY_VAR SET	Overlay
      5  0650				   TEMPORARY_OFFSET SET	0
      6  0650				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      7  0650				   FUNCTION_NAME SET	ListPlayerMoves
    572  0650					      SUBROUTINE
    573  0650
    574  0650							; Build a list of (mostly) valid player moves. The list of all moves is generated, and then
    575  0650							; these are each verified by making the move and listing all opponent moves. If the opponent
    576  0650							; can capture the king, the move is invalidated by setting its "from" square to zero.
    577  0650
    578  0650							; The movelist is built in the second ply so as not to stomp on the movelist from the computer
    579  0650							; on the previous response. This allows the player movelist to be generated BEFORE the
    580  0650							; computer's move has been visually shown on the screen.
    581  0650
    582  0650							; This in turn requires the minimum memory for PLY banks to be 3 (computer, player, response)
    583  0650
      0  0650					      REF	COMMON_VARS
      1  0650					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0650				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0650					      ENDIF
      0  0650					      REF	selectmove	;✅
      1  0650				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0650				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0650					      ENDIF
      0  0650					      REF	StartupBankReset	;✅
      1  0650				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0650				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0650					      ENDIF
    587  0650
      0  0650					      VEND	ListPlayerMoves
      1  0650
      2  0650
      3  0650		       00 b6	   VAREND_ListPlayerMoves =	TEMPORARY_VAR
      4  0650
    589  0650
    590  0650
    591  0650		       a9 00		      lda	#0
    592  0652		       85 b1		      sta	__quiesceCapOnly	; gen ALL moves
    593  0654
    594  0654		       a9 89		      lda	#RAMBANK_PLY+1
    595  0656		       85 95		      sta	currentPly
    596  0658
    597  0658		       20 a6 f1 	      jsr	GenerateAllMoves	;@this
    598  065b
      0  065b					      ldx@PLY	moveIndex
      1  065b		       ae cf f9 	      ldx	moveIndex
      0  065e				   .scan      stx@PLY	movePtr
      1  065e		       8e d0 fb 	      stx	[RAM]+movePtr
    601  0661
      0  0661					      CALL	MakeMove	;@1
      1  0661				  -	      IF	SLOT_MakeMove == _BANK_SLOT
      2  0661				  -FNAME      SETSTR	MakeMove
      3  0661				  -	      ECHO	""
      4  0661				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0661				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0661				  -	      ERR
      7  0661					      ENDIF
      8  0661		       a9 43		      lda	#BANK_MakeMove
      9  0663		       85 3f		      sta	SET_BANK
     10  0665		       20 7f f4 	      jsr	MakeMove
    603  0668
    604  0668		       e6 95		      inc	currentPly
    605  066a		       20 a6 f1 	      jsr	GenerateAllMoves	;@this
    606  066d
    607  066d		       c6 95		      dec	currentPly
    608  066f
    609  066f		       20 ad f2 	      jsr	unmakeMove	;@this
    610  0672
    611  0672		       a5 a1		      lda	flagCheck
    612  0674		       f0 08		      beq	.next
    613  0676
      0  0676					      ldx@PLY	movePtr
      1  0676		       ae d0 f9 	      ldx	movePtr
    615  0679		       a9 00		      lda	#0
      0  067b					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  067b		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
    617  067e
      0  067e				   .next      ldx@PLY	movePtr
      1  067e		       ae d0 f9 	      ldx	movePtr
    619  0681		       ca		      dex
    620  0682		       10 da		      bpl	.scan
    621  0684
    622  0684		       60		      rts
    623  0685
    624  0685
    625  0685							;---------------------------------------------------------------------------------------------------
    626  0685
      0  0685					      DEF	AddMove
      1  0685				   SLOT_AddMove SET	_BANK_SLOT
      2  0685				   BANK_AddMove SET	SLOT_AddMove + _CURRENT_BANK
      3  0685				   AddMove
      4  0685				   TEMPORARY_VAR SET	Overlay
      5  0685				   TEMPORARY_OFFSET SET	0
      6  0685				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      7  0685				   FUNCTION_NAME SET	AddMove
    628  0685					      SUBROUTINE
    629  0685
      0  0685					      REF	Handle_KING	;✅
      1  0685					      IF	VAREND_Handle_KING > TEMPORARY_VAR
      2  0685				   TEMPORARY_VAR SET	VAREND_Handle_KING
      3  0685					      ENDIF
      0  0685					      REF	Handle_QUEEN	;✅
      1  0685				  -	      IF	VAREND_Handle_QUEEN > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_QUEEN
      3  0685					      ENDIF
      0  0685					      REF	Handle_ROOK	;✅
      1  0685				  -	      IF	VAREND_Handle_ROOK > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_ROOK
      3  0685					      ENDIF
      0  0685					      REF	Handle_BISHOP	;✅
      1  0685				  -	      IF	VAREND_Handle_BISHOP > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_BISHOP
      3  0685					      ENDIF
      0  0685					      REF	Handle_KNIGHT	;✅
      1  0685				  -	      IF	VAREND_Handle_KNIGHT > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_KNIGHT
      3  0685					      ENDIF
      0  0685					      REF	Handle_WHITE_PAWN	;✅
      1  0685				  -	      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  0685					      ENDIF
      0  0685					      REF	Handle_BLACK_PAWN	;✅
      1  0685				  -	      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  0685				  -TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  0685					      ENDIF
    637  0685
      0  0685					      VEND	AddMove
      1  0685
      2  0685
      3  0685		       00 bb	   VAREND_AddMove =	TEMPORARY_VAR
      4  0685
    639  0685
    640  0685							; add square in y register to movelist as destination (X12 format)
    641  0685							; [y]		     to square (X12)
    642  0685							; currentSquare     from square (X12)
    643  0685							; currentPiece      piece.
    644  0685							;   ENPASSANT flag set if pawn double-moving off opening rank
    645  0685							; capture	     captured piece
    646  0685
    647  0685
    648  0685		       a5 a0		      lda	capture
    649  0687		       d0 04		      bne	.always
    650  0689		       a5 b1		      lda	__quiesceCapOnly
    651  068b		       d0 1c		      bne	.abort
    652  068d
    653  068d		       98	   .always    tya
    654  068e		       aa		      tax
    655  068f
      0  068f					      ldy@PLY	moveIndex
      1  068f		       ac cf f9 	      ldy	moveIndex
    657  0692		       c8		      iny
      0  0693					      sty@PLY	moveIndex
      1  0693		       8c cf fb 	      sty	[RAM]+moveIndex
    659  0696
      0  0696					      sta@PLY	MoveTo,y
      1  0696		       99 64 fa 	      sta	[RAM]+MoveTo,y
    661  0699		       a5 93		      lda	currentSquare
      0  069b					      sta@PLY	MoveFrom,y
      1  069b		       99 00 fa 	      sta	[RAM]+MoveFrom,y
    663  069e		       a5 92		      lda	currentPiece
      0  06a0					      sta@PLY	MovePiece,y
      1  06a0		       99 00 fb 	      sta	[RAM]+MovePiece,y
    665  06a3		       a5 a0		      lda	capture
      0  06a5					      sta@PLY	MoveCapture,y
      1  06a5		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    667  06a8		       60		      rts
    668  06a9
    669  06a9		       98	   .abort     tya
    670  06aa		       aa		      tax
    671  06ab		       60		      rts
    672  06ac
    673  06ac
    674  06ac							;---------------------------------------------------------------------------------------------------
    675  06ac
      0  06ac					      DEF	debug
      1  06ac				   SLOT_debug SET	_BANK_SLOT
      2  06ac				   BANK_debug SET	SLOT_debug + _CURRENT_BANK
      3  06ac				   debug
      4  06ac				   TEMPORARY_VAR SET	Overlay
      5  06ac				   TEMPORARY_OFFSET SET	0
      6  06ac				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      7  06ac				   FUNCTION_NAME SET	debug
    677  06ac					      SUBROUTINE
    678  06ac		       60		      rts
    679  06ad
    680  06ad
    681  06ad							;---------------------------------------------------------------------------------------------------
    682  06ad
      0  06ad					      DEF	unmakeMove
      1  06ad				   SLOT_unmakeMove SET	_BANK_SLOT
      2  06ad				   BANK_unmakeMove SET	SLOT_unmakeMove + _CURRENT_BANK
      3  06ad				   unmakeMove
      4  06ad				   TEMPORARY_VAR SET	Overlay
      5  06ad				   TEMPORARY_OFFSET SET	0
      6  06ad				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      7  06ad				   FUNCTION_NAME SET	unmakeMove
    684  06ad					      SUBROUTINE
    685  06ad
      0  06ad					      REF	selectmove	;✅
      1  06ad					      IF	VAREND_selectmove > TEMPORARY_VAR
      2  06ad				   TEMPORARY_VAR SET	VAREND_selectmove
      3  06ad					      ENDIF
      0  06ad					      REF	ListPlayerMoves	;✅
      1  06ad				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  06ad				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  06ad					      ENDIF
      0  06ad					      REF	quiesce	;✅
      1  06ad					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  06ad				   TEMPORARY_VAR SET	VAREND_quiesce
      3  06ad					      ENDIF
      0  06ad					      REF	negaMax	;✅
      1  06ad				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  06ad				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  06ad					      ENDIF
      0  06ad					      VEND	unmakeMove
      1  06ad
      2  06ad
      3  06ad		       00 b8	   VAREND_unmakeMove =	TEMPORARY_VAR
      4  06ad
    691  06ad
    692  06ad							; restore the board evaluation to what it was at the start of this ply
    693  06ad							; TODO: note: moved flag seems wrong on restoration??
    694  06ad
    695  06ad		       a5 95		      lda	currentPly
    696  06af		       85 3e		      sta	SET_BANK_RAM	;@2
    697  06b1		       a2 d7		      ldx	#RAMBANK_BOARD
    698  06b3		       86 3e		      stx	SET_BANK_RAM	;@3
    699  06b5
      0  06b5					      lda@PLY	savedEvaluation
      1  06b5		       ad c8 f9 	      lda	savedEvaluation
    701  06b8		       85 90		      sta	Evaluation
      0  06ba					      lda@PLY	savedEvaluation+1
      1  06ba		       ad c9 f9 	      lda	savedEvaluation+1
    703  06bd		       85 91		      sta	Evaluation+1
    704  06bf
      0  06bf					      lda@PLY	virtualKingSquare
      1  06bf		       ad da f9 	      lda	virtualKingSquare
    706  06c2		       85 a3		      sta	vkSquare
      0  06c4					      lda@PLY	virtualKingSquare+1
      1  06c4		       ad db f9 	      lda	virtualKingSquare+1
    708  06c7		       85 a4		      sta	vkSquare+1
    709  06c9
      0  06c9					      lda@PLY	enPassantSquare
      1  06c9		       ad ca f9 	      lda	enPassantSquare
    711  06cc		       85 94		      sta	enPassantPawn
    712  06ce
      0  06ce					      ldx@PLY	movePtr
      1  06ce		       ae d0 f9 	      ldx	movePtr
      0  06d1					      ldy@PLY	MoveFrom,x
      1  06d1		       bc 00 f8 	      ldy	MoveFrom,x
      0  06d4					      lda@PLY	restorePiece
      1  06d4		       ad d9 f9 	      lda	restorePiece
      0  06d7					      sta@RAM	Board,y
      1  06d7		       99 79 fe 	      sta	[RAM]+Board,y
    717  06da
      0  06da					      ldy@PLY	MoveTo,x
      1  06da		       bc 64 f8 	      ldy	MoveTo,x
      0  06dd					      lda@PLY	capturedPiece
      1  06dd		       ad cb f9 	      lda	capturedPiece
      0  06e0					      sta@RAM	Board,y
      1  06e0		       99 79 fe 	      sta	[RAM]+Board,y
    721  06e3
    722  06e3
    723  06e3							; See if there are any 'secondary' pieces that moved
    724  06e3							; here we're dealing with reverting a castling or enPassant move
    725  06e3
      0  06e3					      lda@PLY	secondaryPiece
      1  06e3		       ad cc f9 	      lda	secondaryPiece
    727  06e6		       f0 10		      beq	.noSecondary
      0  06e8					      ldx@PLY	secondarySquare
      1  06e8		       ae cd f9 	      ldx	secondarySquare
      0  06eb					      sta@RAM	Board,x	; put piece back
      1  06eb		       9d 79 fe 	      sta	[RAM]+Board,x
      0  06ee					      ldy@PLY	secondaryBlank
      1  06ee		       ac ce f9 	      ldy	secondaryBlank
    731  06f1		       f0 05		      beq	.noSecondary	; enpassant - no blanker square
    732  06f3		       a9 00		      lda	#0
      0  06f5					      sta@RAM	Board,y	; blank piece origin
      1  06f5		       99 79 fe 	      sta	[RAM]+Board,y
    734  06f8
      0  06f8				   .noSecondary SWAP
      1  06f8
      2  06f8		       a5 96		      lda	sideToMove
      3  06fa		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  06fc		       85 96		      sta	sideToMove
      5  06fe
    736  06fe		       60		      rts
    737  06ff
    738  06ff
    739  06ff							;---------------------------------------------------------------------------------------------------
    740  06ff
      0  06ff					      DEF	showMoveCaptures
      1  06ff				   SLOT_showMoveCaptures SET	_BANK_SLOT
      2  06ff				   BANK_showMoveCaptures SET	SLOT_showMoveCaptures + _CURRENT_BANK
      3  06ff				   showMoveCaptures
      4  06ff				   TEMPORARY_VAR SET	Overlay
      5  06ff				   TEMPORARY_OFFSET SET	0
      6  06ff				   VAR_BOUNDARY_showMoveCaptures SET	TEMPORARY_OFFSET
      7  06ff				   FUNCTION_NAME SET	showMoveCaptures
    742  06ff					      SUBROUTINE
    743  06ff
      0  06ff					      REF	aiShowMoveCaptures	;✅
      1  06ff					      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  06ff				   TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  06ff					      ENDIF
    745  06ff
      0  06ff					      VAR	__toSquareX12, 1
      1  06ff		       00 a8	   __toSquareX12 =	TEMPORARY_VAR
      2  06ff				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06ff
      4  06ff				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06ff				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06ff				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06ff					      ENDIF
      8  06ff				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  06ff				  -VNAME      SETSTR	__toSquareX12
     10  06ff				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  06ff				  -	      ERR
     12  06ff					      ENDIF
      0  06ff					      VAR	__fromPiece, 1
      1  06ff		       00 a9	   __fromPiece =	TEMPORARY_VAR
      2  06ff				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06ff
      4  06ff				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06ff				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06ff				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06ff					      ENDIF
      8  06ff				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  06ff				  -VNAME      SETSTR	__fromPiece
     10  06ff				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  06ff				  -	      ERR
     12  06ff					      ENDIF
      0  06ff					      VAR	__aiMoveIndex, 1
      1  06ff		       00 aa	   __aiMoveIndex =	TEMPORARY_VAR
      2  06ff				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  06ff
      4  06ff				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  06ff				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  06ff				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  06ff					      ENDIF
      8  06ff				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  06ff				  -VNAME      SETSTR	__aiMoveIndex
     10  06ff				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  06ff				  -	      ERR
     12  06ff					      ENDIF
    749  06ff
      0  06ff					      VEND	showMoveCaptures
      1  06ff
      2  06ff
      3  06ff		       00 ab	   VAREND_showMoveCaptures =	TEMPORARY_VAR
      4  06ff
    751  06ff
    752  06ff							; place a marker on the board for any square matching the piece
    753  06ff							; EXCEPT for squares which are occupied (we'll flash those later)
    754  06ff							; x = movelist item # being checked
    755  06ff
    756  06ff
    757  06ff		       a6 8e	   .next      ldx	aiMoveIndex
    758  0701		       86 aa		      stx	__aiMoveIndex
    759  0703		       30 4a		      bmi	.skip	; no moves in list
    760  0705
    761  0705		       ad 84 02 	      lda	INTIM
    762  0708		       c9 14		      cmp	#20
    763  070a		       90 43		      bcc	.skip
    764  070c
    765  070c		       c6 8e		      dec	aiMoveIndex
    766  070e
    767  070e		       a9 89		      lda	#RAMBANK_PLY+1
    768  0710		       85 3e		      sta	SET_BANK_RAM
      0  0712					      lda@PLY	MoveFrom,x
      1  0712		       bd 00 f8 	      lda	MoveFrom,x
    770  0715		       c5 86		      cmp	fromX12
    771  0717		       d0 e6		      bne	.next
    772  0719
      0  0719					      lda@PLY	MoveTo,x
      1  0719		       bd 64 f8 	      lda	MoveTo,x
    774  071c		       85 a8		      sta	__toSquareX12
    775  071e		       a8		      tay
    776  071f
    777  071f		       a9 d7		      lda	#RAMBANK_BOARD
    778  0721		       85 3e		      sta	SET_BANK_RAM	;@3
    779  0723		       b9 79 fc 	      lda	Board,y
    780  0726		       29 0f		      and	#PIECE_MASK
    781  0728		       f0 d5		      beq	.next
    782  072a
    783  072a							; There's something on the board at destination, so it's a capture
    784  072a							; Let's see if we are doing a pawn promote...
    785  072a
    786  072a		       a4 86		      ldy	fromX12
    787  072c
    788  072c		       a9 d7		      lda	#RAMBANK_BOARD
    789  072e		       85 3e		      sta	SET_BANK_RAM	;@3
    790  0730		       b9 79 fc 	      lda	Board,y
    791  0733		       85 a9		      sta	__fromPiece
    792  0735
    793  0735		       a9 89		      lda	#RAMBANK_PLY+1
    794  0737		       85 3e		      sta	SET_BANK_RAM
      0  0739					      lda@PLY	MovePiece,x
      1  0739		       bd 00 f9 	      lda	MovePiece,x
    796  073c		       45 a9		      eor	__fromPiece
    797  073e		       29 0f		      and	#PIECE_MASK
    798  0740		       f0 06		      beq	.legit	; from == to, so not a promote
    799  0742
    800  0742							; Have detected a promotion duplicate - skip all 3 of them
    801  0742							; TODO: this will need reworking once moves are sorted
    802  0742
    803  0742		       c6 8e		      dec	aiMoveIndex	; skip "KBRQ" promotes
    804  0744		       c6 8e		      dec	aiMoveIndex
    805  0746		       c6 8e		      dec	aiMoveIndex
    806  0748
    807  0748				   .legit
    808  0748
    809  0748							;TIMECHECK CopySinglePiece, restoreIndex     ; not enough time to draw
    810  0748
    811  0748		       a5 a8		      lda	__toSquareX12
    812  074a		       85 81		      sta	squareToDraw
    813  074c
    814  074c							; WARNING - local variables will not survive the following call...!
    815  074c		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    816  074f
    817  074f		       60	   .skip      rts
    818  0750
    819  0750
    820  0750							;---------------------------------------------------------------------------------------------------
    821  0750
      0  0750					      DEF	CopyPieceToRowBitmap
      1  0750				   SLOT_CopyPieceToRowBitmap SET	_BANK_SLOT
      2  0750				   BANK_CopyPieceToRowBitmap SET	SLOT_CopyPieceToRowBitmap + _CURRENT_BANK
      3  0750				   CopyPieceToRowBitmap
      4  0750				   TEMPORARY_VAR SET	Overlay
      5  0750				   TEMPORARY_OFFSET SET	0
      6  0750				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      7  0750				   FUNCTION_NAME SET	CopyPieceToRowBitmap
    823  0750					      SUBROUTINE
    824  0750
      0  0750					      REF	Variable_PieceShapeBuffer
      1  0750					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0750				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0750					      ENDIF
      0  0750					      REF	InterceptMarkerCopy	;✅
      1  0750					      IF	VAREND_InterceptMarkerCopy > TEMPORARY_VAR
      2  0750				   TEMPORARY_VAR SET	VAREND_InterceptMarkerCopy
      3  0750					      ENDIF
    827  0750
      0  0750					      VEND	CopyPieceToRowBitmap
      1  0750
      2  0750
      3  0750		       00 f0	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
      4  0750
    829  0750
    830  0750		       a0 11		      ldy	#17
    831  0752		       b0 30		      bcs	.rightSide
    832  0754
    833  0754		       b9 a6 00    .copyPiece lda	__pieceShapeBuffer,y
    834  0757		       f0 06		      beq	.blank1
    835  0759		       59 00 f8 	      eor	ChessBitmap,y
      0  075c					      sta@RAM	ChessBitmap,y
      1  075c		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    837  075f
    838  075f		       b9 b8 00    .blank1    lda	__pieceShapeBuffer+18,y
    839  0762		       f0 06		      beq	.blank2
    840  0764		       59 12 f8 	      eor	ChessBitmap+18,y
      0  0767					      sta@RAM	ChessBitmap+18,y
      1  0767		       99 12 fa 	      sta	[RAM]+ChessBitmap+18,y
    842  076a
    843  076a		       b9 ca 00    .blank2    lda	__pieceShapeBuffer+36,y
    844  076d		       f0 06		      beq	.blank3
    845  076f		       59 24 f8 	      eor	ChessBitmap+36,y
      0  0772					      sta@RAM	ChessBitmap+36,y
      1  0772		       99 24 fa 	      sta	[RAM]+ChessBitmap+36,y
    847  0775
    848  0775		       b9 dc 00    .blank3    lda	__pieceShapeBuffer+54,y
    849  0778		       f0 06		      beq	.blank4
    850  077a		       59 36 f8 	      eor	ChessBitmap+54,y
      0  077d					      sta@RAM	ChessBitmap+54,y
      1  077d		       99 36 fa 	      sta	[RAM]+ChessBitmap+54,y
    852  0780
    853  0780		       88	   .blank4    dey
    854  0781		       10 d1		      bpl	.copyPiece
    855  0783		       60		      rts
    856  0784
    857  0784				   .rightSide
    858  0784
    859  0784					      SUBROUTINE
    860  0784
    861  0784		       b9 a6 00    .copyPieceR lda	__pieceShapeBuffer,y
    862  0787		       f0 06		      beq	.blank1
    863  0789		       59 48 f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE,y
      0  078c					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE,y
      1  078c		       99 48 fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE,y
    865  078f
    866  078f		       b9 b8 00    .blank1    lda	__pieceShapeBuffer+18,y
    867  0792		       f0 06		      beq	.blank2
    868  0794		       59 5a f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE+18,y
      0  0797					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE+18,y
      1  0797		       99 5a fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE+18,y
    870  079a
    871  079a		       b9 ca 00    .blank2    lda	__pieceShapeBuffer+36,y
    872  079d		       f0 06		      beq	.blank3
    873  079f		       59 6c f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE+36,y
      0  07a2					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE+36,y
      1  07a2		       99 6c fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE+36,y
    875  07a5
    876  07a5		       b9 dc 00    .blank3    lda	__pieceShapeBuffer+54,y
    877  07a8		       f0 06		      beq	.blank4
    878  07aa		       59 7e f8 	      eor	ChessBitmap+PIECE_SHAPE_SIZE+54,y
      0  07ad					      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE+54,y
      1  07ad		       99 7e fa 	      sta	[RAM]+ChessBitmap+PIECE_SHAPE_SIZE+54,y
    880  07b0
    881  07b0		       88	   .blank4    dey
    882  07b1		       10 d1		      bpl	.copyPieceR
    883  07b3		       60		      rts
    884  07b4
    885  07b4
    886  07b4							;---------------------------------------------------------------------------------------------------
    887  07b4
      0  07b4					      DEF	EnPassantRemoveCapturedPawn
      1  07b4				   SLOT_EnPassantRemoveCapturedPawn SET	_BANK_SLOT
      2  07b4				   BANK_EnPassantRemoveCapturedPawn SET	SLOT_EnPassantRemoveCapturedPawn + _CURRENT_BANK
      3  07b4				   EnPassantRemoveCapturedPawn
      4  07b4				   TEMPORARY_VAR SET	Overlay
      5  07b4				   TEMPORARY_OFFSET SET	0
      6  07b4				   VAR_BOUNDARY_EnPassantRemoveCapturedPawn SET	TEMPORARY_OFFSET
      7  07b4				   FUNCTION_NAME SET	EnPassantRemoveCapturedPawn
    889  07b4					      SUBROUTINE
    890  07b4
      0  07b4					      REF	aiSpecialMoveFixup
      1  07b4					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  07b4				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  07b4					      ENDIF
      0  07b4					      VEND	EnPassantRemoveCapturedPawn
      1  07b4
      2  07b4
      3  07b4		       00 b6	   VAREND_EnPassantRemoveCapturedPawn =	TEMPORARY_VAR
      4  07b4
    893  07b4
    894  07b4		       a4 94		      ldy	enPassantPawn
    895  07b6		       f0 27		      beq	.exit
    896  07b8
    897  07b8
    898  07b8		       a9 d7		      lda	#RAMBANK_BOARD
    899  07ba		       85 3e		      sta	SET_BANK_RAM	;@3
    900  07bc
    901  07bc							; Account for the opponent pawn being removed
    902  07bc							; Effectively ADD the values to our current score
    903  07bc
    904  07bc		       a5 96		      lda	sideToMove
    905  07be		       49 80		      eor	#128
    906  07c0		       29 80		      and	#128
    907  07c2		       09 01		      ora	#WP	; == BP in this usage
    908  07c4
    909  07c4		       a2 89		      ldx	#BANK_AddPiecePositionValue
    910  07c6		       86 3f		      stx	SET_BANK	;@2
    911  07c8		       20 59 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    912  07cb
    913  07cb		       a9 01		      lda	#WP	; == BP
    914  07cd		       a2 89		      ldx	#BANK_AddPieceMaterialValue
    915  07cf		       86 3f		      stx	SET_BANK	;@2
    916  07d1		       20 36 f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    917  07d4
    918  07d4		       a9 d7		      lda	#RAMBANK_BOARD
    919  07d6		       85 3e		      sta	SET_BANK_RAM	;@3
    920  07d8
    921  07d8		       a6 94		      ldx	enPassantPawn
    922  07da		       a9 00		      lda	#0
      0  07dc					      sta@RAM	Board,x
      1  07dc		       9d 79 fe 	      sta	[RAM]+Board,x
    924  07df
    925  07df
    926  07df		       60	   .exit      rts
    927  07e0
    928  07e0
    929  07e0							;---------------------------------------------------------------------------------------------------
    930  07e0
      0  07e0					      END_BANK
      1  07e0				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  07e0				  -	      CHECK_RAM_BANK_SIZE
      3  07e0					      ELSE
      0  07e0					      CHECK_BANK_SIZE
      1  07e0		       03 e0	   .TEMP      =	* - _BANK_START
 ROM bank # 2 LOCKED_BANK size = $3e0 free = 31
      2  07e0					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  07e0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  07e0				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  07e0				  -	      ERR
      6  07e0					      ENDIF
      5  07e0					      ENDIF
    932  07e0
    933  07e0							;---------------------------------------------------------------------------------------------------
    934  07e0							; EOF
------- FILE ./chess.asm
    192  07e0
------- FILE @1 GENERIC #1.asm LEVEL 2 PASS 4
      0  07e0					      include	"@1 GENERIC #1.asm"
      1  07e0							;---------------------------------------------------------------------------------------------------
      2  07e0							; @1 GENERIC #1.asm
      3  07e0
      4  07e0							; Atari 2600 Chess
      5  07e0							; Copyright (c) 2019-2020 Andrew Davie
      6  07e0							; andrew@taswegian.com
      7  07e0
      8  07e0							;---------------------------------------------------------------------------------------------------
      9  07e0
      0  07e0					      SLOT	1	; which bank this code switches to
      1  07e0
      2  07e0				  -	      IF	(1 < 0) || (1 > 3)
      3  07e0				  -	      ECHO	"Illegal bank address/segment location", 1
      4  07e0				  -	      ERR
      5  07e0					      ENDIF
      6  07e0
      7  07e0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  07e0				   _BANK_SLOT SET	1 * 64
      9  07e0
      0  07e0					      ROMBANK	ONE
      1  0af4 ????				      SEG	ROM_ONE
      2  0800					      ORG	_ORIGIN
      3  0800					      RORG	_BANK_ADDRESS_ORIGIN
      4  0800				   _BANK_START SET	*
      5  0800				   ONE_START  SET	*
      6  0800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0800				   ROMBANK_ONE SET	_BANK_SLOT + _CURRENT_BANK
      8  0800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0800				   _LAST_BANK SETSTR	ONE
     10  0800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0800
     13  0800
     14  0800							;---------------------------------------------------------------------------------------------------
     15  0800
      0  0800					      DEF	CartInit
      1  0800				   SLOT_CartInit SET	_BANK_SLOT
      2  0800				   BANK_CartInit SET	SLOT_CartInit + _CURRENT_BANK
      3  0800				   CartInit
      4  0800				   TEMPORARY_VAR SET	Overlay
      5  0800				   TEMPORARY_OFFSET SET	0
      6  0800				   VAR_BOUNDARY_CartInit SET	TEMPORARY_OFFSET
      7  0800				   FUNCTION_NAME SET	CartInit
     17  0800					      SUBROUTINE
     18  0800
      0  0800					      REF	StartupBankReset	;✅
      1  0800				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0800				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0800					      ENDIF
     20  0800
      0  0800					      VEND	CartInit
      1  0800
      2  0800
      3  0800		       00 a6	   VAREND_CartInit =	TEMPORARY_VAR
      4  0800
     22  0800
     23  0800
     24  0800							; See if we can come up with something 'random' for startup
     25  0800
     26  0800		       ac 84 02 	      ldy	INTIM
     27  0803		       d0 02		      bne	.toR
     28  0805		       a0 9a		      ldy	#$9A
     29  0807		       84 82	   .toR       sty	rnd
     30  0809
     31  0809		       a9 1f		      lda	#31
     32  080b		       85 a2		      sta	randomness
     33  080d
     34  080d		       a9 00		      lda	#0
     35  080f		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     36  0812		       85 2b		      sta	HMCLR
     37  0814
     38  0814
     39  0814		       85 1b		      sta	GRP0
     40  0816		       85 1c		      sta	GRP1
     41  0818		       85 1d		      sta	ENAM0
     42  081a		       85 1e		      sta	ENAM1
     43  081c		       85 1f		      sta	ENABL
     44  081e
     45  081e							;lda #$FF
     46  081e		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     47  0821
     48  0821							; cleanup remains of title screen
     49  0821							;sta GRP0
     50  0821							;sta GRP1
     51  0821
     52  0821		       a9 07		      lda	#%111
     53  0823		       85 04		      sta	NUSIZ0
     54  0825		       85 05		      sta	NUSIZ1	; quad-width
     55  0827
     56  0827							;lda #%00000100
     57  0827							;sta CTRLPF
     58  0827		       a9 00		      lda	#BACKGCOL
     59  0829		       85 09		      sta	COLUBK
     60  082b
     61  082b
     62  082b		       a9 40		      lda	#WHITE|HUMAN
     63  082d		       85 96		      sta	sideToMove
     64  082f
     65  082f		       ad 82 02 	      lda	SWCHB
     66  0832		       0a		      asl
     67  0833		       2a		      rol
     68  0834		       2a		      rol
     69  0835		       29 01		      and	#1
     70  0837		       85 a5		      sta	platform	; P1 difficulty --> NTSC/PAL
     71  0839
     72  0839							;SPEAK left_speech
     73  0839		       60		      rts
     74  083a
     75  083a
     76  083a							;---------------------------------------------------------------------------------------------------
     77  083a
      0  083a					      DEF	SetupBanks
      1  083a				   SLOT_SetupBanks SET	_BANK_SLOT
      2  083a				   BANK_SetupBanks SET	SLOT_SetupBanks + _CURRENT_BANK
      3  083a				   SetupBanks
      4  083a				   TEMPORARY_VAR SET	Overlay
      5  083a				   TEMPORARY_OFFSET SET	0
      6  083a				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      7  083a				   FUNCTION_NAME SET	SetupBanks
     79  083a					      SUBROUTINE
     80  083a
      0  083a					      REF	StartupBankReset
      1  083a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  083a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  083a					      ENDIF
      0  083a					      VEND	SetupBanks
      1  083a
      2  083a
      3  083a		       00 a6	   VAREND_SetupBanks =	TEMPORARY_VAR
      4  083a
     83  083a
     84  083a
     85  083a
     86  083a							; Move a copy of the row bank template to the first 8 banks of RAM
     87  083a							; and then terminate the draw subroutine by substituting in a RTS on the last one
     88  083a
      0  083a					      REF	StartupBankReset	;✅
      1  083a				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  083a				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  083a					      ENDIF
      0  083a					      VEND	SetupBanks
      1  083a
      2  083a
      3  083a		       00 a6	   VAREND_SetupBanks =	TEMPORARY_VAR
      4  083a
     91  083a
     92  083a							; Copy the bitmap shadow into the first 8 RAM banks via x(SLOT3)-->y(SLOT2)
     93  083a
     94  083a				   .ROWBANK   SET	0
     95  083a					      REPEAT	8
     96  083a		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     97  083c		       a0 c0		      ldy	#[SLOT3] + .ROWBANK
     98  083e		       20 3b f5 	      jsr	CopyShadowROMtoRAM
     99  083e				   .ROWBANK   SET	.ROWBANK+1
     95  083e					      REPEND
     96  0841		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     97  0843		       a0 c1		      ldy	#[SLOT3] + .ROWBANK
     98  0845		       20 3b f5 	      jsr	CopyShadowROMtoRAM
     99  0845				   .ROWBANK   SET	.ROWBANK+1
     95  0845					      REPEND
     96  0848		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     97  084a		       a0 c2		      ldy	#[SLOT3] + .ROWBANK
     98  084c		       20 3b f5 	      jsr	CopyShadowROMtoRAM
     99  084c				   .ROWBANK   SET	.ROWBANK+1
     95  084c					      REPEND
     96  084f		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     97  0851		       a0 c3		      ldy	#[SLOT3] + .ROWBANK
     98  0853		       20 3b f5 	      jsr	CopyShadowROMtoRAM
     99  0853				   .ROWBANK   SET	.ROWBANK+1
     95  0853					      REPEND
     96  0856		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     97  0858		       a0 c4		      ldy	#[SLOT3] + .ROWBANK
     98  085a		       20 3b f5 	      jsr	CopyShadowROMtoRAM
     99  085a				   .ROWBANK   SET	.ROWBANK+1
     95  085a					      REPEND
     96  085d		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     97  085f		       a0 c5		      ldy	#[SLOT3] + .ROWBANK
     98  0861		       20 3b f5 	      jsr	CopyShadowROMtoRAM
     99  0861				   .ROWBANK   SET	.ROWBANK+1
     95  0861					      REPEND
     96  0864		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     97  0866		       a0 c6		      ldy	#[SLOT3] + .ROWBANK
     98  0868		       20 3b f5 	      jsr	CopyShadowROMtoRAM
     99  0868				   .ROWBANK   SET	.ROWBANK+1
     95  0868					      REPEND
     96  086b		       a2 88		      ldx	#BANK_SHADOW_ChessBitmap
     97  086d		       a0 c7		      ldy	#[SLOT3] + .ROWBANK
     98  086f		       20 3b f5 	      jsr	CopyShadowROMtoRAM
     99  086f				   .ROWBANK   SET	.ROWBANK+1
    100  0872					      REPEND
    101  0872
    102  0872
    103  0872							; Patch the final row's "loop" to a RTS
    104  0872
    105  0872		       a2 87		      ldx	#[SLOT2] + 7	; last ROW BITMAP bank
    106  0874		       86 3e		      stx	SET_BANK_RAM
    107  0876		       a9 60		      lda	#$60	; "rts"
      0  0878					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  0878		       8d a0 fa 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
    109  087b
    110  087b
    111  087b							; Patch the NTSC/PAL colours in all row banks
    112  087b
    113  087b		       a6 a5		      ldx	platform
    114  087b				   .ROWBANK   SET	[SLOT2]
    115  087d					      REPEAT	8
    116  087d		       a9 80		      lda	#.ROWBANK
    117  087f		       85 3e		      sta	SET_BANK_RAM
    118  0881
    119  0881		       bd 35 f5 	      lda	col1,x
      0  0884					      sta@RAM	SMCOL1+1
      1  0884		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    121  0887		       bd 37 f5 	      lda	col2,x
      0  088a					      sta@RAM	SMCOL2+1
      1  088a		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    123  088d		       bd 39 f5 	      lda	col3,x
      0  0890					      sta@RAM	SMCOL3+1
      1  0890		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    125  0893
    126  0893				  -	      IFCONST	RAINBOW
    127  0893				  -	      inx
    128  0893				  -	      inx
    129  0893					      ENDIF
    130  0893
    131  0893				   .ROWBANK   SET	.ROWBANK + 1
    115  0893					      REPEND
    116  0893		       a9 81		      lda	#.ROWBANK
    117  0895		       85 3e		      sta	SET_BANK_RAM
    118  0897
    119  0897		       bd 35 f5 	      lda	col1,x
      0  089a					      sta@RAM	SMCOL1+1
      1  089a		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    121  089d		       bd 37 f5 	      lda	col2,x
      0  08a0					      sta@RAM	SMCOL2+1
      1  08a0		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    123  08a3		       bd 39 f5 	      lda	col3,x
      0  08a6					      sta@RAM	SMCOL3+1
      1  08a6		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    125  08a9
    126  08a9				  -	      IFCONST	RAINBOW
    127  08a9				  -	      inx
    128  08a9				  -	      inx
    129  08a9					      ENDIF
    130  08a9
    131  08a9				   .ROWBANK   SET	.ROWBANK + 1
    115  08a9					      REPEND
    116  08a9		       a9 82		      lda	#.ROWBANK
    117  08ab		       85 3e		      sta	SET_BANK_RAM
    118  08ad
    119  08ad		       bd 35 f5 	      lda	col1,x
      0  08b0					      sta@RAM	SMCOL1+1
      1  08b0		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    121  08b3		       bd 37 f5 	      lda	col2,x
      0  08b6					      sta@RAM	SMCOL2+1
      1  08b6		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    123  08b9		       bd 39 f5 	      lda	col3,x
      0  08bc					      sta@RAM	SMCOL3+1
      1  08bc		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    125  08bf
    126  08bf				  -	      IFCONST	RAINBOW
    127  08bf				  -	      inx
    128  08bf				  -	      inx
    129  08bf					      ENDIF
    130  08bf
    131  08bf				   .ROWBANK   SET	.ROWBANK + 1
    115  08bf					      REPEND
    116  08bf		       a9 83		      lda	#.ROWBANK
    117  08c1		       85 3e		      sta	SET_BANK_RAM
    118  08c3
    119  08c3		       bd 35 f5 	      lda	col1,x
      0  08c6					      sta@RAM	SMCOL1+1
      1  08c6		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    121  08c9		       bd 37 f5 	      lda	col2,x
      0  08cc					      sta@RAM	SMCOL2+1
      1  08cc		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    123  08cf		       bd 39 f5 	      lda	col3,x
      0  08d2					      sta@RAM	SMCOL3+1
      1  08d2		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    125  08d5
    126  08d5				  -	      IFCONST	RAINBOW
    127  08d5				  -	      inx
    128  08d5				  -	      inx
    129  08d5					      ENDIF
    130  08d5
    131  08d5				   .ROWBANK   SET	.ROWBANK + 1
    115  08d5					      REPEND
    116  08d5		       a9 84		      lda	#.ROWBANK
    117  08d7		       85 3e		      sta	SET_BANK_RAM
    118  08d9
    119  08d9		       bd 35 f5 	      lda	col1,x
      0  08dc					      sta@RAM	SMCOL1+1
      1  08dc		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    121  08df		       bd 37 f5 	      lda	col2,x
      0  08e2					      sta@RAM	SMCOL2+1
      1  08e2		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    123  08e5		       bd 39 f5 	      lda	col3,x
      0  08e8					      sta@RAM	SMCOL3+1
      1  08e8		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    125  08eb
    126  08eb				  -	      IFCONST	RAINBOW
    127  08eb				  -	      inx
    128  08eb				  -	      inx
    129  08eb					      ENDIF
    130  08eb
    131  08eb				   .ROWBANK   SET	.ROWBANK + 1
    115  08eb					      REPEND
    116  08eb		       a9 85		      lda	#.ROWBANK
    117  08ed		       85 3e		      sta	SET_BANK_RAM
    118  08ef
    119  08ef		       bd 35 f5 	      lda	col1,x
      0  08f2					      sta@RAM	SMCOL1+1
      1  08f2		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    121  08f5		       bd 37 f5 	      lda	col2,x
      0  08f8					      sta@RAM	SMCOL2+1
      1  08f8		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    123  08fb		       bd 39 f5 	      lda	col3,x
      0  08fe					      sta@RAM	SMCOL3+1
      1  08fe		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    125  0901
    126  0901				  -	      IFCONST	RAINBOW
    127  0901				  -	      inx
    128  0901				  -	      inx
    129  0901					      ENDIF
    130  0901
    131  0901				   .ROWBANK   SET	.ROWBANK + 1
    115  0901					      REPEND
    116  0901		       a9 86		      lda	#.ROWBANK
    117  0903		       85 3e		      sta	SET_BANK_RAM
    118  0905
    119  0905		       bd 35 f5 	      lda	col1,x
      0  0908					      sta@RAM	SMCOL1+1
      1  0908		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    121  090b		       bd 37 f5 	      lda	col2,x
      0  090e					      sta@RAM	SMCOL2+1
      1  090e		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    123  0911		       bd 39 f5 	      lda	col3,x
      0  0914					      sta@RAM	SMCOL3+1
      1  0914		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    125  0917
    126  0917				  -	      IFCONST	RAINBOW
    127  0917				  -	      inx
    128  0917				  -	      inx
    129  0917					      ENDIF
    130  0917
    131  0917				   .ROWBANK   SET	.ROWBANK + 1
    115  0917					      REPEND
    116  0917		       a9 87		      lda	#.ROWBANK
    117  0919		       85 3e		      sta	SET_BANK_RAM
    118  091b
    119  091b		       bd 35 f5 	      lda	col1,x
      0  091e					      sta@RAM	SMCOL1+1
      1  091e		       8d b2 fa 	      sta	[RAM]+SMCOL1+1
    121  0921		       bd 37 f5 	      lda	col2,x
      0  0924					      sta@RAM	SMCOL2+1
      1  0924		       8d f0 fa 	      sta	[RAM]+SMCOL2+1
    123  0927		       bd 39 f5 	      lda	col3,x
      0  092a					      sta@RAM	SMCOL3+1
      1  092a		       8d 21 fb 	      sta	[RAM]+SMCOL3+1
    125  092d
    126  092d				  -	      IFCONST	RAINBOW
    127  092d				  -	      inx
    128  092d				  -	      inx
    129  092d					      ENDIF
    130  092d
    131  092d				   .ROWBANK   SET	.ROWBANK + 1
    132  092d					      REPEND
    133  092d
    134  092d
    135  092d
    136  092d							; copy the BOARD/MOVES bank
    137  092d
    138  092d		       a2 9d		      ldx	#ROMBANK_SHADOW_BOARD
    139  092f		       a0 d7		      ldy	#RAMBANK_BOARD
    140  0931		       20 3b f5 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
    141  0934
    142  0934
    143  0934							; copy the PLY banks
    144  0934							; If there's no content (only variable decs) then we don't really need to do this.
    145  0934
    146  0934							;.PLY SET 0
    147  0934							;    REPEAT PLY_BANKS
    148  0934
    149  0934							;		      ldx #SHADOW_PLY
    150  0934							;		      ldy #RAMBANK_PLY + .PLY
    151  0934							;jsr CopyShadowROMtoRAM
    152  0934							;.PLY SET .PLY + 1
    153  0934							;    REPEND
    154  0934
    155  0934							; copy the evaluation code/tables
    156  0934							; 3E+ moved from RAM to ROM
    157  0934
    158  0934							;		      ldx #[SLOT2] + SHADOW_EVAL
    159  0934							;		      ldy #[SLOT3] + EVAL
    160  0934							;		      jsr CopyShadowROMtoRAM
    161  0934
    162  0934
    163  0934							;		      ldy #RAMBANK_RAM_PIECELIST
    164  0934							;		      ldx #ROM_PIECELIST
    165  0934							;		      jsr CopyShadowROMtoRAM
    166  0934
    167  0934		       60		      rts
    168  0935
    169  0935
    170  0935				   col1
    171  0935		       86 d6		      .byte.b	NTSC_COLOUR_LINE_1, PAL_COLOUR_LINE_1
    172  0937				  -	      IFCONST	RAINBOW
    173  0937				  -	      .byte	(NTSC_COLOUR_LINE_1+16)&$FF, PAL_COLOUR_LINE_1
    174  0937				  -	      .byte	(NTSC_COLOUR_LINE_1+32)&$FF, PAL_COLOUR_LINE_1
    175  0937				  -	      .byte	(NTSC_COLOUR_LINE_1+48)&$FF, PAL_COLOUR_LINE_1
    176  0937				  -	      .byte	(NTSC_COLOUR_LINE_1+64)&$FF, PAL_COLOUR_LINE_1
    177  0937				  -	      .byte	(NTSC_COLOUR_LINE_1+80)&$FF, PAL_COLOUR_LINE_1
    178  0937				  -	      .byte	(NTSC_COLOUR_LINE_1+96)&$FF, PAL_COLOUR_LINE_1
    179  0937				  -	      .byte	(NTSC_COLOUR_LINE_1+112)&$FF, PAL_COLOUR_LINE_1
    180  0937					      ENDIF
    181  0937				   col2
    182  0937		       48 6a		      .byte.b	NTSC_COLOUR_LINE_2, PAL_COLOUR_LINE_2
    183  0939				  -	      IFCONST	RAINBOW
    184  0939				  -	      .byte	(NTSC_COLOUR_LINE_2+32)&$FF, PAL_COLOUR_LINE_2
    185  0939				  -	      .byte	(NTSC_COLOUR_LINE_2+48)&$FF, PAL_COLOUR_LINE_2
    186  0939				  -	      .byte	(NTSC_COLOUR_LINE_2+64)&$FF, PAL_COLOUR_LINE_2
    187  0939				  -	      .byte	(NTSC_COLOUR_LINE_2+80)&$FF, PAL_COLOUR_LINE_2
    188  0939				  -	      .byte	(NTSC_COLOUR_LINE_2+96)&$FF, PAL_COLOUR_LINE_2
    189  0939				  -	      .byte	(NTSC_COLOUR_LINE_2+112)&$FF, PAL_COLOUR_LINE_2
    190  0939				  -	      .byte	(NTSC_COLOUR_LINE_2+128)&$FF, PAL_COLOUR_LINE_2
    191  0939					      ENDIF
    192  0939				   col3
    193  0939		       da 3c		      .byte.b	NTSC_COLOUR_LINE_3, PAL_COLOUR_LINE_3
    194  093b				  -	      IFCONST	RAINBOW
    195  093b				  -	      .byte	(NTSC_COLOUR_LINE_3+32)&$FF, PAL_COLOUR_LINE_3
    196  093b				  -	      .byte	(NTSC_COLOUR_LINE_3+48)&$FF, PAL_COLOUR_LINE_3
    197  093b				  -	      .byte	(NTSC_COLOUR_LINE_3+64)&$FF, PAL_COLOUR_LINE_3
    198  093b				  -	      .byte	(NTSC_COLOUR_LINE_3+80)&$FF, PAL_COLOUR_LINE_3
    199  093b				  -	      .byte	(NTSC_COLOUR_LINE_3+96)&$FF, PAL_COLOUR_LINE_3
    200  093b				  -	      .byte	(NTSC_COLOUR_LINE_3+112)&$FF, PAL_COLOUR_LINE_3
    201  093b				  -	      .byte	(NTSC_COLOUR_LINE_3+128)&$FF, PAL_COLOUR_LINE_3
    202  093b					      ENDIF
    203  093b
    204  093b
    205  093b				  -	      IFCONST	RAINBOW
    206  093b				  -	      DEF	RainBoard
    207  093b				  -
    208  093b				  -	      clc
    209  093b				  -	      lda	base
    210  093b				  -	      adc	#4
    211  093b				  -	      sta	base
    212  093b				  -
    213  093b				  -	      and	#$F0
    214  093b				  -	      beq	RainBoard
    215  093b				  -
    216  093b				  -	      ora	#8
    217  093b				  -
    218  093b				  -
    219  093b				  -.ROWBANK   SET	[SLOT2]
    220  093b				  -	      REPEAT	8
    221  093b				  -	      ldy	#.ROWBANK
    222  093b				  -	      sty	SET_BANK_RAM
    223  093b				  -
    224  093b				  -	      sta@RAM	SMCOL1+1
    225  093b				  -
    226  093b				  -	      clc
    227  093b				  -	      adc	#16
    228  093b				  -
    229  093b				  -.ROWBANK   SET	.ROWBANK + 1
    230  093b				  -	      REPEND
    231  093b				  -
    232  093b				  -	      rts
    233  093b					      ENDIF
    234  093b
    235  093b
    236  093b							;---------------------------------------------------------------------------------------------------
    237  093b
      0  093b					      DEF	CopyShadowROMtoRAM
      1  093b				   SLOT_CopyShadowROMtoRAM SET	_BANK_SLOT
      2  093b				   BANK_CopyShadowROMtoRAM SET	SLOT_CopyShadowROMtoRAM + _CURRENT_BANK
      3  093b				   CopyShadowROMtoRAM
      4  093b				   TEMPORARY_VAR SET	Overlay
      5  093b				   TEMPORARY_OFFSET SET	0
      6  093b				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      7  093b				   FUNCTION_NAME SET	CopyShadowROMtoRAM
    239  093b					      SUBROUTINE
    240  093b
      0  093b					      REF	SetupBanks	;✅
      1  093b				  -	      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  093b				  -TEMPORARY_VAR SET	VAREND_SetupBanks
      3  093b					      ENDIF
    242  093b
      0  093b					      VEND	CopyShadowROMtoRAM
      1  093b
      2  093b
      3  093b		       00 a6	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
      4  093b
    244  093b
    245  093b							; Copy a whole ROM SHADOW into a destination RAM 512 byte bank
    246  093b							; used to setup callable RAM code from ROM templates
    247  093b
    248  093b							; x = source ROM bank
    249  093b							; y = destination RAM bank (preserved)
    250  093b
    251  093b		       86 3f		      stx	SET_BANK
    252  093d		       84 3e		      sty	SET_BANK_RAM
    253  093f
    254  093f		       a2 00		      ldx	#0
    255  0941		       bd 00 f8    .copyPage  lda	$F800,x
      0  0944					      sta@RAM	$FC00,x
      1  0944		       9d 00 fe 	      sta	[RAM]+$FC00,x
    257  0947		       bd 00 f9 	      lda	$F900,x
      0  094a					      sta@RAM	$FD00,x
      1  094a		       9d 00 ff 	      sta	[RAM]+$FD00,x
    259  094d		       ca		      dex
    260  094e		       d0 f1		      bne	.copyPage
    261  0950		       60		      rts
    262  0951
    263  0951
    264  0951							;---------------------------------------------------------------------------------------------------
    265  0951
      0  0951					      DEF	InitialisePieceSquares
      1  0951				   SLOT_InitialisePieceSquares SET	_BANK_SLOT
      2  0951				   BANK_InitialisePieceSquares SET	SLOT_InitialisePieceSquares + _CURRENT_BANK
      3  0951				   InitialisePieceSquares
      4  0951				   TEMPORARY_VAR SET	Overlay
      5  0951				   TEMPORARY_OFFSET SET	0
      6  0951				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      7  0951				   FUNCTION_NAME SET	InitialisePieceSquares
    267  0951					      SUBROUTINE
    268  0951
      0  0951					      REF	COMMON_VARS
      1  0951					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0951				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0951					      ENDIF
      0  0951					      REF	StartupBankReset	;✅
      1  0951				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  0951				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  0951					      ENDIF
    271  0951
      0  0951					      VAR	__initPiece, 1
      1  0951		       00 b6	   __initPiece =	TEMPORARY_VAR
      2  0951				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0951
      4  0951				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0951				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0951				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0951					      ENDIF
      8  0951				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0951				  -VNAME      SETSTR	__initPiece
     10  0951				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0951				  -	      ERR
     12  0951					      ENDIF
      0  0951					      VAR	__initSquare, 1
      1  0951		       00 b7	   __initSquare =	TEMPORARY_VAR
      2  0951				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0951
      4  0951				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0951				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0951				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0951					      ENDIF
      8  0951				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0951				  -VNAME      SETSTR	__initSquare
     10  0951				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0951				  -	      ERR
     12  0951					      ENDIF
      0  0951					      VAR	__initListPtr, 1
      1  0951		       00 b8	   __initListPtr =	TEMPORARY_VAR
      2  0951				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0951
      4  0951				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0951				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0951				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0951					      ENDIF
      8  0951				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0951				  -VNAME      SETSTR	__initListPtr
     10  0951				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0951				  -	      ERR
     12  0951					      ENDIF
      0  0951					      VAR	__op, 1
      1  0951		       00 b9	   __op       =	TEMPORARY_VAR
      2  0951				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0951
      4  0951				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0951				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0951				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0951					      ENDIF
      8  0951				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0951				  -VNAME      SETSTR	__op
     10  0951				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0951				  -	      ERR
     12  0951					      ENDIF
    276  0951
      0  0951					      VEND	InitialisePieceSquares
      1  0951
      2  0951
      3  0951		       00 ba	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
      4  0951
    278  0951
    279  0951		       a9 00		      lda	#0
    280  0953		       85 90		      sta	Evaluation
    281  0955		       85 91		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    282  0957		       85 94		      sta	enPassantPawn	; no en-passant
    283  0959
    284  0959
      0  0959					      PHASE	StartClearBoard
      1  0959		       a9 0d		      lda	#AI_StartClearBoard
      2  095b		       85 8c		      sta	aiState
    286  095d
    287  095d		       a2 00		      ldx	#0
    288  095f				   .fillPieceLists
    289  095f
    290  095f
    291  095f		       bd b1 f5 	      lda	InitPieceList,x	; colour/-1
    292  0962		       f0 4c		      beq	.exit
    293  0964		       85 b9		      sta	__op	; type
    294  0966		       bc b2 f5 	      ldy	InitPieceList+1,x	; square
    295  0969		       84 b7		      sty	__initSquare
    296  096b
    297  096b		       a9 d7		      lda	#RAMBANK_BOARD
    298  096d		       85 3e		      sta	SET_BANK_RAM
    299  096f		       a5 b9		      lda	__op
      0  0971					      sta@RAM	Board,y
      1  0971		       99 79 fe 	      sta	[RAM]+Board,y
    301  0974		       10 0d		      bpl	.white
    302  0976
      0  0976					      NEGEVAL
      1  0976
      2  0976		       38		      sec
      3  0977		       a9 00		      lda	#0
      4  0979		       e5 90		      sbc	Evaluation
      5  097b		       85 90		      sta	Evaluation
      6  097d		       a9 00		      lda	#0
      7  097f		       e5 91		      sbc	Evaluation+1
      8  0981		       85 91		      sta	Evaluation+1
      9  0983
    304  0983				   .white
    305  0983
    306  0983		       86 b8		      stx	__initListPtr
    307  0985
    308  0985							; Add the material value of the piece to the evaluation
    309  0985
    310  0985		       a5 b9		      lda	__op
    311  0987		       a2 89		      ldx	#BANK_AddPieceMaterialValue
    312  0989		       86 3f		      stx	SET_BANK	;@2
    313  098b		       20 36 f9 	      jsr	AddPieceMaterialValue
    314  098e
    315  098e
    316  098e							; add the positional value of the piece to the evaluation
    317  098e
    318  098e		       a4 b7		      ldy	__initSquare
    319  0990		       a5 b9		      lda	__op
    320  0992		       a2 89		      ldx	#BANK_AddPiecePositionValue
    321  0994		       86 3f		      stx	SET_BANK
    322  0996		       20 59 f9 	      jsr	AddPiecePositionValue
    323  0999
    324  0999		       a5 b9		      lda	__op	; type/colour
    325  099b		       10 0d		      bpl	.white2
      0  099d					      NEGEVAL
      1  099d
      2  099d		       38		      sec
      3  099e		       a9 00		      lda	#0
      4  09a0		       e5 90		      sbc	Evaluation
      5  09a2		       85 90		      sta	Evaluation
      6  09a4		       a9 00		      lda	#0
      7  09a6		       e5 91		      sbc	Evaluation+1
      8  09a8		       85 91		      sta	Evaluation+1
      9  09aa
    327  09aa				   .white2
    328  09aa
    329  09aa		       a6 b8		      ldx	__initListPtr
    330  09ac		       e8		      inx
    331  09ad		       e8		      inx
    332  09ae		       10 af		      bpl	.fillPieceLists
    333  09b0
    334  09b0				   .exit
    335  09b0		       60		      rts
    336  09b1
    337  09b1
    338  09b1				   InitPieceList
    339  09b1
    340  09b1
    341  09b1					      IF	!TEST_POSITION
    342  09b1
    343  09b1		       06 19		      .byte.b	WHITE|Q, 25
    344  09b3		       04 18		      .byte.b	WHITE|B, 24
    345  09b5		       04 1b		      .byte.b	WHITE|B, 27
    346  09b7		       05 16		      .byte.b	WHITE|R, 22
    347  09b9		       05 1d		      .byte.b	WHITE|R, 29
    348  09bb		       03 17		      .byte.b	WHITE|N, 23
    349  09bd		       03 1c		      .byte.b	WHITE|N, 28
    350  09bf
    351  09bf		       01 23		      .byte.b	WHITE|WP, 35
    352  09c1		       01 24		      .byte.b	WHITE|WP, 36
    353  09c3		       01 22		      .byte.b	WHITE|WP, 34
    354  09c5		       01 25		      .byte.b	WHITE|WP, 37
    355  09c7		       01 21		      .byte.b	WHITE|WP, 33
    356  09c9		       01 26		      .byte.b	WHITE|WP, 38
    357  09cb		       01 20		      .byte.b	WHITE|WP, 32
    358  09cd		       01 27		      .byte.b	WHITE|WP, 39
    359  09cf
    360  09cf		       07 1a		      .byte.b	WHITE|K, 26
    361  09d1
    362  09d1		       86 5f		      .byte.b	BLACK|Q, 95
    363  09d3		       84 5e		      .byte.b	BLACK|B, 94
    364  09d5		       84 61		      .byte.b	BLACK|B, 97
    365  09d7		       85 5c		      .byte.b	BLACK|R, 92
    366  09d9		       85 63		      .byte.b	BLACK|R, 99
    367  09db		       83 5d		      .byte.b	BLACK|N, 93
    368  09dd		       83 62		      .byte.b	BLACK|N, 98
    369  09df
    370  09df		       82 55		      .byte.b	BLACK|BP, 85
    371  09e1		       82 56		      .byte.b	BLACK|BP, 86
    372  09e3		       82 54		      .byte.b	BLACK|BP, 84
    373  09e5		       82 57		      .byte.b	BLACK|BP, 87
    374  09e7		       82 53		      .byte.b	BLACK|BP, 83
    375  09e9		       82 58		      .byte.b	BLACK|BP, 88
    376  09eb		       82 52		      .byte.b	BLACK|BP, 82
    377  09ed		       82 59		      .byte.b	BLACK|BP, 89
    378  09ef
    379  09ef		       87 60		      .byte.b	BLACK|K, 96
    380  09f1
    381  09f1		       00		      .byte.b	0	;end
    382  09f2
    383  09f2				  -	      ELSE		; test position...
    384  09f2				  -
    385  09f2				  -	      IF	0
    386  09f2				  -			; make sure illegal moves leaving K in check are removed
    387  09f2				  -
    388  09f2				  -	      .byte	WHITE|N, 28
    389  09f2				  -	      .byte	WHITE|K, 26
    390  09f2				  -
    391  09f2				  -	      .byte	BLACK|Q, 29
    392  09f2				  -
    393  09f2				  -	      .byte	0	;end
    394  09f2				  -
    395  09f2				  -	      ENDIF
    396  09f2				  -
    397  09f2				  -	      IF	0
    398  09f2				  -
    399  09f2				  -	      .byte	WHITE|K, 28
    400  09f2				  -	      .byte	WHITE|WP, 37
    401  09f2				  -	      .byte	WHITE|WP, 38
    402  09f2				  -	      .byte	WHITE|WP, 53
    403  09f2				  -	      .byte	WHITE|WP, 49
    404  09f2				  -	      .byte	WHITE|WP, 32
    405  09f2				  -	      .byte	WHITE|R, 27
    406  09f2				  -	      .byte	WHITE|B, 46
    407  09f2				  -	      .byte	WHITE|R, 54
    408  09f2				  -
    409  09f2				  -	      .byte	BLACK|BP, 56
    410  09f2				  -	      .byte	BLACK|BP, 87
    411  09f2				  -	      .byte	BLACK|BP, 88
    412  09f2				  -	      .byte	BLACK|BP, 89
    413  09f2				  -	      .byte	BLACK|BP, 84
    414  09f2				  -	      .byte	BLACK|B, 66
    415  09f2				  -	      .byte	BLACK|R, 69
    416  09f2				  -	      .byte	BLACK|K, 98
    417  09f2				  -
    418  09f2				  -	      .byte	BLACK|R, 92
    419  09f2				  -
    420  09f2				  -
    421  09f2				  -
    422  09f2				  -	      ENDIF
    423  09f2				  -
    424  09f2				  -	      IF	TEST_POSITION & 0
    425  09f2				  -			; Castling across/into check
    426  09f2				  -			; pawn promotion
    427  09f2				  -
    428  09f2				  -	      .byte	WHITE|K, 26
    429  09f2				  -	      .byte	WHITE|R, 29
    430  09f2				  -	      .byte	BLACK|B, 45
    431  09f2				  -	      .byte	WHITE|Q, 72
    432  09f2				  -	      .byte	BLACK|N, 84
    433  09f2				  -	      .byte	WHITE|WP,89
    434  09f2				  -
    435  09f2				  -	      ENDIF
    436  09f2				  -
    437  09f2				  -
    438  09f2				  -
    439  09f2				  -	      IF	TEST_POSITION & 0
    440  09f2				  -			; En passant test
    441  09f2				  -
    442  09f2				  -	      .byte	BLACK|BP, 88
    443  09f2				  -	      .byte	BLACK|BP, 86
    444  09f2				  -
    445  09f2				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    446  09f2				  -	      .byte	WHITE|K, 52
    447  09f2				  -
    448  09f2				  -
    449  09f2				  -	      ENDIF
    450  09f2				  -
    451  09f2				  -	      IF	TEST_POSITION & 1
    452  09f2				  -			; En passant test (white)
    453  09f2				  -
    454  09f2				  -	      .byte	BLACK|BP|FLAG_MOVED, 53
    455  09f2				  -
    456  09f2				  -	      .byte	WHITE|WP, 34
    457  09f2				  -	      .byte	WHITE|K, 52
    458  09f2				  -
    459  09f2				  -
    460  09f2				  -	      .byte	BLACK|BP, 88
    461  09f2				  -	      .byte	WHITE|WP|FLAG_MOVED, 67
    462  09f2				  -
    463  09f2				  -
    464  09f2				  -	      ENDIF
    465  09f2				  -
    466  09f2				  -
    467  09f2				  -	      IF	TEST_POSITION & 0
    468  09f2				  -			; castle
    469  09f2				  -
    470  09f2				  -	      .byte	BLACK|R, 99
    471  09f2				  -	      .byte	BLACK|K, 96
    472  09f2				  -	      .byte	BLACK|BP, 89
    473  09f2				  -	      .byte	BLACK|BP, 88
    474  09f2				  -
    475  09f2				  -			;.byte WHITE|WP, 37
    476  09f2				  -			;.byte WHITE|WP, 38
    477  09f2				  -			;.byte WHITE|WP, 39
    478  09f2				  -	      .byte	WHITE|R,29
    479  09f2				  -	      .byte	WHITE|K, 26
    480  09f2				  -
    481  09f2				  -	      ENDIF
    482  09f2				  -
    483  09f2				  -
    484  09f2				  -	      IF	TEST_POSITION & 0
    485  09f2				  -			; mate/draw
    486  09f2				  -
    487  09f2				  -	      .byte	BLACK|K, 99
    488  09f2				  -
    489  09f2				  -	      .byte	WHITE|Q,78
    490  09f2				  -	      .byte	WHITE|K, 79
    491  09f2				  -
    492  09f2				  -	      ENDIF
    493  09f2				  -
    494  09f2				  -
    495  09f2				  -	      IF	TEST_POSITION & 0
    496  09f2				  -			; promote test
    497  09f2				  -
    498  09f2				  -	      .byte	BLACK|K, 22
    499  09f2				  -	      .byte	BLACK|N, 96
    500  09f2				  -
    501  09f2				  -	      .byte	WHITE|WP, 87
    502  09f2				  -	      .byte	WHITE|R,95
    503  09f2				  -	      .byte	WHITE|R,94
    504  09f2				  -	      .byte	WHITE|K, 52
    505  09f2				  -
    506  09f2				  -
    507  09f2				  -	      ENDIF
    508  09f2				  -
    509  09f2				  -
    510  09f2				  -
    511  09f2				  -	      IF	0
    512  09f2				  -
    513  09f2				  -
    514  09f2				  -			;.byte BLACK|R, 97
    515  09f2				  -	      .byte	BLACK|K, 98
    516  09f2				  -	      .byte	BLACK|BP, 87
    517  09f2				  -	      .byte	BLACK|BP, 88
    518  09f2				  -	      .byte	BLACK|BP, 89
    519  09f2				  -			;    .byte BLACK|B, 76
    520  09f2				  -
    521  09f2				  -
    522  09f2				  -	      .byte	WHITE|R,28
    523  09f2				  -	      .byte	WHITE|Q,58
    524  09f2				  -			;   .byte WHITE|N,65
    525  09f2				  -	      ENDIF
    526  09f2				  -
    527  09f2				  -	      IF	0
    528  09f2				  -			;.byte WHITE|WP, 56
    529  09f2				  -
    530  09f2				  -
    531  09f2				  -	      .byte	BLACK|K, 98
    532  09f2				  -
    533  09f2				  -
    534  09f2				  -	      .byte	WHITE|R,29
    535  09f2				  -	      .byte	WHITE|Q,49
    536  09f2				  -	      .byte	WHITE|N,65
    537  09f2				  -	      ENDIF
    538  09f2				  -	      .byte	0	;end
    539  09f2				  -
    540  09f2					      ENDIF
    541  09f2
    542  09f2
    543  09f2							;---------------------------------------------------------------------------------------------------
    544  09f2
    545  09f2				  -	      IF	0
    546  09f2				  -	      DEF	AddMoveSimple
    547  09f2				  -	      SUBROUTINE
    548  09f2				  -
    549  09f2				  -	      REF	MoveVAR
    550  09f2				  -	      VEND	AddMoveSimple
    551  09f2				  -
    552  09f2				  -			; add square in y register to movelist as destination (X12 format)
    553  09f2				  -			; [y]		     to square (X12)
    554  09f2				  -			; currentSquare     from square (X12)
    555  09f2				  -			; currentPiece      piece.
    556  09f2				  -			;   ENPASSANT flag set if pawn double-moving off opening rank
    557  09f2				  -			; capture	     captured piece
    558  09f2				  -
    559  09f2				  -	      lda	__capture
    560  09f2				  -	      bne	.always
    561  09f2				  -	      lda	__quiesceCapOnly
    562  09f2				  -	      bne	.abort
    563  09f2				  -
    564  09f2				  -.always    tya
    565  09f2				  -
    566  09f2				  -	      ldy@PLY	moveIndex
    567  09f2				  -	      iny
    568  09f2				  -	      sty@PLY	moveIndex
    569  09f2				  -
    570  09f2				  -	      sta@PLY	MoveTo,y
    571  09f2				  -	      lda	currentSquare
    572  09f2				  -	      sta@PLY	MoveFrom,y
    573  09f2				  -	      lda	currentPiece
    574  09f2				  -	      sta@PLY	MovePiece,y
    575  09f2				  -	      lda	__capture
    576  09f2				  -	      sta@PLY	MoveCapture,y
    577  09f2				  -
    578  09f2				  -.abort     rts
    579  09f2					      ENDIF
    580  09f2
    581  09f2
    582  09f2							;---------------------------------------------------------------------------------------------------
    583  09f2
      0  09f2					      DEF	aiSpecialMoveFixup
      1  09f2				   SLOT_aiSpecialMoveFixup SET	_BANK_SLOT
      2  09f2				   BANK_aiSpecialMoveFixup SET	SLOT_aiSpecialMoveFixup + _CURRENT_BANK
      3  09f2				   aiSpecialMoveFixup
      4  09f2				   TEMPORARY_VAR SET	Overlay
      5  09f2				   TEMPORARY_OFFSET SET	0
      6  09f2				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      7  09f2				   FUNCTION_NAME SET	aiSpecialMoveFixup
    585  09f2					      SUBROUTINE
    586  09f2
      0  09f2					      REF	COMMON_VARS
      1  09f2					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  09f2				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  09f2					      ENDIF
      0  09f2					      REF	AiStateMachine	;✅
      1  09f2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  09f2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  09f2					      ENDIF
      0  09f2					      VEND	aiSpecialMoveFixup
      1  09f2
      2  09f2
      3  09f2		       00 b6	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
      4  09f2
    590  09f2
    591  09f2		       ad 84 02 	      lda	INTIM
    592  09f5		       c9 2d		      cmp	#SPEEDOF_CopySinglePiece+4
    593  09f7		       b0 01		      bcs	.cont
    594  09f9		       60		      rts
    595  09fa
    596  09fa
    597  09fa				   .cont
    598  09fa
      0  09fa					      PHASE	DelayAfterPlaced
      1  09fa		       a9 27		      lda	#AI_DelayAfterPlaced
      2  09fc		       85 8c		      sta	aiState
    600  09fe
    601  09fe
    602  09fe							; Special move fixup
    603  09fe
    604  09fe		       a5 95		      lda	currentPly
    605  0a00		       85 3e		      sta	SET_BANK_RAM
    606  0a02
    607  0a02		       20 33 f6 	      jsr	CastleFixupDraw
    608  0a05
    609  0a05		       a5 86		      lda	fromX12
    610  0a07		       85 81		      sta	squareToDraw
    611  0a09
    612  0a09		       60		      rts
    613  0a0a
    614  0a0a
    615  0a0a							;---------------------------------------------------------------------------------------------------
    616  0a0a
      0  0a0a					      DEF	aiEPFlash
      1  0a0a				   SLOT_aiEPFlash SET	_BANK_SLOT
      2  0a0a				   BANK_aiEPFlash SET	SLOT_aiEPFlash + _CURRENT_BANK
      3  0a0a				   aiEPFlash
      4  0a0a				   TEMPORARY_VAR SET	Overlay
      5  0a0a				   TEMPORARY_OFFSET SET	0
      6  0a0a				   VAR_BOUNDARY_aiEPFlash SET	TEMPORARY_OFFSET
      7  0a0a				   FUNCTION_NAME SET	aiEPFlash
    618  0a0a					      SUBROUTINE
    619  0a0a
      0  0a0a					      REF	Variable_PieceShapeBuffer
      1  0a0a					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0a0a				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0a0a					      ENDIF
      0  0a0a					      REF	AiStateMachine
      1  0a0a				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a0a				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a0a					      ENDIF
      0  0a0a					      VEND	aiEPFlash
      1  0a0a
      2  0a0a
      3  0a0a		       00 ee	   VAREND_aiEPFlash =	TEMPORARY_VAR
      4  0a0a
    623  0a0a
    624  0a0a		       a5 83		      lda	drawDelay
    625  0a0c		       f0 03		      beq	.deCount
    626  0a0e		       c6 83		      dec	drawDelay
    627  0a10		       60		      rts
    628  0a11
    629  0a11		       a5 85	   .deCount   lda	drawCount
    630  0a13		       f0 0e		      beq	.flashDone2
    631  0a15		       c6 85		      dec	drawCount
    632  0a17
    633  0a17		       a9 0a		      lda	#10
    634  0a19		       85 83		      sta	drawDelay	; "getting ready to move" flash
    635  0a1b
    636  0a1b		       a5 94		      lda	enPassantPawn
    637  0a1d		       85 81		      sta	squareToDraw
    638  0a1f
    639  0a1f							; WARNING - local variables will not survive the following call...!
    640  0a1f		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    641  0a22		       60		      rts
    642  0a23
    643  0a23				   .flashDone2
    644  0a23
    645  0a23
    646  0a23		       a9 00		      lda	#0	; on/off count
    647  0a25		       85 85		      sta	drawCount	; flashing for piece about to move
    648  0a27		       a9 00		      lda	#0
    649  0a29		       85 83		      sta	drawDelay
    650  0a2b
    651  0a2b		       20 b4 f3 	      jsr	EnPassantRemoveCapturedPawn
    652  0a2e
    653  0a2e							;lda #100
    654  0a2e							;sta aiFlashDelay ;???
    655  0a2e
      0  0a2e					      PHASE	FinalFlash
      1  0a2e		       a9 1b		      lda	#AI_FinalFlash
      2  0a30		       85 8c		      sta	aiState
    657  0a32		       60		      rts
    658  0a33
    659  0a33
    660  0a33							;---------------------------------------------------------------------------------------------------
    661  0a33
      0  0a33					      DEF	CastleFixupDraw
      1  0a33				   SLOT_CastleFixupDraw SET	_BANK_SLOT
      2  0a33				   BANK_CastleFixupDraw SET	SLOT_CastleFixupDraw + _CURRENT_BANK
      3  0a33				   CastleFixupDraw
      4  0a33				   TEMPORARY_VAR SET	Overlay
      5  0a33				   TEMPORARY_OFFSET SET	0
      6  0a33				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      7  0a33				   FUNCTION_NAME SET	CastleFixupDraw
    663  0a33					      SUBROUTINE
    664  0a33
      0  0a33					      REF	aiSpecialMoveFixup	;✅
      1  0a33					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0a33				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0a33					      ENDIF
      0  0a33					      VEND	CastleFixupDraw
      1  0a33
      2  0a33
      3  0a33		       00 b6	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
      4  0a33
    667  0a33
    668  0a33							; guarantee flags for piece, post-move, are correct
    669  0a33
    670  0a33
    671  0a33		       a9 d7		      lda	#RAMBANK_BOARD
    672  0a35		       85 3e		      sta	SET_BANK_RAM	;@2
    673  0a37
    674  0a37		       a5 97		      lda	fromPiece
    675  0a39		       29 df		      and	#~FLAG_ENPASSANT
    676  0a3b		       09 40		      ora	#FLAG_MOVED
    677  0a3d
    678  0a3d		       a4 86		      ldy	fromX12	; destination
      0  0a3f					      sta@RAM	Board,y
      1  0a3f		       99 79 fe 	      sta	[RAM]+Board,y
    680  0a42
    681  0a42
    682  0a42							; fixup any castling issues
    683  0a42							; at this point the king has finished his two-square march
    684  0a42							; based on the finish square, we determine which rook we're interacting with
    685  0a42							; and generate a 'move' for the rook to position on the other side of the king
    686  0a42
    687  0a42
    688  0a42					      IF	CASTLING_ENABLED
      0  0a42					      CALL	GenCastleMoveForRook	;@3
      1  0a42				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  0a42				  -FNAME      SETSTR	GenCastleMoveForRook
      3  0a42				  -	      ECHO	""
      4  0a42				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0a42				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0a42				  -	      ERR
      7  0a42					      ENDIF
      8  0a42		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      9  0a44		       85 3f		      sta	SET_BANK
     10  0a46		       20 22 fc 	      jsr	GenCastleMoveForRook
    690  0a49		       b0 07		      bcs	.phase
    691  0a4b					      ENDIF
    692  0a4b
      0  0a4b					      SWAP
      1  0a4b
      2  0a4b		       a5 96		      lda	sideToMove
      3  0a4d		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  0a4f		       85 96		      sta	sideToMove
      5  0a51
    694  0a51		       60		      rts
    695  0a52
    696  0a52				   .phase
    697  0a52
    698  0a52							; in this siutation (castle, rook moving) we do not change sides yet!
    699  0a52
      0  0a52					      PHASE	MoveIsSelected
      1  0a52		       a9 14		      lda	#AI_MoveIsSelected
      2  0a54		       85 8c		      sta	aiState
    701  0a56		       60		      rts
    702  0a57
    703  0a57
    704  0a57							;---------------------------------------------------------------------------------------------------
    705  0a57
      0  0a57					      DEF	aiDrawEntireBoard
      1  0a57				   SLOT_aiDrawEntireBoard SET	_BANK_SLOT
      2  0a57				   BANK_aiDrawEntireBoard SET	SLOT_aiDrawEntireBoard + _CURRENT_BANK
      3  0a57				   aiDrawEntireBoard
      4  0a57				   TEMPORARY_VAR SET	Overlay
      5  0a57				   TEMPORARY_OFFSET SET	0
      6  0a57				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      7  0a57				   FUNCTION_NAME SET	aiDrawEntireBoard
    707  0a57					      SUBROUTINE
    708  0a57
      0  0a57					      REF	Variable_PieceShapeBuffer
      1  0a57					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0a57				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0a57					      ENDIF
      0  0a57					      REF	AiStateMachine	;✅
      1  0a57				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a57				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a57					      ENDIF
    711  0a57
      0  0a57					      VEND	aiDrawEntireBoard
      1  0a57
      2  0a57
      3  0a57		       00 ee	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
      4  0a57
    713  0a57
    714  0a57
    715  0a57		       ad 84 02 	      lda	INTIM
    716  0a5a		       c9 2d		      cmp	#SPEEDOF_CopySinglePiece+4
    717  0a5c		       90 2c		      bcc	.exit
    718  0a5e
    719  0a5e							; We use [SLOT3] for accessing board
    720  0a5e
    721  0a5e		       a9 d7		      lda	#RAMBANK_BOARD
    722  0a60		       85 3e		      sta	SET_BANK_RAM
    723  0a62		       a4 81		      ldy	squareToDraw
    724  0a64		       b9 15 fc 	      lda	ValidSquare,y
    725  0a67		       30 1d		      bmi	.isablank2
    726  0a69
    727  0a69		       b9 79 fc 	      lda	Board,y
    728  0a6c		       f0 13		      beq	.isablank
    729  0a6e		       48		      pha
    730  0a6f		       a9 00		      lda	#BLANK
      0  0a71					      sta@RAM	Board,y
      1  0a71		       99 79 fe 	      sta	[RAM]+Board,y
    732  0a74
    733  0a74							; WARNING - local variables will not survive the following call...!
    734  0a74		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    735  0a77
    736  0a77		       a9 d7		      lda	#RAMBANK_BOARD
    737  0a79		       85 3e		      sta	SET_BANK_RAM
    738  0a7b
    739  0a7b		       a4 81		      ldy	squareToDraw
    740  0a7d		       68		      pla
      0  0a7e					      sta@RAM	Board,y
      1  0a7e		       99 79 fe 	      sta	[RAM]+Board,y
    742  0a81
      0  0a81				   .isablank  PHASE	DrawPart2
      1  0a81		       a9 10		      lda	#AI_DrawPart2
      2  0a83		       85 8c		      sta	aiState
    744  0a85		       60		      rts
    745  0a86
      0  0a86				   .isablank2 PHASE	DrawPart3
      1  0a86		       a9 11		      lda	#AI_DrawPart3
      2  0a88		       85 8c		      sta	aiState
    747  0a8a		       60	   .exit      rts
    748  0a8b
    749  0a8b
    750  0a8b							;---------------------------------------------------------------------------------------------------
    751  0a8b
      0  0a8b					      DEF	aiDrawPart2
      1  0a8b				   SLOT_aiDrawPart2 SET	_BANK_SLOT
      2  0a8b				   BANK_aiDrawPart2 SET	SLOT_aiDrawPart2 + _CURRENT_BANK
      3  0a8b				   aiDrawPart2
      4  0a8b				   TEMPORARY_VAR SET	Overlay
      5  0a8b				   TEMPORARY_OFFSET SET	0
      6  0a8b				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      7  0a8b				   FUNCTION_NAME SET	aiDrawPart2
    753  0a8b					      SUBROUTINE
    754  0a8b
      0  0a8b					      REF	Variable_PieceShapeBuffer
      1  0a8b					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0a8b				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0a8b					      ENDIF
      0  0a8b					      REF	AiStateMachine
      1  0a8b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0a8b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0a8b					      ENDIF
      0  0a8b					      VEND	aiDrawPart2
      1  0a8b
      2  0a8b
      3  0a8b		       00 ee	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
      4  0a8b
    758  0a8b
    759  0a8b							; WARNING - local variables will not survive the following call...!
    760  0a8b		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    761  0a8e
      0  0a8e					      DEF	aiDrawPart3
      1  0a8e				   SLOT_aiDrawPart3 SET	_BANK_SLOT
      2  0a8e				   BANK_aiDrawPart3 SET	SLOT_aiDrawPart3 + _CURRENT_BANK
      3  0a8e				   aiDrawPart3
      4  0a8e				   TEMPORARY_VAR SET	Overlay
      5  0a8e				   TEMPORARY_OFFSET SET	0
      6  0a8e				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      7  0a8e				   FUNCTION_NAME SET	aiDrawPart3
    763  0a8e					      SUBROUTINE
    764  0a8e
    765  0a8e		       c6 81		      dec	squareToDraw
    766  0a90		       a5 81		      lda	squareToDraw
    767  0a92		       c9 16		      cmp	#22
    768  0a94		       90 05		      bcc	.comp
    769  0a96
      0  0a96					      PHASE	DrawEntireBoard
      1  0a96		       a9 0f		      lda	#AI_DrawEntireBoard
      2  0a98		       85 8c		      sta	aiState
    771  0a9a		       60		      rts
    772  0a9b
    773  0a9b				   .comp
    774  0a9b
    775  0a9b		       a9 ff		      lda	#-1
    776  0a9d		       85 87		      sta	toX12	; becomes startup flash square
    777  0a9f		       a9 24		      lda	#36	; becomes cursor position
    778  0aa1		       85 88		      sta	originX12
    779  0aa3
    780  0aa3
      0  0aa3					      PHASE	GenerateMoves
      1  0aa3		       a9 12		      lda	#AI_GenerateMoves
      2  0aa5		       85 8c		      sta	aiState
    782  0aa7		       60		      rts
    783  0aa8
    784  0aa8
    785  0aa8							;---------------------------------------------------------------------------------------------------
    786  0aa8
      0  0aa8					      DEF	aiMarchB
      1  0aa8				   SLOT_aiMarchB SET	_BANK_SLOT
      2  0aa8				   BANK_aiMarchB SET	SLOT_aiMarchB + _CURRENT_BANK
      3  0aa8				   aiMarchB
      4  0aa8				   TEMPORARY_VAR SET	Overlay
      5  0aa8				   TEMPORARY_OFFSET SET	0
      6  0aa8				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      7  0aa8				   FUNCTION_NAME SET	aiMarchB
    788  0aa8					      SUBROUTINE
    789  0aa8
      0  0aa8					      REF	Variable_PieceShapeBuffer
      1  0aa8					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  0aa8				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  0aa8					      ENDIF
      0  0aa8					      REF	AiStateMachine
      1  0aa8				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0aa8				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0aa8					      ENDIF
      0  0aa8					      VEND	aiMarchB
      1  0aa8
      2  0aa8
      3  0aa8		       00 ee	   VAREND_aiMarchB =	TEMPORARY_VAR
      4  0aa8
    793  0aa8
    794  0aa8							; Draw the piece in the new square
    795  0aa8
    796  0aa8		       a5 86		      lda	fromX12
    797  0aaa		       85 81		      sta	squareToDraw
    798  0aac
    799  0aac							; WARNING - local variables will not survive the following call...!
    800  0aac		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; draw the moving piece into the new square
    801  0aaf
    802  0aaf		       a9 02		      lda	#2	; snail trail delay
    803  0ab1		       85 83		      sta	drawDelay
    804  0ab3
      0  0ab3					      PHASE	MarchToTargetB
      1  0ab3		       a9 19		      lda	#AI_MarchToTargetB
      2  0ab5		       85 8c		      sta	aiState
    806  0ab7		       60		      rts
    807  0ab8
    808  0ab8
    809  0ab8							;---------------------------------------------------------------------------------------------------
    810  0ab8
      0  0ab8					      DEF	aiDraw
      1  0ab8				   SLOT_aiDraw SET	_BANK_SLOT
      2  0ab8				   BANK_aiDraw SET	SLOT_aiDraw + _CURRENT_BANK
      3  0ab8				   aiDraw
      4  0ab8				   TEMPORARY_VAR SET	Overlay
      5  0ab8				   TEMPORARY_OFFSET SET	0
      6  0ab8				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      7  0ab8				   FUNCTION_NAME SET	aiDraw
    812  0ab8					      SUBROUTINE
    813  0ab8
    814  0ab8		       a6 a5		      ldx	platform
    815  0aba		       bd c0 f6 	      lda	colGreen,x
    816  0abd		       85 09		      sta	COLUBK
    817  0abf		       60		      rts
    818  0ac0
    819  0ac0				   colGreen
    820  0ac0		       c2 34		      .byte.b	$C2, $34
    821  0ac2
    822  0ac2							;---------------------------------------------------------------------------------------------------
    823  0ac2
      0  0ac2					      DEF	aiCheckMate
      1  0ac2				   SLOT_aiCheckMate SET	_BANK_SLOT
      2  0ac2				   BANK_aiCheckMate SET	SLOT_aiCheckMate + _CURRENT_BANK
      3  0ac2				   aiCheckMate
      4  0ac2				   TEMPORARY_VAR SET	Overlay
      5  0ac2				   TEMPORARY_OFFSET SET	0
      6  0ac2				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      7  0ac2				   FUNCTION_NAME SET	aiCheckMate
    825  0ac2					      SUBROUTINE
    826  0ac2		       a6 a5		      ldx	platform
    827  0ac4		       bd ca f6 	      lda	colRed,x
    828  0ac7		       85 09		      sta	COLUBK
    829  0ac9		       60		      rts
    830  0aca
    831  0aca				   colRed
    832  0aca		       42 64		      .byte.b	$42, $64
    833  0acc
    834  0acc							;---------------------------------------------------------------------------------------------------
    835  0acc
      0  0acc					      DEF	aiQuiescent
      1  0acc				   SLOT_aiQuiescent SET	_BANK_SLOT
      2  0acc				   BANK_aiQuiescent SET	SLOT_aiQuiescent + _CURRENT_BANK
      3  0acc				   aiQuiescent
      4  0acc				   TEMPORARY_VAR SET	Overlay
      5  0acc				   TEMPORARY_OFFSET SET	0
      6  0acc				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      7  0acc				   FUNCTION_NAME SET	aiQuiescent
    837  0acc					      SUBROUTINE
    838  0acc
      0  0acc					      REF	AiStateMachine
      1  0acc					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0acc				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0acc					      ENDIF
      0  0acc					      VEND	aiQuiescent
      1  0acc
      2  0acc
      3  0acc		       00 a8	   VAREND_aiQuiescent =	TEMPORARY_VAR
      4  0acc
    841  0acc
    842  0acc							; Move has been selected
    843  0acc
    844  0acc		       a9 ff		      lda	#-1
    845  0ace		       85 89		      sta	cursorX12
    846  0ad0
    847  0ad0		       a5 86		      lda	fromX12
    848  0ad2		       85 88		      sta	originX12
      0  0ad4					      CALL	GetPiece	;@3		    ; from the movelist
      1  0ad4				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  0ad4				  -FNAME      SETSTR	GetPiece
      3  0ad4				  -	      ECHO	""
      4  0ad4				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0ad4				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0ad4				  -	      ERR
      7  0ad4					      ENDIF
      8  0ad4		       a9 d9		      lda	#BANK_GetPiece
      9  0ad6		       85 3f		      sta	SET_BANK
     10  0ad8		       20 01 fc 	      jsr	GetPiece
    850  0adb
    851  0adb		       a4 86		      ldy	fromX12
    852  0add		       a9 d7		      lda	#RAMBANK_BOARD
    853  0adf		       85 3e		      sta	SET_BANK_RAM	;@3
    854  0ae1		       b9 79 fc 	      lda	Board,y
    855  0ae4		       45 97		      eor	fromPiece
    856  0ae6		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    857  0ae8		       d0 05		      bne	.promote	; promote a pawn
    858  0aea
      0  0aea					      PHASE	MoveIsSelected
      1  0aea		       a9 14		      lda	#AI_MoveIsSelected
      2  0aec		       85 8c		      sta	aiState
    860  0aee		       60		      rts
    861  0aef
      0  0aef				   .promote   PHASE	PromotePawnStart
      1  0aef		       a9 1f		      lda	#AI_PromotePawnStart
      2  0af1		       85 8c		      sta	aiState
    863  0af3		       60		      rts
    864  0af4
    865  0af4
    866  0af4							;---------------------------------------------------------------------------------------------------
    867  0af4
      0  0af4					      END_BANK
      1  0af4				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  0af4				  -	      CHECK_RAM_BANK_SIZE
      3  0af4					      ELSE
      0  0af4					      CHECK_BANK_SIZE
      1  0af4		       02 f4	   .TEMP      =	* - _BANK_START
 ROM bank # 3 ONE size = $2f4 free = 267
      2  0af4					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  0af4				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0af4				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  0af4				  -	      ERR
      6  0af4					      ENDIF
      5  0af4					      ENDIF
    869  0af4
    870  0af4							;---------------------------------------------------------------------------------------------------
    871  0af4							; EOF
------- FILE ./chess.asm
------- FILE @1 NEGAMAX.asm LEVEL 2 PASS 4
      0  0af4					      include	"@1 NEGAMAX.asm"
      1  0af4							;---------------------------------------------------------------------------------------------------
      2  0af4							; @1 NEGAMAX.asm
      3  0af4
      4  0af4							; Atari 2600 Chess
      5  0af4							; Copyright (c) 2019-2020 Andrew Davie
      6  0af4							; andrew@taswegian.com
      7  0af4
      8  0af4							;---------------------------------------------------------------------------------------------------
      9  0af4
      0  0af4					      SLOT	1
      1  0af4
      2  0af4				  -	      IF	(1 < 0) || (1 > 3)
      3  0af4				  -	      ECHO	"Illegal bank address/segment location", 1
      4  0af4				  -	      ERR
      5  0af4					      ENDIF
      6  0af4
      7  0af4				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  0af4				   _BANK_SLOT SET	1 * 64
      9  0af4
      0  0af4					      ROMBANK	NEGAMAX
      1  0fb9 ????				      SEG	ROM_NEGAMAX
      2  0c00					      ORG	_ORIGIN
      3  0c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  0c00				   _BANK_START SET	*
      5  0c00				   NEGAMAX_START SET	*
      6  0c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  0c00				   ROMBANK_NEGAMAX SET	_BANK_SLOT + _CURRENT_BANK
      8  0c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  0c00				   _LAST_BANK SETSTR	NEGAMAX
     10  0c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     12  0c00
     13  0c00
     14  0c00							;---------------------------------------------------------------------------------------------------
     15  0c00
      0  0c00					      DEF	aiComputerMove
      1  0c00				   SLOT_aiComputerMove SET	_BANK_SLOT
      2  0c00				   BANK_aiComputerMove SET	SLOT_aiComputerMove + _CURRENT_BANK
      3  0c00				   aiComputerMove
      4  0c00				   TEMPORARY_VAR SET	Overlay
      5  0c00				   TEMPORARY_OFFSET SET	0
      6  0c00				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      7  0c00				   FUNCTION_NAME SET	aiComputerMove
     17  0c00					      SUBROUTINE
     18  0c00
      0  0c00					      REF	AiStateMachine	;✅
      1  0c00					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0c00				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0c00					      ENDIF
      0  0c00					      VEND	aiComputerMove
      1  0c00
      2  0c00
      3  0c00		       00 a8	   VAREND_aiComputerMove =	TEMPORARY_VAR
      4  0c00
     21  0c00
     22  0c00							; Computer is about to select a move
     23  0c00
     24  0c00
     25  0c00		       a9 88		      lda	#RAMBANK_PLY
     26  0c02		       85 95		      sta	currentPly
     27  0c04		       85 3e		      sta	SET_BANK_RAM	;@2		 ; switch in movelist
     28  0c06
     29  0c06		       a9 01		      lda	#1
     30  0c08		       85 0a		      sta	CTRLPF	; mirroring for thinkbars
     31  0c0a
     32  0c0a		       20 3a f4 	      jsr	selectmove	;@this
     33  0c0d
     34  0c0d		       a9 00		      lda	#0
     35  0c0f		       85 0a		      sta	CTRLPF	; clear mirroring
     36  0c11		       85 0e		      sta	PF1
     37  0c13		       85 0f		      sta	PF2
     38  0c15
     39  0c15							; correct ply is already switched
     40  0c15
      0  0c15					      lda@PLY	bestMove
      1  0c15		       ad d1 f9 	      lda	bestMove
     42  0c18		       10 17		      bpl	.notComputer
     43  0c1a
     44  0c1a							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
     45  0c1a
      0  0c1a					      SWAP
      1  0c1a
      2  0c1a		       a5 96		      lda	sideToMove
      3  0c1c		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  0c1e		       85 96		      sta	sideToMove
      5  0c20
     47  0c20		       20 a6 f1 	      jsr	GenerateAllMoves	;@0
     48  0c23		       a5 a1		      lda	flagCheck
     49  0c25		       f0 05		      beq	.gameDrawn
     50  0c27
      0  0c27					      PHASE	CheckMate
      1  0c27		       a9 23		      lda	#AI_CheckMate
      2  0c29		       85 8c		      sta	aiState
     52  0c2b		       60		      rts
     53  0c2c
     54  0c2c
      0  0c2c				   .gameDrawn PHASE	Draw
      1  0c2c		       a9 24		      lda	#AI_Draw
      2  0c2e		       85 8c		      sta	aiState
     56  0c30		       60		      rts
     57  0c31
     58  0c31				   .notComputer
     59  0c31
     60  0c31
     61  0c31		       a9 ff		      lda	#-1
     62  0c33		       85 89		      sta	cursorX12
     63  0c35
      0  0c35					      PHASE	DelayAfterMove
      1  0c35		       a9 25		      lda	#AI_DelayAfterMove
      2  0c37		       85 8c		      sta	aiState
     65  0c39		       60	   .halted    rts
     66  0c3a
     67  0c3a
     68  0c3a							;---------------------------------------------------------------------------------------------------
     69  0c3a
      0  0c3a					      DEF	selectmove
      1  0c3a				   SLOT_selectmove SET	_BANK_SLOT
      2  0c3a				   BANK_selectmove SET	SLOT_selectmove + _CURRENT_BANK
      3  0c3a				   selectmove
      4  0c3a				   TEMPORARY_VAR SET	Overlay
      5  0c3a				   TEMPORARY_OFFSET SET	0
      6  0c3a				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      7  0c3a				   FUNCTION_NAME SET	selectmove
     71  0c3a					      SUBROUTINE
     72  0c3a
      0  0c3a					      REF	COMMON_VARS
      1  0c3a					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0c3a				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0c3a					      ENDIF
      0  0c3a					      REF	aiComputerMove	;✅
      1  0c3a				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  0c3a				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  0c3a					      ENDIF
      0  0c3a					      VEND	selectmove
      1  0c3a
      2  0c3a
      3  0c3a		       00 b6	   VAREND_selectmove =	TEMPORARY_VAR
      4  0c3a
     76  0c3a
     77  0c3a
     78  0c3a							; RAM bank already switched in!!!
     79  0c3a							; returns with RAM bank switched
     80  0c3a
     81  0c3a
     82  0c3a				  -	      IF	DIAGNOSTICS
     83  0c3a				  -
     84  0c3a				  -	      lda	#0
     85  0c3a				  -	      sta	positionCount
     86  0c3a				  -	      sta	positionCount+1
     87  0c3a				  -	      sta	positionCount+2
     88  0c3a				  -			;sta maxPly
     89  0c3a					      ENDIF
     90  0c3a
     91  0c3a		       a9 ff		      lda	#<INFINITY
     92  0c3c		       85 ab		      sta	__beta
     93  0c3e		       a9 7f		      lda	#>INFINITY
     94  0c40		       85 ac		      sta	__beta+1
     95  0c42
     96  0c42		       a9 01		      lda	#<-INFINITY
     97  0c44		       85 a9		      sta	__alpha
     98  0c46		       a9 80		      lda	#>-INFINITY
     99  0c48		       85 aa		      sta	__alpha+1	; player tries to maximise
    100  0c4a
    101  0c4a		       a2 04		      ldx	#SEARCH_DEPTH
    102  0c4c		       a9 00		      lda	#0	; no captured piece
    103  0c4e		       85 b1		      sta	__quiesceCapOnly	; ALL moves to be generated
    104  0c50
    105  0c50		       20 1d f5 	      jsr	negaMax
    106  0c53
    107  0c53
    108  0c53							;lda currentPly
    109  0c53							;sta SET_BANK_RAM ;tmp?
    110  0c53
    111  0c53
    112  0c53
    113  0c53
      0  0c53					      ldx@PLY	bestMove
      1  0c53		       ae d1 f9 	      ldx	bestMove
    115  0c56		       30 26		      bmi	.nomove
    116  0c58
    117  0c58							; Generate player's moves in reply
    118  0c58							; Make the computer move, list player moves (PLY+1), unmake computer move
    119  0c58
      0  0c58					      stx@PLY	movePtr
      1  0c58		       8e d0 fb 	      stx	[RAM]+movePtr
    121  0c5b		       20 7f f4 	      jsr	MakeMove	;@this
    122  0c5e		       20 50 f2 	      jsr	ListPlayerMoves	;@0
    123  0c61
    124  0c61		       c6 95		      dec	currentPly
    125  0c63		       20 ad f2 	      jsr	unmakeMove	;@0
    126  0c66
    127  0c66							; Grab the computer move details for the UI animation
    128  0c66
    129  0c66		       a9 88		      lda	#RAMBANK_PLY
    130  0c68		       85 3e		      sta	SET_BANK_RAM
    131  0c6a
      0  0c6a					      ldx@PLY	bestMove
      1  0c6a		       ae d1 f9 	      ldx	bestMove
      0  0c6d					      lda@PLY	MoveTo,x
      1  0c6d		       bd 64 f8 	      lda	MoveTo,x
    134  0c70		       85 87		      sta	toX12
      0  0c72					      lda@PLY	MoveFrom,x
      1  0c72		       bd 00 f8 	      lda	MoveFrom,x
    136  0c75		       85 88		      sta	originX12
    137  0c77		       85 86		      sta	fromX12
      0  0c79					      lda@PLY	MovePiece,x
      1  0c79		       bd 00 f9 	      lda	MovePiece,x
    139  0c7c		       85 97		      sta	fromPiece
    140  0c7e
    141  0c7e				   .nomove
    142  0c7e		       60		      rts
    143  0c7f
    144  0c7f
    145  0c7f							;---------------------------------------------------------------------------------------------------
    146  0c7f
      0  0c7f					      DEF	MakeMove
      1  0c7f				   SLOT_MakeMove SET	_BANK_SLOT
      2  0c7f				   BANK_MakeMove SET	SLOT_MakeMove + _CURRENT_BANK
      3  0c7f				   MakeMove
      4  0c7f				   TEMPORARY_VAR SET	Overlay
      5  0c7f				   TEMPORARY_OFFSET SET	0
      6  0c7f				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      7  0c7f				   FUNCTION_NAME SET	MakeMove
    148  0c7f					      SUBROUTINE
    149  0c7f
      0  0c7f					      REF	COMMON_VARS
      1  0c7f					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0c7f				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0c7f					      ENDIF
      0  0c7f					      REF	selectmove	;✅
      1  0c7f				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0c7f				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0c7f					      ENDIF
      0  0c7f					      REF	ListPlayerMoves	;✅
      1  0c7f				  -	      IF	VAREND_ListPlayerMoves > TEMPORARY_VAR
      2  0c7f				  -TEMPORARY_VAR SET	VAREND_ListPlayerMoves
      3  0c7f					      ENDIF
      0  0c7f					      REF	quiesce	;✅
      1  0c7f					      IF	VAREND_quiesce > TEMPORARY_VAR
      2  0c7f				   TEMPORARY_VAR SET	VAREND_quiesce
      3  0c7f					      ENDIF
      0  0c7f					      REF	negaMax	;✅
      1  0c7f				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0c7f				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  0c7f					      ENDIF
      0  0c7f					      VEND	MakeMove
      1  0c7f
      2  0c7f
      3  0c7f		       00 b8	   VAREND_MakeMove =	TEMPORARY_VAR
      4  0c7f
    156  0c7f
    157  0c7f							; Do a move without any GUI stuff
    158  0c7f							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    159  0c7f							; and all relevant flags in original state. This is NOT used for the visible move on the
    160  0c7f							; screen.
    161  0c7f
    162  0c7f
    163  0c7f							; fromPiece	 piece doing the move
    164  0c7f							; fromX12	 current square X12
    165  0c7f							; originX12	 starting square X12
    166  0c7f							; toX12	 ending square X12
    167  0c7f
    168  0c7f							; BANK:SLOT2 = currentPly
    169  0c7f
    170  0c7f
    171  0c7f							; There are potentially "two" moves, with the following
    172  0c7f							; a) Castling, moving both rook and king
    173  0c7f							; b) en-Passant, capturing pawn on "odd" square
    174  0c7f							; These both set "secondary" movers which are used for restoring during unmakeMove
    175  0c7f
    176  0c7f		       a0 d7		      ldy	#RAMBANK_BOARD
    177  0c81		       84 3e		      sty	SET_BANK_RAM	;@3
    178  0c83
      0  0c83					      ldx@PLY	movePtr
      1  0c83		       ae d0 f9 	      ldx	movePtr
      0  0c86					      ldy@PLY	MoveFrom,x
      1  0c86		       bc 00 f8 	      ldy	MoveFrom,x
    181  0c89		       84 86		      sty	fromX12
    182  0c8b		       84 88		      sty	originX12
    183  0c8d
      0  0c8d					      lda@RAM	Board,y
      1  0c8d		       b9 79 fc 	      lda	Board,y
    185  0c90		       85 b2		      sta	__originalPiece
      0  0c92					      sta@PLY	restorePiece
      1  0c92		       8d d9 fb 	      sta	[RAM]+restorePiece
    187  0c95
    188  0c95		       a9 00		      lda	#0
      0  0c97					      sta@RAM	Board,y
      1  0c97		       99 79 fe 	      sta	[RAM]+Board,y
      0  0c9a					      sta@PLY	secondaryPiece
      1  0c9a		       8d cc fb 	      sta	[RAM]+secondaryPiece
    191  0c9d
    192  0c9d		       85 a3		      sta	vkSquare
    193  0c9f		       85 a4		      sta	vkSquare+1
    194  0ca1
      0  0ca1					      ldy@PLY	MoveTo,x
      1  0ca1		       bc 64 f8 	      ldy	MoveTo,x
    196  0ca4		       84 87		      sty	toX12
    197  0ca6
      0  0ca6					      lda@RAM	Board,y
      1  0ca6		       b9 79 fc 	      lda	Board,y
    199  0ca9		       85 b3		      sta	__capturedPiece
      0  0cab					      sta@PLY	capturedPiece
      1  0cab		       8d cb fb 	      sta	[RAM]+capturedPiece
    201  0cae
      0  0cae					      lda@PLY	MovePiece,x
      1  0cae		       bd 00 f9 	      lda	MovePiece,x
    203  0cb1		       85 97		      sta	fromPiece
    204  0cb3
    205  0cb3		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
    206  0cb5		       09 40		      ora	#FLAG_MOVED
      0  0cb7					      sta@RAM	Board,y
      1  0cb7		       99 79 fe 	      sta	[RAM]+Board,y
    208  0cba
    209  0cba
      0  0cba				   .move      CALL	AdjustMaterialPositionalValue	;@2
      1  0cba				  -	      IF	SLOT_AdjustMaterialPositionalValue == _BANK_SLOT
      2  0cba				  -FNAME      SETSTR	AdjustMaterialPositionalValue
      3  0cba				  -	      ECHO	""
      4  0cba				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0cba				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0cba				  -	      ERR
      7  0cba					      ENDIF
      8  0cba		       a9 89		      lda	#BANK_AdjustMaterialPositionalValue
      9  0cbc		       85 3f		      sta	SET_BANK
     10  0cbe		       20 ea f8 	      jsr	AdjustMaterialPositionalValue
    211  0cc1
    212  0cc1
    213  0cc1					      IF	CASTLING_ENABLED
    214  0cc1
    215  0cc1							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
    216  0cc1							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
    217  0cc1							; redo the moving code (for the rook, this time).
    218  0cc1
    219  0cc1							; Set the squares that need to be checked for "virtual check" - preventing the king
    220  0cc1							; from castling from/across check.
    221  0cc1
    222  0cc1		       a5 97		      lda	fromPiece
    223  0cc3		       29 17		      and	#FLAG_CASTLE|KING
    224  0cc5		       c9 17		      cmp	#FLAG_CASTLE|KING
    225  0cc7		       d0 13		      bne	.exit	; NOT involved in castle!
    226  0cc9
    227  0cc9							; Must be a king, castling. Calculate the virtual squares which need to be checked for
    228  0cc9							; invalid castling. Prevents moving in/across check.
    229  0cc9
    230  0cc9		       18		      clc
    231  0cca		       a5 88		      lda	originX12
    232  0ccc		       85 a4		      sta	vkSquare+1	; king origin
    233  0cce		       65 87		      adc	toX12
    234  0cd0		       4a		      lsr
    235  0cd1		       85 a3		      sta	vkSquare	; intermediate square
    236  0cd3
    237  0cd3
    238  0cd3							; Now generate a new move for the rook
    239  0cd3
      0  0cd3					      CALL	GenCastleMoveForRook	;@3
      1  0cd3				  -	      IF	SLOT_GenCastleMoveForRook == _BANK_SLOT
      2  0cd3				  -FNAME      SETSTR	GenCastleMoveForRook
      3  0cd3				  -	      ECHO	""
      4  0cd3				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0cd3				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0cd3				  -	      ERR
      7  0cd3					      ENDIF
      8  0cd3		       a9 d9		      lda	#BANK_GenCastleMoveForRook
      9  0cd5		       85 3f		      sta	SET_BANK
     10  0cd7		       20 22 fc 	      jsr	GenCastleMoveForRook
    241  0cda		       b0 de		      bcs	.move	; move the rook!
    242  0cdc
    243  0cdc				   .exit
    244  0cdc					      ENDIF
    245  0cdc
    246  0cdc
    247  0cdc					      IF	ENPASSANT_ENABLED
    248  0cdc
      0  0cdc					      CALL	EnPassantFixupDraw	; generate enPassantPawn value
      1  0cdc				  -	      IF	SLOT_EnPassantFixupDraw == _BANK_SLOT
      2  0cdc				  -FNAME      SETSTR	EnPassantFixupDraw
      3  0cdc				  -	      ECHO	""
      4  0cdc				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  0cdc				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  0cdc				  -	      ERR
      7  0cdc					      ENDIF
      8  0cdc		       a9 89		      lda	#BANK_EnPassantFixupDraw
      9  0cde		       85 3f		      sta	SET_BANK
     10  0ce0		       20 80 f8 	      jsr	EnPassantFixupDraw
    250  0ce3							;CALL EnPassantRemoveCapturedPawn
    251  0ce3
    252  0ce3					      ENDIF
    253  0ce3
    254  0ce3
    255  0ce3							; Swap over sides
    256  0ce3
      0  0ce3					      NEGEVAL
      1  0ce3
      2  0ce3		       38		      sec
      3  0ce4		       a9 00		      lda	#0
      4  0ce6		       e5 90		      sbc	Evaluation
      5  0ce8		       85 90		      sta	Evaluation
      6  0cea		       a9 00		      lda	#0
      7  0cec		       e5 91		      sbc	Evaluation+1
      8  0cee		       85 91		      sta	Evaluation+1
      9  0cf0
      0  0cf0					      SWAP
      1  0cf0
      2  0cf0		       a5 96		      lda	sideToMove
      3  0cf2		       49 c0		      eor	#SWAP_SIDE|HUMAN
      4  0cf4		       85 96		      sta	sideToMove
      5  0cf6
    259  0cf6
    260  0cf6		       a5 95		      lda	currentPly
    261  0cf8		       85 3e		      sta	SET_BANK_RAM
    262  0cfa		       60		      rts
    263  0cfb
    264  0cfb
    265  0cfb							;---------------------------------------------------------------------------------------------------
    266  0cfb
    267  0cfb							;function negaMax(node, depth, α, β, color) is
    268  0cfb							;    if depth = 0 or node is a terminal node then
    269  0cfb							;	  return color × the heuristic value of node
    270  0cfb
    271  0cfb							;    childNodes := generateMoves(node)
    272  0cfb							;    childNodes := orderMoves(childNodes)
    273  0cfb							;    value := −∞
    274  0cfb							;    foreach child in childNodes do
    275  0cfb							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    276  0cfb							;	  α := max(α, value)
    277  0cfb							;	  if α ≥ β then
    278  0cfb							;	      break (* cut-off *)
    279  0cfb							;    return value
    280  0cfb							;(* Initial call for Player A's root node *)
    281  0cfb							;negaMax(rootNode, depth, −∞, +∞, 1)
    282  0cfb
    283  0cfb
    284  0cfb					      SUBROUTINE
    285  0cfb
    286  0cfb		       a9 ff	   .doQ       lda	#-1
    287  0cfd		       85 b1		      sta	__quiesceCapOnly
    288  0cff		       20 d2 f6 	      jsr	quiesce
    289  0d02		       e6 b1		      inc	__quiesceCapOnly
    290  0d04		       60		      rts
    291  0d05
    292  0d05
      0  0d05				   .exit      lda@PLY	value
      1  0d05		       ad d6 f9 	      lda	value
    294  0d08		       85 ad		      sta	__negaMax
      0  0d0a					      lda@PLY	value+1
      1  0d0a		       ad d7 f9 	      lda	value+1
    296  0d0d		       85 ae		      sta	__negaMax+1
    297  0d0f		       60		      rts
    298  0d10
    299  0d10
    300  0d10				   .terminal
    301  0d10
    302  0d10					      IF	QUIESCE_EXTRA_DEPTH > 0
    303  0d10		       c9 00		      cmp	#0	; captured piece
    304  0d12		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
    305  0d14					      ENDIF
    306  0d14
    307  0d14		       a5 90		      lda	Evaluation
    308  0d16		       85 ad		      sta	__negaMax
    309  0d18		       a5 91		      lda	Evaluation+1
    310  0d1a		       85 ae		      sta	__negaMax+1
    311  0d1c
    312  0d1c		       60	   .inCheck2  rts
    313  0d1d
    314  0d1d
    315  0d1d							;---------------------------------------------------------------------------------------------------
    316  0d1d
      0  0d1d					      DEF	negaMax
      1  0d1d				   SLOT_negaMax SET	_BANK_SLOT
      2  0d1d				   BANK_negaMax SET	SLOT_negaMax + _CURRENT_BANK
      3  0d1d				   negaMax
      4  0d1d				   TEMPORARY_VAR SET	Overlay
      5  0d1d				   TEMPORARY_OFFSET SET	0
      6  0d1d				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      7  0d1d				   FUNCTION_NAME SET	negaMax
    318  0d1d
    319  0d1d							; PARAMS depth-1, -beta, -alpha
    320  0d1d							; pased through temporary variables (__alpha, __beta) and X reg
    321  0d1d
    322  0d1d							; pass...
    323  0d1d							; x = depthleft
    324  0d1d							; a = captured piece
    325  0d1d							; SET_BANK_RAM      --> current ply
    326  0d1d							; __alpha[2] = param alpha
    327  0d1d							; __beta[2] = param beta
    328  0d1d
    329  0d1d
      0  0d1d					      REF	COMMON_VARS
      1  0d1d					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0d1d				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0d1d					      ENDIF
      0  0d1d					      REF	selectmove	;✅
      1  0d1d				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  0d1d				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  0d1d					      ENDIF
      0  0d1d					      VAR	ev2,2
      1  0d1d		       00 b6	   ev2	      =	TEMPORARY_VAR
      2  0d1d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  0d1d
      4  0d1d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0d1d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0d1d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0d1d					      ENDIF
      8  0d1d				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0d1d				  -VNAME      SETSTR	ev2
     10  0d1d				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0d1d				  -	      ERR
     12  0d1d					      ENDIF
      0  0d1d					      VEND	negaMax
      1  0d1d
      2  0d1d
      3  0d1d		       00 b8	   VAREND_negaMax =	TEMPORARY_VAR
      4  0d1d
    334  0d1d
    335  0d1d
    336  0d1d		       48		      pha
    337  0d1e
    338  0d1e		       20 81 f0 	      jsr	ThinkBar	;@0
    339  0d21
    340  0d21		       a5 95		      lda	currentPly
    341  0d23		       85 3e		      sta	SET_BANK_RAM	;@2
    342  0d25
    343  0d25		       68		      pla
    344  0d26		       ca		      dex
    345  0d27		       30 e7		      bmi	.terminal
      0  0d29					      stx@PLY	depthLeft
      1  0d29		       8e d8 fb 	      stx	[RAM]+depthLeft
    347  0d2c
    348  0d2c
    349  0d2c							; Allow the player to force computer to select a move. Press the SELECT switch
    350  0d2c
      0  0d2c					      lda@PLY	bestMove
      1  0d2c		       ad d1 f9 	      lda	bestMove
    352  0d2f		       30 07		      bmi	.noCheat	; can't force if no move chosen!
    353  0d31		       ad 82 02 	      lda	SWCHB
    354  0d34		       29 02		      and	#SELECT_SWITCH
    355  0d36		       f0 cd		      beq	.exit	; SELECT abort
    356  0d38				   .noCheat
    357  0d38
    358  0d38
      0  0d38					      NEXT_RANDOM
      1  0d38
      2  0d38		       a5 82		      lda	rnd
      3  0d3a		       4a		      lsr
      4  0d3b		       90 02		      bcc	.skipEOR
      5  0d3d		       49 b4		      eor	#RND_EOR_VAL
      6  0d3f		       85 82	   .skipEOR   sta	rnd
      7  0d41
    360  0d41		       25 a2		      and	randomness
    361  0d43		       65 90		      adc	Evaluation
    362  0d45		       85 90		      sta	Evaluation	; since it's random we don't care about HI
    363  0d47							;bcc .evOK
    364  0d47							;inc Evaluation+1
    365  0d47				   .evOK
    366  0d47
    367  0d47
    368  0d47		       a5 a9		      lda	__alpha
      0  0d49					      sta@PLY	alpha
      1  0d49		       8d d2 fb 	      sta	[RAM]+alpha
    370  0d4c		       a5 aa		      lda	__alpha+1
      0  0d4e					      sta@PLY	alpha+1
      1  0d4e		       8d d3 fb 	      sta	[RAM]+alpha+1
    372  0d51
    373  0d51		       a5 ab		      lda	__beta
      0  0d53					      sta@PLY	beta
      1  0d53		       8d d4 fb 	      sta	[RAM]+beta
    375  0d56		       a5 ac		      lda	__beta+1
      0  0d58					      sta@PLY	beta+1
      1  0d58		       8d d5 fb 	      sta	[RAM]+beta+1
    377  0d5b
    378  0d5b
    379  0d5b		       20 a6 f1 	      jsr	GenerateAllMoves	;@0
    380  0d5e
    381  0d5e		       a5 a1		      lda	flagCheck
    382  0d60		       d0 ba		      bne	.inCheck2	; OTHER guy in check
    383  0d62
    384  0d62							; add mobility to the score (for all moves). Will un-add on move revert
    385  0d62							; the 4x loop is to give weight to mobility :)
    386  0d62
    387  0d62					      IF	1
      0  0d62					      lda@PLY	moveIndex
      1  0d62		       ad cf f9 	      lda	moveIndex
    389  0d65		       c9 ff		      cmp	#$FF
    390  0d67		       f0 15		      beq	.nomoves
    391  0d69
    392  0d69		       a2 00		      ldx	#0
    393  0d6b		       86 b7		      stx	ev2+1
    394  0d6d
    395  0d6d				  -	      REPEAT	0
    396  0d6d				  -	      asl
    397  0d6d				  -	      rol	ev2+1
    398  0d6d					      REPEND
    399  0d6d
    400  0d6d		       18		      clc
    401  0d6e		       65 90		      adc	Evaluation
      0  0d70					      sta@PLY	savedEvaluation
      1  0d70		       8d c8 fb 	      sta	[RAM]+savedEvaluation
    403  0d73		       85 90		      sta	Evaluation
    404  0d75		       a5 91		      lda	Evaluation+1
    405  0d77		       65 b7		      adc	ev2+1
    406  0d79		       85 91		      sta	Evaluation+1
      0  0d7b					      sta@PLY	savedEvaluation+1
      1  0d7b		       8d c9 fb 	      sta	[RAM]+savedEvaluation+1
    408  0d7e
    409  0d7e				   .nomoves
    410  0d7e					      ENDIF
    411  0d7e
    412  0d7e
    413  0d7e							; Reurse?
    414  0d7e							; to smaller depth, then sort...
    415  0d7e
    416  0d7e							;ldx #2
    417  0d7e							;jsr negaMax
    418  0d7e							;jsr debug
    419  0d7e
    420  0d7e		       a9 01		      lda	#<-INFINITY
      0  0d80					      sta@PLY	value
      1  0d80		       8d d6 fb 	      sta	[RAM]+value
    422  0d83		       a9 80		      lda	#>-INFINITY
      0  0d85					      sta@PLY	value+1
      1  0d85		       8d d7 fb 	      sta	[RAM]+value+1
    424  0d88
      0  0d88					      ldx@PLY	moveIndex
      1  0d88		       ae cf f9 	      ldx	moveIndex
    426  0d8b		       10 03		      bpl	.forChild
    427  0d8d		       4c 05 f5 	      jmp	.exit
    428  0d90
      0  0d90				   .forChild  stx@PLY	movePtr
      1  0d90		       8e d0 fb 	      stx	[RAM]+movePtr
    430  0d93
    431  0d93		       20 ac f2 	      jsr	debug
    432  0d96		       20 7f f4 	      jsr	MakeMove	;@this
    433  0d99
    434  0d99
    435  0d99							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
    436  0d99
    437  0d99							; PARAMS depth-1, -beta, -alpha
    438  0d99							; pased through temporary variables (__alpha, __beta) and X reg
    439  0d99
    440  0d99		       38		      sec
    441  0d9a		       a9 00		      lda	#0
      0  0d9c					      sbc@PLY	beta
      1  0d9c		       ed d4 f9 	      sbc	beta
    443  0d9f		       85 a9		      sta	__alpha
    444  0da1		       a9 00		      lda	#0
      0  0da3					      sbc@PLY	beta+1
      1  0da3		       ed d5 f9 	      sbc	beta+1
    446  0da6		       85 aa		      sta	__alpha+1
    447  0da8
    448  0da8		       38		      sec
    449  0da9		       a9 00		      lda	#0
      0  0dab					      sbc@PLY	alpha
      1  0dab		       ed d2 f9 	      sbc	alpha
    451  0dae		       85 ab		      sta	__beta
    452  0db0		       a9 00		      lda	#0
      0  0db2					      sbc@PLY	alpha+1
      1  0db2		       ed d3 f9 	      sbc	alpha+1
    454  0db5		       85 ac		      sta	__beta+1
    455  0db7
    456  0db7
      0  0db7					      ldx@PLY	depthLeft
      1  0db7		       ae d8 f9 	      ldx	depthLeft
      0  0dba					      lda@PLY	capturedPiece
      1  0dba		       ad cb f9 	      lda	capturedPiece
    459  0dbd
    460  0dbd		       e6 95		      inc	currentPly
    461  0dbf		       a4 95		      ldy	currentPly
    462  0dc1		       84 3e		      sty	SET_BANK_RAM	; self-switch
    463  0dc3
    464  0dc3		       20 1d f5 	      jsr	negaMax	;@this
    465  0dc6
    466  0dc6		       c6 95		      dec	currentPly
    467  0dc8
    468  0dc8
    469  0dc8		       a5 95		      lda	currentPly
    470  0dca		       85 3e		      sta	SET_BANK_RAM
    471  0dcc
      0  0dcc					      ldx@PLY	movePtr
      1  0dcc		       ae d0 f9 	      ldx	movePtr
    473  0dcf
    474  0dcf		       18		      clc
    475  0dd0		       69 07		      adc	#RAMBANK_SORT-RAMBANK_PLY
    476  0dd2		       85 3e		      sta	SET_BANK_RAM
    477  0dd4
    478  0dd4		       a5 ad		      lda	__negaMax
      0  0dd6					      sta@RAM	MoveValueLO,x
      1  0dd6		       9d 00 fa 	      sta	[RAM]+MoveValueLO,x
    480  0dd9		       a5 ae		      lda	__negaMax+1
      0  0ddb					      sta@RAM	MoveValueHI,x
      1  0ddb		       9d 64 fa 	      sta	[RAM]+MoveValueHI,x
    482  0dde
    483  0dde		       20 ad f2 	      jsr	unmakeMove	;@0
    484  0de1
    485  0de1		       a5 95		      lda	currentPly
    486  0de3		       85 3e		      sta	SET_BANK_RAM
    487  0de5
    488  0de5		       38		      sec
    489  0de6		       a9 00		      lda	#0
    490  0de8		       e5 ad		      sbc	__negaMax
    491  0dea		       85 ad		      sta	__negaMax
    492  0dec		       a9 00		      lda	#0
    493  0dee		       e5 ae		      sbc	__negaMax+1
    494  0df0		       85 ae		      sta	__negaMax+1	; -negaMax(...)
    495  0df2
    496  0df2
    497  0df2					      IF	1
    498  0df2		       a5 a1		      lda	flagCheck
    499  0df4		       f0 06		      beq	.notCheck
    500  0df6
    501  0df6							; at this point we've determined that the move was illegal, because the next ply detected
    502  0df6							; a king capture. So, the move should be totally discounted
    503  0df6
    504  0df6		       a9 00		      lda	#0
    505  0df8		       85 a1		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
    506  0dfa		       f0 59		      beq	.nextMove	; unconditional - move is not considered!
    507  0dfc					      ENDIF
    508  0dfc
    509  0dfc
    510  0dfc				   .notCheck
    511  0dfc
    512  0dfc		       a5 95		      lda	currentPly
    513  0dfe		       c9 88		      cmp	#RAMBANK_PLY
    514  0e00		       d0 00		      bne	.not0
    515  0e02							;jsr debug
    516  0e02				   .not0
    517  0e02		       38		      sec
      0  0e03					      lda@PLY	value
      1  0e03		       ad d6 f9 	      lda	value
    519  0e06		       e5 ad		      sbc	__negaMax
      0  0e08					      lda@PLY	value+1
      1  0e08		       ad d7 f9 	      lda	value+1
    521  0e0b		       e5 ae		      sbc	__negaMax+1
    522  0e0d		       50 02		      bvc	.lab0
    523  0e0f		       49 80		      eor	#$80
    524  0e11		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
    525  0e13
    526  0e13
    527  0e13							; so, negaMax > value!
    528  0e13
    529  0e13
    530  0e13		       a5 ad		      lda	__negaMax
      0  0e15					      sta@PLY	value
      1  0e15		       8d d6 fb 	      sta	[RAM]+value
    532  0e18		       a5 ae		      lda	__negaMax+1
      0  0e1a					      sta@PLY	value+1	; max(value, -negaMax)
      1  0e1a		       8d d7 fb 	      sta	[RAM]+value+1
    534  0e1d
      0  0e1d					      lda@PLY	movePtr
      1  0e1d		       ad d0 f9 	      lda	movePtr
      0  0e20					      sta@PLY	bestMove
      1  0e20		       8d d1 fb 	      sta	[RAM]+bestMove
    537  0e23				   .lt0
    538  0e23
    539  0e23							;	  α := max(α, value)
    540  0e23
    541  0e23		       38		      sec
      0  0e24					      lda@PLY	value
      1  0e24		       ad d6 f9 	      lda	value
      0  0e27					      sbc@PLY	alpha
      1  0e27		       ed d2 f9 	      sbc	alpha
      0  0e2a					      lda@PLY	value+1
      1  0e2a		       ad d7 f9 	      lda	value+1
      0  0e2d					      sbc@PLY	alpha+1
      1  0e2d		       ed d3 f9 	      sbc	alpha+1
    546  0e30		       50 02		      bvc	.lab1
    547  0e32		       49 80		      eor	#$80
    548  0e34		       30 0c	   .lab1      bmi	.lt1	; value < alpha
    549  0e36
      0  0e36					      lda@PLY	value
      1  0e36		       ad d6 f9 	      lda	value
      0  0e39					      sta@PLY	alpha
      1  0e39		       8d d2 fb 	      sta	[RAM]+alpha
      0  0e3c					      lda@PLY	value+1
      1  0e3c		       ad d7 f9 	      lda	value+1
      0  0e3f					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  0e3f		       8d d3 fb 	      sta	[RAM]+alpha+1
    554  0e42
    555  0e42				   .lt1
    556  0e42
    557  0e42							;	  if α ≥ β then
    558  0e42							;	      break (* cut-off *)
    559  0e42
    560  0e42		       38		      sec
      0  0e43					      lda@PLY	alpha
      1  0e43		       ad d2 f9 	      lda	alpha
      0  0e46					      sbc@PLY	beta
      1  0e46		       ed d4 f9 	      sbc	beta
      0  0e49					      lda@PLY	alpha+1
      1  0e49		       ad d3 f9 	      lda	alpha+1
      0  0e4c					      sbc@PLY	beta+1
      1  0e4c		       ed d5 f9 	      sbc	beta+1
    565  0e4f		       50 02		      bvc	.lab2
    566  0e51		       49 80		      eor	#$80
    567  0e53		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
    568  0e55
    569  0e55
      0  0e55				   .nextMove  ldx@PLY	movePtr
      1  0e55		       ae d0 f9 	      ldx	movePtr
    571  0e58		       ca	   .nextX     dex
    572  0e59		       30 03		      bmi	.retrn
    573  0e5b		       4c 90 f5 	      jmp	.forChild
    574  0e5e
    575  0e5e		       4c 05 f5    .retrn     jmp	.exit
    576  0e61
    577  0e61
    578  0e61							;---------------------------------------------------------------------------------------------------
    579  0e61
    580  0e61					      MAC	xchg
    581  0e61					      lda@PLY	{1},x
    582  0e61					      pha		;sta __xchg
    583  0e61					      lda@PLY	{1},y
    584  0e61					      sta@PLY	{1},x
    585  0e61					      pla		;lda __xchg
    586  0e61					      sta@PLY	{1},y
    587  0e61					      ENDM		;{name}
    588  0e61
    589  0e61
      0  0e61					      DEF	Sort
      1  0e61				   SLOT_Sort  SET	_BANK_SLOT
      2  0e61				   BANK_Sort  SET	SLOT_Sort + _CURRENT_BANK
      3  0e61				   Sort
      4  0e61				   TEMPORARY_VAR SET	Overlay
      5  0e61				   TEMPORARY_OFFSET SET	0
      6  0e61				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      7  0e61				   FUNCTION_NAME SET	Sort
    591  0e61					      SUBROUTINE
    592  0e61
      0  0e61					      REF	GenerateAllMoves
      1  0e61					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  0e61				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  0e61					      ENDIF
      0  0e61					      VAR	__xchg, 1
      1  0e61		       00 bb	   __xchg     =	TEMPORARY_VAR
      2  0e61				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  0e61
      4  0e61				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  0e61				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  0e61				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  0e61					      ENDIF
      8  0e61				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  0e61				  -VNAME      SETSTR	__xchg
     10  0e61				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  0e61				  -	      ERR
     12  0e61					      ENDIF
      0  0e61					      VEND	Sort
      1  0e61
      2  0e61
      3  0e61		       00 bc	   VAREND_Sort =	TEMPORARY_VAR
      4  0e61
    596  0e61
    597  0e61		       a5 b1		      lda	__quiesceCapOnly
    598  0e63		       d0 4a		      bne	.exit	; only caps present so already sorted!
    599  0e65
      0  0e65					      ldx@PLY	moveIndex
      1  0e65		       ae cf f9 	      ldx	moveIndex
      0  0e68					      ldy@PLY	moveIndex
      1  0e68		       ac cf f9 	      ldy	moveIndex
    602  0e6b		       c8		      iny		; this is OK - swaps "1st" with itself if it's a capture
    603  0e6c
    604  0e6c		       88	   .next      dey
    605  0e6d		       30 40		      bmi	.exit
    606  0e6f
      0  0e6f					      lda@PLY	MoveCapture,y
      1  0e6f		       b9 64 f9 	      lda	MoveCapture,y
    608  0e72		       f0 f8		      beq	.next
    609  0e74
      0  0e74					      XCHG	MoveFrom
      0  0e74					      lda@PLY	MoveFrom,x
      1  0e74		       bd 00 f8 	      lda	MoveFrom,x
      2  0e77		       48		      pha
      0  0e78					      lda@PLY	MoveFrom,y
      1  0e78		       b9 00 f8 	      lda	MoveFrom,y
      0  0e7b					      sta@PLY	MoveFrom,x
      1  0e7b		       9d 00 fa 	      sta	[RAM]+MoveFrom,x
      5  0e7e		       68		      pla
      0  0e7f					      sta@PLY	MoveFrom,y
      1  0e7f		       99 00 fa 	      sta	[RAM]+MoveFrom,y
      0  0e82					      XCHG	MoveTo
      0  0e82					      lda@PLY	MoveTo,x
      1  0e82		       bd 64 f8 	      lda	MoveTo,x
      2  0e85		       48		      pha
      0  0e86					      lda@PLY	MoveTo,y
      1  0e86		       b9 64 f8 	      lda	MoveTo,y
      0  0e89					      sta@PLY	MoveTo,x
      1  0e89		       9d 64 fa 	      sta	[RAM]+MoveTo,x
      5  0e8c		       68		      pla
      0  0e8d					      sta@PLY	MoveTo,y
      1  0e8d		       99 64 fa 	      sta	[RAM]+MoveTo,y
      0  0e90					      XCHG	MovePiece
      0  0e90					      lda@PLY	MovePiece,x
      1  0e90		       bd 00 f9 	      lda	MovePiece,x
      2  0e93		       48		      pha
      0  0e94					      lda@PLY	MovePiece,y
      1  0e94		       b9 00 f9 	      lda	MovePiece,y
      0  0e97					      sta@PLY	MovePiece,x
      1  0e97		       9d 00 fb 	      sta	[RAM]+MovePiece,x
      5  0e9a		       68		      pla
      0  0e9b					      sta@PLY	MovePiece,y
      1  0e9b		       99 00 fb 	      sta	[RAM]+MovePiece,y
      0  0e9e					      XCHG	MoveCapture
      0  0e9e					      lda@PLY	MoveCapture,x
      1  0e9e		       bd 64 f9 	      lda	MoveCapture,x
      2  0ea1		       48		      pha
      0  0ea2					      lda@PLY	MoveCapture,y
      1  0ea2		       b9 64 f9 	      lda	MoveCapture,y
      0  0ea5					      sta@PLY	MoveCapture,x
      1  0ea5		       9d 64 fb 	      sta	[RAM]+MoveCapture,x
      5  0ea8		       68		      pla
      0  0ea9					      sta@PLY	MoveCapture,y
      1  0ea9		       99 64 fb 	      sta	[RAM]+MoveCapture,y
    614  0eac
    615  0eac		       ca		      dex
    616  0ead		       10 bd		      bpl	.next
    617  0eaf
    618  0eaf				   .exit
    619  0eaf
    620  0eaf							; Scan for capture of king
    621  0eaf							; Also scan for virtual king captures (squares involved in castling)
    622  0eaf
      0  0eaf					      ldx@PLY	moveIndex
      1  0eaf		       ae cf f9 	      ldx	moveIndex
    624  0eb2		       30 19		      bmi	.notCheck	; OK if no captures in quiesce!
    625  0eb4
      0  0eb4				   .scanCheck lda@PLY	MoveCapture,x
      1  0eb4		       bd 64 f9 	      lda	MoveCapture,x
    627  0eb7		       29 0f		      and	#PIECE_MASK
    628  0eb9		       c9 07		      cmp	#KING
    629  0ebb		       f0 12		      beq	.check
    630  0ebd
    631  0ebd							; If the squares the king is crossing for castling are capturable, then that's an illegal
    632  0ebd							; castle move and it's treated as if the king were in check.
    633  0ebd
      0  0ebd					      lda@PLY	MoveTo,x
      1  0ebd		       bd 64 f8 	      lda	MoveTo,x
      0  0ec0					      cmp@PLY	virtualKingSquare
      1  0ec0		       cd da f9 	      cmp	virtualKingSquare
    636  0ec3		       f0 0a		      beq	.check
      0  0ec5					      cmp@PLY	virtualKingSquare+1
      1  0ec5		       cd db f9 	      cmp	virtualKingSquare+1
    638  0ec8		       f0 05		      beq	.check
    639  0eca
    640  0eca		       ca	   .nextScan  dex
    641  0ecb		       10 e7		      bpl	.scanCheck
    642  0ecd
    643  0ecd		       a9 00	   .notCheck  lda	#0
    644  0ecf		       85 a1	   .check     sta	flagCheck
    645  0ed1		       60		      rts
    646  0ed2
    647  0ed2
    648  0ed2							;---------------------------------------------------------------------------------------------------
    649  0ed2							; QUIESCE!
    650  0ed2
    651  0ed2							;int Quiesce( int alpha, int beta ) {
    652  0ed2							;    int stand_pat = Evaluate();
    653  0ed2							;    if( stand_pat >= beta )
    654  0ed2							;	  return beta;
    655  0ed2							;    if( alpha < stand_pat )
    656  0ed2							;	  alpha = stand_pat;
    657  0ed2
    658  0ed2							;    until( every_capture_has_been_examined )	{
    659  0ed2							;	  MakeCapture();
    660  0ed2							;	  score = -Quiesce( -beta, -alpha );
    661  0ed2							;	  TakeBackMove();
    662  0ed2
    663  0ed2							;	  if( score >= beta )
    664  0ed2							;	      return beta;
    665  0ed2							;	  if( score > alpha )
    666  0ed2							;	     alpha = score;
    667  0ed2							;    }
    668  0ed2							;    return alpha;
    669  0ed2							;}
    670  0ed2
    671  0ed2
    672  0ed2							;---------------------------------------------------------------------------------------------------
    673  0ed2
      0  0ed2					      DEF	quiesce
      1  0ed2				   SLOT_quiesce SET	_BANK_SLOT
      2  0ed2				   BANK_quiesce SET	SLOT_quiesce + _CURRENT_BANK
      3  0ed2				   quiesce
      4  0ed2				   TEMPORARY_VAR SET	Overlay
      5  0ed2				   TEMPORARY_OFFSET SET	0
      6  0ed2				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      7  0ed2				   FUNCTION_NAME SET	quiesce
    675  0ed2					      SUBROUTINE
    676  0ed2
    677  0ed2							; pass...
    678  0ed2							; x = depthleft
    679  0ed2							; SET_BANK_RAM      --> current ply
    680  0ed2							; __alpha[2] = param alpha
    681  0ed2							; __beta[2] = param beta
    682  0ed2
    683  0ed2
      0  0ed2					      REF	COMMON_VARS
      1  0ed2					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  0ed2				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  0ed2					      ENDIF
      0  0ed2					      REF	negaMax
      1  0ed2					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  0ed2				   TEMPORARY_VAR SET	VAREND_negaMax
      3  0ed2					      ENDIF
      0  0ed2					      VEND	quiesce
      1  0ed2
      2  0ed2
      3  0ed2		       00 b8	   VAREND_quiesce =	TEMPORARY_VAR
      4  0ed2
    687  0ed2
    688  0ed2		       a5 95		      lda	currentPly
    689  0ed4		       c9 8e		      cmp	#RAMBANK_PLY + PLY_BANKS -1
    690  0ed6		       b0 28		      bcs	.retBeta
    691  0ed8							;sta SET_BANK_RAM ;tmp
    692  0ed8
    693  0ed8
    694  0ed8		       20 81 f0 	      jsr	ThinkBar	;@0
    695  0edb
    696  0edb		       a5 ab		      lda	__beta
      0  0edd					      sta@PLY	beta
      1  0edd		       8d d4 fb 	      sta	[RAM]+beta
    698  0ee0		       a5 ac		      lda	__beta+1
      0  0ee2					      sta@PLY	beta+1
      1  0ee2		       8d d5 fb 	      sta	[RAM]+beta+1
    700  0ee5
    701  0ee5		       a5 a9		      lda	__alpha
      0  0ee7					      sta@PLY	alpha
      1  0ee7		       8d d2 fb 	      sta	[RAM]+alpha
    703  0eea		       a5 aa		      lda	__alpha+1
      0  0eec					      sta@PLY	alpha+1
      1  0eec		       8d d3 fb 	      sta	[RAM]+alpha+1
    705  0eef
    706  0eef
    707  0eef							;    int stand_pat = Evaluate();
    708  0eef							;    if( stand_pat >= beta )
    709  0eef							;	  return beta;
    710  0eef
    711  0eef		       38		      sec
    712  0ef0		       a5 90		      lda	Evaluation
      0  0ef2					      sbc@PLY	beta
      1  0ef2		       ed d4 f9 	      sbc	beta
    714  0ef5		       a5 91		      lda	Evaluation+1
      0  0ef7					      sbc@PLY	beta+1
      1  0ef7		       ed d5 f9 	      sbc	beta+1
    716  0efa		       50 02		      bvc	.spat0
    717  0efc		       49 80		      eor	#$80
    718  0efe		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    719  0f00
    720  0f00		       ad d4 f9    .retBeta   lda	beta
    721  0f03		       85 ad		      sta	__negaMax
    722  0f05		       ad d5 f9 	      lda	beta+1
    723  0f08		       85 ae		      sta	__negaMax+1
    724  0f0a
    725  0f0a		       60	   .abort     rts
    726  0f0b
    727  0f0b				   .norb
    728  0f0b
    729  0f0b
    730  0f0b							;    if( alpha < stand_pat )
    731  0f0b							;	  alpha = stand_pat;
    732  0f0b
    733  0f0b		       38		      sec
    734  0f0c		       ad d2 f9 	      lda	alpha
    735  0f0f		       e5 90		      sbc	Evaluation
    736  0f11		       ad d3 f9 	      lda	alpha+1
    737  0f14		       e5 91		      sbc	Evaluation+1
    738  0f16		       50 02		      bvc	.spat1
    739  0f18		       49 80		      eor	#$80
    740  0f1a		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    741  0f1c
    742  0f1c							; alpha < stand_pat
    743  0f1c
    744  0f1c		       a5 90		      lda	Evaluation
      0  0f1e					      sta@PLY	alpha
      1  0f1e		       8d d2 fb 	      sta	[RAM]+alpha
    746  0f21		       a5 91		      lda	Evaluation+1
      0  0f23					      sta@PLY	alpha+1
      1  0f23		       8d d3 fb 	      sta	[RAM]+alpha+1
    748  0f26
    749  0f26				   .alpha
    750  0f26		       20 a6 f1 	      jsr	GenerateAllMoves
    751  0f29		       a5 a1		      lda	flagCheck
    752  0f2b		       d0 dd		      bne	.abort	; pure abort
    753  0f2d
      0  0f2d					      ldx@PLY	moveIndex
      1  0f2d		       ae cf f9 	      ldx	moveIndex
    755  0f30		       30 76		      bmi	.exit
    756  0f32
      0  0f32				   .forChild  stx@PLY	movePtr
      1  0f32		       8e d0 fb 	      stx	[RAM]+movePtr
    758  0f35
    759  0f35							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    760  0f35
    761  0f35		       20 7f f4 	      jsr	MakeMove	;@this
    762  0f38
    763  0f38		       38		      sec
    764  0f39		       a9 00		      lda	#0
      0  0f3b					      sbc@PLY	beta
      1  0f3b		       ed d4 f9 	      sbc	beta
    766  0f3e		       85 a9		      sta	__alpha
    767  0f40		       a9 00		      lda	#0
      0  0f42					      sbc@PLY	beta+1
      1  0f42		       ed d5 f9 	      sbc	beta+1
    769  0f45		       85 aa		      sta	__alpha+1
    770  0f47
    771  0f47		       38		      sec
    772  0f48		       a9 00		      lda	#0
      0  0f4a					      sbc@PLY	alpha
      1  0f4a		       ed d2 f9 	      sbc	alpha
    774  0f4d		       85 ab		      sta	__beta
    775  0f4f		       a9 00		      lda	#0
      0  0f51					      sbc@PLY	alpha+1
      1  0f51		       ed d3 f9 	      sbc	alpha+1
    777  0f54		       85 ac		      sta	__beta+1
    778  0f56
    779  0f56		       e6 95		      inc	currentPly
    780  0f58		       a5 95		      lda	currentPly
    781  0f5a		       85 3e		      sta	SET_BANK_RAM	; self-switch
    782  0f5c
    783  0f5c		       20 d2 f6 	      jsr	quiesce	;@this
    784  0f5f
    785  0f5f		       c6 95		      dec	currentPly
    786  0f61
    787  0f61		       20 ad f2 	      jsr	unmakeMove	;@0
    788  0f64
    789  0f64		       a5 a1		      lda	flagCheck	; don't consider moves which leave us in check
    790  0f66		       d0 4b		      bne	.inCheck
    791  0f68
    792  0f68		       38		      sec
    793  0f69							;lda #0			 ; already 0
    794  0f69		       e5 ad		      sbc	__negaMax
    795  0f6b		       85 ad		      sta	__negaMax
    796  0f6d		       a9 00		      lda	#0
    797  0f6f		       e5 ae		      sbc	__negaMax+1
    798  0f71		       85 ae		      sta	__negaMax+1	; -negaMax(...)
    799  0f73
    800  0f73
    801  0f73
    802  0f73							;	  if( score >= beta )
    803  0f73							;	      return beta;
    804  0f73
    805  0f73
    806  0f73		       38		      sec
    807  0f74		       a5 ad		      lda	__negaMax
      0  0f76					      sbc@PLY	beta
      1  0f76		       ed d4 f9 	      sbc	beta
    809  0f79		       a5 ae		      lda	__negaMax+1
      0  0f7b					      sbc@PLY	beta+1
      1  0f7b		       ed d5 f9 	      sbc	beta+1
    811  0f7e		       50 02		      bvc	.lab0
    812  0f80		       49 80		      eor	#$80
    813  0f82		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    814  0f84		       4c 00 f7 	      jmp	.retBeta
    815  0f87				   .nrb2
    816  0f87
    817  0f87							;	  if( score > alpha )
    818  0f87							;	     alpha = score;
    819  0f87							;    }
    820  0f87
    821  0f87		       38		      sec
      0  0f88					      lda@PLY	alpha
      1  0f88		       ad d2 f9 	      lda	alpha
    823  0f8b		       e5 ad		      sbc	__negaMax
      0  0f8d					      lda@PLY	alpha+1
      1  0f8d		       ad d3 f9 	      lda	alpha+1
    825  0f90		       e5 ae		      sbc	__negaMax+1
    826  0f92		       50 02		      bvc	.lab2
    827  0f94		       49 80		      eor	#$80
    828  0f96		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    829  0f98
    830  0f98							; score > alpha
    831  0f98
    832  0f98		       a5 ad		      lda	__negaMax
      0  0f9a					      sta@PLY	alpha
      1  0f9a		       8d d2 fb 	      sta	[RAM]+alpha
    834  0f9d		       a5 ae		      lda	__negaMax+1
      0  0f9f					      sta@PLY	alpha+1
      1  0f9f		       8d d3 fb 	      sta	[RAM]+alpha+1
    836  0fa2
      0  0fa2				   .nextMove  ldx@PLY	movePtr
      1  0fa2		       ae d0 f9 	      ldx	movePtr
    838  0fa5		       ca		      dex
    839  0fa6		       10 8a		      bpl	.forChild
    840  0fa8
    841  0fa8							;    return alpha;
    842  0fa8
    843  0fa8				   .exit
      0  0fa8					      lda@PLY	alpha
      1  0fa8		       ad d2 f9 	      lda	alpha
    845  0fab		       85 ad		      sta	__negaMax
      0  0fad					      lda@PLY	alpha+1
      1  0fad		       ad d3 f9 	      lda	alpha+1
    847  0fb0		       85 ae		      sta	__negaMax+1
    848  0fb2		       60		      rts
    849  0fb3
    850  0fb3		       a9 00	   .inCheck   lda	#0
    851  0fb5		       85 a1		      sta	flagCheck
    852  0fb7		       f0 e9		      beq	.nextMove
    853  0fb9
    854  0fb9
    855  0fb9							;---------------------------------------------------------------------------------------------------
    856  0fb9
      0  0fb9					      END_BANK
      1  0fb9				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  0fb9				  -	      CHECK_RAM_BANK_SIZE
      3  0fb9					      ELSE
      0  0fb9					      CHECK_BANK_SIZE
      1  0fb9		       03 b9	   .TEMP      =	* - _BANK_START
 ROM bank # 4 NEGAMAX size = $3b9 free = 70
      2  0fb9					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  0fb9				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  0fb9				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  0fb9				  -	      ERR
      6  0fb9					      ENDIF
      5  0fb9					      ENDIF
    858  0fb9
    859  0fb9							;---------------------------------------------------------------------------------------------------
    860  0fb9							; EOF
------- FILE ./chess.asm
------- FILE @1 STATE MACHINE #1.asm LEVEL 2 PASS 4
      0  0fb9					      include	"@1 STATE MACHINE #1.asm"
      1  0fb9							;---------------------------------------------------------------------------------------------------
      2  0fb9							; @1 STATE MACHINE #1.asm
      3  0fb9
      4  0fb9							; Atari 2600 Chess
      5  0fb9							; Copyright (c) 2019-2020 Andrew Davie
      6  0fb9							; andrew@taswegian.com
      7  0fb9
      8  0fb9
      9  0fb9							;---------------------------------------------------------------------------------------------------
     10  0fb9
      0  0fb9					      SLOT	1
      1  0fb9
      2  0fb9				  -	      IF	(1 < 0) || (1 > 3)
      3  0fb9				  -	      ECHO	"Illegal bank address/segment location", 1
      4  0fb9				  -	      ERR
      5  0fb9					      ENDIF
      6  0fb9
      7  0fb9				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  0fb9				   _BANK_SLOT SET	1 * 64
      9  0fb9
      0  0fb9					      ROMBANK	STATEMACHINE
      1  13e1 ????				      SEG	ROM_STATEMACHINE
      2  1000					      ORG	_ORIGIN
      3  1000					      RORG	_BANK_ADDRESS_ORIGIN
      4  1000				   _BANK_START SET	*
      5  1000				   STATEMACHINE_START SET	*
      6  1000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1000				   ROMBANK_STATEMACHINE SET	_BANK_SLOT + _CURRENT_BANK
      8  1000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1000				   _LAST_BANK SETSTR	STATEMACHINE
     10  1000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1000
     14  1000
     15  1000							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
     16  1000
     17  1000
     18  1000		       00 10	   CURSOR_MOVE_SPEED =	16
     19  1000		       00 14	   CAP_SPEED  =	20
     20  1000		       00 28	   HOLD_DELAY =	40
     21  1000
     22  1000
     23  1000							;---------------------------------------------------------------------------------------------------
     24  1000
      0  1000					      DEF	aiStartMoveGen
      1  1000				   SLOT_aiStartMoveGen SET	_BANK_SLOT
      2  1000				   BANK_aiStartMoveGen SET	SLOT_aiStartMoveGen + _CURRENT_BANK
      3  1000				   aiStartMoveGen
      4  1000				   TEMPORARY_VAR SET	Overlay
      5  1000				   TEMPORARY_OFFSET SET	0
      6  1000				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      7  1000				   FUNCTION_NAME SET	aiStartMoveGen
     26  1000					      SUBROUTINE
     27  1000
      0  1000					      REF	AiStateMachine
      1  1000					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1000				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1000					      ENDIF
      0  1000					      VEND	aiStartMoveGen
      1  1000
      2  1000
      3  1000		       00 a8	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
      4  1000
     30  1000
     31  1000							; To assist with castling, generate the moves for the opponent, giving us effectively
     32  1000							; a list of squares that are being attacked. The castling can't happen if the king is
     33  1000							; in check or if the squares it would have to move over are in check
     34  1000
     35  1000							; we don't need to worry about this if K has moved, or relevant R has moved or if
     36  1000							; the squares between are occupied. We can tell THAT by examining the movelist to see
     37  1000							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
     38  1000
     39  1000							;inc currentPly
     40  1000							;jsr InitialiseMoveGeneration
     41  1000
      0  1000					      PHASE	StepMoveGen
      1  1000		       a9 0c		      lda	#AI_StepMoveGen
      2  1002		       85 8c		      sta	aiState
     43  1004		       60		      rts
     44  1005
     45  1005
     46  1005							;---------------------------------------------------------------------------------------------------
     47  1005
      0  1005					      DEF	aiInCheckBackupStart
      1  1005				   SLOT_aiInCheckBackupStart SET	_BANK_SLOT
      2  1005				   BANK_aiInCheckBackupStart SET	SLOT_aiInCheckBackupStart + _CURRENT_BANK
      3  1005				   aiInCheckBackupStart
      4  1005				   TEMPORARY_VAR SET	Overlay
      5  1005				   TEMPORARY_OFFSET SET	0
      6  1005				   VAR_BOUNDARY_aiInCheckBackupStart SET	TEMPORARY_OFFSET
      7  1005				   FUNCTION_NAME SET	aiInCheckBackupStart
     49  1005					      SUBROUTINE
     50  1005
      0  1005					      REF	AiStateMachine
      1  1005					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1005				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1005					      ENDIF
      0  1005					      VEND	aiInCheckBackupStart
      1  1005
      2  1005
      3  1005		       00 a8	   VAREND_aiInCheckBackupStart =	TEMPORARY_VAR
      4  1005
     53  1005
     54  1005
     55  1005
     56  1005		       a9 08		      lda	#8
     57  1007		       85 85		      sta	drawCount	; row to draw
     58  1009
      0  1009					      PHASE	InCheckBackup
      1  1009		       a9 1d		      lda	#AI_InCheckBackup
      2  100b		       85 8c		      sta	aiState
     60  100d		       60		      rts
     61  100e
     62  100e
     63  100e							;---------------------------------------------------------------------------------------------------
     64  100e
      0  100e					      DEF	aiInCheckBackup
      1  100e				   SLOT_aiInCheckBackup SET	_BANK_SLOT
      2  100e				   BANK_aiInCheckBackup SET	SLOT_aiInCheckBackup + _CURRENT_BANK
      3  100e				   aiInCheckBackup
      4  100e				   TEMPORARY_VAR SET	Overlay
      5  100e				   TEMPORARY_OFFSET SET	0
      6  100e				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      7  100e				   FUNCTION_NAME SET	aiInCheckBackup
     66  100e					      SUBROUTINE
     67  100e
      0  100e					      REF	AiStateMachine
      1  100e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  100e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  100e					      ENDIF
      0  100e					      VEND	aiInCheckBackup
      1  100e
      2  100e
      3  100e		       00 a8	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
      4  100e
     70  100e
     71  100e
     72  100e							; We're about to draw some large text on the screen
     73  100e							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
     74  100e
     75  100e		       c6 85		      dec	drawCount
     76  1010		       30 07		      bmi	.exit	; done all rows
     77  1012
      0  1012					      JUMP	BackupBitmaps	;@3
      1  1012				  -	      IF	SLOT_BackupBitmaps == _BANK_SLOT
      2  1012				  -FNAME      SETSTR	BackupBitmaps
      3  1012				  -	      ECHO	""
      4  1012				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  1012				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1012				  -	      ERR
      7  1012					      ENDIF
      8  1012		       a9 da		      lda	#BANK_BackupBitmaps
      9  1014		       85 3f		      sta	SET_BANK
     10  1016		       4c 5d fc 	      jmp	BackupBitmaps
     79  1019
     80  1019				   .exit
     81  1019
     82  1019		       a9 08		      lda	#8
     83  101b		       85 85		      sta	drawCount	; ROW
     84  101d
      0  101d					      PHASE	MaskBitmapBackground
      1  101d		       a9 2f		      lda	#AI_MaskBitmapBackground
      2  101f		       85 8c		      sta	aiState
     86  1021		       60		      rts
     87  1022
     88  1022
     89  1022							;---------------------------------------------------------------------------------------------------
     90  1022
      0  1022					      DEF	aiWaitBitmap
      1  1022				   SLOT_aiWaitBitmap SET	_BANK_SLOT
      2  1022				   BANK_aiWaitBitmap SET	SLOT_aiWaitBitmap + _CURRENT_BANK
      3  1022				   aiWaitBitmap
      4  1022				   TEMPORARY_VAR SET	Overlay
      5  1022				   TEMPORARY_OFFSET SET	0
      6  1022				   VAR_BOUNDARY_aiWaitBitmap SET	TEMPORARY_OFFSET
      7  1022				   FUNCTION_NAME SET	aiWaitBitmap
     92  1022					      SUBROUTINE
     93  1022
      0  1022					      REF	AiStateMachine
      1  1022					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1022				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1022					      ENDIF
      0  1022					      VEND	aiWaitBitmap
      1  1022
      2  1022
      3  1022		       00 a8	   VAREND_aiWaitBitmap =	TEMPORARY_VAR
      4  1022
     96  1022
     97  1022							;		      lda INPT4
     98  1022							;		      bmi .noButton
     99  1022							;PHASE DrawBitmap
    100  1022							;rts
    101  1022		       c6 85		      dec	drawCount
    102  1024		       a5 85		      lda	drawCount
    103  1026		       c9 dc		      cmp	#220
    104  1028		       d0 08		      bne	.noButton
    105  102a
    106  102a
    107  102a				   .button
    108  102a		       a9 08		      lda	#8
    109  102c		       85 85		      sta	drawCount	; ROW#
    110  102e
      0  102e					      PHASE	RestoreBitmaps
      1  102e		       a9 2d		      lda	#AI_RestoreBitmaps
      2  1030		       85 8c		      sta	aiState
    112  1032		       60	   .noButton  rts
    113  1033
    114  1033
    115  1033							;---------------------------------------------------------------------------------------------------
    116  1033
      0  1033					      DEF	aiRestoreBitmaps
      1  1033				   SLOT_aiRestoreBitmaps SET	_BANK_SLOT
      2  1033				   BANK_aiRestoreBitmaps SET	SLOT_aiRestoreBitmaps + _CURRENT_BANK
      3  1033				   aiRestoreBitmaps
      4  1033				   TEMPORARY_VAR SET	Overlay
      5  1033				   TEMPORARY_OFFSET SET	0
      6  1033				   VAR_BOUNDARY_aiRestoreBitmaps SET	TEMPORARY_OFFSET
      7  1033				   FUNCTION_NAME SET	aiRestoreBitmaps
    118  1033					      SUBROUTINE
    119  1033
    120  1033		       c6 85		      dec	drawCount
    121  1035		       30 07		      bmi	.exit	; done all rows
    122  1037
      0  1037					      JUMP	RestoreBitmaps	;@3
      1  1037				  -	      IF	SLOT_RestoreBitmaps == _BANK_SLOT
      2  1037				  -FNAME      SETSTR	RestoreBitmaps
      3  1037				  -	      ECHO	""
      4  1037				  -	      ECHO	"ERROR: Incompatible slot for jump to function", FNAME
      5  1037				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1037				  -	      ERR
      7  1037					      ENDIF
      8  1037		       a9 da		      lda	#BANK_RestoreBitmaps
      9  1039		       85 3f		      sta	SET_BANK
     10  103b		       4c 71 fc 	      jmp	RestoreBitmaps
    124  103e
    125  103e				   .exit
    126  103e
    127  103e		       a5 0c		      lda	INPT4
    128  1040							;bmi .noButton
      0  1040					      PHASE	SelectStartSquare
      1  1040		       a9 02		      lda	#AI_SelectStartSquare
      2  1042		       85 8c		      sta	aiState
    130  1044		       60		      rts
    131  1045				   .noButton
    132  1045							;		      PHASE InCheckDelay
      0  1045					      PHASE	SelectStartSquare
      1  1045		       a9 02		      lda	#AI_SelectStartSquare
      2  1047		       85 8c		      sta	aiState
    134  1049							;PHASE InCheckBackupStart
    135  1049		       60		      rts
    136  104a
    137  104a
    138  104a
    139  104a							;---------------------------------------------------------------------------------------------------
    140  104a
      0  104a					      DEF	aiInCheckDelay
      1  104a				   SLOT_aiInCheckDelay SET	_BANK_SLOT
      2  104a				   BANK_aiInCheckDelay SET	SLOT_aiInCheckDelay + _CURRENT_BANK
      3  104a				   aiInCheckDelay
      4  104a				   TEMPORARY_VAR SET	Overlay
      5  104a				   TEMPORARY_OFFSET SET	0
      6  104a				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      7  104a				   FUNCTION_NAME SET	aiInCheckDelay
    142  104a					      SUBROUTINE
    143  104a
      0  104a					      REF	AiStateMachine
      1  104a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  104a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  104a					      ENDIF
      0  104a					      VEND	aiInCheckDelay
      1  104a
      2  104a
      3  104a		       00 a8	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
      4  104a
    146  104a
    147  104a		       c6 8a		      dec	mdelay
    148  104c		       d0 08		      bne	.exit
    149  104e
    150  104e		       a9 00		      lda	#0
    151  1050		       85 09		      sta	COLUBK
    152  1052
      0  1052					      PHASE	BeginSelectMovePhase
      1  1052		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  1054		       85 8c		      sta	aiState
    154  1056		       60	   .exit      rts
    155  1057
    156  1057
    157  1057							;---------------------------------------------------------------------------------------------------
    158  1057
      0  1057					      DEF	aiBeginSelectMovePhase
      1  1057				   SLOT_aiBeginSelectMovePhase SET	_BANK_SLOT
      2  1057				   BANK_aiBeginSelectMovePhase SET	SLOT_aiBeginSelectMovePhase + _CURRENT_BANK
      3  1057				   aiBeginSelectMovePhase
      4  1057				   TEMPORARY_VAR SET	Overlay
      5  1057				   TEMPORARY_OFFSET SET	0
      6  1057				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      7  1057				   FUNCTION_NAME SET	aiBeginSelectMovePhase
    160  1057					      SUBROUTINE
    161  1057
      0  1057					      REF	AiStateMachine
      1  1057					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1057				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1057					      ENDIF
      0  1057					      VEND	aiBeginSelectMovePhase
      1  1057
      2  1057
      3  1057		       00 a8	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
      4  1057
    164  1057
    165  1057		       a6 a5		      ldx	platform
    166  1059		       bd 79 f4 	      lda	greyCol,x
    167  105c		       85 06		      sta	COLUP0
    168  105e
    169  105e		       a2 04		      ldx	#%100
    170  1060		       86 0a		      stx	CTRLPF	; under
    171  1062
    172  1062		       a9 00		      lda	#0
    173  1064		       85 8a		      sta	mdelay	;?
    174  1066		       85 8f		      sta	aiFlashPhase	; odd/even for flashing pieces
    175  1068
    176  1068		       a9 28		      lda	#CAP_SPEED*2
    177  106a		       85 8d		      sta	aiFlashDelay
    178  106c
    179  106c		       a9 ff		      lda	#-1
    180  106e		       85 86		      sta	fromX12
    181  1070		       85 87		      sta	toX12
    182  1072
    183  1072		       46 a2		      lsr	randomness
    184  1074
    185  1074
      0  1074					      PHASE	FlashComputerMove
      1  1074		       a9 00		      lda	#AI_FlashComputerMove
      2  1076		       85 8c		      sta	aiState
    187  1078		       60		      rts
    188  1079
    189  1079				   greyCol
    190  1079		       06 08		      .byte.b	6, 8
    191  107b
    192  107b							;---------------------------------------------------------------------------------------------------
    193  107b
      0  107b					      DEF	aiFlashComputerMove
      1  107b				   SLOT_aiFlashComputerMove SET	_BANK_SLOT
      2  107b				   BANK_aiFlashComputerMove SET	SLOT_aiFlashComputerMove + _CURRENT_BANK
      3  107b				   aiFlashComputerMove
      4  107b				   TEMPORARY_VAR SET	Overlay
      5  107b				   TEMPORARY_OFFSET SET	0
      6  107b				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      7  107b				   FUNCTION_NAME SET	aiFlashComputerMove
    195  107b					      SUBROUTINE
    196  107b
      0  107b					      REF	Variable_PieceShapeBuffer
      1  107b					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  107b				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  107b					      ENDIF
      0  107b					      REF	AiStateMachine
      1  107b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  107b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  107b					      ENDIF
      0  107b					      VEND	aiFlashComputerMove
      1  107b
      2  107b
      3  107b		       00 ee	   VAREND_aiFlashComputerMove =	TEMPORARY_VAR
      4  107b
    200  107b
    201  107b		       a5 81		      lda	squareToDraw
    202  107d		       30 30		      bmi	.initial2	; startup - no computer move to show
    203  107f
    204  107f		       a5 8f		      lda	aiFlashPhase
    205  1081		       4a		      lsr
    206  1082		       b0 0c		      bcs	.noSwapside	; only check for SELECT/exit if piece is drawn
    207  1084
    208  1084		       ad 82 02 	      lda	SWCHB
    209  1087		       29 02		      and	#SELECT_SWITCH
    210  1089		       d0 05		      bne	.noSwapside
    211  108b
      0  108b					      PHASE	DebounceSelect
      1  108b		       a9 2b		      lda	#AI_DebounceSelect
      2  108d		       85 8c		      sta	aiState
    213  108f		       60		      rts
    214  1090				   .noSwapside
    215  1090
    216  1090							; "squareToDraw" is the piece that should flash while human waits
    217  1090
    218  1090		       ad 80 02 	      lda	SWCHA
    219  1093		       29 f0		      and	#$F0	; UDLR bits
    220  1095		       c9 f0		      cmp	#$F0	; all NOT pressed
    221  1097		       f0 08		      beq	.nodir
    222  1099
    223  1099							; direction has been pressed, so transition out of flashing
    224  1099
    225  1099		       a9 01		      lda	#1
    226  109b		       85 8d		      sta	aiFlashDelay
    227  109d		       25 8f		      and	aiFlashPhase
    228  109f		       f0 0e		      beq	.initial
    229  10a1
    230  10a1		       c6 8d	   .nodir     dec	aiFlashDelay
    231  10a3		       d0 0e		      bne	.exit	; don't flash
    232  10a5		       a9 28		      lda	#CAP_SPEED*2
    233  10a7		       85 8d		      sta	aiFlashDelay
    234  10a9
    235  10a9		       e6 8f		      inc	aiFlashPhase
    236  10ab
    237  10ab							; WARNING - local variables will not survive the following call...!
    238  10ab		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    239  10ae		       60		      rts
    240  10af
    241  10af				   .initial
    242  10af
    243  10af							;SWAP
    244  10af				   .initial2
    245  10af
    246  10af
    247  10af							;PHASE InCheckBackupStart ;tmp
    248  10af							;rts
    249  10af
    250  10af
      0  10af					      PHASE	SelectStartSquare
      1  10af		       a9 02		      lda	#AI_SelectStartSquare
      2  10b1		       85 8c		      sta	aiState
    252  10b3
    253  10b3		       60	   .exit      rts
    254  10b4
    255  10b4
    256  10b4							;---------------------------------------------------------------------------------------------------
    257  10b4
      0  10b4					      DEF	aiSelectStartSquare
      1  10b4				   SLOT_aiSelectStartSquare SET	_BANK_SLOT
      2  10b4				   BANK_aiSelectStartSquare SET	SLOT_aiSelectStartSquare + _CURRENT_BANK
      3  10b4				   aiSelectStartSquare
      4  10b4				   TEMPORARY_VAR SET	Overlay
      5  10b4				   TEMPORARY_OFFSET SET	0
      6  10b4				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      7  10b4				   FUNCTION_NAME SET	aiSelectStartSquare
    259  10b4					      SUBROUTINE
    260  10b4
      0  10b4					      REF	AiStateMachine
      1  10b4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  10b4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  10b4					      ENDIF
      0  10b4					      VEND	aiSelectStartSquare
      1  10b4
      2  10b4
      3  10b4		       00 a8	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
      4  10b4
    263  10b4
      0  10b4					      NEXT_RANDOM
      1  10b4
      2  10b4		       a5 82		      lda	rnd
      3  10b6		       4a		      lsr
      4  10b7		       90 02		      bcc	.skipEOR
      5  10b9		       49 b4		      eor	#RND_EOR_VAL
      6  10bb		       85 82	   .skipEOR   sta	rnd
      7  10bd
    265  10bd
    266  10bd		       ad 82 02 	      lda	SWCHB
    267  10c0		       29 02		      and	#SELECT_SWITCH
    268  10c2		       f0 34		      beq	.swapside
    269  10c4
      0  10c4					      CALL	moveCursor	;@2
      1  10c4				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  10c4				  -FNAME      SETSTR	moveCursor
      3  10c4				  -	      ECHO	""
      4  10c4				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  10c4				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  10c4				  -	      ERR
      7  10c4					      ENDIF
      8  10c4		       a9 8a		      lda	#BANK_moveCursor
      9  10c6		       85 3f		      sta	SET_BANK
     10  10c8		       20 00 f8 	      jsr	moveCursor
    271  10cb
    272  10cb							; Search the player's movelist for the square, so we can set cursor colour
    273  10cb
    274  10cb		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
    275  10cd		       85 3e		      sta	SET_BANK_RAM	;@2
    276  10cf
    277  10cf		       a5 89		      lda	cursorX12
    278  10d1		       85 86		      sta	fromX12
    279  10d3
      0  10d3					      ldy@PLY	moveIndex
      1  10d3		       ac cf f9 	      ldy	moveIndex
    281  10d6		       30 0d		      bmi	.done
    282  10d8
    283  10d8		       d9 00 f8    .scan      cmp	MoveFrom,y
    284  10db		       f0 03		      beq	.scanned
    285  10dd		       88		      dey
    286  10de		       10 f8		      bpl	.scan
    287  10e0
      0  10e0				   .scanned   lda@PLY	MovePiece,y
      1  10e0		       b9 00 f9 	      lda	MovePiece,y
    289  10e3		       85 97		      sta	fromPiece
    290  10e5
    291  10e5		       c6 8b	   .done      dec	ccur	; pulse colour for valid squares
      0  10e7					      CALL	setCursorColours
      1  10e7				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  10e7				  -FNAME      SETSTR	setCursorColours
      3  10e7				  -	      ECHO	""
      4  10e7				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  10e7				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  10e7				  -	      ERR
      7  10e7					      ENDIF
      8  10e7		       a9 8a		      lda	#BANK_setCursorColours
      9  10e9		       85 3f		      sta	SET_BANK
     10  10eb		       20 4a f8 	      jsr	setCursorColours
    293  10ee
    294  10ee		       98		      tya
    295  10ef		       05 0c		      ora	INPT4
    296  10f1		       30 04		      bmi	.exit	; illegal square or no button press
    297  10f3
      0  10f3					      PHASE	StartSquareSelected
      1  10f3		       a9 03		      lda	#AI_StartSquareSelected
      2  10f5		       85 8c		      sta	aiState
    299  10f7
    300  10f7		       60	   .exit      rts
    301  10f8
    302  10f8
    303  10f8
    304  10f8				   .swapside
    305  10f8
      0  10f8					      PHASE	DebounceSelect
      1  10f8		       a9 2b		      lda	#AI_DebounceSelect
      2  10fa		       85 8c		      sta	aiState
    307  10fc		       60		      rts
    308  10fd
    309  10fd							;---------------------------------------------------------------------------------------------------
    310  10fd
      0  10fd					      DEF	aiDebounceSelect
      1  10fd				   SLOT_aiDebounceSelect SET	_BANK_SLOT
      2  10fd				   BANK_aiDebounceSelect SET	SLOT_aiDebounceSelect + _CURRENT_BANK
      3  10fd				   aiDebounceSelect
      4  10fd				   TEMPORARY_VAR SET	Overlay
      5  10fd				   TEMPORARY_OFFSET SET	0
      6  10fd				   VAR_BOUNDARY_aiDebounceSelect SET	TEMPORARY_OFFSET
      7  10fd				   FUNCTION_NAME SET	aiDebounceSelect
    312  10fd					      SUBROUTINE
    313  10fd
    314  10fd		       ad 82 02 	      lda	SWCHB
    315  1100		       29 02		      and	#SELECT_SWITCH
    316  1102		       f0 17		      beq	.exit	; SELECT still pressed
    317  1104
    318  1104		       a5 96		      lda	sideToMove
    319  1106		       49 40		      eor	#HUMAN
    320  1108		       85 96		      sta	sideToMove
    321  110a
      0  110a					      NEGEVAL
      1  110a
      2  110a		       38		      sec
      3  110b		       a9 00		      lda	#0
      4  110d		       e5 90		      sbc	Evaluation
      5  110f		       85 90		      sta	Evaluation
      6  1111		       a9 00		      lda	#0
      7  1113		       e5 91		      sbc	Evaluation+1
      8  1115		       85 91		      sta	Evaluation+1
      9  1117
    323  1117
      0  1117					      PHASE	ComputerMove
      1  1117		       a9 13		      lda	#AI_ComputerMove
      2  1119		       85 8c		      sta	aiState
    325  111b		       60	   .exit      rts
    326  111c
    327  111c
    328  111c							;---------------------------------------------------------------------------------------------------
    329  111c
      0  111c					      DEF	aiDrawMoves
      1  111c				   SLOT_aiDrawMoves SET	_BANK_SLOT
      2  111c				   BANK_aiDrawMoves SET	SLOT_aiDrawMoves + _CURRENT_BANK
      3  111c				   aiDrawMoves
      4  111c				   TEMPORARY_VAR SET	Overlay
      5  111c				   TEMPORARY_OFFSET SET	0
      6  111c				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      7  111c				   FUNCTION_NAME SET	aiDrawMoves
    331  111c					      SUBROUTINE
    332  111c
      0  111c					      REF	AiStateMachine
      1  111c					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  111c				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  111c					      ENDIF
      0  111c					      VEND	aiDrawMoves
      1  111c
      2  111c
      3  111c		       00 a8	   VAREND_aiDrawMoves =	TEMPORARY_VAR
      4  111c
    335  111c
    336  111c		       c6 8b		      dec	ccur
      0  111e					      CALL	setCursorColours
      1  111e				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  111e				  -FNAME      SETSTR	setCursorColours
      3  111e				  -	      ECHO	""
      4  111e				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  111e				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  111e				  -	      ERR
      7  111e					      ENDIF
      8  111e		       a9 8a		      lda	#BANK_setCursorColours
      9  1120		       85 3f		      sta	SET_BANK
     10  1122		       20 4a f8 	      jsr	setCursorColours
    338  1125
    339  1125		       c6 8a		      dec	mdelay
    340  1127		       d0 25		      bne	.exit
    341  1129		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    342  112b		       85 8a		      sta	mdelay	; once triggered, runs always
    343  112d
    344  112d		       a5 8e		      lda	aiMoveIndex
    345  112f		       10 09		      bpl	.valid
    346  1131
    347  1131		       a9 89		      lda	#RAMBANK_PLY+1
    348  1133		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1135					      lda@PLY	moveIndex
      1  1135		       ad cf f9 	      lda	moveIndex
    350  1138		       85 8e		      sta	aiMoveIndex
    351  113a				   .valid
    352  113a
    353  113a		       20 5b f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    354  113d		       a5 8e		      lda	aiMoveIndex
    355  113f		       10 19		      bpl	.unsure	; still drawing in this phase
    356  1141
    357  1141		       a9 14		      lda	#CAP_SPEED
    358  1143		       85 8a		      sta	mdelay
    359  1145
    360  1145		       a9 00		      lda	#0
    361  1147		       85 8f		      sta	aiFlashPhase	; controls odd/even exit of flashing
    362  1149
      0  1149					      PHASE	ShowMoveCaptures
      1  1149		       a9 05		      lda	#AI_ShowMoveCaptures
      2  114b		       85 8c		      sta	aiState
    364  114d		       60		      rts
    365  114e
    366  114e				   .exit
    367  114e
    368  114e							; Initial piece selection has happened, but the button hasn't been released yet
    369  114e							; AND we're still in the waiting phase to see if the button was held long enough for move show
    370  114e
    371  114e		       a5 0c		      lda	INPT4
    372  1150		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    373  1152
    374  1152							; Aha! Button released, so we know the selected piece and can start flashing it
    375  1152							; and allowing movement of the selector to a destination square...
    376  1152
    377  1152		       a9 18		      lda	#6*4
    378  1154		       85 8b		      sta	ccur	; bright green square for selection
    379  1156
      0  1156					      PHASE	SelectDestinationSquare
      1  1156		       a9 08		      lda	#AI_SelectDestinationSquare
      2  1158		       85 8c		      sta	aiState
    381  115a
    382  115a		       60	   .unsure    rts
    383  115b
    384  115b
    385  115b							;---------------------------------------------------------------------------------------------------
    386  115b
      0  115b					      DEF	showMoveOptions
      1  115b				   SLOT_showMoveOptions SET	_BANK_SLOT
      2  115b				   BANK_showMoveOptions SET	SLOT_showMoveOptions + _CURRENT_BANK
      3  115b				   showMoveOptions
      4  115b				   TEMPORARY_VAR SET	Overlay
      5  115b				   TEMPORARY_OFFSET SET	0
      6  115b				   VAR_BOUNDARY_showMoveOptions SET	TEMPORARY_OFFSET
      7  115b				   FUNCTION_NAME SET	showMoveOptions
    388  115b					      SUBROUTINE
    389  115b
      0  115b					      REF	aiDrawMoves
      1  115b					      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  115b				   TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  115b					      ENDIF
      0  115b					      REF	aiUnDrawTargetSquares
      1  115b				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  115b				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  115b					      ENDIF
    392  115b
      0  115b					      VAR	__saveIdx, 1
      1  115b		       00 a8	   __saveIdx  =	TEMPORARY_VAR
      2  115b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  115b
      4  115b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  115b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  115b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  115b					      ENDIF
      8  115b				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  115b				  -VNAME      SETSTR	__saveIdx
     10  115b				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  115b				  -	      ERR
     12  115b					      ENDIF
      0  115b					      VAR	__piece, 1
      1  115b		       00 a9	   __piece    =	TEMPORARY_VAR
      2  115b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  115b
      4  115b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  115b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  115b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  115b					      ENDIF
      8  115b				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  115b				  -VNAME      SETSTR	__piece
     10  115b				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  115b				  -	      ERR
     12  115b					      ENDIF
    395  115b
      0  115b					      VEND	showMoveOptions
      1  115b
      2  115b
      3  115b		       00 aa	   VAREND_showMoveOptions =	TEMPORARY_VAR
      4  115b
    397  115b
    398  115b							; place a marker on the board for any square matching the piece
    399  115b							; EXCEPT for squares which are occupied (we'll flash those later)
    400  115b
    401  115b		       a6 8e	   .next      ldx	aiMoveIndex
    402  115d		       86 a8		      stx	__saveIdx
    403  115f		       30 4c		      bmi	.skip
    404  1161
    405  1161		       ad 84 02 	      lda	INTIM
    406  1164		       c9 2b		      cmp	#2+SPEEDOF_CopySinglePiece
    407  1166		       90 45		      bcc	.skip
    408  1168
    409  1168		       c6 8e		      dec	aiMoveIndex
    410  116a
    411  116a		       a9 89		      lda	#RAMBANK_PLY+1
    412  116c		       85 3e		      sta	SET_BANK_RAM	;@2
    413  116e
      0  116e					      lda@PLY	MoveFrom,x
      1  116e		       bd 00 f8 	      lda	MoveFrom,x
    415  1171		       c5 86		      cmp	fromX12
    416  1173		       d0 e6		      bne	.next
    417  1175
      0  1175					      lda@PLY	MoveTo,x
      1  1175		       bd 64 f8 	      lda	MoveTo,x
    419  1178		       85 81		      sta	squareToDraw
    420  117a
      0  117a					      lda@PLY	MovePiece,x
      1  117a		       bd 00 f9 	      lda	MovePiece,x
    422  117d		       85 a9		      sta	__piece
    423  117f
    424  117f							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    425  117f							; TODO this could/will fail on sorted lists. MMh.
    426  117f
    427  117f		       ca		      dex
    428  1180		       30 16		      bmi	.prom
    429  1182
      0  1182					      lda@PLY	MoveTo,x
      1  1182		       bd 64 f8 	      lda	MoveTo,x
    431  1185		       c5 81		      cmp	squareToDraw
    432  1187		       d0 0f		      bne	.prom
    433  1189
      0  1189					      lda@PLY	MovePiece,x
      1  1189		       bd 00 f9 	      lda	MovePiece,x
    435  118c		       45 a9		      eor	__piece
    436  118e		       29 0f		      and	#PIECE_MASK
    437  1190		       f0 06		      beq	.prom	; same piece type so not a promote
    438  1192
    439  1192		       c6 8e		      dec	aiMoveIndex
    440  1194		       c6 8e		      dec	aiMoveIndex
    441  1196		       c6 8e		      dec	aiMoveIndex
    442  1198				   .prom
    443  1198
    444  1198		       a4 81		      ldy	squareToDraw
    445  119a
    446  119a		       a9 d7		      lda	#RAMBANK_BOARD
    447  119c		       85 3e		      sta	SET_BANK_RAM	;@3
    448  119e		       b9 79 fc 	      lda	Board,y
    449  11a1		       29 0f		      and	#PIECE_MASK
    450  11a3		       d0 b6		      bne	.next	; don't draw dots on captures - they are flashed later
    451  11a5
    452  11a5
    453  11a5							;lda INTIM
    454  11a5							;cmp #SPEEDOF_CopySinglePiece
    455  11a5							;bcc .skip
    456  11a5
    457  11a5							;lda aiMoveIndex
    458  11a5							;sta __saveIdx
    459  11a5
    460  11a5							; Draw the marker..."?
    461  11a5							; WARNING - local variables will not survive the following call...!
    462  11a5
    463  11a5		       a0 1c		      ldy	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
    464  11a7		       20 b2 f5 	      jsr	CopySetupForMarker	;@this
    465  11aa		       4c c8 f0 	      jmp	InterceptMarkerCopy	;@0
    466  11ad
    467  11ad
    468  11ad
    469  11ad		       a5 a8	   .skip      lda	__saveIdx
    470  11af		       85 8e		      sta	aiMoveIndex
    471  11b1		       60		      rts
    472  11b2
    473  11b2
    474  11b2							;---------------------------------------------------------------------------------------------------
    475  11b2
      0  11b2					      DEF	CopySetupForMarker
      1  11b2				   SLOT_CopySetupForMarker SET	_BANK_SLOT
      2  11b2				   BANK_CopySetupForMarker SET	SLOT_CopySetupForMarker + _CURRENT_BANK
      3  11b2				   CopySetupForMarker
      4  11b2				   TEMPORARY_VAR SET	Overlay
      5  11b2				   TEMPORARY_OFFSET SET	0
      6  11b2				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      7  11b2				   FUNCTION_NAME SET	CopySetupForMarker
    477  11b2					      SUBROUTINE
    478  11b2
      0  11b2					      REF	showMoveOptions
      1  11b2					      IF	VAREND_showMoveOptions > TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	VAREND_showMoveOptions
      3  11b2					      ENDIF
      0  11b2					      REF	showPromoteOptions
      1  11b2					      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  11b2					      ENDIF
    481  11b2
      0  11b2					      VAR	__pieceColour2b, 1
      1  11b2		       00 ee	   __pieceColour2b =	TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  11b2
      4  11b2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  11b2				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  11b2				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  11b2					      ENDIF
      8  11b2				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  11b2				  -VNAME      SETSTR	__pieceColour2b
     10  11b2				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  11b2				  -	      ERR
     12  11b2					      ENDIF
      0  11b2					      VAR	__tmpb, 1
      1  11b2		       00 ef	   __tmpb     =	TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  11b2
      4  11b2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  11b2				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  11b2				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  11b2					      ENDIF
      8  11b2				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  11b2				  -VNAME      SETSTR	__tmpb
     10  11b2				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  11b2				  -	      ERR
     12  11b2					      ENDIF
      0  11b2					      VAR	__shiftxb, 1
      1  11b2		       00 f0	   __shiftxb  =	TEMPORARY_VAR
      2  11b2				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  11b2
      4  11b2				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  11b2					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  11b2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  11b2					      ENDIF
      8  11b2				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  11b2				  -VNAME      SETSTR	__shiftxb
     10  11b2				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  11b2				  -	      ERR
     12  11b2					      ENDIF
    485  11b2
      0  11b2					      VEND	CopySetupForMarker
      1  11b2
      2  11b2
      3  11b2		       00 f1	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
      4  11b2
    487  11b2
    488  11b2
    489  11b2							; y = base shape
    490  11b2							; figure colouration of square
    491  11b2
    492  11b2		       a5 81		      lda	squareToDraw
    493  11b4
    494  11b4		       a2 0a		      ldx	#10
    495  11b6		       38		      sec
    496  11b7		       e9 0a	   .sub10     sbc	#10
    497  11b9		       ca		      dex
    498  11ba		       b0 fb		      bcs	.sub10
    499  11bc		       69 08		      adc	#8
    500  11be		       85 f0		      sta	__shiftxb
    501  11c0		       86 ef		      stx	__tmpb
    502  11c2		       65 ef		      adc	__tmpb
    503  11c4
    504  11c4
    505  11c4		       29 01		      and	#1
    506  11c6							;eor #1
    507  11c6		       f0 02		      beq	.white
    508  11c8		       a9 24		      lda	#36
    509  11ca				   .white
    510  11ca		       85 ee		      sta	__pieceColour2b	; actually SQUARE black/white
    511  11cc
    512  11cc		       a5 96		      lda	sideToMove
    513  11ce		       0a		      asl
    514  11cf		       90 02		      bcc	.blackAdjust
    515  11d1		       09 10		      ora	#16	; switch white pieces
    516  11d3		       4a	   .blackAdjust lsr
    517  11d4		       29 0f		      and	#%1111
    518  11d6		       aa		      tax
    519  11d7
    520  11d7		       a5 f0		      lda	__shiftxb
    521  11d9		       29 03		      and	#3	; shift position in P
    522  11db		       85 f0		      sta	__shiftxb
    523  11dd
    524  11dd		       98		      tya
    525  11de		       18		      clc
    526  11df		       65 f0		      adc	__shiftxb
    527  11e1		       18		      clc
    528  11e2		       65 ee		      adc	__pieceColour2b
    529  11e4		       a8		      tay
    530  11e5		       60		      rts
    531  11e6
    532  11e6
    533  11e6							;---------------------------------------------------------------------------------------------------
    534  11e6
      0  11e6					      DEF	aiUnDrawTargetSquares
      1  11e6				   SLOT_aiUnDrawTargetSquares SET	_BANK_SLOT
      2  11e6				   BANK_aiUnDrawTargetSquares SET	SLOT_aiUnDrawTargetSquares + _CURRENT_BANK
      3  11e6				   aiUnDrawTargetSquares
      4  11e6				   TEMPORARY_VAR SET	Overlay
      5  11e6				   TEMPORARY_OFFSET SET	0
      6  11e6				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      7  11e6				   FUNCTION_NAME SET	aiUnDrawTargetSquares
    536  11e6					      SUBROUTINE
    537  11e6
      0  11e6					      REF	AiStateMachine
      1  11e6					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  11e6				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  11e6					      ENDIF
      0  11e6					      VEND	aiUnDrawTargetSquares
      1  11e6
      2  11e6
      3  11e6		       00 a8	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
      4  11e6
    540  11e6
    541  11e6
    542  11e6		       c6 8b		      dec	ccur
      0  11e8					      CALL	setCursorColours
      1  11e8				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  11e8				  -FNAME      SETSTR	setCursorColours
      3  11e8				  -	      ECHO	""
      4  11e8				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  11e8				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  11e8				  -	      ERR
      7  11e8					      ENDIF
      8  11e8		       a9 8a		      lda	#BANK_setCursorColours
      9  11ea		       85 3f		      sta	SET_BANK
     10  11ec		       20 4a f8 	      jsr	setCursorColours
    544  11ef
    545  11ef		       c6 8a		      dec	mdelay
    546  11f1		       d0 1c		      bne	.exit
    547  11f3		       a9 01		      lda	#1
    548  11f5		       85 8a		      sta	mdelay	; once triggered, runs always
    549  11f7
    550  11f7		       a5 8e		      lda	aiMoveIndex
    551  11f9		       10 09		      bpl	.valid
    552  11fb
    553  11fb		       a9 89		      lda	#RAMBANK_PLY+1
    554  11fd		       85 3e		      sta	SET_BANK_RAM	;@2
      0  11ff					      lda@PLY	moveIndex
      1  11ff		       ad cf f9 	      lda	moveIndex
    556  1202		       85 8e		      sta	aiMoveIndex
    557  1204				   .valid
    558  1204
    559  1204		       20 5b f5 	      jsr	showMoveOptions	; draw potential moves one at a time
    560  1207		       a5 8e		      lda	aiMoveIndex
    561  1209		       10 04		      bpl	.exit	; still drawing in this phase
    562  120b
      0  120b					      PHASE	SelectStartSquare
      1  120b		       a9 02		      lda	#AI_SelectStartSquare
      2  120d		       85 8c		      sta	aiState
    564  120f
    565  120f		       60	   .exit      rts
    566  1210
    567  1210
    568  1210							;---------------------------------------------------------------------------------------------------
    569  1210
    570  1210
      0  1210					      DEF	aiShowMoveCaptures
      1  1210				   SLOT_aiShowMoveCaptures SET	_BANK_SLOT
      2  1210				   BANK_aiShowMoveCaptures SET	SLOT_aiShowMoveCaptures + _CURRENT_BANK
      3  1210				   aiShowMoveCaptures
      4  1210				   TEMPORARY_VAR SET	Overlay
      5  1210				   TEMPORARY_OFFSET SET	0
      6  1210				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      7  1210				   FUNCTION_NAME SET	aiShowMoveCaptures
    572  1210					      SUBROUTINE
    573  1210
      0  1210					      REF	AiStateMachine
      1  1210					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1210				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1210					      ENDIF
      0  1210					      VEND	aiShowMoveCaptures
      1  1210
      2  1210
      3  1210		       00 a8	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
      4  1210
    576  1210
    577  1210							; draw/undraw ALL captured pieces
    578  1210							; we should do this an even number of times so that pieces don't disappear
    579  1210
    580  1210		       c6 8b		      dec	ccur
      0  1212					      CALL	setCursorColours
      1  1212				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1212				  -FNAME      SETSTR	setCursorColours
      3  1212				  -	      ECHO	""
      4  1212				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1212				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1212				  -	      ERR
      7  1212					      ENDIF
      8  1212		       a9 8a		      lda	#BANK_setCursorColours
      9  1214		       85 3f		      sta	SET_BANK
     10  1216		       20 4a f8 	      jsr	setCursorColours
    582  1219
    583  1219		       c6 8a		      dec	mdelay	; flash speed UNVARYING despite draw happening
    584  121b
    585  121b		       a5 8e		      lda	aiMoveIndex
    586  121d		       10 09		      bpl	.valid	; guaranteed -1 on 1st call
    587  121f		       a9 89		      lda	#RAMBANK_PLY+1
    588  1221		       85 3e		      sta	SET_BANK_RAM	;@2
      0  1223					      lda@PLY	moveIndex
      1  1223		       ad cf f9 	      lda	moveIndex
    590  1226		       85 8e		      sta	aiMoveIndex
    591  1228				   .valid
    592  1228
    593  1228							;lda #BANK_showMoveCaptures
    594  1228							;sta SET_BANK;@0
    595  1228
    596  1228		       20 ff f2 	      jsr	showMoveCaptures	;@0
    597  122b		       a5 8e		      lda	aiMoveIndex
    598  122d		       10 06		      bpl	.exit
    599  122f
    600  122f		       e6 8f		      inc	aiFlashPhase
    601  1231
      0  1231					      PHASE	SlowFlash
      1  1231		       a9 06		      lda	#AI_SlowFlash
      2  1233		       85 8c		      sta	aiState
    603  1235
    604  1235		       60	   .exit      rts
    605  1236
    606  1236
    607  1236							;---------------------------------------------------------------------------------------------------
    608  1236
      0  1236					      DEF	aiSlowFlash
      1  1236				   SLOT_aiSlowFlash SET	_BANK_SLOT
      2  1236				   BANK_aiSlowFlash SET	SLOT_aiSlowFlash + _CURRENT_BANK
      3  1236				   aiSlowFlash
      4  1236				   TEMPORARY_VAR SET	Overlay
      5  1236				   TEMPORARY_OFFSET SET	0
      6  1236				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      7  1236				   FUNCTION_NAME SET	aiSlowFlash
    610  1236					      SUBROUTINE
    611  1236
      0  1236					      REF	AiStateMachine
      1  1236					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1236				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1236					      ENDIF
      0  1236					      VEND	aiSlowFlash
      1  1236
      2  1236
      3  1236		       00 a8	   VAREND_aiSlowFlash =	TEMPORARY_VAR
      4  1236
    614  1236
    615  1236							; Joystick button is held down, so we're displaying the available moves
    616  1236							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    617  1236
    618  1236		       c6 8b		      dec	ccur
      0  1238					      CALL	setCursorColours
      1  1238				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  1238				  -FNAME      SETSTR	setCursorColours
      3  1238				  -	      ECHO	""
      4  1238				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1238				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1238				  -	      ERR
      7  1238					      ENDIF
      8  1238		       a9 8a		      lda	#BANK_setCursorColours
      9  123a		       85 3f		      sta	SET_BANK
     10  123c		       20 4a f8 	      jsr	setCursorColours
    620  123f
    621  123f		       a5 8f		      lda	aiFlashPhase
    622  1241		       29 01		      and	#1
    623  1243		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    624  1245
    625  1245		       a5 0c		      lda	INPT4
    626  1247		       30 0d		      bmi	.butpress	; exit on button release
    627  1249
    628  1249				   .notEven
    629  1249
    630  1249							; Wait for delay to expire then back and flash 'em again
    631  1249
    632  1249		       c6 8a		      dec	mdelay
    633  124b		       10 08		      bpl	.slowWait
    634  124d
    635  124d		       a9 14		      lda	#CAP_SPEED
    636  124f		       85 8a		      sta	mdelay
    637  1251
      0  1251					      PHASE	ShowMoveCaptures	; go back and rEORdraw all captures again
      1  1251		       a9 05		      lda	#AI_ShowMoveCaptures
      2  1253		       85 8c		      sta	aiState
    639  1255
    640  1255		       60	   .slowWait  rts
    641  1256
    642  1256
    643  1256		       a9 01	   .butpress  lda	#1
    644  1258		       85 8a		      sta	mdelay
    645  125a
      0  125a					      PHASE	UnDrawTargetSquares
      1  125a		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  125c		       85 8c		      sta	aiState
    647  125e		       60		      rts
    648  125f
    649  125f
    650  125f							;---------------------------------------------------------------------------------------------------
    651  125f
      0  125f					      DEF	aiSelectDestinationSquare
      1  125f				   SLOT_aiSelectDestinationSquare SET	_BANK_SLOT
      2  125f				   BANK_aiSelectDestinationSquare SET	SLOT_aiSelectDestinationSquare + _CURRENT_BANK
      3  125f				   aiSelectDestinationSquare
      4  125f				   TEMPORARY_VAR SET	Overlay
      5  125f				   TEMPORARY_OFFSET SET	0
      6  125f				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      7  125f				   FUNCTION_NAME SET	aiSelectDestinationSquare
    653  125f					      SUBROUTINE
    654  125f
      0  125f					      REF	Variable_PieceShapeBuffer
      1  125f					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  125f				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  125f					      ENDIF
      0  125f					      REF	AiStateMachine
      1  125f				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  125f				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  125f					      ENDIF
      0  125f					      VEND	aiSelectDestinationSquare
      1  125f
      2  125f
      3  125f		       00 ee	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
      4  125f
    658  125f
    659  125f							; Piece is selected and now we're looking for a button press on a destination square
    660  125f							; we flash the piece on-and-off while we're doing that
    661  125f							; Flash the selected piece
    662  125f
    663  125f		       ad 84 02 	      lda	INTIM
    664  1262		       c9 28		      cmp	#ONCEPERFRAME
    665  1264		       90 0e		      bcc	.exit
    666  1266
    667  1266
    668  1266		       c6 8d		      dec	aiFlashDelay
    669  1268		       d0 0a		      bne	.exit	; don't flash
    670  126a		       a9 14		      lda	#CAP_SPEED
    671  126c		       85 8d		      sta	aiFlashDelay
    672  126e
    673  126e		       e6 8f		      inc	aiFlashPhase
    674  1270
    675  1270							; WARNING - local variables will not survive the following call...!
    676  1270		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    677  1273		       60		      rts
    678  1274
    679  1274				   .exit
      0  1274					      CALL	moveCursor	;@2
      1  1274				  -	      IF	SLOT_moveCursor == _BANK_SLOT
      2  1274				  -FNAME      SETSTR	moveCursor
      3  1274				  -	      ECHO	""
      4  1274				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1274				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1274				  -	      ERR
      7  1274					      ENDIF
      8  1274		       a9 8a		      lda	#BANK_moveCursor
      9  1276		       85 3f		      sta	SET_BANK
     10  1278		       20 00 f8 	      jsr	moveCursor
    681  127b
    682  127b		       ad 84 02 	      lda	INTIM
    683  127e		       c9 14		      cmp	#20
    684  1280		       90 3d		      bcc	.noButton
    685  1282
    686  1282
    687  1282		       a4 89		      ldy	cursorX12
    688  1284		       84 87		      sty	toX12
    689  1286
      0  1286					      CALL	GetPiece	;@3
      1  1286				  -	      IF	SLOT_GetPiece == _BANK_SLOT
      2  1286				  -FNAME      SETSTR	GetPiece
      3  1286				  -	      ECHO	""
      4  1286				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  1286				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  1286				  -	      ERR
      7  1286					      ENDIF
      8  1286		       a9 d9		      lda	#BANK_GetPiece
      9  1288		       85 3f		      sta	SET_BANK
     10  128a		       20 01 fc 	      jsr	GetPiece
      0  128d					      CALL	setCursorColours
      1  128d				  -	      IF	SLOT_setCursorColours == _BANK_SLOT
      2  128d				  -FNAME      SETSTR	setCursorColours
      3  128d				  -	      ECHO	""
      4  128d				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  128d				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  128d				  -	      ERR
      7  128d					      ENDIF
      8  128d		       a9 8a		      lda	#BANK_setCursorColours
      9  128f		       85 3f		      sta	SET_BANK
     10  1291		       20 4a f8 	      jsr	setCursorColours
    692  1294
    693  1294
    694  1294							; y = valid square
    695  1294
    696  1294		       a5 0c		      lda	INPT4
    697  1296		       30 27		      bmi	.noButton
    698  1298
    699  1298		       a5 87		      lda	toX12
    700  129a		       c5 86		      cmp	fromX12
    701  129c		       f0 0d		      beq	.cancel
    702  129e
    703  129e		       c0 ff		      cpy	#-1
    704  12a0		       f0 1d		      beq	.noButton	; not a valid square
    705  12a2
    706  12a2		       a5 8f		      lda	aiFlashPhase
    707  12a4		       29 01		      and	#1
    708  12a6		       f0 13		      beq	.done
    709  12a8		       85 8d		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    710  12aa		       60		      rts
    711  12ab
    712  12ab				   .cancel
    713  12ab
    714  12ab		       a5 8f		      lda	aiFlashPhase
    715  12ad		       29 01		      and	#1
    716  12af		       f0 05		      beq	.doCancel
    717  12b1
    718  12b1							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    719  12b1
    720  12b1		       a9 01		      lda	#1
    721  12b3		       85 8d		      sta	aiFlashDelay
    722  12b5		       60		      rts
    723  12b6
    724  12b6
      0  12b6				   .doCancel  PHASE	ReselectDebounce
      1  12b6		       a9 0a		      lda	#AI_ReselectDebounce
      2  12b8		       85 8c		      sta	aiState
    726  12ba		       60		      rts
    727  12bb
      0  12bb				   .done      PHASE	Quiescent	; destination selected!
      1  12bb		       a9 09		      lda	#AI_Quiescent
      2  12bd		       85 8c		      sta	aiState
    729  12bf		       60	   .noButton  rts
    730  12c0
    731  12c0
    732  12c0
    733  12c0
    734  12c0
    735  12c0							;---------------------------------------------------------------------------------------------------
    736  12c0
      0  12c0					      DEF	aiRollPromotionPiece
      1  12c0				   SLOT_aiRollPromotionPiece SET	_BANK_SLOT
      2  12c0				   BANK_aiRollPromotionPiece SET	SLOT_aiRollPromotionPiece + _CURRENT_BANK
      3  12c0				   aiRollPromotionPiece
      4  12c0				   TEMPORARY_VAR SET	Overlay
      5  12c0				   TEMPORARY_OFFSET SET	0
      6  12c0				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      7  12c0				   FUNCTION_NAME SET	aiRollPromotionPiece
    738  12c0					      SUBROUTINE
    739  12c0
      0  12c0					      REF	AiStateMachine
      1  12c0					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  12c0				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  12c0					      ENDIF
      0  12c0					      VEND	aiRollPromotionPiece
      1  12c0
      2  12c0
      3  12c0		       00 a8	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
      4  12c0
    742  12c0
    743  12c0							; Flash the '?' and wait for an UDLR move
    744  12c0
    745  12c0		       ad 84 02 	      lda	INTIM
    746  12c3		       c9 29		      cmp	#SPEEDOF_CopySinglePiece
    747  12c5		       90 2b		      bcc	.exit
    748  12c7
    749  12c7		       ad 80 02 	      lda	SWCHA
    750  12ca		       29 f0		      and	#$F0
    751  12cc		       c9 f0		      cmp	#$F0
    752  12ce		       f0 0a		      beq	.nojoy
    753  12d0
    754  12d0		       a9 00		      lda	#0
    755  12d2		       85 8d		      sta	aiFlashDelay
    756  12d4
    757  12d4		       a5 8f		      lda	aiFlashPhase
    758  12d6		       29 01		      and	#1
    759  12d8		       f0 19		      beq	.even
    760  12da
    761  12da		       a5 8d	   .nojoy     lda	aiFlashDelay
    762  12dc		       f0 03		      beq	.do
    763  12de		       c6 8d		      dec	aiFlashDelay
    764  12e0		       60		      rts
    765  12e1
    766  12e1				   .do
    767  12e1		       a9 1e		      lda	#30
    768  12e3		       85 8d		      sta	aiFlashDelay	; speed of "?" flashing
    769  12e5
    770  12e5
    771  12e5		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    772  12e7		       a5 96		      lda	sideToMove
    773  12e9		       10 02		      bpl	.wtm
    774  12eb		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    775  12ed				   .wtm
    776  12ed		       20 07 f7 	      jsr	showPromoteOptions	; draw the "?"
    777  12f0
    778  12f0		       e6 8f		      inc	aiFlashPhase
    779  12f2
    780  12f2		       60	   .exit      rts
    781  12f3
    782  12f3
    783  12f3		       a9 03	   .even      lda	#3	; QUEEN
    784  12f5		       85 97		      sta	fromPiece	; cycles as index to NBRQ
    785  12f7
    786  12f7							;inc aiFlashPhase
    787  12f7
    788  12f7		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    789  12f9		       a5 96		      lda	sideToMove
    790  12fb		       10 02		      bpl	.blackStuff
    791  12fd		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    792  12ff				   .blackStuff
    793  12ff
    794  12ff		       20 07 f7 	      jsr	showPromoteOptions	; draw the initial Q
    795  1302
      0  1302					      PHASE	ChooseDebounce
      1  1302		       a9 22		      lda	#AI_ChooseDebounce
      2  1304		       85 8c		      sta	aiState
    797  1306		       60		      rts
    798  1307
    799  1307
    800  1307							;---------------------------------------------------------------------------------------------------
    801  1307
      0  1307					      DEF	showPromoteOptions
      1  1307				   SLOT_showPromoteOptions SET	_BANK_SLOT
      2  1307				   BANK_showPromoteOptions SET	SLOT_showPromoteOptions + _CURRENT_BANK
      3  1307				   showPromoteOptions
      4  1307				   TEMPORARY_VAR SET	Overlay
      5  1307				   TEMPORARY_OFFSET SET	0
      6  1307				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      7  1307				   FUNCTION_NAME SET	showPromoteOptions
    803  1307					      SUBROUTINE
    804  1307
      0  1307					      REF	aiRollPromotionPiece	;✅
      1  1307					      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  1307				   TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  1307					      ENDIF
      0  1307					      REF	aiChoosePromotePiece	;✅
      1  1307					      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  1307				   TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  1307					      ENDIF
      0  1307					      VEND	showPromoteOptions
      1  1307
      2  1307
      3  1307		       00 ee	   VAREND_showPromoteOptions =	TEMPORARY_VAR
      4  1307
    808  1307
    809  1307							; X = character shape # (?/N/B/R/Q)
    810  1307
    811  1307		       a4 87		      ldy	toX12
    812  1309		       84 81		      sty	squareToDraw
    813  130b
    814  130b		       8a		      txa
    815  130c		       a8		      tay
    816  130d
    817  130d		       20 b2 f5 	      jsr	CopySetupForMarker	;@this
    818  1310		       4c c8 f0 	      jmp	InterceptMarkerCopy	;@0
    819  1313
    820  1313
    821  1313							;---------------------------------------------------------------------------------------------------
    822  1313
      0  1313					      DEF	aiChoosePromotePiece
      1  1313				   SLOT_aiChoosePromotePiece SET	_BANK_SLOT
      2  1313				   BANK_aiChoosePromotePiece SET	SLOT_aiChoosePromotePiece + _CURRENT_BANK
      3  1313				   aiChoosePromotePiece
      4  1313				   TEMPORARY_VAR SET	Overlay
      5  1313				   TEMPORARY_OFFSET SET	0
      6  1313				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      7  1313				   FUNCTION_NAME SET	aiChoosePromotePiece
    824  1313					      SUBROUTINE
    825  1313
      0  1313					      REF	Variable_PieceShapeBuffer
      1  1313					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1313				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1313					      ENDIF
      0  1313					      REF	AiStateMachine
      1  1313				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1313				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1313					      ENDIF
      0  1313					      VEND	aiChoosePromotePiece
      1  1313
      2  1313
      3  1313		       00 ee	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
      4  1313
    829  1313
    830  1313							; Question-mark phase has exited via joystick direction
    831  1313							; Now we cycle through the selectable pieces
    832  1313
    833  1313		       ad 84 02 	      lda	INTIM
    834  1316		       c9 29		      cmp	#SPEEDOF_CopySinglePiece
    835  1318		       90 4e		      bcc	.exit
    836  131a
    837  131a		       a5 0c		      lda	INPT4
    838  131c		       30 0a		      bmi	.nobut	; no press
    839  131e
    840  131e							; button pressed but make sure phase is correct for exit
    841  131e
    842  131e		       a9 01		      lda	#1
    843  1320		       85 8d		      sta	aiFlashDelay	; force quick rehash to this if phase incorrect
    844  1322
    845  1322		       a5 8f		      lda	aiFlashPhase
    846  1324		       29 01		      and	#1
    847  1326		       f0 41		      beq	.chosen	; button pressed --> selection made
    848  1328				   .nobut
    849  1328
    850  1328		       ad 80 02 	      lda	SWCHA
    851  132b		       29 f0		      and	#$F0
    852  132d		       c9 f0		      cmp	#$F0
    853  132f		       f0 04		      beq	.nodir	; no direction pressed
    854  1331
    855  1331
    856  1331		       a9 01		      lda	#1
    857  1333		       85 8d		      sta	aiFlashDelay
    858  1335
    859  1335
    860  1335		       c6 8d	   .nodir     dec	aiFlashDelay
    861  1337		       d0 2f		      bne	.exit
    862  1339
    863  1339		       a9 1e		      lda	#30
    864  133b		       85 8d		      sta	aiFlashDelay
    865  133d
    866  133d		       a5 8f		      lda	aiFlashPhase
    867  133f		       4a		      lsr
    868  1340		       b0 1c		      bcs	.odd	; must wait until piece undrawn
    869  1342
    870  1342		       ad 80 02 	      lda	SWCHA
    871  1345		       29 f0		      and	#$F0
    872  1347		       c9 f0		      cmp	#$F0
    873  1349		       f0 13		      beq	.odd	; no direction pressed
    874  134b
    875  134b		       4a		      lsr
    876  134c		       4a		      lsr
    877  134d		       4a		      lsr
    878  134e		       4a		      lsr
    879  134f		       a8		      tay
    880  1350
    881  1350
    882  1350							; cycle to the next promotable piece (N/B/R/Q)
    883  1350							; TODO; use joy table for mod instead of just incrementing all the time
    884  1350
    885  1350		       18		      clc
    886  1351		       a5 97		      lda	fromPiece
    887  1353		       79 65 f8 	      adc	JoyCombined,y
    888  1356		       29 03		      and	#3
    889  1358		       85 97		      sta	fromPiece
    890  135a
      0  135a					      PHASE	ChooseDebounce	; after draw, wait for release
      1  135a		       a9 22		      lda	#AI_ChooseDebounce
      2  135c		       85 8c		      sta	aiState
    892  135e
    893  135e				   .odd
    894  135e
    895  135e				   .force
    896  135e		       e6 8f		      inc	aiFlashPhase	; on/off toggle
    897  1360
    898  1360		       a4 97		      ldy	fromPiece
    899  1362		       be 88 f7 	      ldx	promotePiece,y
    900  1365		       20 07 f7 	      jsr	showPromoteOptions	;@this
    901  1368
    902  1368		       60	   .exit      rts
    903  1369
    904  1369
    905  1369
    906  1369
    907  1369
    908  1369
    909  1369				   .chosen
    910  1369		       a5 97		      lda	fromPiece
    911  136b		       29 0f		      and	#PIECE_MASK
    912  136d		       aa		      tax
    913  136e
    914  136e		       bd 8c f7 	      lda	promoteType,x
    915  1371		       85 97		      sta	fromPiece
    916  1373
    917  1373		       a4 87		      ldy	toX12
    918  1375		       a9 d7		      lda	#RAMBANK_BOARD
    919  1377		       85 3e		      sta	SET_BANK_RAM	;@3
    920  1379		       b9 79 fc 	      lda	Board,y
    921  137c		       29 0f		      and	#PIECE_MASK
    922  137e		       f0 03		      beq	.nothing
    923  1380
    924  1380		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; put back whatever was there to start
    925  1383
      0  1383				   .nothing   PHASE	MoveIsSelected
      1  1383		       a9 14		      lda	#AI_MoveIsSelected
      2  1385		       85 8c		      sta	aiState
    927  1387		       60		      rts
    928  1388
      0  1388					      ALLOCATE	promotePiece, 4
      1  1388
      2  1388				   .NAME      SETSTR	promotePiece
      0  1388					      OPTIONAL_PAGEBREAK	.NAME, 4
      1  1388
      2  1388				  -	      IF	(>( * + 4 -1 )) > ( >* )
      3  1388				  -.EARLY_LOCATION SET	*
      4  1388				  -	      ALIGN	256
      5  1388				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  1388					      ENDIF
      0  1388					      DEF	promotePiece
      1  1388				   SLOT_promotePiece SET	_BANK_SLOT
      2  1388				   BANK_promotePiece SET	SLOT_promotePiece + _CURRENT_BANK
      3  1388				   promotePiece
      4  1388				   TEMPORARY_VAR SET	Overlay
      5  1388				   TEMPORARY_OFFSET SET	0
      6  1388				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      7  1388				   FUNCTION_NAME SET	promotePiece
      5  1388
    930  1388		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    931  1389		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    932  138a		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    933  138b		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    934  138c
      0  138c					      ALLOCATE	promoteType,4
      1  138c
      2  138c				   .NAME      SETSTR	promoteType
      0  138c					      OPTIONAL_PAGEBREAK	.NAME, 4
      1  138c
      2  138c				  -	      IF	(>( * + 4 -1 )) > ( >* )
      3  138c				  -.EARLY_LOCATION SET	*
      4  138c				  -	      ALIGN	256
      5  138c				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  138c					      ENDIF
      0  138c					      DEF	promoteType
      1  138c				   SLOT_promoteType SET	_BANK_SLOT
      2  138c				   BANK_promoteType SET	SLOT_promoteType + _CURRENT_BANK
      3  138c				   promoteType
      4  138c				   TEMPORARY_VAR SET	Overlay
      5  138c				   TEMPORARY_OFFSET SET	0
      6  138c				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      7  138c				   FUNCTION_NAME SET	promoteType
      5  138c
    936  138c		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    937  1390
    938  1390
    939  1390							;---------------------------------------------------------------------------------------------------
    940  1390
      0  1390					      DEF	aiMarchA2
      1  1390				   SLOT_aiMarchA2 SET	_BANK_SLOT
      2  1390				   BANK_aiMarchA2 SET	SLOT_aiMarchA2 + _CURRENT_BANK
      3  1390				   aiMarchA2
      4  1390				   TEMPORARY_VAR SET	Overlay
      5  1390				   TEMPORARY_OFFSET SET	0
      6  1390				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      7  1390				   FUNCTION_NAME SET	aiMarchA2
    942  1390					      SUBROUTINE
    943  1390
      0  1390					      REF	Variable_PieceShapeBuffer
      1  1390					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1390				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1390					      ENDIF
      0  1390					      REF	AiStateMachine
      1  1390				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1390				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1390					      ENDIF
      0  1390					      VEND	aiMarchA2
      1  1390
      2  1390
      3  1390		       00 ee	   VAREND_aiMarchA2 =	TEMPORARY_VAR
      4  1390
    947  1390
    948  1390							; erase object in new sqare --> blank
    949  1390
    950  1390		       a4 86		      ldy	fromX12
    951  1392		       84 81		      sty	squareToDraw
    952  1394
    953  1394		       a9 d7		      lda	#RAMBANK_BOARD
    954  1396		       85 3e		      sta	SET_BANK_RAM	;@3
    955  1398		       b9 79 fc 	      lda	Board,y
    956  139b		       f0 03		      beq	.skipbl
    957  139d
    958  139d							; WARNING - local variables will not survive the following call...!
    959  139d		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; erase next square along --> blank
    960  13a0
    961  13a0				   .skipbl
    962  13a0		       a4 86		      ldy	fromX12
    963  13a2		       84 a9		      sty	__boardIndex
    964  13a4
    965  13a4		       a9 d7		      lda	#RAMBANK_BOARD
    966  13a6		       85 3e		      sta	SET_BANK_RAM	;@3
    967  13a8		       b9 79 fc 	      lda	Board,y
    968  13ab		       85 98		      sta	lastPiece	; what we are overwriting
    969  13ad		       a5 97		      lda	fromPiece
    970  13af		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    971  13b1		       29 df		      and	#~FLAG_ENPASSANT
    972  13b3		       a4 a9		      ldy	__boardIndex
      0  13b5					      sta@RAM	Board,y	; and what's actually moving there
      1  13b5		       99 79 fe 	      sta	[RAM]+Board,y
    974  13b8
    975  13b8
      0  13b8					      PHASE	MarchB
      1  13b8		       a9 18		      lda	#AI_MarchB
      2  13ba		       85 8c		      sta	aiState
    977  13bc		       60		      rts
    978  13bd
    979  13bd
    980  13bd							;---------------------------------------------------------------------------------------------------
    981  13bd
      0  13bd					      DEF	aiMarchB2
      1  13bd				   SLOT_aiMarchB2 SET	_BANK_SLOT
      2  13bd				   BANK_aiMarchB2 SET	SLOT_aiMarchB2 + _CURRENT_BANK
      3  13bd				   aiMarchB2
      4  13bd				   TEMPORARY_VAR SET	Overlay
      5  13bd				   TEMPORARY_OFFSET SET	0
      6  13bd				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      7  13bd				   FUNCTION_NAME SET	aiMarchB2
    983  13bd					      SUBROUTINE
    984  13bd
      0  13bd					      REF	Variable_PieceShapeBuffer
      1  13bd					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  13bd				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  13bd					      ENDIF
      0  13bd					      REF	AiStateMachine
      1  13bd				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  13bd				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  13bd					      ENDIF
      0  13bd					      VEND	aiMarchB2
      1  13bd
      2  13bd
      3  13bd		       00 ee	   VAREND_aiMarchB2 =	TEMPORARY_VAR
      4  13bd
    988  13bd
    989  13bd		       a4 84		      ldy	lastSquareX12
    990  13bf		       84 81		      sty	squareToDraw
    991  13c1
    992  13c1		       a9 d7		      lda	#RAMBANK_BOARD
    993  13c3		       85 3e		      sta	SET_BANK_RAM	;@3
    994  13c5		       b9 79 fc 	      lda	Board,y
    995  13c8		       f0 03		      beq	.skipbl2
    996  13ca
    997  13ca							; WARNING - local variables will not survive the following call...!
    998  13ca		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; draw previous piece back in old position
    999  13cd				   .skipbl2
   1000  13cd
   1001  13cd		       a5 86		      lda	fromX12
   1002  13cf		       c5 87		      cmp	toX12
   1003  13d1		       f0 09		      beq	xhalt
   1004  13d3
   1005  13d3		       a9 02		      lda	#2	;??? inter-move segment speed (can be 0)
   1006  13d5		       85 83		      sta	drawDelay
      0  13d7					      PHASE	MarchToTargetA
      1  13d7		       a9 16		      lda	#AI_MarchToTargetA
      2  13d9		       85 8c		      sta	aiState
   1008  13db
   1009  13db		       60		      rts
   1010  13dc
      0  13dc				   xhalt      PHASE	EPHandler
      1  13dc		       a9 29		      lda	#AI_EPHandler
      2  13de		       85 8c		      sta	aiState
   1012  13e0		       60		      rts
   1013  13e1
   1014  13e1
   1015  13e1
   1016  13e1
   1017  13e1							;---------------------------------------------------------------------------------------------------
   1018  13e1
      0  13e1					      END_BANK
      1  13e1				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  13e1				  -	      CHECK_RAM_BANK_SIZE
      3  13e1					      ELSE
      0  13e1					      CHECK_BANK_SIZE
      1  13e1		       03 e1	   .TEMP      =	* - _BANK_START
 ROM bank # 5 STATEMACHINE size = $3e1 free = 30
      2  13e1					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  13e1				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  13e1				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  13e1				  -	      ERR
      6  13e1					      ENDIF
      5  13e1					      ENDIF
   1020  13e1
   1021  13e1							;---------------------------------------------------------------------------------------------------
   1022  13e1							; EOF
------- FILE ./chess.asm
------- FILE @1 STATE MACHINE #2.asm LEVEL 2 PASS 4
      0  13e1					      include	"@1 STATE MACHINE #2.asm"
      1  13e1							;---------------------------------------------------------------------------------------------------
      2  13e1							; @1 STATE MACHINE #2.asm
      3  13e1
      4  13e1							; Atari 2600 Chess
      5  13e1							; Copyright (c) 2019-2020 Andrew Davie
      6  13e1							; andrew@taswegian.com
      7  13e1
      8  13e1
      9  13e1							;---------------------------------------------------------------------------------------------------
     10  13e1
      0  13e1					      SLOT	1
      1  13e1
      2  13e1				  -	      IF	(1 < 0) || (1 > 3)
      3  13e1				  -	      ECHO	"Illegal bank address/segment location", 1
      4  13e1				  -	      ERR
      5  13e1					      ENDIF
      6  13e1
      7  13e1				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  13e1				   _BANK_SLOT SET	1 * 64
      9  13e1
      0  13e1					      ROMBANK	STATEMACHINE2
      1  1628 ????				      SEG	ROM_STATEMACHINE2
      2  1400					      ORG	_ORIGIN
      3  1400					      RORG	_BANK_ADDRESS_ORIGIN
      4  1400				   _BANK_START SET	*
      5  1400				   STATEMACHINE2_START SET	*
      6  1400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1400				   ROMBANK_STATEMACHINE2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1400				   _LAST_BANK SETSTR	STATEMACHINE2
     10  1400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1400
     14  1400
     15  1400							;---------------------------------------------------------------------------------------------------
     16  1400
      0  1400					      DEF	aiChooseDebounce
      1  1400				   SLOT_aiChooseDebounce SET	_BANK_SLOT
      2  1400				   BANK_aiChooseDebounce SET	SLOT_aiChooseDebounce + _CURRENT_BANK
      3  1400				   aiChooseDebounce
      4  1400				   TEMPORARY_VAR SET	Overlay
      5  1400				   TEMPORARY_OFFSET SET	0
      6  1400				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      7  1400				   FUNCTION_NAME SET	aiChooseDebounce
     18  1400					      SUBROUTINE
     19  1400
      0  1400					      REF	AiStateMachine
      1  1400					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1400				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1400					      ENDIF
      0  1400					      VEND	aiChooseDebounce
      1  1400
      2  1400
      3  1400		       00 a8	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
      4  1400
     22  1400
     23  1400							; We've changed promotion piece, and drawn it
     24  1400							; wait for joystick to be released before continuing
     25  1400
     26  1400		       ad 80 02 	      lda	SWCHA
     27  1403		       29 f0		      and	#$F0
     28  1405		       c9 f0		      cmp	#$F0
     29  1407		       d0 0a		      bne	.exit	; wait while joystick still pressed
     30  1409
     31  1409		       a9 01		      lda	#1
     32  140b		       85 8d		      sta	aiFlashDelay
     33  140d		       85 8f		      sta	aiFlashPhase
     34  140f
      0  140f					      PHASE	ChoosePromotePiece
      1  140f		       a9 21		      lda	#AI_ChoosePromotePiece
      2  1411		       85 8c		      sta	aiState
     36  1413		       60	   .exit      rts
     37  1414
     38  1414
     39  1414							;---------------------------------------------------------------------------------------------------
     40  1414
      0  1414					      DEF	aiReselectDebounce
      1  1414				   SLOT_aiReselectDebounce SET	_BANK_SLOT
      2  1414				   BANK_aiReselectDebounce SET	SLOT_aiReselectDebounce + _CURRENT_BANK
      3  1414				   aiReselectDebounce
      4  1414				   TEMPORARY_VAR SET	Overlay
      5  1414				   TEMPORARY_OFFSET SET	0
      6  1414				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      7  1414				   FUNCTION_NAME SET	aiReselectDebounce
     42  1414					      SUBROUTINE
     43  1414
      0  1414					      REF	AiStateMachine
      1  1414					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1414				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1414					      ENDIF
      0  1414					      VEND	aiReselectDebounce
      1  1414
      2  1414
      3  1414		       00 a8	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
      4  1414
     46  1414
     47  1414							; We've just cancelled the move. Wait for the button to be released
     48  1414							; and then go back to selecting a piece to move
     49  1414
     50  1414		       a5 0c		      lda	INPT4
     51  1416		       10 04		      bpl	.exit	; button still pressed, so wait
     52  1418
      0  1418					      PHASE	SelectStartSquare
      1  1418		       a9 02		      lda	#AI_SelectStartSquare
      2  141a		       85 8c		      sta	aiState
     54  141c		       60	   .exit      rts
     55  141d
     56  141d
     57  141d							;---------------------------------------------------------------------------------------------------
     58  141d
      0  141d					      DEF	aiDelayAfterMove
      1  141d				   SLOT_aiDelayAfterMove SET	_BANK_SLOT
      2  141d				   BANK_aiDelayAfterMove SET	SLOT_aiDelayAfterMove + _CURRENT_BANK
      3  141d				   aiDelayAfterMove
      4  141d				   TEMPORARY_VAR SET	Overlay
      5  141d				   TEMPORARY_OFFSET SET	0
      6  141d				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      7  141d				   FUNCTION_NAME SET	aiDelayAfterMove
     60  141d					      SUBROUTINE
     61  141d
      0  141d					      REF	AiStateMachine
      1  141d					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  141d				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  141d					      ENDIF
      0  141d					      VEND	aiDelayAfterMove
      1  141d
      2  141d
      3  141d		       00 a8	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
      4  141d
     64  141d
     65  141d		       a9 32		      lda	#50
     66  141f		       85 8d		      sta	aiFlashDelay
      0  1421					      PHASE	DelayAfterMove2
      1  1421		       a9 26		      lda	#AI_DelayAfterMove2
      2  1423		       85 8c		      sta	aiState
     68  1425		       60	   .exit      rts
     69  1426
     70  1426
     71  1426							;---------------------------------------------------------------------------------------------------
     72  1426
      0  1426					      DEF	aiDelayAfterMove2
      1  1426				   SLOT_aiDelayAfterMove2 SET	_BANK_SLOT
      2  1426				   BANK_aiDelayAfterMove2 SET	SLOT_aiDelayAfterMove2 + _CURRENT_BANK
      3  1426				   aiDelayAfterMove2
      4  1426				   TEMPORARY_VAR SET	Overlay
      5  1426				   TEMPORARY_OFFSET SET	0
      6  1426				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      7  1426				   FUNCTION_NAME SET	aiDelayAfterMove2
     74  1426					      SUBROUTINE
     75  1426
      0  1426					      REF	AiStateMachine
      1  1426					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1426				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1426					      ENDIF
      0  1426					      VEND	aiDelayAfterMove
      1  1426
      2  1426
      3  1426		       00 a8	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
      4  1426
     78  1426
     79  1426		       c6 8d		      dec	aiFlashDelay
     80  1428		       d0 04		      bne	.exit
      0  142a					      PHASE	MoveIsSelected
      1  142a		       a9 14		      lda	#AI_MoveIsSelected
      2  142c		       85 8c		      sta	aiState
     82  142e		       60	   .exit      rts
     83  142f
     84  142f
     85  142f							;---------------------------------------------------------------------------------------------------
     86  142f
      0  142f					      DEF	aiDelayAfterPlaced
      1  142f				   SLOT_aiDelayAfterPlaced SET	_BANK_SLOT
      2  142f				   BANK_aiDelayAfterPlaced SET	SLOT_aiDelayAfterPlaced + _CURRENT_BANK
      3  142f				   aiDelayAfterPlaced
      4  142f				   TEMPORARY_VAR SET	Overlay
      5  142f				   TEMPORARY_OFFSET SET	0
      6  142f				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      7  142f				   FUNCTION_NAME SET	aiDelayAfterPlaced
     88  142f					      SUBROUTINE
     89  142f
      0  142f					      REF	AiStateMachine
      1  142f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  142f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  142f					      ENDIF
      0  142f					      VEND	aiDelayAfterPlaced
      1  142f
      2  142f
      3  142f		       00 a8	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
      4  142f
     92  142f
     93  142f		       a2 4b		      ldx	#75	; delay after human move
     94  1431		       a5 96		      lda	sideToMove
     95  1433		       0a		      asl
     96  1434		       30 02		      bmi	.human
     97  1436		       a2 01		      ldx	#1	; delay after computer move
     98  1438		       86 8d	   .human     stx	aiFlashDelay
     99  143a
      0  143a					      PHASE	DelayAfterPlaced2
      1  143a		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  143c		       85 8c		      sta	aiState
    101  143e		       60		      rts
    102  143f
    103  143f
    104  143f							;---------------------------------------------------------------------------------------------------
    105  143f
      0  143f					      DEF	aiDelayAfterPlaced2
      1  143f				   SLOT_aiDelayAfterPlaced2 SET	_BANK_SLOT
      2  143f				   BANK_aiDelayAfterPlaced2 SET	SLOT_aiDelayAfterPlaced2 + _CURRENT_BANK
      3  143f				   aiDelayAfterPlaced2
      4  143f				   TEMPORARY_VAR SET	Overlay
      5  143f				   TEMPORARY_OFFSET SET	0
      6  143f				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      7  143f				   FUNCTION_NAME SET	aiDelayAfterPlaced2
    107  143f					      SUBROUTINE
    108  143f
      0  143f					      REF	AiStateMachine
      1  143f					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  143f				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  143f					      ENDIF
      0  143f					      VEND	aiDelayAfterPlaced2
      1  143f
      2  143f
      3  143f		       00 a8	   VAREND_aiDelayAfterPlaced2 =	TEMPORARY_VAR
      4  143f
    111  143f
    112  143f
    113  143f		       ad 82 02 	      lda	SWCHB
    114  1442		       29 02		      and	#SELECT_SWITCH
    115  1444		       d0 05		      bne	.noSwapside
    116  1446
      0  1446					      PHASE	DebounceSelect
      1  1446		       a9 2b		      lda	#AI_DebounceSelect
      2  1448		       85 8c		      sta	aiState
    118  144a		       60		      rts
    119  144b				   .noSwapside
    120  144b
    121  144b
    122  144b		       c6 8d		      dec	aiFlashDelay
    123  144d		       d0 04		      bne	.exit
    124  144f
    125  144f							;SWAP
    126  144f
      0  144f					      PHASE	GenerateMoves
      1  144f		       a9 12		      lda	#AI_GenerateMoves
      2  1451		       85 8c		      sta	aiState
    128  1453		       60	   .exit      rts
    129  1454
    130  1454
    131  1454							;---------------------------------------------------------------------------------------------------
    132  1454
      0  1454					      DEF	aiMarchToTargetB
      1  1454				   SLOT_aiMarchToTargetB SET	_BANK_SLOT
      2  1454				   BANK_aiMarchToTargetB SET	SLOT_aiMarchToTargetB + _CURRENT_BANK
      3  1454				   aiMarchToTargetB
      4  1454				   TEMPORARY_VAR SET	Overlay
      5  1454				   TEMPORARY_OFFSET SET	0
      6  1454				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      7  1454				   FUNCTION_NAME SET	aiMarchToTargetB
    134  1454					      SUBROUTINE
    135  1454
      0  1454					      REF	Variable_PieceShapeBuffer
      1  1454					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1454				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1454					      ENDIF
      0  1454					      REF	AiStateMachine
      1  1454				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1454				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1454					      ENDIF
      0  1454					      VEND	aiMarchToTargetB
      1  1454
      2  1454
      3  1454		       00 ee	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
      4  1454
    139  1454
    140  1454							; now we want to undraw the piece in the old square
    141  1454
    142  1454		       a5 83		      lda	drawDelay
    143  1456		       f0 03		      beq	.stepOne
    144  1458		       c6 83		      dec	drawDelay
    145  145a		       60		      rts
    146  145b
    147  145b				   .stepOne
    148  145b		       a5 84		      lda	lastSquareX12
    149  145d		       85 81		      sta	squareToDraw
    150  145f
    151  145f							; WARNING - local variables will not survive the following call...!
    152  145f		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; erase whatever was on the previous square (completely blank)
    153  1462
    154  1462		       a4 84		      ldy	lastSquareX12
    155  1464		       a5 99		      lda	previousPiece
    156  1466
    157  1466		       a2 d7		      ldx	#RAMBANK_BOARD
    158  1468		       86 3e		      stx	SET_BANK_RAM	;@3
      0  146a					      sta@RAM	Board,y	; and what's actually moving there
      1  146a		       99 79 fe 	      sta	[RAM]+Board,y
    160  146d
    161  146d		       a5 98		      lda	lastPiece
    162  146f		       85 99		      sta	previousPiece
    163  1471
      0  1471					      PHASE	MarchB2
      1  1471		       a9 1a		      lda	#AI_MarchB2
      2  1473		       85 8c		      sta	aiState
    165  1475		       60		      rts
    166  1476
    167  1476
    168  1476							;---------------------------------------------------------------------------------------------------
    169  1476
      0  1476					      DEF	aiPromotePawnStart
      1  1476				   SLOT_aiPromotePawnStart SET	_BANK_SLOT
      2  1476				   BANK_aiPromotePawnStart SET	SLOT_aiPromotePawnStart + _CURRENT_BANK
      3  1476				   aiPromotePawnStart
      4  1476				   TEMPORARY_VAR SET	Overlay
      5  1476				   TEMPORARY_OFFSET SET	0
      6  1476				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      7  1476				   FUNCTION_NAME SET	aiPromotePawnStart
    171  1476					      SUBROUTINE
    172  1476
      0  1476					      REF	Variable_PieceShapeBuffer
      1  1476					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1476				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1476					      ENDIF
      0  1476					      REF	AiStateMachine
      1  1476				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1476				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1476					      ENDIF
      0  1476					      VEND	aiPromotePawnStart
      1  1476
      2  1476
      3  1476		       00 ee	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
      4  1476
    176  1476
    177  1476
    178  1476		       ad 84 02 	      lda	INTIM
    179  1479		       c9 29		      cmp	#SPEEDOF_CopySinglePiece
    180  147b		       90 1c		      bcc	.exit
    181  147d
    182  147d		       a9 00		      lda	#0
    183  147f		       85 8f		      sta	aiFlashPhase
    184  1481		       85 8d		      sta	aiFlashDelay
    185  1483
    186  1483		       a4 87		      ldy	toX12
    187  1485		       84 81		      sty	squareToDraw
    188  1487
    189  1487		       a9 d7		      lda	#RAMBANK_BOARD
    190  1489		       85 3e		      sta	SET_BANK_RAM	;@3
    191  148b		       b9 79 fc 	      lda	Board,y
    192  148e		       29 0f		      and	#PIECE_MASK
    193  1490		       f0 03		      beq	.empty
    194  1492
    195  1492							; WARNING - local variables will not survive the following call...!
    196  1492		       20 c1 f0 	      jsr	CopySinglePiece	;@0	      ; remove any capturable piece for display purposes
    197  1495
      0  1495				   .empty     PHASE	RollPromotionPiece
      1  1495		       a9 20		      lda	#AI_RollPromotionPiece
      2  1497		       85 8c		      sta	aiState
    199  1499		       60	   .exit      rts
    200  149a
    201  149a
    202  149a							;---------------------------------------------------------------------------------------------------
    203  149a
      0  149a					      DEF	aiGenerateMoves
      1  149a				   SLOT_aiGenerateMoves SET	_BANK_SLOT
      2  149a				   BANK_aiGenerateMoves SET	SLOT_aiGenerateMoves + _CURRENT_BANK
      3  149a				   aiGenerateMoves
      4  149a				   TEMPORARY_VAR SET	Overlay
      5  149a				   TEMPORARY_OFFSET SET	0
      6  149a				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      7  149a				   FUNCTION_NAME SET	aiGenerateMoves
    205  149a					      SUBROUTINE
    206  149a
      0  149a					      REF	AiStateMachine
      1  149a					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  149a				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  149a					      ENDIF
      0  149a					      VEND	aiGenerateMoves
      1  149a
      2  149a
      3  149a		       00 a8	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
      4  149a
    209  149a
    210  149a							;	      CALL Breaker
    211  149a
    212  149a		       a5 87		      lda	toX12
    213  149c		       85 81		      sta	squareToDraw	; for showing move (display square)
    214  149e
    215  149e		       a5 96		      lda	sideToMove
    216  14a0		       0a		      asl
    217  14a1		       30 05		      bmi	.player
    218  14a3
    219  14a3
      0  14a3				   .computer  PHASE	ComputerMove	; computer select move
      1  14a3		       a9 13		      lda	#AI_ComputerMove
      2  14a5		       85 8c		      sta	aiState
    221  14a7		       60		      rts
    222  14a8
    223  14a8
      0  14a8				   .player    PHASE	StartMoveGen
      1  14a8		       a9 0b		      lda	#AI_StartMoveGen
      2  14aa		       85 8c		      sta	aiState
    225  14ac		       60		      rts
    226  14ad
    227  14ad
    228  14ad							;---------------------------------------------------------------------------------------------------
    229  14ad
      0  14ad					      DEF	aiStepMoveGen
      1  14ad				   SLOT_aiStepMoveGen SET	_BANK_SLOT
      2  14ad				   BANK_aiStepMoveGen SET	SLOT_aiStepMoveGen + _CURRENT_BANK
      3  14ad				   aiStepMoveGen
      4  14ad				   TEMPORARY_VAR SET	Overlay
      5  14ad				   TEMPORARY_OFFSET SET	0
      6  14ad				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      7  14ad				   FUNCTION_NAME SET	aiStepMoveGen
    231  14ad					      SUBROUTINE
    232  14ad
      0  14ad					      REF	AiStateMachine
      1  14ad					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  14ad				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  14ad					      ENDIF
      0  14ad					      VEND	aiStepMoveGen
      1  14ad
      2  14ad
      3  14ad		       00 a8	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
      4  14ad
    235  14ad
    236  14ad		       a5 88		      lda	originX12	; location of cursor (show move)
    237  14af		       85 89		      sta	cursorX12
      0  14b1					      PHASE	BeginSelectMovePhase
      1  14b1		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  14b3		       85 8c		      sta	aiState
    239  14b5		       60		      rts
    240  14b6
    241  14b6
    242  14b6							;---------------------------------------------------------------------------------------------------
    243  14b6
    244  1500		       00 00 00 00*	      align	256	; TODO?
    245  1500
    246  1500
      0  1500					      DEF	PositionSprites
      1  1500				   SLOT_PositionSprites SET	_BANK_SLOT
      2  1500				   BANK_PositionSprites SET	SLOT_PositionSprites + _CURRENT_BANK
      3  1500				   PositionSprites
      4  1500				   TEMPORARY_VAR SET	Overlay
      5  1500				   TEMPORARY_OFFSET SET	0
      6  1500				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      7  1500				   FUNCTION_NAME SET	PositionSprites
    248  1500					      SUBROUTINE
    249  1500
      0  1500					      REF	StartupBankReset
      1  1500				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  1500				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  1500					      ENDIF
      0  1500					      VEND	PositionSprites
      1  1500
      2  1500
      3  1500		       00 a6	   VAREND_PositionSprites =	TEMPORARY_VAR
      4  1500
    252  1500
    253  1500
    254  1500		       a5 89		      lda	cursorX12
    255  1502		       38		      sec
    256  1503		       e9 0a	   .sub10     sbc	#10
    257  1505		       b0 fc		      bcs	.sub10
    258  1507		       69 08		      adc	#8
    259  1509		       a8		      tay
    260  150a
    261  150a		       85 02		      sta	WSYNC	; 00	  Sync to start of scanline.
    262  150c
    263  150c		       b9 30 f5 	      lda	colToPixel,y
    264  150f
    265  150f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
    266  1510		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
    267  1512		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
    268  1514
    269  1514		       a8		      tay
    270  1515		       b9 30 f4 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
    271  1518		       85 20		      sta	HMP0
    272  151a		       85 10		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
    273  151c
    274  151c		       85 02		      sta	WSYNC
    275  151e		       85 2a		      sta	HMOVE
    276  1520
    277  1520		       60		      rts
    278  1521
    279  1521							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
    280  1521							; fine adjustment value. This table is on a page boundary to guarantee the processor
    281  1521							; will cross a page boundary and waste a cycle in order to be at the precise position
    282  1521							; for a RESP0,x write
    283  1521
    284  1521				   fineAdjustBegin
    285  1521
    286  1521		       70		      DC.B	%01110000	; Left 7
    287  1522		       60		      DC.B	%01100000	; Left 6
    288  1523		       50		      DC.B	%01010000	; Left 5
    289  1524		       40		      DC.B	%01000000	; Left 4
    290  1525		       30		      DC.B	%00110000	; Left 3
    291  1526		       20		      DC.B	%00100000	; Left 2
    292  1527		       10		      DC.B	%00010000	; Left 1
    293  1528		       00		      DC.B	%00000000	; No movement.
    294  1529		       f0		      DC.B	%11110000	; Right 1
    295  152a		       e0		      DC.B	%11100000	; Right 2
    296  152b		       d0		      DC.B	%11010000	; Right 3
    297  152c		       c0		      DC.B	%11000000	; Right 4
    298  152d		       b0		      DC.B	%10110000	; Right 5
    299  152e		       a0		      DC.B	%10100000	; Right 6
    300  152f		       90		      DC.B	%10010000	; Right 7
    301  1530
    302  1530		       f4 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
    303  1530
    304  1530
      0  1530					      ALLOCATE	colToPixel, 8
      1  1530
      2  1530				   .NAME      SETSTR	colToPixel
      0  1530					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  1530
      2  1530				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  1530				  -.EARLY_LOCATION SET	*
      4  1530				  -	      ALIGN	256
      5  1530				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  1530					      ENDIF
      0  1530					      DEF	colToPixel
      1  1530				   SLOT_colToPixel SET	_BANK_SLOT
      2  1530				   BANK_colToPixel SET	SLOT_colToPixel + _CURRENT_BANK
      3  1530				   colToPixel
      4  1530				   TEMPORARY_VAR SET	Overlay
      5  1530				   TEMPORARY_OFFSET SET	0
      6  1530				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      7  1530				   FUNCTION_NAME SET	colToPixel
      5  1530
    306  1530		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
    307  1538
    308  1538
    309  1538							;---------------------------------------------------------------------------------------------------
    310  1538
      0  1538					      DEF	aiMarchToTargetA
      1  1538				   SLOT_aiMarchToTargetA SET	_BANK_SLOT
      2  1538				   BANK_aiMarchToTargetA SET	SLOT_aiMarchToTargetA + _CURRENT_BANK
      3  1538				   aiMarchToTargetA
      4  1538				   TEMPORARY_VAR SET	Overlay
      5  1538				   TEMPORARY_OFFSET SET	0
      6  1538				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      7  1538				   FUNCTION_NAME SET	aiMarchToTargetA
    312  1538					      SUBROUTINE
    313  1538
      0  1538					      REF	AiStateMachine
      1  1538					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1538					      ENDIF
    315  1538
      0  1538					      VAR	__fromRow, 1
      1  1538		       00 a8	   __fromRow  =	TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1538
      4  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1538					      ENDIF
      8  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1538				  -VNAME      SETSTR	__fromRow
     10  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1538				  -	      ERR
     12  1538					      ENDIF
      0  1538					      VAR	__boardIndex, 1
      1  1538		       00 a9	   __boardIndex =	TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1538
      4  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1538					      ENDIF
      8  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1538				  -VNAME      SETSTR	__boardIndex
     10  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1538				  -	      ERR
     12  1538					      ENDIF
      0  1538					      VAR	__fromCol, 1
      1  1538		       00 aa	   __fromCol  =	TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1538
      4  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1538					      ENDIF
      8  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1538				  -VNAME      SETSTR	__fromCol
     10  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1538				  -	      ERR
     12  1538					      ENDIF
      0  1538					      VAR	__toCol, 1
      1  1538		       00 ab	   __toCol    =	TEMPORARY_VAR
      2  1538				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1538
      4  1538				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1538				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1538				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1538					      ENDIF
      8  1538				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1538				  -VNAME      SETSTR	__toCol
     10  1538				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1538				  -	      ERR
     12  1538					      ENDIF
    320  1538
      0  1538					      VEND	aiMarchToTargetA
      1  1538
      2  1538
      3  1538		       00 ac	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
      4  1538
    322  1538
    323  1538
    324  1538		       a5 83		      lda	drawDelay
    325  153a		       f0 03		      beq	.nodelay
    326  153c		       c6 83		      dec	drawDelay
    327  153e		       60		      rts
    328  153f				   .nodelay
    329  153f
    330  153f							; Now we calculate move to new square
    331  153f
    332  153f		       a5 86		      lda	fromX12
    333  1541		       c5 87		      cmp	toX12
    334  1543		       f0 44		      beq	.unmovedx
    335  1545		       85 84		      sta	lastSquareX12
    336  1547
    337  1547		       38		      sec
    338  1548		       a2 fd		      ldx	#-3
    339  154a		       e9 0a	   .sub10     sbc	#10
    340  154c		       e8		      inx
    341  154d		       b0 fb		      bcs	.sub10
    342  154f		       69 08		      adc	#8
    343  1551		       85 aa		      sta	__fromCol
    344  1553		       86 a8		      stx	__fromRow
    345  1555
    346  1555		       a5 87		      lda	toX12
    347  1557		       38		      sec
    348  1558		       a2 fd		      ldx	#-3
    349  155a		       e9 0a	   .sub10b    sbc	#10
    350  155c		       e8		      inx
    351  155d		       b0 fb		      bcs	.sub10b
    352  155f		       69 08		      adc	#8
    353  1561		       85 ab		      sta	__toCol
    354  1563
    355  1563
    356  1563		       e4 a8		      cpx	__fromRow
    357  1565		       f0 13		      beq	.rowDone
    358  1567
    359  1567		       b0 0a		      bcs	.incRow
    360  1569
    361  1569		       38		      sec
    362  156a		       a5 86		      lda	fromX12
    363  156c		       e9 0a		      sbc	#10
    364  156e		       85 86		      sta	fromX12
    365  1570		       4c 7a f5 	      jmp	.rowDone
    366  1573
    367  1573		       18	   .incRow    clc
    368  1574		       a5 86		      lda	fromX12
    369  1576		       69 0a		      adc	#10
    370  1578		       85 86		      sta	fromX12
    371  157a
    372  157a				   .rowDone
    373  157a
    374  157a		       a5 ab		      lda	__toCol
    375  157c		       c5 aa		      cmp	__fromCol
    376  157e		       f0 09		      beq	.colDone
    377  1580
    378  1580		       b0 05		      bcs	.incCol
    379  1582
    380  1582		       c6 86		      dec	fromX12
    381  1584		       4c 89 f5 	      jmp	.colDone
    382  1587
    383  1587		       e6 86	   .incCol    inc	fromX12
    384  1589				   .colDone
    385  1589				   .unmovedx
    386  1589
    387  1589		       a5 88		      lda	originX12
    388  158b		       85 89		      sta	cursorX12
    389  158d
      0  158d					      PHASE	MarchA2
      1  158d		       a9 17		      lda	#AI_MarchA2
      2  158f		       85 8c		      sta	aiState
    391  1591		       60		      rts
    392  1592
    393  1592
    394  1592							;---------------------------------------------------------------------------------------------------
    395  1592
      0  1592					      DEF	aiFinalFlash
      1  1592				   SLOT_aiFinalFlash SET	_BANK_SLOT
      2  1592				   BANK_aiFinalFlash SET	SLOT_aiFinalFlash + _CURRENT_BANK
      3  1592				   aiFinalFlash
      4  1592				   TEMPORARY_VAR SET	Overlay
      5  1592				   TEMPORARY_OFFSET SET	0
      6  1592				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      7  1592				   FUNCTION_NAME SET	aiFinalFlash
    397  1592					      SUBROUTINE
    398  1592
      0  1592					      REF	Variable_PieceShapeBuffer
      1  1592					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  1592				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  1592					      ENDIF
      0  1592					      REF	AiStateMachine
      1  1592				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  1592				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  1592					      ENDIF
      0  1592					      VEND	aiFinalFlash
      1  1592
      2  1592
      3  1592		       00 ee	   VAREND_aiFinalFlash =	TEMPORARY_VAR
      4  1592
    402  1592
    403  1592							; Piece has finished the animated move and is now in destination square.
    404  1592							; Flash the piece
    405  1592
    406  1592
    407  1592							; TODO: if en-passant, we can remove the piece being taken
    408  1592							; check movePiece for enPassant flag set (x)
    409  1592
    410  1592
    411  1592		       a5 83		      lda	drawDelay
    412  1594		       f0 03		      beq	.deCount
    413  1596		       c6 83		      dec	drawDelay
    414  1598		       60		      rts
    415  1599
    416  1599		       a5 85	   .deCount   lda	drawCount
    417  159b		       f0 0e		      beq	.flashDone2
    418  159d		       c6 85		      dec	drawCount
    419  159f
    420  159f		       a9 0a		      lda	#10
    421  15a1		       85 83		      sta	drawDelay	; "getting ready to move" flash
    422  15a3
    423  15a3		       a5 86		      lda	fromX12
    424  15a5		       85 81		      sta	squareToDraw
    425  15a7
    426  15a7							; WARNING - local variables will not survive the following call...!
    427  15a7		       20 c1 f0 	      jsr	CopySinglePiece	;@0
    428  15aa		       60		      rts
    429  15ab
    430  15ab				   .flashDone2
    431  15ab
    432  15ab		       a9 64		      lda	#100
    433  15ad		       85 8d		      sta	aiFlashDelay
    434  15af
      0  15af					      PHASE	SpecialMoveFixup
      1  15af		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  15b1		       85 8c		      sta	aiState
    436  15b3		       60		      rts
    437  15b4
    438  15b4
    439  15b4							;---------------------------------------------------------------------------------------------------
    440  15b4
      0  15b4					      DEF	aiStartSquareSelected
      1  15b4				   SLOT_aiStartSquareSelected SET	_BANK_SLOT
      2  15b4				   BANK_aiStartSquareSelected SET	SLOT_aiStartSquareSelected + _CURRENT_BANK
      3  15b4				   aiStartSquareSelected
      4  15b4				   TEMPORARY_VAR SET	Overlay
      5  15b4				   TEMPORARY_OFFSET SET	0
      6  15b4				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      7  15b4				   FUNCTION_NAME SET	aiStartSquareSelected
    442  15b4					      SUBROUTINE
    443  15b4
      0  15b4					      REF	AiStateMachine
      1  15b4					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  15b4				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  15b4					      ENDIF
      0  15b4					      VEND	aiStartSquareSelected
      1  15b4
      2  15b4
      3  15b4		       00 a8	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
      4  15b4
    446  15b4
    447  15b4
    448  15b4							; Mark all the valid moves for the selected piece on the board
    449  15b4							; and then start pulsing the piece
    450  15b4							; AND start choosing for selection of TO square
    451  15b4
    452  15b4							; Iterate the movelist and for all from squares which = drawPieceNumber
    453  15b4							; then draw a BLANK at that square
    454  15b4							; do 1 by one, when none found then increment state
    455  15b4
    456  15b4		       a5 89		      lda	cursorX12
    457  15b6		       85 81		      sta	squareToDraw
    458  15b8
    459  15b8		       a9 0a		      lda	#10
    460  15ba		       85 8d		      sta	aiFlashDelay
    461  15bc
    462  15bc		       a9 00		      lda	#0
    463  15be		       85 87		      sta	toX12	;aiToSquareX12
    464  15c0		       85 8f		      sta	aiFlashPhase	; for debounce exit timing
    465  15c2
    466  15c2		       a9 ff		      lda	#-1
    467  15c4		       85 8e		      sta	aiMoveIndex
    468  15c6
    469  15c6		       a9 28		      lda	#HOLD_DELAY
    470  15c8		       85 8a		      sta	mdelay	; hold-down delay before moves are shown
    471  15ca
      0  15ca					      PHASE	DrawMoves
      1  15ca		       a9 04		      lda	#AI_DrawMoves
      2  15cc		       85 8c		      sta	aiState
    473  15ce		       60		      rts
    474  15cf
    475  15cf
    476  15cf							;---------------------------------------------------------------------------------------------------
    477  15cf
      0  15cf					      DEF	aiWriteStartPieceBlank
      1  15cf				   SLOT_aiWriteStartPieceBlank SET	_BANK_SLOT
      2  15cf				   BANK_aiWriteStartPieceBlank SET	SLOT_aiWriteStartPieceBlank + _CURRENT_BANK
      3  15cf				   aiWriteStartPieceBlank
      4  15cf				   TEMPORARY_VAR SET	Overlay
      5  15cf				   TEMPORARY_OFFSET SET	0
      6  15cf				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      7  15cf				   FUNCTION_NAME SET	aiWriteStartPieceBlank
    479  15cf					      SUBROUTINE
    480  15cf
      0  15cf					      REF	Variable_PieceShapeBuffer
      1  15cf					      IF	VAREND_Variable_PieceShapeBuffer > TEMPORARY_VAR
      2  15cf				   TEMPORARY_VAR SET	VAREND_Variable_PieceShapeBuffer
      3  15cf					      ENDIF
      0  15cf					      REF	AiStateMachine
      1  15cf				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  15cf				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  15cf					      ENDIF
      0  15cf					      VEND	aiWriteStartPieceBlank
      1  15cf
      2  15cf
      3  15cf		       00 ee	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
      4  15cf
    484  15cf
    485  15cf							; Flash the piece in-place preparatory to moving it.
    486  15cf							; drawDelay = flash speed
    487  15cf							; drawCount = # of flashes
    488  15cf
    489  15cf
    490  15cf		       a9 04		      lda	#%100
    491  15d1		       85 0a		      sta	CTRLPF
    492  15d3
    493  15d3		       a6 a5		      ldx	platform
    494  15d5		       bd e1 f5 	      lda	startCol,x
    495  15d8		       85 06		      sta	COLUP0
    496  15da
    497  15da
    498  15da		       a5 83		      lda	drawDelay
    499  15dc		       f0 05		      beq	deCount
    500  15de		       c6 83		      dec	drawDelay
    501  15e0		       60		      rts
    502  15e1
    503  15e1				   startCol
    504  15e1		       46 68		      .byte.b	NTSC_COLOUR_LINE_2-2, PAL_COLOUR_LINE_2-2
    505  15e3
    506  15e3
    507  15e3
    508  15e3				   deCount
    509  15e3
    510  15e3		       a5 85		      lda	drawCount
    511  15e5		       f0 0d		      beq	flashDone
    512  15e7		       c6 85		      dec	drawCount
    513  15e9
    514  15e9		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    515  15eb		       85 83		      sta	drawDelay	; "getting ready to move" flash
    516  15ed
    517  15ed		       a5 86		      lda	fromX12
    518  15ef		       85 81		      sta	squareToDraw
    519  15f1
    520  15f1							; WARNING - local variables will not survive the following call...!
    521  15f1		       4c c1 f0 	      jmp	CopySinglePiece	;@0	      ; EOR-draw = flash
    522  15f4
    523  15f4				   flashDone
    524  15f4
    525  15f4							;lda #2
    526  15f4							;sta drawDelay
      0  15f4					      PHASE	MarchToTargetA
      1  15f4		       a9 16		      lda	#AI_MarchToTargetA
      2  15f6		       85 8c		      sta	aiState
    528  15f8		       60		      rts
    529  15f9
    530  15f9
    531  15f9							;---------------------------------------------------------------------------------------------------
    532  15f9
      0  15f9					      DEF	aiEPHandler
      1  15f9				   SLOT_aiEPHandler SET	_BANK_SLOT
      2  15f9				   BANK_aiEPHandler SET	SLOT_aiEPHandler + _CURRENT_BANK
      3  15f9				   aiEPHandler
      4  15f9				   TEMPORARY_VAR SET	Overlay
      5  15f9				   TEMPORARY_OFFSET SET	0
      6  15f9				   VAR_BOUNDARY_aiEPHandler SET	TEMPORARY_OFFSET
      7  15f9				   FUNCTION_NAME SET	aiEPHandler
    534  15f9					      SUBROUTINE
    535  15f9
    536  15f9							;CALL EnPassantFixupDraw	  ; set enPassantPawn
    537  15f9
    538  15f9
    539  15f9		       a5 97		      lda	fromPiece
    540  15fb		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    541  15fd		       c9 60		      cmp	#FLAG_ENPASSANT|FLAG_MOVED
    542  15ff		       d0 1a		      bne	.exit
    543  1601
    544  1601							; we have deteced a piece DOING an en passant capture
    545  1601							; so do the actual removal of the captured pawn...
    546  1601							; calculate the captured pawn's square based on piece colour
    547  1601
    548  1601		       a9 f6		      lda	#-10
    549  1603		       a6 97		      ldx	fromPiece
    550  1605		       10 02		      bpl	.white
    551  1607		       a9 0a		      lda	#10
    552  1609				   .white
    553  1609		       18		      clc
    554  160a		       65 86		      adc	fromX12	; attacker destination square
    555  160c		       85 94		      sta	enPassantPawn	; now this is the pawn to ERASE
    556  160e
    557  160e		       a9 05		      lda	#5	; on/off count (leave undrawn)
    558  1610		       85 85		      sta	drawCount	; flashing for piece about to move
    559  1612		       a9 00		      lda	#0
    560  1614		       85 83		      sta	drawDelay
    561  1616
      0  1616					      PHASE	EPFlash
      1  1616		       a9 2a		      lda	#AI_EPFlash
      2  1618		       85 8c		      sta	aiState
    563  161a		       60		      rts
    564  161b
    565  161b
    566  161b				   .exit
    567  161b
    568  161b		       a9 04		      lda	#4	; on/off count (leave undrawn)
    569  161d		       85 85		      sta	drawCount	; flashing for piece about to move
    570  161f		       a9 00		      lda	#0
    571  1621		       85 83		      sta	drawDelay
    572  1623
      0  1623					      PHASE	FinalFlash
      1  1623		       a9 1b		      lda	#AI_FinalFlash
      2  1625		       85 8c		      sta	aiState
    574  1627		       60		      rts
    575  1628
    576  1628
    577  1628							;---------------------------------------------------------------------------------------------------
    578  1628
      0  1628					      END_BANK
      1  1628				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  1628				  -	      CHECK_RAM_BANK_SIZE
      3  1628					      ELSE
      0  1628					      CHECK_BANK_SIZE
      1  1628		       02 28	   .TEMP      =	* - _BANK_START
 ROM bank # 6 STATEMACHINE2 size = $228 free = 471
      2  1628					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  1628				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1628				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  1628				  -	      ERR
      6  1628					      ENDIF
      5  1628					      ENDIF
    580  1628
    581  1628							;---------------------------------------------------------------------------------------------------
    582  1628							; EOF
------- FILE ./chess.asm
------- FILE @1 PIECE HANDLER #1.asm LEVEL 2 PASS 4
      0  1628					      include	"@1 PIECE HANDLER #1.asm"
      1  1628							;---------------------------------------------------------------------------------------------------
      2  1628							; @1 PIECE HANDLER #1.asm
      3  1628
      4  1628							; Atari 2600 Chess
      5  1628							; Copyright (c) 2019-2020 Andrew Davie
      6  1628							; andrew@taswegian.com
      7  1628
      8  1628
      9  1628							;---------------------------------------------------------------------------------------------------
     10  1628
      0  1628					      SLOT	1
      1  1628
      2  1628				  -	      IF	(1 < 0) || (1 > 3)
      3  1628				  -	      ECHO	"Illegal bank address/segment location", 1
      4  1628				  -	      ERR
      5  1628					      ENDIF
      6  1628
      7  1628				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  1628				   _BANK_SLOT SET	1 * 64
      9  1628
      0  1628					      ROMBANK	PIECE_HANDLER_1
      1  1ac4 ????				      SEG	ROM_PIECE_HANDLER_1
      2  1800					      ORG	_ORIGIN
      3  1800					      RORG	_BANK_ADDRESS_ORIGIN
      4  1800				   _BANK_START SET	*
      5  1800				   PIECE_HANDLER_1_START SET	*
      6  1800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1800				   ROMBANK_PIECE_HANDLER_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  1800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1800				   _LAST_BANK SETSTR	PIECE_HANDLER_1
     10  1800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1800
------- FILE PIECE_PAWN.asm LEVEL 3 PASS 4
      0  1800					      include	"PIECE_PAWN.asm"
      1  1800							; Copyright (C)2020 Andrew Davie
      2  1800							; Pawn move handlers
      3  1800
      4  1800							;---------------------------------------------------------------------------------------------------
      5  1800							; WHITE PAWN
      6  1800							;---------------------------------------------------------------------------------------------------
      7  1800
      8  1800		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  1800		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  1800
     11  1800							;---------------------------------------------------------------------------------------------------
     12  1800
     13  1800					      MAC	en_passant
     14  1800					      SUBROUTINE
     15  1800							; {1} = _LEFT or _RIGHT
     16  1800
     17  1800					      ldx	currentSquare
     18  1800					      ldy	ValidSquare+{1},x
     19  1800					      cpy	enPassantPawn
     20  1800					      bne	.invalid
     21  1800					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  1800					      lda	Board,y
     23  1800					      bne	.invalid
     24  1800					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  1800				   .invalid
     26  1800					      ENDM
     27  1800
     28  1800							;---------------------------------------------------------------------------------------------------
     29  1800
     30  1800					      MAC	promote_pawn
     31  1800							;SUBROUTINE
     32  1800
     33  1800							;{1} = BLACK or WHITE
     34  1800
     35  1800
     36  1800					      sty	__temp
     37  1800					      lda	#{1}|QUEEN
     38  1800					      sta	currentPiece
     39  1800					      jsr	AddMove
     40  1800
     41  1800					      lda	#{1}|ROOK
     42  1800					      sta	currentPiece
     43  1800					      ldy	__temp
     44  1800					      jsr	AddMove
     45  1800
     46  1800					      lda	#{1}|BISHOP
     47  1800					      sta	currentPiece
     48  1800					      ldy	__temp
     49  1800					      jsr	AddMove
     50  1800
     51  1800					      lda	#{1}|KNIGHT
     52  1800					      sta	currentPiece
     53  1800					      ldy	__temp
     54  1800					      jsr	AddMove
     55  1800
     56  1800					      IF	{1} = WHITE
     57  1800					      lda	#WHITE|WP
     58  1800					      ENDIF
     59  1800					      IF	{1} = BLACK
     60  1800					      lda	#BLACK|BP
     61  1800					      ENDIF
     62  1800					      sta	currentPiece
     63  1800					      ENDM
     64  1800
     65  1800							;---------------------------------------------------------------------------------------------------
     66  1800
     67  1800					      MAC	move_or_promote_pawn
     68  1800							;SUBROUTINE
     69  1800							; {1} = BLACK or WHITE
     70  1800
     71  1800					      IF	{1} = WHITE
     72  1800					      cpy	#90	; last rank?
     73  1800					      bcc	.standard
     74  1800					      jsr	PromoteWhitePawn
     75  1800					      jmp	.pMoved
     76  1800					      ENDIF
     77  1800
     78  1800					      IF	{1} = BLACK
     79  1800					      cpy	#30	; last rank?
     80  1800					      bcs	.standard
     81  1800					      jsr	PromoteBlackPawn
     82  1800					      jmp	.pMoved
     83  1800					      ENDIF
     84  1800
     85  1800				   .standard  jsr	AddMove	; add +1UP move
     86  1800				   .pMoved
     87  1800
     88  1800					      ENDM
     89  1800
     90  1800							;---------------------------------------------------------------------------------------------------
     91  1800
     92  1800					      MAC	take
     93  1800							;SUBROUTINE
     94  1800							; {1} = capture square offset
     95  1800
     96  1800					      ldx	currentSquare
     97  1800					      ldy	ValidSquare+{1},x
     98  1800					      bmi	.invalid2
     99  1800					      lda	Board,y
    100  1800					      beq	.invalid2	; square empty
    101  1800					      sta	capture
    102  1800					      eor	currentPiece
    103  1800					      bpl	.invalid	; same colour
    104  1800
    105  1800					      MOVE_OR_PROMOTE_PAWN	{2}
    106  1800
    107  1800					      jmp	.invalid2
    108  1800				   .invalid		;inc protecting ???
    109  1800				   .invalid2
    110  1800					      ENDM
    111  1800
    112  1800							;---------------------------------------------------------------------------------------------------
    113  1800
      0  1800					      DEF	PromoteWhitePawn
      1  1800				   SLOT_PromoteWhitePawn SET	_BANK_SLOT
      2  1800				   BANK_PromoteWhitePawn SET	SLOT_PromoteWhitePawn + _CURRENT_BANK
      3  1800				   PromoteWhitePawn
      4  1800				   TEMPORARY_VAR SET	Overlay
      5  1800				   TEMPORARY_OFFSET SET	0
      6  1800				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      7  1800				   FUNCTION_NAME SET	PromoteWhitePawn
    115  1800					      SUBROUTINE
    116  1800
      0  1800					      REF	Handle_WHITE_PAWN
      1  1800					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  1800				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  1800					      ENDIF
      0  1800					      VAR	__temp, 1
      1  1800		       00 bb	   __temp     =	TEMPORARY_VAR
      2  1800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  1800
      4  1800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  1800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  1800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  1800					      ENDIF
      8  1800				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  1800				  -VNAME      SETSTR	__temp
     10  1800				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  1800				  -	      ERR
     12  1800					      ENDIF
      0  1800					      VEND	PromoteWhitePawn
      1  1800
      2  1800
      3  1800		       00 bc	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
      4  1800
    120  1800
      0  1800					      PROMOTE_PAWN	WHITE
      1  1800
      2  1800
      3  1800
      4  1800
      5  1800
      6  1800		       84 bb		      sty	__temp
      7  1802		       a9 06		      lda	#WHITE|QUEEN
      8  1804		       85 92		      sta	currentPiece
      9  1806		       20 85 f2 	      jsr	AddMove
     10  1809
     11  1809		       a9 05		      lda	#WHITE|ROOK
     12  180b		       85 92		      sta	currentPiece
     13  180d		       a4 bb		      ldy	__temp
     14  180f		       20 85 f2 	      jsr	AddMove
     15  1812
     16  1812		       a9 04		      lda	#WHITE|BISHOP
     17  1814		       85 92		      sta	currentPiece
     18  1816		       a4 bb		      ldy	__temp
     19  1818		       20 85 f2 	      jsr	AddMove
     20  181b
     21  181b		       a9 03		      lda	#WHITE|KNIGHT
     22  181d		       85 92		      sta	currentPiece
     23  181f		       a4 bb		      ldy	__temp
     24  1821		       20 85 f2 	      jsr	AddMove
     25  1824
     26  1824					      IF	WHITE = WHITE
     27  1824		       a9 01		      lda	#WHITE|WP
     28  1826					      ENDIF
     29  1826				  -	      IF	WHITE = BLACK
     30  1826				  -	      lda	#BLACK|BP
     31  1826					      ENDIF
     32  1826		       85 92		      sta	currentPiece
    122  1828		       60		      rts
    123  1829
    124  1829							;---------------------------------------------------------------------------------------------------
    125  1829
      0  1829					      DEF	Handle_WHITE_PAWN
      1  1829				   SLOT_Handle_WHITE_PAWN SET	_BANK_SLOT
      2  1829				   BANK_Handle_WHITE_PAWN SET	SLOT_Handle_WHITE_PAWN + _CURRENT_BANK
      3  1829				   Handle_WHITE_PAWN
      4  1829				   TEMPORARY_VAR SET	Overlay
      5  1829				   TEMPORARY_OFFSET SET	0
      6  1829				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      7  1829				   FUNCTION_NAME SET	Handle_WHITE_PAWN
    127  1829					      SUBROUTINE
    128  1829
      0  1829					      REF	GenerateAllMoves
      1  1829					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1829				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1829					      ENDIF
      0  1829					      VEND	Handle_WHITE_PAWN
      1  1829
      2  1829
      3  1829		       00 bb	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
      4  1829
    131  1829
    132  1829		       bc 1f fc 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  182c		       b9 79 fc 	      lda	Board,y
    134  182f		       d0 26		      bne	.pMoved	; occupied
    135  1831		       85 a0		      sta	capture
    136  1833
    137  1833							; we may need to promote the pawn
    138  1833							; All possibilites (Q/R/B/N) are added as individual moves
    139  1833
      0  1833					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  1833
      2  1833
      3  1833
      4  1833					      IF	WHITE = WHITE
      5  1833		       c0 5a		      cpy	#90
      6  1835		       90 06		      bcc	.standard
      7  1837		       20 00 f4 	      jsr	PromoteWhitePawn
      8  183a		       4c 40 f4 	      jmp	.pMoved
      9  183d					      ENDIF
     10  183d
     11  183d				  -	      IF	WHITE = BLACK
     12  183d				  -	      cpy	#30
     13  183d				  -	      bcs	.standard
     14  183d				  -	      jsr	PromoteBlackPawn
     15  183d				  -	      jmp	.pMoved
     16  183d					      ENDIF
     17  183d
     18  183d		       20 85 f2    .standard  jsr	AddMove
     19  1840				   .pMoved
     20  1840
    141  1840
    142  1840							; the +2 move off the home rank...
    143  1840
    144  1840		       a6 93		      ldx	currentSquare
    145  1842		       e0 28		      cpx	#WHITE_HOME_ROW
    146  1844		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  1846		       bc 29 fc 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  1849		       b9 79 fc 	      lda	Board,y
    149  184c		       d0 09		      bne	.pMoved	; destination square occupied
    150  184e
    151  184e		       a5 92		      lda	currentPiece
    152  1850		       09 20		      ora	#FLAG_ENPASSANT
    153  1852		       85 92		      sta	currentPiece	; GENERATE en-passant opportunity
    154  1854
    155  1854		       20 85 f2 	      jsr	AddMove	; add the +2UP move off home row
    156  1857
    157  1857				   .pMoved
    158  1857
    159  1857							; regular captures...
    160  1857
      0  1857					      TAKE	_UP+_LEFT, WHITE
      1  1857
      2  1857
      3  1857
      4  1857		       a6 93		      ldx	currentSquare
      5  1859		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      6  185c		       30 1b		      bmi	.invalid2
      7  185e		       b9 79 fc 	      lda	Board,y
      8  1861		       f0 16		      beq	.invalid2
      9  1863		       85 a0		      sta	capture
     10  1865		       45 92		      eor	currentPiece
     11  1867		       10 10		      bpl	.invalid
     12  1869
      0  1869					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  1869
      2  1869
      3  1869
      4  1869					      IF	WHITE = WHITE
      5  1869		       c0 5a		      cpy	#90
      6  186b		       90 06		      bcc	.standard
      7  186d		       20 00 f4 	      jsr	PromoteWhitePawn
      8  1870		       4c 76 f4 	      jmp	.pMoved
      9  1873					      ENDIF
     10  1873
     11  1873				  -	      IF	WHITE = BLACK
     12  1873				  -	      cpy	#30
     13  1873				  -	      bcs	.standard
     14  1873				  -	      jsr	PromoteBlackPawn
     15  1873				  -	      jmp	.pMoved
     16  1873					      ENDIF
     17  1873
     18  1873		       20 85 f2    .standard  jsr	AddMove
     19  1876				   .pMoved
     20  1876
     14  1876
     15  1876		       4c 79 f4 	      jmp	.invalid2
     16  1879				   .invalid
     17  1879				   .invalid2
      0  1879					      TAKE	_UP+_RIGHT, WHITE
      1  1879
      2  1879
      3  1879
      4  1879		       a6 93		      ldx	currentSquare
      5  187b		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  187e		       30 1b		      bmi	.invalid2
      7  1880		       b9 79 fc 	      lda	Board,y
      8  1883		       f0 16		      beq	.invalid2
      9  1885		       85 a0		      sta	capture
     10  1887		       45 92		      eor	currentPiece
     11  1889		       10 10		      bpl	.invalid
     12  188b
      0  188b					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  188b
      2  188b
      3  188b
      4  188b					      IF	WHITE = WHITE
      5  188b		       c0 5a		      cpy	#90
      6  188d		       90 06		      bcc	.standard
      7  188f		       20 00 f4 	      jsr	PromoteWhitePawn
      8  1892		       4c 98 f4 	      jmp	.pMoved
      9  1895					      ENDIF
     10  1895
     11  1895				  -	      IF	WHITE = BLACK
     12  1895				  -	      cpy	#30
     13  1895				  -	      bcs	.standard
     14  1895				  -	      jsr	PromoteBlackPawn
     15  1895				  -	      jmp	.pMoved
     16  1895					      ENDIF
     17  1895
     18  1895		       20 85 f2    .standard  jsr	AddMove
     19  1898				   .pMoved
     20  1898
     14  1898
     15  1898		       4c 9b f4 	      jmp	.invalid2
     16  189b				   .invalid
     17  189b				   .invalid2
    163  189b
    164  189b
    165  189b					      IF	ENPASSANT_ENABLED
    166  189b							; en-passant captures...
    167  189b
    168  189b		       a5 94		      lda	enPassantPawn
    169  189d		       f0 2e		      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  189f
    171  189f		       a5 92		      lda	currentPiece
    172  18a1		       09 20		      ora	#FLAG_ENPASSANT
    173  18a3		       85 92		      sta	currentPiece	; CONSUME en-passant opportunity
    174  18a5
      0  18a5					      EN_PASSANT	_LEFT, _UP
      1  18a5					      SUBROUTINE
      2  18a5
      3  18a5
      4  18a5		       a6 93		      ldx	currentSquare
      5  18a7		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  18aa		       c4 94		      cpy	enPassantPawn
      7  18ac		       d0 0b		      bne	.invalid
      8  18ae		       bc 1e fc 	      ldy	ValidSquare+_LEFT+_UP,x
      9  18b1		       b9 79 fc 	      lda	Board,y
     10  18b4		       d0 03		      bne	.invalid
     11  18b6		       20 85 f2 	      jsr	AddMove
     12  18b9				   .invalid
      0  18b9					      EN_PASSANT	_RIGHT, _UP
      1  18b9					      SUBROUTINE
      2  18b9
      3  18b9
      4  18b9		       a6 93		      ldx	currentSquare
      5  18bb		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  18be		       c4 94		      cpy	enPassantPawn
      7  18c0		       d0 0b		      bne	.invalid
      8  18c2		       bc 20 fc 	      ldy	ValidSquare+_RIGHT+_UP,x
      9  18c5		       b9 79 fc 	      lda	Board,y
     10  18c8		       d0 03		      bne	.invalid
     11  18ca		       20 85 f2 	      jsr	AddMove
     12  18cd				   .invalid
    177  18cd
    178  18cd				   .noEnPassant
    179  18cd					      ENDIF
    180  18cd
    181  18cd		       4c e8 f1 	      jmp	MoveReturn
    182  18d0
    183  18d0
    184  18d0							;---------------------------------------------------------------------------------------------------
    185  18d0							; BLACK PAWN
    186  18d0							;---------------------------------------------------------------------------------------------------
    187  18d0
      0  18d0					      DEF	PromoteBlackPawn
      1  18d0				   SLOT_PromoteBlackPawn SET	_BANK_SLOT
      2  18d0				   BANK_PromoteBlackPawn SET	SLOT_PromoteBlackPawn + _CURRENT_BANK
      3  18d0				   PromoteBlackPawn
      4  18d0				   TEMPORARY_VAR SET	Overlay
      5  18d0				   TEMPORARY_OFFSET SET	0
      6  18d0				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      7  18d0				   FUNCTION_NAME SET	PromoteBlackPawn
    189  18d0					      SUBROUTINE
    190  18d0
      0  18d0					      REF	Handle_BLACK_PAWN
      1  18d0					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  18d0				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  18d0					      ENDIF
      0  18d0					      VAR	__temp, 1
      1  18d0		       00 bb	   __temp     =	TEMPORARY_VAR
      2  18d0				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  18d0
      4  18d0				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  18d0				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  18d0				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  18d0					      ENDIF
      8  18d0				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  18d0				  -VNAME      SETSTR	__temp
     10  18d0				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  18d0				  -	      ERR
     12  18d0					      ENDIF
      0  18d0					      VEND	PromoteBlackPawn
      1  18d0
      2  18d0
      3  18d0		       00 bc	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
      4  18d0
    194  18d0
      0  18d0					      PROMOTE_PAWN	BLACK
      1  18d0
      2  18d0
      3  18d0
      4  18d0
      5  18d0
      6  18d0		       84 bb		      sty	__temp
      7  18d2		       a9 86		      lda	#BLACK|QUEEN
      8  18d4		       85 92		      sta	currentPiece
      9  18d6		       20 85 f2 	      jsr	AddMove
     10  18d9
     11  18d9		       a9 85		      lda	#BLACK|ROOK
     12  18db		       85 92		      sta	currentPiece
     13  18dd		       a4 bb		      ldy	__temp
     14  18df		       20 85 f2 	      jsr	AddMove
     15  18e2
     16  18e2		       a9 84		      lda	#BLACK|BISHOP
     17  18e4		       85 92		      sta	currentPiece
     18  18e6		       a4 bb		      ldy	__temp
     19  18e8		       20 85 f2 	      jsr	AddMove
     20  18eb
     21  18eb		       a9 83		      lda	#BLACK|KNIGHT
     22  18ed		       85 92		      sta	currentPiece
     23  18ef		       a4 bb		      ldy	__temp
     24  18f1		       20 85 f2 	      jsr	AddMove
     25  18f4
     26  18f4				  -	      IF	BLACK = WHITE
     27  18f4				  -	      lda	#WHITE|WP
     28  18f4					      ENDIF
     29  18f4					      IF	BLACK = BLACK
     30  18f4		       a9 82		      lda	#BLACK|BP
     31  18f6					      ENDIF
     32  18f6		       85 92		      sta	currentPiece
    196  18f8		       60		      rts
    197  18f9
      0  18f9					      DEF	Handle_BLACK_PAWN
      1  18f9				   SLOT_Handle_BLACK_PAWN SET	_BANK_SLOT
      2  18f9				   BANK_Handle_BLACK_PAWN SET	SLOT_Handle_BLACK_PAWN + _CURRENT_BANK
      3  18f9				   Handle_BLACK_PAWN
      4  18f9				   TEMPORARY_VAR SET	Overlay
      5  18f9				   TEMPORARY_OFFSET SET	0
      6  18f9				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      7  18f9				   FUNCTION_NAME SET	Handle_BLACK_PAWN
    199  18f9					      SUBROUTINE
    200  18f9
      0  18f9					      REF	GenerateAllMoves
      1  18f9					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  18f9				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  18f9					      ENDIF
      0  18f9					      VEND	Handle_BLACK_PAWN
      1  18f9
      2  18f9
      3  18f9		       00 bb	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
      4  18f9
    203  18f9
    204  18f9		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  18fc		       b9 79 fc 	      lda	Board,y
    206  18ff		       d0 26		      bne	.pMoved	; occupied
    207  1901		       85 a0		      sta	capture
    208  1903
    209  1903							; we may need to promote the pawn
    210  1903							; All possibilites (Q/R/B/N) are added as individual moves
    211  1903
      0  1903					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  1903
      2  1903
      3  1903
      4  1903				  -	      IF	BLACK = WHITE
      5  1903				  -	      cpy	#90
      6  1903				  -	      bcc	.standard
      7  1903				  -	      jsr	PromoteWhitePawn
      8  1903				  -	      jmp	.pMoved
      9  1903					      ENDIF
     10  1903
     11  1903					      IF	BLACK = BLACK
     12  1903		       c0 1e		      cpy	#30
     13  1905		       b0 06		      bcs	.standard
     14  1907		       20 d0 f4 	      jsr	PromoteBlackPawn
     15  190a		       4c 10 f5 	      jmp	.pMoved
     16  190d					      ENDIF
     17  190d
     18  190d		       20 85 f2    .standard  jsr	AddMove
     19  1910				   .pMoved
     20  1910
    213  1910
    214  1910							; the +2 move off the home rank...
    215  1910
    216  1910		       a6 93		      ldx	currentSquare
    217  1912		       e0 52		      cpx	#BLACK_HOME_ROW
    218  1914		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  1916
    220  1916
    221  1916		       bc 01 fc 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  1919		       b9 79 fc 	      lda	Board,y
    223  191c		       d0 09		      bne	.pMoved	; destination square occupied
    224  191e
    225  191e		       a5 92		      lda	currentPiece
    226  1920		       09 20		      ora	#FLAG_ENPASSANT
    227  1922		       85 92		      sta	currentPiece	; CAN en-passant
    228  1924
    229  1924		       20 85 f2 	      jsr	AddMove	; add the +2DOWN move off home row
    230  1927
    231  1927				   .pMoved
    232  1927
    233  1927							; regular captures... (with promotion)
    234  1927
      0  1927					      TAKE	_DOWN+_LEFT, BLACK
      1  1927
      2  1927
      3  1927
      4  1927		       a6 93		      ldx	currentSquare
      5  1929		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  192c		       30 1b		      bmi	.invalid2
      7  192e		       b9 79 fc 	      lda	Board,y
      8  1931		       f0 16		      beq	.invalid2
      9  1933		       85 a0		      sta	capture
     10  1935		       45 92		      eor	currentPiece
     11  1937		       10 10		      bpl	.invalid
     12  1939
      0  1939					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  1939
      2  1939
      3  1939
      4  1939				  -	      IF	BLACK = WHITE
      5  1939				  -	      cpy	#90
      6  1939				  -	      bcc	.standard
      7  1939				  -	      jsr	PromoteWhitePawn
      8  1939				  -	      jmp	.pMoved
      9  1939					      ENDIF
     10  1939
     11  1939					      IF	BLACK = BLACK
     12  1939		       c0 1e		      cpy	#30
     13  193b		       b0 06		      bcs	.standard
     14  193d		       20 d0 f4 	      jsr	PromoteBlackPawn
     15  1940		       4c 46 f5 	      jmp	.pMoved
     16  1943					      ENDIF
     17  1943
     18  1943		       20 85 f2    .standard  jsr	AddMove
     19  1946				   .pMoved
     20  1946
     14  1946
     15  1946		       4c 49 f5 	      jmp	.invalid2
     16  1949				   .invalid
     17  1949				   .invalid2
      0  1949					      TAKE	_DOWN+_RIGHT, BLACK
      1  1949
      2  1949
      3  1949
      4  1949		       a6 93		      ldx	currentSquare
      5  194b		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  194e		       30 1b		      bmi	.invalid2
      7  1950		       b9 79 fc 	      lda	Board,y
      8  1953		       f0 16		      beq	.invalid2
      9  1955		       85 a0		      sta	capture
     10  1957		       45 92		      eor	currentPiece
     11  1959		       10 10		      bpl	.invalid
     12  195b
      0  195b					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  195b
      2  195b
      3  195b
      4  195b				  -	      IF	BLACK = WHITE
      5  195b				  -	      cpy	#90
      6  195b				  -	      bcc	.standard
      7  195b				  -	      jsr	PromoteWhitePawn
      8  195b				  -	      jmp	.pMoved
      9  195b					      ENDIF
     10  195b
     11  195b					      IF	BLACK = BLACK
     12  195b		       c0 1e		      cpy	#30
     13  195d		       b0 06		      bcs	.standard
     14  195f		       20 d0 f4 	      jsr	PromoteBlackPawn
     15  1962		       4c 68 f5 	      jmp	.pMoved
     16  1965					      ENDIF
     17  1965
     18  1965		       20 85 f2    .standard  jsr	AddMove
     19  1968				   .pMoved
     20  1968
     14  1968
     15  1968		       4c 6b f5 	      jmp	.invalid2
     16  196b				   .invalid
     17  196b				   .invalid2
    237  196b
    238  196b
    239  196b					      IF	ENPASSANT_ENABLED
    240  196b							; en-passant captures...
    241  196b
    242  196b		       a5 94		      lda	enPassantPawn
    243  196d		       f0 2e		      beq	.noEnPassant	; was last move en-passantable?
    244  196f
    245  196f		       a5 92		      lda	currentPiece
    246  1971		       09 20		      ora	#FLAG_ENPASSANT
    247  1973		       85 92		      sta	currentPiece	; any en-passant move added will have flag set
    248  1975
      0  1975					      EN_PASSANT	_LEFT, _DOWN
      1  1975					      SUBROUTINE
      2  1975
      3  1975
      4  1975		       a6 93		      ldx	currentSquare
      5  1977		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      6  197a		       c4 94		      cpy	enPassantPawn
      7  197c		       d0 0b		      bne	.invalid
      8  197e		       bc 0a fc 	      ldy	ValidSquare+_LEFT+_DOWN,x
      9  1981		       b9 79 fc 	      lda	Board,y
     10  1984		       d0 03		      bne	.invalid
     11  1986		       20 85 f2 	      jsr	AddMove
     12  1989				   .invalid
      0  1989					      EN_PASSANT	_RIGHT, _DOWN
      1  1989					      SUBROUTINE
      2  1989
      3  1989
      4  1989		       a6 93		      ldx	currentSquare
      5  198b		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      6  198e		       c4 94		      cpy	enPassantPawn
      7  1990		       d0 0b		      bne	.invalid
      8  1992		       bc 0c fc 	      ldy	ValidSquare+_RIGHT+_DOWN,x
      9  1995		       b9 79 fc 	      lda	Board,y
     10  1998		       d0 03		      bne	.invalid
     11  199a		       20 85 f2 	      jsr	AddMove
     12  199d				   .invalid
    251  199d
    252  199d				   .noEnPassant
    253  199d					      ENDIF
    254  199d
    255  199d		       4c e8 f1 	      jmp	MoveReturn
    256  19a0
    257  19a0							; EOF
------- FILE @1 PIECE HANDLER #1.asm
------- FILE PIECE_KNIGHT.asm LEVEL 3 PASS 4
      0  19a0					      include	"PIECE_KNIGHT.asm"
      1  19a0							; Copyright (C)2020 Andrew Davie
      2  19a0							; Knight move handler
      3  19a0
      4  19a0							;---------------------------------------------------------------------------------------------------
      5  19a0							; KNIGHT
      6  19a0							;---------------------------------------------------------------------------------------------------
      7  19a0
      0  19a0					      DEF	Handle_KNIGHT
      1  19a0				   SLOT_Handle_KNIGHT SET	_BANK_SLOT
      2  19a0				   BANK_Handle_KNIGHT SET	SLOT_Handle_KNIGHT + _CURRENT_BANK
      3  19a0				   Handle_KNIGHT
      4  19a0				   TEMPORARY_VAR SET	Overlay
      5  19a0				   TEMPORARY_OFFSET SET	0
      6  19a0				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      7  19a0				   FUNCTION_NAME SET	Handle_KNIGHT
      9  19a0					      SUBROUTINE
     10  19a0
      0  19a0					      REF	GenerateAllMoves	;✅
      1  19a0					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  19a0				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  19a0					      ENDIF
      0  19a0					      VEND	Handle_KNIGHT
      1  19a0
      2  19a0
      3  19a0		       00 bb	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
      4  19a0
     13  19a0
     14  19a0							; x = currentSquare (square the piece is on)
     15  19a0							; currentPiece (with flags/colour attached)
     16  19a0
      0  19a0					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  19a0					      SUBROUTINE
      2  19a0
      3  19a0		       bc 00 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      4  19a3		       30 0e		      bmi	.invalid
      5  19a5		       b9 79 fc 	      lda	Board,y
      6  19a8		       85 a0		      sta	capture
      7  19aa		       f0 04		      beq	.squareEmpty
      8  19ac		       45 92		      eor	currentPiece
      9  19ae		       10 03		      bpl	.invalid
     10  19b0		       20 85 f2    .squareEmpty jsr	AddMove
     11  19b3				   .invalid
     12  19b3
      0  19b3					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  19b3		       a6 93		      ldx	currentSquare
      0  19b5					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  19b5					      SUBROUTINE
      2  19b5
      3  19b5		       bc 02 fc 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      4  19b8		       30 0e		      bmi	.invalid
      5  19ba		       b9 79 fc 	      lda	Board,y
      6  19bd		       85 a0		      sta	capture
      7  19bf		       f0 04		      beq	.squareEmpty
      8  19c1		       45 92		      eor	currentPiece
      9  19c3		       10 03		      bpl	.invalid
     10  19c5		       20 85 f2    .squareEmpty jsr	AddMove
     11  19c8				   .invalid
     12  19c8
      0  19c8					      MOVE_TO_X	_UP+_UP+_LEFT
      1  19c8		       a6 93		      ldx	currentSquare
      0  19ca					      MOVE_TO	_UP+_UP+_LEFT
      1  19ca					      SUBROUTINE
      2  19ca
      3  19ca		       bc 28 fc 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      4  19cd		       30 0e		      bmi	.invalid
      5  19cf		       b9 79 fc 	      lda	Board,y
      6  19d2		       85 a0		      sta	capture
      7  19d4		       f0 04		      beq	.squareEmpty
      8  19d6		       45 92		      eor	currentPiece
      9  19d8		       10 03		      bpl	.invalid
     10  19da		       20 85 f2    .squareEmpty jsr	AddMove
     11  19dd				   .invalid
     12  19dd
      0  19dd					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  19dd		       a6 93		      ldx	currentSquare
      0  19df					      MOVE_TO	_UP+_UP+_RIGHT
      1  19df					      SUBROUTINE
      2  19df
      3  19df		       bc 2a fc 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      4  19e2		       30 0e		      bmi	.invalid
      5  19e4		       b9 79 fc 	      lda	Board,y
      6  19e7		       85 a0		      sta	capture
      7  19e9		       f0 04		      beq	.squareEmpty
      8  19eb		       45 92		      eor	currentPiece
      9  19ed		       10 03		      bpl	.invalid
     10  19ef		       20 85 f2    .squareEmpty jsr	AddMove
     11  19f2				   .invalid
     12  19f2
     21  19f2
      0  19f2					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  19f2		       a6 93		      ldx	currentSquare
      0  19f4					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  19f4					      SUBROUTINE
      2  19f4
      3  19f4		       bc 09 fc 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      4  19f7		       30 0e		      bmi	.invalid
      5  19f9		       b9 79 fc 	      lda	Board,y
      6  19fc		       85 a0		      sta	capture
      7  19fe		       f0 04		      beq	.squareEmpty
      8  1a00		       45 92		      eor	currentPiece
      9  1a02		       10 03		      bpl	.invalid
     10  1a04		       20 85 f2    .squareEmpty jsr	AddMove
     11  1a07				   .invalid
     12  1a07
      0  1a07					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  1a07		       a6 93		      ldx	currentSquare
      0  1a09					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  1a09					      SUBROUTINE
      2  1a09
      3  1a09		       bc 0d fc 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      4  1a0c		       30 0e		      bmi	.invalid
      5  1a0e		       b9 79 fc 	      lda	Board,y
      6  1a11		       85 a0		      sta	capture
      7  1a13		       f0 04		      beq	.squareEmpty
      8  1a15		       45 92		      eor	currentPiece
      9  1a17		       10 03		      bpl	.invalid
     10  1a19		       20 85 f2    .squareEmpty jsr	AddMove
     11  1a1c				   .invalid
     12  1a1c
      0  1a1c					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  1a1c		       a6 93		      ldx	currentSquare
      0  1a1e					      MOVE_TO	_UP+_LEFT+_LEFT
      1  1a1e					      SUBROUTINE
      2  1a1e
      3  1a1e		       bc 1d fc 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      4  1a21		       30 0e		      bmi	.invalid
      5  1a23		       b9 79 fc 	      lda	Board,y
      6  1a26		       85 a0		      sta	capture
      7  1a28		       f0 04		      beq	.squareEmpty
      8  1a2a		       45 92		      eor	currentPiece
      9  1a2c		       10 03		      bpl	.invalid
     10  1a2e		       20 85 f2    .squareEmpty jsr	AddMove
     11  1a31				   .invalid
     12  1a31
      0  1a31					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  1a31		       a6 93		      ldx	currentSquare
      0  1a33					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  1a33					      SUBROUTINE
      2  1a33
      3  1a33		       bc 21 fc 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      4  1a36		       30 0e		      bmi	.invalid
      5  1a38		       b9 79 fc 	      lda	Board,y
      6  1a3b		       85 a0		      sta	capture
      7  1a3d		       f0 04		      beq	.squareEmpty
      8  1a3f		       45 92		      eor	currentPiece
      9  1a41		       10 03		      bpl	.invalid
     10  1a43		       20 85 f2    .squareEmpty jsr	AddMove
     11  1a46				   .invalid
     12  1a46
     26  1a46
     27  1a46		       4c e8 f1 	      jmp	MoveReturn
     28  1a49
     29  1a49							; EOF
------- FILE @1 PIECE HANDLER #1.asm
------- FILE PIECE_BISHOP.asm LEVEL 3 PASS 4
      0  1a49					      include	"PIECE_BISHOP.asm"
      1  1a49							; Copyright (C)2020 Andrew Davie
      2  1a49
      3  1a49							;---------------------------------------------------------------------------------------------------
      4  1a49							; BISHOP
      5  1a49							;---------------------------------------------------------------------------------------------------
      6  1a49
      0  1a49					      DEF	Handle_BISHOP
      1  1a49				   SLOT_Handle_BISHOP SET	_BANK_SLOT
      2  1a49				   BANK_Handle_BISHOP SET	SLOT_Handle_BISHOP + _CURRENT_BANK
      3  1a49				   Handle_BISHOP
      4  1a49				   TEMPORARY_VAR SET	Overlay
      5  1a49				   TEMPORARY_OFFSET SET	0
      6  1a49				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      7  1a49				   FUNCTION_NAME SET	Handle_BISHOP
      8  1a49					      SUBROUTINE
      9  1a49
      0  1a49					      REF	GenerateAllMoves	;✅
      1  1a49					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1a49				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1a49					      ENDIF
      0  1a49					      VEND	Handle_BISHOP
      1  1a49
      2  1a49
      3  1a49		       00 bb	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
      4  1a49
     12  1a49
     13  1a49							; x = currentSquare (square the piece is on)
     14  1a49							; currentPiece (with flags/colour attached)
     15  1a49
      0  1a49					      MOVE_TOWARDS	_DOWN+_LEFT
      1  1a49					      SUBROUTINE
      2  1a49
      3  1a49
      4  1a49
      5  1a49		       a9 00		      lda	#0
      6  1a4b		       85 a0		      sta	capture
      7  1a4d
      8  1a4d		       a6 93		      ldx	currentSquare
      9  1a4f		       d0 03		      bne	.project
     10  1a51
     11  1a51		       20 85 f2    .empty     jsr	AddMove
     12  1a54		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  1a57		       30 0e		      bmi	.invalid
     14  1a59		       b9 79 fc 	      lda	Board,y
     15  1a5c		       f0 f3		      beq	.empty
     16  1a5e		       85 a0		      sta	capture
     17  1a60		       45 92		      eor	currentPiece
     18  1a62		       10 03		      bpl	.invalid
     19  1a64		       20 85 f2 	      jsr	AddMove
     20  1a67
     21  1a67				   .invalid
     22  1a67
      0  1a67					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  1a67					      SUBROUTINE
      2  1a67
      3  1a67
      4  1a67
      5  1a67		       a9 00		      lda	#0
      6  1a69		       85 a0		      sta	capture
      7  1a6b
      8  1a6b		       a6 93		      ldx	currentSquare
      9  1a6d		       d0 03		      bne	.project
     10  1a6f
     11  1a6f		       20 85 f2    .empty     jsr	AddMove
     12  1a72		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  1a75		       30 0e		      bmi	.invalid
     14  1a77		       b9 79 fc 	      lda	Board,y
     15  1a7a		       f0 f3		      beq	.empty
     16  1a7c		       85 a0		      sta	capture
     17  1a7e		       45 92		      eor	currentPiece
     18  1a80		       10 03		      bpl	.invalid
     19  1a82		       20 85 f2 	      jsr	AddMove
     20  1a85
     21  1a85				   .invalid
     22  1a85
      0  1a85					      MOVE_TOWARDS	_UP+_LEFT
      1  1a85					      SUBROUTINE
      2  1a85
      3  1a85
      4  1a85
      5  1a85		       a9 00		      lda	#0
      6  1a87		       85 a0		      sta	capture
      7  1a89
      8  1a89		       a6 93		      ldx	currentSquare
      9  1a8b		       d0 03		      bne	.project
     10  1a8d
     11  1a8d		       20 85 f2    .empty     jsr	AddMove
     12  1a90		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  1a93		       30 0e		      bmi	.invalid
     14  1a95		       b9 79 fc 	      lda	Board,y
     15  1a98		       f0 f3		      beq	.empty
     16  1a9a		       85 a0		      sta	capture
     17  1a9c		       45 92		      eor	currentPiece
     18  1a9e		       10 03		      bpl	.invalid
     19  1aa0		       20 85 f2 	      jsr	AddMove
     20  1aa3
     21  1aa3				   .invalid
     22  1aa3
      0  1aa3					      MOVE_TOWARDS	_UP+_RIGHT
      1  1aa3					      SUBROUTINE
      2  1aa3
      3  1aa3
      4  1aa3
      5  1aa3		       a9 00		      lda	#0
      6  1aa5		       85 a0		      sta	capture
      7  1aa7
      8  1aa7		       a6 93		      ldx	currentSquare
      9  1aa9		       d0 03		      bne	.project
     10  1aab
     11  1aab		       20 85 f2    .empty     jsr	AddMove
     12  1aae		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  1ab1		       30 0e		      bmi	.invalid
     14  1ab3		       b9 79 fc 	      lda	Board,y
     15  1ab6		       f0 f3		      beq	.empty
     16  1ab8		       85 a0		      sta	capture
     17  1aba		       45 92		      eor	currentPiece
     18  1abc		       10 03		      bpl	.invalid
     19  1abe		       20 85 f2 	      jsr	AddMove
     20  1ac1
     21  1ac1				   .invalid
     22  1ac1
     20  1ac1
     21  1ac1		       4c e8 f1 	      jmp	MoveReturn
     22  1ac4
     23  1ac4							;---------------------------------------------------------------------------------------------------
     24  1ac4							; EOF
------- FILE @1 PIECE HANDLER #1.asm
     17  1ac4
     18  1ac4							;---------------------------------------------------------------------------------------------------
     19  1ac4
      0  1ac4					      END_BANK
      1  1ac4				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  1ac4				  -	      CHECK_RAM_BANK_SIZE
      3  1ac4					      ELSE
      0  1ac4					      CHECK_BANK_SIZE
      1  1ac4		       02 c4	   .TEMP      =	* - _BANK_START
 ROM bank # 7 PIECE_HANDLER_1 size = $2c4 free = 315
      2  1ac4					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  1ac4				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1ac4				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  1ac4				  -	      ERR
      6  1ac4					      ENDIF
      5  1ac4					      ENDIF
     21  1ac4
     22  1ac4							;---------------------------------------------------------------------------------------------------
     23  1ac4							; EOF
------- FILE ./chess.asm
------- FILE @1 PIECE HANDLER #2.asm LEVEL 2 PASS 4
      0  1ac4					      include	"@1 PIECE HANDLER #2.asm"
      1  1ac4							;---------------------------------------------------------------------------------------------------
      2  1ac4							; @1 PIECE HANDLER #2.asm
      3  1ac4
      4  1ac4							; Atari 2600 Chess
      5  1ac4							; Copyright (c) 2019-2020 Andrew Davie
      6  1ac4							; andrew@taswegian.com
      7  1ac4
      8  1ac4
      9  1ac4							;---------------------------------------------------------------------------------------------------
     10  1ac4
      0  1ac4					      SLOT	1
      1  1ac4
      2  1ac4				  -	      IF	(1 < 0) || (1 > 3)
      3  1ac4				  -	      ECHO	"Illegal bank address/segment location", 1
      4  1ac4				  -	      ERR
      5  1ac4					      ENDIF
      6  1ac4
      7  1ac4				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  1ac4				   _BANK_SLOT SET	1 * 64
      9  1ac4
      0  1ac4					      ROMBANK	PIECE_HANDLER_2
      1  1e5c ????				      SEG	ROM_PIECE_HANDLER_2
      2  1c00					      ORG	_ORIGIN
      3  1c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  1c00				   _BANK_START SET	*
      5  1c00				   PIECE_HANDLER_2_START SET	*
      6  1c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  1c00				   ROMBANK_PIECE_HANDLER_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  1c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  1c00				   _LAST_BANK SETSTR	PIECE_HANDLER_2
     10  1c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  1c00
------- FILE PIECE_ROOK.asm LEVEL 3 PASS 4
      0  1c00					      include	"PIECE_ROOK.asm"
      1  1c00							; Copyright (C)2020 Andrew Davie
      2  1c00							; Rook move handler
      3  1c00
      4  1c00							;---------------------------------------------------------------------------------------------------
      5  1c00							; ROOK
      6  1c00							;---------------------------------------------------------------------------------------------------
      7  1c00
      0  1c00					      DEF	Handle_ROOK
      1  1c00				   SLOT_Handle_ROOK SET	_BANK_SLOT
      2  1c00				   BANK_Handle_ROOK SET	SLOT_Handle_ROOK + _CURRENT_BANK
      3  1c00				   Handle_ROOK
      4  1c00				   TEMPORARY_VAR SET	Overlay
      5  1c00				   TEMPORARY_OFFSET SET	0
      6  1c00				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      7  1c00				   FUNCTION_NAME SET	Handle_ROOK
      9  1c00					      SUBROUTINE
     10  1c00
      0  1c00					      REF	GenerateAllMoves	;✅
      1  1c00					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1c00				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1c00					      ENDIF
      0  1c00					      VEND	Handle_ROOK
      1  1c00
      2  1c00
      3  1c00		       00 bb	   VAREND_Handle_ROOK =	TEMPORARY_VAR
      4  1c00
     13  1c00
     14  1c00							; Pass...
     15  1c00							; x = currentSquare (square the piece is on)
     16  1c00							; currentPiece (with flags/colour attached)
     17  1c00
     18  1c00
      0  1c00					      MOVE_TOWARDS	_DOWN
      1  1c00					      SUBROUTINE
      2  1c00
      3  1c00
      4  1c00
      5  1c00		       a9 00		      lda	#0
      6  1c02		       85 a0		      sta	capture
      7  1c04
      8  1c04		       a6 93		      ldx	currentSquare
      9  1c06		       d0 03		      bne	.project
     10  1c08
     11  1c08		       20 85 f2    .empty     jsr	AddMove
     12  1c0b		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  1c0e		       30 0e		      bmi	.invalid
     14  1c10		       b9 79 fc 	      lda	Board,y
     15  1c13		       f0 f3		      beq	.empty
     16  1c15		       85 a0		      sta	capture
     17  1c17		       45 92		      eor	currentPiece
     18  1c19		       10 03		      bpl	.invalid
     19  1c1b		       20 85 f2 	      jsr	AddMove
     20  1c1e
     21  1c1e				   .invalid
     22  1c1e
      0  1c1e					      MOVE_TOWARDS	_RIGHT
      1  1c1e					      SUBROUTINE
      2  1c1e
      3  1c1e
      4  1c1e
      5  1c1e		       a9 00		      lda	#0
      6  1c20		       85 a0		      sta	capture
      7  1c22
      8  1c22		       a6 93		      ldx	currentSquare
      9  1c24		       d0 03		      bne	.project
     10  1c26
     11  1c26		       20 85 f2    .empty     jsr	AddMove
     12  1c29		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  1c2c		       30 0e		      bmi	.invalid
     14  1c2e		       b9 79 fc 	      lda	Board,y
     15  1c31		       f0 f3		      beq	.empty
     16  1c33		       85 a0		      sta	capture
     17  1c35		       45 92		      eor	currentPiece
     18  1c37		       10 03		      bpl	.invalid
     19  1c39		       20 85 f2 	      jsr	AddMove
     20  1c3c
     21  1c3c				   .invalid
     22  1c3c
      0  1c3c					      MOVE_TOWARDS	_UP
      1  1c3c					      SUBROUTINE
      2  1c3c
      3  1c3c
      4  1c3c
      5  1c3c		       a9 00		      lda	#0
      6  1c3e		       85 a0		      sta	capture
      7  1c40
      8  1c40		       a6 93		      ldx	currentSquare
      9  1c42		       d0 03		      bne	.project
     10  1c44
     11  1c44		       20 85 f2    .empty     jsr	AddMove
     12  1c47		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  1c4a		       30 0e		      bmi	.invalid
     14  1c4c		       b9 79 fc 	      lda	Board,y
     15  1c4f		       f0 f3		      beq	.empty
     16  1c51		       85 a0		      sta	capture
     17  1c53		       45 92		      eor	currentPiece
     18  1c55		       10 03		      bpl	.invalid
     19  1c57		       20 85 f2 	      jsr	AddMove
     20  1c5a
     21  1c5a				   .invalid
     22  1c5a
      0  1c5a					      MOVE_TOWARDS	_LEFT
      1  1c5a					      SUBROUTINE
      2  1c5a
      3  1c5a
      4  1c5a
      5  1c5a		       a9 00		      lda	#0
      6  1c5c		       85 a0		      sta	capture
      7  1c5e
      8  1c5e		       a6 93		      ldx	currentSquare
      9  1c60		       d0 03		      bne	.project
     10  1c62
     11  1c62		       20 85 f2    .empty     jsr	AddMove
     12  1c65		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  1c68		       30 0e		      bmi	.invalid
     14  1c6a		       b9 79 fc 	      lda	Board,y
     15  1c6d		       f0 f3		      beq	.empty
     16  1c6f		       85 a0		      sta	capture
     17  1c71		       45 92		      eor	currentPiece
     18  1c73		       10 03		      bpl	.invalid
     19  1c75		       20 85 f2 	      jsr	AddMove
     20  1c78
     21  1c78				   .invalid
     22  1c78
     23  1c78
     24  1c78		       4c e8 f1 	      jmp	MoveReturn
     25  1c7b
     26  1c7b							;---------------------------------------------------------------------------------------------------
     27  1c7b							; EOF
------- FILE @1 PIECE HANDLER #2.asm
------- FILE PIECE_QUEEN.asm LEVEL 3 PASS 4
      0  1c7b					      include	"PIECE_QUEEN.asm"
      1  1c7b							; Copyright (C)2020 Andrew Davie
      2  1c7b
      3  1c7b							;---------------------------------------------------------------------------------------------------
      4  1c7b							; QUEEN
      5  1c7b							;---------------------------------------------------------------------------------------------------
      6  1c7b
      0  1c7b					      DEF	Handle_QUEEN
      1  1c7b				   SLOT_Handle_QUEEN SET	_BANK_SLOT
      2  1c7b				   BANK_Handle_QUEEN SET	SLOT_Handle_QUEEN + _CURRENT_BANK
      3  1c7b				   Handle_QUEEN
      4  1c7b				   TEMPORARY_VAR SET	Overlay
      5  1c7b				   TEMPORARY_OFFSET SET	0
      6  1c7b				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      7  1c7b				   FUNCTION_NAME SET	Handle_QUEEN
      8  1c7b					      SUBROUTINE
      9  1c7b
      0  1c7b					      REF	GenerateAllMoves	;✅
      1  1c7b					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1c7b				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1c7b					      ENDIF
      0  1c7b					      VEND	Handle_QUEEN
      1  1c7b
      2  1c7b
      3  1c7b		       00 bb	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
      4  1c7b
     12  1c7b
     13  1c7b							; Pass...
     14  1c7b							; x = currentSquare (square the piece is on)
     15  1c7b							; currentPiece (with flags/colour attached)
     16  1c7b
      0  1c7b					      MOVE_TOWARDS	_DOWN+_LEFT
      1  1c7b					      SUBROUTINE
      2  1c7b
      3  1c7b
      4  1c7b
      5  1c7b		       a9 00		      lda	#0
      6  1c7d		       85 a0		      sta	capture
      7  1c7f
      8  1c7f		       a6 93		      ldx	currentSquare
      9  1c81		       d0 03		      bne	.project
     10  1c83
     11  1c83		       20 85 f2    .empty     jsr	AddMove
     12  1c86		       bc 0a fc    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  1c89		       30 0e		      bmi	.invalid
     14  1c8b		       b9 79 fc 	      lda	Board,y
     15  1c8e		       f0 f3		      beq	.empty
     16  1c90		       85 a0		      sta	capture
     17  1c92		       45 92		      eor	currentPiece
     18  1c94		       10 03		      bpl	.invalid
     19  1c96		       20 85 f2 	      jsr	AddMove
     20  1c99
     21  1c99				   .invalid
     22  1c99
      0  1c99					      MOVE_TOWARDS	_DOWN
      1  1c99					      SUBROUTINE
      2  1c99
      3  1c99
      4  1c99
      5  1c99		       a9 00		      lda	#0
      6  1c9b		       85 a0		      sta	capture
      7  1c9d
      8  1c9d		       a6 93		      ldx	currentSquare
      9  1c9f		       d0 03		      bne	.project
     10  1ca1
     11  1ca1		       20 85 f2    .empty     jsr	AddMove
     12  1ca4		       bc 0b fc    .project   ldy	ValidSquare+_DOWN,x
     13  1ca7		       30 0e		      bmi	.invalid
     14  1ca9		       b9 79 fc 	      lda	Board,y
     15  1cac		       f0 f3		      beq	.empty
     16  1cae		       85 a0		      sta	capture
     17  1cb0		       45 92		      eor	currentPiece
     18  1cb2		       10 03		      bpl	.invalid
     19  1cb4		       20 85 f2 	      jsr	AddMove
     20  1cb7
     21  1cb7				   .invalid
     22  1cb7
      0  1cb7					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  1cb7					      SUBROUTINE
      2  1cb7
      3  1cb7
      4  1cb7
      5  1cb7		       a9 00		      lda	#0
      6  1cb9		       85 a0		      sta	capture
      7  1cbb
      8  1cbb		       a6 93		      ldx	currentSquare
      9  1cbd		       d0 03		      bne	.project
     10  1cbf
     11  1cbf		       20 85 f2    .empty     jsr	AddMove
     12  1cc2		       bc 0c fc    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  1cc5		       30 0e		      bmi	.invalid
     14  1cc7		       b9 79 fc 	      lda	Board,y
     15  1cca		       f0 f3		      beq	.empty
     16  1ccc		       85 a0		      sta	capture
     17  1cce		       45 92		      eor	currentPiece
     18  1cd0		       10 03		      bpl	.invalid
     19  1cd2		       20 85 f2 	      jsr	AddMove
     20  1cd5
     21  1cd5				   .invalid
     22  1cd5
      0  1cd5					      MOVE_TOWARDS	_RIGHT
      1  1cd5					      SUBROUTINE
      2  1cd5
      3  1cd5
      4  1cd5
      5  1cd5		       a9 00		      lda	#0
      6  1cd7		       85 a0		      sta	capture
      7  1cd9
      8  1cd9		       a6 93		      ldx	currentSquare
      9  1cdb		       d0 03		      bne	.project
     10  1cdd
     11  1cdd		       20 85 f2    .empty     jsr	AddMove
     12  1ce0		       bc 16 fc    .project   ldy	ValidSquare+_RIGHT,x
     13  1ce3		       30 0e		      bmi	.invalid
     14  1ce5		       b9 79 fc 	      lda	Board,y
     15  1ce8		       f0 f3		      beq	.empty
     16  1cea		       85 a0		      sta	capture
     17  1cec		       45 92		      eor	currentPiece
     18  1cee		       10 03		      bpl	.invalid
     19  1cf0		       20 85 f2 	      jsr	AddMove
     20  1cf3
     21  1cf3				   .invalid
     22  1cf3
      0  1cf3					      MOVE_TOWARDS	_UP+_RIGHT
      1  1cf3					      SUBROUTINE
      2  1cf3
      3  1cf3
      4  1cf3
      5  1cf3		       a9 00		      lda	#0
      6  1cf5		       85 a0		      sta	capture
      7  1cf7
      8  1cf7		       a6 93		      ldx	currentSquare
      9  1cf9		       d0 03		      bne	.project
     10  1cfb
     11  1cfb		       20 85 f2    .empty     jsr	AddMove
     12  1cfe		       bc 20 fc    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  1d01		       30 0e		      bmi	.invalid
     14  1d03		       b9 79 fc 	      lda	Board,y
     15  1d06		       f0 f3		      beq	.empty
     16  1d08		       85 a0		      sta	capture
     17  1d0a		       45 92		      eor	currentPiece
     18  1d0c		       10 03		      bpl	.invalid
     19  1d0e		       20 85 f2 	      jsr	AddMove
     20  1d11
     21  1d11				   .invalid
     22  1d11
      0  1d11					      MOVE_TOWARDS	_UP
      1  1d11					      SUBROUTINE
      2  1d11
      3  1d11
      4  1d11
      5  1d11		       a9 00		      lda	#0
      6  1d13		       85 a0		      sta	capture
      7  1d15
      8  1d15		       a6 93		      ldx	currentSquare
      9  1d17		       d0 03		      bne	.project
     10  1d19
     11  1d19		       20 85 f2    .empty     jsr	AddMove
     12  1d1c		       bc 1f fc    .project   ldy	ValidSquare+_UP,x
     13  1d1f		       30 0e		      bmi	.invalid
     14  1d21		       b9 79 fc 	      lda	Board,y
     15  1d24		       f0 f3		      beq	.empty
     16  1d26		       85 a0		      sta	capture
     17  1d28		       45 92		      eor	currentPiece
     18  1d2a		       10 03		      bpl	.invalid
     19  1d2c		       20 85 f2 	      jsr	AddMove
     20  1d2f
     21  1d2f				   .invalid
     22  1d2f
      0  1d2f					      MOVE_TOWARDS	_UP+_LEFT
      1  1d2f					      SUBROUTINE
      2  1d2f
      3  1d2f
      4  1d2f
      5  1d2f		       a9 00		      lda	#0
      6  1d31		       85 a0		      sta	capture
      7  1d33
      8  1d33		       a6 93		      ldx	currentSquare
      9  1d35		       d0 03		      bne	.project
     10  1d37
     11  1d37		       20 85 f2    .empty     jsr	AddMove
     12  1d3a		       bc 1e fc    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  1d3d		       30 0e		      bmi	.invalid
     14  1d3f		       b9 79 fc 	      lda	Board,y
     15  1d42		       f0 f3		      beq	.empty
     16  1d44		       85 a0		      sta	capture
     17  1d46		       45 92		      eor	currentPiece
     18  1d48		       10 03		      bpl	.invalid
     19  1d4a		       20 85 f2 	      jsr	AddMove
     20  1d4d
     21  1d4d				   .invalid
     22  1d4d
      0  1d4d					      MOVE_TOWARDS	_LEFT
      1  1d4d					      SUBROUTINE
      2  1d4d
      3  1d4d
      4  1d4d
      5  1d4d		       a9 00		      lda	#0
      6  1d4f		       85 a0		      sta	capture
      7  1d51
      8  1d51		       a6 93		      ldx	currentSquare
      9  1d53		       d0 03		      bne	.project
     10  1d55
     11  1d55		       20 85 f2    .empty     jsr	AddMove
     12  1d58		       bc 14 fc    .project   ldy	ValidSquare+_LEFT,x
     13  1d5b		       30 0e		      bmi	.invalid
     14  1d5d		       b9 79 fc 	      lda	Board,y
     15  1d60		       f0 f3		      beq	.empty
     16  1d62		       85 a0		      sta	capture
     17  1d64		       45 92		      eor	currentPiece
     18  1d66		       10 03		      bpl	.invalid
     19  1d68		       20 85 f2 	      jsr	AddMove
     20  1d6b
     21  1d6b				   .invalid
     22  1d6b
     25  1d6b
     26  1d6b		       4c e8 f1 	      jmp	MoveReturn
     27  1d6e
     28  1d6e							; EOF
------- FILE @1 PIECE HANDLER #2.asm
------- FILE PIECE_KING.asm LEVEL 3 PASS 4
      0  1d6e					      include	"PIECE_KING.asm"
      1  1d6e							; Copyright (C)2020 Andrew Davie
      2  1d6e
      3  1d6e							;---------------------------------------------------------------------------------------------------
      4  1d6e							; KING
      5  1d6e							; This is the move handler for a KING
      6  1d6e							; "Check" is detected in the next ply of the search.
      7  1d6e
      8  1d6e
      9  1d6e							;---------------------------------------------------------------------------------------------------
     10  1d6e
     11  1d6e							; MACRO - Castling
     12  1d6e
     13  1d6e		       00 03	   KINGSIDE   =	3
     14  1d6e		       ff ff ff fc QUEENSIDE  =	-4
     15  1d6e
     16  1d6e					      MAC	castle
     17  1d6e							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  1d6e
     19  1d6e					      ldx	currentSquare
     20  1d6e					      lda	Board+{1},x	; kingside/queenside R position
     21  1d6e					      and	#PIECE_MASK|FLAG_MOVED
     22  1d6e					      cmp	#ROOK
     23  1d6e					      bne	.noCastle	; not a R that hasn't moved
     24  1d6e
     25  1d6e							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  1d6e							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  1d6e
     28  1d6e					      IF	{1} = QUEENSIDE
     29  1d6e					      lda	Board-3,x	; N pos
     30  1d6e					      ora	Board-2,x	; B pos
     31  1d6e					      ora	Board-1,x	; Q pos
     32  1d6e					      bne	.noCastle	; not vacant?
     33  1d6e
     34  1d6e					      ENDIF
     35  1d6e
     36  1d6e					      IF	{1} = KINGSIDE
     37  1d6e					      lda	Board+2,x	; N pos
     38  1d6e					      ora	Board+1,x	; B pos
     39  1d6e					      bne	.noCastle	; not vacant?
     40  1d6e					      ENDIF
     41  1d6e
     42  1d6e							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  1d6e
     44  1d6e							; FINALLY -- king can castle
     45  1d6e							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  1d6e							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  1d6e							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  1d6e
     49  1d6e					      lda	currentPiece
     50  1d6e					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  1d6e					      sta	currentPiece
     52  1d6e
     53  1d6e					      IF	{1} = KINGSIDE
     54  1d6e					      ldy	ValidSquare+2,x
     55  1d6e					      ENDIF
     56  1d6e
     57  1d6e					      IF	{1} = QUEENSIDE
     58  1d6e					      ldy	ValidSquare-2,x
     59  1d6e					      ENDIF
     60  1d6e
     61  1d6e
     62  1d6e					      jsr	AddMove	; 57
     63  1d6e				   .noCastle
     64  1d6e					      ENDM
     65  1d6e
     66  1d6e
     67  1d6e							;---------------------------------------------------------------------------------------------------
     68  1d6e
      0  1d6e					      DEF	Handle_KING
      1  1d6e				   SLOT_Handle_KING SET	_BANK_SLOT
      2  1d6e				   BANK_Handle_KING SET	SLOT_Handle_KING + _CURRENT_BANK
      3  1d6e				   Handle_KING
      4  1d6e				   TEMPORARY_VAR SET	Overlay
      5  1d6e				   TEMPORARY_OFFSET SET	0
      6  1d6e				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      7  1d6e				   FUNCTION_NAME SET	Handle_KING
     70  1d6e					      SUBROUTINE
     71  1d6e
      0  1d6e					      REF	GenerateAllMoves	;✅
      1  1d6e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  1d6e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  1d6e					      ENDIF
      0  1d6e					      VEND	Handle_KING
      1  1d6e
      2  1d6e
      3  1d6e		       00 bb	   VAREND_Handle_KING =	TEMPORARY_VAR
      4  1d6e
     74  1d6e
     75  1d6e							; x = currentSquare (square the KING is on)
     76  1d6e							; currentPiece (KING of course, but with flags/colour attached)
     77  1d6e
     78  1d6e
      0  1d6e					      MOVE_TO	_DOWN+_LEFT
      1  1d6e					      SUBROUTINE
      2  1d6e
      3  1d6e		       bc 0a fc 	      ldy	ValidSquare+_DOWN+_LEFT,x
      4  1d71		       30 0e		      bmi	.invalid
      5  1d73		       b9 79 fc 	      lda	Board,y
      6  1d76		       85 a0		      sta	capture
      7  1d78		       f0 04		      beq	.squareEmpty
      8  1d7a		       45 92		      eor	currentPiece
      9  1d7c		       10 03		      bpl	.invalid
     10  1d7e		       20 85 f2    .squareEmpty jsr	AddMove
     11  1d81				   .invalid
     12  1d81
     80  1d81					      IF	1
      0  1d81					      MOVE_TO_X	_DOWN
      1  1d81		       a6 93		      ldx	currentSquare
      0  1d83					      MOVE_TO	_DOWN
      1  1d83					      SUBROUTINE
      2  1d83
      3  1d83		       bc 0b fc 	      ldy	ValidSquare+_DOWN,x
      4  1d86		       30 0e		      bmi	.invalid
      5  1d88		       b9 79 fc 	      lda	Board,y
      6  1d8b		       85 a0		      sta	capture
      7  1d8d		       f0 04		      beq	.squareEmpty
      8  1d8f		       45 92		      eor	currentPiece
      9  1d91		       10 03		      bpl	.invalid
     10  1d93		       20 85 f2    .squareEmpty jsr	AddMove
     11  1d96				   .invalid
     12  1d96
      0  1d96					      MOVE_TO_X	_DOWN+_RIGHT
      1  1d96		       a6 93		      ldx	currentSquare
      0  1d98					      MOVE_TO	_DOWN+_RIGHT
      1  1d98					      SUBROUTINE
      2  1d98
      3  1d98		       bc 0c fc 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      4  1d9b		       30 0e		      bmi	.invalid
      5  1d9d		       b9 79 fc 	      lda	Board,y
      6  1da0		       85 a0		      sta	capture
      7  1da2		       f0 04		      beq	.squareEmpty
      8  1da4		       45 92		      eor	currentPiece
      9  1da6		       10 03		      bpl	.invalid
     10  1da8		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dab				   .invalid
     12  1dab
      0  1dab					      MOVE_TO_X	_RIGHT
      1  1dab		       a6 93		      ldx	currentSquare
      0  1dad					      MOVE_TO	_RIGHT
      1  1dad					      SUBROUTINE
      2  1dad
      3  1dad		       bc 16 fc 	      ldy	ValidSquare+_RIGHT,x
      4  1db0		       30 0e		      bmi	.invalid
      5  1db2		       b9 79 fc 	      lda	Board,y
      6  1db5		       85 a0		      sta	capture
      7  1db7		       f0 04		      beq	.squareEmpty
      8  1db9		       45 92		      eor	currentPiece
      9  1dbb		       10 03		      bpl	.invalid
     10  1dbd		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dc0				   .invalid
     12  1dc0
      0  1dc0					      MOVE_TO_X	_UP+_RIGHT
      1  1dc0		       a6 93		      ldx	currentSquare
      0  1dc2					      MOVE_TO	_UP+_RIGHT
      1  1dc2					      SUBROUTINE
      2  1dc2
      3  1dc2		       bc 20 fc 	      ldy	ValidSquare+_UP+_RIGHT,x
      4  1dc5		       30 0e		      bmi	.invalid
      5  1dc7		       b9 79 fc 	      lda	Board,y
      6  1dca		       85 a0		      sta	capture
      7  1dcc		       f0 04		      beq	.squareEmpty
      8  1dce		       45 92		      eor	currentPiece
      9  1dd0		       10 03		      bpl	.invalid
     10  1dd2		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dd5				   .invalid
     12  1dd5
      0  1dd5					      MOVE_TO_X	_UP
      1  1dd5		       a6 93		      ldx	currentSquare
      0  1dd7					      MOVE_TO	_UP
      1  1dd7					      SUBROUTINE
      2  1dd7
      3  1dd7		       bc 1f fc 	      ldy	ValidSquare+_UP,x
      4  1dda		       30 0e		      bmi	.invalid
      5  1ddc		       b9 79 fc 	      lda	Board,y
      6  1ddf		       85 a0		      sta	capture
      7  1de1		       f0 04		      beq	.squareEmpty
      8  1de3		       45 92		      eor	currentPiece
      9  1de5		       10 03		      bpl	.invalid
     10  1de7		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dea				   .invalid
     12  1dea
      0  1dea					      MOVE_TO_X	_UP+_LEFT
      1  1dea		       a6 93		      ldx	currentSquare
      0  1dec					      MOVE_TO	_UP+_LEFT
      1  1dec					      SUBROUTINE
      2  1dec
      3  1dec		       bc 1e fc 	      ldy	ValidSquare+_UP+_LEFT,x
      4  1def		       30 0e		      bmi	.invalid
      5  1df1		       b9 79 fc 	      lda	Board,y
      6  1df4		       85 a0		      sta	capture
      7  1df6		       f0 04		      beq	.squareEmpty
      8  1df8		       45 92		      eor	currentPiece
      9  1dfa		       10 03		      bpl	.invalid
     10  1dfc		       20 85 f2    .squareEmpty jsr	AddMove
     11  1dff				   .invalid
     12  1dff
      0  1dff					      MOVE_TO_X	_LEFT
      1  1dff		       a6 93		      ldx	currentSquare
      0  1e01					      MOVE_TO	_LEFT
      1  1e01					      SUBROUTINE
      2  1e01
      3  1e01		       bc 14 fc 	      ldy	ValidSquare+_LEFT,x
      4  1e04		       30 0e		      bmi	.invalid
      5  1e06		       b9 79 fc 	      lda	Board,y
      6  1e09		       85 a0		      sta	capture
      7  1e0b		       f0 04		      beq	.squareEmpty
      8  1e0d		       45 92		      eor	currentPiece
      9  1e0f		       10 03		      bpl	.invalid
     10  1e11		       20 85 f2    .squareEmpty jsr	AddMove
     11  1e14				   .invalid
     12  1e14
     88  1e14					      ENDIF
     89  1e14
     90  1e14					      IF	CASTLING_ENABLED
     91  1e14
     92  1e14		       24 92		      bit	currentPiece
     93  1e16		       70 41		      bvs	.exit	; king has moved, so no castling
     94  1e18
      0  1e18					      CASTLE	KINGSIDE
      1  1e18
      2  1e18
      3  1e18		       a6 93		      ldx	currentSquare
      4  1e1a		       bd 7c fc 	      lda	Board+KINGSIDE,x
      5  1e1d		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  1e1f		       c9 05		      cmp	#ROOK
      7  1e21		       d0 14		      bne	.noCastle
      8  1e23
      9  1e23
     10  1e23
     11  1e23
     12  1e23				  -	      IF	KINGSIDE = QUEENSIDE
     13  1e23				  -	      lda	Board-3,x
     14  1e23				  -	      ora	Board-2,x
     15  1e23				  -	      ora	Board-1,x
     16  1e23				  -	      bne	.noCastle
     17  1e23				  -
     18  1e23					      ENDIF
     19  1e23
     20  1e23					      IF	KINGSIDE = KINGSIDE
     21  1e23		       bd 7b fc 	      lda	Board+2,x
     22  1e26		       1d 7a fc 	      ora	Board+1,x
     23  1e29		       d0 0c		      bne	.noCastle
     24  1e2b					      ENDIF
     25  1e2b
     26  1e2b
     27  1e2b
     28  1e2b
     29  1e2b
     30  1e2b
     31  1e2b
     32  1e2b
     33  1e2b		       a5 92		      lda	currentPiece
     34  1e2d		       09 10		      ora	#FLAG_CASTLE
     35  1e2f		       85 92		      sta	currentPiece
     36  1e31
     37  1e31					      IF	KINGSIDE = KINGSIDE
     38  1e31		       bc 17 fc 	      ldy	ValidSquare+2,x
     39  1e34					      ENDIF
     40  1e34
     41  1e34				  -	      IF	KINGSIDE = QUEENSIDE
     42  1e34				  -	      ldy	ValidSquare-2,x
     43  1e34					      ENDIF
     44  1e34
     45  1e34
     46  1e34		       20 85 f2 	      jsr	AddMove
     47  1e37				   .noCastle
      0  1e37					      CASTLE	QUEENSIDE
      1  1e37
      2  1e37
      3  1e37		       a6 93		      ldx	currentSquare
      4  1e39		       bd 75 fc 	      lda	Board+QUEENSIDE,x
      5  1e3c		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  1e3e		       c9 05		      cmp	#ROOK
      7  1e40		       d0 17		      bne	.noCastle
      8  1e42
      9  1e42
     10  1e42
     11  1e42
     12  1e42					      IF	QUEENSIDE = QUEENSIDE
     13  1e42		       bd 76 fc 	      lda	Board-3,x
     14  1e45		       1d 77 fc 	      ora	Board-2,x
     15  1e48		       1d 78 fc 	      ora	Board-1,x
     16  1e4b		       d0 0c		      bne	.noCastle
     17  1e4d
     18  1e4d					      ENDIF
     19  1e4d
     20  1e4d				  -	      IF	QUEENSIDE = KINGSIDE
     21  1e4d				  -	      lda	Board+2,x
     22  1e4d				  -	      ora	Board+1,x
     23  1e4d				  -	      bne	.noCastle
     24  1e4d					      ENDIF
     25  1e4d
     26  1e4d
     27  1e4d
     28  1e4d
     29  1e4d
     30  1e4d
     31  1e4d
     32  1e4d
     33  1e4d		       a5 92		      lda	currentPiece
     34  1e4f		       09 10		      ora	#FLAG_CASTLE
     35  1e51		       85 92		      sta	currentPiece
     36  1e53
     37  1e53				  -	      IF	QUEENSIDE = KINGSIDE
     38  1e53				  -	      ldy	ValidSquare+2,x
     39  1e53					      ENDIF
     40  1e53
     41  1e53					      IF	QUEENSIDE = QUEENSIDE
     42  1e53		       bc 13 fc 	      ldy	ValidSquare-2,x
     43  1e56					      ENDIF
     44  1e56
     45  1e56
     46  1e56		       20 85 f2 	      jsr	AddMove
     47  1e59				   .noCastle
     97  1e59
     98  1e59					      ENDIF
     99  1e59
    100  1e59
    101  1e59		       4c e8 f1    .exit      jmp	MoveReturn
    102  1e5c
    103  1e5c							;---------------------------------------------------------------------------------------------------
    104  1e5c							; EOF
------- FILE @1 PIECE HANDLER #2.asm
     17  1e5c
     18  1e5c							;---------------------------------------------------------------------------------------------------
     19  1e5c
      0  1e5c					      END_BANK
      1  1e5c				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  1e5c				  -	      CHECK_RAM_BANK_SIZE
      3  1e5c					      ELSE
      0  1e5c					      CHECK_BANK_SIZE
      1  1e5c		       02 5c	   .TEMP      =	* - _BANK_START
 ROM bank # 8 PIECE_HANDLER_2 size = $25c free = 419
      2  1e5c					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  1e5c				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  1e5c				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  1e5c				  -	      ERR
      6  1e5c					      ENDIF
      5  1e5c					      ENDIF
     21  1e5c
     22  1e5c							;---------------------------------------------------------------------------------------------------
     23  1e5c							; EOF
------- FILE ./chess.asm
    199  1e5c
------- FILE @2 SCREEN RAM.asm LEVEL 2 PASS 4
      0  1e5c					      include	"@2 SCREEN RAM.asm"
      1  1e5c							;---------------------------------------------------------------------------------------------------
      2  1e5c							; @2 SCREEN RAM.asm
      3  1e5c
      4  1e5c							; Atari 2600 Chess
      5  1e5c							; Copyright (c) 2019-2020 Andrew Davie
      6  1e5c							; andrew@taswegian.com
      7  1e5c
      8  1e5c
      9  1e5c							;---------------------------------------------------------------------------------------------------
     10  1e5c
      0  1e5c					      SLOT	2
      1  1e5c
      2  1e5c				  -	      IF	(2 < 0) || (2 > 3)
      3  1e5c				  -	      ECHO	"Illegal bank address/segment location", 2
      4  1e5c				  -	      ERR
      5  1e5c					      ENDIF
      6  1e5c
      7  1e5c				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  1e5c				   _BANK_SLOT SET	2 * 64
      9  1e5c
     12  1e5c					      REPEAT	CHESSBOARD_ROWS
      0  1e5c					      RAMBANK	CHESSBOARDROW
      1  1e5c
      2 U0e00 ????				      SEG.U	RAM_CHESSBOARDROW
      3 U0000					      ORG	ORIGIN_RAM
      4 U0000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0000				   _BANK_START SET	*
      6 U0000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0000				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0000				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0000					      END_BANK
      1 U0000					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0000					      CHECK_RAM_BANK_SIZE
      1 U0000		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 1 CHESSBOARDROW size =  $0 free = $1ff
      2 U0000					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0000				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0000				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0000				  -	      ERR
      6 U0000					      ENDIF
      3 U0000				  -	      ELSE
      4 U0000				  -	      CHECK_BANK_SIZE
      5 U0000					      ENDIF
     12 U0000					      REPEND
      0 U0000					      RAMBANK	CHESSBOARDROW
      1 U0000
      2 U0000					      SEG.U	RAM_CHESSBOARDROW
      3 U0200					      ORG	ORIGIN_RAM
      4 U0200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0200				   _BANK_START SET	*
      6 U0200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0200				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0200				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0200					      END_BANK
      1 U0200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0200					      CHECK_RAM_BANK_SIZE
      1 U0200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 2 CHESSBOARDROW size =  $0 free = $1ff
      2 U0200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0200				  -	      ERR
      6 U0200					      ENDIF
      3 U0200				  -	      ELSE
      4 U0200				  -	      CHECK_BANK_SIZE
      5 U0200					      ENDIF
     12 U0200					      REPEND
      0 U0200					      RAMBANK	CHESSBOARDROW
      1 U0200
      2 U0200					      SEG.U	RAM_CHESSBOARDROW
      3 U0400					      ORG	ORIGIN_RAM
      4 U0400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0400				   _BANK_START SET	*
      6 U0400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0400				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0400				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0400					      END_BANK
      1 U0400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0400					      CHECK_RAM_BANK_SIZE
      1 U0400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 3 CHESSBOARDROW size =  $0 free = $1ff
      2 U0400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0400				  -	      ERR
      6 U0400					      ENDIF
      3 U0400				  -	      ELSE
      4 U0400				  -	      CHECK_BANK_SIZE
      5 U0400					      ENDIF
     12 U0400					      REPEND
      0 U0400					      RAMBANK	CHESSBOARDROW
      1 U0400
      2 U0400					      SEG.U	RAM_CHESSBOARDROW
      3 U0600					      ORG	ORIGIN_RAM
      4 U0600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0600				   _BANK_START SET	*
      6 U0600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0600				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0600				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0600					      END_BANK
      1 U0600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0600					      CHECK_RAM_BANK_SIZE
      1 U0600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 4 CHESSBOARDROW size =  $0 free = $1ff
      2 U0600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0600				  -	      ERR
      6 U0600					      ENDIF
      3 U0600				  -	      ELSE
      4 U0600				  -	      CHECK_BANK_SIZE
      5 U0600					      ENDIF
     12 U0600					      REPEND
      0 U0600					      RAMBANK	CHESSBOARDROW
      1 U0600
      2 U0600					      SEG.U	RAM_CHESSBOARDROW
      3 U0800					      ORG	ORIGIN_RAM
      4 U0800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0800				   _BANK_START SET	*
      6 U0800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0800				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0800				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0800				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0800					      END_BANK
      1 U0800					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0800					      CHECK_RAM_BANK_SIZE
      1 U0800		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 5 CHESSBOARDROW size =  $0 free = $1ff
      2 U0800					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0800				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0800				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0800				  -	      ERR
      6 U0800					      ENDIF
      3 U0800				  -	      ELSE
      4 U0800				  -	      CHECK_BANK_SIZE
      5 U0800					      ENDIF
     12 U0800					      REPEND
      0 U0800					      RAMBANK	CHESSBOARDROW
      1 U0800
      2 U0800					      SEG.U	RAM_CHESSBOARDROW
      3 U0a00					      ORG	ORIGIN_RAM
      4 U0a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0a00				   _BANK_START SET	*
      6 U0a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0a00				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0a00				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0a00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0a00					      END_BANK
      1 U0a00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0a00					      CHECK_RAM_BANK_SIZE
      1 U0a00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 6 CHESSBOARDROW size =  $0 free = $1ff
      2 U0a00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0a00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0a00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0a00				  -	      ERR
      6 U0a00					      ENDIF
      3 U0a00				  -	      ELSE
      4 U0a00				  -	      CHECK_BANK_SIZE
      5 U0a00					      ENDIF
     12 U0a00					      REPEND
      0 U0a00					      RAMBANK	CHESSBOARDROW
      1 U0a00
      2 U0a00					      SEG.U	RAM_CHESSBOARDROW
      3 U0c00					      ORG	ORIGIN_RAM
      4 U0c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0c00				   _BANK_START SET	*
      6 U0c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0c00				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0c00				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0c00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0c00					      END_BANK
      1 U0c00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0c00					      CHECK_RAM_BANK_SIZE
      1 U0c00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 7 CHESSBOARDROW size =  $0 free = $1ff
      2 U0c00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0c00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0c00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0c00				  -	      ERR
      6 U0c00					      ENDIF
      3 U0c00				  -	      ELSE
      4 U0c00				  -	      CHECK_BANK_SIZE
      5 U0c00					      ENDIF
     12 U0c00					      REPEND
      0 U0c00					      RAMBANK	CHESSBOARDROW
      1 U0c00
      2 U0c00					      SEG.U	RAM_CHESSBOARDROW
      3 U0e00					      ORG	ORIGIN_RAM
      4 U0e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U0e00				   _BANK_START SET	*
      6 U0e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U0e00				   RAMBANK_CHESSBOARDROW SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U0e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U0e00				   _LAST_BANK SETSTR	CHESSBOARDROW
     10 U0e00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U0e00					      END_BANK
      1 U0e00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U0e00					      CHECK_RAM_BANK_SIZE
      1 U0e00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 8 CHESSBOARDROW size =  $0 free = $1ff
      2 U0e00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U0e00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U0e00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U0e00				  -	      ERR
      6 U0e00					      ENDIF
      3 U0e00				  -	      ELSE
      4 U0e00				  -	      CHECK_BANK_SIZE
      5 U0e00					      ENDIF
     15 U0e00					      REPEND
     16 U0e00
     17 U0e00
     18 U0e00							;---------------------------------------------------------------------------------------------------
     19 U0e00
     20 U0e00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
     21 U0e00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
     22 U0e00							; The variable definitions are also in that ROM bank (even though they're RAM :)
     23 U0e00
     24 U0e00							; Now we have the actual graphics data for each of the rows.  This consists of an
     25 U0e00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
     26 U0e00							; character shapes are masked/copied. The depth of the character shapes may be
     27 U0e00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
     28 U0e00							; a multiple of 3, so that the RGB scanlines match at character joins.
     29 U0e00
     30 U0e00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
     31 U0e00							; accessed via the above labels but with the appropriate bank switched in.
     32 U0e00
      0 U0e00					      ROMBANK	BITMAP
      1  21d9 ????				      SEG	ROM_BITMAP
      2  2000					      ORG	_ORIGIN
      3  2000					      RORG	_BANK_ADDRESS_ORIGIN
      4  2000				   _BANK_START SET	*
      5  2000				   BITMAP_START SET	*
      6  2000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2000				   ROMBANK_BITMAP SET	_BANK_SLOT + _CURRENT_BANK
      8  2000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2000				   _LAST_BANK SETSTR	BITMAP
     10  2000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     34  2000
     35  2000							; These equates allow revectoring (address offset) if the RAM slot is not the same as the SHADOW slot
     36  2000
     37  2000		       f8 00	   ChessBitmap =	SHADOW_ChessBitmap
     38  2000
     39  2000		       f8 00	   ChessBitmap0 =	SHADOW_ChessBitmap0
     40  2000		       f8 18	   ChessBitmap1 =	SHADOW_ChessBitmap1
     41  2000		       f8 30	   ChessBitmap2 =	SHADOW_ChessBitmap2
     42  2000		       f8 48	   ChessBitmap3 =	SHADOW_ChessBitmap3
     43  2000		       f8 60	   ChessBitmap4 =	SHADOW_ChessBitmap4
     44  2000		       f8 78	   ChessBitmap5 =	SHADOW_ChessBitmap5
     45  2000
     46  2000							; Template bank for a SINGLE ROW of the chessboard display.
     47  2000							; There are 8x of these.
     48  2000							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
     49  2000							; The bank is copied from ROM into RAM at startup.
     50  2000							; The draw switches between consecutive row banks, with the last returning
     51  2000							; we effectively have 1K
     52  2000							;---------------------------------------------------------------------------------------------------
     53  2000
     54  2000							; NTSC
     55  2000
     56  2000		       00 00	   BW	      =	0
     57  2000		       00 01	   NTSC       =	1
     58  2000		       00 02	   PAL	      =	2
     59  2000
     60  2000
     61  2000
     62  2000		       00 02	   COL_TYPE   =	PAL
     63  2000
     64  2000
     65  2000
     66  2000				  -	      IF	COL_TYPE = NTSC
     67  2000				  -COLOUR_LINE_1 =	$86
     68  2000				  -COLOUR_LINE_2 =	$46
     69  2000				  -COLOUR_LINE_3 =	$D8
     70  2000					      ENDIF
     71  2000
     72  2000					      IF	COL_TYPE = PAL
     73  2000		       00 d6	   COLOUR_LINE_1 =	$D6	;86
     74  2000		       00 66	   COLOUR_LINE_2 =	$66	;46
     75  2000		       00 38	   COLOUR_LINE_3 =	$38	;D8
     76  2000					      ENDIF
     77  2000
     78  2000
     79  2000				  -	      IF	COL_TYPE = BW
     80  2000				  -COLOUR_LINE_1 =	$24	;86
     81  2000				  -COLOUR_LINE_2 =	$A2	;46
     82  2000				  -COLOUR_LINE_3 =	$94	;D8
     83  2000					      ENDIF
     84  2000
     85  2000
     86  2000		       00 00	   BACKGCOL   =	$0
     87  2000
     88  2000		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     89  2000
     90  2000
      0  2000					      ALLOCATE	SHADOW_ChessBitmap, ROW_BITMAP_SIZE
      1  2000
      2  2000				   .NAME      SETSTR	SHADOW_ChessBitmap
      0  2000					      OPTIONAL_PAGEBREAK	.NAME, ROW_BITMAP_SIZE
      1  2000
      2  2000				  -	      IF	(>( * + ROW_BITMAP_SIZE -1 )) > ( >* )
      3  2000				  -.EARLY_LOCATION SET	*
      4  2000				  -	      ALIGN	256
      5  2000				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2000					      ENDIF
      0  2000					      DEF	SHADOW_ChessBitmap
      1  2000				   SLOT_SHADOW_ChessBitmap SET	_BANK_SLOT
      2  2000				   BANK_SHADOW_ChessBitmap SET	SLOT_SHADOW_ChessBitmap + _CURRENT_BANK
      3  2000				   SHADOW_ChessBitmap
      4  2000				   TEMPORARY_VAR SET	Overlay
      5  2000				   TEMPORARY_OFFSET SET	0
      6  2000				   VAR_BOUNDARY_SHADOW_ChessBitmap SET	TEMPORARY_OFFSET
      7  2000				   FUNCTION_NAME SET	SHADOW_ChessBitmap
      5  2000
     92  2000		       00 00 00 00*SHADOW_ChessBitmap0 ds	24
     93  2018		       00 00 00 00*SHADOW_ChessBitmap1 ds	24
     94  2030		       00 00 00 00*SHADOW_ChessBitmap2 ds	24
     95  2048		       00 00 00 00*SHADOW_ChessBitmap3 ds	24
     96  2060		       00 00 00 00*SHADOW_ChessBitmap4 ds	24
     97  2078		       00 00 00 00*SHADOW_ChessBitmap5 ds	24
     98  2090
      0  2090					      ALLOCATE	BlankSprite, 8
      1  2090
      2  2090				   .NAME      SETSTR	BlankSprite
      0  2090					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  2090
      2  2090				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  2090				  -.EARLY_LOCATION SET	*
      4  2090				  -	      ALIGN	256
      5  2090				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2090					      ENDIF
      0  2090					      DEF	BlankSprite
      1  2090				   SLOT_BlankSprite SET	_BANK_SLOT
      2  2090				   BANK_BlankSprite SET	SLOT_BlankSprite + _CURRENT_BANK
      3  2090				   BlankSprite
      4  2090				   TEMPORARY_VAR SET	Overlay
      5  2090				   TEMPORARY_OFFSET SET	0
      6  2090				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      7  2090				   FUNCTION_NAME SET	BlankSprite
      5  2090
    100  2090		       00 00 00 00*	      ds	8, 0
    101  2098
      0  2098					      ALLOCATE	SpriteBuffer, 8
      1  2098
      2  2098				   .NAME      SETSTR	SpriteBuffer
      0  2098					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  2098
      2  2098				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  2098				  -.EARLY_LOCATION SET	*
      4  2098				  -	      ALIGN	256
      5  2098				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2098					      ENDIF
      0  2098					      DEF	SpriteBuffer
      1  2098				   SLOT_SpriteBuffer SET	_BANK_SLOT
      2  2098				   BANK_SpriteBuffer SET	SLOT_SpriteBuffer + _CURRENT_BANK
      3  2098				   SpriteBuffer
      4  2098				   TEMPORARY_VAR SET	Overlay
      5  2098				   TEMPORARY_OFFSET SET	0
      6  2098				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      7  2098				   FUNCTION_NAME SET	SpriteBuffer
      5  2098
    103  2098				   SpriteBuffer2
    104  2098		       f8		      .byte.b	%11111000
    105  2099		       f8		      .byte.b	%11111000
    106  209a		       f8		      .byte.b	%11111000
    107  209b		       f8		      .byte.b	%11111000
    108  209c		       f8		      .byte.b	%11111000
    109  209d		       f8		      .byte.b	%11111000
    110  209e		       f8		      .byte.b	%11111000
    111  209f		       f8		      .byte.b	%11111000
    112  20a0
    113  20a0							;---------------------------------------------------------------------------------------------------
    114  20a0
    115  20a0							;ALIGN 256
    116  20a0					      SUBROUTINE
    117  20a0
      0  20a0					      REF	StartupBankReset
      1  20a0				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  20a0				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  20a0					      ENDIF
    119  20a0							;__dummy
    120  20a0							;    VEND __dummy
    121  20a0
    122  20a0							; x = row # (and bank#)
    123  20a0
    124  20a0				   .endline
    125  20a0
    126  20a0							;@59
    127  20a0
    128  20a0							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
    129  20a0							; Note that the other 7 row banks are unmodified (keeping the 'inx')
    130  20a0				   SELFMOD_RTS_ON_LAST_ROW
    131  20a0
    132  20a0		       e8		      inx		; 2
    133  20a1		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
    134  20a3
      0  20a3					      DEF	DrawRow
      1  20a3				   SLOT_DrawRow SET	_BANK_SLOT
      2  20a3				   BANK_DrawRow SET	SLOT_DrawRow + _CURRENT_BANK
      3  20a3				   DrawRow
      4  20a3				   TEMPORARY_VAR SET	Overlay
      5  20a3				   TEMPORARY_OFFSET SET	0
      6  20a3				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      7  20a3				   FUNCTION_NAME SET	DrawRow
    136  20a3
    137  20a3
    138  20a3
    139  20a3							;@64
    140  20a3		       a0 07		      ldy	#7	; 2
    141  20a5		       10 3e		      bpl	.dl2	; 3   (must be 69 here)
    142  20a7
    143  20a7							;@58...
    144  20a7
    145  20a7				   .l3
    146  20a7
    147  20a7		       b9 a8 f8    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
    148  20aa		       85 1b		      sta	GRP0	; 3
    149  20ac		       b9 a8 f8    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
    150  20af		       85 1c		      sta	GRP1	; 3
    151  20b1
    152  20b1							;@-4
    153  20b1
    154  20b1		       a9 d6	   SMCOL1     lda	#COLOUR_LINE_1	;#$94			  ; 2
    155  20b3		       85 08		      sta	COLUPF	; 3 @1
    156  20b5		       29 f0		      and	#$F0
    157  20b7		       a9 00		      lda	#$0	;A0
    158  20b9		       85 09		      sta	COLUBK
    159  20bb
    160  20bb		       b9 10 f8 	      lda	ChessBitmap0+16,y	; 4
    161  20be		       85 0d		      sta	PF0	; 3
    162  20c0		       b9 28 f8 	      lda	ChessBitmap1+16,y	; 4
    163  20c3		       85 0e		      sta	PF1	; 3
    164  20c5		       b9 40 f8 	      lda	ChessBitmap2+16,y	; 4
    165  20c8		       85 0f		      sta	PF2	; 3 @22
    166  20ca
    167  20ca							;SLEEP 6		      ; 6 @28
    168  20ca
    169  20ca		       b9 58 f8 	      lda	ChessBitmap3+16,y	; 4
    170  20cd		       85 0d		      sta	PF0	; 3
    171  20cf		       b9 70 f8 	      lda	ChessBitmap4+16,y	; 4
    172  20d2		       85 0e		      sta	PF1	; 3
    173  20d4		       b9 88 f8 	      lda	ChessBitmap5+16,y	; 4
    174  20d7		       8d 0f 00 	      sta.w	PF2	; 4 @50
    175  20da
      0  20da					      SLEEP	3	; 4
      1  20da				   .CYCLES    SET	3
      2  20da
      3  20da				  -	      IF	.CYCLES < 2
      4  20da				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20da				  -	      ERR
      6  20da					      ENDIF
      7  20da
      8  20da					      IF	.CYCLES & 1
      9  20da					      IFNCONST	NO_ILLEGAL_OPCODES
     10  20da		       04 00		      nop	0
     11  20dc				  -	      ELSE
     12  20dc				  -	      bit	VSYNC
     13  20dc					      ENDIF
     14  20dc				   .CYCLES    SET	.CYCLES - 3
     15  20dc					      ENDIF
     16  20dc
     17  20dc				  -	      REPEAT	.CYCLES / 2
     18  20dc				  -	      nop
     19  20dc					      REPEND
    177  20dc
    178  20dc		       88		      dey		; 2
    179  20dd		       30 c1		      bmi	.endline	; 2 (3)
    180  20df
    181  20df							;@57
    182  20df				   .drawLine
    183  20df
      0  20df					      SLEEP	11
      1  20df				   .CYCLES    SET	11
      2  20df
      3  20df				  -	      IF	.CYCLES < 2
      4  20df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  20df				  -	      ERR
      6  20df					      ENDIF
      7  20df
      8  20df					      IF	.CYCLES & 1
      9  20df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  20df		       04 00		      nop	0
     11  20e1				  -	      ELSE
     12  20e1				  -	      bit	VSYNC
     13  20e1					      ENDIF
     14  20e1				   .CYCLES    SET	.CYCLES - 3
     15  20e1					      ENDIF
     16  20e1
     17  20e1					      REPEAT	.CYCLES / 2
     18  20e1		       ea		      nop
     17  20e1					      REPEND
     18  20e2		       ea		      nop
     17  20e2					      REPEND
     18  20e3		       ea		      nop
     17  20e3					      REPEND
     18  20e4		       ea		      nop
     19  20e5					      REPEND
    185  20e5
    186  20e5				   .dl2
    187  20e5		       b9 98 f8    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    188  20e8		       85 1b		      sta	GRP0	; 3
    189  20ea		       b9 98 f8    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    190  20ed		       85 1c		      sta	GRP1	; 3
    191  20ef
    192  20ef							;@7
    193  20ef
    194  20ef		       a9 66	   SMCOL2     lda	#COLOUR_LINE_2	;#$4A			  ; 2
    195  20f1		       85 08		      sta	COLUPF	; 3 @12
    196  20f3
    197  20f3		       b9 00 f8 	      lda	ChessBitmap0,y	; 4
    198  20f6		       85 0d		      sta	PF0	; 3
    199  20f8		       b9 18 f8 	      lda	ChessBitmap1,y	; 4
    200  20fb		       85 0e		      sta	PF1	; 3
    201  20fd		       b9 30 f8 	      lda	ChessBitmap2,y	; 4
    202  2100		       85 0f		      sta	PF2	; 3 @33
    203  2102
      0  2102					      SLEEP	3	; 3 @36
      1  2102				   .CYCLES    SET	3
      2  2102
      3  2102				  -	      IF	.CYCLES < 2
      4  2102				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2102				  -	      ERR
      6  2102					      ENDIF
      7  2102
      8  2102					      IF	.CYCLES & 1
      9  2102					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2102		       04 00		      nop	0
     11  2104				  -	      ELSE
     12  2104				  -	      bit	VSYNC
     13  2104					      ENDIF
     14  2104				   .CYCLES    SET	.CYCLES - 3
     15  2104					      ENDIF
     16  2104
     17  2104				  -	      REPEAT	.CYCLES / 2
     18  2104				  -	      nop
     19  2104					      REPEND
    205  2104
    206  2104		       b9 48 f8 	      lda	ChessBitmap3,y	; 4
    207  2107		       85 0d		      sta	PF0	; 3
    208  2109		       b9 60 f8 	      lda	ChessBitmap4,y	; 4
    209  210c		       85 0e		      sta	PF1	; 3
    210  210e		       b9 78 f8 	      lda	ChessBitmap5,y	; 4
    211  2111		       85 0f		      sta	PF2	; 3 @57
    212  2113
      0  2113					      SLEEP	5
      1  2113				   .CYCLES    SET	5
      2  2113
      3  2113				  -	      IF	.CYCLES < 2
      4  2113				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2113				  -	      ERR
      6  2113					      ENDIF
      7  2113
      8  2113					      IF	.CYCLES & 1
      9  2113					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2113		       04 00		      nop	0
     11  2115				  -	      ELSE
     12  2115				  -	      bit	VSYNC
     13  2115					      ENDIF
     14  2115				   .CYCLES    SET	.CYCLES - 3
     15  2115					      ENDIF
     16  2115
     17  2115					      REPEAT	.CYCLES / 2
     18  2115		       ea		      nop
     19  2116					      REPEND
    214  2116
    215  2116		       b9 a0 f8    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    216  2119		       85 1b		      sta	GRP0	; 3
    217  211b		       b9 a0 f8    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    218  211e		       85 1c		      sta	GRP1	; 3
    219  2120
    220  2120							;@0
    221  2120		       a9 38	   SMCOL3     lda	#COLOUR_LINE_3	;#$28			  ; 2
    222  2122		       85 08		      sta	COLUPF	; 3 @5
    223  2124
    224  2124		       b9 08 f8 	      lda	ChessBitmap0+8,y	; 4
    225  2127		       85 0d		      sta	PF0	; 3
    226  2129		       b9 20 f8 	      lda	ChessBitmap1+8,y	; 4
    227  212c		       85 0e		      sta	PF1	; 3
    228  212e		       b9 38 f8 	      lda	ChessBitmap2+8,y	; 4
    229  2131		       85 0f		      sta	PF2	; 3 @26
    230  2133
      0  2133					      SLEEP	8	; 6 @34
      1  2133				   .CYCLES    SET	8
      2  2133
      3  2133				  -	      IF	.CYCLES < 2
      4  2133				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2133				  -	      ERR
      6  2133					      ENDIF
      7  2133
      8  2133				  -	      IF	.CYCLES & 1
      9  2133				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2133				  -	      nop	0
     11  2133				  -	      ELSE
     12  2133				  -	      bit	VSYNC
     13  2133				  -	      ENDIF
     14  2133				  -.CYCLES    SET	.CYCLES - 3
     15  2133					      ENDIF
     16  2133
     17  2133					      REPEAT	.CYCLES / 2
     18  2133		       ea		      nop
     17  2133					      REPEND
     18  2134		       ea		      nop
     17  2134					      REPEND
     18  2135		       ea		      nop
     17  2135					      REPEND
     18  2136		       ea		      nop
     19  2137					      REPEND
    232  2137
    233  2137		       b9 50 f8 	      lda	ChessBitmap3+8,y	; 4
    234  213a		       85 0d		      sta	PF0	; 3
    235  213c		       b9 68 f8 	      lda	ChessBitmap4+8,y	; 4
    236  213f		       85 0e		      sta	PF1	; 3
    237  2141		       b9 80 f8 	      lda	ChessBitmap5+8,y	; 4
    238  2144		       85 0f		      sta	PF2	; 3 @55
    239  2146
    240  2146		       4c a7 f8 	      jmp	.l3	; 3 @58
    241  2149
    242  2149
    243  2149							;---------------------------------------------------------------------------------------------------
    244  2149
      0  2149					      DEF	BackupBitmap
      1  2149				   SLOT_BackupBitmap SET	_BANK_SLOT
      2  2149				   BANK_BackupBitmap SET	SLOT_BackupBitmap + _CURRENT_BANK
      3  2149				   BackupBitmap
      4  2149				   TEMPORARY_VAR SET	Overlay
      5  2149				   TEMPORARY_OFFSET SET	0
      6  2149				   VAR_BOUNDARY_BackupBitmap SET	TEMPORARY_OFFSET
      7  2149				   FUNCTION_NAME SET	BackupBitmap
    246  2149		       00 00 00 00*	      ds	ROW_BITMAP_SIZE, 0
    247  21d9
    248  21d9
    249  21d9							;---------------------------------------------------------------------------------------------------
    250  21d9
      0  21d9					      CHECK_RAM_BANK_SIZE
      1  21d9		       01 d9	   .TEMP      =	* - _BANK_START
 RAM bank # 8 BITMAP size =  $1d9 free = $26
      2  21d9					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3  21d9				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4  21d9				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5  21d9				  -	      ERR
      6  21d9					      ENDIF
    252  21d9
    253  21d9							;---------------------------------------------------------------------------------------------------
    254  21d9							;EOF
------- FILE ./chess.asm
------- FILE @2 PLY.asm LEVEL 2 PASS 4
      0  21d9					      include	"@2 PLY.asm"
      1  21d9							;---------------------------------------------------------------------------------------------------
      2  21d9							; @2 PLY.asm
      3  21d9
      4  21d9							; Atari 2600 Chess
      5  21d9							; Copyright (c) 2019-2020 Andrew Davie
      6  21d9							; andrew@taswegian.com
      7  21d9
      8  21d9
      9  21d9							;---------------------------------------------------------------------------------------------------
     10  21d9							; Define the RAM banks
     11  21d9							; A "PLY" bank represents all the data required on any single ply of the search tree.
     12  21d9							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
     13  21d9							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     14  21d9							; they act as independant switchable banks usable for data on each ply during the search.
     15  21d9							; A ply will hold the move list for that position
     16  21d9
     17  21d9
      0  21d9					      SLOT	2
      1  21d9
      2  21d9				  -	      IF	(2 < 0) || (2 > 3)
      3  21d9				  -	      ECHO	"Illegal bank address/segment location", 2
      4  21d9				  -	      ERR
      5  21d9					      ENDIF
      6  21d9
      7  21d9				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  21d9				   _BANK_SLOT SET	2 * 64
      9  21d9
      0  21d9					      RAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  21d9
      2 U11dc ????				      SEG.U	RAM_PLY
      3 U1000					      ORG	ORIGIN_RAM
      4 U1000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1000				   _BANK_START SET	*
      6 U1000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1000				   RAMBANK_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1000				   _LAST_BANK SETSTR	PLY
     10 U1000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
     20 U1000
     21 U1000							;---------------------------------------------------------------------------------------------------
     22 U1000
     23 U1000		       00 64	   MAX_MOVES  =	100	; big is good
     24 U1000
      0 U1000					      VARIABLE	MoveFrom, MAX_MOVES
      1 U1000
      2 U1000				   .NAME      SETSTR	MoveFrom
      0 U1000					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1000
      2 U1000				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1000				  -.EARLY_LOCATION SET	*
      4 U1000				  -	      ALIGN	256
      5 U1000				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1000					      ENDIF
      4 U1000		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      5 U1064
      0 U1064					      VARIABLE	MoveTo, MAX_MOVES
      1 U1064
      2 U1064				   .NAME      SETSTR	MoveTo
      0 U1064					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1064
      2 U1064				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1064				  -.EARLY_LOCATION SET	*
      4 U1064				  -	      ALIGN	256
      5 U1064				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1064					      ENDIF
      4 U1064		       00 00 00 00*MoveTo     ds	MAX_MOVES
      5 U10c8
      0 U10c8					      VARIABLE	MovePiece, MAX_MOVES
      1 U10c8
      2 U10c8				   .NAME      SETSTR	MovePiece
      0 U10c8					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U10c8
      2 U10c8					      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U10c8				   .EARLY_LOCATION SET	*
      4 U1100		       00 00 00 00*	      ALIGN	256
 Page break for wasted 56 bytes
      5 U1100					      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1100					      ENDIF
      4 U1100		       00 00 00 00*MovePiece  ds	MAX_MOVES
      5 U1164
      0 U1164					      VARIABLE	MoveCapture, MAX_MOVES
      1 U1164
      2 U1164				   .NAME      SETSTR	MoveCapture
      0 U1164					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1164
      2 U1164				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1164				  -.EARLY_LOCATION SET	*
      4 U1164				  -	      ALIGN	256
      5 U1164				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1164					      ENDIF
      4 U1164		       00 00 00 00*MoveCapture ds	MAX_MOVES
      5 U11c8
     29 U11c8
     30 U11c8
     31 U11c8							;---------------------------------------------------------------------------------------------------
     32 U11c8
     33 U11c8							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     34 U11c8							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     35 U11c8
      0 U11c8					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      1 U11c8
      2 U11c8				   .NAME      SETSTR	savedEvaluation
      0 U11c8					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11c8
      2 U11c8				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11c8				  -.EARLY_LOCATION SET	*
      4 U11c8				  -	      ALIGN	256
      5 U11c8				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11c8					      ENDIF
      4 U11c8		       00 00	   savedEvaluation ds	2
      5 U11ca
      0 U11ca					      VARIABLE	enPassantSquare, 1
      1 U11ca
      2 U11ca				   .NAME      SETSTR	enPassantSquare
      0 U11ca					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11ca
      2 U11ca				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11ca				  -.EARLY_LOCATION SET	*
      4 U11ca				  -	      ALIGN	256
      5 U11ca				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11ca					      ENDIF
      4 U11ca		       00	   enPassantSquare ds	1
      5 U11cb
      0 U11cb					      VARIABLE	capturedPiece, 1
      1 U11cb
      2 U11cb				   .NAME      SETSTR	capturedPiece
      0 U11cb					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cb
      2 U11cb				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cb				  -.EARLY_LOCATION SET	*
      4 U11cb				  -	      ALIGN	256
      5 U11cb				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cb					      ENDIF
      4 U11cb		       00	   capturedPiece ds	1
      5 U11cc
     39 U11cc							;VARIABLE originalPiece, 1
      0 U11cc					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      1 U11cc
      2 U11cc				   .NAME      SETSTR	secondaryPiece
      0 U11cc					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cc
      2 U11cc				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cc				  -.EARLY_LOCATION SET	*
      4 U11cc				  -	      ALIGN	256
      5 U11cc				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cc					      ENDIF
      4 U11cc		       00	   secondaryPiece ds	1
      5 U11cd
      0 U11cd					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      1 U11cd
      2 U11cd				   .NAME      SETSTR	secondarySquare
      0 U11cd					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cd
      2 U11cd				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cd				  -.EARLY_LOCATION SET	*
      4 U11cd				  -	      ALIGN	256
      5 U11cd				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cd					      ENDIF
      4 U11cd		       00	   secondarySquare ds	1
      5 U11ce
      0 U11ce					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      1 U11ce
      2 U11ce				   .NAME      SETSTR	secondaryBlank
      0 U11ce					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11ce
      2 U11ce				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11ce				  -.EARLY_LOCATION SET	*
      4 U11ce				  -	      ALIGN	256
      5 U11ce				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11ce					      ENDIF
      4 U11ce		       00	   secondaryBlank ds	1
      5 U11cf
      0 U11cf					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      1 U11cf
      2 U11cf				   .NAME      SETSTR	moveIndex
      0 U11cf					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11cf
      2 U11cf				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11cf				  -.EARLY_LOCATION SET	*
      4 U11cf				  -	      ALIGN	256
      5 U11cf				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11cf					      ENDIF
      4 U11cf		       00	   moveIndex  ds	1
      5 U11d0
      0 U11d0					      VARIABLE	movePtr, 1
      1 U11d0
      2 U11d0				   .NAME      SETSTR	movePtr
      0 U11d0					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d0
      2 U11d0				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d0				  -.EARLY_LOCATION SET	*
      4 U11d0				  -	      ALIGN	256
      5 U11d0				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d0					      ENDIF
      4 U11d0		       00	   movePtr    ds	1
      5 U11d1
      0 U11d1					      VARIABLE	bestMove, 1
      1 U11d1
      2 U11d1				   .NAME      SETSTR	bestMove
      0 U11d1					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d1
      2 U11d1				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d1				  -.EARLY_LOCATION SET	*
      4 U11d1				  -	      ALIGN	256
      5 U11d1				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d1					      ENDIF
      4 U11d1		       00	   bestMove   ds	1
      5 U11d2
      0 U11d2					      VARIABLE	alpha, 2
      1 U11d2
      2 U11d2				   .NAME      SETSTR	alpha
      0 U11d2					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11d2
      2 U11d2				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11d2				  -.EARLY_LOCATION SET	*
      4 U11d2				  -	      ALIGN	256
      5 U11d2				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d2					      ENDIF
      4 U11d2		       00 00	   alpha      ds	2
      5 U11d4
      0 U11d4					      VARIABLE	beta, 2
      1 U11d4
      2 U11d4				   .NAME      SETSTR	beta
      0 U11d4					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11d4
      2 U11d4				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11d4				  -.EARLY_LOCATION SET	*
      4 U11d4				  -	      ALIGN	256
      5 U11d4				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d4					      ENDIF
      4 U11d4		       00 00	   beta       ds	2
      5 U11d6
      0 U11d6					      VARIABLE	value, 2
      1 U11d6
      2 U11d6				   .NAME      SETSTR	value
      0 U11d6					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11d6
      2 U11d6				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11d6				  -.EARLY_LOCATION SET	*
      4 U11d6				  -	      ALIGN	256
      5 U11d6				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d6					      ENDIF
      4 U11d6		       00 00	   value      ds	2
      5 U11d8
      0 U11d8					      VARIABLE	depthLeft, 1
      1 U11d8
      2 U11d8				   .NAME      SETSTR	depthLeft
      0 U11d8					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d8
      2 U11d8				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d8				  -.EARLY_LOCATION SET	*
      4 U11d8				  -	      ALIGN	256
      5 U11d8				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d8					      ENDIF
      4 U11d8		       00	   depthLeft  ds	1
      5 U11d9
      0 U11d9					      VARIABLE	restorePiece, 1
      1 U11d9
      2 U11d9				   .NAME      SETSTR	restorePiece
      0 U11d9					      OPTIONAL_PAGEBREAK	.NAME, 1
      1 U11d9
      2 U11d9				  -	      IF	(>( * + 1 -1 )) > ( >* )
      3 U11d9				  -.EARLY_LOCATION SET	*
      4 U11d9				  -	      ALIGN	256
      5 U11d9				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11d9					      ENDIF
      4 U11d9		       00	   restorePiece ds	1
      5 U11da
      0 U11da					      VARIABLE	virtualKingSquare, 2	; traversing squares for castle/check
      1 U11da
      2 U11da				   .NAME      SETSTR	virtualKingSquare
      0 U11da					      OPTIONAL_PAGEBREAK	.NAME, 2
      1 U11da
      2 U11da				  -	      IF	(>( * + 2 -1 )) > ( >* )
      3 U11da				  -.EARLY_LOCATION SET	*
      4 U11da				  -	      ALIGN	256
      5 U11da				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U11da					      ENDIF
      4 U11da		       00 00	   virtualKingSquare ds	2
      5 U11dc
     52 U11dc
      0 U11dc					      END_BANK
      1 U11dc					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U11dc					      CHECK_RAM_BANK_SIZE
      1 U11dc		       01 dc	   .TEMP      =	* - _BANK_START
 RAM bank # 9 PLY size =  $1dc free = $23
      2 U11dc					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U11dc				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U11dc				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U11dc				  -	      ERR
      6 U11dc					      ENDIF
      3 U11dc				  -	      ELSE
      4 U11dc				  -	      CHECK_BANK_SIZE
      5 U11dc					      ENDIF
     54 U11dc
     55 U11dc
     56 U11dc					      REPEAT	PLY_BANKS-1
      0 U11dc					      RAMBANK	.DUMMY_PLY
      1 U11dc
      2 U2a00 ????				      SEG.U	RAM_.DUMMY_PLY
      3 U1200					      ORG	ORIGIN_RAM
      4 U1200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1200				   _BANK_START SET	*
      6 U1200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1200				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1200					      END_BANK
      1 U1200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1200					      CHECK_RAM_BANK_SIZE
      1 U1200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 10 .DUMMY_PLY size =  $0 free = $1ff
      2 U1200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1200				  -	      ERR
      6 U1200					      ENDIF
      3 U1200				  -	      ELSE
      4 U1200				  -	      CHECK_BANK_SIZE
      5 U1200					      ENDIF
     56 U1200					      REPEND
      0 U1200					      RAMBANK	.DUMMY_PLY
      1 U1200
      2 U1200					      SEG.U	RAM_.DUMMY_PLY
      3 U1400					      ORG	ORIGIN_RAM
      4 U1400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1400				   _BANK_START SET	*
      6 U1400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1400				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1400					      END_BANK
      1 U1400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1400					      CHECK_RAM_BANK_SIZE
      1 U1400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 11 .DUMMY_PLY size =  $0 free = $1ff
      2 U1400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1400				  -	      ERR
      6 U1400					      ENDIF
      3 U1400				  -	      ELSE
      4 U1400				  -	      CHECK_BANK_SIZE
      5 U1400					      ENDIF
     56 U1400					      REPEND
      0 U1400					      RAMBANK	.DUMMY_PLY
      1 U1400
      2 U1400					      SEG.U	RAM_.DUMMY_PLY
      3 U1600					      ORG	ORIGIN_RAM
      4 U1600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1600				   _BANK_START SET	*
      6 U1600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1600				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1600				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1600					      END_BANK
      1 U1600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1600					      CHECK_RAM_BANK_SIZE
      1 U1600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 12 .DUMMY_PLY size =  $0 free = $1ff
      2 U1600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1600				  -	      ERR
      6 U1600					      ENDIF
      3 U1600				  -	      ELSE
      4 U1600				  -	      CHECK_BANK_SIZE
      5 U1600					      ENDIF
     56 U1600					      REPEND
      0 U1600					      RAMBANK	.DUMMY_PLY
      1 U1600
      2 U1600					      SEG.U	RAM_.DUMMY_PLY
      3 U1800					      ORG	ORIGIN_RAM
      4 U1800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1800				   _BANK_START SET	*
      6 U1800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1800				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1800				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1800					      END_BANK
      1 U1800					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1800					      CHECK_RAM_BANK_SIZE
      1 U1800		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 13 .DUMMY_PLY size =  $0 free = $1ff
      2 U1800					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1800				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1800				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1800				  -	      ERR
      6 U1800					      ENDIF
      3 U1800				  -	      ELSE
      4 U1800				  -	      CHECK_BANK_SIZE
      5 U1800					      ENDIF
     56 U1800					      REPEND
      0 U1800					      RAMBANK	.DUMMY_PLY
      1 U1800
      2 U1800					      SEG.U	RAM_.DUMMY_PLY
      3 U1a00					      ORG	ORIGIN_RAM
      4 U1a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1a00				   _BANK_START SET	*
      6 U1a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1a00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1a00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1a00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1a00					      END_BANK
      1 U1a00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1a00					      CHECK_RAM_BANK_SIZE
      1 U1a00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 14 .DUMMY_PLY size =  $0 free = $1ff
      2 U1a00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1a00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1a00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1a00				  -	      ERR
      6 U1a00					      ENDIF
      3 U1a00				  -	      ELSE
      4 U1a00				  -	      CHECK_BANK_SIZE
      5 U1a00					      ENDIF
     56 U1a00					      REPEND
      0 U1a00					      RAMBANK	.DUMMY_PLY
      1 U1a00
      2 U1a00					      SEG.U	RAM_.DUMMY_PLY
      3 U1c00					      ORG	ORIGIN_RAM
      4 U1c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1c00				   _BANK_START SET	*
      6 U1c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1c00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1c00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U1c00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U1c00					      END_BANK
      1 U1c00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1c00					      CHECK_RAM_BANK_SIZE
      1 U1c00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 15 .DUMMY_PLY size =  $0 free = $1ff
      2 U1c00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1c00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1c00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1c00				  -	      ERR
      6 U1c00					      ENDIF
      3 U1c00				  -	      ELSE
      4 U1c00				  -	      CHECK_BANK_SIZE
      5 U1c00					      ENDIF
     59 U1c00					      REPEND
     60 U1c00
     61 U1c00
     62 U1c00							;---------------------------------------------------------------------------------------------------
     63 U1c00							; EOF
------- FILE ./chess.asm
------- FILE @2 PLY2.asm LEVEL 2 PASS 4
      0 U1c00					      include	"@2 PLY2.asm"
      0 U1c00					      SLOT	2
      1 U1c00
      2 U1c00				  -	      IF	(2 < 0) || (2 > 3)
      3 U1c00				  -	      ECHO	"Illegal bank address/segment location", 2
      4 U1c00				  -	      ERR
      5 U1c00					      ENDIF
      6 U1c00
      7 U1c00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8 U1c00				   _BANK_SLOT SET	2 * 64
      9 U1c00
      0 U1c00					      RAMBANK	SORT
      1 U1c00
      2 U1ec8 ????				      SEG.U	RAM_SORT
      3 U1e00					      ORG	ORIGIN_RAM
      4 U1e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U1e00				   _BANK_START SET	*
      6 U1e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U1e00				   RAMBANK_SORT SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U1e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U1e00				   _LAST_BANK SETSTR	SORT
     10 U1e00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      3 U1e00
      4 U1e00							;---------------------------------------------------------------------------------------------------
      5 U1e00
      0 U1e00					      VARIABLE	MoveValueLO, MAX_MOVES
      1 U1e00
      2 U1e00				   .NAME      SETSTR	MoveValueLO
      0 U1e00					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1e00
      2 U1e00				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1e00				  -.EARLY_LOCATION SET	*
      4 U1e00				  -	      ALIGN	256
      5 U1e00				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1e00					      ENDIF
      4 U1e00		       00 00 00 00*MoveValueLO ds	MAX_MOVES
      5 U1e64
      0 U1e64					      VARIABLE	MoveValueHI, MAX_MOVES
      1 U1e64
      2 U1e64				   .NAME      SETSTR	MoveValueHI
      0 U1e64					      OPTIONAL_PAGEBREAK	.NAME, MAX_MOVES
      1 U1e64
      2 U1e64				  -	      IF	(>( * + MAX_MOVES -1 )) > ( >* )
      3 U1e64				  -.EARLY_LOCATION SET	*
      4 U1e64				  -	      ALIGN	256
      5 U1e64				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6 U1e64					      ENDIF
      4 U1e64		       00 00 00 00*MoveValueHI ds	MAX_MOVES
      5 U1ec8
      8 U1ec8
      9 U1ec8							;---------------------------------------------------------------------------------------------------
     10 U1ec8
      0 U1ec8					      END_BANK
      1 U1ec8					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U1ec8					      CHECK_RAM_BANK_SIZE
      1 U1ec8		       00 c8	   .TEMP      =	* - _BANK_START
 RAM bank # 16 SORT size =  $c8 free = $137
      2 U1ec8					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U1ec8				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U1ec8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U1ec8				  -	      ERR
      6 U1ec8					      ENDIF
      3 U1ec8				  -	      ELSE
      4 U1ec8				  -	      CHECK_BANK_SIZE
      5 U1ec8					      ENDIF
     12 U1ec8
     13 U1ec8							;---------------------------------------------------------------------------------------------------
     14 U1ec8
     15 U1ec8					      REPEAT	PLY_BANKS-1
      0 U1ec8					      RAMBANK	.DUMMY_PLY
      1 U1ec8
      2 U1c00					      SEG.U	RAM_.DUMMY_PLY
      3 U2000					      ORG	ORIGIN_RAM
      4 U2000					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2000				   _BANK_START SET	*
      6 U2000				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2000				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2000				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2000				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2000					      END_BANK
      1 U2000					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2000					      CHECK_RAM_BANK_SIZE
      1 U2000		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 17 .DUMMY_PLY size =  $0 free = $1ff
      2 U2000					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2000				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2000				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2000				  -	      ERR
      6 U2000					      ENDIF
      3 U2000				  -	      ELSE
      4 U2000				  -	      CHECK_BANK_SIZE
      5 U2000					      ENDIF
     15 U2000					      REPEND
      0 U2000					      RAMBANK	.DUMMY_PLY
      1 U2000
      2 U2000					      SEG.U	RAM_.DUMMY_PLY
      3 U2200					      ORG	ORIGIN_RAM
      4 U2200					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2200				   _BANK_START SET	*
      6 U2200				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2200				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2200				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2200				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2200				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2200					      END_BANK
      1 U2200					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2200					      CHECK_RAM_BANK_SIZE
      1 U2200		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 18 .DUMMY_PLY size =  $0 free = $1ff
      2 U2200					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2200				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2200				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2200				  -	      ERR
      6 U2200					      ENDIF
      3 U2200				  -	      ELSE
      4 U2200				  -	      CHECK_BANK_SIZE
      5 U2200					      ENDIF
     15 U2200					      REPEND
      0 U2200					      RAMBANK	.DUMMY_PLY
      1 U2200
      2 U2200					      SEG.U	RAM_.DUMMY_PLY
      3 U2400					      ORG	ORIGIN_RAM
      4 U2400					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2400				   _BANK_START SET	*
      6 U2400				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2400				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2400				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2400				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2400					      END_BANK
      1 U2400					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2400					      CHECK_RAM_BANK_SIZE
      1 U2400		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 19 .DUMMY_PLY size =  $0 free = $1ff
      2 U2400					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2400				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2400				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2400				  -	      ERR
      6 U2400					      ENDIF
      3 U2400				  -	      ELSE
      4 U2400				  -	      CHECK_BANK_SIZE
      5 U2400					      ENDIF
     15 U2400					      REPEND
      0 U2400					      RAMBANK	.DUMMY_PLY
      1 U2400
      2 U2400					      SEG.U	RAM_.DUMMY_PLY
      3 U2600					      ORG	ORIGIN_RAM
      4 U2600					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2600				   _BANK_START SET	*
      6 U2600				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2600				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2600				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2600				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2600				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2600					      END_BANK
      1 U2600					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2600					      CHECK_RAM_BANK_SIZE
      1 U2600		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 20 .DUMMY_PLY size =  $0 free = $1ff
      2 U2600					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2600				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2600				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2600				  -	      ERR
      6 U2600					      ENDIF
      3 U2600				  -	      ELSE
      4 U2600				  -	      CHECK_BANK_SIZE
      5 U2600					      ENDIF
     15 U2600					      REPEND
      0 U2600					      RAMBANK	.DUMMY_PLY
      1 U2600
      2 U2600					      SEG.U	RAM_.DUMMY_PLY
      3 U2800					      ORG	ORIGIN_RAM
      4 U2800					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2800				   _BANK_START SET	*
      6 U2800				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2800				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2800				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2800				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2800					      END_BANK
      1 U2800					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2800					      CHECK_RAM_BANK_SIZE
      1 U2800		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 21 .DUMMY_PLY size =  $0 free = $1ff
      2 U2800					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2800				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2800				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2800				  -	      ERR
      6 U2800					      ENDIF
      3 U2800				  -	      ELSE
      4 U2800				  -	      CHECK_BANK_SIZE
      5 U2800					      ENDIF
     15 U2800					      REPEND
      0 U2800					      RAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800					      SEG.U	RAM_.DUMMY_PLY
      3 U2a00					      ORG	ORIGIN_RAM
      4 U2a00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2a00				   _BANK_START SET	*
      6 U2a00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2a00				   RAMBANK_.DUMMY_PLY SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2a00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2a00				   _LAST_BANK SETSTR	.DUMMY_PLY
     10 U2a00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2a00					      END_BANK
      1 U2a00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2a00					      CHECK_RAM_BANK_SIZE
      1 U2a00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 22 .DUMMY_PLY size =  $0 free = $1ff
      2 U2a00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2a00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2a00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2a00				  -	      ERR
      6 U2a00					      ENDIF
      3 U2a00				  -	      ELSE
      4 U2a00				  -	      CHECK_BANK_SIZE
      5 U2a00					      ENDIF
     18 U2a00					      REPEND
     19 U2a00
     20 U2a00
     21 U2a00							;---------------------------------------------------------------------------------------------------
     22 U2a00							; EOF
     23 U2a00
------- FILE ./chess.asm
------- FILE @2 GENERIC #3.asm LEVEL 2 PASS 4
      0 U2a00					      include	"@2 GENERIC #3.asm"
      1 U2a00							;---------------------------------------------------------------------------------------------------
      2 U2a00							; @2 GENERIC #3.asm
      3 U2a00
      4 U2a00							; Atari 2600 Chess
      5 U2a00							; Copyright (c) 2019-2020 Andrew Davie
      6 U2a00							; andrew@taswegian.com
      7 U2a00
      8 U2a00
      9 U2a00							;---------------------------------------------------------------------------------------------------
     10 U2a00
      0 U2a00					      SLOT	2
      1 U2a00
      2 U2a00				  -	      IF	(2 < 0) || (2 > 3)
      3 U2a00				  -	      ECHO	"Illegal bank address/segment location", 2
      4 U2a00				  -	      ERR
      5 U2a00					      ENDIF
      6 U2a00
      7 U2a00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8 U2a00				   _BANK_SLOT SET	2 * 64
      9 U2a00
      0 U2a00					      ROMBANK	GENERIC_BANK@2#1
      1  2799 ????				      SEG	ROM_GENERIC_BANK@2#1
      2  2400					      ORG	_ORIGIN
      3  2400					      RORG	_BANK_ADDRESS_ORIGIN
      4  2400				   _BANK_START SET	*
      5  2400				   GENERIC_BANK@2#1_START SET	*
      6  2400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2400				   ROMBANK_GENERIC_BANK@2#1 SET	_BANK_SLOT + _CURRENT_BANK
      8  2400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2400				   _LAST_BANK SETSTR	GENERIC_BANK@2#1
     10  2400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  2400
     14  2400							;    DEFINE_1K_SEGMENT DECODE_LEVEL_SHADOW
     15  2400
     16  2400				  -	      IF	PLUSCART = YES
     17  2400				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
     18  2400				  -	      .byte	"pluscart.firmaplus.de", #0
     19  2400					      ENDIF
     20  2400
     21  2400		       54 4a 33 45 STELLA_AUTODETECT dc	"TJ3E"	; 3E+ autodetect
     22  2404
     23  2404
     24  2404							;---------------------------------------------------------------------------------------------------
     25  2404
      0  2404					      DEF	tidySc
      1  2404				   SLOT_tidySc SET	_BANK_SLOT
      2  2404				   BANK_tidySc SET	SLOT_tidySc + _CURRENT_BANK
      3  2404				   tidySc
      4  2404				   TEMPORARY_VAR SET	Overlay
      5  2404				   TEMPORARY_OFFSET SET	0
      6  2404				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      7  2404				   FUNCTION_NAME SET	tidySc
     27  2404					      SUBROUTINE
     28  2404
      0  2404					      REF	StartupBankReset	;✅
      1  2404				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  2404				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  2404					      ENDIF
      0  2404					      VEND	tidySc
      1  2404
      2  2404
      3  2404		       00 a6	   VAREND_tidySc =	TEMPORARY_VAR
      4  2404
     31  2404
     32  2404		       a9 00		      lda	#0
     33  2406		       85 0d		      sta	PF0
     34  2408		       85 0e		      sta	PF1
     35  240a		       85 0f		      sta	PF2
     36  240c		       85 1b		      sta	GRP0
     37  240e		       85 09		      sta	COLUBK
     38  2410
     39  2410		       a9 42		      lda	#%01000010	; bit6 is not required
     40  2412							;sta VBLANK			  ; end of screen - enter blanking
     41  2412
     42  2412
     43  2412							; END OF VISIBLE SCREEN
     44  2412							; HERE'S SOME TIME TO DO STUFF
     45  2412
     46  2412							;		      lda #TIME_PART_2
     47  2412							;		      sta TIM64T
     48  2412
     49  2412		       a6 a5		      ldx	platform
     50  2414		       bd 1b f8 	      lda	time64b,x
     51  2417		       8d 96 02 	      sta	TIM64T
     52  241a		       60		      rts
     53  241b
     54  241b				   time64b
     55  241b		       2e 38		      .byte.b	TIME_PART_2, TIME_PART_2_PAL
     56  241d
     57  241d
     58  241d							;---------------------------------------------------------------------------------------------------
     59  241d
      0  241d					      DEF	longD
      1  241d				   SLOT_longD SET	_BANK_SLOT
      2  241d				   BANK_longD SET	SLOT_longD + _CURRENT_BANK
      3  241d				   longD
      4  241d				   TEMPORARY_VAR SET	Overlay
      5  241d				   TEMPORARY_OFFSET SET	0
      6  241d				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      7  241d				   FUNCTION_NAME SET	longD
     61  241d					      SUBROUTINE
     62  241d
      0  241d					      REF	StartupBankReset	;✅
      1  241d				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  241d				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  241d					      ENDIF
      0  241d					      VEND	longD
      1  241d
      2  241d
      3  241d		       00 a6	   VAREND_longD =	TEMPORARY_VAR
      4  241d
     65  241d
     66  241d		       85 02		      sta	WSYNC
     67  241f
     68  241f		       20 30 f8 	      jsr	_rts
     69  2422		       20 30 f8 	      jsr	_rts
     70  2425		       20 30 f8 	      jsr	_rts
      0  2428					      SLEEP	7
      1  2428				   .CYCLES    SET	7
      2  2428
      3  2428				  -	      IF	.CYCLES < 2
      4  2428				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2428				  -	      ERR
      6  2428					      ENDIF
      7  2428
      8  2428					      IF	.CYCLES & 1
      9  2428					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2428		       04 00		      nop	0
     11  242a				  -	      ELSE
     12  242a				  -	      bit	VSYNC
     13  242a					      ENDIF
     14  242a				   .CYCLES    SET	.CYCLES - 3
     15  242a					      ENDIF
     16  242a
     17  242a					      REPEAT	.CYCLES / 2
     18  242a		       ea		      nop
     17  242a					      REPEND
     18  242b		       ea		      nop
     19  242c					      REPEND
     72  242c
     73  242c		       a2 00		      ldx	#0
     74  242e		       86 01		      stx	VBLANK
     75  2430		       60	   _rts       rts
     76  2431
     77  2431
     78  2431							;---------------------------------------------------------------------------------------------------
     79  2431
      0  2431					      DEF	aiStartClearBoard
      1  2431				   SLOT_aiStartClearBoard SET	_BANK_SLOT
      2  2431				   BANK_aiStartClearBoard SET	SLOT_aiStartClearBoard + _CURRENT_BANK
      3  2431				   aiStartClearBoard
      4  2431				   TEMPORARY_VAR SET	Overlay
      5  2431				   TEMPORARY_OFFSET SET	0
      6  2431				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      7  2431				   FUNCTION_NAME SET	aiStartClearBoard
     81  2431					      SUBROUTINE
     82  2431
      0  2431					      REF	AiStateMachine	;✅
      1  2431					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2431				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2431					      ENDIF
      0  2431					      VEND	aiStartClearBoard
      1  2431
      2  2431
      3  2431		       00 a8	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
      4  2431
     85  2431
     86  2431		       a2 08		      ldx	#8
     87  2433		       86 85		      stx	drawCount	; = bank
     88  2435
     89  2435		       a9 ff		      lda	#-1
     90  2437		       85 89		      sta	cursorX12
     91  2439
      0  2439					      PHASE	ClearEachRow
      1  2439		       a9 0e		      lda	#AI_ClearEachRow
      2  243b		       85 8c		      sta	aiState
     93  243d		       60		      rts
     94  243e
     95  243e
     96  243e							;---------------------------------------------------------------------------------------------------
     97  243e
      0  243e					      DEF	aiClearEachRow
      1  243e				   SLOT_aiClearEachRow SET	_BANK_SLOT
      2  243e				   BANK_aiClearEachRow SET	SLOT_aiClearEachRow + _CURRENT_BANK
      3  243e				   aiClearEachRow
      4  243e				   TEMPORARY_VAR SET	Overlay
      5  243e				   TEMPORARY_OFFSET SET	0
      6  243e				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      7  243e				   FUNCTION_NAME SET	aiClearEachRow
     99  243e					      SUBROUTINE
    100  243e
      0  243e					      REF	AiStateMachine	;✅
      1  243e					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  243e				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  243e					      ENDIF
      0  243e					      VEND	aiClearEachRow
      1  243e
      2  243e
      3  243e		       00 a8	   VAREND_aiClearEachRow =	TEMPORARY_VAR
      4  243e
    103  243e
    104  243e		       c6 85		      dec	drawCount
    105  2440		       30 0e		      bmi	.bitmapCleared
    106  2442
    107  2442							; switch in RAM bank for ROW
    108  2442
    109  2442		       a5 85		      lda	drawCount
    110  2444		       09 40		      ora	#SLOT1
    111  2446		       85 3e		      sta	SET_BANK_RAM	;@1
    112  2448
      0  2448					      CALL	ClearRowBitmap	;@3
      1  2448				  -	      IF	SLOT_ClearRowBitmap == _BANK_SLOT
      2  2448				  -FNAME      SETSTR	ClearRowBitmap
      3  2448				  -	      ECHO	""
      4  2448				  -	      ECHO	"ERROR: Incompatible slot for call to function", FNAME
      5  2448				  -	      ECHO	"Cannot switch bank in use for ", FNAME
      6  2448				  -	      ERR
      7  2448					      ENDIF
      8  2448		       a9 da		      lda	#BANK_ClearRowBitmap
      9  244a		       85 3f		      sta	SET_BANK
     10  244c		       20 00 fc 	      jsr	ClearRowBitmap
    114  244f		       60		      rts
    115  2450
    116  2450				   .bitmapCleared
    117  2450
    118  2450		       a9 63		      lda	#99
    119  2452		       85 81		      sta	squareToDraw
    120  2454
      0  2454					      PHASE	DrawEntireBoard
      1  2454		       a9 0f		      lda	#AI_DrawEntireBoard
      2  2456		       85 8c		      sta	aiState
    122  2458		       60		      rts
    123  2459
    124  2459
    125  2459							;---------------------------------------------------------------------------------------------------
    126  2459
      0  2459					      DEF	aiMoveIsSelected
      1  2459				   SLOT_aiMoveIsSelected SET	_BANK_SLOT
      2  2459				   BANK_aiMoveIsSelected SET	SLOT_aiMoveIsSelected + _CURRENT_BANK
      3  2459				   aiMoveIsSelected
      4  2459				   TEMPORARY_VAR SET	Overlay
      5  2459				   TEMPORARY_OFFSET SET	0
      6  2459				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      7  2459				   FUNCTION_NAME SET	aiMoveIsSelected
    128  2459					      SUBROUTINE
    129  2459
      0  2459					      REF	COMMON_VARS
      1  2459					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  2459				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  2459					      ENDIF
      0  2459					      REF	AiStateMachine	;✅
      1  2459				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  2459				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  2459					      ENDIF
      0  2459					      VEND	aiMoveIsSelected
      1  2459
      2  2459
      3  2459		       00 b6	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
      4  2459
    133  2459
    134  2459							; Both computer and human have now seleted a move, and converge here
    135  2459
    136  2459
    137  2459							; fromPiece	 piece doing the move
    138  2459							; fromX12	 current square X12
    139  2459							; originX12	 starting square X12
    140  2459							; toX12	 ending square X12
    141  2459
    142  2459		       20 80 f8 	      jsr	EnPassantFixupDraw
    143  245c
    144  245c							; get the piece types from the board
    145  245c
    146  245c		       a9 d7		      lda	#RAMBANK_BOARD
    147  245e		       85 3e		      sta	SET_BANK_RAM	;@3
    148  2460		       a4 88		      ldy	originX12
    149  2462		       b9 79 fc 	      lda	Board,y
    150  2465		       85 b2		      sta	__originalPiece
    151  2467		       a4 87		      ldy	toX12
    152  2469		       b9 79 fc 	      lda	Board,y
    153  246c		       85 b3		      sta	__capturedPiece
    154  246e
    155  246e							;TODO: what about castling...?
    156  246e
    157  246e		       20 ea f8 	      jsr	AdjustMaterialPositionalValue	;@this
    158  2471
    159  2471		       a9 00		      lda	#0
    160  2473		       85 99		      sta	previousPiece
    161  2475		       85 83		      sta	drawDelay
    162  2477
    163  2477		       a9 0a		      lda	#10	; on/off count
    164  2479		       85 85		      sta	drawCount	; flashing for piece about to move
    165  247b
      0  247b					      PHASE	WriteStartPieceBlank
      1  247b		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  247d		       85 8c		      sta	aiState
    167  247f		       60	   .idleErase rts
    168  2480
    169  2480
    170  2480							;---------------------------------------------------------------------------------------------------
    171  2480
      0  2480					      DEF	EnPassantFixupDraw
      1  2480				   SLOT_EnPassantFixupDraw SET	_BANK_SLOT
      2  2480				   BANK_EnPassantFixupDraw SET	SLOT_EnPassantFixupDraw + _CURRENT_BANK
      3  2480				   EnPassantFixupDraw
      4  2480				   TEMPORARY_VAR SET	Overlay
      5  2480				   TEMPORARY_OFFSET SET	0
      6  2480				   VAR_BOUNDARY_EnPassantFixupDraw SET	TEMPORARY_OFFSET
      7  2480				   FUNCTION_NAME SET	EnPassantFixupDraw
    173  2480					      SUBROUTINE
    174  2480
    175  2480							; {
    176  2480							; With en-passant flag, it is essentially dual-use.
    177  2480							; First, it marks if the move is *involved* somehow in an en-passant
    178  2480							; if the piece has MOVED already, then it's an en-passant capture
    179  2480							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
    180  2480
    181  2480		       a2 00		      ldx	#0	; (probably) NO en-passant this time
    182  2482
    183  2482		       a5 97		      lda	fromPiece
    184  2484		       a8		      tay
    185  2485
    186  2485		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
    187  2487		       c9 20		      cmp	#FLAG_ENPASSANT
    188  2489		       d0 11		      bne	.noep	; HAS moved, or not en-passant
    189  248b
    190  248b		       45 97		      eor	fromPiece	; clear FLAG_ENPASSANT
    191  248d		       85 97		      sta	fromPiece
    192  248f
    193  248f		       a6 87		      ldx	toX12	; this IS an en-passantable opening, so record the square
    194  2491
    195  2491							; set the secondary piece movement info - this allows move/unmakemove to work for enpassant
    196  2491
    197  2491		       a9 00		      lda	#0
      0  2493					      sta@PLY	secondaryBlank
      1  2493		       8d ce fb 	      sta	[RAM]+secondaryBlank
      0  2496					      stx@PLY	secondarySquare
      1  2496		       8e cd fb 	      stx	[RAM]+secondarySquare
      0  2499					      sty@PLY	secondaryPiece
      1  2499		       8c cc fb 	      sty	[RAM]+secondaryPiece
    201  249c
    202  249c				   .noep
    203  249c		       86 94		      stx	enPassantPawn	; capturable square for en-passant move (or none)
    204  249e							; }
    205  249e
    206  249e		       60		      rts
    207  249f
    208  249f							;---------------------------------------------------------------------------------------------------
    209  249f
      0  249f					      DEF	CopySetup
      1  249f				   SLOT_CopySetup SET	_BANK_SLOT
      2  249f				   BANK_CopySetup SET	SLOT_CopySetup + _CURRENT_BANK
      3  249f				   CopySetup
      4  249f				   TEMPORARY_VAR SET	Overlay
      5  249f				   TEMPORARY_OFFSET SET	0
      6  249f				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      7  249f				   FUNCTION_NAME SET	CopySetup
    211  249f					      SUBROUTINE
    212  249f
      0  249f					      REF	CopySinglePiece	;✅
      1  249f					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  249f				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  249f					      ENDIF
    214  249f
      0  249f					      VAR	__tmp, 1
      1  249f		       00 ee	   __tmp      =	TEMPORARY_VAR
      2  249f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  249f
      4  249f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  249f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  249f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  249f					      ENDIF
      8  249f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  249f				  -VNAME      SETSTR	__tmp
     10  249f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  249f				  -	      ERR
     12  249f					      ENDIF
      0  249f					      VAR	__shiftx, 1
      1  249f		       00 ef	   __shiftx   =	TEMPORARY_VAR
      2  249f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  249f
      4  249f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  249f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  249f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  249f					      ENDIF
      8  249f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  249f				  -VNAME      SETSTR	__shiftx
     10  249f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  249f				  -	      ERR
     12  249f					      ENDIF
      0  249f					      VAR	__pieceColour2, 1
      1  249f		       00 f0	   __pieceColour2 =	TEMPORARY_VAR
      2  249f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  249f
      4  249f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  249f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  249f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  249f					      ENDIF
      8  249f				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  249f				  -VNAME      SETSTR	__pieceColour2
     10  249f				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  249f				  -	      ERR
     12  249f					      ENDIF
    218  249f
      0  249f					      VEND	CopySetup
      1  249f
      2  249f
      3  249f		       00 f1	   VAREND_CopySetup =	TEMPORARY_VAR
      4  249f
    220  249f
    221  249f							; figure colouration of square
    222  249f
    223  249f		       a5 81		      lda	squareToDraw
    224  24a1
    225  24a1				  -	      IF	DIAGNOSTICS
    226  24a1				  -			; Catch out-of-range piece square
    227  24a1				  -			; will not catch off left/right edge
    228  24a1				  -
    229  24a1				  -.fail      cmp	#100
    230  24a1				  -	      bcs	.fail
    231  24a1				  -	      cmp	#22
    232  24a1				  -	      bcc	.fail
    233  24a1					      ENDIF
    234  24a1
    235  24a1
    236  24a1		       a2 0a		      ldx	#10
    237  24a3		       38		      sec
    238  24a4		       e9 0a	   .sub10     sbc	#10
    239  24a6		       ca		      dex
    240  24a7		       b0 fb		      bcs	.sub10
    241  24a9		       69 08		      adc	#8
    242  24ab		       85 ef		      sta	__shiftx
    243  24ad				  -	      IF	DIAGNOSTICS
    244  24ad				  -.fail2     cmp	#8
    245  24ad				  -	      bcs	.fail2
    246  24ad				  -	      cpx	#8
    247  24ad				  -	      bcs	.fail2
    248  24ad					      ENDIF
    249  24ad		       86 ee		      stx	__tmp
    250  24af		       65 ee		      adc	__tmp
    251  24b1
    252  24b1
    253  24b1		       29 01		      and	#1
    254  24b3		       49 01		      eor	#1
    255  24b5		       f0 02		      beq	.white
    256  24b7		       a9 24		      lda	#36
    257  24b9				   .white
    258  24b9		       85 f0		      sta	__pieceColour2	; actually SQUARE black/white
    259  24bb
    260  24bb							; PieceColour = 0 for white square, 36 for black square
    261  24bb
    262  24bb		       a9 d7		      lda	#RAMBANK_BOARD
    263  24bd		       85 3e		      sta	SET_BANK_RAM	;@3
    264  24bf
    265  24bf		       a4 81		      ldy	squareToDraw
    266  24c1		       b9 79 fc 	      lda	Board,y
    267  24c4							;and #$87
    268  24c4		       0a		      asl
    269  24c5		       90 02		      bcc	.blackAdjust
    270  24c7		       09 10		      ora	#16	; switch white pieces
    271  24c9		       4a	   .blackAdjust lsr
    272  24ca		       29 0f		      and	#%1111
    273  24cc		       aa		      tax
    274  24cd
    275  24cd		       a5 ef		      lda	__shiftx
    276  24cf		       29 03		      and	#3	; shift position in P
    277  24d1
    278  24d1		       18		      clc
    279  24d2		       7d da f8 	      adc	PieceToShape,x
    280  24d5		       18		      clc
    281  24d6		       65 f0		      adc	__pieceColour2
    282  24d8		       a8		      tay
    283  24d9		       60		      rts
    284  24da
    285  24da				   PieceToShape
    286  24da
    287  24da		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    288  24db		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    289  24dc		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (black P)
    290  24dd		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    291  24de		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    292  24df		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    293  24e0		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    294  24e1		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    295  24e2
    296  24e2		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    297  24e3		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0	; impossible (white P)
    298  24e4		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    299  24e5		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    300  24e6		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    301  24e7		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    302  24e8		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    303  24e9		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    304  24ea
    305  24ea
    306  24ea							;---------------------------------------------------------------------------------------------------
    307  24ea
      0  24ea					      DEF	AdjustMaterialPositionalValue
      1  24ea				   SLOT_AdjustMaterialPositionalValue SET	_BANK_SLOT
      2  24ea				   BANK_AdjustMaterialPositionalValue SET	SLOT_AdjustMaterialPositionalValue + _CURRENT_BANK
      3  24ea				   AdjustMaterialPositionalValue
      4  24ea				   TEMPORARY_VAR SET	Overlay
      5  24ea				   TEMPORARY_OFFSET SET	0
      6  24ea				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      7  24ea				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
    309  24ea					      SUBROUTINE
    310  24ea
    311  24ea							; A move is about to be made, so  adjust material and positional values based on from/to and
    312  24ea							; capture.
    313  24ea
    314  24ea							; First, nominate referencing subroutines so that local variables can be adjusted properly
    315  24ea
      0  24ea					      REF	COMMON_VARS
      1  24ea					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  24ea				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  24ea					      ENDIF
      0  24ea					      REF	MakeMove	;✅
      1  24ea					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  24ea				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  24ea					      ENDIF
      0  24ea					      REF	aiMoveIsSelected	;✅
      1  24ea				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  24ea				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  24ea					      ENDIF
      0  24ea					      VEND	AdjustMaterialPositionalValue
      1  24ea
      2  24ea
      3  24ea		       00 b8	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
      4  24ea
    320  24ea
    321  24ea							; fromPiece	 piece doing the move (promoted type)
    322  24ea							; fromX12	 current square
    323  24ea							; originX12	 starting square
    324  24ea							; toX12	 ending square
    325  24ea
    326  24ea
    327  24ea							; {
    328  24ea							;   adjust the positional value  (originX12 --> fromX12)
    329  24ea
    330  24ea		       a4 87		      ldy	toX12	; already loaded
    331  24ec		       a5 97		      lda	fromPiece
    332  24ee		       20 59 f9 	      jsr	AddPiecePositionValue	; add pos value for new position
    333  24f1
    334  24f1
    335  24f1		       a5 b2		      lda	__originalPiece
    336  24f3		       45 97		      eor	fromPiece	; the new piece
    337  24f5		       29 0f		      and	#PIECE_MASK
    338  24f7		       f0 05		      beq	.same1	; unchanged, so skip
    339  24f9
    340  24f9		       a5 97		      lda	fromPiece	; new piece
    341  24fb		       20 36 f9 	      jsr	AddPieceMaterialValue
    342  24fe
    343  24fe				   .same1
    344  24fe
    345  24fe							; and now the 'subtracts'
    346  24fe
      0  24fe					      NEGEVAL
      1  24fe
      2  24fe		       38		      sec
      3  24ff		       a9 00		      lda	#0
      4  2501		       e5 90		      sbc	Evaluation
      5  2503		       85 90		      sta	Evaluation
      6  2505		       a9 00		      lda	#0
      7  2507		       e5 91		      sbc	Evaluation+1
      8  2509		       85 91		      sta	Evaluation+1
      9  250b
    348  250b
    349  250b		       a4 88		      ldy	originX12
    350  250d		       a5 b2		      lda	__originalPiece
    351  250f		       20 59 f9 	      jsr	AddPiecePositionValue	; remove pos value for original position
    352  2512
    353  2512
    354  2512		       a5 b2		      lda	__originalPiece
    355  2514		       45 97		      eor	fromPiece	; the new piece
    356  2516		       29 0f		      and	#PIECE_MASK
    357  2518		       f0 05		      beq	.same2	; unchanged, so skip
    358  251a
    359  251a		       a5 b2		      lda	__originalPiece
    360  251c		       20 36 f9 	      jsr	AddPieceMaterialValue	; remove material for original type
    361  251f				   .same2
    362  251f
      0  251f					      NEGEVAL
      1  251f
      2  251f		       38		      sec
      3  2520		       a9 00		      lda	#0
      4  2522		       e5 90		      sbc	Evaluation
      5  2524		       85 90		      sta	Evaluation
      6  2526		       a9 00		      lda	#0
      7  2528		       e5 91		      sbc	Evaluation+1
      8  252a		       85 91		      sta	Evaluation+1
      9  252c
    364  252c
    365  252c							; If there's a capture, we adjust the material value
    366  252c
    367  252c							;		      lda __capturedPiece
    368  252c							;		      eor __originalPiece
    369  252c							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    370  252c
    371  252c
    372  252c		       a5 b3		      lda	__capturedPiece
    373  252e		       29 0f		      and	#PIECE_MASK
    374  2530		       f0 03		      beq	.noCapture
    375  2532		       20 36 f9 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    376  2535				   .noCapture
    377  2535
    378  2535							; }
    379  2535		       60		      rts
    380  2536
    381  2536
    382  2536							;---------------------------------------------------------------------------------------------------
    383  2536
      0  2536					      DEF	AddPieceMaterialValue
      1  2536				   SLOT_AddPieceMaterialValue SET	_BANK_SLOT
      2  2536				   BANK_AddPieceMaterialValue SET	SLOT_AddPieceMaterialValue + _CURRENT_BANK
      3  2536				   AddPieceMaterialValue
      4  2536				   TEMPORARY_VAR SET	Overlay
      5  2536				   TEMPORARY_OFFSET SET	0
      6  2536				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      7  2536				   FUNCTION_NAME SET	AddPieceMaterialValue
    385  2536					      SUBROUTINE
    386  2536
      0  2536					      REF	COMMON_VARS
      1  2536					      IF	VAREND_COMMON_VARS > TEMPORARY_VAR
      2  2536				   TEMPORARY_VAR SET	VAREND_COMMON_VARS
      3  2536					      ENDIF
      0  2536					      REF	InitialisePieceSquares	;✅
      1  2536					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  2536				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  2536					      ENDIF
      0  2536					      REF	AdjustMaterialPositionalValue	;✅
      1  2536				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  2536				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  2536					      ENDIF
    390  2536							;REF EnPassantRemovePiece ;✅
      0  2536					      VEND	AddPieceMaterialValue
      1  2536
      2  2536
      3  2536		       00 ba	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
      4  2536
    392  2536
    393  2536							; Adjust the material score based on the piece
    394  2536							; a = piece type + flags
    395  2536
    396  2536		       29 0f		      and	#PIECE_MASK
    397  2538		       a8		      tay
    398  2539
    399  2539		       18		      clc
    400  253a		       b9 49 f9 	      lda	PieceValueLO,y
    401  253d		       65 90		      adc	Evaluation
    402  253f		       85 90		      sta	Evaluation
    403  2541		       b9 51 f9 	      lda	PieceValueHI,y
    404  2544		       65 91		      adc	Evaluation+1
    405  2546		       85 91		      sta	Evaluation+1
    406  2548		       60		      rts
    407  2549
    408  2549
    409  2549					      MAC	valuetable
    410  2549					      .byte	{1}0	; blank
    411  2549					      .byte	{1}100	; white P
    412  2549					      .byte	{1}100	; black P
    413  2549					      .byte	{1}320	; N
    414  2549					      .byte	{1}375	; B
    415  2549					      .byte	{1}575	; R
    416  2549					      .byte	{1}900	; Q
    417  2549					      .byte	{1}10000	; K
    418  2549					      ENDM
    419  2549
    420  2549				   PieceValueLO
      0  2549					      VALUETABLE	<
      1  2549		       00		      .byte.b	<0
      2  254a		       64		      .byte.b	<100
      3  254b		       64		      .byte.b	<100
      4  254c		       40		      .byte.b	<320
      5  254d		       77		      .byte.b	<375
      6  254e		       3f		      .byte.b	<575
      7  254f		       84		      .byte.b	<900
      8  2550		       10		      .byte.b	<10000
    422  2551
    423  2551				   PieceValueHI
      0  2551					      VALUETABLE	>
      1  2551		       00		      .byte.b	>0
      2  2552		       00		      .byte.b	>100
      3  2553		       00		      .byte.b	>100
      4  2554		       01		      .byte.b	>320
      5  2555		       01		      .byte.b	>375
      6  2556		       02		      .byte.b	>575
      7  2557		       03		      .byte.b	>900
      8  2558		       27		      .byte.b	>10000
    425  2559
    426  2559
    427  2559							;---------------------------------------------------------------------------------------------------
    428  2559
      0  2559					      DEF	AddPiecePositionValue
      1  2559				   SLOT_AddPiecePositionValue SET	_BANK_SLOT
      2  2559				   BANK_AddPiecePositionValue SET	SLOT_AddPiecePositionValue + _CURRENT_BANK
      3  2559				   AddPiecePositionValue
      4  2559				   TEMPORARY_VAR SET	Overlay
      5  2559				   TEMPORARY_OFFSET SET	0
      6  2559				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      7  2559				   FUNCTION_NAME SET	AddPiecePositionValue
    430  2559					      SUBROUTINE
    431  2559
      0  2559					      REF	InitialisePieceSquares	;✅
      1  2559					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  2559				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  2559					      ENDIF
      0  2559					      REF	AdjustMaterialPositionalValue	;✅
      1  2559				  -	      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  2559				  -TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  2559					      ENDIF
    434  2559							;REF EnPassantRemovePiece ;✅
      0  2559					      VAR	__valPtr, 2
      1  2559		       00 ba	   __valPtr   =	TEMPORARY_VAR
      2  2559				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  2559
      4  2559				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2559				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2559				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2559					      ENDIF
      8  2559				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  2559				  -VNAME      SETSTR	__valPtr
     10  2559				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  2559				  -	      ERR
     12  2559					      ENDIF
      0  2559					      VEND	AddPiecePositionValue
      1  2559
      2  2559
      3  2559		       00 bc	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
      4  2559
    437  2559
    438  2559
    439  2559							; adds value of square piece is on to the evaluation
    440  2559							; note to do the subtraction as -( -x + val) == x - val
    441  2559
    442  2559							; y = square
    443  2559							; a = piece type (+flags)
    444  2559
    445  2559
    446  2559
    447  2559		       c9 80		      cmp	#128	; black = CS
    448  255b		       29 0f		      and	#PIECE_MASK
    449  255d		       aa		      tax
    450  255e
    451  255e		       a9 db		      lda	#ROMBANK_EVALUATE
    452  2560		       85 3f		      sta	SET_BANK	;@3
    453  2562
    454  2562							; black pieces flip rows so we can use the same eval tables
    455  2562
    456  2562		       98		      tya
    457  2563		       90 03		      bcc	.white
    458  2565		       b9 85 f9 	      lda	FlipSquareIndex,y
    459  2568							;clc
    460  2568				   .white
    461  2568		       7d 00 fc 	      adc	PosValVecLO,x
    462  256b		       85 ba		      sta	__valPtr
    463  256d		       bd 08 fc 	      lda	PosValVecHI,x
    464  2570		       69 00		      adc	#0
    465  2572		       85 bb		      sta	__valPtr+1
    466  2574
    467  2574		       a0 00		      ldy	#0
    468  2576		       b1 ba		      lda	(__valPtr),y
    469  2578		       10 01		      bpl	.sum
    470  257a		       88		      dey
    471  257b
    472  257b				   .sum 		;clc
    473  257b		       65 90		      adc	Evaluation
    474  257d		       85 90		      sta	Evaluation
    475  257f		       98		      tya
    476  2580		       65 91		      adc	Evaluation+1
    477  2582		       85 91		      sta	Evaluation+1
    478  2584		       60		      rts
    479  2585
    480  2585
    481  2585				   FlipSquareIndex
    482  2585
    483  2585		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    484  258f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    485  2599
    486  2599				   .SQBASE    SET	90-1
    487  2599					      REPEAT	8
    488  2599		       00 00		      .byte.b	0,0
    489  2599				   .SQX       SET	2
    490  259b					      REPEAT	8
    491  259b		       5b		      .byte.b	(.SQBASE+.SQX)
    492  259b				   .SQX       SET	.SQX + 1
    490  259b					      REPEND
    491  259c		       5c		      .byte.b	(.SQBASE+.SQX)
    492  259c				   .SQX       SET	.SQX + 1
    490  259c					      REPEND
    491  259d		       5d		      .byte.b	(.SQBASE+.SQX)
    492  259d				   .SQX       SET	.SQX + 1
    490  259d					      REPEND
    491  259e		       5e		      .byte.b	(.SQBASE+.SQX)
    492  259e				   .SQX       SET	.SQX + 1
    490  259e					      REPEND
    491  259f		       5f		      .byte.b	(.SQBASE+.SQX)
    492  259f				   .SQX       SET	.SQX + 1
    490  259f					      REPEND
    491  25a0		       60		      .byte.b	(.SQBASE+.SQX)
    492  25a0				   .SQX       SET	.SQX + 1
    490  25a0					      REPEND
    491  25a1		       61		      .byte.b	(.SQBASE+.SQX)
    492  25a1				   .SQX       SET	.SQX + 1
    490  25a1					      REPEND
    491  25a2		       62		      .byte.b	(.SQBASE+.SQX)
    492  25a2				   .SQX       SET	.SQX + 1
    493  25a3					      REPEND
    494  25a3				   .SQBASE    SET	.SQBASE - 10
    487  25a3					      REPEND
    488  25a3		       00 00		      .byte.b	0,0
    489  25a3				   .SQX       SET	2
    490  25a5					      REPEAT	8
    491  25a5		       51		      .byte.b	(.SQBASE+.SQX)
    492  25a5				   .SQX       SET	.SQX + 1
    490  25a5					      REPEND
    491  25a6		       52		      .byte.b	(.SQBASE+.SQX)
    492  25a6				   .SQX       SET	.SQX + 1
    490  25a6					      REPEND
    491  25a7		       53		      .byte.b	(.SQBASE+.SQX)
    492  25a7				   .SQX       SET	.SQX + 1
    490  25a7					      REPEND
    491  25a8		       54		      .byte.b	(.SQBASE+.SQX)
    492  25a8				   .SQX       SET	.SQX + 1
    490  25a8					      REPEND
    491  25a9		       55		      .byte.b	(.SQBASE+.SQX)
    492  25a9				   .SQX       SET	.SQX + 1
    490  25a9					      REPEND
    491  25aa		       56		      .byte.b	(.SQBASE+.SQX)
    492  25aa				   .SQX       SET	.SQX + 1
    490  25aa					      REPEND
    491  25ab		       57		      .byte.b	(.SQBASE+.SQX)
    492  25ab				   .SQX       SET	.SQX + 1
    490  25ab					      REPEND
    491  25ac		       58		      .byte.b	(.SQBASE+.SQX)
    492  25ac				   .SQX       SET	.SQX + 1
    493  25ad					      REPEND
    494  25ad				   .SQBASE    SET	.SQBASE - 10
    487  25ad					      REPEND
    488  25ad		       00 00		      .byte.b	0,0
    489  25ad				   .SQX       SET	2
    490  25af					      REPEAT	8
    491  25af		       47		      .byte.b	(.SQBASE+.SQX)
    492  25af				   .SQX       SET	.SQX + 1
    490  25af					      REPEND
    491  25b0		       48		      .byte.b	(.SQBASE+.SQX)
    492  25b0				   .SQX       SET	.SQX + 1
    490  25b0					      REPEND
    491  25b1		       49		      .byte.b	(.SQBASE+.SQX)
    492  25b1				   .SQX       SET	.SQX + 1
    490  25b1					      REPEND
    491  25b2		       4a		      .byte.b	(.SQBASE+.SQX)
    492  25b2				   .SQX       SET	.SQX + 1
    490  25b2					      REPEND
    491  25b3		       4b		      .byte.b	(.SQBASE+.SQX)
    492  25b3				   .SQX       SET	.SQX + 1
    490  25b3					      REPEND
    491  25b4		       4c		      .byte.b	(.SQBASE+.SQX)
    492  25b4				   .SQX       SET	.SQX + 1
    490  25b4					      REPEND
    491  25b5		       4d		      .byte.b	(.SQBASE+.SQX)
    492  25b5				   .SQX       SET	.SQX + 1
    490  25b5					      REPEND
    491  25b6		       4e		      .byte.b	(.SQBASE+.SQX)
    492  25b6				   .SQX       SET	.SQX + 1
    493  25b7					      REPEND
    494  25b7				   .SQBASE    SET	.SQBASE - 10
    487  25b7					      REPEND
    488  25b7		       00 00		      .byte.b	0,0
    489  25b7				   .SQX       SET	2
    490  25b9					      REPEAT	8
    491  25b9		       3d		      .byte.b	(.SQBASE+.SQX)
    492  25b9				   .SQX       SET	.SQX + 1
    490  25b9					      REPEND
    491  25ba		       3e		      .byte.b	(.SQBASE+.SQX)
    492  25ba				   .SQX       SET	.SQX + 1
    490  25ba					      REPEND
    491  25bb		       3f		      .byte.b	(.SQBASE+.SQX)
    492  25bb				   .SQX       SET	.SQX + 1
    490  25bb					      REPEND
    491  25bc		       40		      .byte.b	(.SQBASE+.SQX)
    492  25bc				   .SQX       SET	.SQX + 1
    490  25bc					      REPEND
    491  25bd		       41		      .byte.b	(.SQBASE+.SQX)
    492  25bd				   .SQX       SET	.SQX + 1
    490  25bd					      REPEND
    491  25be		       42		      .byte.b	(.SQBASE+.SQX)
    492  25be				   .SQX       SET	.SQX + 1
    490  25be					      REPEND
    491  25bf		       43		      .byte.b	(.SQBASE+.SQX)
    492  25bf				   .SQX       SET	.SQX + 1
    490  25bf					      REPEND
    491  25c0		       44		      .byte.b	(.SQBASE+.SQX)
    492  25c0				   .SQX       SET	.SQX + 1
    493  25c1					      REPEND
    494  25c1				   .SQBASE    SET	.SQBASE - 10
    487  25c1					      REPEND
    488  25c1		       00 00		      .byte.b	0,0
    489  25c1				   .SQX       SET	2
    490  25c3					      REPEAT	8
    491  25c3		       33		      .byte.b	(.SQBASE+.SQX)
    492  25c3				   .SQX       SET	.SQX + 1
    490  25c3					      REPEND
    491  25c4		       34		      .byte.b	(.SQBASE+.SQX)
    492  25c4				   .SQX       SET	.SQX + 1
    490  25c4					      REPEND
    491  25c5		       35		      .byte.b	(.SQBASE+.SQX)
    492  25c5				   .SQX       SET	.SQX + 1
    490  25c5					      REPEND
    491  25c6		       36		      .byte.b	(.SQBASE+.SQX)
    492  25c6				   .SQX       SET	.SQX + 1
    490  25c6					      REPEND
    491  25c7		       37		      .byte.b	(.SQBASE+.SQX)
    492  25c7				   .SQX       SET	.SQX + 1
    490  25c7					      REPEND
    491  25c8		       38		      .byte.b	(.SQBASE+.SQX)
    492  25c8				   .SQX       SET	.SQX + 1
    490  25c8					      REPEND
    491  25c9		       39		      .byte.b	(.SQBASE+.SQX)
    492  25c9				   .SQX       SET	.SQX + 1
    490  25c9					      REPEND
    491  25ca		       3a		      .byte.b	(.SQBASE+.SQX)
    492  25ca				   .SQX       SET	.SQX + 1
    493  25cb					      REPEND
    494  25cb				   .SQBASE    SET	.SQBASE - 10
    487  25cb					      REPEND
    488  25cb		       00 00		      .byte.b	0,0
    489  25cb				   .SQX       SET	2
    490  25cd					      REPEAT	8
    491  25cd		       29		      .byte.b	(.SQBASE+.SQX)
    492  25cd				   .SQX       SET	.SQX + 1
    490  25cd					      REPEND
    491  25ce		       2a		      .byte.b	(.SQBASE+.SQX)
    492  25ce				   .SQX       SET	.SQX + 1
    490  25ce					      REPEND
    491  25cf		       2b		      .byte.b	(.SQBASE+.SQX)
    492  25cf				   .SQX       SET	.SQX + 1
    490  25cf					      REPEND
    491  25d0		       2c		      .byte.b	(.SQBASE+.SQX)
    492  25d0				   .SQX       SET	.SQX + 1
    490  25d0					      REPEND
    491  25d1		       2d		      .byte.b	(.SQBASE+.SQX)
    492  25d1				   .SQX       SET	.SQX + 1
    490  25d1					      REPEND
    491  25d2		       2e		      .byte.b	(.SQBASE+.SQX)
    492  25d2				   .SQX       SET	.SQX + 1
    490  25d2					      REPEND
    491  25d3		       2f		      .byte.b	(.SQBASE+.SQX)
    492  25d3				   .SQX       SET	.SQX + 1
    490  25d3					      REPEND
    491  25d4		       30		      .byte.b	(.SQBASE+.SQX)
    492  25d4				   .SQX       SET	.SQX + 1
    493  25d5					      REPEND
    494  25d5				   .SQBASE    SET	.SQBASE - 10
    487  25d5					      REPEND
    488  25d5		       00 00		      .byte.b	0,0
    489  25d5				   .SQX       SET	2
    490  25d7					      REPEAT	8
    491  25d7		       1f		      .byte.b	(.SQBASE+.SQX)
    492  25d7				   .SQX       SET	.SQX + 1
    490  25d7					      REPEND
    491  25d8		       20		      .byte.b	(.SQBASE+.SQX)
    492  25d8				   .SQX       SET	.SQX + 1
    490  25d8					      REPEND
    491  25d9		       21		      .byte.b	(.SQBASE+.SQX)
    492  25d9				   .SQX       SET	.SQX + 1
    490  25d9					      REPEND
    491  25da		       22		      .byte.b	(.SQBASE+.SQX)
    492  25da				   .SQX       SET	.SQX + 1
    490  25da					      REPEND
    491  25db		       23		      .byte.b	(.SQBASE+.SQX)
    492  25db				   .SQX       SET	.SQX + 1
    490  25db					      REPEND
    491  25dc		       24		      .byte.b	(.SQBASE+.SQX)
    492  25dc				   .SQX       SET	.SQX + 1
    490  25dc					      REPEND
    491  25dd		       25		      .byte.b	(.SQBASE+.SQX)
    492  25dd				   .SQX       SET	.SQX + 1
    490  25dd					      REPEND
    491  25de		       26		      .byte.b	(.SQBASE+.SQX)
    492  25de				   .SQX       SET	.SQX + 1
    493  25df					      REPEND
    494  25df				   .SQBASE    SET	.SQBASE - 10
    487  25df					      REPEND
    488  25df		       00 00		      .byte.b	0,0
    489  25df				   .SQX       SET	2
    490  25e1					      REPEAT	8
    491  25e1		       15		      .byte.b	(.SQBASE+.SQX)
    492  25e1				   .SQX       SET	.SQX + 1
    490  25e1					      REPEND
    491  25e2		       16		      .byte.b	(.SQBASE+.SQX)
    492  25e2				   .SQX       SET	.SQX + 1
    490  25e2					      REPEND
    491  25e3		       17		      .byte.b	(.SQBASE+.SQX)
    492  25e3				   .SQX       SET	.SQX + 1
    490  25e3					      REPEND
    491  25e4		       18		      .byte.b	(.SQBASE+.SQX)
    492  25e4				   .SQX       SET	.SQX + 1
    490  25e4					      REPEND
    491  25e5		       19		      .byte.b	(.SQBASE+.SQX)
    492  25e5				   .SQX       SET	.SQX + 1
    490  25e5					      REPEND
    491  25e6		       1a		      .byte.b	(.SQBASE+.SQX)
    492  25e6				   .SQX       SET	.SQX + 1
    490  25e6					      REPEND
    491  25e7		       1b		      .byte.b	(.SQBASE+.SQX)
    492  25e7				   .SQX       SET	.SQX + 1
    490  25e7					      REPEND
    491  25e8		       1c		      .byte.b	(.SQBASE+.SQX)
    492  25e8				   .SQX       SET	.SQX + 1
    493  25e9					      REPEND
    494  25e9				   .SQBASE    SET	.SQBASE - 10
    495  25e9					      REPEND
    496  25e9
    497  25e9
    498  25e9							;---------------------------------------------------------------------------------------------------
    499  25e9
------- FILE piece_vectors.asm LEVEL 3 PASS 4
      0  25e9					      include	"piece_vectors.asm"
      1  25e9							; Created by ConvertChessPieces.py
      0  25e9					      DEF	PIECE_VECTOR_LO
      1  25e9				   SLOT_PIECE_VECTOR_LO SET	_BANK_SLOT
      2  25e9				   BANK_PIECE_VECTOR_LO SET	SLOT_PIECE_VECTOR_LO + _CURRENT_BANK
      3  25e9				   PIECE_VECTOR_LO
      4  25e9				   TEMPORARY_VAR SET	Overlay
      5  25e9				   TEMPORARY_OFFSET SET	0
      6  25e9				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      7  25e9				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      3  25e9		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  25ea		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  25eb		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  25ec		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  25ed		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  25ee		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  25ef		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  25f0		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  25f1		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  25f2		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  25f3		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  25f4		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  25f5		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  25f6		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  25f7		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  25f8		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  25f9		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  25fa		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  25fb		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  25fc		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  25fd		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  25fe		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  25ff		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  2600		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  2601		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  2602		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  2603		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  2604		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  2605		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  2606		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  2607		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  2608		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  2609		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  260a		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  260b		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  260c		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  260d		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  260e		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  260f		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  2610		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  2611		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  2612		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  2613		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  2614		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  2615		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  2616		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  2617		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  2618		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  2619		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  261a		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  261b		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  261c		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  261d		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  261e		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  261f		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  2620		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  2621		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  2622		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  2623		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  2624		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  2625		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  2626		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  2627		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  2628		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  2629		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  262a		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  262b		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  262c		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  262d		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  262e		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  262f		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  2630		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  2631		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  2632		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  2633		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  2634		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  2635		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  2636		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  2637		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  2638		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  2639		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  263a		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  263b		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  263c		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  263d		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  263e		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  263f		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  2640		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  2641		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  2642		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  2643		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  2644		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  2645		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  2646		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  2647		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  2648		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  2649		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  264a		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  264b		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  264c		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  264d		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  264e		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  264f		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  2650		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  2651		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  2652		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  2653		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  2654		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  2655		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  2656		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  2657		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  2658		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  2659		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  265a		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  265b		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  265c		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  265d		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  265e		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  265f		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  2660		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  2661		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  2662		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  2663		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  2664		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  2665		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  2666		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  2667		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  2668		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  2669		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  266a		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  266b		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  266c		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  266d		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  266e		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  266f		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  2670		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  2671		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  2672		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  2673		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  2674		       90		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  2675		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  2676		       48		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  2677		       90		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  2678		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  2679					      DEF	PIECE_VECTOR_HI
      1  2679				   SLOT_PIECE_VECTOR_HI SET	_BANK_SLOT
      2  2679				   BANK_PIECE_VECTOR_HI SET	SLOT_PIECE_VECTOR_HI + _CURRENT_BANK
      3  2679				   PIECE_VECTOR_HI
      4  2679				   TEMPORARY_VAR SET	Overlay
      5  2679				   TEMPORARY_OFFSET SET	0
      6  2679				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      7  2679				   FUNCTION_NAME SET	PIECE_VECTOR_HI
    148  2679		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  267a		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  267b		       f8		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  267c		       f9		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  267d		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  267e		       f9		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  267f		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  2680		       fa		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  2681		       fa		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  2682		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  2683		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  2684		       fb		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  2685		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  2686		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  2687		       f8		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  2688		       f9		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  2689		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  268a		       f9		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  268b		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  268c		       fa		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  268d		       fa		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  268e		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  268f		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  2690		       fb		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  2691		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  2692		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  2693		       f8		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  2694		       f9		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  2695		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  2696		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  2697		       f8		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  2698		       fa		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  2699		       fa		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  269a		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  269b		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  269c		       fb		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  269d		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  269e		       f9		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  269f		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  26a0		       fa		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  26a1		       fa		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  26a2		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  26a3		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  26a4		       fb		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  26a5		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  26a6		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  26a7		       f8		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  26a8		       f9		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  26a9		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  26aa		       f9		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  26ab		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  26ac		       fa		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  26ad		       fa		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  26ae		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  26af		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  26b0		       fb		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  26b1		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  26b2		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  26b3		       f8		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  26b4		       f9		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  26b5		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  26b6		       f9		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  26b7		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  26b8		       fa		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  26b9		       fa		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  26ba		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  26bb		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  26bc		       fb		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  26bd		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  26be		       f9		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  26bf		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  26c0		       fa		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  26c1		       fa		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  26c2		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  26c3		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  26c4		       fb		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  26c5		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  26c6		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  26c7		       f8		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  26c8		       f9		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  26c9		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  26ca		       f9		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  26cb		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  26cc		       fa		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  26cd		       fa		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  26ce		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  26cf		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  26d0		       fb		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  26d1		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  26d2		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  26d3		       f8		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  26d4		       f9		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  26d5		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  26d6		       f9		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  26d7		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  26d8		       fa		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  26d9		       fa		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  26da		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  26db		       fb		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  26dc		       f8		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  26dd		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  26de		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  26df		       f8		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  26e0		       f9		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  26e1		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  26e2		       f9		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  26e3		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  26e4		       fa		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  26e5		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  26e6		       f8		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  26e7		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  26e8		       f9		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  26e9		       f9		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  26ea		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  26eb		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  26ec		       fa		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  26ed		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  26ee		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  26ef		       fb		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  26f0		       f8		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  26f1		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  26f2		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  26f3		       f9		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  26f4		       fa		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  26f5		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  26f6		       fa		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  26f7		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  26f8		       fb		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  26f9		       fb		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  26fa		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  26fb		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  26fc		       f8		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  26fd		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  26fe		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  26ff		       f9		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  2700		       fa		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  2701		       fa		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  2702		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  2703		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  2704		       fb		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  2705		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  2706		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  2707		       f8		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  2708		       f9		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  2709					      DEF	PIECE_VECTOR_BANK
      1  2709				   SLOT_PIECE_VECTOR_BANK SET	_BANK_SLOT
      2  2709				   BANK_PIECE_VECTOR_BANK SET	SLOT_PIECE_VECTOR_BANK + _CURRENT_BANK
      3  2709				   PIECE_VECTOR_BANK
      4  2709				   TEMPORARY_VAR SET	Overlay
      5  2709				   TEMPORARY_OFFSET SET	0
      6  2709				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      7  2709				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
    293  2709		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  270a		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  270b		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  270c		       8f		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  270d		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  270e		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  270f		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  2710		       8f		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  2711		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  2712		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  2713		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  2714		       8f		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  2715		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  2716		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  2717		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  2718		       90		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  2719		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  271a		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  271b		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  271c		       90		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  271d		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  271e		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  271f		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  2720		       90		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  2721		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  2722		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  2723		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  2724		       91		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  2725		       8c		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  2726		       8c		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  2727		       8c		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  2728		       8d		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  2729		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  272a		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  272b		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  272c		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  272d		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  272e		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  272f		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  2730		       91		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  2731		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  2732		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  2733		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  2734		       91		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  2735		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  2736		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  2737		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  2738		       92		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  2739		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  273a		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  273b		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  273c		       92		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  273d		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  273e		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  273f		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  2740		       92		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  2741		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  2742		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  2743		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  2744		       93		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  2745		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  2746		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  2747		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  2748		       93		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  2749		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  274a		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  274b		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  274c		       8b		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  274d		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  274e		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  274f		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  2750		       8e		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  2751		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  2752		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  2753		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  2754		       93		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  2755		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  2756		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  2757		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  2758		       94		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  2759		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  275a		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  275b		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  275c		       94		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  275d		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  275e		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  275f		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  2760		       94		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  2761		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  2762		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  2763		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  2764		       95		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  2765		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  2766		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  2767		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  2768		       95		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  2769		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  276a		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  276b		       95		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  276c		       96		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  276d		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  276e		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  276f		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  2770		       8e		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  2771		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  2772		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  2773		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  2774		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  2775		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  2776		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  2777		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  2778		       96		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  2779		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  277a		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  277b		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  277c		       96		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  277d		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  277e		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  277f		       96		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  2780		       97		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  2781		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  2782		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  2783		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  2784		       8c		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  2785		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  2786		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  2787		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  2788		       8c		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  2789		       8c		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  278a		       8d		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  278b		       8d		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  278c		       8d		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  278d		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  278e		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  278f		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  2790		       8d		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  2791		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  2792		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  2793		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  2794		       8d		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  2795		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  2796		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  2797		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  2798		       8b		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  2799
    438  2799							; piece index equates...
    439  2799		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  2799		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  2799		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  2799		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  2799		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  2799		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  2799		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  2799		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  2799		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  2799		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  2799		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  2799		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  2799		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  2799		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  2799		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  2799		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  2799		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  2799		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  2799		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  2799		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  2799		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  2799		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  2799		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  2799		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  2799		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  2799		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  2799		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  2799		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  2799		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  2799		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  2799		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  2799		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  2799		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  2799		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  2799		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  2799		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  2799		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  2799		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  2799		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  2799		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  2799		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  2799		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  2799		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  2799		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  2799		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  2799		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  2799		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  2799		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  2799		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  2799		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  2799		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  2799		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  2799		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  2799		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  2799		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  2799		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  2799		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  2799		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  2799		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  2799		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  2799		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  2799		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  2799		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  2799		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  2799		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  2799		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  2799		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  2799		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  2799		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  2799		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  2799		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  2799		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  2799		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  2799		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  2799		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  2799		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  2799		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  2799		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  2799		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  2799		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  2799		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  2799		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  2799		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  2799		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  2799		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  2799		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  2799		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  2799		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  2799		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  2799		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  2799		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  2799		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  2799		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  2799		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  2799		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  2799		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  2799		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  2799		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  2799		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  2799		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  2799		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  2799		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  2799		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  2799		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  2799		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  2799		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  2799		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  2799		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  2799		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  2799		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  2799		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  2799		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  2799		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  2799		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  2799		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  2799		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  2799		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  2799		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  2799		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  2799		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  2799		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  2799		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  2799		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  2799		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  2799		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  2799		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  2799		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  2799		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  2799		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  2799		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  2799		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  2799		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  2799		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  2799		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  2799		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  2799		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  2799		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  2799		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  2799		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  2799		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  2799		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  2799		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  2799		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  2799		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE @2 GENERIC #3.asm
    501  2799
    502  2799
    503  2799							;---------------------------------------------------------------------------------------------------
    504  2799
      0  2799					      END_BANK
      1  2799				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  2799				  -	      CHECK_RAM_BANK_SIZE
      3  2799					      ELSE
      0  2799					      CHECK_BANK_SIZE
      1  2799		       03 99	   .TEMP      =	* - _BANK_START
 ROM bank # 10 GENERIC_BANK@2#1 size = $399 free = 102
      2  2799					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  2799				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2799				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  2799				  -	      ERR
      6  2799					      ENDIF
      5  2799					      ENDIF
    506  2799
    507  2799							;---------------------------------------------------------------------------------------------------
    508  2799							;EOF
------- FILE ./chess.asm
------- FILE @2 GENERIC #4.asm LEVEL 2 PASS 4
      0  2799					      include	"@2 GENERIC #4.asm"
      1  2799							;---------------------------------------------------------------------------------------------------
      2  2799							; @2 GENERIC #4.asm
      3  2799
      4  2799							; Atari 2600 Chess
      5  2799							; Copyright (c) 2019-2020 Andrew Davie
      6  2799							; andrew@taswegian.com
      7  2799
      8  2799
      9  2799							;---------------------------------------------------------------------------------------------------
     10  2799
      0  2799					      SLOT	2
      1  2799
      2  2799				  -	      IF	(2 < 0) || (2 > 3)
      3  2799				  -	      ECHO	"Illegal bank address/segment location", 2
      4  2799				  -	      ERR
      5  2799					      ENDIF
      6  2799
      7  2799				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  2799				   _BANK_SLOT SET	2 * 64
      9  2799
      0  2799					      ROMBANK	GENERIC_BANK@2#2
      1  2885 ????				      SEG	ROM_GENERIC_BANK@2#2
      2  2800					      ORG	_ORIGIN
      3  2800					      RORG	_BANK_ADDRESS_ORIGIN
      4  2800				   _BANK_START SET	*
      5  2800				   GENERIC_BANK@2#2_START SET	*
      6  2800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2800				   ROMBANK_GENERIC_BANK@2#2 SET	_BANK_SLOT + _CURRENT_BANK
      8  2800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2800				   _LAST_BANK SETSTR	GENERIC_BANK@2#2
     10  2800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  2800
     14  2800
     15  2800							;---------------------------------------------------------------------------------------------------
     16  2800
      0  2800					      DEF	moveCursor
      1  2800				   SLOT_moveCursor SET	_BANK_SLOT
      2  2800				   BANK_moveCursor SET	SLOT_moveCursor + _CURRENT_BANK
      3  2800				   moveCursor
      4  2800				   TEMPORARY_VAR SET	Overlay
      5  2800				   TEMPORARY_OFFSET SET	0
      6  2800				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      7  2800				   FUNCTION_NAME SET	moveCursor
     18  2800					      SUBROUTINE
     19  2800
      0  2800					      REF	aiSelectStartSquare
      1  2800					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  2800				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  2800					      ENDIF
      0  2800					      REF	aiSelectDestinationSquare
      1  2800					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  2800				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  2800					      ENDIF
     22  2800
      0  2800					      VAR	__newCursor, 1
      1  2800		       00 ee	   __newCursor =	TEMPORARY_VAR
      2  2800				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  2800
      4  2800				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  2800				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  2800				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  2800					      ENDIF
      8  2800				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  2800				  -VNAME      SETSTR	__newCursor
     10  2800				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  2800				  -	      ERR
     12  2800					      ENDIF
     24  2800
      0  2800					      VEND	moveCursor
      1  2800
      2  2800
      3  2800		       00 ef	   VAREND_moveCursor =	TEMPORARY_VAR
      4  2800
     26  2800
     27  2800							; Part (a) move cursor around the board waiting for joystick press
     28  2800
     29  2800		       a2 00		      ldx	#0	; delay
     30  2802
     31  2802		       ad 80 02 	      lda	SWCHA
     32  2805		       4a		      lsr
     33  2806		       4a		      lsr
     34  2807		       4a		      lsr
     35  2808		       4a		      lsr
     36  2809		       a8		      tay
     37  280a
     38  280a		       c9 0f		      cmp	#15
     39  280c		       f0 1e		      beq	.cursor	; nothing pressed - skip delays
     40  280e
     41  280e		       c6 8a		      dec	mdelay
     42  2810		       10 1f		      bpl	.delaym
     43  2812
     44  2812		       18		      clc
     45  2813		       a5 89		      lda	cursorX12
     46  2815		       79 75 f8 	      adc	JoyMoveCursor,y
     47  2818		       85 ee		      sta	__newCursor
     48  281a		       a8		      tay
     49  281b
     50  281b		       a9 d7		      lda	#RAMBANK_BOARD
     51  281d		       85 3e		      sta	SET_BANK_RAM	;@3
     52  281f		       b9 15 fc 	      lda	ValidSquare,y
     53  2822		       c9 ff		      cmp	#-1
     54  2824		       f0 04		      beq	.invalid
     55  2826		       a5 ee		      lda	__newCursor
     56  2828		       85 89		      sta	cursorX12
     57  282a				   .invalid
     58  282a
     59  282a		       a2 10		      ldx	#CURSOR_MOVE_SPEED
     60  282c		       86 8a	   .cursor    stx	mdelay
     61  282e		       20 32 f8 	      jsr	setCursorPriority
     62  2831		       60	   .delaym    rts
     63  2832
     64  2832
     65  2832							;---------------------------------------------------------------------------------------------------
     66  2832
      0  2832					      DEF	setCursorPriority
      1  2832				   SLOT_setCursorPriority SET	_BANK_SLOT
      2  2832				   BANK_setCursorPriority SET	SLOT_setCursorPriority + _CURRENT_BANK
      3  2832				   setCursorPriority
      4  2832				   TEMPORARY_VAR SET	Overlay
      5  2832				   TEMPORARY_OFFSET SET	0
      6  2832				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      7  2832				   FUNCTION_NAME SET	setCursorPriority
     68  2832					      SUBROUTINE
     69  2832
      0  2832					      REF	moveCursor
      1  2832					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  2832				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  2832					      ENDIF
      0  2832					      VEND	setCursorPriority
      1  2832
      2  2832
      3  2832		       00 ef	   VAREND_setCursorPriority =	TEMPORARY_VAR
      4  2832
     72  2832
     73  2832		       98		      tya
     74  2833		       48		      pha
     75  2834
     76  2834		       a2 04		      ldx	#%100
     77  2836
     78  2836		       a4 89		      ldy	cursorX12
     79  2838		       30 0b		      bmi	.under
     80  283a
     81  283a		       a9 d7		      lda	#RAMBANK_BOARD
     82  283c		       85 3e		      sta	SET_BANK_RAM	;@3
     83  283e		       b9 79 fc 	      lda	Board,y
     84  2841		       d0 02		      bne	.under
     85  2843		       a2 00		      ldx	#0
     86  2845		       86 0a	   .under     stx	CTRLPF	; UNDER
     87  2847
     88  2847		       68		      pla
     89  2848		       a8		      tay
     90  2849		       60		      rts
     91  284a
     92  284a
     93  284a							;---------------------------------------------------------------------------------------------------
     94  284a
      0  284a					      DEF	setCursorColours
      1  284a				   SLOT_setCursorColours SET	_BANK_SLOT
      2  284a				   BANK_setCursorColours SET	SLOT_setCursorColours + _CURRENT_BANK
      3  284a				   setCursorColours
      4  284a				   TEMPORARY_VAR SET	Overlay
      5  284a				   TEMPORARY_OFFSET SET	0
      6  284a				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      7  284a				   FUNCTION_NAME SET	setCursorColours
     96  284a					      SUBROUTINE
     97  284a
      0  284a					      REF	aiSelectStartSquare
      1  284a					      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  284a				   TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  284a					      ENDIF
      0  284a					      REF	aiDrawMoves
      1  284a				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  284a					      ENDIF
      0  284a					      REF	aiUnDrawTargetSquares
      1  284a				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  284a					      ENDIF
      0  284a					      REF	aiShowMoveCaptures
      1  284a				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  284a					      ENDIF
      0  284a					      REF	aiSlowFlash
      1  284a				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  284a				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  284a					      ENDIF
      0  284a					      REF	aiSelectDestinationSquare
      1  284a					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  284a				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  284a					      ENDIF
      0  284a					      VEND	setCursorColours
      1  284a
      2  284a
      3  284a		       00 ee	   VAREND_setCursorColours =	TEMPORARY_VAR
      4  284a
    105  284a
    106  284a							; pass y=-1 if move is NOT in the movelist
    107  284a							; preserve y
    108  284a
    109  284a		       a6 a5		      ldx	platform
    110  284c		       bd 61 f8 	      lda	redCol,x
    111  284f
    112  284f		       c0 ff		      cpy	#-1
    113  2851		       f0 0b		      beq	.writeCursorCol	; NOT in the movelist
    114  2853
    115  2853		       a5 8b		      lda	ccur
    116  2855		       4a		      lsr
    117  2856		       4a		      lsr
    118  2857		       4a		      lsr
    119  2858		       29 06		      and	#6
    120  285a		       18		      clc
    121  285b
    122  285b		       7d 63 f8 	      adc	greenCol,x
    123  285e
    124  285e		       85 06	   .writeCursorCol sta	COLUP0
    125  2860		       60		      rts
    126  2861
    127  2861
    128  2861				   redCol
    129  2861		       46 64		      .byte.b	NTSC_COLOUR_LINE_2 - 2, (PAL_COLOUR_LINE_2&$F0)+4
    130  2863				   greenCol
    131  2863		       d2 32		      .byte.b	(NTSC_COLOUR_LINE_3&$F0)+2, (PAL_COLOUR_LINE_3&$F0)+2
    132  2865
    133  2865							;---------------------------------------------------------------------------------------------------
    134  2865
    135  2865							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    136  2865							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    137  2865
      0  2865					      ALLOCATE	JoyCombined, 16
      1  2865
      2  2865				   .NAME      SETSTR	JoyCombined
      0  2865					      OPTIONAL_PAGEBREAK	.NAME, 16
      1  2865
      2  2865				  -	      IF	(>( * + 16 -1 )) > ( >* )
      3  2865				  -.EARLY_LOCATION SET	*
      4  2865				  -	      ALIGN	256
      5  2865				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2865					      ENDIF
      0  2865					      DEF	JoyCombined
      1  2865				   SLOT_JoyCombined SET	_BANK_SLOT
      2  2865				   BANK_JoyCombined SET	SLOT_JoyCombined + _CURRENT_BANK
      3  2865				   JoyCombined
      4  2865				   TEMPORARY_VAR SET	Overlay
      5  2865				   TEMPORARY_OFFSET SET	0
      6  2865				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      7  2865				   FUNCTION_NAME SET	JoyCombined
      5  2865
    139  2865		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    140  2875
      0  2875					      ALLOCATE	JoyMoveCursor, 16
      1  2875
      2  2875				   .NAME      SETSTR	JoyMoveCursor
      0  2875					      OPTIONAL_PAGEBREAK	.NAME, 16
      1  2875
      2  2875				  -	      IF	(>( * + 16 -1 )) > ( >* )
      3  2875				  -.EARLY_LOCATION SET	*
      4  2875				  -	      ALIGN	256
      5  2875				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2875					      ENDIF
      0  2875					      DEF	JoyMoveCursor
      1  2875				   SLOT_JoyMoveCursor SET	_BANK_SLOT
      2  2875				   BANK_JoyMoveCursor SET	SLOT_JoyMoveCursor + _CURRENT_BANK
      3  2875				   JoyMoveCursor
      4  2875				   TEMPORARY_VAR SET	Overlay
      5  2875				   TEMPORARY_OFFSET SET	0
      6  2875				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      7  2875				   FUNCTION_NAME SET	JoyMoveCursor
      5  2875
    142  2875		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    143  2885
    144  2885
    145  2885							;---------------------------------------------------------------------------------------------------
    146  2885
      0  2885					      END_BANK
      1  2885				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  2885				  -	      CHECK_RAM_BANK_SIZE
      3  2885					      ELSE
      0  2885					      CHECK_BANK_SIZE
      1  2885		       00 85	   .TEMP      =	* - _BANK_START
 ROM bank # 11 GENERIC_BANK@2#2 size = $85 free = 890
      2  2885					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  2885				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2885				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  2885				  -	      ERR
      6  2885					      ENDIF
      5  2885					      ENDIF
    148  2885
    149  2885							;---------------------------------------------------------------------------------------------------
    150  2885							;EOF
------- FILE ./chess.asm
------- FILE @2 GRAPHICS DATA.asm LEVEL 2 PASS 4
      0  2885					      include	"@2 GRAPHICS DATA.asm"
      1  2885							;---------------------------------------------------------------------------------------------------
      2  2885							; @2 GRAPHICS DATA.asm
      3  2885
      4  2885							; Atari 2600 Chess
      5  2885							; Copyright (c) 2019-2020 Andrew Davie
      6  2885							; andrew@taswegian.com
      7  2885
      8  2885
      9  2885							;---------------------------------------------------------------------------------------------------
     10  2885
      0  2885					      SLOT	2
      1  2885
      2  2885				  -	      IF	(2 < 0) || (2 > 3)
      3  2885				  -	      ECHO	"Illegal bank address/segment location", 2
      4  2885				  -	      ERR
      5  2885					      ENDIF
      6  2885
      7  2885				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  2885				   _BANK_SLOT SET	2 * 64
      9  2885
     12  2885
     13  2885
     14  2885							;---------------------------------------------------------------------------------------------------
     15  2885
      0  2885					      ROMBANK	GFX1
      1  2fd8 ????				      SEG	ROM_GFX1
      2  2c00					      ORG	_ORIGIN
      3  2c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  2c00				   _BANK_START SET	*
      5  2c00				   GFX1_START SET	*
      6  2c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  2c00				   ROMBANK_GFX1 SET	_BANK_SLOT + _CURRENT_BANK
      8  2c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  2c00				   _LAST_BANK SETSTR	GFX1
     10  2c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     17  2c00
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2c00					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  2c00					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
      1  2c00
      2  2c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2c00				  -.EARLY_LOCATION SET	*
      4  2c00				  -	      ALIGN	256
      5  2c00				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2c00					      ENDIF
      0  2c00					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  2c00				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2c00				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2c00				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      4  2c00				   TEMPORARY_VAR SET	Overlay
      5  2c00				   TEMPORARY_OFFSET SET	0
      6  2c00				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2c00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  2c00		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2c48					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
      1  2c48
      2  2c48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2c48				  -.EARLY_LOCATION SET	*
      4  2c48				  -	      ALIGN	256
      5  2c48				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2c48					      ENDIF
      0  2c48					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  2c48				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2c48				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2c48				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      4  2c48				   TEMPORARY_VAR SET	Overlay
      5  2c48				   TEMPORARY_OFFSET SET	0
      6  2c48				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2c48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2c90					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
      1  2c90
      2  2c90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2c90				  -.EARLY_LOCATION SET	*
      4  2c90				  -	      ALIGN	256
      5  2c90				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2c90					      ENDIF
      0  2c90					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  2c90				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2c90				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2c90				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      4  2c90				   TEMPORARY_VAR SET	Overlay
      5  2c90				   TEMPORARY_OFFSET SET	0
      6  2c90				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2c90				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2cc0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2cd8					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
      1  2cd8
      2  2cd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  2cd8				   .EARLY_LOCATION SET	*
      4  2d00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PROMOTE_on_BLACK_SQUARE_3 wasted 40 bytes
      5  2d00					      ECHO	"Page break for", "BLACK_PROMOTE_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2d00					      ENDIF
      0  2d00					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  2d00				   SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2d00				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2d00				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      4  2d00				   TEMPORARY_VAR SET	Overlay
      5  2d00				   TEMPORARY_OFFSET SET	0
      6  2d00				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2d00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  2d48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
      1  2d48
      2  2d48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2d48				  -.EARLY_LOCATION SET	*
      4  2d48				  -	      ALIGN	256
      5  2d48				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2d48					      ENDIF
      0  2d48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  2d48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  2d48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  2d48				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      4  2d48				   TEMPORARY_VAR SET	Overlay
      5  2d48				   TEMPORARY_OFFSET SET	0
      6  2d48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2d48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  2d48		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  2d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  2d90					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
      1  2d90
      2  2d90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2d90				  -.EARLY_LOCATION SET	*
      4  2d90				  -	      ALIGN	256
      5  2d90				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2d90					      ENDIF
      0  2d90					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  2d90				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  2d90				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  2d90				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      4  2d90				   TEMPORARY_VAR SET	Overlay
      5  2d90				   TEMPORARY_OFFSET SET	0
      6  2d90				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2d90				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  2dd8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
      1  2dd8
      2  2dd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  2dd8				   .EARLY_LOCATION SET	*
      4  2e00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PROMOTE_on_WHITE_SQUARE_2 wasted 40 bytes
      5  2e00					      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2e00					      ENDIF
      0  2e00					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  2e00				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  2e00				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  2e00				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      4  2e00				   TEMPORARY_VAR SET	Overlay
      5  2e00				   TEMPORARY_OFFSET SET	0
      6  2e00				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2e00				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  2e30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  2e48					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
      1  2e48
      2  2e48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2e48				  -.EARLY_LOCATION SET	*
      4  2e48				  -	      ALIGN	256
      5  2e48				  -	      ECHO	"Page break for", "BLACK_PROMOTE_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2e48					      ENDIF
      0  2e48					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  2e48				   SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  2e48				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  2e48				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      4  2e48				   TEMPORARY_VAR SET	Overlay
      5  2e48				   TEMPORARY_OFFSET SET	0
      6  2e48				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2e48				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  2e90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
      1  2e90
      2  2e90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2e90				  -.EARLY_LOCATION SET	*
      4  2e90				  -	      ALIGN	256
      5  2e90				  -	      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2e90					      ENDIF
      0  2e90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  2e90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  2e90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  2e90				   WHITE_MARKER_on_BLACK_SQUARE_0
      4  2e90				   TEMPORARY_VAR SET	Overlay
      5  2e90				   TEMPORARY_OFFSET SET	0
      6  2e90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  2e90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      3  2e90		       00 40 e0 e0*	      .byte.b	$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00	;PF0
      4  2ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  2ed8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
      1  2ed8
      2  2ed8					      IF	(>( * + 72 -1 )) > ( >* )
      3  2ed8				   .EARLY_LOCATION SET	*
      4  2f00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_MARKER_on_BLACK_SQUARE_1 wasted 40 bytes
      5  2f00					      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2f00					      ENDIF
      0  2f00					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  2f00				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  2f00				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  2f00				   WHITE_MARKER_on_BLACK_SQUARE_1
      4  2f00				   TEMPORARY_VAR SET	Overlay
      5  2f00				   TEMPORARY_OFFSET SET	0
      6  2f00				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  2f00				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       00 10 38 38*	      .byte.b	$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  2f48					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
      1  2f48
      2  2f48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2f48				  -.EARLY_LOCATION SET	*
      4  2f48				  -	      ALIGN	256
      5  2f48				  -	      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2f48					      ENDIF
      0  2f48					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  2f48				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  2f48				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  2f48				   WHITE_MARKER_on_BLACK_SQUARE_2
      4  2f48				   TEMPORARY_VAR SET	Overlay
      5  2f48				   TEMPORARY_OFFSET SET	0
      6  2f48				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  2f48				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       00 00 01 01*	      .byte.b	$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00	;PF1
      5  2f78		       00 01 03 03*	      .byte.b	$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  2f90					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
      1  2f90
      2  2f90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  2f90				  -.EARLY_LOCATION SET	*
      4  2f90				  -	      ALIGN	256
      5  2f90				  -	      ECHO	"Page break for", "WHITE_MARKER_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  2f90					      ENDIF
      0  2f90					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  2f90				   SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  2f90				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	SLOT_WHITE_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  2f90				   WHITE_MARKER_on_BLACK_SQUARE_3
      4  2f90				   TEMPORARY_VAR SET	Overlay
      5  2f90				   TEMPORARY_OFFSET SET	0
      6  2f90				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  2f90				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       00 20 70 70*	      .byte.b	$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     30  2fd8
      0  2fd8					      END_BANK
      1  2fd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  2fd8				  -	      CHECK_RAM_BANK_SIZE
      3  2fd8					      ELSE
      0  2fd8					      CHECK_BANK_SIZE
      1  2fd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 12 GFX1 size = $3d8 free = 39
      2  2fd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  2fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      5  2fd8					      ENDIF
     32  2fd8
     33  2fd8
     34  2fd8							;---------------------------------------------------------------------------------------------------
     35  2fd8
      0  2fd8					      ROMBANK	GFX2
      1  33d8 ????				      SEG	ROM_GFX2
      2  3000					      ORG	_ORIGIN
      3  3000					      RORG	_BANK_ADDRESS_ORIGIN
      4  3000				   _BANK_START SET	*
      5  3000				   GFX2_START SET	*
      6  3000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3000				   ROMBANK_GFX2 SET	_BANK_SLOT + _CURRENT_BANK
      8  3000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3000				   _LAST_BANK SETSTR	GFX2
     10  3000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     37  3000
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3000					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
      1  3000
      2  3000				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3000				  -.EARLY_LOCATION SET	*
      4  3000				  -	      ALIGN	256
      5  3000				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3000					      ENDIF
      0  3000					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  3000				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3000				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3000				   WHITE_MARKER_on_WHITE_SQUARE_0
      4  3000				   TEMPORARY_VAR SET	Overlay
      5  3000				   TEMPORARY_OFFSET SET	0
      6  3000				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3000				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      3  3000		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$40,$e0,$e0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3048					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
      1  3048
      2  3048				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3048				  -.EARLY_LOCATION SET	*
      4  3048				  -	      ALIGN	256
      5  3048				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3048					      ENDIF
      0  3048					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  3048				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3048				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3048				   WHITE_MARKER_on_WHITE_SQUARE_1
      4  3048				   TEMPORARY_VAR SET	Overlay
      5  3048				   TEMPORARY_OFFSET SET	0
      6  3048				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3048				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$10,$38,$38,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3090					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
      1  3090
      2  3090				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3090				  -.EARLY_LOCATION SET	*
      4  3090				  -	      ALIGN	256
      5  3090				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3090					      ENDIF
      0  3090					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  3090				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3090				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3090				   WHITE_MARKER_on_WHITE_SQUARE_2
      4  3090				   TEMPORARY_VAR SET	Overlay
      5  3090				   TEMPORARY_OFFSET SET	0
      6  3090				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3090				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  30c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$03,$03,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  30d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
      1  30d8
      2  30d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  30d8				   .EARLY_LOCATION SET	*
      4  3100		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BISHOP_on_BLACK_SQUARE_0 wasted 40 bytes
      5  3100					      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3100					      ENDIF
      0  3100					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  3100				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3100				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3100				   BLACK_BISHOP_on_BLACK_SQUARE_0
      4  3100				   TEMPORARY_VAR SET	Overlay
      5  3100				   TEMPORARY_OFFSET SET	0
      6  3100				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3100				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      3  3100		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  3118		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3148					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
      1  3148
      2  3148				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3148				  -.EARLY_LOCATION SET	*
      4  3148				  -	      ALIGN	256
      5  3148				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3148					      ENDIF
      0  3148					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  3148				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3148				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3148				   BLACK_BISHOP_on_BLACK_SQUARE_1
      4  3148				   TEMPORARY_VAR SET	Overlay
      5  3148				   TEMPORARY_OFFSET SET	0
      6  3148				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3148				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      3  3148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3160		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3190					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
      1  3190
      2  3190				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3190				  -.EARLY_LOCATION SET	*
      4  3190				  -	      ALIGN	256
      5  3190				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3190					      ENDIF
      0  3190					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  3190				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3190				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3190				   BLACK_BISHOP_on_BLACK_SQUARE_2
      4  3190				   TEMPORARY_VAR SET	Overlay
      5  3190				   TEMPORARY_OFFSET SET	0
      6  3190				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3190				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  31c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  31d8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
      1  31d8
      2  31d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  31d8				   .EARLY_LOCATION SET	*
      4  3200		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BISHOP_on_BLACK_SQUARE_3 wasted 40 bytes
      5  3200					      ECHO	"Page break for", "BLACK_BISHOP_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3200					      ENDIF
      0  3200					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  3200				   SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3200				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3200				   BLACK_BISHOP_on_BLACK_SQUARE_3
      4  3200				   TEMPORARY_VAR SET	Overlay
      5  3200				   TEMPORARY_OFFSET SET	0
      6  3200				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3200				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3230		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3248					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
      1  3248
      2  3248				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3248				  -.EARLY_LOCATION SET	*
      4  3248				  -	      ALIGN	256
      5  3248				  -	      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3248					      ENDIF
      0  3248					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  3248				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3248				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3248				   BLACK_ROOK_on_BLACK_SQUARE_0
      4  3248				   TEMPORARY_VAR SET	Overlay
      5  3248				   TEMPORARY_OFFSET SET	0
      6  3248				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3248				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      3  3248		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  3260		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3290					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
      1  3290
      2  3290				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3290				  -.EARLY_LOCATION SET	*
      4  3290				  -	      ALIGN	256
      5  3290				  -	      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3290					      ENDIF
      0  3290					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  3290				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3290				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3290				   BLACK_ROOK_on_BLACK_SQUARE_1
      4  3290				   TEMPORARY_VAR SET	Overlay
      5  3290				   TEMPORARY_OFFSET SET	0
      6  3290				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3290				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      3  3290		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  32a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  32d8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
      1  32d8
      2  32d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  32d8				   .EARLY_LOCATION SET	*
      4  3300		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_ROOK_on_BLACK_SQUARE_2 wasted 40 bytes
      5  3300					      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3300					      ENDIF
      0  3300					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  3300				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3300				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3300				   BLACK_ROOK_on_BLACK_SQUARE_2
      4  3300				   TEMPORARY_VAR SET	Overlay
      5  3300				   TEMPORARY_OFFSET SET	0
      6  3300				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3300				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  3330		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3348					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
      1  3348
      2  3348				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3348				  -.EARLY_LOCATION SET	*
      4  3348				  -	      ALIGN	256
      5  3348				  -	      ECHO	"Page break for", "BLACK_ROOK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3348					      ENDIF
      0  3348					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  3348				   SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3348				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3348				   BLACK_ROOK_on_BLACK_SQUARE_3
      4  3348				   TEMPORARY_VAR SET	Overlay
      5  3348				   TEMPORARY_OFFSET SET	0
      6  3348				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3348				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3378		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3390					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
      1  3390
      2  3390				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3390				  -.EARLY_LOCATION SET	*
      4  3390				  -	      ALIGN	256
      5  3390				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3390					      ENDIF
      0  3390					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  3390				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3390				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3390				   BLACK_QUEEN_on_BLACK_SQUARE_0
      4  3390				   TEMPORARY_VAR SET	Overlay
      5  3390				   TEMPORARY_OFFSET SET	0
      6  3390				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3390				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      3  3390		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$50,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     50  33d8
      0  33d8					      END_BANK
      1  33d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  33d8				  -	      CHECK_RAM_BANK_SIZE
      3  33d8					      ELSE
      0  33d8					      CHECK_BANK_SIZE
      1  33d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 13 GFX2 size = $3d8 free = 39
      2  33d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  33d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  33d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  33d8				  -	      ERR
      6  33d8					      ENDIF
      5  33d8					      ENDIF
     52  33d8
     53  33d8
     54  33d8							;---------------------------------------------------------------------------------------------------
     55  33d8
      0  33d8					      ROMBANK	GFX3
      1  37d8 ????				      SEG	ROM_GFX3
      2  3400					      ORG	_ORIGIN
      3  3400					      RORG	_BANK_ADDRESS_ORIGIN
      4  3400				   _BANK_START SET	*
      5  3400				   GFX3_START SET	*
      6  3400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3400				   ROMBANK_GFX3 SET	_BANK_SLOT + _CURRENT_BANK
      8  3400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3400				   _LAST_BANK SETSTR	GFX3
     10  3400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     57  3400
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3400					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  3400					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
      1  3400
      2  3400				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3400				  -.EARLY_LOCATION SET	*
      4  3400				  -	      ALIGN	256
      5  3400				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3400					      ENDIF
      0  3400					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  3400				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3400				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3400				   BLACK_QUEEN_on_BLACK_SQUARE_1
      4  3400				   TEMPORARY_VAR SET	Overlay
      5  3400				   TEMPORARY_OFFSET SET	0
      6  3400				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3400				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      3  3400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3418		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$54,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3448					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
      1  3448
      2  3448				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3448				  -.EARLY_LOCATION SET	*
      4  3448				  -	      ALIGN	256
      5  3448				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3448					      ENDIF
      0  3448					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  3448				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3448				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3448				   BLACK_QUEEN_on_BLACK_SQUARE_2
      4  3448				   TEMPORARY_VAR SET	Overlay
      5  3448				   TEMPORARY_OFFSET SET	0
      6  3448				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3448				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$02,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3478		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$05,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3490					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
      1  3490
      2  3490				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3490				  -.EARLY_LOCATION SET	*
      4  3490				  -	      ALIGN	256
      5  3490				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3490					      ENDIF
      0  3490					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  3490				   SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3490				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3490				   BLACK_QUEEN_on_BLACK_SQUARE_3
      4  3490				   TEMPORARY_VAR SET	Overlay
      5  3490				   TEMPORARY_OFFSET SET	0
      6  3490				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3490				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  34c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$a8,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  34d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
      1  34d8
      2  34d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  34d8				   .EARLY_LOCATION SET	*
      4  3500		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KING_on_BLACK_SQUARE_0 wasted 40 bytes
      5  3500					      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3500					      ENDIF
      0  3500					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  3500				   SLOT_BLACK_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3500				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3500				   BLACK_KING_on_BLACK_SQUARE_0
      4  3500				   TEMPORARY_VAR SET	Overlay
      5  3500				   TEMPORARY_OFFSET SET	0
      6  3500				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3500				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      3  3500		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3548					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
      1  3548
      2  3548				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3548				  -.EARLY_LOCATION SET	*
      4  3548				  -	      ALIGN	256
      5  3548				  -	      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3548					      ENDIF
      0  3548					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  3548				   SLOT_BLACK_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3548				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3548				   BLACK_KING_on_BLACK_SQUARE_1
      4  3548				   TEMPORARY_VAR SET	Overlay
      5  3548				   TEMPORARY_OFFSET SET	0
      6  3548				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3548				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      3  3548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3560		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3590					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
      1  3590
      2  3590				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3590				  -.EARLY_LOCATION SET	*
      4  3590				  -	      ALIGN	256
      5  3590				  -	      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3590					      ENDIF
      0  3590					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  3590				   SLOT_BLACK_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3590				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3590				   BLACK_KING_on_BLACK_SQUARE_2
      4  3590				   TEMPORARY_VAR SET	Overlay
      5  3590				   TEMPORARY_OFFSET SET	0
      6  3590				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3590				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  35c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  35d8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
      1  35d8
      2  35d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  35d8				   .EARLY_LOCATION SET	*
      4  3600		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KING_on_BLACK_SQUARE_3 wasted 40 bytes
      5  3600					      ECHO	"Page break for", "BLACK_KING_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3600					      ENDIF
      0  3600					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  3600				   SLOT_BLACK_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3600				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3600				   BLACK_KING_on_BLACK_SQUARE_3
      4  3600				   TEMPORARY_VAR SET	Overlay
      5  3600				   TEMPORARY_OFFSET SET	0
      6  3600				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3600				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3630		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3648					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
      1  3648
      2  3648				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3648				  -.EARLY_LOCATION SET	*
      4  3648				  -	      ALIGN	256
      5  3648				  -	      ECHO	"Page break for", "WHITE_MARKER_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3648					      ENDIF
      0  3648					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  3648				   SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3648				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	SLOT_WHITE_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3648				   WHITE_MARKER_on_WHITE_SQUARE_3
      4  3648				   TEMPORARY_VAR SET	Overlay
      5  3648				   TEMPORARY_OFFSET SET	0
      6  3648				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3648				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$20,$70,$70,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3690					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
      1  3690
      2  3690				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3690				  -.EARLY_LOCATION SET	*
      4  3690				  -	      ALIGN	256
      5  3690				  -	      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3690					      ENDIF
      0  3690					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  3690				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3690				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3690				   BLACK_MARKER_on_BLACK_SQUARE_0
      4  3690				   TEMPORARY_VAR SET	Overlay
      5  3690				   TEMPORARY_OFFSET SET	0
      6  3690				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3690				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      3  3690		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  36a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  36d8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
      1  36d8
      2  36d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  36d8				   .EARLY_LOCATION SET	*
      4  3700		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_MARKER_on_BLACK_SQUARE_1 wasted 40 bytes
      5  3700					      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3700					      ENDIF
      0  3700					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  3700				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3700				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3700				   BLACK_MARKER_on_BLACK_SQUARE_1
      4  3700				   TEMPORARY_VAR SET	Overlay
      5  3700				   TEMPORARY_OFFSET SET	0
      6  3700				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3700				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  3748					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
      1  3748
      2  3748				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3748				  -.EARLY_LOCATION SET	*
      4  3748				  -	      ALIGN	256
      5  3748				  -	      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3748					      ENDIF
      0  3748					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  3748				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3748				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3748				   BLACK_MARKER_on_BLACK_SQUARE_2
      4  3748				   TEMPORARY_VAR SET	Overlay
      5  3748				   TEMPORARY_OFFSET SET	0
      6  3748				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3748				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3778		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3790					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
      1  3790
      2  3790				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3790				  -.EARLY_LOCATION SET	*
      4  3790				  -	      ALIGN	256
      5  3790				  -	      ECHO	"Page break for", "BLACK_MARKER_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3790					      ENDIF
      0  3790					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  3790				   SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3790				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	SLOT_BLACK_MARKER_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3790				   BLACK_MARKER_on_BLACK_SQUARE_3
      4  3790				   TEMPORARY_VAR SET	Overlay
      5  3790				   TEMPORARY_OFFSET SET	0
      6  3790				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3790				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     70  37d8
      0  37d8					      END_BANK
      1  37d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  37d8				  -	      CHECK_RAM_BANK_SIZE
      3  37d8					      ELSE
      0  37d8					      CHECK_BANK_SIZE
      1  37d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 14 GFX3 size = $3d8 free = 39
      2  37d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  37d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      5  37d8					      ENDIF
     72  37d8
     73  37d8
     74  37d8							;---------------------------------------------------------------------------------------------------
     75  37d8
      0  37d8					      ROMBANK	GFX4
      1  3bd8 ????				      SEG	ROM_GFX4
      2  3800					      ORG	_ORIGIN
      3  3800					      RORG	_BANK_ADDRESS_ORIGIN
      4  3800				   _BANK_START SET	*
      5  3800				   GFX4_START SET	*
      6  3800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3800				   ROMBANK_GFX4 SET	_BANK_SLOT + _CURRENT_BANK
      8  3800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3800				   _LAST_BANK SETSTR	GFX4
     10  3800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     77  3800
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3800					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  3800					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
      1  3800
      2  3800				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3800				  -.EARLY_LOCATION SET	*
      4  3800				  -	      ALIGN	256
      5  3800				  -	      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3800					      ENDIF
      0  3800					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  3800				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3800				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3800				   BLACK_MARKER_on_WHITE_SQUARE_0
      4  3800				   TEMPORARY_VAR SET	Overlay
      5  3800				   TEMPORARY_OFFSET SET	0
      6  3800				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3800				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      3  3800		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  3818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3848					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  3848					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
      1  3848
      2  3848				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3848				  -.EARLY_LOCATION SET	*
      4  3848				  -	      ALIGN	256
      5  3848				  -	      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3848					      ENDIF
      0  3848					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  3848				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3848				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3848				   BLACK_MARKER_on_WHITE_SQUARE_1
      4  3848				   TEMPORARY_VAR SET	Overlay
      5  3848				   TEMPORARY_OFFSET SET	0
      6  3848				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3848				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      3  3848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3860		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  3878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3890					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  3890					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
      1  3890
      2  3890				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3890				  -.EARLY_LOCATION SET	*
      4  3890				  -	      ALIGN	256
      5  3890				  -	      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3890					      ENDIF
      0  3890					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  3890				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3890				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3890				   BLACK_MARKER_on_WHITE_SQUARE_2
      4  3890				   TEMPORARY_VAR SET	Overlay
      5  3890				   TEMPORARY_OFFSET SET	0
      6  3890				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3890				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      3  3890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  38a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  38c0		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  38d8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  38d8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
      1  38d8
      2  38d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  38d8				   .EARLY_LOCATION SET	*
      4  3900		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_MARKER_on_WHITE_SQUARE_3 wasted 40 bytes
      5  3900					      ECHO	"Page break for", "BLACK_MARKER_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3900					      ENDIF
      0  3900					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  3900				   SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3900				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	SLOT_BLACK_MARKER_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3900				   BLACK_MARKER_on_WHITE_SQUARE_3
      4  3900				   TEMPORARY_VAR SET	Overlay
      5  3900				   TEMPORARY_OFFSET SET	0
      6  3900				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3900				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      3  3900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3930		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  3948					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  3948					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
      1  3948
      2  3948				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3948				  -.EARLY_LOCATION SET	*
      4  3948				  -	      ALIGN	256
      5  3948				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3948					      ENDIF
      0  3948					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  3948				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  3948				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  3948				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      4  3948				   TEMPORARY_VAR SET	Overlay
      5  3948				   TEMPORARY_OFFSET SET	0
      6  3948				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3948				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  3948		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  3960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  3990					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  3990					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
      1  3990
      2  3990				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3990				  -.EARLY_LOCATION SET	*
      4  3990				  -	      ALIGN	256
      5  3990				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3990					      ENDIF
      0  3990					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  3990				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  3990				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  3990				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      4  3990				   TEMPORARY_VAR SET	Overlay
      5  3990				   TEMPORARY_OFFSET SET	0
      6  3990				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3990				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  3990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  39a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  39c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  39d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  39d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
      1  39d8
      2  39d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  39d8				   .EARLY_LOCATION SET	*
      4  3a00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PROMOTE_on_BLACK_SQUARE_2 wasted 40 bytes
      5  3a00					      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3a00					      ENDIF
      0  3a00					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  3a00				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  3a00				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  3a00				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      4  3a00				   TEMPORARY_VAR SET	Overlay
      5  3a00				   TEMPORARY_OFFSET SET	0
      6  3a00				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3a00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  3a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  3a30		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  3a48					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  3a48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
      1  3a48
      2  3a48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3a48				  -.EARLY_LOCATION SET	*
      4  3a48				  -	      ALIGN	256
      5  3a48				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3a48					      ENDIF
      0  3a48					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  3a48				   SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  3a48				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  3a48				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      4  3a48				   TEMPORARY_VAR SET	Overlay
      5  3a48				   TEMPORARY_OFFSET SET	0
      6  3a48				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3a48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  3a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3a78		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3a90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  3a90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
      1  3a90
      2  3a90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3a90				  -.EARLY_LOCATION SET	*
      4  3a90				  -	      ALIGN	256
      5  3a90				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3a90					      ENDIF
      0  3a90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  3a90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3a90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3a90				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      4  3a90				   TEMPORARY_VAR SET	Overlay
      5  3a90				   TEMPORARY_OFFSET SET	0
      6  3a90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3a90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  3a90		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ad8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  3ad8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
      1  3ad8
      2  3ad8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3ad8				   .EARLY_LOCATION SET	*
      4  3b00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PROMOTE_on_WHITE_SQUARE_1 wasted 40 bytes
      5  3b00					      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3b00					      ENDIF
      0  3b00					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  3b00				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3b00				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3b00				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      4  3b00				   TEMPORARY_VAR SET	Overlay
      5  3b00				   TEMPORARY_OFFSET SET	0
      6  3b00				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3b00				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  3b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b18		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3b48					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  3b48					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
      1  3b48
      2  3b48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3b48				  -.EARLY_LOCATION SET	*
      4  3b48				  -	      ALIGN	256
      5  3b48				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3b48					      ENDIF
      0  3b48					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  3b48				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3b48				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3b48				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      4  3b48				   TEMPORARY_VAR SET	Overlay
      5  3b48				   TEMPORARY_OFFSET SET	0
      6  3b48				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3b48				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  3b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3b78		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3b90					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  3b90					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
      1  3b90
      2  3b90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3b90				  -.EARLY_LOCATION SET	*
      4  3b90				  -	      ALIGN	256
      5  3b90				  -	      ECHO	"Page break for", "WHITE_PROMOTE_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3b90					      ENDIF
      0  3b90					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  3b90				   SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3b90				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PROMOTE_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3b90				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      4  3b90				   TEMPORARY_VAR SET	Overlay
      5  3b90				   TEMPORARY_OFFSET SET	0
      6  3b90				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3b90				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  3b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3bc0		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
     90  3bd8
      0  3bd8					      END_BANK
      1  3bd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  3bd8				  -	      CHECK_RAM_BANK_SIZE
      3  3bd8					      ELSE
      0  3bd8					      CHECK_BANK_SIZE
      1  3bd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 15 GFX4 size = $3d8 free = 39
      2  3bd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  3bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3bd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  3bd8				  -	      ERR
      6  3bd8					      ENDIF
      5  3bd8					      ENDIF
     92  3bd8
     93  3bd8
     94  3bd8							;---------------------------------------------------------------------------------------------------
     95  3bd8
      0  3bd8					      ROMBANK	PIECES_0
      1  3fd8 ????				      SEG	ROM_PIECES_0
      2  3c00					      ORG	_ORIGIN
      3  3c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  3c00				   _BANK_START SET	*
      5  3c00				   PIECES_0_START SET	*
      6  3c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  3c00				   ROMBANK_PIECES_0 SET	_BANK_SLOT + _CURRENT_BANK
      8  3c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  3c00				   _LAST_BANK SETSTR	PIECES_0
     10  3c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     97  3c00
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3c00					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  3c00					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
      1  3c00
      2  3c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3c00				  -.EARLY_LOCATION SET	*
      4  3c00				  -	      ALIGN	256
      5  3c00				  -	      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3c00					      ENDIF
      0  3c00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  3c00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3c00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3c00				   WHITE_BLANK_on_WHITE_SQUARE_0
      4  3c00				   TEMPORARY_VAR SET	Overlay
      5  3c00				   TEMPORARY_OFFSET SET	0
      6  3c00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3c00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      3  3c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  3c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  3c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3c48					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  3c48					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
      1  3c48
      2  3c48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3c48				  -.EARLY_LOCATION SET	*
      4  3c48				  -	      ALIGN	256
      5  3c48				  -	      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3c48					      ENDIF
      0  3c48					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  3c48				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3c48				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3c48				   WHITE_BLANK_on_WHITE_SQUARE_1
      4  3c48				   TEMPORARY_VAR SET	Overlay
      5  3c48				   TEMPORARY_OFFSET SET	0
      6  3c48				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3c48				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      3  3c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  3c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3c90					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  3c90					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
      1  3c90
      2  3c90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3c90				  -.EARLY_LOCATION SET	*
      4  3c90				  -	      ALIGN	256
      5  3c90				  -	      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3c90					      ENDIF
      0  3c90					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  3c90				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3c90				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3c90				   WHITE_BLANK_on_WHITE_SQUARE_2
      4  3c90				   TEMPORARY_VAR SET	Overlay
      5  3c90				   TEMPORARY_OFFSET SET	0
      6  3c90				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3c90				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      3  3c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ca8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  3cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3cd8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  3cd8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
      1  3cd8
      2  3cd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3cd8				   .EARLY_LOCATION SET	*
      4  3d00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BLANK_on_WHITE_SQUARE_3 wasted 40 bytes
      5  3d00					      ECHO	"Page break for", "WHITE_BLANK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3d00					      ENDIF
      0  3d00					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  3d00				   SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3d00				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3d00				   WHITE_BLANK_on_WHITE_SQUARE_3
      4  3d00				   TEMPORARY_VAR SET	Overlay
      5  3d00				   TEMPORARY_OFFSET SET	0
      6  3d00				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3d00				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      3  3d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3d48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  3d48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
      1  3d48
      2  3d48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3d48				  -.EARLY_LOCATION SET	*
      4  3d48				  -	      ALIGN	256
      5  3d48				  -	      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3d48					      ENDIF
      0  3d48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  3d48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3d48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3d48				   WHITE_PAWN_on_WHITE_SQUARE_0
      4  3d48				   TEMPORARY_VAR SET	Overlay
      5  3d48				   TEMPORARY_OFFSET SET	0
      6  3d48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3d48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      3  3d48		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3d90					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  3d90					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
      1  3d90
      2  3d90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3d90				  -.EARLY_LOCATION SET	*
      4  3d90				  -	      ALIGN	256
      5  3d90				  -	      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3d90					      ENDIF
      0  3d90					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  3d90				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3d90				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3d90				   WHITE_PAWN_on_WHITE_SQUARE_1
      4  3d90				   TEMPORARY_VAR SET	Overlay
      5  3d90				   TEMPORARY_OFFSET SET	0
      6  3d90				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3d90				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      3  3d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3da8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3dd8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  3dd8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
      1  3dd8
      2  3dd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3dd8				   .EARLY_LOCATION SET	*
      4  3e00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PAWN_on_WHITE_SQUARE_2 wasted 40 bytes
      5  3e00					      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3e00					      ENDIF
      0  3e00					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  3e00				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3e00				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3e00				   WHITE_PAWN_on_WHITE_SQUARE_2
      4  3e00				   TEMPORARY_VAR SET	Overlay
      5  3e00				   TEMPORARY_OFFSET SET	0
      6  3e00				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3e00				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e30		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3e48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
      1  3e48
      2  3e48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3e48				  -.EARLY_LOCATION SET	*
      4  3e48				  -	      ALIGN	256
      5  3e48				  -	      ECHO	"Page break for", "WHITE_PAWN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3e48					      ENDIF
      0  3e48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  3e48				   SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3e48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3e48				   WHITE_PAWN_on_WHITE_SQUARE_3
      4  3e48				   TEMPORARY_VAR SET	Overlay
      5  3e48				   TEMPORARY_OFFSET SET	0
      6  3e48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3e48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  3e90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
      1  3e90
      2  3e90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3e90				  -.EARLY_LOCATION SET	*
      4  3e90				  -	      ALIGN	256
      5  3e90				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3e90					      ENDIF
      0  3e90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  3e90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  3e90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  3e90				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      4  3e90				   TEMPORARY_VAR SET	Overlay
      5  3e90				   TEMPORARY_OFFSET SET	0
      6  3e90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  3e90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  3e90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3ea8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  3ed8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
      1  3ed8
      2  3ed8					      IF	(>( * + 72 -1 )) > ( >* )
      3  3ed8				   .EARLY_LOCATION SET	*
      4  3f00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KNIGHT_on_WHITE_SQUARE_1 wasted 40 bytes
      5  3f00					      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3f00					      ENDIF
      0  3f00					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  3f00				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  3f00				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  3f00				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      4  3f00				   TEMPORARY_VAR SET	Overlay
      5  3f00				   TEMPORARY_OFFSET SET	0
      6  3f00				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  3f00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  3f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  3f48					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
      1  3f48
      2  3f48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3f48				  -.EARLY_LOCATION SET	*
      4  3f48				  -	      ALIGN	256
      5  3f48				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3f48					      ENDIF
      0  3f48					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  3f48				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  3f48				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  3f48				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      4  3f48				   TEMPORARY_VAR SET	Overlay
      5  3f48				   TEMPORARY_OFFSET SET	0
      6  3f48				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  3f48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  3f90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
      1  3f90
      2  3f90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  3f90				  -.EARLY_LOCATION SET	*
      4  3f90				  -	      ALIGN	256
      5  3f90				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  3f90					      ENDIF
      0  3f90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  3f90				   SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  3f90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  3f90				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      4  3f90				   TEMPORARY_VAR SET	Overlay
      5  3f90				   TEMPORARY_OFFSET SET	0
      6  3f90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  3f90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    110  3fd8
      0  3fd8					      END_BANK
      1  3fd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  3fd8				  -	      CHECK_RAM_BANK_SIZE
      3  3fd8					      ELSE
      0  3fd8					      CHECK_BANK_SIZE
      1  3fd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 16 PIECES_0 size = $3d8 free = 39
      2  3fd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  3fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      5  3fd8					      ENDIF
    112  3fd8
    113  3fd8
    114  3fd8							;---------------------------------------------------------------------------------------------------
    115  3fd8
      0  3fd8					      ROMBANK	PIECES_1
      1  43d8 ????				      SEG	ROM_PIECES_1
      2  4000					      ORG	_ORIGIN
      3  4000					      RORG	_BANK_ADDRESS_ORIGIN
      4  4000				   _BANK_START SET	*
      5  4000				   PIECES_1_START SET	*
      6  4000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4000				   ROMBANK_PIECES_1 SET	_BANK_SLOT + _CURRENT_BANK
      8  4000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4000				   _LAST_BANK SETSTR	PIECES_1
     10  4000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    117  4000
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4000					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  4000					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
      1  4000
      2  4000				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4000				  -.EARLY_LOCATION SET	*
      4  4000				  -	      ALIGN	256
      5  4000				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4000					      ENDIF
      0  4000					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  4000				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4000				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4000				   WHITE_BISHOP_on_WHITE_SQUARE_0
      4  4000				   TEMPORARY_VAR SET	Overlay
      5  4000				   TEMPORARY_OFFSET SET	0
      6  4000				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4000				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      3  4000		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  4018		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4048					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  4048					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
      1  4048
      2  4048				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4048				  -.EARLY_LOCATION SET	*
      4  4048				  -	      ALIGN	256
      5  4048				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4048					      ENDIF
      0  4048					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  4048				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4048				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4048				   WHITE_BISHOP_on_WHITE_SQUARE_1
      4  4048				   TEMPORARY_VAR SET	Overlay
      5  4048				   TEMPORARY_OFFSET SET	0
      6  4048				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4048				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      3  4048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4060		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  4078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4090					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  4090					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
      1  4090
      2  4090				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4090				  -.EARLY_LOCATION SET	*
      4  4090				  -	      ALIGN	256
      5  4090				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4090					      ENDIF
      0  4090					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  4090				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4090				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4090				   WHITE_BISHOP_on_WHITE_SQUARE_2
      4  4090				   TEMPORARY_VAR SET	Overlay
      5  4090				   TEMPORARY_OFFSET SET	0
      6  4090				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4090				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      3  4090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  40a8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  40c0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  40d8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  40d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
      1  40d8
      2  40d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  40d8				   .EARLY_LOCATION SET	*
      4  4100		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BISHOP_on_WHITE_SQUARE_3 wasted 40 bytes
      5  4100					      ECHO	"Page break for", "WHITE_BISHOP_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4100					      ENDIF
      0  4100					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  4100				   SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4100				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4100				   WHITE_BISHOP_on_WHITE_SQUARE_3
      4  4100				   TEMPORARY_VAR SET	Overlay
      5  4100				   TEMPORARY_OFFSET SET	0
      6  4100				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4100				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      3  4100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4130		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4148					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  4148					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
      1  4148
      2  4148				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4148				  -.EARLY_LOCATION SET	*
      4  4148				  -	      ALIGN	256
      5  4148				  -	      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4148					      ENDIF
      0  4148					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  4148				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4148				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4148				   WHITE_ROOK_on_WHITE_SQUARE_0
      4  4148				   TEMPORARY_VAR SET	Overlay
      5  4148				   TEMPORARY_OFFSET SET	0
      6  4148				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4148				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      3  4148		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4160		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4190					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  4190					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
      1  4190
      2  4190				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4190				  -.EARLY_LOCATION SET	*
      4  4190				  -	      ALIGN	256
      5  4190				  -	      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4190					      ENDIF
      0  4190					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  4190				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4190				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4190				   WHITE_ROOK_on_WHITE_SQUARE_1
      4  4190				   TEMPORARY_VAR SET	Overlay
      5  4190				   TEMPORARY_OFFSET SET	0
      6  4190				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4190				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      3  4190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  41a8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  41c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  41d8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  41d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
      1  41d8
      2  41d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  41d8				   .EARLY_LOCATION SET	*
      4  4200		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_ROOK_on_WHITE_SQUARE_2 wasted 40 bytes
      5  4200					      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4200					      ENDIF
      0  4200					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  4200				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4200				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4200				   WHITE_ROOK_on_WHITE_SQUARE_2
      4  4200				   TEMPORARY_VAR SET	Overlay
      5  4200				   TEMPORARY_OFFSET SET	0
      6  4200				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4200				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      3  4200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4218		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4230		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4248					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  4248					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
      1  4248
      2  4248				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4248				  -.EARLY_LOCATION SET	*
      4  4248				  -	      ALIGN	256
      5  4248				  -	      ECHO	"Page break for", "WHITE_ROOK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4248					      ENDIF
      0  4248					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  4248				   SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4248				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	SLOT_WHITE_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4248				   WHITE_ROOK_on_WHITE_SQUARE_3
      4  4248				   TEMPORARY_VAR SET	Overlay
      5  4248				   TEMPORARY_OFFSET SET	0
      6  4248				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4248				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      3  4248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4278		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4290					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  4290					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
      1  4290
      2  4290				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4290				  -.EARLY_LOCATION SET	*
      4  4290				  -	      ALIGN	256
      5  4290				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4290					      ENDIF
      0  4290					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  4290				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4290				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4290				   WHITE_QUEEN_on_WHITE_SQUARE_0
      4  4290				   TEMPORARY_VAR SET	Overlay
      5  4290				   TEMPORARY_OFFSET SET	0
      6  4290				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4290				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      3  4290		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$50,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  42a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  42c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  42d8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  42d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
      1  42d8
      2  42d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  42d8				   .EARLY_LOCATION SET	*
      4  4300		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_QUEEN_on_WHITE_SQUARE_1 wasted 40 bytes
      5  4300					      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4300					      ENDIF
      0  4300					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  4300				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4300				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4300				   WHITE_QUEEN_on_WHITE_SQUARE_1
      4  4300				   TEMPORARY_VAR SET	Overlay
      5  4300				   TEMPORARY_OFFSET SET	0
      6  4300				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4300				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      3  4300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4318		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$54,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4348					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  4348					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
      1  4348
      2  4348				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4348				  -.EARLY_LOCATION SET	*
      4  4348				  -	      ALIGN	256
      5  4348				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4348					      ENDIF
      0  4348					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  4348				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4348				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4348				   WHITE_QUEEN_on_WHITE_SQUARE_2
      4  4348				   TEMPORARY_VAR SET	Overlay
      5  4348				   TEMPORARY_OFFSET SET	0
      6  4348				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4348				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      3  4348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4360		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$02,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4378		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$05,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4390					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  4390					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
      1  4390
      2  4390				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4390				  -.EARLY_LOCATION SET	*
      4  4390				  -	      ALIGN	256
      5  4390				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4390					      ENDIF
      0  4390					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  4390				   SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4390				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4390				   WHITE_QUEEN_on_WHITE_SQUARE_3
      4  4390				   TEMPORARY_VAR SET	Overlay
      5  4390				   TEMPORARY_OFFSET SET	0
      6  4390				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4390				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      3  4390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  43a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  43c0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$a8,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    130  43d8
      0  43d8					      END_BANK
      1  43d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  43d8				  -	      CHECK_RAM_BANK_SIZE
      3  43d8					      ELSE
      0  43d8					      CHECK_BANK_SIZE
      1  43d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 17 PIECES_1 size = $3d8 free = 39
      2  43d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  43d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  43d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  43d8				  -	      ERR
      6  43d8					      ENDIF
      5  43d8					      ENDIF
    132  43d8
    133  43d8
    134  43d8							;---------------------------------------------------------------------------------------------------
    135  43d8
      0  43d8					      ROMBANK	PIECES_2
      1  47d8 ????				      SEG	ROM_PIECES_2
      2  4400					      ORG	_ORIGIN
      3  4400					      RORG	_BANK_ADDRESS_ORIGIN
      4  4400				   _BANK_START SET	*
      5  4400				   PIECES_2_START SET	*
      6  4400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4400				   ROMBANK_PIECES_2 SET	_BANK_SLOT + _CURRENT_BANK
      8  4400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4400				   _LAST_BANK SETSTR	PIECES_2
     10  4400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    137  4400
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4400					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  4400					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
      1  4400
      2  4400				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4400				  -.EARLY_LOCATION SET	*
      4  4400				  -	      ALIGN	256
      5  4400				  -	      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4400					      ENDIF
      0  4400					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  4400				   SLOT_WHITE_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4400				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4400				   WHITE_KING_on_WHITE_SQUARE_0
      4  4400				   TEMPORARY_VAR SET	Overlay
      5  4400				   TEMPORARY_OFFSET SET	0
      6  4400				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4400				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      3  4400		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$00,$80,$40,$00,$00	;PF0
      4  4418		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4448					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  4448					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
      1  4448
      2  4448				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4448				  -.EARLY_LOCATION SET	*
      4  4448				  -	      ALIGN	256
      5  4448				  -	      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4448					      ENDIF
      0  4448					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  4448				   SLOT_WHITE_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4448				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4448				   WHITE_KING_on_WHITE_SQUARE_1
      4  4448				   TEMPORARY_VAR SET	Overlay
      5  4448				   TEMPORARY_OFFSET SET	0
      6  4448				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4448				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      3  4448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4460		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$00,$08,$10,$00,$00	;PF1
      5  4478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4490					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  4490					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
      1  4490
      2  4490				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4490				  -.EARLY_LOCATION SET	*
      4  4490				  -	      ALIGN	256
      5  4490				  -	      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4490					      ENDIF
      0  4490					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  4490				   SLOT_WHITE_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4490				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4490				   WHITE_KING_on_WHITE_SQUARE_2
      4  4490				   TEMPORARY_VAR SET	Overlay
      5  4490				   TEMPORARY_OFFSET SET	0
      6  4490				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4490				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      3  4490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  44a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  44c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$00,$02,$01,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  44d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  44d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
      1  44d8
      2  44d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  44d8				   .EARLY_LOCATION SET	*
      4  4500		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KING_on_WHITE_SQUARE_3 wasted 40 bytes
      5  4500					      ECHO	"Page break for", "WHITE_KING_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4500					      ENDIF
      0  4500					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  4500				   SLOT_WHITE_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4500				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	SLOT_WHITE_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4500				   WHITE_KING_on_WHITE_SQUARE_3
      4  4500				   TEMPORARY_VAR SET	Overlay
      5  4500				   TEMPORARY_OFFSET SET	0
      6  4500				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4500				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      3  4500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4530		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$00,$40,$20,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4548					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  4548					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
      1  4548
      2  4548				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4548				  -.EARLY_LOCATION SET	*
      4  4548				  -	      ALIGN	256
      5  4548				  -	      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4548					      ENDIF
      0  4548					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  4548				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4548				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4548				   WHITE_BLANK_on_BLACK_SQUARE_0
      4  4548				   TEMPORARY_VAR SET	Overlay
      5  4548				   TEMPORARY_OFFSET SET	0
      6  4548				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4548				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      3  4548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4590					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  4590					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
      1  4590
      2  4590				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4590				  -.EARLY_LOCATION SET	*
      4  4590				  -	      ALIGN	256
      5  4590				  -	      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4590					      ENDIF
      0  4590					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  4590				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4590				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4590				   WHITE_BLANK_on_BLACK_SQUARE_1
      4  4590				   TEMPORARY_VAR SET	Overlay
      5  4590				   TEMPORARY_OFFSET SET	0
      6  4590				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4590				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      3  4590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  45a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  45c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  45d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  45d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
      1  45d8
      2  45d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  45d8				   .EARLY_LOCATION SET	*
      4  4600		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BLANK_on_BLACK_SQUARE_2 wasted 40 bytes
      5  4600					      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4600					      ENDIF
      0  4600					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  4600				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4600				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4600				   WHITE_BLANK_on_BLACK_SQUARE_2
      4  4600				   TEMPORARY_VAR SET	Overlay
      5  4600				   TEMPORARY_OFFSET SET	0
      6  4600				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4600				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      3  4600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4648					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  4648					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
      1  4648
      2  4648				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4648				  -.EARLY_LOCATION SET	*
      4  4648				  -	      ALIGN	256
      5  4648				  -	      ECHO	"Page break for", "WHITE_BLANK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4648					      ENDIF
      0  4648					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  4648				   SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4648				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4648				   WHITE_BLANK_on_BLACK_SQUARE_3
      4  4648				   TEMPORARY_VAR SET	Overlay
      5  4648				   TEMPORARY_OFFSET SET	0
      6  4648				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4648				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      3  4648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4690					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  4690					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
      1  4690
      2  4690				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4690				  -.EARLY_LOCATION SET	*
      4  4690				  -	      ALIGN	256
      5  4690				  -	      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4690					      ENDIF
      0  4690					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  4690				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4690				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4690				   WHITE_PAWN_on_BLACK_SQUARE_0
      4  4690				   TEMPORARY_VAR SET	Overlay
      5  4690				   TEMPORARY_OFFSET SET	0
      6  4690				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4690				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      3  4690		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  46a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  46c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  46d8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  46d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
      1  46d8
      2  46d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  46d8				   .EARLY_LOCATION SET	*
      4  4700		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_PAWN_on_BLACK_SQUARE_1 wasted 40 bytes
      5  4700					      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4700					      ENDIF
      0  4700					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  4700				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4700				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4700				   WHITE_PAWN_on_BLACK_SQUARE_1
      4  4700				   TEMPORARY_VAR SET	Overlay
      5  4700				   TEMPORARY_OFFSET SET	0
      6  4700				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4700				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      3  4700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4718		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  4730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4748					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  4748					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
      1  4748
      2  4748				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4748				  -.EARLY_LOCATION SET	*
      4  4748				  -	      ALIGN	256
      5  4748				  -	      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4748					      ENDIF
      0  4748					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  4748				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4748				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4748				   WHITE_PAWN_on_BLACK_SQUARE_2
      4  4748				   TEMPORARY_VAR SET	Overlay
      5  4748				   TEMPORARY_OFFSET SET	0
      6  4748				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4748				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      3  4748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4760		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  4778		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4790					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  4790					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
      1  4790
      2  4790				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4790				  -.EARLY_LOCATION SET	*
      4  4790				  -	      ALIGN	256
      5  4790				  -	      ECHO	"Page break for", "WHITE_PAWN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4790					      ENDIF
      0  4790					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  4790				   SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4790				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4790				   WHITE_PAWN_on_BLACK_SQUARE_3
      4  4790				   TEMPORARY_VAR SET	Overlay
      5  4790				   TEMPORARY_OFFSET SET	0
      6  4790				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4790				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      3  4790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  47a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  47c0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    150  47d8
      0  47d8					      END_BANK
      1  47d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  47d8				  -	      CHECK_RAM_BANK_SIZE
      3  47d8					      ELSE
      0  47d8					      CHECK_BANK_SIZE
      1  47d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 18 PIECES_2 size = $3d8 free = 39
      2  47d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  47d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  47d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  47d8				  -	      ERR
      6  47d8					      ENDIF
      5  47d8					      ENDIF
    152  47d8
    153  47d8
    154  47d8							;---------------------------------------------------------------------------------------------------
    155  47d8
      0  47d8					      ROMBANK	PIECES_3
      1  4bd8 ????				      SEG	ROM_PIECES_3
      2  4800					      ORG	_ORIGIN
      3  4800					      RORG	_BANK_ADDRESS_ORIGIN
      4  4800				   _BANK_START SET	*
      5  4800				   PIECES_3_START SET	*
      6  4800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4800				   ROMBANK_PIECES_3 SET	_BANK_SLOT + _CURRENT_BANK
      8  4800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4800				   _LAST_BANK SETSTR	PIECES_3
     10  4800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    157  4800
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4800					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  4800					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
      1  4800
      2  4800				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4800				  -.EARLY_LOCATION SET	*
      4  4800				  -	      ALIGN	256
      5  4800				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4800					      ENDIF
      0  4800					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  4800				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4800				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4800				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      4  4800				   TEMPORARY_VAR SET	Overlay
      5  4800				   TEMPORARY_OFFSET SET	0
      6  4800				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4800				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  4800		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  4818		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  4830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4848					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  4848					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
      1  4848
      2  4848				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4848				  -.EARLY_LOCATION SET	*
      4  4848				  -	      ALIGN	256
      5  4848				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4848					      ENDIF
      0  4848					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  4848				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4848				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4848				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      4  4848				   TEMPORARY_VAR SET	Overlay
      5  4848				   TEMPORARY_OFFSET SET	0
      6  4848				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4848				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  4848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4860		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  4878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4890					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  4890					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
      1  4890
      2  4890				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4890				  -.EARLY_LOCATION SET	*
      4  4890				  -	      ALIGN	256
      5  4890				  -	      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4890					      ENDIF
      0  4890					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  4890				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4890				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4890				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      4  4890				   TEMPORARY_VAR SET	Overlay
      5  4890				   TEMPORARY_OFFSET SET	0
      6  4890				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4890				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  4890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  48a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  48c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  48d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  48d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
      1  48d8
      2  48d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  48d8				   .EARLY_LOCATION SET	*
      4  4900		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KNIGHT_on_BLACK_SQUARE_3 wasted 40 bytes
      5  4900					      ECHO	"Page break for", "WHITE_KNIGHT_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4900					      ENDIF
      0  4900					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  4900				   SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4900				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4900				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      4  4900				   TEMPORARY_VAR SET	Overlay
      5  4900				   TEMPORARY_OFFSET SET	0
      6  4900				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4900				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  4900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4930		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4948					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  4948					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
      1  4948
      2  4948				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4948				  -.EARLY_LOCATION SET	*
      4  4948				  -	      ALIGN	256
      5  4948				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4948					      ENDIF
      0  4948					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  4948				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4948				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4948				   WHITE_BISHOP_on_BLACK_SQUARE_0
      4  4948				   TEMPORARY_VAR SET	Overlay
      5  4948				   TEMPORARY_OFFSET SET	0
      6  4948				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4948				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      3  4948		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  4960		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  4978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4990					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  4990					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
      1  4990
      2  4990				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4990				  -.EARLY_LOCATION SET	*
      4  4990				  -	      ALIGN	256
      5  4990				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4990					      ENDIF
      0  4990					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  4990				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4990				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4990				   WHITE_BISHOP_on_BLACK_SQUARE_1
      4  4990				   TEMPORARY_VAR SET	Overlay
      5  4990				   TEMPORARY_OFFSET SET	0
      6  4990				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4990				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      3  4990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  49a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  49c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  49d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  49d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
      1  49d8
      2  49d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  49d8				   .EARLY_LOCATION SET	*
      4  4a00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_BISHOP_on_BLACK_SQUARE_2 wasted 40 bytes
      5  4a00					      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4a00					      ENDIF
      0  4a00					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  4a00				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4a00				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4a00				   WHITE_BISHOP_on_BLACK_SQUARE_2
      4  4a00				   TEMPORARY_VAR SET	Overlay
      5  4a00				   TEMPORARY_OFFSET SET	0
      6  4a00				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4a00				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      3  4a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a18		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  4a30		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4a48					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  4a48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
      1  4a48
      2  4a48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4a48				  -.EARLY_LOCATION SET	*
      4  4a48				  -	      ALIGN	256
      5  4a48				  -	      ECHO	"Page break for", "WHITE_BISHOP_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4a48					      ENDIF
      0  4a48					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  4a48				   SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4a48				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	SLOT_WHITE_BISHOP_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4a48				   WHITE_BISHOP_on_BLACK_SQUARE_3
      4  4a48				   TEMPORARY_VAR SET	Overlay
      5  4a48				   TEMPORARY_OFFSET SET	0
      6  4a48				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4a48				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      3  4a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4a78		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4a90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  4a90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
      1  4a90
      2  4a90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4a90				  -.EARLY_LOCATION SET	*
      4  4a90				  -	      ALIGN	256
      5  4a90				  -	      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4a90					      ENDIF
      0  4a90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  4a90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4a90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4a90				   WHITE_ROOK_on_BLACK_SQUARE_0
      4  4a90				   TEMPORARY_VAR SET	Overlay
      5  4a90				   TEMPORARY_OFFSET SET	0
      6  4a90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4a90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      3  4a90		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  4aa8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  4ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ad8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  4ad8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
      1  4ad8
      2  4ad8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4ad8				   .EARLY_LOCATION SET	*
      4  4b00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_ROOK_on_BLACK_SQUARE_1 wasted 40 bytes
      5  4b00					      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4b00					      ENDIF
      0  4b00					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  4b00				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4b00				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4b00				   WHITE_ROOK_on_BLACK_SQUARE_1
      4  4b00				   TEMPORARY_VAR SET	Overlay
      5  4b00				   TEMPORARY_OFFSET SET	0
      6  4b00				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4b00				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      3  4b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b18		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  4b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4b48					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  4b48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
      1  4b48
      2  4b48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4b48				  -.EARLY_LOCATION SET	*
      4  4b48				  -	      ALIGN	256
      5  4b48				  -	      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4b48					      ENDIF
      0  4b48					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  4b48				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4b48				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4b48				   WHITE_ROOK_on_BLACK_SQUARE_2
      4  4b48				   TEMPORARY_VAR SET	Overlay
      5  4b48				   TEMPORARY_OFFSET SET	0
      6  4b48				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4b48				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      3  4b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4b60		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  4b78		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4b90					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  4b90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
      1  4b90
      2  4b90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4b90				  -.EARLY_LOCATION SET	*
      4  4b90				  -	      ALIGN	256
      5  4b90				  -	      ECHO	"Page break for", "WHITE_ROOK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4b90					      ENDIF
      0  4b90					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  4b90				   SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4b90				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	SLOT_WHITE_ROOK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4b90				   WHITE_ROOK_on_BLACK_SQUARE_3
      4  4b90				   TEMPORARY_VAR SET	Overlay
      5  4b90				   TEMPORARY_OFFSET SET	0
      6  4b90				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4b90				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      3  4b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4bc0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    170  4bd8
      0  4bd8					      END_BANK
      1  4bd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  4bd8				  -	      CHECK_RAM_BANK_SIZE
      3  4bd8					      ELSE
      0  4bd8					      CHECK_BANK_SIZE
      1  4bd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 19 PIECES_3 size = $3d8 free = 39
      2  4bd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  4bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4bd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  4bd8				  -	      ERR
      6  4bd8					      ENDIF
      5  4bd8					      ENDIF
    172  4bd8
    173  4bd8
    174  4bd8							;---------------------------------------------------------------------------------------------------
    175  4bd8
      0  4bd8					      ROMBANK	PIECE_4
      1  4fd8 ????				      SEG	ROM_PIECE_4
      2  4c00					      ORG	_ORIGIN
      3  4c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  4c00				   _BANK_START SET	*
      5  4c00				   PIECE_4_START SET	*
      6  4c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  4c00				   ROMBANK_PIECE_4 SET	_BANK_SLOT + _CURRENT_BANK
      8  4c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  4c00				   _LAST_BANK SETSTR	PIECE_4
     10  4c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    177  4c00
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4c00					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  4c00					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
      1  4c00
      2  4c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4c00				  -.EARLY_LOCATION SET	*
      4  4c00				  -	      ALIGN	256
      5  4c00				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4c00					      ENDIF
      0  4c00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  4c00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4c00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4c00				   WHITE_QUEEN_on_BLACK_SQUARE_0
      4  4c00				   TEMPORARY_VAR SET	Overlay
      5  4c00				   TEMPORARY_OFFSET SET	0
      6  4c00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4c00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      3  4c00		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$50,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$50,$50,$00	;PF0
      4  4c18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$80,$80,$00	;PF1
      5  4c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4c48					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  4c48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
      1  4c48
      2  4c48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4c48				  -.EARLY_LOCATION SET	*
      4  4c48				  -	      ALIGN	256
      5  4c48				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4c48					      ENDIF
      0  4c48					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  4c48				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4c48				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4c48				   WHITE_QUEEN_on_BLACK_SQUARE_1
      4  4c48				   TEMPORARY_VAR SET	Overlay
      5  4c48				   TEMPORARY_OFFSET SET	0
      6  4c48				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4c48				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      3  4c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4c60		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$54,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$54,$54,$00	;PF1
      5  4c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4c90					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  4c90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
      1  4c90
      2  4c90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4c90				  -.EARLY_LOCATION SET	*
      4  4c90				  -	      ALIGN	256
      5  4c90				  -	      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4c90					      ENDIF
      0  4c90					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  4c90				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4c90				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4c90				   WHITE_QUEEN_on_BLACK_SQUARE_2
      4  4c90				   TEMPORARY_VAR SET	Overlay
      5  4c90				   TEMPORARY_OFFSET SET	0
      6  4c90				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4c90				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      3  4c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4ca8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$02,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$02,$02,$00	;PF1
      5  4cc0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$05,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$05,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4cd8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  4cd8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
      1  4cd8
      2  4cd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4cd8				   .EARLY_LOCATION SET	*
      4  4d00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_QUEEN_on_BLACK_SQUARE_3 wasted 40 bytes
      5  4d00					      ECHO	"Page break for", "WHITE_QUEEN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4d00					      ENDIF
      0  4d00					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  4d00				   SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4d00				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	SLOT_WHITE_QUEEN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4d00				   WHITE_QUEEN_on_BLACK_SQUARE_3
      4  4d00				   TEMPORARY_VAR SET	Overlay
      5  4d00				   TEMPORARY_OFFSET SET	0
      6  4d00				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4d00				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      3  4d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4d30		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$a8,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$a8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  4d48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  4d48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
      1  4d48
      2  4d48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4d48				  -.EARLY_LOCATION SET	*
      4  4d48				  -	      ALIGN	256
      5  4d48				  -	      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4d48					      ENDIF
      0  4d48					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  4d48				   SLOT_WHITE_KING_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  4d48				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  4d48				   WHITE_KING_on_BLACK_SQUARE_0
      4  4d48				   TEMPORARY_VAR SET	Overlay
      5  4d48				   TEMPORARY_OFFSET SET	0
      6  4d48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4d48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      3  4d48		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$70,$00,$e0,$40	;PF0
      4  4d60		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  4d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  4d90					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  4d90					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
      1  4d90
      2  4d90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4d90				  -.EARLY_LOCATION SET	*
      4  4d90				  -	      ALIGN	256
      5  4d90				  -	      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4d90					      ENDIF
      0  4d90					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  4d90				   SLOT_WHITE_KING_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  4d90				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  4d90				   WHITE_KING_on_BLACK_SQUARE_1
      4  4d90				   TEMPORARY_VAR SET	Overlay
      5  4d90				   TEMPORARY_OFFSET SET	0
      6  4d90				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4d90				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      3  4d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4da8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$74,$00,$38,$10	;PF1
      5  4dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  4dd8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  4dd8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
      1  4dd8
      2  4dd8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4dd8				   .EARLY_LOCATION SET	*
      4  4e00		       00 00 00 00*	      ALIGN	256
 Page break for WHITE_KING_on_BLACK_SQUARE_2 wasted 40 bytes
      5  4e00					      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4e00					      ENDIF
      0  4e00					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  4e00				   SLOT_WHITE_KING_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  4e00				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  4e00				   WHITE_KING_on_BLACK_SQUARE_2
      4  4e00				   TEMPORARY_VAR SET	Overlay
      5  4e00				   TEMPORARY_OFFSET SET	0
      6  4e00				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4e00				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      3  4e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e18		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  4e30		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$05,$00,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  4e48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  4e48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
      1  4e48
      2  4e48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4e48				  -.EARLY_LOCATION SET	*
      4  4e48				  -	      ALIGN	256
      5  4e48				  -	      ECHO	"Page break for", "WHITE_KING_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4e48					      ENDIF
      0  4e48					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  4e48				   SLOT_WHITE_KING_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  4e48				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	SLOT_WHITE_KING_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  4e48				   WHITE_KING_on_BLACK_SQUARE_3
      4  4e48				   TEMPORARY_VAR SET	Overlay
      5  4e48				   TEMPORARY_OFFSET SET	0
      6  4e48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4e48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      3  4e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4e78		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$b8,$00,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  4e90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  4e90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
      1  4e90
      2  4e90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4e90				  -.EARLY_LOCATION SET	*
      4  4e90				  -	      ALIGN	256
      5  4e90				  -	      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4e90					      ENDIF
      0  4e90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  4e90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  4e90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  4e90				   BLACK_BLANK_on_WHITE_SQUARE_0
      4  4e90				   TEMPORARY_VAR SET	Overlay
      5  4e90				   TEMPORARY_OFFSET SET	0
      6  4e90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  4e90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      3  4e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  4ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  4ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  4ed8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  4ed8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
      1  4ed8
      2  4ed8					      IF	(>( * + 72 -1 )) > ( >* )
      3  4ed8				   .EARLY_LOCATION SET	*
      4  4f00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BLANK_on_WHITE_SQUARE_1 wasted 40 bytes
      5  4f00					      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4f00					      ENDIF
      0  4f00					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  4f00				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  4f00				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  4f00				   BLACK_BLANK_on_WHITE_SQUARE_1
      4  4f00				   TEMPORARY_VAR SET	Overlay
      5  4f00				   TEMPORARY_OFFSET SET	0
      6  4f00				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  4f00				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      3  4f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  4f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  4f48					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  4f48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
      1  4f48
      2  4f48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4f48				  -.EARLY_LOCATION SET	*
      4  4f48				  -	      ALIGN	256
      5  4f48				  -	      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4f48					      ENDIF
      0  4f48					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  4f48				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  4f48				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  4f48				   BLACK_BLANK_on_WHITE_SQUARE_2
      4  4f48				   TEMPORARY_VAR SET	Overlay
      5  4f48				   TEMPORARY_OFFSET SET	0
      6  4f48				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  4f48				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      3  4f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  4f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  4f90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  4f90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
      1  4f90
      2  4f90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  4f90				  -.EARLY_LOCATION SET	*
      4  4f90				  -	      ALIGN	256
      5  4f90				  -	      ECHO	"Page break for", "BLACK_BLANK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  4f90					      ENDIF
      0  4f90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  4f90				   SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  4f90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BLANK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  4f90				   BLACK_BLANK_on_WHITE_SQUARE_3
      4  4f90				   TEMPORARY_VAR SET	Overlay
      5  4f90				   TEMPORARY_OFFSET SET	0
      6  4f90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  4f90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      3  4f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  4fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  4fc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE @2 GRAPHICS DATA.asm
    190  4fd8
      0  4fd8					      END_BANK
      1  4fd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  4fd8				  -	      CHECK_RAM_BANK_SIZE
      3  4fd8					      ELSE
      0  4fd8					      CHECK_BANK_SIZE
      1  4fd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 20 PIECE_4 size = $3d8 free = 39
      2  4fd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  4fd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  4fd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  4fd8				  -	      ERR
      6  4fd8					      ENDIF
      5  4fd8					      ENDIF
    192  4fd8
    193  4fd8
    194  4fd8							;---------------------------------------------------------------------------------------------------
    195  4fd8
      0  4fd8					      ROMBANK	PIECE_5
      1  53d8 ????				      SEG	ROM_PIECE_5
      2  5000					      ORG	_ORIGIN
      3  5000					      RORG	_BANK_ADDRESS_ORIGIN
      4  5000				   _BANK_START SET	*
      5  5000				   PIECE_5_START SET	*
      6  5000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5000				   ROMBANK_PIECE_5 SET	_BANK_SLOT + _CURRENT_BANK
      8  5000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5000				   _LAST_BANK SETSTR	PIECE_5
     10  5000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    197  5000
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5000					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  5000					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
      1  5000
      2  5000				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5000				  -.EARLY_LOCATION SET	*
      4  5000				  -	      ALIGN	256
      5  5000				  -	      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5000					      ENDIF
      0  5000					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  5000				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5000				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5000				   BLACK_PAWN_on_WHITE_SQUARE_0
      4  5000				   TEMPORARY_VAR SET	Overlay
      5  5000				   TEMPORARY_OFFSET SET	0
      6  5000				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5000				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      3  5000		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  5018		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5048					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  5048					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
      1  5048
      2  5048				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5048				  -.EARLY_LOCATION SET	*
      4  5048				  -	      ALIGN	256
      5  5048				  -	      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5048					      ENDIF
      0  5048					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  5048				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5048				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5048				   BLACK_PAWN_on_WHITE_SQUARE_1
      4  5048				   TEMPORARY_VAR SET	Overlay
      5  5048				   TEMPORARY_OFFSET SET	0
      6  5048				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5048				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      3  5048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5060		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  5078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5090					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  5090					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
      1  5090
      2  5090				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5090				  -.EARLY_LOCATION SET	*
      4  5090				  -	      ALIGN	256
      5  5090				  -	      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5090					      ENDIF
      0  5090					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  5090				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5090				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5090				   BLACK_PAWN_on_WHITE_SQUARE_2
      4  5090				   TEMPORARY_VAR SET	Overlay
      5  5090				   TEMPORARY_OFFSET SET	0
      6  5090				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5090				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      3  5090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  50a8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  50c0		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  50d8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  50d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
      1  50d8
      2  50d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  50d8				   .EARLY_LOCATION SET	*
      4  5100		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PAWN_on_WHITE_SQUARE_3 wasted 40 bytes
      5  5100					      ECHO	"Page break for", "BLACK_PAWN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5100					      ENDIF
      0  5100					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  5100				   SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5100				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_PAWN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5100				   BLACK_PAWN_on_WHITE_SQUARE_3
      4  5100				   TEMPORARY_VAR SET	Overlay
      5  5100				   TEMPORARY_OFFSET SET	0
      6  5100				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5100				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      3  5100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5130		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5148					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  5148					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
      1  5148
      2  5148				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5148				  -.EARLY_LOCATION SET	*
      4  5148				  -	      ALIGN	256
      5  5148				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5148					      ENDIF
      0  5148					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  5148				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5148				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5148				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      4  5148				   TEMPORARY_VAR SET	Overlay
      5  5148				   TEMPORARY_OFFSET SET	0
      6  5148				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5148				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  5148		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  5160		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  5178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5190					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  5190					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
      1  5190
      2  5190				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5190				  -.EARLY_LOCATION SET	*
      4  5190				  -	      ALIGN	256
      5  5190				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5190					      ENDIF
      0  5190					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  5190				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5190				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5190				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      4  5190				   TEMPORARY_VAR SET	Overlay
      5  5190				   TEMPORARY_OFFSET SET	0
      6  5190				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5190				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  5190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  51a8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  51c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  51d8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  51d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
      1  51d8
      2  51d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  51d8				   .EARLY_LOCATION SET	*
      4  5200		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KNIGHT_on_WHITE_SQUARE_2 wasted 40 bytes
      5  5200					      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5200					      ENDIF
      0  5200					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  5200				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5200				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5200				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      4  5200				   TEMPORARY_VAR SET	Overlay
      5  5200				   TEMPORARY_OFFSET SET	0
      6  5200				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5200				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  5200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5218		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  5230		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5248					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  5248					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
      1  5248
      2  5248				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5248				  -.EARLY_LOCATION SET	*
      4  5248				  -	      ALIGN	256
      5  5248				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5248					      ENDIF
      0  5248					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  5248				   SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5248				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5248				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      4  5248				   TEMPORARY_VAR SET	Overlay
      5  5248				   TEMPORARY_OFFSET SET	0
      6  5248				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5248				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  5248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5278		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5290					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  5290					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
      1  5290
      2  5290				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5290				  -.EARLY_LOCATION SET	*
      4  5290				  -	      ALIGN	256
      5  5290				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5290					      ENDIF
      0  5290					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  5290				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5290				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5290				   BLACK_BISHOP_on_WHITE_SQUARE_0
      4  5290				   TEMPORARY_VAR SET	Overlay
      5  5290				   TEMPORARY_OFFSET SET	0
      6  5290				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5290				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      3  5290		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  52a8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  52c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  52d8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  52d8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
      1  52d8
      2  52d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  52d8				   .EARLY_LOCATION SET	*
      4  5300		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BISHOP_on_WHITE_SQUARE_1 wasted 40 bytes
      5  5300					      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5300					      ENDIF
      0  5300					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  5300				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5300				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5300				   BLACK_BISHOP_on_WHITE_SQUARE_1
      4  5300				   TEMPORARY_VAR SET	Overlay
      5  5300				   TEMPORARY_OFFSET SET	0
      6  5300				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5300				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      3  5300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5318		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  5330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5348					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  5348					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
      1  5348
      2  5348				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5348				  -.EARLY_LOCATION SET	*
      4  5348				  -	      ALIGN	256
      5  5348				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5348					      ENDIF
      0  5348					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  5348				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5348				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5348				   BLACK_BISHOP_on_WHITE_SQUARE_2
      4  5348				   TEMPORARY_VAR SET	Overlay
      5  5348				   TEMPORARY_OFFSET SET	0
      6  5348				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5348				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      3  5348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5360		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  5378		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5390					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  5390					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
      1  5390
      2  5390				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5390				  -.EARLY_LOCATION SET	*
      4  5390				  -	      ALIGN	256
      5  5390				  -	      ECHO	"Page break for", "BLACK_BISHOP_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5390					      ENDIF
      0  5390					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  5390				   SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5390				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	SLOT_BLACK_BISHOP_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5390				   BLACK_BISHOP_on_WHITE_SQUARE_3
      4  5390				   TEMPORARY_VAR SET	Overlay
      5  5390				   TEMPORARY_OFFSET SET	0
      6  5390				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5390				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      3  5390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  53a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  53c0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
    210  53d8
      0  53d8					      END_BANK
      1  53d8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  53d8				  -	      CHECK_RAM_BANK_SIZE
      3  53d8					      ELSE
      0  53d8					      CHECK_BANK_SIZE
      1  53d8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 21 PIECE_5 size = $3d8 free = 39
      2  53d8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  53d8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  53d8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  53d8				  -	      ERR
      6  53d8					      ENDIF
      5  53d8					      ENDIF
    212  53d8
    213  53d8
    214  53d8							;---------------------------------------------------------------------------------------------------
    215  53d8
      0  53d8					      ROMBANK	PIECE_6
      1  5790 ????				      SEG	ROM_PIECE_6
      2  5400					      ORG	_ORIGIN
      3  5400					      RORG	_BANK_ADDRESS_ORIGIN
      4  5400				   _BANK_START SET	*
      5  5400				   PIECE_6_START SET	*
      6  5400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5400				   ROMBANK_PIECE_6 SET	_BANK_SLOT + _CURRENT_BANK
      8  5400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5400				   _LAST_BANK SETSTR	PIECE_6
     10  5400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    217  5400
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5400					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  5400					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
      1  5400
      2  5400				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5400				  -.EARLY_LOCATION SET	*
      4  5400				  -	      ALIGN	256
      5  5400				  -	      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5400					      ENDIF
      0  5400					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  5400				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5400				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5400				   BLACK_ROOK_on_WHITE_SQUARE_0
      4  5400				   TEMPORARY_VAR SET	Overlay
      5  5400				   TEMPORARY_OFFSET SET	0
      6  5400				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5400				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      3  5400		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  5418		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  5430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5448					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  5448					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
      1  5448
      2  5448				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5448				  -.EARLY_LOCATION SET	*
      4  5448				  -	      ALIGN	256
      5  5448				  -	      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5448					      ENDIF
      0  5448					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  5448				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5448				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5448				   BLACK_ROOK_on_WHITE_SQUARE_1
      4  5448				   TEMPORARY_VAR SET	Overlay
      5  5448				   TEMPORARY_OFFSET SET	0
      6  5448				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5448				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      3  5448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5460		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  5478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5490					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  5490					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
      1  5490
      2  5490				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5490				  -.EARLY_LOCATION SET	*
      4  5490				  -	      ALIGN	256
      5  5490				  -	      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5490					      ENDIF
      0  5490					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  5490				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5490				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5490				   BLACK_ROOK_on_WHITE_SQUARE_2
      4  5490				   TEMPORARY_VAR SET	Overlay
      5  5490				   TEMPORARY_OFFSET SET	0
      6  5490				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5490				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      3  5490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  54a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  54c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  54d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  54d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
      1  54d8
      2  54d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  54d8				   .EARLY_LOCATION SET	*
      4  5500		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_ROOK_on_WHITE_SQUARE_3 wasted 40 bytes
      5  5500					      ECHO	"Page break for", "BLACK_ROOK_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5500					      ENDIF
      0  5500					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  5500				   SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5500				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	SLOT_BLACK_ROOK_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5500				   BLACK_ROOK_on_WHITE_SQUARE_3
      4  5500				   TEMPORARY_VAR SET	Overlay
      5  5500				   TEMPORARY_OFFSET SET	0
      6  5500				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5500				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      3  5500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5530		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5548					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  5548					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
      1  5548
      2  5548				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5548				  -.EARLY_LOCATION SET	*
      4  5548				  -	      ALIGN	256
      5  5548				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5548					      ENDIF
      0  5548					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  5548				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5548				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5548				   BLACK_QUEEN_on_WHITE_SQUARE_0
      4  5548				   TEMPORARY_VAR SET	Overlay
      5  5548				   TEMPORARY_OFFSET SET	0
      6  5548				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5548				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      3  5548		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$50,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$50,$50,$00	;PF0
      4  5560		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  5578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  5590					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  5590					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
      1  5590
      2  5590				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5590				  -.EARLY_LOCATION SET	*
      4  5590				  -	      ALIGN	256
      5  5590				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5590					      ENDIF
      0  5590					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  5590				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5590				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5590				   BLACK_QUEEN_on_WHITE_SQUARE_1
      4  5590				   TEMPORARY_VAR SET	Overlay
      5  5590				   TEMPORARY_OFFSET SET	0
      6  5590				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5590				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      3  5590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  55a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$54,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$54,$54,$00	;PF1
      5  55c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  55d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  55d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
      1  55d8
      2  55d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  55d8				   .EARLY_LOCATION SET	*
      4  5600		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_QUEEN_on_WHITE_SQUARE_2 wasted 40 bytes
      5  5600					      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5600					      ENDIF
      0  5600					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  5600				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5600				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5600				   BLACK_QUEEN_on_WHITE_SQUARE_2
      4  5600				   TEMPORARY_VAR SET	Overlay
      5  5600				   TEMPORARY_OFFSET SET	0
      6  5600				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5600				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      3  5600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5618		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$02,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$02,$02,$00	;PF1
      5  5630		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$05,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$05,$05,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5648					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  5648					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
      1  5648
      2  5648				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5648				  -.EARLY_LOCATION SET	*
      4  5648				  -	      ALIGN	256
      5  5648				  -	      ECHO	"Page break for", "BLACK_QUEEN_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5648					      ENDIF
      0  5648					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  5648				   SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5648				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	SLOT_BLACK_QUEEN_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5648				   BLACK_QUEEN_on_WHITE_SQUARE_3
      4  5648				   TEMPORARY_VAR SET	Overlay
      5  5648				   TEMPORARY_OFFSET SET	0
      6  5648				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5648				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      3  5648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5678		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$a8,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$a8,$a8,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 4
      0  5690					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  5690					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
      1  5690
      2  5690				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5690				  -.EARLY_LOCATION SET	*
      4  5690				  -	      ALIGN	256
      5  5690				  -	      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5690					      ENDIF
      0  5690					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  5690				   SLOT_BLACK_KING_on_WHITE_SQUARE_0 SET	_BANK_SLOT
      2  5690				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_0 + _CURRENT_BANK
      3  5690				   BLACK_KING_on_WHITE_SQUARE_0
      4  5690				   TEMPORARY_VAR SET	Overlay
      5  5690				   TEMPORARY_OFFSET SET	0
      6  5690				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5690				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      3  5690		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$50,$f0,$40,$e0,$40	;PF0
      4  56a8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  56c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 4
      0  56d8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  56d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
      1  56d8
      2  56d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  56d8				   .EARLY_LOCATION SET	*
      4  5700		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KING_on_WHITE_SQUARE_1 wasted 40 bytes
      5  5700					      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5700					      ENDIF
      0  5700					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  5700				   SLOT_BLACK_KING_on_WHITE_SQUARE_1 SET	_BANK_SLOT
      2  5700				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_1 + _CURRENT_BANK
      3  5700				   BLACK_KING_on_WHITE_SQUARE_1
      4  5700				   TEMPORARY_VAR SET	Overlay
      5  5700				   TEMPORARY_OFFSET SET	0
      6  5700				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5700				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      3  5700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5718		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$54,$7c,$10,$38,$10	;PF1
      5  5730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 4
      0  5748					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  5748					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
      1  5748
      2  5748				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5748				  -.EARLY_LOCATION SET	*
      4  5748				  -	      ALIGN	256
      5  5748				  -	      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5748					      ENDIF
      0  5748					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  5748				   SLOT_BLACK_KING_on_WHITE_SQUARE_2 SET	_BANK_SLOT
      2  5748				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_2 + _CURRENT_BANK
      3  5748				   BLACK_KING_on_WHITE_SQUARE_2
      4  5748				   TEMPORARY_VAR SET	Overlay
      5  5748				   TEMPORARY_OFFSET SET	0
      6  5748				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5748				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      3  5748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5760		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00	;PF1
      5  5778		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$05,$07,$01,$03,$01	;PF2
------- FILE @2 GRAPHICS DATA.asm
    229  5790
      0  5790					      END_BANK
      1  5790				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  5790				  -	      CHECK_RAM_BANK_SIZE
      3  5790					      ELSE
      0  5790					      CHECK_BANK_SIZE
      1  5790		       03 90	   .TEMP      =	* - _BANK_START
 ROM bank # 22 PIECE_6 size = $390 free = 111
      2  5790					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  5790				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5790				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  5790				  -	      ERR
      6  5790					      ENDIF
      5  5790					      ENDIF
    231  5790
    232  5790
    233  5790							;---------------------------------------------------------------------------------------------------
    234  5790
      0  5790					      ROMBANK	PIECE_7
      1  5bd8 ????				      SEG	ROM_PIECE_7
      2  5800					      ORG	_ORIGIN
      3  5800					      RORG	_BANK_ADDRESS_ORIGIN
      4  5800				   _BANK_START SET	*
      5  5800				   PIECE_7_START SET	*
      6  5800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5800				   ROMBANK_PIECE_7 SET	_BANK_SLOT + _CURRENT_BANK
      8  5800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5800				   _LAST_BANK SETSTR	PIECE_7
     10  5800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    236  5800
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 4
      0  5800					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  5800					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
      1  5800
      2  5800				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5800				  -.EARLY_LOCATION SET	*
      4  5800				  -	      ALIGN	256
      5  5800				  -	      ECHO	"Page break for", "BLACK_KING_on_WHITE_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5800					      ENDIF
      0  5800					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  5800				   SLOT_BLACK_KING_on_WHITE_SQUARE_3 SET	_BANK_SLOT
      2  5800				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	SLOT_BLACK_KING_on_WHITE_SQUARE_3 + _CURRENT_BANK
      3  5800				   BLACK_KING_on_WHITE_SQUARE_3
      4  5800				   TEMPORARY_VAR SET	Overlay
      5  5800				   TEMPORARY_OFFSET SET	0
      6  5800				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5800				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      3  5800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5830		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$a8,$f8,$20,$70,$20	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5848					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  5848					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
      1  5848
      2  5848				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5848				  -.EARLY_LOCATION SET	*
      4  5848				  -	      ALIGN	256
      5  5848				  -	      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5848					      ENDIF
      0  5848					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  5848				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5848				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5848				   BLACK_BLANK_on_BLACK_SQUARE_0
      4  5848				   TEMPORARY_VAR SET	Overlay
      5  5848				   TEMPORARY_OFFSET SET	0
      6  5848				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5848				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      3  5848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5890					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  5890					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
      1  5890
      2  5890				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5890				  -.EARLY_LOCATION SET	*
      4  5890				  -	      ALIGN	256
      5  5890				  -	      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5890					      ENDIF
      0  5890					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  5890				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5890				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5890				   BLACK_BLANK_on_BLACK_SQUARE_1
      4  5890				   TEMPORARY_VAR SET	Overlay
      5  5890				   TEMPORARY_OFFSET SET	0
      6  5890				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5890				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      3  5890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  58a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  58c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  58d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  58d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
      1  58d8
      2  58d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  58d8				   .EARLY_LOCATION SET	*
      4  5900		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_BLANK_on_BLACK_SQUARE_2 wasted 40 bytes
      5  5900					      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5900					      ENDIF
      0  5900					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  5900				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5900				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5900				   BLACK_BLANK_on_BLACK_SQUARE_2
      4  5900				   TEMPORARY_VAR SET	Overlay
      5  5900				   TEMPORARY_OFFSET SET	0
      6  5900				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5900				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      3  5900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5948					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  5948					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
      1  5948
      2  5948				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5948				  -.EARLY_LOCATION SET	*
      4  5948				  -	      ALIGN	256
      5  5948				  -	      ECHO	"Page break for", "BLACK_BLANK_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5948					      ENDIF
      0  5948					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  5948				   SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5948				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	SLOT_BLACK_BLANK_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5948				   BLACK_BLANK_on_BLACK_SQUARE_3
      4  5948				   TEMPORARY_VAR SET	Overlay
      5  5948				   TEMPORARY_OFFSET SET	0
      6  5948				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5948				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      3  5948		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5990					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  5990					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
      1  5990
      2  5990				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5990				  -.EARLY_LOCATION SET	*
      4  5990				  -	      ALIGN	256
      5  5990				  -	      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5990					      ENDIF
      0  5990					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  5990				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5990				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5990				   BLACK_PAWN_on_BLACK_SQUARE_0
      4  5990				   TEMPORARY_VAR SET	Overlay
      5  5990				   TEMPORARY_OFFSET SET	0
      6  5990				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5990				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      3  5990		       e0 e0 40 00*	      .byte.b	$e0,$e0,$40,$00,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  59a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  59c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  59d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  59d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
      1  59d8
      2  59d8					      IF	(>( * + 72 -1 )) > ( >* )
      3  59d8				   .EARLY_LOCATION SET	*
      4  5a00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_PAWN_on_BLACK_SQUARE_1 wasted 40 bytes
      5  5a00					      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5a00					      ENDIF
      0  5a00					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  5a00				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5a00				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5a00				   BLACK_PAWN_on_BLACK_SQUARE_1
      4  5a00				   TEMPORARY_VAR SET	Overlay
      5  5a00				   TEMPORARY_OFFSET SET	0
      6  5a00				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5a00				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      3  5a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a18		       38 38 10 00*	      .byte.b	$38,$38,$10,$00,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5a48					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
      1  5a48
      2  5a48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5a48				  -.EARLY_LOCATION SET	*
      4  5a48				  -	      ALIGN	256
      5  5a48				  -	      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5a48					      ENDIF
      0  5a48					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  5a48				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5a48				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5a48				   BLACK_PAWN_on_BLACK_SQUARE_2
      4  5a48				   TEMPORARY_VAR SET	Overlay
      5  5a48				   TEMPORARY_OFFSET SET	0
      6  5a48				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5a48				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a78		       03 03 01 00*	      .byte.b	$03,$03,$01,$00,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5a90					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
      1  5a90
      2  5a90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5a90				  -.EARLY_LOCATION SET	*
      4  5a90				  -	      ALIGN	256
      5  5a90				  -	      ECHO	"Page break for", "BLACK_PAWN_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5a90					      ENDIF
      0  5a90					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  5a90				   SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5a90				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	SLOT_BLACK_PAWN_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5a90				   BLACK_PAWN_on_BLACK_SQUARE_3
      4  5a90				   TEMPORARY_VAR SET	Overlay
      5  5a90				   TEMPORARY_OFFSET SET	0
      6  5a90				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5a90				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      3  5a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       70 70 20 00*	      .byte.b	$70,$70,$20,$00,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 4
      0  5ad8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
      1  5ad8
      2  5ad8					      IF	(>( * + 72 -1 )) > ( >* )
      3  5ad8				   .EARLY_LOCATION SET	*
      4  5b00		       00 00 00 00*	      ALIGN	256
 Page break for BLACK_KNIGHT_on_BLACK_SQUARE_0 wasted 40 bytes
      5  5b00					      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_0", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5b00					      ENDIF
      0  5b00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  5b00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_BANK_SLOT
      2  5b00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_0 + _CURRENT_BANK
      3  5b00				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      4  5b00				   TEMPORARY_VAR SET	Overlay
      5  5b00				   TEMPORARY_OFFSET SET	0
      6  5b00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      7  5b00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  5b00		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  5b18		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 4
      0  5b48					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
      1  5b48
      2  5b48				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5b48				  -.EARLY_LOCATION SET	*
      4  5b48				  -	      ALIGN	256
      5  5b48				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_1", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5b48					      ENDIF
      0  5b48					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  5b48				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_BANK_SLOT
      2  5b48				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_1 + _CURRENT_BANK
      3  5b48				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      4  5b48				   TEMPORARY_VAR SET	Overlay
      5  5b48				   TEMPORARY_OFFSET SET	0
      6  5b48				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      7  5b48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  5b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b60		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  5b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 4
      0  5b90					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
      1  5b90
      2  5b90				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5b90				  -.EARLY_LOCATION SET	*
      4  5b90				  -	      ALIGN	256
      5  5b90				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_2", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5b90					      ENDIF
      0  5b90					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  5b90				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_BANK_SLOT
      2  5b90				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_2 + _CURRENT_BANK
      3  5b90				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      4  5b90				   TEMPORARY_VAR SET	Overlay
      5  5b90				   TEMPORARY_OFFSET SET	0
      6  5b90				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      7  5b90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5bc0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    249  5bd8
      0  5bd8					      END_BANK
      1  5bd8				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  5bd8				  -	      CHECK_RAM_BANK_SIZE
      3  5bd8					      ELSE
      0  5bd8					      CHECK_BANK_SIZE
      1  5bd8		       03 d8	   .TEMP      =	* - _BANK_START
 ROM bank # 23 PIECE_7 size = $3d8 free = 39
      2  5bd8					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  5bd8				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5bd8				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  5bd8				  -	      ERR
      6  5bd8					      ENDIF
      5  5bd8					      ENDIF
    251  5bd8
    252  5bd8
    253  5bd8							;---------------------------------------------------------------------------------------------------
    254  5bd8
      0  5bd8					      ROMBANK	PIECE_8
      1  5c48 ????				      SEG	ROM_PIECE_8
      2  5c00					      ORG	_ORIGIN
      3  5c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  5c00				   _BANK_START SET	*
      5  5c00				   PIECE_8_START SET	*
      6  5c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  5c00				   ROMBANK_PIECE_8 SET	_BANK_SLOT + _CURRENT_BANK
      8  5c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  5c00				   _LAST_BANK SETSTR	PIECE_8
     10  5c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
    256  5c00
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 4
      0  5c00					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  5c00					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
      1  5c00
      2  5c00				  -	      IF	(>( * + 72 -1 )) > ( >* )
      3  5c00				  -.EARLY_LOCATION SET	*
      4  5c00				  -	      ALIGN	256
      5  5c00				  -	      ECHO	"Page break for", "BLACK_KNIGHT_on_BLACK_SQUARE_3", "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  5c00					      ENDIF
      0  5c00					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  5c00				   SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_BANK_SLOT
      2  5c00				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	SLOT_BLACK_KNIGHT_on_BLACK_SQUARE_3 + _CURRENT_BANK
      3  5c00				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      4  5c00				   TEMPORARY_VAR SET	Overlay
      5  5c00				   TEMPORARY_OFFSET SET	0
      6  5c00				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      7  5c00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  5c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c30		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE @2 GRAPHICS DATA.asm
    258  5c48
      0  5c48					      END_BANK
      1  5c48				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  5c48				  -	      CHECK_RAM_BANK_SIZE
      3  5c48					      ELSE
      0  5c48					      CHECK_BANK_SIZE
      1  5c48		       00 48	   .TEMP      =	* - _BANK_START
 ROM bank # 24 PIECE_8 size = $48 free = 951
      2  5c48					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  5c48				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  5c48				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  5c48				  -	      ERR
      6  5c48					      ENDIF
      5  5c48					      ENDIF
    260  5c48
    261  5c48
    262  5c48							;---------------------------------------------------------------------------------------------------
    263  5c48							;EOF
------- FILE ./chess.asm
------- FILE @2 VOX.asm LEVEL 2 PASS 4
      0  5c48					      include	"@2 VOX.asm"
      1  5c48							;
      2  5c48							; vox_test.asm
      3  5c48							;
      4  5c48							;
      5  5c48							; By Alex Herbert, 2004
      6  5c48							;
      7  5c48
      0  5c48					      SLOT	2
      1  5c48
      2  5c48				  -	      IF	(2 < 0) || (2 > 3)
      3  5c48				  -	      ECHO	"Illegal bank address/segment location", 2
      4  5c48				  -	      ERR
      5  5c48					      ENDIF
      6  5c48
      7  5c48				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  5c48				   _BANK_SLOT SET	2 * 64
      9  5c48
      0  5c48					      ROMBANK	VOX
      1  6360 ????				      SEG	ROM_VOX
      2  6000					      ORG	_ORIGIN
      3  6000					      RORG	_BANK_ADDRESS_ORIGIN
      4  6000				   _BANK_START SET	*
      5  6000				   VOX_START  SET	*
      6  6000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6000				   ROMBANK_VOX SET	_BANK_SLOT + _CURRENT_BANK
      8  6000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6000				   _LAST_BANK SETSTR	VOX
     10  6000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     10  6000
     11  6000
     12  6000							; Speakjet Driver
     13  6000
     14  6000
     15  6000
     16  6000							; Constants
     17  6000
     18  6000
     19  6000		       00 01	   SERIAL_OUTMASK equ	$01
     20  6000		       00 02	   SERIAL_RDYMASK equ	$02
     21  6000
     22  6000
     23  6000
     24  6000							; Macros
     25  6000
     26  6000					      MACRO	spkout
     27  6000
     28  6000
     29  6000							; check buffer-full status
     30  6000
     31  6000					      lda	SWCHA
     32  6000					      and	#SERIAL_RDYMASK
     33  6000					      beq	.speech_done
     34  6000
     35  6000							; get next speech byte
     36  6000
     37  6000					      ldy	#0
     38  6000					      lda	(speech_addr),y
     39  6000
     40  6000							; invert data and check for end of string
     41  6000
     42  6000					      eor	#$ff
     43  6000					      beq	.speech_done
     44  6000					      sta	{1}
     45  6000
     46  6000							; increment speech pointer
     47  6000
     48  6000					      inc	speech_addr
     49  6000					      bne	.incaddr_skip
     50  6000					      inc	speech_addr+1
     51  6000				   .incaddr_skip
     52  6000
     53  6000							; output byte as serial data
     54  6000
     55  6000					      sec		; start bit
     56  6000				   .byteout_loop
     57  6000
     58  6000							; put carry flag into bit 0 of SWACNT, perserving other bits
     59  6000
     60  6000					      lda	SWACNT	; 4
     61  6000					      and	#$fe	; 2 6
     62  6000					      adc	#$00	; 2 8
     63  6000					      sta	SWACNT	; 4 12
     64  6000
     65  6000							; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
     66  6000
     67  6000					      cpy	#$09	; 2 14
     68  6000					      beq	.speech_done	; 2 16
     69  6000					      iny		; 2 18
     70  6000
     71  6000							; waste some cycles
     72  6000					      ldx	#$07
     73  6000				   .delay_loop
     74  6000					      dex
     75  6000					      bne	.delay_loop	; 36 54
     76  6000
     77  6000							; shift next data bit into carry
     78  6000					      lsr	{1}	; 5 59
     79  6000
     80  6000							; and loop (branch always taken)
     81  6000					      bpl	.byteout_loop	; 3 62 cycles for loop
     82  6000
     83  6000				   .speech_done
     84  6000
     85  6000					      endm
     86  6000
     87  6000
     88  6000					      mac	speak
     89  6000
     90  6000					      lda	#<{1}
     91  6000					      sta	speech_addr
     92  6000					      lda	#>{1}
     93  6000					      sta	speech_addr+1
     94  6000
     95  6000					      endm
     96  6000
     97  6000
     98  6000
     99  6000
    100  6000
    101  6000
    102  6000
    103  6000							; Macros
    104  6000
    105  6000					      mac	wait_timint
    106  6000				   .1	      bit	TIMINT
    107  6000					      bpl	.1
    108  6000					      sta	WSYNC
    109  6000					      endm
    110  6000
    111  6000
    112  6000
    113  6000					      mac	wait_hbls
    114  6000					      ldx	{1}
    115  6000				   .1	      dex
    116  6000					      sta	WSYNC
    117  6000					      bne	.1
    118  6000					      endm
    119  6000
    120  6000
    121  6000
    122  6000
    123  6000							; Variables
    124  6000
    125  6000
    126  6000							; Code/Data
    127  6000
    128  6000							;	  seg	  code
    129  6000							;	  org	  $f000,$ff
    130  6000
    131  6000
    132  6000							; Speech Data
    133  6000
    134  6000				   fire_speech
    135  6000		       1f fd		      dc.b	31,253
    136  6002		       ff		      dc.b	$ff
    137  6003
    138  6003				   up_speech
    139  6003		       1f bf 83 08*	      dc.b	31,191,131,8,187,191,129,143,2,2
    140  600d		       bf 83 08 bb*	      dc.b	191,131,8,187,191,129,143,2,2
    141  6016		       93 0e 88 08*	      dc.b	147,14,136,8,141,8,191,162,8,190,148,8,128,31
    142  6024		       ff		      dc.b	$ff
    143  6025				   down_speech
    144  6025		       1f 16 6e 17*	      dc.b	31,22,110,23,1,215,6
    145  602c		       ae 9a 07 8d*	      dc.b	174,154,7,141,7,165,7,151,6,215,6
    146  6037		       ae 9a 07 8d*	      dc.b	174,154,7,141,7,165,7,151,6,215,6
    147  6042		       ae 9a 07 8d*	      dc.b	174,154,7,141,7,165,7,151,31
    148  604b		       ff		      dc.b	$ff
    149  604c				   left_speech
    150  604c		       1f 15 74 17*	      dc.b	31,21,116,23,4,22,55,182,129,194,131,141
    151  6058		       02 02 08 ba*	      dc.b	2,2,8,186,7,155,4,191,6,145,7,136,7,155,196,6
    152  6068		       9a 80 06 94*	      dc.b	154,128,6,148,7,137,7,164,18,171,136,191,31
    153  6075		       ff		      dc.b	$ff
    154  6076				   right_speech
    155  6076		       1f 15 7f aa*	      dc.b	31,21,127,170,128,174,128,170,128,174,128
    156  6081		       aa 80 ae 80*	      dc.b	170,128,174,128,170,128,174,128,170,128,174,128,31
    157  608e		       ff		      dc.b	$ff
    158  608f
    159  608f				   silence_speech
    160  608f		       1f		      dc.b	31
    161  6090		       ff		      dc.b	$ff
    162  6091
    163  6091
    164  6091
    165  6091							; Boot Code
    166  6091
      0  6091					      DEF	SayIt
      1  6091				   SLOT_SayIt SET	_BANK_SLOT
      2  6091				   BANK_SayIt SET	SLOT_SayIt + _CURRENT_BANK
      3  6091				   SayIt
      4  6091				   TEMPORARY_VAR SET	Overlay
      5  6091				   TEMPORARY_OFFSET SET	0
      6  6091				   VAR_BOUNDARY_SayIt SET	TEMPORARY_OFFSET
      7  6091				   FUNCTION_NAME SET	SayIt
    168  6091		       60		      rts
    169  6092
    170  6092
    171  6092				   boot
    172  6092		       78		      sei
    173  6093		       d8		      cld
    174  6094
    175  6094		       a2 ff		      ldx	#$ff
    176  6096		       9a		      txs
    177  6097
    178  6097		       e8		      inx
    179  6098		       8a		      txa
    180  6099				   boot_loop
    181  6099		       48		      pha
    182  609a		       ca		      dex
    183  609b		       d0 fc		      bne	boot_loop
    184  609d
      0  609d					      SPEAK	silence_speech
      1  609d
      2  609d		       a9 8f		      lda	#<silence_speech
      3  609f		       85 9a		      sta	speech_addr
      4  60a1		       a9 f8		      lda	#>silence_speech
      5  60a3		       85 9b		      sta	speech_addr+1
      6  60a5
    186  60a5
    187  60a5
    188  60a5							; Display Loop
    189  60a5
    190  60a5				   vertical_sync
    191  60a5		       a9 02		      lda	#$02
    192  60a7		       85 02		      sta	WSYNC
    193  60a9		       85 00		      sta	VSYNC
    194  60ab
    195  60ab		       a2 ff		      ldx	#$ff
    196  60ad		       9a		      txs
    197  60ae
    198  60ae		       e6 9c		      inc	voxframe
    199  60b0
    200  60b0		       85 02		      sta	WSYNC
    201  60b2
    202  60b2		       a9 2a		      lda	#(36*76)>>6
    203  60b4		       85 02		      sta	WSYNC
    204  60b6		       8d 96 02 	      sta	TIM64T
    205  60b9
    206  60b9		       a9 00		      lda	#$00
    207  60bb		       85 02		      sta	WSYNC
    208  60bd		       85 00		      sta	VSYNC
    209  60bf
    210  60bf
    211  60bf				   vblank_start
    212  60bf		       20 aa f9 	      jsr	read_switches
    213  60c2
    214  60c2		       20 cd f9 	      jsr	speech_select
    215  60c5
    216  60c5
    217  60c5		       a9 03		      lda	#$03
    218  60c7		       85 02		      sta	WSYNC
    219  60c9		       85 04		      sta	NUSIZ0	; 3
    220  60cb		       85 05		      sta	NUSIZ1	; 3 6
    221  60cd		       a2 01		      ldx	#$01	; 2 8
    222  60cf		       86 25		      stx	VDELP0	; 3 11
    223  60d1		       86 26		      stx	VDELP1	; 3 14
    224  60d3		       86 0a		      stx	CTRLPF	; 3 17
    225  60d5		       ca		      dex		; 2 19
    226  60d6		       86 1b		      stx	GRP0	; 3 22
    227  60d8		       86 1c		      stx	GRP1	; 3 25
    228  60da		       86 1b		      stx	GRP0	; 3 28
    229  60dc
    230  60dc		       a9 40		      lda	#$40	; 2 30
    231  60de		       85 20		      sta	HMP0	; 3 33
    232  60e0		       a9 50		      lda	#$50	; 2 35
    233  60e2		       85 21		      sta	HMP1	; 3 37
    234  60e4
    235  60e4		       85 10		      sta	RESP0	; 3 40
    236  60e6		       85 11		      sta	RESP1	; 3 43
    237  60e8
    238  60e8		       a9 04		      lda	#$04
    239  60ea		       85 09		      sta	COLUBK
    240  60ec
    241  60ec		       a9 28		      lda	#$28
    242  60ee		       85 06		      sta	COLUP0
    243  60f0		       85 07		      sta	COLUP1
    244  60f2
    245  60f2		       85 02		      sta	WSYNC
    246  60f4		       85 2a		      sta	HMOVE
    247  60f6
    248  60f6
      0  60f6					      WAIT_TIMINT
      1  60f6		       2c 85 02    .1	      bit	TIMINT
      2  60f9		       10 fb		      bpl	.1
      3  60fb		       85 02		      sta	WSYNC
    250  60fd
    251  60fd
    252  60fd				   display_start
    253  60fd		       a9 00		      lda	#$00
    254  60ff		       85 02		      sta	WSYNC
    255  6101		       85 01		      sta	VBLANK
    256  6103
    257  6103		       a9 e2		      lda	#(191*76)>>6
    258  6105		       8d 96 02 	      sta	TIM64T
    259  6108
    260  6108
      0  6108					      WAIT_HBLS	#$40
      1  6108		       a2 40		      ldx	#$40
      2  610a		       ca	   .1	      dex
      3  610b		       85 02		      sta	WSYNC
      4  610d		       d0 fb		      bne	.1
    262  610f
    263  610f
    264  610f		       a9 fe		      lda	#$fe
    265  6111		       85 02		      sta	WSYNC
    266  6113		       85 0f		      sta	PF2
    267  6115		       85 02		      sta	WSYNC
    268  6117		       85 02		      sta	WSYNC
    269  6119		       85 02		      sta	WSYNC
    270  611b
    271  611b		       a2 10		      ldx	#$10
    272  611d				   title_loop
    273  611d		       ca		      dex
    274  611e		       85 02		      sta	WSYNC
    275  6120
    276  6120		       bd 00 fb 	      lda	title_sprite0,x	; 4
    277  6123		       85 1b		      sta	GRP0	; 3
    278  6125		       bd 10 fb 	      lda	title_sprite1,x	; 4
    279  6128		       85 1c		      sta	GRP1	; 3
    280  612a		       bd 20 fb 	      lda	title_sprite2,x	; 4
    281  612d		       85 1b		      sta	GRP0	; 3 21
    282  612f
    283  612f		       bc 30 fb 	      ldy	title_sprite3,x	; 4
    284  6132		       bd 40 fb 	      lda	title_sprite4,x	; 4
    285  6135		       85 9d		      sta	temp	; 3
    286  6137		       bd 50 fb 	      lda	title_sprite5,x	; 4 36
    287  613a
    288  613a		       9a		      txs		; 2
    289  613b		       a6 9d		      ldx	temp	; 3 41
    290  613d
    291  613d		       84 1c		      sty	GRP1	; 3 44
    292  613f		       86 1b		      stx	GRP0	; 3 47
    293  6141		       85 1c		      sta	GRP1	; 3 50
    294  6143		       85 1b		      sta	GRP0	; 3 53
    295  6145
    296  6145		       a9 00		      lda	#$00
    297  6147		       85 02		      sta	WSYNC
    298  6149		       85 1c		      sta	GRP1
    299  614b		       85 1b		      sta	GRP0
    300  614d		       85 1c		      sta	GRP1
    301  614f
    302  614f		       ba		      tsx
    303  6150		       d0 cb		      bne	title_loop
    304  6152
    305  6152		       85 02		      sta	WSYNC
    306  6154		       85 02		      sta	WSYNC
    307  6156		       85 02		      sta	WSYNC
    308  6158		       a9 00		      lda	#$00
    309  615a		       85 02		      sta	WSYNC
    310  615c		       85 0f		      sta	PF2
    311  615e
    312  615e
      0  615e					      WAIT_TIMINT
      1  615e		       2c 85 02    .1	      bit	TIMINT
      2  6161		       10 fb		      bpl	.1
      3  6163		       85 02		      sta	WSYNC
    314  6165
    315  6165
    316  6165				   overscan_start
    317  6165		       a9 02		      lda	#$02
    318  6167		       85 02		      sta	WSYNC
    319  6169		       85 01		      sta	VBLANK
    320  616b
    321  616b		       a9 23		      lda	#(30*76)>>6
    322  616d		       8d 96 02 	      sta	TIM64T
    323  6170
    324  6170
      0  6170					      SPKOUT	temp
      1  6170
      2  6170
      3  6170
      4  6170
      5  6170		       ad 80 02 	      lda	SWCHA
      6  6173		       29 02		      and	#SERIAL_RDYMASK
      7  6175		       f0 29		      beq	.speech_done
      8  6177
      9  6177
     10  6177
     11  6177		       a0 00		      ldy	#0
     12  6179		       b1 9a		      lda	(speech_addr),y
     13  617b
     14  617b
     15  617b
     16  617b		       49 ff		      eor	#$ff
     17  617d		       f0 21		      beq	.speech_done
     18  617f		       85 9d		      sta	temp
     19  6181
     20  6181
     21  6181
     22  6181		       e6 9a		      inc	speech_addr
     23  6183		       d0 02		      bne	.incaddr_skip
     24  6185		       e6 9b		      inc	speech_addr+1
     25  6187				   .incaddr_skip
     26  6187
     27  6187
     28  6187
     29  6187		       38		      sec
     30  6188				   .byteout_loop
     31  6188
     32  6188
     33  6188
     34  6188		       ad 81 02 	      lda	SWACNT
     35  618b		       29 fe		      and	#$fe
     36  618d		       69 00		      adc	#$00
     37  618f		       8d 81 02 	      sta	SWACNT
     38  6192
     39  6192
     40  6192
     41  6192		       c0 09		      cpy	#$09
     42  6194		       f0 0a		      beq	.speech_done
     43  6196		       c8		      iny
     44  6197
     45  6197
     46  6197		       a2 07		      ldx	#$07
     47  6199				   .delay_loop
     48  6199		       ca		      dex
     49  619a		       d0 fd		      bne	.delay_loop
     50  619c
     51  619c
     52  619c		       46 9d		      lsr	temp
     53  619e
     54  619e
     55  619e		       10 e8		      bpl	.byteout_loop
     56  61a0
     57  61a0				   .speech_done
     58  61a0
    326  61a0
    327  61a0
      0  61a0					      WAIT_TIMINT
      1  61a0		       2c 85 02    .1	      bit	TIMINT
      2  61a3		       10 fb		      bpl	.1
      3  61a5		       85 02		      sta	WSYNC
    329  61a7
    330  61a7		       4c a5 f8 	      jmp	vertical_sync
    331  61aa
    332  61aa
    333  61aa
    334  61aa							; Subroutines
    335  61aa
    336  61aa				   read_switches
    337  61aa		       a5 9e		      lda	switch_states
    338  61ac		       49 ff		      eor	#$ff
    339  61ae		       85 9f		      sta	switch_edges
    340  61b0
    341  61b0		       ad 82 02 	      lda	SWCHB
    342  61b3		       09 f4		      ora	#$f4
    343  61b5		       85 9e		      sta	switch_states
    344  61b7		       ad 80 02 	      lda	SWCHA
    345  61ba		       09 0f		      ora	#$0f
    346  61bc		       25 9e		      and	switch_states
    347  61be		       24 0c		      bit	INPT4
    348  61c0		       30 02		      bmi	switches_skip
    349  61c2		       29 fb		      and	#$fb
    350  61c4				   switches_skip
    351  61c4		       49 ff		      eor	#$ff
    352  61c6		       85 9e		      sta	switch_states
    353  61c8		       25 9f		      and	switch_edges
    354  61ca		       85 9f		      sta	switch_edges
    355  61cc		       60		      rts
    356  61cd
    357  61cd
    358  61cd
    359  61cd				   speech_select
    360  61cd		       a5 9f		      lda	switch_edges
    361  61cf		       0a		      asl
    362  61d0		       b0 31		      bcs	start_rightspeech
    363  61d2		       0a		      asl
    364  61d3		       b0 25		      bcs	start_leftspeech
    365  61d5		       0a		      asl
    366  61d6		       b0 19		      bcs	start_downspeech
    367  61d8		       0a		      asl
    368  61d9		       b0 0d		      bcs	start_upspeech
    369  61db		       0a		      asl
    370  61dc		       30 01		      bmi	start_firespeech
    371  61de		       60		      rts
    372  61df
    373  61df				   start_firespeech
      0  61df					      SPEAK	fire_speech
      1  61df
      2  61df		       a9 00		      lda	#<fire_speech
      3  61e1		       85 9a		      sta	speech_addr
      4  61e3		       a9 f8		      lda	#>fire_speech
      5  61e5		       85 9b		      sta	speech_addr+1
      6  61e7
    375  61e7		       60		      rts
    376  61e8
    377  61e8				   start_upspeech
      0  61e8					      SPEAK	up_speech
      1  61e8
      2  61e8		       a9 03		      lda	#<up_speech
      3  61ea		       85 9a		      sta	speech_addr
      4  61ec		       a9 f8		      lda	#>up_speech
      5  61ee		       85 9b		      sta	speech_addr+1
      6  61f0
    379  61f0		       60		      rts
    380  61f1
    381  61f1				   start_downspeech
      0  61f1					      SPEAK	down_speech
      1  61f1
      2  61f1		       a9 25		      lda	#<down_speech
      3  61f3		       85 9a		      sta	speech_addr
      4  61f5		       a9 f8		      lda	#>down_speech
      5  61f7		       85 9b		      sta	speech_addr+1
      6  61f9
    383  61f9		       60		      rts
    384  61fa
    385  61fa				   start_leftspeech
      0  61fa					      SPEAK	left_speech
      1  61fa
      2  61fa		       a9 4c		      lda	#<left_speech
      3  61fc		       85 9a		      sta	speech_addr
      4  61fe		       a9 f8		      lda	#>left_speech
      5  6200		       85 9b		      sta	speech_addr+1
      6  6202
    387  6202		       60		      rts
    388  6203
    389  6203				   start_rightspeech
      0  6203					      SPEAK	right_speech
      1  6203
      2  6203		       a9 76		      lda	#<right_speech
      3  6205		       85 9a		      sta	speech_addr
      4  6207		       a9 f8		      lda	#>right_speech
      5  6209		       85 9b		      sta	speech_addr+1
      6  620b
    391  620b		       60		      rts
    392  620c
    393  620c
    394  620c
    395  620c							; Sprite Data
    396  620c
    397  6300		       00 00 00 00*	      align	$100
    398  6300
    399  6300				   title_sprite0
    400  6300		       00		      dc.b	%00000000
    401  6301		       00		      dc.b	%00000000
    402  6302		       00		      dc.b	%00000000
    403  6303		       00		      dc.b	%00000000
    404  6304		       00		      dc.b	%00000000
    405  6305		       00		      dc.b	%00000000
    406  6306		       00		      dc.b	%00000000
    407  6307		       00		      dc.b	0
    408  6308		       00		      dc.b	0
    409  6309		       88		      dc.b	%10001000
    410  630a		       88		      dc.b	%10001000
    411  630b		       f8		      dc.b	%11111000
    412  630c		       88		      dc.b	%10001000
    413  630d		       88		      dc.b	%10001000
    414  630e		       50		      dc.b	%01010000
    415  630f		       23		      dc.b	%00100011
    416  6310
    417  6310				   title_sprite1
    418  6310		       02		      dc.b	%00000010
    419  6311		       02		      dc.b	%00000010
    420  6312		       02		      dc.b	%00000010
    421  6313		       02		      dc.b	%00000010
    422  6314		       02		      dc.b	%00000010
    423  6315		       02		      dc.b	%00000010
    424  6316		       0f		      dc.b	%00001111
    425  6317		       00		      dc.b	0
    426  6318		       00		      dc.b	0
    427  6319		       88		      dc.b	%10001000
    428  631a		       88		      dc.b	%10001000
    429  631b		       8f		      dc.b	%10001111
    430  631c		       88		      dc.b	%10001000
    431  631d		       88		      dc.b	%10001000
    432  631e		       85		      dc.b	%10000101
    433  631f		       e2		      dc.b	%11100010
    434  6320
    435  6320				   title_sprite2
    436  6320		       3e		      dc.b	%00111110
    437  6321		       20		      dc.b	%00100000
    438  6322		       20		      dc.b	%00100000
    439  6323		       3c		      dc.b	%00111100
    440  6324		       20		      dc.b	%00100000
    441  6325		       20		      dc.b	%00100000
    442  6326		       be		      dc.b	%10111110
    443  6327		       00		      dc.b	0
    444  6328		       00		      dc.b	0
    445  6329		       a2		      dc.b	%10100010
    446  632a		       a4		      dc.b	%10100100
    447  632b		       a8		      dc.b	%10101000
    448  632c		       bc		      dc.b	%10111100
    449  632d		       a2		      dc.b	%10100010
    450  632e		       22		      dc.b	%00100010
    451  632f		       3c		      dc.b	%00111100
    452  6330
    453  6330				   title_sprite3
    454  6330		       70		      dc.b	%01110000
    455  6331		       88		      dc.b	%10001000
    456  6332		       08		      dc.b	%00001000
    457  6333		       70		      dc.b	%01110000
    458  6334		       80		      dc.b	%10000000
    459  6335		       88		      dc.b	%10001000
    460  6336		       73		      dc.b	%01110011
    461  6337		       00		      dc.b	0
    462  6338		       00		      dc.b	0
    463  6339		       70		      dc.b	%01110000
    464  633a		       21		      dc.b	%00100001
    465  633b		       22		      dc.b	%00100010
    466  633c		       22		      dc.b	%00100010
    467  633d		       22		      dc.b	%00100010
    468  633e		       22		      dc.b	%00100010
    469  633f		       72		      dc.b	%01110010
    470  6340
    471  6340				   title_sprite4
    472  6340		       80		      dc.b	%10000000
    473  6341		       80		      dc.b	%10000000
    474  6342		       80		      dc.b	%10000000
    475  6343		       80		      dc.b	%10000000
    476  6344		       80		      dc.b	%10000000
    477  6345		       80		      dc.b	%10000000
    478  6346		       e0		      dc.b	%11100000
    479  6347		       00		      dc.b	0
    480  6348		       00		      dc.b	0
    481  6349		       87		      dc.b	%10000111
    482  634a		       48		      dc.b	%01001000
    483  634b		       28		      dc.b	%00101000
    484  634c		       28		      dc.b	%00101000
    485  634d		       28		      dc.b	%00101000
    486  634e		       28		      dc.b	%00101000
    487  634f		       27		      dc.b	%00100111
    488  6350
    489  6350				   title_sprite5
    490  6350		       00		      dc.b	%00000000
    491  6351		       00		      dc.b	%00000000
    492  6352		       00		      dc.b	%00000000
    493  6353		       00		      dc.b	%00000000
    494  6354		       00		      dc.b	%00000000
    495  6355		       00		      dc.b	%00000000
    496  6356		       00		      dc.b	%00000000
    497  6357		       00		      dc.b	0
    498  6358		       00		      dc.b	0
    499  6359		       22		      dc.b	%00100010
    500  635a		       a2		      dc.b	%10100010
    501  635b		       94		      dc.b	%10010100
    502  635c		       88		      dc.b	%10001000
    503  635d		       94		      dc.b	%10010100
    504  635e		       a2		      dc.b	%10100010
    505  635f		       22		      dc.b	%00100010
    506  6360
    507  6360
    508  6360
    509  6360
    510  6360
      0  6360					      END_BANK
      1  6360				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  6360				  -	      CHECK_RAM_BANK_SIZE
      3  6360					      ELSE
      0  6360					      CHECK_BANK_SIZE
      1  6360		       03 60	   .TEMP      =	* - _BANK_START
 ROM bank # 25 VOX size = $360 free = 159
      2  6360					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  6360				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6360				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  6360				  -	      ERR
      6  6360					      ENDIF
      5  6360					      ENDIF
------- FILE ./chess.asm
    207  6360
------- FILE @3 GENERIC #2.asm LEVEL 2 PASS 4
      0  6360					      include	"@3 GENERIC #2.asm"
      1  6360							;---------------------------------------------------------------------------------------------------
      2  6360							; @3 GENERIC #2.asm
      3  6360
      4  6360							; Atari 2600 Chess
      5  6360							; Copyright (c) 2019-2020 Andrew Davie
      6  6360							; andrew@taswegian.com
      7  6360
      8  6360
      9  6360							;---------------------------------------------------------------------------------------------------
     10  6360
      0  6360					      SLOT	3
      1  6360
      2  6360				  -	      IF	(3 < 0) || (3 > 3)
      3  6360				  -	      ECHO	"Illegal bank address/segment location", 3
      4  6360				  -	      ERR
      5  6360					      ENDIF
      6  6360
      7  6360				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  6360				   _BANK_SLOT SET	3 * 64
      9  6360
      0  6360					      ROMBANK	THREE
      1  64aa ????				      SEG	ROM_THREE
      2  6400					      ORG	_ORIGIN
      3  6400					      RORG	_BANK_ADDRESS_ORIGIN
      4  6400				   _BANK_START SET	*
      5  6400				   THREE_START SET	*
      6  6400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6400				   ROMBANK_THREE SET	_BANK_SLOT + _CURRENT_BANK
      8  6400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6400				   _LAST_BANK SETSTR	THREE
     10  6400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     13  6400
      0  6400					      DEF	Breaker
      1  6400				   SLOT_Breaker SET	_BANK_SLOT
      2  6400				   BANK_Breaker SET	SLOT_Breaker + _CURRENT_BANK
      3  6400				   Breaker
      4  6400				   TEMPORARY_VAR SET	Overlay
      5  6400				   TEMPORARY_OFFSET SET	0
      6  6400				   VAR_BOUNDARY_Breaker SET	TEMPORARY_OFFSET
      7  6400				   FUNCTION_NAME SET	Breaker
     15  6400		       00		      brk
     16  6401
     17  6401
     18  6401							;---------------------------------------------------------------------------------------------------
     19  6401
      0  6401					      DEF	GetPiece
      1  6401				   SLOT_GetPiece SET	_BANK_SLOT
      2  6401				   BANK_GetPiece SET	SLOT_GetPiece + _CURRENT_BANK
      3  6401				   GetPiece
      4  6401				   TEMPORARY_VAR SET	Overlay
      5  6401				   TEMPORARY_OFFSET SET	0
      6  6401				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      7  6401				   FUNCTION_NAME SET	GetPiece
     21  6401					      SUBROUTINE
     22  6401
      0  6401					      REF	aiSelectDestinationSquare	;✅
      1  6401					      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  6401				   TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  6401					      ENDIF
      0  6401					      REF	aiQuiescent	;✅
      1  6401				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  6401				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  6401					      ENDIF
      0  6401					      VEND	GetPiece
      1  6401
      2  6401
      3  6401		       00 ee	   VAREND_GetPiece =	TEMPORARY_VAR
      4  6401
     26  6401
     27  6401							; Retrieve the piece+flags from the movelist, given from/to squares
     28  6401							; Required as moves have different flags but same origin squares (e.g., castling)
     29  6401
     30  6401		       a9 89		      lda	#RAMBANK_PLY+1	;currentPly
     31  6403							;lda currentPly
     32  6403		       85 3e		      sta	SET_BANK_RAM	;@2
     33  6405
     34  6405							; returns piece in A+fromPiece
     35  6405							; or Y=-1 if not found
     36  6405
     37  6405							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
     38  6405							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
     39  6405							; This fixes the move with/without castle flag
     40  6405
     41  6405
      0  6405					      ldy@PLY	moveIndex
      1  6405		       ac cf f9 	      ldy	moveIndex
     43  6408		       30 11		      bmi	.fail	; shouldn't happen
     44  640a
     45  640a		       a5 86	   .scan      lda	fromX12
      0  640c					      cmp@PLY	MoveFrom,y
      1  640c		       d9 00 f8 	      cmp	MoveFrom,y
     47  640f		       d0 07		      bne	.next
     48  6411		       a5 87		      lda	toX12
      0  6413					      cmp@PLY	MoveTo,y
      1  6413		       d9 64 f8 	      cmp	MoveTo,y
     50  6416		       f0 04		      beq	.found
     51  6418		       88	   .next      dey
     52  6419		       10 ef		      bpl	.scan
     53  641b		       60	   .fail      rts
     54  641c
      0  641c				   .found     lda@PLY	MovePiece,y
      1  641c		       b9 00 f9 	      lda	MovePiece,y
     56  641f		       85 97		      sta	fromPiece
     57  6421
     58  6421		       60		      rts
     59  6422
     60  6422
     61  6422							;---------------------------------------------------------------------------------------------------
     62  6422
     63  6422							;     DEF GenCastleMoveForRook_ENPASSANT
     64  6422							;     SUBROUTINE
     65  6422
     66  6422							;	   REF MakeMove ;✅
     67  6422							;	   REF CastleFixupDraw_ENPASSANT ;✅
     68  6422							;	   VEND GenCastleMoveForRook_ENPASSANT
     69  6422
     70  6422							;	   rts ;tmp
     71  6422							;	   jsr debug ;tmp
     72  6422
     73  6422							;     ; Like castling, this generates the acutal extra-move for the en-passant
     74  6422
     75  6422
     76  6422							;     ; Check to see if we are doing an actual en-passant capture...
     77  6422
     78  6422							;     ; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
     79  6422							;     ;  as the en-passant will fail if the taking piece does not have this flag set correctly
     80  6422
     81  6422
     82  6422
     83  6422							;     ; {
     84  6422							;     ; With en-passant flag, it is essentially dual-use.
     85  6422							;     ; First, it marks if the move is *involved* somehow in an en-passant
     86  6422							;     ; if the piece has MOVED already, then it's an en-passant capture
     87  6422							;     ; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
     88  6422
     89  6422							;		       ldy enPassantPawn	       ; save from previous side move
     90  6422
     91  6422							;		       ldx #0			       ; (probably) NO en-passant this time
     92  6422							;		       lda fromPiece
     93  6422							;		       and #FLAG_ENPASSANT|FLAG_MOVED
     94  6422							;		       cmp #FLAG_ENPASSANT
     95  6422							;		       bne .noep		       ; HAS moved, or not en-passant
     96  6422
     97  6422							;		       eor fromPiece		       ; clear FLAG_ENPASSANT
     98  6422							;		       sta fromPiece
     99  6422
    100  6422							;		       ldx toX12		       ; this IS an en-passantable opening, so record the square
    101  6422							; .noep	       stx enPassantPawn	       ; capturable square for en-passant move (or none)
    102  6422
    103  6422							;     ; }
    104  6422
    105  6422							;		       clc
    106  6422
    107  6422							;		       lda fromPiece
    108  6422							;		       and #FLAG_ENPASSANT
    109  6422							;		       beq .notEnPassant	       ; not an en-passant, or it's enpassant by a MOVED piece
    110  6422
    111  6422
    112  6422							;     ; at this point the attacking pawn has finished moving to the "take" square
    113  6422							;     ; the loser-pawn is marked with enPassantPawn
    114  6422							;     ; we want to generate a 'blank' move to take the pawn
    115  6422
    116  6422							;		       lda originX12		       ; we need a blank square to move FROM
    117  6422							;		       sta fromX12		       ; use the square the attacker pawn just left
    118  6422
    119  6422							;     ; calculate the captured pawn's square based on move colour
    120  6422
    121  6422							;		       lda #-10
    122  6422							;		       ldx fromPiece
    123  6422							;		       bpl .white
    124  6422							;		       lda #10
    125  6422							; .white
    126  6422							;		       clc
    127  6422							;		       adc fromX12		       ; attacker destination square
    128  6422							;		       sta toX12		       ; now we have the captured pawn square!
    129  6422							;		       sta@PLY secondarySquare	       ; square to which we RESTORE the captured pawn on unmakemove
    130  6422
    131  6422							;		       sta@PLY secondaryBlank
    132  6422							;		       lda fromPiece
    133  6422							;		       eor #$80 		       ; opponent pawn
    134  6422							;		       sta@PLY secondaryPiece	       ; a capture!
    135  6422
    136  6422
    137  6422							;		       sec			       ; double-move, so don't change sides
    138  6422							; .notEnPassant       rts
    139  6422
    140  6422
    141  6422							;---------------------------------------------------------------------------------------------------
    142  6422
      0  6422					      DEF	GenCastleMoveForRook
      1  6422				   SLOT_GenCastleMoveForRook SET	_BANK_SLOT
      2  6422				   BANK_GenCastleMoveForRook SET	SLOT_GenCastleMoveForRook + _CURRENT_BANK
      3  6422				   GenCastleMoveForRook
      4  6422				   TEMPORARY_VAR SET	Overlay
      5  6422				   TEMPORARY_OFFSET SET	0
      6  6422				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      7  6422				   FUNCTION_NAME SET	GenCastleMoveForRook
    144  6422					      SUBROUTINE
    145  6422
      0  6422					      REF	MakeMove	;✅
      1  6422					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  6422				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  6422					      ENDIF
      0  6422					      REF	CastleFixupDraw	;✅
      1  6422				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  6422				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  6422					      ENDIF
      0  6422					      VEND	GenCastleMoveForRook
      1  6422
      2  6422
      3  6422		       00 b8	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
      4  6422
    149  6422
    150  6422							; Generate secondary move for the rook, involved in a castling move
    151  6422							; Returns:
    152  6422							;   CC --> not a castle/secondary
    153  6422							;   CS --> secondary move valid
    154  6422
    155  6422
    156  6422		       18		      clc
    157  6423
    158  6423		       a5 97		      lda	fromPiece
    159  6425		       29 10		      and	#FLAG_CASTLE
    160  6427		       f0 2d		      beq	.exit	; NOT involved in castle!
    161  6429
    162  6429		       a2 04		      ldx	#4
    163  642b		       a5 87		      lda	toX12	; *destination*
    164  642d		       18	   .findCast  clc
    165  642e		       ca		      dex
    166  642f		       30 25		      bmi	.exit
    167  6431		       dd 57 fc 	      cmp	KSquare,x
    168  6434		       d0 f7		      bne	.findCast
    169  6436
    170  6436		       bd 5f fc 	      lda	RSquareEnd,x
    171  6439		       85 87		      sta	toX12
      0  643b					      sta@PLY	secondaryBlank
      1  643b		       8d ce fb 	      sta	[RAM]+secondaryBlank
    173  643e		       bc 5b fc 	      ldy	RSquareStart,x
    174  6441		       84 86		      sty	fromX12
    175  6443		       84 88		      sty	originX12
      0  6445					      sty@PLY	secondarySquare
      1  6445		       8c cd fb 	      sty	[RAM]+secondarySquare
    177  6448
    178  6448		       a5 97		      lda	fromPiece
    179  644a		       29 80		      and	#128	; colour bit
    180  644c		       09 05		      ora	#ROOK	; preserve colour
    181  644e		       85 97		      sta	fromPiece
    182  6450		       85 b2		      sta	__originalPiece
      0  6452					      sta@PLY	secondaryPiece
      1  6452		       8d cc fb 	      sta	[RAM]+secondaryPiece
    184  6455
    185  6455		       38		      sec
    186  6456		       60	   .exit      rts
    187  6457
    188  6457
    189  6457		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    190  645b		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    191  645f		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    192  6463		       19 1b 5f 61 virtualSquare1 .byte.b	25,27,95,97
    193  6467							;virtualSquare2      .byte 26,26,96,96
    194  6467
    195  6467							;---------------------------------------------------------------------------------------------------
    196  6467
    197  6467							; DEF GenEnPassantMove
    198  6467							; SUBROUTINE
    199  6467
    200  6467							;     REF EnPassantCheck
    201  6467							;     REF MakeMove
    202  6467							;     VEND GenEnPassantMove
    203  6467
    204  6467
    205  6467							;		   rts
    206  6467
    207  6467
    208  6467
    209  6467							; The reset vectors
    210  6467							; these must live in the fixed bank (bank 0 in 3E+ format)
    211  6467
    212  6467							;    ORG $63FC
    213  6467							;    RORG $FFFC
    214  6467
    215  6467							;		      .word StartCartridge	      ; RESET
    216  6467							;		      .word StartCartridge	      ; IRQ	   (not used)
    217  6467
    218  6467
    219  6467							;---------------------------------------------------------------------------------------------------
    220  6467
      0  6467					      DEF	InterlaceFrame
      1  6467				   SLOT_InterlaceFrame SET	_BANK_SLOT
      2  6467				   BANK_InterlaceFrame SET	SLOT_InterlaceFrame + _CURRENT_BANK
      3  6467				   InterlaceFrame
      4  6467				   TEMPORARY_VAR SET	Overlay
      5  6467				   TEMPORARY_OFFSET SET	0
      6  6467				   VAR_BOUNDARY_InterlaceFrame SET	TEMPORARY_OFFSET
      7  6467				   FUNCTION_NAME SET	InterlaceFrame
    222  6467
    223  6467
    224  6467							; START OF FRAME
    225  6467
    226  6467
    227  6467				  -	      IF	0
    228  6467				  -
    229  6467				  -	      lda	SWCHB
    230  6467				  -	      bmi	.normal	; RIGHT difficulty switches on/off
    231  6467				  -
    232  6467				  -	      dec	framenum
    233  6467				  -	      lda	framenum
    234  6467				  -	      lsr
    235  6467				  -	      bcs	.normal
    236  6467				  -
    237  6467				  -	      SLEEP	36
    238  6467				  -
    239  6467				  -.normal    lda	#2
    240  6467				  -	      sta	WSYNC
    241  6467				  -	      sta	VSYNC
    242  6467				  -
    243  6467				  -	      sta	WSYNC	; line 1 of VSYNC
    244  6467				  -	      sta	WSYNC	; line 2 of VSYNC
    245  6467				  -
    246  6467				  -	      lda	#0
    247  6467				  -	      sta	WSYNC	; line 3 of VSYNC
    248  6467				  -	      sta	VSYNC	; @0
    249  6467				  -
    250  6467				  -
    251  6467				  -	      sta	VBLANK
    252  6467				  -
    253  6467					      ENDIF
    254  6467
    255  6467
    256  6467
    257  6467					      IF	1
    258  6467
    259  6467
    260  6467				   frame
    261  6467							;Vertical sync
    262  6467							;dec	framenum
    263  6467
    264  6467							;lda	interlaced		;see if we are in interlaced mode
    265  6467							;beq	non_interlaced
    266  6467
    267  6467		       ad 82 02 	      lda	SWCHB
    268  646a		       30 1b		      bmi	even_sync
    269  646c
    270  646c		       c6 80		      dec	framenum
    271  646e		       a5 80		      lda	framenum
    272  6470		       29 01		      and	#1
    273  6472		       f0 13		      beq	even_sync
    274  6474
    275  6474				   non_interlaced		;entry point for non-interlaced
    276  6474							;this is the vertical sync for the first field of an interlaced frame
    277  6474							;or just a normal non-interlaced vertical sync
    278  6474		       a9 02		      lda	#2
    279  6476		       85 02		      sta	WSYNC
    280  6478		       85 00		      sta	VSYNC	; Begin vertical sync.
    281  647a
    282  647a		       85 02		      sta	WSYNC	; First line of VSYNC
    283  647c		       85 02		      sta	WSYNC	; Second line of VSYNC.
    284  647e		       a9 00		      lda	#0
    285  6480		       85 02		      sta	WSYNC	; Third line of VSYNC.
    286  6482		       85 00		      sta	VSYNC	; (0)
    287  6484
    288  6484		       4c a9 fc 	      jmp	done_sync
    289  6487				   even_sync
    290  6487							;this is the vertical sync for the second field of an interlaced fram
    291  6487		       85 02		      sta	WSYNC
    292  6489							;need 40 cycles until the start of vertical sync
    293  6489
      0  6489					      SLEEP	36
      1  6489				   .CYCLES    SET	36
      2  6489
      3  6489				  -	      IF	.CYCLES < 2
      4  6489				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6489				  -	      ERR
      6  6489					      ENDIF
      7  6489
      8  6489				  -	      IF	.CYCLES & 1
      9  6489				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  6489				  -	      nop	0
     11  6489				  -	      ELSE
     12  6489				  -	      bit	VSYNC
     13  6489				  -	      ENDIF
     14  6489				  -.CYCLES    SET	.CYCLES - 3
     15  6489					      ENDIF
     16  6489
     17  6489					      REPEAT	.CYCLES / 2
     18  6489		       ea		      nop
     17  6489					      REPEND
     18  648a		       ea		      nop
     17  648a					      REPEND
     18  648b		       ea		      nop
     17  648b					      REPEND
     18  648c		       ea		      nop
     17  648c					      REPEND
     18  648d		       ea		      nop
     17  648d					      REPEND
     18  648e		       ea		      nop
     17  648e					      REPEND
     18  648f		       ea		      nop
     17  648f					      REPEND
     18  6490		       ea		      nop
     17  6490					      REPEND
     18  6491		       ea		      nop
     17  6491					      REPEND
     18  6492		       ea		      nop
     17  6492					      REPEND
     18  6493		       ea		      nop
     17  6493					      REPEND
     18  6494		       ea		      nop
     17  6494					      REPEND
     18  6495		       ea		      nop
     17  6495					      REPEND
     18  6496		       ea		      nop
     17  6496					      REPEND
     18  6497		       ea		      nop
     17  6497					      REPEND
     18  6498		       ea		      nop
     17  6498					      REPEND
     18  6499		       ea		      nop
     17  6499					      REPEND
     18  649a		       ea		      nop
     19  649b					      REPEND
    295  649b
    296  649b
    297  649b		       a9 02		      lda	#2	;40
    298  649d
    299  649d		       85 00		      sta	VSYNC	; Begin vertical sync.
    300  649f		       85 02		      sta	WSYNC	; First line of VSYNC
    301  64a1		       85 02		      sta	WSYNC	; Second line of VSYNC.
    302  64a3
    303  64a3		       85 02		      sta	WSYNC	; Third line of VSYNC.
    304  64a5							;need 33 cycles until the end of VSYNC
    305  64a5
    306  64a5
    307  64a5							;SLEEP 10
    308  64a5
    309  64a5
    310  64a5
    311  64a5		       a9 00		      lda	#0	;33
    312  64a7		       85 00		      sta	VSYNC
    313  64a9
    314  64a9				   done_sync
    315  64a9
    316  64a9							;	LDA #40		;timer for 34 lines of blanking
    317  64a9							;	STA TIM64T
    318  64a9					      ENDIF
    319  64a9
    320  64a9
    321  64a9							;		      lda #%1110		      ; VSYNC ON
    322  64a9							;.loopVSync3	      sta WSYNC
    323  64a9							;		      sta VSYNC
    324  64a9							;		      lsr
    325  64a9							;		      bne .loopVSync3		      ; branch until VYSNC has been reset
    326  64a9
    327  64a9							;		      sta VBLANK
    328  64a9
    329  64a9		       60		      rts
    330  64aa
    331  64aa
    332  64aa							;---------------------------------------------------------------------------------------------------
    333  64aa
      0  64aa					      END_BANK
      1  64aa				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  64aa				  -	      CHECK_RAM_BANK_SIZE
      3  64aa					      ELSE
      0  64aa					      CHECK_BANK_SIZE
      1  64aa		       00 aa	   .TEMP      =	* - _BANK_START
 ROM bank # 26 THREE size = $aa free = 853
      2  64aa					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  64aa				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  64aa				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  64aa				  -	      ERR
      6  64aa					      ENDIF
      5  64aa					      ENDIF
    335  64aa
    336  64aa							;---------------------------------------------------------------------------------------------------
    337  64aa							; EOF
------- FILE ./chess.asm
------- FILE @3 SCREEN ROM.asm LEVEL 2 PASS 4
      0  64aa					      include	"@3 SCREEN ROM.asm"
      1  64aa
      0  64aa					      SLOT	3
      1  64aa
      2  64aa				  -	      IF	(3 < 0) || (3 > 3)
      3  64aa				  -	      ECHO	"Illegal bank address/segment location", 3
      4  64aa				  -	      ERR
      5  64aa					      ENDIF
      6  64aa
      7  64aa				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  64aa				   _BANK_SLOT SET	3 * 64
      9  64aa
      0  64aa					      ROMBANK	ROM_SCREEN
      1  6ac6 ????				      SEG	ROM_ROM_SCREEN
      2  6800					      ORG	_ORIGIN
      3  6800					      RORG	_BANK_ADDRESS_ORIGIN
      4  6800				   _BANK_START SET	*
      5  6800				   ROM_SCREEN_START SET	*
      6  6800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6800				   ROMBANK_ROM_SCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  6800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6800				   _LAST_BANK SETSTR	ROM_SCREEN
     10  6800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      4  6800
      5  6800							;---------------------------------------------------------------------------------------------------
      6  6800
      0  6800					      DEF	ClearRowBitmap
      1  6800				   SLOT_ClearRowBitmap SET	_BANK_SLOT
      2  6800				   BANK_ClearRowBitmap SET	SLOT_ClearRowBitmap + _CURRENT_BANK
      3  6800				   ClearRowBitmap
      4  6800				   TEMPORARY_VAR SET	Overlay
      5  6800				   TEMPORARY_OFFSET SET	0
      6  6800				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      7  6800				   FUNCTION_NAME SET	ClearRowBitmap
      8  6800					      SUBROUTINE
      9  6800
      0  6800					      REF	aiClearEachRow
      1  6800					      IF	VAREND_aiClearEachRow > TEMPORARY_VAR
      2  6800				   TEMPORARY_VAR SET	VAREND_aiClearEachRow
      3  6800					      ENDIF
      0  6800					      VEND	ClearRowBitmap
      1  6800
      2  6800
      3  6800		       00 a8	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
      4  6800
     12  6800
     13  6800							; No transient variable dependencies/calls
     14  6800
     15  6800		       a9 00		      lda	#0
     16  6802		       a8		      tay
      0  6803				   .clearRow  sta@RAM	ChessBitmap,y
      1  6803		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
     18  6806		       c8		      iny
     19  6807		       c0 90		      cpy	#ROW_BITMAP_SIZE
     20  6809		       d0 f8		      bne	.clearRow
     21  680b		       60		      rts
     22  680c
     23  680c
     24  680c							;---------------------------------------------------------------------------------------------------
     25  680c
      0  680c					      DEF	WriteBlank
      1  680c				   SLOT_WriteBlank SET	_BANK_SLOT
      2  680c				   BANK_WriteBlank SET	SLOT_WriteBlank + _CURRENT_BANK
      3  680c				   WriteBlank
      4  680c				   TEMPORARY_VAR SET	Overlay
      5  680c				   TEMPORARY_OFFSET SET	0
      6  680c				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      7  680c				   FUNCTION_NAME SET	WriteBlank
     27  680c					      SUBROUTINE
     28  680c
      0  680c					      REF	StartupBankReset	;✅
      1  680c				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  680c				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  680c					      ENDIF
      0  680c					      VEND	WriteBlank
      1  680c
      2  680c
      3  680c		       00 a6	   VAREND_WriteBlank =	TEMPORARY_VAR
      4  680c
     31  680c
     32  680c		       a9 90		      lda	#<BlankSprite
      0  680e					      sta@RAM	SMSPRITE0_0+1
      1  680e		       8d e6 fa 	      sta	[RAM]+SMSPRITE0_0+1
      0  6811					      sta@RAM	SMSPRITE8_0+1
      1  6811		       8d 17 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  6814					      sta@RAM	SMSPRITE16_0+1
      1  6814		       8d a8 fa 	      sta	[RAM]+SMSPRITE16_0+1
      0  6817					      sta@RAM	SMSPRITE0_1+1
      1  6817		       8d eb fa 	      sta	[RAM]+SMSPRITE0_1+1
      0  681a					      sta@RAM	SMSPRITE8_1+1
      1  681a		       8d 1c fb 	      sta	[RAM]+SMSPRITE8_1+1
      0  681d					      sta@RAM	SMSPRITE16_1+1
      1  681d		       8d ad fa 	      sta	[RAM]+SMSPRITE16_1+1
     39  6820
     40  6820		       a9 f8		      lda	#>BlankSprite
      0  6822					      sta@RAM	SMSPRITE0_0+2
      1  6822		       8d e7 fa 	      sta	[RAM]+SMSPRITE0_0+2
      0  6825					      sta@RAM	SMSPRITE8_0+2
      1  6825		       8d 18 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  6828					      sta@RAM	SMSPRITE16_0+2
      1  6828		       8d a9 fa 	      sta	[RAM]+SMSPRITE16_0+2
      0  682b					      sta@RAM	SMSPRITE0_1+2
      1  682b		       8d ec fa 	      sta	[RAM]+SMSPRITE0_1+2
      0  682e					      sta@RAM	SMSPRITE8_1+2
      1  682e		       8d 1d fb 	      sta	[RAM]+SMSPRITE8_1+2
      0  6831					      sta@RAM	SMSPRITE16_1+2
      1  6831		       8d ae fa 	      sta	[RAM]+SMSPRITE16_1+2
     47  6834
     48  6834		       60		      rts
     49  6835
     50  6835
     51  6835							;---------------------------------------------------------------------------------------------------
     52  6835
      0  6835					      DEF	WriteCursor
      1  6835				   SLOT_WriteCursor SET	_BANK_SLOT
      2  6835				   BANK_WriteCursor SET	SLOT_WriteCursor + _CURRENT_BANK
      3  6835				   WriteCursor
      4  6835				   TEMPORARY_VAR SET	Overlay
      5  6835				   TEMPORARY_OFFSET SET	0
      6  6835				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      7  6835				   FUNCTION_NAME SET	WriteCursor
     54  6835					      SUBROUTINE
     55  6835
      0  6835					      REF	StartupBankReset	;✅
      1  6835				  -	      IF	VAREND_StartupBankReset > TEMPORARY_VAR
      2  6835				  -TEMPORARY_VAR SET	VAREND_StartupBankReset
      3  6835					      ENDIF
      0  6835					      VEND	WriteCursor
      1  6835
      2  6835
      3  6835		       00 a6	   VAREND_WriteCursor =	TEMPORARY_VAR
      4  6835
     58  6835
     59  6835		       38		      sec
     60  6836		       a5 89		      lda	cursorX12
     61  6838		       30 22		      bmi	.exit
     62  683a		       a2 0a		      ldx	#10
     63  683c		       e9 0a	   .sub10     sbc	#10
     64  683e		       ca		      dex
     65  683f		       b0 fb		      bcs	.sub10
     66  6841
     67  6841		       8a		      txa
     68  6842		       69 80		      adc	#SLOT_DrawRow	;cc implied
     69  6844		       85 3e		      sta	SET_BANK_RAM
     70  6846
     71  6846		       a9 98		      lda	#<SpriteBuffer
      0  6848					      sta@RAM	SMSPRITE0_0+1
      1  6848		       8d e6 fa 	      sta	[RAM]+SMSPRITE0_0+1
      0  684b					      sta@RAM	SMSPRITE8_0+1
      1  684b		       8d 17 fb 	      sta	[RAM]+SMSPRITE8_0+1
      0  684e					      sta@RAM	SMSPRITE16_0+1
      1  684e		       8d a8 fa 	      sta	[RAM]+SMSPRITE16_0+1
     75  6851		       a9 f8		      lda	#>SpriteBuffer
      0  6853					      sta@RAM	SMSPRITE0_0+2
      1  6853		       8d e7 fa 	      sta	[RAM]+SMSPRITE0_0+2
      0  6856					      sta@RAM	SMSPRITE8_0+2
      1  6856		       8d 18 fb 	      sta	[RAM]+SMSPRITE8_0+2
      0  6859					      sta@RAM	SMSPRITE16_0+2
      1  6859		       8d a9 fa 	      sta	[RAM]+SMSPRITE16_0+2
     79  685c
     80  685c		       60	   .exit      rts
     81  685d
     82  685d
     83  685d							;---------------------------------------------------------------------------------------------------
     84  685d
      0  685d					      DEF	BackupBitmaps
      1  685d				   SLOT_BackupBitmaps SET	_BANK_SLOT
      2  685d				   BANK_BackupBitmaps SET	SLOT_BackupBitmaps + _CURRENT_BANK
      3  685d				   BackupBitmaps
      4  685d				   TEMPORARY_VAR SET	Overlay
      5  685d				   TEMPORARY_OFFSET SET	0
      6  685d				   VAR_BOUNDARY_BackupBitmaps SET	TEMPORARY_OFFSET
      7  685d				   FUNCTION_NAME SET	BackupBitmaps
     86  685d					      SUBROUTINE
     87  685d
     88  685d							; drawCount = ROW# (0-7)
     89  685d
      0  685d					      REF	aiInCheckBackup
      1  685d					      IF	VAREND_aiInCheckBackup > TEMPORARY_VAR
      2  685d				   TEMPORARY_VAR SET	VAREND_aiInCheckBackup
      3  685d					      ENDIF
      0  685d					      VEND	BackupBitmaps
      1  685d
      2  685d
      3  685d		       00 a8	   VAREND_BackupBitmaps =	TEMPORARY_VAR
      4  685d
     92  685d
     93  685d							; switch in in ROW bitmap to RAM
     94  685d
     95  685d		       a5 85		      lda	drawCount
     96  685f		       09 80		      ora	#SLOT2
     97  6861		       85 3e		      sta	SET_BANK_RAM	;@2
     98  6863
     99  6863							; save bitmap data to backup
    100  6863
    101  6863		       a0 00		      ldy	#0
      0  6865				   .fromTo    lda@RAM	ChessBitmap,y
      1  6865		       b9 00 f8 	      lda	ChessBitmap,y
      0  6868					      sta@RAM	BackupBitmap,y
      1  6868		       99 49 fb 	      sta	[RAM]+BackupBitmap,y
    104  686b
    105  686b							;lda #255
    106  686b							;sta@RAM ChessBitmap,y
    107  686b
    108  686b		       c8		      iny
    109  686c		       c0 90		      cpy	#ROW_BITMAP_SIZE
    110  686e		       d0 f5		      bne	.fromTo
    111  6870		       60		      rts
    112  6871
    113  6871
    114  6871							;---------------------------------------------------------------------------------------------------
    115  6871
      0  6871					      DEF	RestoreBitmaps
      1  6871				   SLOT_RestoreBitmaps SET	_BANK_SLOT
      2  6871				   BANK_RestoreBitmaps SET	SLOT_RestoreBitmaps + _CURRENT_BANK
      3  6871				   RestoreBitmaps
      4  6871				   TEMPORARY_VAR SET	Overlay
      5  6871				   TEMPORARY_OFFSET SET	0
      6  6871				   VAR_BOUNDARY_RestoreBitmaps SET	TEMPORARY_OFFSET
      7  6871				   FUNCTION_NAME SET	RestoreBitmaps
    117  6871					      SUBROUTINE
    118  6871
      0  6871					      VEND	RestoreBitmaps
      1  6871
      2  6871
      3  6871		       00 a6	   VAREND_RestoreBitmaps =	TEMPORARY_VAR
      4  6871
    120  6871
    121  6871							; switch in in ROW bitmap to RAM
    122  6871
    123  6871		       a5 85		      lda	drawCount
    124  6873		       09 80		      ora	#SLOT2
    125  6875		       85 3e		      sta	SET_BANK_RAM	;@2
    126  6877
    127  6877							; copy backup bitmap back to origin
    128  6877
    129  6877		       a0 00		      ldy	#0
      0  6879				   .fromTo    lda@RAM	BackupBitmap,y
      1  6879		       b9 49 f9 	      lda	BackupBitmap,y
      0  687c					      sta@RAM	ChessBitmap,y
      1  687c		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    132  687f		       c8		      iny
    133  6880		       c0 90		      cpy	#ROW_BITMAP_SIZE
    134  6882		       d0 f5		      bne	.fromTo
    135  6884
    136  6884		       60		      rts
    137  6885
    138  6885
    139  6885							;---------------------------------------------------------------------------------------------------
    140  6885
    141  6885				  -	      IF	0
    142  6885				  -
    143  6885				  -	      DEF	CopyTextToRowBitmap
    144  6885				  -	      SUBROUTINE
    145  6885				  -
    146  6885				  -	      VEND	CopyTextToRowBitmap
    147  6885				  -
    148  6885				  -			; An OR-draw, used for placing matricies/text onscreen
    149  6885				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    150  6885				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    151  6885				  -			; in original state once text disappears
    152  6885				  -
    153  6885				  -	      ldy	#PIECE_SHAPE_SIZE-1
    154  6885				  -	      bcs	.rightSide
    155  6885				  -
    156  6885				  -.copy      lda	__pieceShapeBuffer,y
    157  6885				  -	      ora	ChessBitmap,y
    158  6885				  -	      sta@RAM	ChessBitmap,y
    159  6885				  -	      dey
    160  6885				  -	      bpl	.copy
    161  6885				  -
    162  6885				  -	      rts
    163  6885				  -
    164  6885				  -.rightSide
    165  6885				  -
    166  6885				  -	      SUBROUTINE
    167  6885				  -
    168  6885				  -.copy      lda	__pieceShapeBuffer,y
    169  6885				  -	      ora	ChessBitmap+PIECE_SHAPE_SIZE,y
    170  6885				  -	      sta@RAM	ChessBitmap+PIECE_SHAPE_SIZE,y
    171  6885				  -	      dey
    172  6885				  -	      bpl	.copy
    173  6885				  -
    174  6885				  -	      rts
    175  6885				  -
    176  6885					      ENDIF
    177  6885
    178  6885							;---------------------------------------------------------------------------------------------------
    179  6885
      0  6885					      DEF	aiMaskBitmapBackground
      1  6885				   SLOT_aiMaskBitmapBackground SET	_BANK_SLOT
      2  6885				   BANK_aiMaskBitmapBackground SET	SLOT_aiMaskBitmapBackground + _CURRENT_BANK
      3  6885				   aiMaskBitmapBackground
      4  6885				   TEMPORARY_VAR SET	Overlay
      5  6885				   TEMPORARY_OFFSET SET	0
      6  6885				   VAR_BOUNDARY_aiMaskBitmapBackground SET	TEMPORARY_OFFSET
      7  6885				   FUNCTION_NAME SET	aiMaskBitmapBackground
    181  6885					      SUBROUTINE
    182  6885
    183  6885							; Remove any unwanted background via mask
    184  6885
      0  6885					      REF	AiStateMachine
      1  6885					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  6885				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  6885					      ENDIF
      0  6885					      VAR	_tt,1
      1  6885		       00 a8	   _tt	      =	TEMPORARY_VAR
      2  6885				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6885
      4  6885				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6885				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6885				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6885					      ENDIF
      8  6885				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  6885				  -VNAME      SETSTR	_tt
     10  6885				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  6885				  -	      ERR
     12  6885					      ENDIF
      0  6885					      VAR	_mask, 2
      1  6885		       00 a9	   _mask      =	TEMPORARY_VAR
      2  6885				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6885
      4  6885				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6885				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6885				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6885					      ENDIF
      8  6885				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  6885				  -VNAME      SETSTR	_mask
     10  6885				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  6885				  -	      ERR
     12  6885					      ENDIF
      0  6885					      VAR	_mask2, 2
      1  6885		       00 ab	   _mask2     =	TEMPORARY_VAR
      2  6885				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6885
      4  6885				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6885				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6885				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6885					      ENDIF
      8  6885				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  6885				  -VNAME      SETSTR	_mask2
     10  6885				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  6885				  -	      ERR
     12  6885					      ENDIF
      0  6885					      VEND	aiMaskBitmapBackground
      1  6885
      2  6885
      3  6885		       00 ad	   VAREND_aiMaskBitmapBackground =	TEMPORARY_VAR
      4  6885
    190  6885
    191  6885		       c6 85		      dec	drawCount
    192  6887		       30 34		      bmi	.next
    193  6889
    194  6889		       a5 85		      lda	drawCount
    195  688b		       09 80		      ora	#SLOT2
    196  688d		       85 3e		      sta	SET_BANK_RAM
    197  688f
    198  688f		       a9 9c		      lda	#BANK_BitmapShapeLO
    199  6891		       85 3f		      sta	SET_BANK	;@2
    200  6893
    201  6893		       a0 00		      ldy	#0	; hardwired bitmap shape #
    202  6895
    203  6895		       b9 00 f8 	      lda	BitmapShapeLO,y
    204  6898		       85 a9		      sta	_mask
    205  689a		       b9 02 f8 	      lda	BitmapShapeHI,y
    206  689d		       85 aa		      sta	_mask+1
    207  689f
    208  689f		       a4 85		      ldy	drawCount	; row
    209  68a1		       b1 a9		      lda	(_mask),y
    210  68a3		       c9 ff		      cmp	#-1
    211  68a5		       f0 15		      beq	.exit	; no mask for this row
    212  68a7
    213  68a7
    214  68a7
    215  68a7		       a9 16		      lda	#<SampleBitmap
    216  68a9		       85 a9		      sta	_mask
    217  68ab		       a9 fd		      lda	#>SampleBitmap
    218  68ad		       85 aa		      sta	_mask+1
    219  68af
    220  68af		       a0 8f		      ldy	#ROW_BITMAP_SIZE-1
    221  68b1		       b1 a9	   .draw      lda	(_mask),y
      0  68b3					      and@RAM	ChessBitmap,y
      1  68b3		       39 00 f8 	      and	ChessBitmap,y
      0  68b6					      sta@RAM	ChessBitmap,y
      1  68b6		       99 00 fa 	      sta	[RAM]+ChessBitmap,y
    224  68b9
    225  68b9		       88		      dey
    226  68ba		       10 f5		      bpl	.draw
    227  68bc		       60	   .exit      rts
    228  68bd
    229  68bd
    230  68bd				   .next
    231  68bd		       a9 08		      lda	#8
    232  68bf		       85 85		      sta	drawCount	; ROW
    233  68c1
      0  68c1				   .noButton  PHASE	DrawBitmap2
      1  68c1		       a9 30		      lda	#AI_DrawBitmap2
      2  68c3		       85 8c		      sta	aiState
    235  68c5		       60		      rts
    236  68c6
      0  68c6				   pwb	      PHASE	WaitBitmap
      1  68c6		       a9 2e		      lda	#AI_WaitBitmap
      2  68c8		       85 8c		      sta	aiState
    238  68ca		       60		      rts
    239  68cb
    240  68cb
      0  68cb					      DEF	aiDrawBitmap2
      1  68cb				   SLOT_aiDrawBitmap2 SET	_BANK_SLOT
      2  68cb				   BANK_aiDrawBitmap2 SET	SLOT_aiDrawBitmap2 + _CURRENT_BANK
      3  68cb				   aiDrawBitmap2
      4  68cb				   TEMPORARY_VAR SET	Overlay
      5  68cb				   TEMPORARY_OFFSET SET	0
      6  68cb				   VAR_BOUNDARY_aiDrawBitmap2 SET	TEMPORARY_OFFSET
      7  68cb				   FUNCTION_NAME SET	aiDrawBitmap2
    242  68cb					      SUBROUTINE
    243  68cb
      0  68cb					      REF	AiStateMachine
      1  68cb					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  68cb				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  68cb					      ENDIF
      0  68cb					      VEND	aiDrawBitmap2
      1  68cb
      2  68cb
      3  68cb		       00 a8	   VAREND_aiDrawBitmap2 =	TEMPORARY_VAR
      4  68cb
    246  68cb
    247  68cb		       c6 85		      dec	drawCount
    248  68cd		       30 1e		      bmi	.next
    249  68cf
    250  68cf		       a5 85		      lda	drawCount
    251  68d1		       09 80		      ora	#SLOT2
    252  68d3		       85 3e		      sta	SET_BANK_RAM
    253  68d5
    254  68d5
    255  68d5		       a2 47		      ldx	#ROW_BITMAP_SIZE/2-1
    256  68d7
    257  68d7		       bd a6 fd    .draw      lda	SampleBitmap2,x
      0  68da					      ora@RAM	ChessBitmap,x
      1  68da		       1d 00 f8 	      ora	ChessBitmap,x
      0  68dd					      sta@RAM	ChessBitmap,x
      1  68dd		       9d 00 fa 	      sta	[RAM]+ChessBitmap,x
    260  68e0
    261  68e0		       bd ee fd 	      lda	SampleBitmap2+ROW_BITMAP_SIZE/2,x
      0  68e3					      ora@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  68e3		       1d 48 f8 	      ora	ChessBitmap+ROW_BITMAP_SIZE/2,x
      0  68e6					      sta@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  68e6		       9d 48 fa 	      sta	[RAM]+ChessBitmap+ROW_BITMAP_SIZE/2,x
    264  68e9
    265  68e9		       ca		      dex
    266  68ea		       10 eb		      bpl	.draw
    267  68ec		       60		      rts
    268  68ed
      0  68ed				   .next      PHASE	WaitBitmap
      1  68ed		       a9 2e		      lda	#AI_WaitBitmap
      2  68ef		       85 8c		      sta	aiState
    270  68f1		       60		      rts
    271  68f2
      0  68f2					      DEF	aiDrawBitmap3
      1  68f2				   SLOT_aiDrawBitmap3 SET	_BANK_SLOT
      2  68f2				   BANK_aiDrawBitmap3 SET	SLOT_aiDrawBitmap3 + _CURRENT_BANK
      3  68f2				   aiDrawBitmap3
      4  68f2				   TEMPORARY_VAR SET	Overlay
      5  68f2				   TEMPORARY_OFFSET SET	0
      6  68f2				   VAR_BOUNDARY_aiDrawBitmap3 SET	TEMPORARY_OFFSET
      7  68f2				   FUNCTION_NAME SET	aiDrawBitmap3
    273  68f2					      SUBROUTINE
    274  68f2
      0  68f2					      REF	AiStateMachine
      1  68f2					      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  68f2				   TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  68f2					      ENDIF
      0  68f2					      VEND	aiDrawBitmap3
      1  68f2
      2  68f2
      3  68f2		       00 a8	   VAREND_aiDrawBitmap3 =	TEMPORARY_VAR
      4  68f2
    277  68f2
    278  68f2
    279  68f2		       a9 84		      lda	#SLOT2|4
    280  68f4		       85 3e		      sta	SET_BANK_RAM
    281  68f6
    282  68f6
    283  68f6		       a2 47		      ldx	#ROW_BITMAP_SIZE/2-1
    284  68f8
    285  68f8		       bd a6 fd    .draw      lda	SampleBitmap3,x
      0  68fb					      ora@RAM	ChessBitmap,x
      1  68fb		       1d 00 f8 	      ora	ChessBitmap,x
      0  68fe					      sta@RAM	ChessBitmap,x
      1  68fe		       9d 00 fa 	      sta	[RAM]+ChessBitmap,x
    288  6901
    289  6901		       bd ee fd 	      lda	SampleBitmap3+ROW_BITMAP_SIZE/2,x
      0  6904					      ora@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  6904		       1d 48 f8 	      ora	ChessBitmap+ROW_BITMAP_SIZE/2,x
      0  6907					      sta@RAM	ChessBitmap+ROW_BITMAP_SIZE/2,x
      1  6907		       9d 48 fa 	      sta	[RAM]+ChessBitmap+ROW_BITMAP_SIZE/2,x
    292  690a
    293  690a							;		      lda SampleBitmap,y
    294  690a							;		      ora@RAM ChessBitmap+6,x
    295  690a							;		      sta@RAM ChessBitmap+6,x
    296  690a
    297  690a							;		      lda SampleBitmap,y
    298  690a							;		      ora@RAM ChessBitmap+12,x
    299  690a							;		      sta@RAM ChessBitmap+12,x
    300  690a
    301  690a							;		      iny
    302  690a
    303  690a		       ca		      dex
    304  690b		       10 eb		      bpl	.draw
    305  690d
    306  690d
    307  690d
      0  690d					      PHASE	WaitBitmap
      1  690d		       a9 2e		      lda	#AI_WaitBitmap
      2  690f		       85 8c		      sta	aiState
    309  6911							;PHASE DrawBitmap
    310  6911		       60		      rts
    311  6912
    312  6912
      0  6912					      DEF	Phaser
      1  6912				   SLOT_Phaser SET	_BANK_SLOT
      2  6912				   BANK_Phaser SET	SLOT_Phaser + _CURRENT_BANK
      3  6912				   Phaser
      4  6912				   TEMPORARY_VAR SET	Overlay
      5  6912				   TEMPORARY_OFFSET SET	0
      6  6912				   VAR_BOUNDARY_Phaser SET	TEMPORARY_OFFSET
      7  6912				   FUNCTION_NAME SET	Phaser
    314  6912		       00 01 02 03	      .byte.b	0, 1, 2, 3
    315  6916
    316  6916
      0  6916					      DEF	SampleBitmap
      1  6916				   SLOT_SampleBitmap SET	_BANK_SLOT
      2  6916				   BANK_SampleBitmap SET	SLOT_SampleBitmap + _CURRENT_BANK
      3  6916				   SampleBitmap
      4  6916				   TEMPORARY_VAR SET	Overlay
      5  6916				   TEMPORARY_OFFSET SET	0
      6  6916				   VAR_BOUNDARY_SampleBitmap SET	TEMPORARY_OFFSET
      7  6916				   FUNCTION_NAME SET	SampleBitmap
    318  6916
    319  6916
    320  6916							; line 7,6,5,4,3,2,1,0
    321  6916							; R/G/B on successive lines
    322  6916							; PF0/PF1/PF2/PF0/PF1/PF2
    323  6916							; x axis goes downwards
    324  6916
    325  6916
    326  6916		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    327  691c		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    328  6922		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    329  6928		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    330  692e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    331  6934		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    332  693a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    333  6940		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    334  6946		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    335  694c		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    336  6952		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    337  6958		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    338  695e		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    339  6964		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    340  696a		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    341  6970		       ff ff 00 00*	      .byte.b	%11111111,%11111111,%00000000,%00000000,%00000000,%00000000
    342  6976		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    343  697c		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    344  6982		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    345  6988		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    346  698e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    347  6994		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    348  699a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    349  69a0		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
    350  69a6
    351  69a6
    352  69a6
    353  69a6
      0  69a6					      DEF	SampleBitmap2
      1  69a6				   SLOT_SampleBitmap2 SET	_BANK_SLOT
      2  69a6				   BANK_SampleBitmap2 SET	SLOT_SampleBitmap2 + _CURRENT_BANK
      3  69a6				   SampleBitmap2
      4  69a6				   TEMPORARY_VAR SET	Overlay
      5  69a6				   TEMPORARY_OFFSET SET	0
      6  69a6				   VAR_BOUNDARY_SampleBitmap2 SET	TEMPORARY_OFFSET
      7  69a6				   FUNCTION_NAME SET	SampleBitmap2
      0  69a6					      DEF	SampleBitmap3
      1  69a6				   SLOT_SampleBitmap3 SET	_BANK_SLOT
      2  69a6				   BANK_SampleBitmap3 SET	SLOT_SampleBitmap3 + _CURRENT_BANK
      3  69a6				   SampleBitmap3
      4  69a6				   TEMPORARY_VAR SET	Overlay
      5  69a6				   TEMPORARY_OFFSET SET	0
      6  69a6				   VAR_BOUNDARY_SampleBitmap3 SET	TEMPORARY_OFFSET
      7  69a6				   FUNCTION_NAME SET	SampleBitmap3
    356  69a6
    357  69a6							; line 7,6,5,4,3,2,1,0
    358  69a6							; R/G/B on successive lines
    359  69a6							; PF0/PF1/PF2/PF0/PF1/PF2
    360  69a6							; x axis goes downwards
    361  69a6
    362  69a6							;     7	 6	   5	     4	       3	 2	   1	     0
    363  69a6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R PF0 left
    364  69ae		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    365  69b6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
    366  69be
    367  69be		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    368  69c6		       64 94 84 84*	      .byte.b	%01100100,%10010100,%10000100,%10000100,%10000111,%10000100,%10010100,%01100100	;B
    369  69ce		       64 94 84 84*	      .byte.b	%01100100,%10010100,%10000100,%10000100,%10000111,%10000100,%10010100,%01100100	;B
    370  69d6
    371  69d6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    372  69de		       3d 85 85 85*	      .byte.b	%00111101,%10000101,%10000101,%10000101,%10011101,%10000101,%10000101,%00111101
    373  69e6		       3d 85 85 85*	      .byte.b	%00111101,%10000101,%10000101,%10000101,%10011101,%10000101,%10000101,%00111101
    374  69ee
    375  69ee		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    376  69f6		       30 01 81 01*	      .byte.b	%00110000,%00000001,%10000001,%00000001,%00000001,%00000001,%00001111,%00110000
    377  69fe		       30 01 81 01*	      .byte.b	%00110000,%00000001,%10000001,%00000001,%00000001,%00000001,%00001111,%00110000
    378  6a06
    379  6a06		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    380  6a0e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    381  6a16		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    382  6a1e
    383  6a1e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    384  6a26		       81 00 81 01*	      .byte.b	%10000001,%00000000,%10000001,%00000001,%00000001,%00000001,%00000001,%00000001
    385  6a2e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    386  6a36
    387  6a36
    388  6a36
    389  6a36							; line 7,6,5,4,3,2,1,0
    390  6a36							; R/G/B on successive lines
    391  6a36							; PF0/PF1/PF2/PF0/PF1/PF2
    392  6a36							; x axis goes downwards
    393  6a36
    394  6a36							;     7	 6	   5	     4	       3	 2	   1	     0
    395  6a36		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R PF0 left
    396  6a3e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    397  6a46		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
    398  6a4e
    399  6a4e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    400  6a56		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    401  6a5e		       64 94 84 84*	      .byte.b	%01100100,%10010100,%10000100,%10000100,%10000111,%10000100,%10010100,%01100100	;B
    402  6a66
    403  6a66		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    404  6a6e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    405  6a76		       3d 85 85 85*	      .byte.b	%00111101,%10000101,%10000101,%10000101,%10011101,%10000101,%10000101,%00111101
    406  6a7e
    407  6a7e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    408  6a86		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    409  6a8e		       30 01 81 01*	      .byte.b	%00110000,%00000001,%10000001,%00000001,%00000001,%00000001,%00001111,%00110000
    410  6a96
    411  6a96		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;PF1
    412  6a9e		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    413  6aa6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000
    414  6aae
    415  6aae		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    416  6ab6		       00 00 00 00*	      .byte.b	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;G
    417  6abe		       81 00 81 01*	      .byte.b	%10000001,%00000000,%10000001,%00000001,%00000001,%00000001,%00000001,%00000001
    418  6ac6
    419  6ac6
    420  6ac6
    421  6ac6
    422  6ac6
    423  6ac6
    424  6ac6							;---------------------------------------------------------------------------------------------------
    425  6ac6
      0  6ac6					      END_BANK
      1  6ac6				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  6ac6				  -	      CHECK_RAM_BANK_SIZE
      3  6ac6					      ELSE
      0  6ac6					      CHECK_BANK_SIZE
      1  6ac6		       02 c6	   .TEMP      =	* - _BANK_START
 ROM bank # 27 ROM_SCREEN size = $2c6 free = 313
      2  6ac6					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  6ac6				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6ac6				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  6ac6				  -	      ERR
      6  6ac6					      ENDIF
      5  6ac6					      ENDIF
    427  6ac6
    428  6ac6							;---------------------------------------------------------------------------------------------------
    429  6ac6							;EOF
------- FILE ./chess.asm
------- FILE @3 EVALUATE.asm LEVEL 2 PASS 4
      0  6ac6					      include	"@3 EVALUATE.asm"
      1  6ac6							;---------------------------------------------------------------------------------------------------
      2  6ac6							; @3 EVALUATE.asm
      3  6ac6
      4  6ac6							; Atari 2600 Chess
      5  6ac6							; Copyright (c) 2019-2020 Andrew Davie
      6  6ac6							; andrew@taswegian.com
      7  6ac6
      8  6ac6
      9  6ac6							;---------------------------------------------------------------------------------------------------
     10  6ac6
      0  6ac6					      SLOT	3
      1  6ac6
      2  6ac6				  -	      IF	(3 < 0) || (3 > 3)
      3  6ac6				  -	      ECHO	"Illegal bank address/segment location", 3
      4  6ac6				  -	      ERR
      5  6ac6					      ENDIF
      6  6ac6
      7  6ac6				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  6ac6				   _BANK_SLOT SET	3 * 64
      9  6ac6
      0  6ac6					      RAMBANK	EVALUATE
      1  6ac6
      2 U2c00 ????				      SEG.U	RAM_EVALUATE
      3 U2c00					      ORG	ORIGIN_RAM
      4 U2c00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2c00				   _BANK_START SET	*
      6 U2c00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2c00				   RAMBANK_EVALUATE SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2c00				   _LAST_BANK SETSTR	EVALUATE
     10 U2c00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      0 U2c00					      END_BANK
      1 U2c00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2c00					      CHECK_RAM_BANK_SIZE
      1 U2c00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 23 EVALUATE size =  $0 free = $1ff
      2 U2c00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2c00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2c00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2c00				  -	      ERR
      6 U2c00					      ENDIF
      3 U2c00				  -	      ELSE
      4 U2c00				  -	      CHECK_BANK_SIZE
      5 U2c00					      ENDIF
     14 U2c00
     15 U2c00
     16 U2c00							;---------------------------------------------------------------------------------------------------
     17 U2c00
      0 U2c00					      ROMBANK	EVALUATE
      1  6e40 ????				      SEG	ROM_EVALUATE
      2  6c00					      ORG	_ORIGIN
      3  6c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  6c00				   _BANK_START SET	*
      5  6c00				   EVALUATE_START SET	*
      6  6c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  6c00				   ROMBANK_EVALUATE SET	_BANK_SLOT + _CURRENT_BANK
      8  6c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  6c00				   _LAST_BANK SETSTR	EVALUATE
     10  6c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     19  6c00
     20  6c00
     21  6c00							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
     22  6c00
     23  6c00
     24  6c00							;ds 22
     25  6c00
     26  6c00							;---------------------------------------------------------------------------------------------------
     27  6c00							; Vectors to the position value tables for each piece
     28  6c00
     29  6c00							;---------------------------------------------------------------------------------------------------
     30  6c00							; Vectors to the position value tables for each piece
     31  6c00
     32  6c00					      MAC	posval
     33  6c00					      .byte	0
     34  6c00					      .byte	{1}(PositionalValue_PAWN - 22)
     35  6c00					      .byte	{1}(PositionalValue_PAWN - 22)
     36  6c00					      .byte	{1}(PositionalValue_KNIGHT - 22)
     37  6c00					      .byte	{1}(PositionalValue_BISHOP - 22)
     38  6c00					      .byte	{1}(PositionalValue_ROOK - 22)
     39  6c00					      .byte	{1}(PositionalValue_QUEEN - 22)
     40  6c00					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
     41  6c00					      ENDM
     42  6c00
      0  6c00					      ALLOCATE	PosValVecLO, 8
      1  6c00
      2  6c00				   .NAME      SETSTR	PosValVecLO
      0  6c00					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  6c00
      2  6c00				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  6c00				  -.EARLY_LOCATION SET	*
      4  6c00				  -	      ALIGN	256
      5  6c00				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  6c00					      ENDIF
      0  6c00					      DEF	PosValVecLO
      1  6c00				   SLOT_PosValVecLO SET	_BANK_SLOT
      2  6c00				   BANK_PosValVecLO SET	SLOT_PosValVecLO + _CURRENT_BANK
      3  6c00				   PosValVecLO
      4  6c00				   TEMPORARY_VAR SET	Overlay
      5  6c00				   TEMPORARY_OFFSET SET	0
      6  6c00				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      7  6c00				   FUNCTION_NAME SET	PosValVecLO
      5  6c00
      0  6c00					      POSVAL	<
      1  6c00		       00		      .byte.b	0
      2  6c01		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      3  6c02		       fa		      .byte.b	<(PositionalValue_PAWN - 22)
      4  6c03		       4a		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  6c04		       9a		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  6c05		       ea		      .byte.b	<(PositionalValue_ROOK - 22)
      7  6c06		       3a		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  6c07		       8a		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  6c08					      ALLOCATE	PosValVecHI, 8
      1  6c08
      2  6c08				   .NAME      SETSTR	PosValVecHI
      0  6c08					      OPTIONAL_PAGEBREAK	.NAME, 8
      1  6c08
      2  6c08				  -	      IF	(>( * + 8 -1 )) > ( >* )
      3  6c08				  -.EARLY_LOCATION SET	*
      4  6c08				  -	      ALIGN	256
      5  6c08				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  6c08					      ENDIF
      0  6c08					      DEF	PosValVecHI
      1  6c08				   SLOT_PosValVecHI SET	_BANK_SLOT
      2  6c08				   BANK_PosValVecHI SET	SLOT_PosValVecHI + _CURRENT_BANK
      3  6c08				   PosValVecHI
      4  6c08				   TEMPORARY_VAR SET	Overlay
      5  6c08				   TEMPORARY_OFFSET SET	0
      6  6c08				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      7  6c08				   FUNCTION_NAME SET	PosValVecHI
      5  6c08
      0  6c08					      POSVAL	>
      1  6c08		       00		      .byte.b	0
      2  6c09		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      3  6c0a		       fb		      .byte.b	>(PositionalValue_PAWN - 22)
      4  6c0b		       fc		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  6c0c		       fc		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  6c0d		       fc		      .byte.b	>(PositionalValue_ROOK - 22)
      7  6c0e		       fd		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  6c0f		       fd		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
     47  6c10
     48  6c10
     49  6c10					      MAC	eval8
     50  6c10					      IF	({1} > 127) || ({1} < -128)
     51  6c10					      ECHO	"Erroneous position value", {1}
     52  6c10					      ERR
     53  6c10					      ENDIF
     54  6c10					      .byte	{1}
     55  6c10					      ENDM
     56  6c10
     57  6c10
     58  6c10					      MAC	pval
     59  6c10					      EVAL8	{1}
     60  6c10					      EVAL8	{2}
     61  6c10					      EVAL8	{3}
     62  6c10					      EVAL8	{4}
     63  6c10					      EVAL8	{5}
     64  6c10					      EVAL8	{6}
     65  6c10					      EVAL8	{7}
     66  6c10					      EVAL8	{8}
     67  6c10					      EVAL8	0
     68  6c10					      EVAL8	0
     69  6c10					      ENDM		;{ 10 entries }
     70  6c10
     71  6c10
     72  6c10							;---------------------------------------------------------------------------------------------------
     73  6c10
     74  6c10				   PositionalValue_PAWN
     75  6c10
      0  6c10					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  6c10					      EVAL8	0
      1  6c10				  -	      IF	(0 > 127) || (0 < -128)
      2  6c10				  -	      ECHO	"Erroneous position value", 0
      3  6c10				  -	      ERR
      4  6c10					      ENDIF
      5  6c10		       00		      .byte.b	0
      0  6c11					      EVAL8	0
      1  6c11				  -	      IF	(0 > 127) || (0 < -128)
      2  6c11				  -	      ECHO	"Erroneous position value", 0
      3  6c11				  -	      ERR
      4  6c11					      ENDIF
      5  6c11		       00		      .byte.b	0
      0  6c12					      EVAL8	0
      1  6c12				  -	      IF	(0 > 127) || (0 < -128)
      2  6c12				  -	      ECHO	"Erroneous position value", 0
      3  6c12				  -	      ERR
      4  6c12					      ENDIF
      5  6c12		       00		      .byte.b	0
      0  6c13					      EVAL8	0
      1  6c13				  -	      IF	(0 > 127) || (0 < -128)
      2  6c13				  -	      ECHO	"Erroneous position value", 0
      3  6c13				  -	      ERR
      4  6c13					      ENDIF
      5  6c13		       00		      .byte.b	0
      0  6c14					      EVAL8	0
      1  6c14				  -	      IF	(0 > 127) || (0 < -128)
      2  6c14				  -	      ECHO	"Erroneous position value", 0
      3  6c14				  -	      ERR
      4  6c14					      ENDIF
      5  6c14		       00		      .byte.b	0
      0  6c15					      EVAL8	0
      1  6c15				  -	      IF	(0 > 127) || (0 < -128)
      2  6c15				  -	      ECHO	"Erroneous position value", 0
      3  6c15				  -	      ERR
      4  6c15					      ENDIF
      5  6c15		       00		      .byte.b	0
      0  6c16					      EVAL8	0
      1  6c16				  -	      IF	(0 > 127) || (0 < -128)
      2  6c16				  -	      ECHO	"Erroneous position value", 0
      3  6c16				  -	      ERR
      4  6c16					      ENDIF
      5  6c16		       00		      .byte.b	0
      0  6c17					      EVAL8	0
      1  6c17				  -	      IF	(0 > 127) || (0 < -128)
      2  6c17				  -	      ECHO	"Erroneous position value", 0
      3  6c17				  -	      ERR
      4  6c17					      ENDIF
      5  6c17		       00		      .byte.b	0
      0  6c18					      EVAL8	0
      1  6c18				  -	      IF	(0 > 127) || (0 < -128)
      2  6c18				  -	      ECHO	"Erroneous position value", 0
      3  6c18				  -	      ERR
      4  6c18					      ENDIF
      5  6c18		       00		      .byte.b	0
      0  6c19					      EVAL8	0
      1  6c19				  -	      IF	(0 > 127) || (0 < -128)
      2  6c19				  -	      ECHO	"Erroneous position value", 0
      3  6c19				  -	      ERR
      4  6c19					      ENDIF
      5  6c19		       00		      .byte.b	0
      0  6c1a					      PVAL	15, 20, 0, -10, -10, 0, 20, 15
      0  6c1a					      EVAL8	15
      1  6c1a				  -	      IF	(15 > 127) || (15 < -128)
      2  6c1a				  -	      ECHO	"Erroneous position value", 15
      3  6c1a				  -	      ERR
      4  6c1a					      ENDIF
      5  6c1a		       0f		      .byte.b	15
      0  6c1b					      EVAL8	20
      1  6c1b				  -	      IF	(20 > 127) || (20 < -128)
      2  6c1b				  -	      ECHO	"Erroneous position value", 20
      3  6c1b				  -	      ERR
      4  6c1b					      ENDIF
      5  6c1b		       14		      .byte.b	20
      0  6c1c					      EVAL8	0
      1  6c1c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c1c				  -	      ECHO	"Erroneous position value", 0
      3  6c1c				  -	      ERR
      4  6c1c					      ENDIF
      5  6c1c		       00		      .byte.b	0
      0  6c1d					      EVAL8	-10
      1  6c1d				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6c1d				  -	      ECHO	"Erroneous position value", -10
      3  6c1d				  -	      ERR
      4  6c1d					      ENDIF
      5  6c1d		       f6		      .byte.b	-10
      0  6c1e					      EVAL8	-10
      1  6c1e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6c1e				  -	      ECHO	"Erroneous position value", -10
      3  6c1e				  -	      ERR
      4  6c1e					      ENDIF
      5  6c1e		       f6		      .byte.b	-10
      0  6c1f					      EVAL8	0
      1  6c1f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c1f				  -	      ECHO	"Erroneous position value", 0
      3  6c1f				  -	      ERR
      4  6c1f					      ENDIF
      5  6c1f		       00		      .byte.b	0
      0  6c20					      EVAL8	20
      1  6c20				  -	      IF	(20 > 127) || (20 < -128)
      2  6c20				  -	      ECHO	"Erroneous position value", 20
      3  6c20				  -	      ERR
      4  6c20					      ENDIF
      5  6c20		       14		      .byte.b	20
      0  6c21					      EVAL8	15
      1  6c21				  -	      IF	(15 > 127) || (15 < -128)
      2  6c21				  -	      ECHO	"Erroneous position value", 15
      3  6c21				  -	      ERR
      4  6c21					      ENDIF
      5  6c21		       0f		      .byte.b	15
      0  6c22					      EVAL8	0
      1  6c22				  -	      IF	(0 > 127) || (0 < -128)
      2  6c22				  -	      ECHO	"Erroneous position value", 0
      3  6c22				  -	      ERR
      4  6c22					      ENDIF
      5  6c22		       00		      .byte.b	0
      0  6c23					      EVAL8	0
      1  6c23				  -	      IF	(0 > 127) || (0 < -128)
      2  6c23				  -	      ECHO	"Erroneous position value", 0
      3  6c23				  -	      ERR
      4  6c23					      ENDIF
      5  6c23		       00		      .byte.b	0
      0  6c24					      PVAL	5, -5, 20, 0, 0, 20, -5, 5
      0  6c24					      EVAL8	5
      1  6c24				  -	      IF	(5 > 127) || (5 < -128)
      2  6c24				  -	      ECHO	"Erroneous position value", 5
      3  6c24				  -	      ERR
      4  6c24					      ENDIF
      5  6c24		       05		      .byte.b	5
      0  6c25					      EVAL8	-5
      1  6c25				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6c25				  -	      ECHO	"Erroneous position value", -5
      3  6c25				  -	      ERR
      4  6c25					      ENDIF
      5  6c25		       fb		      .byte.b	-5
      0  6c26					      EVAL8	20
      1  6c26				  -	      IF	(20 > 127) || (20 < -128)
      2  6c26				  -	      ECHO	"Erroneous position value", 20
      3  6c26				  -	      ERR
      4  6c26					      ENDIF
      5  6c26		       14		      .byte.b	20
      0  6c27					      EVAL8	0
      1  6c27				  -	      IF	(0 > 127) || (0 < -128)
      2  6c27				  -	      ECHO	"Erroneous position value", 0
      3  6c27				  -	      ERR
      4  6c27					      ENDIF
      5  6c27		       00		      .byte.b	0
      0  6c28					      EVAL8	0
      1  6c28				  -	      IF	(0 > 127) || (0 < -128)
      2  6c28				  -	      ECHO	"Erroneous position value", 0
      3  6c28				  -	      ERR
      4  6c28					      ENDIF
      5  6c28		       00		      .byte.b	0
      0  6c29					      EVAL8	20
      1  6c29				  -	      IF	(20 > 127) || (20 < -128)
      2  6c29				  -	      ECHO	"Erroneous position value", 20
      3  6c29				  -	      ERR
      4  6c29					      ENDIF
      5  6c29		       14		      .byte.b	20
      0  6c2a					      EVAL8	-5
      1  6c2a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6c2a				  -	      ECHO	"Erroneous position value", -5
      3  6c2a				  -	      ERR
      4  6c2a					      ENDIF
      5  6c2a		       fb		      .byte.b	-5
      0  6c2b					      EVAL8	5
      1  6c2b				  -	      IF	(5 > 127) || (5 < -128)
      2  6c2b				  -	      ECHO	"Erroneous position value", 5
      3  6c2b				  -	      ERR
      4  6c2b					      ENDIF
      5  6c2b		       05		      .byte.b	5
      0  6c2c					      EVAL8	0
      1  6c2c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c2c				  -	      ECHO	"Erroneous position value", 0
      3  6c2c				  -	      ERR
      4  6c2c					      ENDIF
      5  6c2c		       00		      .byte.b	0
      0  6c2d					      EVAL8	0
      1  6c2d				  -	      IF	(0 > 127) || (0 < -128)
      2  6c2d				  -	      ECHO	"Erroneous position value", 0
      3  6c2d				  -	      ERR
      4  6c2d					      ENDIF
      5  6c2d		       00		      .byte.b	0
      0  6c2e					      PVAL	5, 5, 10, 20, 40, 20, 5, 5
      0  6c2e					      EVAL8	5
      1  6c2e				  -	      IF	(5 > 127) || (5 < -128)
      2  6c2e				  -	      ECHO	"Erroneous position value", 5
      3  6c2e				  -	      ERR
      4  6c2e					      ENDIF
      5  6c2e		       05		      .byte.b	5
      0  6c2f					      EVAL8	5
      1  6c2f				  -	      IF	(5 > 127) || (5 < -128)
      2  6c2f				  -	      ECHO	"Erroneous position value", 5
      3  6c2f				  -	      ERR
      4  6c2f					      ENDIF
      5  6c2f		       05		      .byte.b	5
      0  6c30					      EVAL8	10
      1  6c30				  -	      IF	(10 > 127) || (10 < -128)
      2  6c30				  -	      ECHO	"Erroneous position value", 10
      3  6c30				  -	      ERR
      4  6c30					      ENDIF
      5  6c30		       0a		      .byte.b	10
      0  6c31					      EVAL8	20
      1  6c31				  -	      IF	(20 > 127) || (20 < -128)
      2  6c31				  -	      ECHO	"Erroneous position value", 20
      3  6c31				  -	      ERR
      4  6c31					      ENDIF
      5  6c31		       14		      .byte.b	20
      0  6c32					      EVAL8	40
      1  6c32				  -	      IF	(40 > 127) || (40 < -128)
      2  6c32				  -	      ECHO	"Erroneous position value", 40
      3  6c32				  -	      ERR
      4  6c32					      ENDIF
      5  6c32		       28		      .byte.b	40
      0  6c33					      EVAL8	20
      1  6c33				  -	      IF	(20 > 127) || (20 < -128)
      2  6c33				  -	      ECHO	"Erroneous position value", 20
      3  6c33				  -	      ERR
      4  6c33					      ENDIF
      5  6c33		       14		      .byte.b	20
      0  6c34					      EVAL8	5
      1  6c34				  -	      IF	(5 > 127) || (5 < -128)
      2  6c34				  -	      ECHO	"Erroneous position value", 5
      3  6c34				  -	      ERR
      4  6c34					      ENDIF
      5  6c34		       05		      .byte.b	5
      0  6c35					      EVAL8	5
      1  6c35				  -	      IF	(5 > 127) || (5 < -128)
      2  6c35				  -	      ECHO	"Erroneous position value", 5
      3  6c35				  -	      ERR
      4  6c35					      ENDIF
      5  6c35		       05		      .byte.b	5
      0  6c36					      EVAL8	0
      1  6c36				  -	      IF	(0 > 127) || (0 < -128)
      2  6c36				  -	      ECHO	"Erroneous position value", 0
      3  6c36				  -	      ERR
      4  6c36					      ENDIF
      5  6c36		       00		      .byte.b	0
      0  6c37					      EVAL8	0
      1  6c37				  -	      IF	(0 > 127) || (0 < -128)
      2  6c37				  -	      ECHO	"Erroneous position value", 0
      3  6c37				  -	      ERR
      4  6c37					      ENDIF
      5  6c37		       00		      .byte.b	0
      0  6c38					      PVAL	15, 15, 20, 40, 50, 20, 15, 15
      0  6c38					      EVAL8	15
      1  6c38				  -	      IF	(15 > 127) || (15 < -128)
      2  6c38				  -	      ECHO	"Erroneous position value", 15
      3  6c38				  -	      ERR
      4  6c38					      ENDIF
      5  6c38		       0f		      .byte.b	15
      0  6c39					      EVAL8	15
      1  6c39				  -	      IF	(15 > 127) || (15 < -128)
      2  6c39				  -	      ECHO	"Erroneous position value", 15
      3  6c39				  -	      ERR
      4  6c39					      ENDIF
      5  6c39		       0f		      .byte.b	15
      0  6c3a					      EVAL8	20
      1  6c3a				  -	      IF	(20 > 127) || (20 < -128)
      2  6c3a				  -	      ECHO	"Erroneous position value", 20
      3  6c3a				  -	      ERR
      4  6c3a					      ENDIF
      5  6c3a		       14		      .byte.b	20
      0  6c3b					      EVAL8	40
      1  6c3b				  -	      IF	(40 > 127) || (40 < -128)
      2  6c3b				  -	      ECHO	"Erroneous position value", 40
      3  6c3b				  -	      ERR
      4  6c3b					      ENDIF
      5  6c3b		       28		      .byte.b	40
      0  6c3c					      EVAL8	50
      1  6c3c				  -	      IF	(50 > 127) || (50 < -128)
      2  6c3c				  -	      ECHO	"Erroneous position value", 50
      3  6c3c				  -	      ERR
      4  6c3c					      ENDIF
      5  6c3c		       32		      .byte.b	50
      0  6c3d					      EVAL8	20
      1  6c3d				  -	      IF	(20 > 127) || (20 < -128)
      2  6c3d				  -	      ECHO	"Erroneous position value", 20
      3  6c3d				  -	      ERR
      4  6c3d					      ENDIF
      5  6c3d		       14		      .byte.b	20
      0  6c3e					      EVAL8	15
      1  6c3e				  -	      IF	(15 > 127) || (15 < -128)
      2  6c3e				  -	      ECHO	"Erroneous position value", 15
      3  6c3e				  -	      ERR
      4  6c3e					      ENDIF
      5  6c3e		       0f		      .byte.b	15
      0  6c3f					      EVAL8	15
      1  6c3f				  -	      IF	(15 > 127) || (15 < -128)
      2  6c3f				  -	      ECHO	"Erroneous position value", 15
      3  6c3f				  -	      ERR
      4  6c3f					      ENDIF
      5  6c3f		       0f		      .byte.b	15
      0  6c40					      EVAL8	0
      1  6c40				  -	      IF	(0 > 127) || (0 < -128)
      2  6c40				  -	      ECHO	"Erroneous position value", 0
      3  6c40				  -	      ERR
      4  6c40					      ENDIF
      5  6c40		       00		      .byte.b	0
      0  6c41					      EVAL8	0
      1  6c41				  -	      IF	(0 > 127) || (0 < -128)
      2  6c41				  -	      ECHO	"Erroneous position value", 0
      3  6c41				  -	      ERR
      4  6c41					      ENDIF
      5  6c41		       00		      .byte.b	0
      0  6c42					      PVAL	60, 60, 80, 80, 80, 80, 60, 60
      0  6c42					      EVAL8	60
      1  6c42				  -	      IF	(60 > 127) || (60 < -128)
      2  6c42				  -	      ECHO	"Erroneous position value", 60
      3  6c42				  -	      ERR
      4  6c42					      ENDIF
      5  6c42		       3c		      .byte.b	60
      0  6c43					      EVAL8	60
      1  6c43				  -	      IF	(60 > 127) || (60 < -128)
      2  6c43				  -	      ECHO	"Erroneous position value", 60
      3  6c43				  -	      ERR
      4  6c43					      ENDIF
      5  6c43		       3c		      .byte.b	60
      0  6c44					      EVAL8	80
      1  6c44				  -	      IF	(80 > 127) || (80 < -128)
      2  6c44				  -	      ECHO	"Erroneous position value", 80
      3  6c44				  -	      ERR
      4  6c44					      ENDIF
      5  6c44		       50		      .byte.b	80
      0  6c45					      EVAL8	80
      1  6c45				  -	      IF	(80 > 127) || (80 < -128)
      2  6c45				  -	      ECHO	"Erroneous position value", 80
      3  6c45				  -	      ERR
      4  6c45					      ENDIF
      5  6c45		       50		      .byte.b	80
      0  6c46					      EVAL8	80
      1  6c46				  -	      IF	(80 > 127) || (80 < -128)
      2  6c46				  -	      ECHO	"Erroneous position value", 80
      3  6c46				  -	      ERR
      4  6c46					      ENDIF
      5  6c46		       50		      .byte.b	80
      0  6c47					      EVAL8	80
      1  6c47				  -	      IF	(80 > 127) || (80 < -128)
      2  6c47				  -	      ECHO	"Erroneous position value", 80
      3  6c47				  -	      ERR
      4  6c47					      ENDIF
      5  6c47		       50		      .byte.b	80
      0  6c48					      EVAL8	60
      1  6c48				  -	      IF	(60 > 127) || (60 < -128)
      2  6c48				  -	      ECHO	"Erroneous position value", 60
      3  6c48				  -	      ERR
      4  6c48					      ENDIF
      5  6c48		       3c		      .byte.b	60
      0  6c49					      EVAL8	60
      1  6c49				  -	      IF	(60 > 127) || (60 < -128)
      2  6c49				  -	      ECHO	"Erroneous position value", 60
      3  6c49				  -	      ERR
      4  6c49					      ENDIF
      5  6c49		       3c		      .byte.b	60
      0  6c4a					      EVAL8	0
      1  6c4a				  -	      IF	(0 > 127) || (0 < -128)
      2  6c4a				  -	      ECHO	"Erroneous position value", 0
      3  6c4a				  -	      ERR
      4  6c4a					      ENDIF
      5  6c4a		       00		      .byte.b	0
      0  6c4b					      EVAL8	0
      1  6c4b				  -	      IF	(0 > 127) || (0 < -128)
      2  6c4b				  -	      ECHO	"Erroneous position value", 0
      3  6c4b				  -	      ERR
      4  6c4b					      ENDIF
      5  6c4b		       00		      .byte.b	0
      0  6c4c					      PVAL	100, 100, 120, 120, 120, 120, 100, 100
      0  6c4c					      EVAL8	100
      1  6c4c				  -	      IF	(100 > 127) || (100 < -128)
      2  6c4c				  -	      ECHO	"Erroneous position value", 100
      3  6c4c				  -	      ERR
      4  6c4c					      ENDIF
      5  6c4c		       64		      .byte.b	100
      0  6c4d					      EVAL8	100
      1  6c4d				  -	      IF	(100 > 127) || (100 < -128)
      2  6c4d				  -	      ECHO	"Erroneous position value", 100
      3  6c4d				  -	      ERR
      4  6c4d					      ENDIF
      5  6c4d		       64		      .byte.b	100
      0  6c4e					      EVAL8	120
      1  6c4e				  -	      IF	(120 > 127) || (120 < -128)
      2  6c4e				  -	      ECHO	"Erroneous position value", 120
      3  6c4e				  -	      ERR
      4  6c4e					      ENDIF
      5  6c4e		       78		      .byte.b	120
      0  6c4f					      EVAL8	120
      1  6c4f				  -	      IF	(120 > 127) || (120 < -128)
      2  6c4f				  -	      ECHO	"Erroneous position value", 120
      3  6c4f				  -	      ERR
      4  6c4f					      ENDIF
      5  6c4f		       78		      .byte.b	120
      0  6c50					      EVAL8	120
      1  6c50				  -	      IF	(120 > 127) || (120 < -128)
      2  6c50				  -	      ECHO	"Erroneous position value", 120
      3  6c50				  -	      ERR
      4  6c50					      ENDIF
      5  6c50		       78		      .byte.b	120
      0  6c51					      EVAL8	120
      1  6c51				  -	      IF	(120 > 127) || (120 < -128)
      2  6c51				  -	      ECHO	"Erroneous position value", 120
      3  6c51				  -	      ERR
      4  6c51					      ENDIF
      5  6c51		       78		      .byte.b	120
      0  6c52					      EVAL8	100
      1  6c52				  -	      IF	(100 > 127) || (100 < -128)
      2  6c52				  -	      ECHO	"Erroneous position value", 100
      3  6c52				  -	      ERR
      4  6c52					      ENDIF
      5  6c52		       64		      .byte.b	100
      0  6c53					      EVAL8	100
      1  6c53				  -	      IF	(100 > 127) || (100 < -128)
      2  6c53				  -	      ECHO	"Erroneous position value", 100
      3  6c53				  -	      ERR
      4  6c53					      ENDIF
      5  6c53		       64		      .byte.b	100
      0  6c54					      EVAL8	0
      1  6c54				  -	      IF	(0 > 127) || (0 < -128)
      2  6c54				  -	      ECHO	"Erroneous position value", 0
      3  6c54				  -	      ERR
      4  6c54					      ENDIF
      5  6c54		       00		      .byte.b	0
      0  6c55					      EVAL8	0
      1  6c55				  -	      IF	(0 > 127) || (0 < -128)
      2  6c55				  -	      ECHO	"Erroneous position value", 0
      3  6c55				  -	      ERR
      4  6c55					      ENDIF
      5  6c55		       00		      .byte.b	0
      0  6c56					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  6c56					      EVAL8	0
      1  6c56				  -	      IF	(0 > 127) || (0 < -128)
      2  6c56				  -	      ECHO	"Erroneous position value", 0
      3  6c56				  -	      ERR
      4  6c56					      ENDIF
      5  6c56		       00		      .byte.b	0
      0  6c57					      EVAL8	0
      1  6c57				  -	      IF	(0 > 127) || (0 < -128)
      2  6c57				  -	      ECHO	"Erroneous position value", 0
      3  6c57				  -	      ERR
      4  6c57					      ENDIF
      5  6c57		       00		      .byte.b	0
      0  6c58					      EVAL8	0
      1  6c58				  -	      IF	(0 > 127) || (0 < -128)
      2  6c58				  -	      ECHO	"Erroneous position value", 0
      3  6c58				  -	      ERR
      4  6c58					      ENDIF
      5  6c58		       00		      .byte.b	0
      0  6c59					      EVAL8	0
      1  6c59				  -	      IF	(0 > 127) || (0 < -128)
      2  6c59				  -	      ECHO	"Erroneous position value", 0
      3  6c59				  -	      ERR
      4  6c59					      ENDIF
      5  6c59		       00		      .byte.b	0
      0  6c5a					      EVAL8	0
      1  6c5a				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5a				  -	      ECHO	"Erroneous position value", 0
      3  6c5a				  -	      ERR
      4  6c5a					      ENDIF
      5  6c5a		       00		      .byte.b	0
      0  6c5b					      EVAL8	0
      1  6c5b				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5b				  -	      ECHO	"Erroneous position value", 0
      3  6c5b				  -	      ERR
      4  6c5b					      ENDIF
      5  6c5b		       00		      .byte.b	0
      0  6c5c					      EVAL8	0
      1  6c5c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5c				  -	      ECHO	"Erroneous position value", 0
      3  6c5c				  -	      ERR
      4  6c5c					      ENDIF
      5  6c5c		       00		      .byte.b	0
      0  6c5d					      EVAL8	0
      1  6c5d				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5d				  -	      ECHO	"Erroneous position value", 0
      3  6c5d				  -	      ERR
      4  6c5d					      ENDIF
      5  6c5d		       00		      .byte.b	0
      0  6c5e					      EVAL8	0
      1  6c5e				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5e				  -	      ECHO	"Erroneous position value", 0
      3  6c5e				  -	      ERR
      4  6c5e					      ENDIF
      5  6c5e		       00		      .byte.b	0
      0  6c5f					      EVAL8	0
      1  6c5f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c5f				  -	      ECHO	"Erroneous position value", 0
      3  6c5f				  -	      ERR
      4  6c5f					      ENDIF
      5  6c5f		       00		      .byte.b	0
     84  6c60
     85  6c60							;---------------------------------------------------------------------------------------------------
     86  6c60
     87  6c60				   PositionalValue_KNIGHT
     88  6c60
      0  6c60					      PVAL	-50, -30, -30, -30, -30, -30, -22, -50
      0  6c60					      EVAL8	-50
      1  6c60				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6c60				  -	      ECHO	"Erroneous position value", -50
      3  6c60				  -	      ERR
      4  6c60					      ENDIF
      5  6c60		       ce		      .byte.b	-50
      0  6c61					      EVAL8	-30
      1  6c61				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c61				  -	      ECHO	"Erroneous position value", -30
      3  6c61				  -	      ERR
      4  6c61					      ENDIF
      5  6c61		       e2		      .byte.b	-30
      0  6c62					      EVAL8	-30
      1  6c62				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c62				  -	      ECHO	"Erroneous position value", -30
      3  6c62				  -	      ERR
      4  6c62					      ENDIF
      5  6c62		       e2		      .byte.b	-30
      0  6c63					      EVAL8	-30
      1  6c63				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c63				  -	      ECHO	"Erroneous position value", -30
      3  6c63				  -	      ERR
      4  6c63					      ENDIF
      5  6c63		       e2		      .byte.b	-30
      0  6c64					      EVAL8	-30
      1  6c64				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c64				  -	      ECHO	"Erroneous position value", -30
      3  6c64				  -	      ERR
      4  6c64					      ENDIF
      5  6c64		       e2		      .byte.b	-30
      0  6c65					      EVAL8	-30
      1  6c65				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c65				  -	      ECHO	"Erroneous position value", -30
      3  6c65				  -	      ERR
      4  6c65					      ENDIF
      5  6c65		       e2		      .byte.b	-30
      0  6c66					      EVAL8	-22
      1  6c66				  -	      IF	(-22 > 127) || (-22 < -128)
      2  6c66				  -	      ECHO	"Erroneous position value", -22
      3  6c66				  -	      ERR
      4  6c66					      ENDIF
      5  6c66		       ea		      .byte.b	-22
      0  6c67					      EVAL8	-50
      1  6c67				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6c67				  -	      ECHO	"Erroneous position value", -50
      3  6c67				  -	      ERR
      4  6c67					      ENDIF
      5  6c67		       ce		      .byte.b	-50
      0  6c68					      EVAL8	0
      1  6c68				  -	      IF	(0 > 127) || (0 < -128)
      2  6c68				  -	      ECHO	"Erroneous position value", 0
      3  6c68				  -	      ERR
      4  6c68					      ENDIF
      5  6c68		       00		      .byte.b	0
      0  6c69					      EVAL8	0
      1  6c69				  -	      IF	(0 > 127) || (0 < -128)
      2  6c69				  -	      ECHO	"Erroneous position value", 0
      3  6c69				  -	      ERR
      4  6c69					      ENDIF
      5  6c69		       00		      .byte.b	0
      0  6c6a					      PVAL	-40, -20, 0, -5, -25, 0, -20, -40
      0  6c6a					      EVAL8	-40
      1  6c6a				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c6a				  -	      ECHO	"Erroneous position value", -40
      3  6c6a				  -	      ERR
      4  6c6a					      ENDIF
      5  6c6a		       d8		      .byte.b	-40
      0  6c6b					      EVAL8	-20
      1  6c6b				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6c6b				  -	      ECHO	"Erroneous position value", -20
      3  6c6b				  -	      ERR
      4  6c6b					      ENDIF
      5  6c6b		       ec		      .byte.b	-20
      0  6c6c					      EVAL8	0
      1  6c6c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c6c				  -	      ECHO	"Erroneous position value", 0
      3  6c6c				  -	      ERR
      4  6c6c					      ENDIF
      5  6c6c		       00		      .byte.b	0
      0  6c6d					      EVAL8	-5
      1  6c6d				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6c6d				  -	      ECHO	"Erroneous position value", -5
      3  6c6d				  -	      ERR
      4  6c6d					      ENDIF
      5  6c6d		       fb		      .byte.b	-5
      0  6c6e					      EVAL8	-25
      1  6c6e				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6c6e				  -	      ECHO	"Erroneous position value", -25
      3  6c6e				  -	      ERR
      4  6c6e					      ENDIF
      5  6c6e		       e7		      .byte.b	-25
      0  6c6f					      EVAL8	0
      1  6c6f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c6f				  -	      ECHO	"Erroneous position value", 0
      3  6c6f				  -	      ERR
      4  6c6f					      ENDIF
      5  6c6f		       00		      .byte.b	0
      0  6c70					      EVAL8	-20
      1  6c70				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6c70				  -	      ECHO	"Erroneous position value", -20
      3  6c70				  -	      ERR
      4  6c70					      ENDIF
      5  6c70		       ec		      .byte.b	-20
      0  6c71					      EVAL8	-40
      1  6c71				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c71				  -	      ECHO	"Erroneous position value", -40
      3  6c71				  -	      ERR
      4  6c71					      ENDIF
      5  6c71		       d8		      .byte.b	-40
      0  6c72					      EVAL8	0
      1  6c72				  -	      IF	(0 > 127) || (0 < -128)
      2  6c72				  -	      ECHO	"Erroneous position value", 0
      3  6c72				  -	      ERR
      4  6c72					      ENDIF
      5  6c72		       00		      .byte.b	0
      0  6c73					      EVAL8	0
      1  6c73				  -	      IF	(0 > 127) || (0 < -128)
      2  6c73				  -	      ECHO	"Erroneous position value", 0
      3  6c73				  -	      ERR
      4  6c73					      ENDIF
      5  6c73		       00		      .byte.b	0
      0  6c74					      PVAL	-30, 0, 18, 15, 15, 18, 0, -30
      0  6c74					      EVAL8	-30
      1  6c74				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c74				  -	      ECHO	"Erroneous position value", -30
      3  6c74				  -	      ERR
      4  6c74					      ENDIF
      5  6c74		       e2		      .byte.b	-30
      0  6c75					      EVAL8	0
      1  6c75				  -	      IF	(0 > 127) || (0 < -128)
      2  6c75				  -	      ECHO	"Erroneous position value", 0
      3  6c75				  -	      ERR
      4  6c75					      ENDIF
      5  6c75		       00		      .byte.b	0
      0  6c76					      EVAL8	18
      1  6c76				  -	      IF	(18 > 127) || (18 < -128)
      2  6c76				  -	      ECHO	"Erroneous position value", 18
      3  6c76				  -	      ERR
      4  6c76					      ENDIF
      5  6c76		       12		      .byte.b	18
      0  6c77					      EVAL8	15
      1  6c77				  -	      IF	(15 > 127) || (15 < -128)
      2  6c77				  -	      ECHO	"Erroneous position value", 15
      3  6c77				  -	      ERR
      4  6c77					      ENDIF
      5  6c77		       0f		      .byte.b	15
      0  6c78					      EVAL8	15
      1  6c78				  -	      IF	(15 > 127) || (15 < -128)
      2  6c78				  -	      ECHO	"Erroneous position value", 15
      3  6c78				  -	      ERR
      4  6c78					      ENDIF
      5  6c78		       0f		      .byte.b	15
      0  6c79					      EVAL8	18
      1  6c79				  -	      IF	(18 > 127) || (18 < -128)
      2  6c79				  -	      ECHO	"Erroneous position value", 18
      3  6c79				  -	      ERR
      4  6c79					      ENDIF
      5  6c79		       12		      .byte.b	18
      0  6c7a					      EVAL8	0
      1  6c7a				  -	      IF	(0 > 127) || (0 < -128)
      2  6c7a				  -	      ECHO	"Erroneous position value", 0
      3  6c7a				  -	      ERR
      4  6c7a					      ENDIF
      5  6c7a		       00		      .byte.b	0
      0  6c7b					      EVAL8	-30
      1  6c7b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c7b				  -	      ECHO	"Erroneous position value", -30
      3  6c7b				  -	      ERR
      4  6c7b					      ENDIF
      5  6c7b		       e2		      .byte.b	-30
      0  6c7c					      EVAL8	0
      1  6c7c				  -	      IF	(0 > 127) || (0 < -128)
      2  6c7c				  -	      ECHO	"Erroneous position value", 0
      3  6c7c				  -	      ERR
      4  6c7c					      ENDIF
      5  6c7c		       00		      .byte.b	0
      0  6c7d					      EVAL8	0
      1  6c7d				  -	      IF	(0 > 127) || (0 < -128)
      2  6c7d				  -	      ECHO	"Erroneous position value", 0
      3  6c7d				  -	      ERR
      4  6c7d					      ENDIF
      5  6c7d		       00		      .byte.b	0
      0  6c7e					      PVAL	-40, 0, 15, 30, 30, 15, 0, -40
      0  6c7e					      EVAL8	-40
      1  6c7e				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c7e				  -	      ECHO	"Erroneous position value", -40
      3  6c7e				  -	      ERR
      4  6c7e					      ENDIF
      5  6c7e		       d8		      .byte.b	-40
      0  6c7f					      EVAL8	0
      1  6c7f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c7f				  -	      ECHO	"Erroneous position value", 0
      3  6c7f				  -	      ERR
      4  6c7f					      ENDIF
      5  6c7f		       00		      .byte.b	0
      0  6c80					      EVAL8	15
      1  6c80				  -	      IF	(15 > 127) || (15 < -128)
      2  6c80				  -	      ECHO	"Erroneous position value", 15
      3  6c80				  -	      ERR
      4  6c80					      ENDIF
      5  6c80		       0f		      .byte.b	15
      0  6c81					      EVAL8	30
      1  6c81				  -	      IF	(30 > 127) || (30 < -128)
      2  6c81				  -	      ECHO	"Erroneous position value", 30
      3  6c81				  -	      ERR
      4  6c81					      ENDIF
      5  6c81		       1e		      .byte.b	30
      0  6c82					      EVAL8	30
      1  6c82				  -	      IF	(30 > 127) || (30 < -128)
      2  6c82				  -	      ECHO	"Erroneous position value", 30
      3  6c82				  -	      ERR
      4  6c82					      ENDIF
      5  6c82		       1e		      .byte.b	30
      0  6c83					      EVAL8	15
      1  6c83				  -	      IF	(15 > 127) || (15 < -128)
      2  6c83				  -	      ECHO	"Erroneous position value", 15
      3  6c83				  -	      ERR
      4  6c83					      ENDIF
      5  6c83		       0f		      .byte.b	15
      0  6c84					      EVAL8	0
      1  6c84				  -	      IF	(0 > 127) || (0 < -128)
      2  6c84				  -	      ECHO	"Erroneous position value", 0
      3  6c84				  -	      ERR
      4  6c84					      ENDIF
      5  6c84		       00		      .byte.b	0
      0  6c85					      EVAL8	-40
      1  6c85				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c85				  -	      ECHO	"Erroneous position value", -40
      3  6c85				  -	      ERR
      4  6c85					      ENDIF
      5  6c85		       d8		      .byte.b	-40
      0  6c86					      EVAL8	0
      1  6c86				  -	      IF	(0 > 127) || (0 < -128)
      2  6c86				  -	      ECHO	"Erroneous position value", 0
      3  6c86				  -	      ERR
      4  6c86					      ENDIF
      5  6c86		       00		      .byte.b	0
      0  6c87					      EVAL8	0
      1  6c87				  -	      IF	(0 > 127) || (0 < -128)
      2  6c87				  -	      ECHO	"Erroneous position value", 0
      3  6c87				  -	      ERR
      4  6c87					      ENDIF
      5  6c87		       00		      .byte.b	0
      0  6c88					      PVAL	-40, 5, 15, 30, 30, 15, 5, -40
      0  6c88					      EVAL8	-40
      1  6c88				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c88				  -	      ECHO	"Erroneous position value", -40
      3  6c88				  -	      ERR
      4  6c88					      ENDIF
      5  6c88		       d8		      .byte.b	-40
      0  6c89					      EVAL8	5
      1  6c89				  -	      IF	(5 > 127) || (5 < -128)
      2  6c89				  -	      ECHO	"Erroneous position value", 5
      3  6c89				  -	      ERR
      4  6c89					      ENDIF
      5  6c89		       05		      .byte.b	5
      0  6c8a					      EVAL8	15
      1  6c8a				  -	      IF	(15 > 127) || (15 < -128)
      2  6c8a				  -	      ECHO	"Erroneous position value", 15
      3  6c8a				  -	      ERR
      4  6c8a					      ENDIF
      5  6c8a		       0f		      .byte.b	15
      0  6c8b					      EVAL8	30
      1  6c8b				  -	      IF	(30 > 127) || (30 < -128)
      2  6c8b				  -	      ECHO	"Erroneous position value", 30
      3  6c8b				  -	      ERR
      4  6c8b					      ENDIF
      5  6c8b		       1e		      .byte.b	30
      0  6c8c					      EVAL8	30
      1  6c8c				  -	      IF	(30 > 127) || (30 < -128)
      2  6c8c				  -	      ECHO	"Erroneous position value", 30
      3  6c8c				  -	      ERR
      4  6c8c					      ENDIF
      5  6c8c		       1e		      .byte.b	30
      0  6c8d					      EVAL8	15
      1  6c8d				  -	      IF	(15 > 127) || (15 < -128)
      2  6c8d				  -	      ECHO	"Erroneous position value", 15
      3  6c8d				  -	      ERR
      4  6c8d					      ENDIF
      5  6c8d		       0f		      .byte.b	15
      0  6c8e					      EVAL8	5
      1  6c8e				  -	      IF	(5 > 127) || (5 < -128)
      2  6c8e				  -	      ECHO	"Erroneous position value", 5
      3  6c8e				  -	      ERR
      4  6c8e					      ENDIF
      5  6c8e		       05		      .byte.b	5
      0  6c8f					      EVAL8	-40
      1  6c8f				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c8f				  -	      ECHO	"Erroneous position value", -40
      3  6c8f				  -	      ERR
      4  6c8f					      ENDIF
      5  6c8f		       d8		      .byte.b	-40
      0  6c90					      EVAL8	0
      1  6c90				  -	      IF	(0 > 127) || (0 < -128)
      2  6c90				  -	      ECHO	"Erroneous position value", 0
      3  6c90				  -	      ERR
      4  6c90					      ENDIF
      5  6c90		       00		      .byte.b	0
      0  6c91					      EVAL8	0
      1  6c91				  -	      IF	(0 > 127) || (0 < -128)
      2  6c91				  -	      ECHO	"Erroneous position value", 0
      3  6c91				  -	      ERR
      4  6c91					      ENDIF
      5  6c91		       00		      .byte.b	0
      0  6c92					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      0  6c92					      EVAL8	-30
      1  6c92				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c92				  -	      ECHO	"Erroneous position value", -30
      3  6c92				  -	      ERR
      4  6c92					      ENDIF
      5  6c92		       e2		      .byte.b	-30
      0  6c93					      EVAL8	0
      1  6c93				  -	      IF	(0 > 127) || (0 < -128)
      2  6c93				  -	      ECHO	"Erroneous position value", 0
      3  6c93				  -	      ERR
      4  6c93					      ENDIF
      5  6c93		       00		      .byte.b	0
      0  6c94					      EVAL8	10
      1  6c94				  -	      IF	(10 > 127) || (10 < -128)
      2  6c94				  -	      ECHO	"Erroneous position value", 10
      3  6c94				  -	      ERR
      4  6c94					      ENDIF
      5  6c94		       0a		      .byte.b	10
      0  6c95					      EVAL8	15
      1  6c95				  -	      IF	(15 > 127) || (15 < -128)
      2  6c95				  -	      ECHO	"Erroneous position value", 15
      3  6c95				  -	      ERR
      4  6c95					      ENDIF
      5  6c95		       0f		      .byte.b	15
      0  6c96					      EVAL8	15
      1  6c96				  -	      IF	(15 > 127) || (15 < -128)
      2  6c96				  -	      ECHO	"Erroneous position value", 15
      3  6c96				  -	      ERR
      4  6c96					      ENDIF
      5  6c96		       0f		      .byte.b	15
      0  6c97					      EVAL8	10
      1  6c97				  -	      IF	(10 > 127) || (10 < -128)
      2  6c97				  -	      ECHO	"Erroneous position value", 10
      3  6c97				  -	      ERR
      4  6c97					      ENDIF
      5  6c97		       0a		      .byte.b	10
      0  6c98					      EVAL8	0
      1  6c98				  -	      IF	(0 > 127) || (0 < -128)
      2  6c98				  -	      ECHO	"Erroneous position value", 0
      3  6c98				  -	      ERR
      4  6c98					      ENDIF
      5  6c98		       00		      .byte.b	0
      0  6c99					      EVAL8	-30
      1  6c99				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6c99				  -	      ECHO	"Erroneous position value", -30
      3  6c99				  -	      ERR
      4  6c99					      ENDIF
      5  6c99		       e2		      .byte.b	-30
      0  6c9a					      EVAL8	0
      1  6c9a				  -	      IF	(0 > 127) || (0 < -128)
      2  6c9a				  -	      ECHO	"Erroneous position value", 0
      3  6c9a				  -	      ERR
      4  6c9a					      ENDIF
      5  6c9a		       00		      .byte.b	0
      0  6c9b					      EVAL8	0
      1  6c9b				  -	      IF	(0 > 127) || (0 < -128)
      2  6c9b				  -	      ECHO	"Erroneous position value", 0
      3  6c9b				  -	      ERR
      4  6c9b					      ENDIF
      5  6c9b		       00		      .byte.b	0
      0  6c9c					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      0  6c9c					      EVAL8	-40
      1  6c9c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6c9c				  -	      ECHO	"Erroneous position value", -40
      3  6c9c				  -	      ERR
      4  6c9c					      ENDIF
      5  6c9c		       d8		      .byte.b	-40
      0  6c9d					      EVAL8	-20
      1  6c9d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6c9d				  -	      ECHO	"Erroneous position value", -20
      3  6c9d				  -	      ERR
      4  6c9d					      ENDIF
      5  6c9d		       ec		      .byte.b	-20
      0  6c9e					      EVAL8	30
      1  6c9e				  -	      IF	(30 > 127) || (30 < -128)
      2  6c9e				  -	      ECHO	"Erroneous position value", 30
      3  6c9e				  -	      ERR
      4  6c9e					      ENDIF
      5  6c9e		       1e		      .byte.b	30
      0  6c9f					      EVAL8	0
      1  6c9f				  -	      IF	(0 > 127) || (0 < -128)
      2  6c9f				  -	      ECHO	"Erroneous position value", 0
      3  6c9f				  -	      ERR
      4  6c9f					      ENDIF
      5  6c9f		       00		      .byte.b	0
      0  6ca0					      EVAL8	0
      1  6ca0				  -	      IF	(0 > 127) || (0 < -128)
      2  6ca0				  -	      ECHO	"Erroneous position value", 0
      3  6ca0				  -	      ERR
      4  6ca0					      ENDIF
      5  6ca0		       00		      .byte.b	0
      0  6ca1					      EVAL8	30
      1  6ca1				  -	      IF	(30 > 127) || (30 < -128)
      2  6ca1				  -	      ECHO	"Erroneous position value", 30
      3  6ca1				  -	      ERR
      4  6ca1					      ENDIF
      5  6ca1		       1e		      .byte.b	30
      0  6ca2					      EVAL8	-20
      1  6ca2				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6ca2				  -	      ECHO	"Erroneous position value", -20
      3  6ca2				  -	      ERR
      4  6ca2					      ENDIF
      5  6ca2		       ec		      .byte.b	-20
      0  6ca3					      EVAL8	-40
      1  6ca3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6ca3				  -	      ECHO	"Erroneous position value", -40
      3  6ca3				  -	      ERR
      4  6ca3					      ENDIF
      5  6ca3		       d8		      .byte.b	-40
      0  6ca4					      EVAL8	0
      1  6ca4				  -	      IF	(0 > 127) || (0 < -128)
      2  6ca4				  -	      ECHO	"Erroneous position value", 0
      3  6ca4				  -	      ERR
      4  6ca4					      ENDIF
      5  6ca4		       00		      .byte.b	0
      0  6ca5					      EVAL8	0
      1  6ca5				  -	      IF	(0 > 127) || (0 < -128)
      2  6ca5				  -	      ECHO	"Erroneous position value", 0
      3  6ca5				  -	      ERR
      4  6ca5					      ENDIF
      5  6ca5		       00		      .byte.b	0
      0  6ca6					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      0  6ca6					      EVAL8	-50
      1  6ca6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6ca6				  -	      ECHO	"Erroneous position value", -50
      3  6ca6				  -	      ERR
      4  6ca6					      ENDIF
      5  6ca6		       ce		      .byte.b	-50
      0  6ca7					      EVAL8	-20
      1  6ca7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6ca7				  -	      ECHO	"Erroneous position value", -20
      3  6ca7				  -	      ERR
      4  6ca7					      ENDIF
      5  6ca7		       ec		      .byte.b	-20
      0  6ca8					      EVAL8	-30
      1  6ca8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6ca8				  -	      ECHO	"Erroneous position value", -30
      3  6ca8				  -	      ERR
      4  6ca8					      ENDIF
      5  6ca8		       e2		      .byte.b	-30
      0  6ca9					      EVAL8	-30
      1  6ca9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6ca9				  -	      ECHO	"Erroneous position value", -30
      3  6ca9				  -	      ERR
      4  6ca9					      ENDIF
      5  6ca9		       e2		      .byte.b	-30
      0  6caa					      EVAL8	-30
      1  6caa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6caa				  -	      ECHO	"Erroneous position value", -30
      3  6caa				  -	      ERR
      4  6caa					      ENDIF
      5  6caa		       e2		      .byte.b	-30
      0  6cab					      EVAL8	-30
      1  6cab				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6cab				  -	      ECHO	"Erroneous position value", -30
      3  6cab				  -	      ERR
      4  6cab					      ENDIF
      5  6cab		       e2		      .byte.b	-30
      0  6cac					      EVAL8	-20
      1  6cac				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cac				  -	      ECHO	"Erroneous position value", -20
      3  6cac				  -	      ERR
      4  6cac					      ENDIF
      5  6cac		       ec		      .byte.b	-20
      0  6cad					      EVAL8	-50
      1  6cad				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6cad				  -	      ECHO	"Erroneous position value", -50
      3  6cad				  -	      ERR
      4  6cad					      ENDIF
      5  6cad		       ce		      .byte.b	-50
      0  6cae					      EVAL8	0
      1  6cae				  -	      IF	(0 > 127) || (0 < -128)
      2  6cae				  -	      ECHO	"Erroneous position value", 0
      3  6cae				  -	      ERR
      4  6cae					      ENDIF
      5  6cae		       00		      .byte.b	0
      0  6caf					      EVAL8	0
      1  6caf				  -	      IF	(0 > 127) || (0 < -128)
      2  6caf				  -	      ECHO	"Erroneous position value", 0
      3  6caf				  -	      ERR
      4  6caf					      ENDIF
      5  6caf		       00		      .byte.b	0
     97  6cb0
     98  6cb0
     99  6cb0							;---------------------------------------------------------------------------------------------------
    100  6cb0
    101  6cb0				   PositionalValue_BISHOP
    102  6cb0
      0  6cb0					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      0  6cb0					      EVAL8	-20
      1  6cb0				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cb0				  -	      ECHO	"Erroneous position value", -20
      3  6cb0				  -	      ERR
      4  6cb0					      ENDIF
      5  6cb0		       ec		      .byte.b	-20
      0  6cb1					      EVAL8	-10
      1  6cb1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cb1				  -	      ECHO	"Erroneous position value", -10
      3  6cb1				  -	      ERR
      4  6cb1					      ENDIF
      5  6cb1		       f6		      .byte.b	-10
      0  6cb2					      EVAL8	-50
      1  6cb2				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6cb2				  -	      ECHO	"Erroneous position value", -50
      3  6cb2				  -	      ERR
      4  6cb2					      ENDIF
      5  6cb2		       ce		      .byte.b	-50
      0  6cb3					      EVAL8	-10
      1  6cb3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cb3				  -	      ECHO	"Erroneous position value", -10
      3  6cb3				  -	      ERR
      4  6cb3					      ENDIF
      5  6cb3		       f6		      .byte.b	-10
      0  6cb4					      EVAL8	-10
      1  6cb4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cb4				  -	      ECHO	"Erroneous position value", -10
      3  6cb4				  -	      ERR
      4  6cb4					      ENDIF
      5  6cb4		       f6		      .byte.b	-10
      0  6cb5					      EVAL8	-50
      1  6cb5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6cb5				  -	      ECHO	"Erroneous position value", -50
      3  6cb5				  -	      ERR
      4  6cb5					      ENDIF
      5  6cb5		       ce		      .byte.b	-50
      0  6cb6					      EVAL8	-10
      1  6cb6				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cb6				  -	      ECHO	"Erroneous position value", -10
      3  6cb6				  -	      ERR
      4  6cb6					      ENDIF
      5  6cb6		       f6		      .byte.b	-10
      0  6cb7					      EVAL8	-20
      1  6cb7				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cb7				  -	      ECHO	"Erroneous position value", -20
      3  6cb7				  -	      ERR
      4  6cb7					      ENDIF
      5  6cb7		       ec		      .byte.b	-20
      0  6cb8					      EVAL8	0
      1  6cb8				  -	      IF	(0 > 127) || (0 < -128)
      2  6cb8				  -	      ECHO	"Erroneous position value", 0
      3  6cb8				  -	      ERR
      4  6cb8					      ENDIF
      5  6cb8		       00		      .byte.b	0
      0  6cb9					      EVAL8	0
      1  6cb9				  -	      IF	(0 > 127) || (0 < -128)
      2  6cb9				  -	      ECHO	"Erroneous position value", 0
      3  6cb9				  -	      ERR
      4  6cb9					      ENDIF
      5  6cb9		       00		      .byte.b	0
      0  6cba					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      0  6cba					      EVAL8	-10
      1  6cba				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cba				  -	      ECHO	"Erroneous position value", -10
      3  6cba				  -	      ERR
      4  6cba					      ENDIF
      5  6cba		       f6		      .byte.b	-10
      0  6cbb					      EVAL8	5
      1  6cbb				  -	      IF	(5 > 127) || (5 < -128)
      2  6cbb				  -	      ECHO	"Erroneous position value", 5
      3  6cbb				  -	      ERR
      4  6cbb					      ENDIF
      5  6cbb		       05		      .byte.b	5
      0  6cbc					      EVAL8	0
      1  6cbc				  -	      IF	(0 > 127) || (0 < -128)
      2  6cbc				  -	      ECHO	"Erroneous position value", 0
      3  6cbc				  -	      ERR
      4  6cbc					      ENDIF
      5  6cbc		       00		      .byte.b	0
      0  6cbd					      EVAL8	0
      1  6cbd				  -	      IF	(0 > 127) || (0 < -128)
      2  6cbd				  -	      ECHO	"Erroneous position value", 0
      3  6cbd				  -	      ERR
      4  6cbd					      ENDIF
      5  6cbd		       00		      .byte.b	0
      0  6cbe					      EVAL8	0
      1  6cbe				  -	      IF	(0 > 127) || (0 < -128)
      2  6cbe				  -	      ECHO	"Erroneous position value", 0
      3  6cbe				  -	      ERR
      4  6cbe					      ENDIF
      5  6cbe		       00		      .byte.b	0
      0  6cbf					      EVAL8	0
      1  6cbf				  -	      IF	(0 > 127) || (0 < -128)
      2  6cbf				  -	      ECHO	"Erroneous position value", 0
      3  6cbf				  -	      ERR
      4  6cbf					      ENDIF
      5  6cbf		       00		      .byte.b	0
      0  6cc0					      EVAL8	5
      1  6cc0				  -	      IF	(5 > 127) || (5 < -128)
      2  6cc0				  -	      ECHO	"Erroneous position value", 5
      3  6cc0				  -	      ERR
      4  6cc0					      ENDIF
      5  6cc0		       05		      .byte.b	5
      0  6cc1					      EVAL8	-10
      1  6cc1				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cc1				  -	      ECHO	"Erroneous position value", -10
      3  6cc1				  -	      ERR
      4  6cc1					      ENDIF
      5  6cc1		       f6		      .byte.b	-10
      0  6cc2					      EVAL8	0
      1  6cc2				  -	      IF	(0 > 127) || (0 < -128)
      2  6cc2				  -	      ECHO	"Erroneous position value", 0
      3  6cc2				  -	      ERR
      4  6cc2					      ENDIF
      5  6cc2		       00		      .byte.b	0
      0  6cc3					      EVAL8	0
      1  6cc3				  -	      IF	(0 > 127) || (0 < -128)
      2  6cc3				  -	      ECHO	"Erroneous position value", 0
      3  6cc3				  -	      ERR
      4  6cc3					      ENDIF
      5  6cc3		       00		      .byte.b	0
      0  6cc4					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      0  6cc4					      EVAL8	-10
      1  6cc4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cc4				  -	      ECHO	"Erroneous position value", -10
      3  6cc4				  -	      ERR
      4  6cc4					      ENDIF
      5  6cc4		       f6		      .byte.b	-10
      0  6cc5					      EVAL8	10
      1  6cc5				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc5				  -	      ECHO	"Erroneous position value", 10
      3  6cc5				  -	      ERR
      4  6cc5					      ENDIF
      5  6cc5		       0a		      .byte.b	10
      0  6cc6					      EVAL8	10
      1  6cc6				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc6				  -	      ECHO	"Erroneous position value", 10
      3  6cc6				  -	      ERR
      4  6cc6					      ENDIF
      5  6cc6		       0a		      .byte.b	10
      0  6cc7					      EVAL8	10
      1  6cc7				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc7				  -	      ECHO	"Erroneous position value", 10
      3  6cc7				  -	      ERR
      4  6cc7					      ENDIF
      5  6cc7		       0a		      .byte.b	10
      0  6cc8					      EVAL8	10
      1  6cc8				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc8				  -	      ECHO	"Erroneous position value", 10
      3  6cc8				  -	      ERR
      4  6cc8					      ENDIF
      5  6cc8		       0a		      .byte.b	10
      0  6cc9					      EVAL8	10
      1  6cc9				  -	      IF	(10 > 127) || (10 < -128)
      2  6cc9				  -	      ECHO	"Erroneous position value", 10
      3  6cc9				  -	      ERR
      4  6cc9					      ENDIF
      5  6cc9		       0a		      .byte.b	10
      0  6cca					      EVAL8	10
      1  6cca				  -	      IF	(10 > 127) || (10 < -128)
      2  6cca				  -	      ECHO	"Erroneous position value", 10
      3  6cca				  -	      ERR
      4  6cca					      ENDIF
      5  6cca		       0a		      .byte.b	10
      0  6ccb					      EVAL8	-10
      1  6ccb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6ccb				  -	      ECHO	"Erroneous position value", -10
      3  6ccb				  -	      ERR
      4  6ccb					      ENDIF
      5  6ccb		       f6		      .byte.b	-10
      0  6ccc					      EVAL8	0
      1  6ccc				  -	      IF	(0 > 127) || (0 < -128)
      2  6ccc				  -	      ECHO	"Erroneous position value", 0
      3  6ccc				  -	      ERR
      4  6ccc					      ENDIF
      5  6ccc		       00		      .byte.b	0
      0  6ccd					      EVAL8	0
      1  6ccd				  -	      IF	(0 > 127) || (0 < -128)
      2  6ccd				  -	      ECHO	"Erroneous position value", 0
      3  6ccd				  -	      ERR
      4  6ccd					      ENDIF
      5  6ccd		       00		      .byte.b	0
      0  6cce					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      0  6cce					      EVAL8	-10
      1  6cce				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cce				  -	      ECHO	"Erroneous position value", -10
      3  6cce				  -	      ERR
      4  6cce					      ENDIF
      5  6cce		       f6		      .byte.b	-10
      0  6ccf					      EVAL8	0
      1  6ccf				  -	      IF	(0 > 127) || (0 < -128)
      2  6ccf				  -	      ECHO	"Erroneous position value", 0
      3  6ccf				  -	      ERR
      4  6ccf					      ENDIF
      5  6ccf		       00		      .byte.b	0
      0  6cd0					      EVAL8	10
      1  6cd0				  -	      IF	(10 > 127) || (10 < -128)
      2  6cd0				  -	      ECHO	"Erroneous position value", 10
      3  6cd0				  -	      ERR
      4  6cd0					      ENDIF
      5  6cd0		       0a		      .byte.b	10
      0  6cd1					      EVAL8	20
      1  6cd1				  -	      IF	(20 > 127) || (20 < -128)
      2  6cd1				  -	      ECHO	"Erroneous position value", 20
      3  6cd1				  -	      ERR
      4  6cd1					      ENDIF
      5  6cd1		       14		      .byte.b	20
      0  6cd2					      EVAL8	20
      1  6cd2				  -	      IF	(20 > 127) || (20 < -128)
      2  6cd2				  -	      ECHO	"Erroneous position value", 20
      3  6cd2				  -	      ERR
      4  6cd2					      ENDIF
      5  6cd2		       14		      .byte.b	20
      0  6cd3					      EVAL8	10
      1  6cd3				  -	      IF	(10 > 127) || (10 < -128)
      2  6cd3				  -	      ECHO	"Erroneous position value", 10
      3  6cd3				  -	      ERR
      4  6cd3					      ENDIF
      5  6cd3		       0a		      .byte.b	10
      0  6cd4					      EVAL8	0
      1  6cd4				  -	      IF	(0 > 127) || (0 < -128)
      2  6cd4				  -	      ECHO	"Erroneous position value", 0
      3  6cd4				  -	      ERR
      4  6cd4					      ENDIF
      5  6cd4		       00		      .byte.b	0
      0  6cd5					      EVAL8	-10
      1  6cd5				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cd5				  -	      ECHO	"Erroneous position value", -10
      3  6cd5				  -	      ERR
      4  6cd5					      ENDIF
      5  6cd5		       f6		      .byte.b	-10
      0  6cd6					      EVAL8	0
      1  6cd6				  -	      IF	(0 > 127) || (0 < -128)
      2  6cd6				  -	      ECHO	"Erroneous position value", 0
      3  6cd6				  -	      ERR
      4  6cd6					      ENDIF
      5  6cd6		       00		      .byte.b	0
      0  6cd7					      EVAL8	0
      1  6cd7				  -	      IF	(0 > 127) || (0 < -128)
      2  6cd7				  -	      ECHO	"Erroneous position value", 0
      3  6cd7				  -	      ERR
      4  6cd7					      ENDIF
      5  6cd7		       00		      .byte.b	0
      0  6cd8					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      0  6cd8					      EVAL8	-10
      1  6cd8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cd8				  -	      ECHO	"Erroneous position value", -10
      3  6cd8				  -	      ERR
      4  6cd8					      ENDIF
      5  6cd8		       f6		      .byte.b	-10
      0  6cd9					      EVAL8	5
      1  6cd9				  -	      IF	(5 > 127) || (5 < -128)
      2  6cd9				  -	      ECHO	"Erroneous position value", 5
      3  6cd9				  -	      ERR
      4  6cd9					      ENDIF
      5  6cd9		       05		      .byte.b	5
      0  6cda					      EVAL8	5
      1  6cda				  -	      IF	(5 > 127) || (5 < -128)
      2  6cda				  -	      ECHO	"Erroneous position value", 5
      3  6cda				  -	      ERR
      4  6cda					      ENDIF
      5  6cda		       05		      .byte.b	5
      0  6cdb					      EVAL8	20
      1  6cdb				  -	      IF	(20 > 127) || (20 < -128)
      2  6cdb				  -	      ECHO	"Erroneous position value", 20
      3  6cdb				  -	      ERR
      4  6cdb					      ENDIF
      5  6cdb		       14		      .byte.b	20
      0  6cdc					      EVAL8	20
      1  6cdc				  -	      IF	(20 > 127) || (20 < -128)
      2  6cdc				  -	      ECHO	"Erroneous position value", 20
      3  6cdc				  -	      ERR
      4  6cdc					      ENDIF
      5  6cdc		       14		      .byte.b	20
      0  6cdd					      EVAL8	5
      1  6cdd				  -	      IF	(5 > 127) || (5 < -128)
      2  6cdd				  -	      ECHO	"Erroneous position value", 5
      3  6cdd				  -	      ERR
      4  6cdd					      ENDIF
      5  6cdd		       05		      .byte.b	5
      0  6cde					      EVAL8	5
      1  6cde				  -	      IF	(5 > 127) || (5 < -128)
      2  6cde				  -	      ECHO	"Erroneous position value", 5
      3  6cde				  -	      ERR
      4  6cde					      ENDIF
      5  6cde		       05		      .byte.b	5
      0  6cdf					      EVAL8	-10
      1  6cdf				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cdf				  -	      ECHO	"Erroneous position value", -10
      3  6cdf				  -	      ERR
      4  6cdf					      ENDIF
      5  6cdf		       f6		      .byte.b	-10
      0  6ce0					      EVAL8	0
      1  6ce0				  -	      IF	(0 > 127) || (0 < -128)
      2  6ce0				  -	      ECHO	"Erroneous position value", 0
      3  6ce0				  -	      ERR
      4  6ce0					      ENDIF
      5  6ce0		       00		      .byte.b	0
      0  6ce1					      EVAL8	0
      1  6ce1				  -	      IF	(0 > 127) || (0 < -128)
      2  6ce1				  -	      ECHO	"Erroneous position value", 0
      3  6ce1				  -	      ERR
      4  6ce1					      ENDIF
      5  6ce1		       00		      .byte.b	0
      0  6ce2					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      0  6ce2					      EVAL8	-10
      1  6ce2				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6ce2				  -	      ECHO	"Erroneous position value", -10
      3  6ce2				  -	      ERR
      4  6ce2					      ENDIF
      5  6ce2		       f6		      .byte.b	-10
      0  6ce3					      EVAL8	0
      1  6ce3				  -	      IF	(0 > 127) || (0 < -128)
      2  6ce3				  -	      ECHO	"Erroneous position value", 0
      3  6ce3				  -	      ERR
      4  6ce3					      ENDIF
      5  6ce3		       00		      .byte.b	0
      0  6ce4					      EVAL8	5
      1  6ce4				  -	      IF	(5 > 127) || (5 < -128)
      2  6ce4				  -	      ECHO	"Erroneous position value", 5
      3  6ce4				  -	      ERR
      4  6ce4					      ENDIF
      5  6ce4		       05		      .byte.b	5
      0  6ce5					      EVAL8	10
      1  6ce5				  -	      IF	(10 > 127) || (10 < -128)
      2  6ce5				  -	      ECHO	"Erroneous position value", 10
      3  6ce5				  -	      ERR
      4  6ce5					      ENDIF
      5  6ce5		       0a		      .byte.b	10
      0  6ce6					      EVAL8	10
      1  6ce6				  -	      IF	(10 > 127) || (10 < -128)
      2  6ce6				  -	      ECHO	"Erroneous position value", 10
      3  6ce6				  -	      ERR
      4  6ce6					      ENDIF
      5  6ce6		       0a		      .byte.b	10
      0  6ce7					      EVAL8	5
      1  6ce7				  -	      IF	(5 > 127) || (5 < -128)
      2  6ce7				  -	      ECHO	"Erroneous position value", 5
      3  6ce7				  -	      ERR
      4  6ce7					      ENDIF
      5  6ce7		       05		      .byte.b	5
      0  6ce8					      EVAL8	0
      1  6ce8				  -	      IF	(0 > 127) || (0 < -128)
      2  6ce8				  -	      ECHO	"Erroneous position value", 0
      3  6ce8				  -	      ERR
      4  6ce8					      ENDIF
      5  6ce8		       00		      .byte.b	0
      0  6ce9					      EVAL8	-10
      1  6ce9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6ce9				  -	      ECHO	"Erroneous position value", -10
      3  6ce9				  -	      ERR
      4  6ce9					      ENDIF
      5  6ce9		       f6		      .byte.b	-10
      0  6cea					      EVAL8	0
      1  6cea				  -	      IF	(0 > 127) || (0 < -128)
      2  6cea				  -	      ECHO	"Erroneous position value", 0
      3  6cea				  -	      ERR
      4  6cea					      ENDIF
      5  6cea		       00		      .byte.b	0
      0  6ceb					      EVAL8	0
      1  6ceb				  -	      IF	(0 > 127) || (0 < -128)
      2  6ceb				  -	      ECHO	"Erroneous position value", 0
      3  6ceb				  -	      ERR
      4  6ceb					      ENDIF
      5  6ceb		       00		      .byte.b	0
      0  6cec					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  6cec					      EVAL8	-10
      1  6cec				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cec				  -	      ECHO	"Erroneous position value", -10
      3  6cec				  -	      ERR
      4  6cec					      ENDIF
      5  6cec		       f6		      .byte.b	-10
      0  6ced					      EVAL8	0
      1  6ced				  -	      IF	(0 > 127) || (0 < -128)
      2  6ced				  -	      ECHO	"Erroneous position value", 0
      3  6ced				  -	      ERR
      4  6ced					      ENDIF
      5  6ced		       00		      .byte.b	0
      0  6cee					      EVAL8	0
      1  6cee				  -	      IF	(0 > 127) || (0 < -128)
      2  6cee				  -	      ECHO	"Erroneous position value", 0
      3  6cee				  -	      ERR
      4  6cee					      ENDIF
      5  6cee		       00		      .byte.b	0
      0  6cef					      EVAL8	0
      1  6cef				  -	      IF	(0 > 127) || (0 < -128)
      2  6cef				  -	      ECHO	"Erroneous position value", 0
      3  6cef				  -	      ERR
      4  6cef					      ENDIF
      5  6cef		       00		      .byte.b	0
      0  6cf0					      EVAL8	0
      1  6cf0				  -	      IF	(0 > 127) || (0 < -128)
      2  6cf0				  -	      ECHO	"Erroneous position value", 0
      3  6cf0				  -	      ERR
      4  6cf0					      ENDIF
      5  6cf0		       00		      .byte.b	0
      0  6cf1					      EVAL8	0
      1  6cf1				  -	      IF	(0 > 127) || (0 < -128)
      2  6cf1				  -	      ECHO	"Erroneous position value", 0
      3  6cf1				  -	      ERR
      4  6cf1					      ENDIF
      5  6cf1		       00		      .byte.b	0
      0  6cf2					      EVAL8	0
      1  6cf2				  -	      IF	(0 > 127) || (0 < -128)
      2  6cf2				  -	      ECHO	"Erroneous position value", 0
      3  6cf2				  -	      ERR
      4  6cf2					      ENDIF
      5  6cf2		       00		      .byte.b	0
      0  6cf3					      EVAL8	-10
      1  6cf3				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cf3				  -	      ECHO	"Erroneous position value", -10
      3  6cf3				  -	      ERR
      4  6cf3					      ENDIF
      5  6cf3		       f6		      .byte.b	-10
      0  6cf4					      EVAL8	0
      1  6cf4				  -	      IF	(0 > 127) || (0 < -128)
      2  6cf4				  -	      ECHO	"Erroneous position value", 0
      3  6cf4				  -	      ERR
      4  6cf4					      ENDIF
      5  6cf4		       00		      .byte.b	0
      0  6cf5					      EVAL8	0
      1  6cf5				  -	      IF	(0 > 127) || (0 < -128)
      2  6cf5				  -	      ECHO	"Erroneous position value", 0
      3  6cf5				  -	      ERR
      4  6cf5					      ENDIF
      5  6cf5		       00		      .byte.b	0
      0  6cf6					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      0  6cf6					      EVAL8	-20
      1  6cf6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cf6				  -	      ECHO	"Erroneous position value", -20
      3  6cf6				  -	      ERR
      4  6cf6					      ENDIF
      5  6cf6		       ec		      .byte.b	-20
      0  6cf7					      EVAL8	-10
      1  6cf7				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cf7				  -	      ECHO	"Erroneous position value", -10
      3  6cf7				  -	      ERR
      4  6cf7					      ENDIF
      5  6cf7		       f6		      .byte.b	-10
      0  6cf8					      EVAL8	-10
      1  6cf8				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cf8				  -	      ECHO	"Erroneous position value", -10
      3  6cf8				  -	      ERR
      4  6cf8					      ENDIF
      5  6cf8		       f6		      .byte.b	-10
      0  6cf9					      EVAL8	-10
      1  6cf9				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cf9				  -	      ECHO	"Erroneous position value", -10
      3  6cf9				  -	      ERR
      4  6cf9					      ENDIF
      5  6cf9		       f6		      .byte.b	-10
      0  6cfa					      EVAL8	-10
      1  6cfa				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cfa				  -	      ECHO	"Erroneous position value", -10
      3  6cfa				  -	      ERR
      4  6cfa					      ENDIF
      5  6cfa		       f6		      .byte.b	-10
      0  6cfb					      EVAL8	-10
      1  6cfb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cfb				  -	      ECHO	"Erroneous position value", -10
      3  6cfb				  -	      ERR
      4  6cfb					      ENDIF
      5  6cfb		       f6		      .byte.b	-10
      0  6cfc					      EVAL8	-10
      1  6cfc				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6cfc				  -	      ECHO	"Erroneous position value", -10
      3  6cfc				  -	      ERR
      4  6cfc					      ENDIF
      5  6cfc		       f6		      .byte.b	-10
      0  6cfd					      EVAL8	-20
      1  6cfd				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6cfd				  -	      ECHO	"Erroneous position value", -20
      3  6cfd				  -	      ERR
      4  6cfd					      ENDIF
      5  6cfd		       ec		      .byte.b	-20
      0  6cfe					      EVAL8	0
      1  6cfe				  -	      IF	(0 > 127) || (0 < -128)
      2  6cfe				  -	      ECHO	"Erroneous position value", 0
      3  6cfe				  -	      ERR
      4  6cfe					      ENDIF
      5  6cfe		       00		      .byte.b	0
      0  6cff					      EVAL8	0
      1  6cff				  -	      IF	(0 > 127) || (0 < -128)
      2  6cff				  -	      ECHO	"Erroneous position value", 0
      3  6cff				  -	      ERR
      4  6cff					      ENDIF
      5  6cff		       00		      .byte.b	0
    111  6d00
    112  6d00
    113  6d00							;---------------------------------------------------------------------------------------------------
    114  6d00
    115  6d00				   PositionalValue_ROOK
    116  6d00
      0  6d00					      PVAL	-25, -25, 10, 20, 10, 10, -25, -25
      0  6d00					      EVAL8	-25
      1  6d00				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6d00				  -	      ECHO	"Erroneous position value", -25
      3  6d00				  -	      ERR
      4  6d00					      ENDIF
      5  6d00		       e7		      .byte.b	-25
      0  6d01					      EVAL8	-25
      1  6d01				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6d01				  -	      ECHO	"Erroneous position value", -25
      3  6d01				  -	      ERR
      4  6d01					      ENDIF
      5  6d01		       e7		      .byte.b	-25
      0  6d02					      EVAL8	10
      1  6d02				  -	      IF	(10 > 127) || (10 < -128)
      2  6d02				  -	      ECHO	"Erroneous position value", 10
      3  6d02				  -	      ERR
      4  6d02					      ENDIF
      5  6d02		       0a		      .byte.b	10
      0  6d03					      EVAL8	20
      1  6d03				  -	      IF	(20 > 127) || (20 < -128)
      2  6d03				  -	      ECHO	"Erroneous position value", 20
      3  6d03				  -	      ERR
      4  6d03					      ENDIF
      5  6d03		       14		      .byte.b	20
      0  6d04					      EVAL8	10
      1  6d04				  -	      IF	(10 > 127) || (10 < -128)
      2  6d04				  -	      ECHO	"Erroneous position value", 10
      3  6d04				  -	      ERR
      4  6d04					      ENDIF
      5  6d04		       0a		      .byte.b	10
      0  6d05					      EVAL8	10
      1  6d05				  -	      IF	(10 > 127) || (10 < -128)
      2  6d05				  -	      ECHO	"Erroneous position value", 10
      3  6d05				  -	      ERR
      4  6d05					      ENDIF
      5  6d05		       0a		      .byte.b	10
      0  6d06					      EVAL8	-25
      1  6d06				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6d06				  -	      ECHO	"Erroneous position value", -25
      3  6d06				  -	      ERR
      4  6d06					      ENDIF
      5  6d06		       e7		      .byte.b	-25
      0  6d07					      EVAL8	-25
      1  6d07				  -	      IF	(-25 > 127) || (-25 < -128)
      2  6d07				  -	      ECHO	"Erroneous position value", -25
      3  6d07				  -	      ERR
      4  6d07					      ENDIF
      5  6d07		       e7		      .byte.b	-25
      0  6d08					      EVAL8	0
      1  6d08				  -	      IF	(0 > 127) || (0 < -128)
      2  6d08				  -	      ECHO	"Erroneous position value", 0
      3  6d08				  -	      ERR
      4  6d08					      ENDIF
      5  6d08		       00		      .byte.b	0
      0  6d09					      EVAL8	0
      1  6d09				  -	      IF	(0 > 127) || (0 < -128)
      2  6d09				  -	      ECHO	"Erroneous position value", 0
      3  6d09				  -	      ERR
      4  6d09					      ENDIF
      5  6d09		       00		      .byte.b	0
      0  6d0a					      PVAL	-120, 0, 0, 0, 0, 0, 0, -128
      0  6d0a					      EVAL8	-120
      1  6d0a				  -	      IF	(-120 > 127) || (-120 < -128)
      2  6d0a				  -	      ECHO	"Erroneous position value", -120
      3  6d0a				  -	      ERR
      4  6d0a					      ENDIF
      5  6d0a		       88		      .byte.b	-120
      0  6d0b					      EVAL8	0
      1  6d0b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0b				  -	      ECHO	"Erroneous position value", 0
      3  6d0b				  -	      ERR
      4  6d0b					      ENDIF
      5  6d0b		       00		      .byte.b	0
      0  6d0c					      EVAL8	0
      1  6d0c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0c				  -	      ECHO	"Erroneous position value", 0
      3  6d0c				  -	      ERR
      4  6d0c					      ENDIF
      5  6d0c		       00		      .byte.b	0
      0  6d0d					      EVAL8	0
      1  6d0d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0d				  -	      ECHO	"Erroneous position value", 0
      3  6d0d				  -	      ERR
      4  6d0d					      ENDIF
      5  6d0d		       00		      .byte.b	0
      0  6d0e					      EVAL8	0
      1  6d0e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0e				  -	      ECHO	"Erroneous position value", 0
      3  6d0e				  -	      ERR
      4  6d0e					      ENDIF
      5  6d0e		       00		      .byte.b	0
      0  6d0f					      EVAL8	0
      1  6d0f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d0f				  -	      ECHO	"Erroneous position value", 0
      3  6d0f				  -	      ERR
      4  6d0f					      ENDIF
      5  6d0f		       00		      .byte.b	0
      0  6d10					      EVAL8	0
      1  6d10				  -	      IF	(0 > 127) || (0 < -128)
      2  6d10				  -	      ECHO	"Erroneous position value", 0
      3  6d10				  -	      ERR
      4  6d10					      ENDIF
      5  6d10		       00		      .byte.b	0
      0  6d11					      EVAL8	-128
      1  6d11				  -	      IF	(-128 > 127) || (-128 < -128)
      2  6d11				  -	      ECHO	"Erroneous position value", -128
      3  6d11				  -	      ERR
      4  6d11					      ENDIF
      5  6d11		       80		      .byte.b	-128
      0  6d12					      EVAL8	0
      1  6d12				  -	      IF	(0 > 127) || (0 < -128)
      2  6d12				  -	      ECHO	"Erroneous position value", 0
      3  6d12				  -	      ERR
      4  6d12					      ENDIF
      5  6d12		       00		      .byte.b	0
      0  6d13					      EVAL8	0
      1  6d13				  -	      IF	(0 > 127) || (0 < -128)
      2  6d13				  -	      ECHO	"Erroneous position value", 0
      3  6d13				  -	      ERR
      4  6d13					      ENDIF
      5  6d13		       00		      .byte.b	0
      0  6d14					      PVAL	30, 0, 0, 0, 0, 0, 0, 30
      0  6d14					      EVAL8	30
      1  6d14				  -	      IF	(30 > 127) || (30 < -128)
      2  6d14				  -	      ECHO	"Erroneous position value", 30
      3  6d14				  -	      ERR
      4  6d14					      ENDIF
      5  6d14		       1e		      .byte.b	30
      0  6d15					      EVAL8	0
      1  6d15				  -	      IF	(0 > 127) || (0 < -128)
      2  6d15				  -	      ECHO	"Erroneous position value", 0
      3  6d15				  -	      ERR
      4  6d15					      ENDIF
      5  6d15		       00		      .byte.b	0
      0  6d16					      EVAL8	0
      1  6d16				  -	      IF	(0 > 127) || (0 < -128)
      2  6d16				  -	      ECHO	"Erroneous position value", 0
      3  6d16				  -	      ERR
      4  6d16					      ENDIF
      5  6d16		       00		      .byte.b	0
      0  6d17					      EVAL8	0
      1  6d17				  -	      IF	(0 > 127) || (0 < -128)
      2  6d17				  -	      ECHO	"Erroneous position value", 0
      3  6d17				  -	      ERR
      4  6d17					      ENDIF
      5  6d17		       00		      .byte.b	0
      0  6d18					      EVAL8	0
      1  6d18				  -	      IF	(0 > 127) || (0 < -128)
      2  6d18				  -	      ECHO	"Erroneous position value", 0
      3  6d18				  -	      ERR
      4  6d18					      ENDIF
      5  6d18		       00		      .byte.b	0
      0  6d19					      EVAL8	0
      1  6d19				  -	      IF	(0 > 127) || (0 < -128)
      2  6d19				  -	      ECHO	"Erroneous position value", 0
      3  6d19				  -	      ERR
      4  6d19					      ENDIF
      5  6d19		       00		      .byte.b	0
      0  6d1a					      EVAL8	0
      1  6d1a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d1a				  -	      ECHO	"Erroneous position value", 0
      3  6d1a				  -	      ERR
      4  6d1a					      ENDIF
      5  6d1a		       00		      .byte.b	0
      0  6d1b					      EVAL8	30
      1  6d1b				  -	      IF	(30 > 127) || (30 < -128)
      2  6d1b				  -	      ECHO	"Erroneous position value", 30
      3  6d1b				  -	      ERR
      4  6d1b					      ENDIF
      5  6d1b		       1e		      .byte.b	30
      0  6d1c					      EVAL8	0
      1  6d1c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d1c				  -	      ECHO	"Erroneous position value", 0
      3  6d1c				  -	      ERR
      4  6d1c					      ENDIF
      5  6d1c		       00		      .byte.b	0
      0  6d1d					      EVAL8	0
      1  6d1d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d1d				  -	      ECHO	"Erroneous position value", 0
      3  6d1d				  -	      ERR
      4  6d1d					      ENDIF
      5  6d1d		       00		      .byte.b	0
      0  6d1e					      PVAL	40, 0, 0, 0, 0, 0, 0, 40
      0  6d1e					      EVAL8	40
      1  6d1e				  -	      IF	(40 > 127) || (40 < -128)
      2  6d1e				  -	      ECHO	"Erroneous position value", 40
      3  6d1e				  -	      ERR
      4  6d1e					      ENDIF
      5  6d1e		       28		      .byte.b	40
      0  6d1f					      EVAL8	0
      1  6d1f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d1f				  -	      ECHO	"Erroneous position value", 0
      3  6d1f				  -	      ERR
      4  6d1f					      ENDIF
      5  6d1f		       00		      .byte.b	0
      0  6d20					      EVAL8	0
      1  6d20				  -	      IF	(0 > 127) || (0 < -128)
      2  6d20				  -	      ECHO	"Erroneous position value", 0
      3  6d20				  -	      ERR
      4  6d20					      ENDIF
      5  6d20		       00		      .byte.b	0
      0  6d21					      EVAL8	0
      1  6d21				  -	      IF	(0 > 127) || (0 < -128)
      2  6d21				  -	      ECHO	"Erroneous position value", 0
      3  6d21				  -	      ERR
      4  6d21					      ENDIF
      5  6d21		       00		      .byte.b	0
      0  6d22					      EVAL8	0
      1  6d22				  -	      IF	(0 > 127) || (0 < -128)
      2  6d22				  -	      ECHO	"Erroneous position value", 0
      3  6d22				  -	      ERR
      4  6d22					      ENDIF
      5  6d22		       00		      .byte.b	0
      0  6d23					      EVAL8	0
      1  6d23				  -	      IF	(0 > 127) || (0 < -128)
      2  6d23				  -	      ECHO	"Erroneous position value", 0
      3  6d23				  -	      ERR
      4  6d23					      ENDIF
      5  6d23		       00		      .byte.b	0
      0  6d24					      EVAL8	0
      1  6d24				  -	      IF	(0 > 127) || (0 < -128)
      2  6d24				  -	      ECHO	"Erroneous position value", 0
      3  6d24				  -	      ERR
      4  6d24					      ENDIF
      5  6d24		       00		      .byte.b	0
      0  6d25					      EVAL8	40
      1  6d25				  -	      IF	(40 > 127) || (40 < -128)
      2  6d25				  -	      ECHO	"Erroneous position value", 40
      3  6d25				  -	      ERR
      4  6d25					      ENDIF
      5  6d25		       28		      .byte.b	40
      0  6d26					      EVAL8	0
      1  6d26				  -	      IF	(0 > 127) || (0 < -128)
      2  6d26				  -	      ECHO	"Erroneous position value", 0
      3  6d26				  -	      ERR
      4  6d26					      ENDIF
      5  6d26		       00		      .byte.b	0
      0  6d27					      EVAL8	0
      1  6d27				  -	      IF	(0 > 127) || (0 < -128)
      2  6d27				  -	      ECHO	"Erroneous position value", 0
      3  6d27				  -	      ERR
      4  6d27					      ENDIF
      5  6d27		       00		      .byte.b	0
      0  6d28					      PVAL	-50, 0, 0, 0, 0, 0, 0, -50
      0  6d28					      EVAL8	-50
      1  6d28				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6d28				  -	      ECHO	"Erroneous position value", -50
      3  6d28				  -	      ERR
      4  6d28					      ENDIF
      5  6d28		       ce		      .byte.b	-50
      0  6d29					      EVAL8	0
      1  6d29				  -	      IF	(0 > 127) || (0 < -128)
      2  6d29				  -	      ECHO	"Erroneous position value", 0
      3  6d29				  -	      ERR
      4  6d29					      ENDIF
      5  6d29		       00		      .byte.b	0
      0  6d2a					      EVAL8	0
      1  6d2a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2a				  -	      ECHO	"Erroneous position value", 0
      3  6d2a				  -	      ERR
      4  6d2a					      ENDIF
      5  6d2a		       00		      .byte.b	0
      0  6d2b					      EVAL8	0
      1  6d2b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2b				  -	      ECHO	"Erroneous position value", 0
      3  6d2b				  -	      ERR
      4  6d2b					      ENDIF
      5  6d2b		       00		      .byte.b	0
      0  6d2c					      EVAL8	0
      1  6d2c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2c				  -	      ECHO	"Erroneous position value", 0
      3  6d2c				  -	      ERR
      4  6d2c					      ENDIF
      5  6d2c		       00		      .byte.b	0
      0  6d2d					      EVAL8	0
      1  6d2d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2d				  -	      ECHO	"Erroneous position value", 0
      3  6d2d				  -	      ERR
      4  6d2d					      ENDIF
      5  6d2d		       00		      .byte.b	0
      0  6d2e					      EVAL8	0
      1  6d2e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d2e				  -	      ECHO	"Erroneous position value", 0
      3  6d2e				  -	      ERR
      4  6d2e					      ENDIF
      5  6d2e		       00		      .byte.b	0
      0  6d2f					      EVAL8	-50
      1  6d2f				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6d2f				  -	      ECHO	"Erroneous position value", -50
      3  6d2f				  -	      ERR
      4  6d2f					      ENDIF
      5  6d2f		       ce		      .byte.b	-50
      0  6d30					      EVAL8	0
      1  6d30				  -	      IF	(0 > 127) || (0 < -128)
      2  6d30				  -	      ECHO	"Erroneous position value", 0
      3  6d30				  -	      ERR
      4  6d30					      ENDIF
      5  6d30		       00		      .byte.b	0
      0  6d31					      EVAL8	0
      1  6d31				  -	      IF	(0 > 127) || (0 < -128)
      2  6d31				  -	      ECHO	"Erroneous position value", 0
      3  6d31				  -	      ERR
      4  6d31					      ENDIF
      5  6d31		       00		      .byte.b	0
      0  6d32					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      0  6d32					      EVAL8	-5
      1  6d32				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d32				  -	      ECHO	"Erroneous position value", -5
      3  6d32				  -	      ERR
      4  6d32					      ENDIF
      5  6d32		       fb		      .byte.b	-5
      0  6d33					      EVAL8	0
      1  6d33				  -	      IF	(0 > 127) || (0 < -128)
      2  6d33				  -	      ECHO	"Erroneous position value", 0
      3  6d33				  -	      ERR
      4  6d33					      ENDIF
      5  6d33		       00		      .byte.b	0
      0  6d34					      EVAL8	30
      1  6d34				  -	      IF	(30 > 127) || (30 < -128)
      2  6d34				  -	      ECHO	"Erroneous position value", 30
      3  6d34				  -	      ERR
      4  6d34					      ENDIF
      5  6d34		       1e		      .byte.b	30
      0  6d35					      EVAL8	30
      1  6d35				  -	      IF	(30 > 127) || (30 < -128)
      2  6d35				  -	      ECHO	"Erroneous position value", 30
      3  6d35				  -	      ERR
      4  6d35					      ENDIF
      5  6d35		       1e		      .byte.b	30
      0  6d36					      EVAL8	30
      1  6d36				  -	      IF	(30 > 127) || (30 < -128)
      2  6d36				  -	      ECHO	"Erroneous position value", 30
      3  6d36				  -	      ERR
      4  6d36					      ENDIF
      5  6d36		       1e		      .byte.b	30
      0  6d37					      EVAL8	30
      1  6d37				  -	      IF	(30 > 127) || (30 < -128)
      2  6d37				  -	      ECHO	"Erroneous position value", 30
      3  6d37				  -	      ERR
      4  6d37					      ENDIF
      5  6d37		       1e		      .byte.b	30
      0  6d38					      EVAL8	0
      1  6d38				  -	      IF	(0 > 127) || (0 < -128)
      2  6d38				  -	      ECHO	"Erroneous position value", 0
      3  6d38				  -	      ERR
      4  6d38					      ENDIF
      5  6d38		       00		      .byte.b	0
      0  6d39					      EVAL8	-5
      1  6d39				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d39				  -	      ECHO	"Erroneous position value", -5
      3  6d39				  -	      ERR
      4  6d39					      ENDIF
      5  6d39		       fb		      .byte.b	-5
      0  6d3a					      EVAL8	0
      1  6d3a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d3a				  -	      ECHO	"Erroneous position value", 0
      3  6d3a				  -	      ERR
      4  6d3a					      ENDIF
      5  6d3a		       00		      .byte.b	0
      0  6d3b					      EVAL8	0
      1  6d3b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d3b				  -	      ECHO	"Erroneous position value", 0
      3  6d3b				  -	      ERR
      4  6d3b					      ENDIF
      5  6d3b		       00		      .byte.b	0
      0  6d3c					      PVAL	55, 80, 90, 90, 90, 90, 80, 55
      0  6d3c					      EVAL8	55
      1  6d3c				  -	      IF	(55 > 127) || (55 < -128)
      2  6d3c				  -	      ECHO	"Erroneous position value", 55
      3  6d3c				  -	      ERR
      4  6d3c					      ENDIF
      5  6d3c		       37		      .byte.b	55
      0  6d3d					      EVAL8	80
      1  6d3d				  -	      IF	(80 > 127) || (80 < -128)
      2  6d3d				  -	      ECHO	"Erroneous position value", 80
      3  6d3d				  -	      ERR
      4  6d3d					      ENDIF
      5  6d3d		       50		      .byte.b	80
      0  6d3e					      EVAL8	90
      1  6d3e				  -	      IF	(90 > 127) || (90 < -128)
      2  6d3e				  -	      ECHO	"Erroneous position value", 90
      3  6d3e				  -	      ERR
      4  6d3e					      ENDIF
      5  6d3e		       5a		      .byte.b	90
      0  6d3f					      EVAL8	90
      1  6d3f				  -	      IF	(90 > 127) || (90 < -128)
      2  6d3f				  -	      ECHO	"Erroneous position value", 90
      3  6d3f				  -	      ERR
      4  6d3f					      ENDIF
      5  6d3f		       5a		      .byte.b	90
      0  6d40					      EVAL8	90
      1  6d40				  -	      IF	(90 > 127) || (90 < -128)
      2  6d40				  -	      ECHO	"Erroneous position value", 90
      3  6d40				  -	      ERR
      4  6d40					      ENDIF
      5  6d40		       5a		      .byte.b	90
      0  6d41					      EVAL8	90
      1  6d41				  -	      IF	(90 > 127) || (90 < -128)
      2  6d41				  -	      ECHO	"Erroneous position value", 90
      3  6d41				  -	      ERR
      4  6d41					      ENDIF
      5  6d41		       5a		      .byte.b	90
      0  6d42					      EVAL8	80
      1  6d42				  -	      IF	(80 > 127) || (80 < -128)
      2  6d42				  -	      ECHO	"Erroneous position value", 80
      3  6d42				  -	      ERR
      4  6d42					      ENDIF
      5  6d42		       50		      .byte.b	80
      0  6d43					      EVAL8	55
      1  6d43				  -	      IF	(55 > 127) || (55 < -128)
      2  6d43				  -	      ECHO	"Erroneous position value", 55
      3  6d43				  -	      ERR
      4  6d43					      ENDIF
      5  6d43		       37		      .byte.b	55
      0  6d44					      EVAL8	0
      1  6d44				  -	      IF	(0 > 127) || (0 < -128)
      2  6d44				  -	      ECHO	"Erroneous position value", 0
      3  6d44				  -	      ERR
      4  6d44					      ENDIF
      5  6d44		       00		      .byte.b	0
      0  6d45					      EVAL8	0
      1  6d45				  -	      IF	(0 > 127) || (0 < -128)
      2  6d45				  -	      ECHO	"Erroneous position value", 0
      3  6d45				  -	      ERR
      4  6d45					      ENDIF
      5  6d45		       00		      .byte.b	0
      0  6d46					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      0  6d46					      EVAL8	0
      1  6d46				  -	      IF	(0 > 127) || (0 < -128)
      2  6d46				  -	      ECHO	"Erroneous position value", 0
      3  6d46				  -	      ERR
      4  6d46					      ENDIF
      5  6d46		       00		      .byte.b	0
      0  6d47					      EVAL8	0
      1  6d47				  -	      IF	(0 > 127) || (0 < -128)
      2  6d47				  -	      ECHO	"Erroneous position value", 0
      3  6d47				  -	      ERR
      4  6d47					      ENDIF
      5  6d47		       00		      .byte.b	0
      0  6d48					      EVAL8	0
      1  6d48				  -	      IF	(0 > 127) || (0 < -128)
      2  6d48				  -	      ECHO	"Erroneous position value", 0
      3  6d48				  -	      ERR
      4  6d48					      ENDIF
      5  6d48		       00		      .byte.b	0
      0  6d49					      EVAL8	0
      1  6d49				  -	      IF	(0 > 127) || (0 < -128)
      2  6d49				  -	      ECHO	"Erroneous position value", 0
      3  6d49				  -	      ERR
      4  6d49					      ENDIF
      5  6d49		       00		      .byte.b	0
      0  6d4a					      EVAL8	0
      1  6d4a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4a				  -	      ECHO	"Erroneous position value", 0
      3  6d4a				  -	      ERR
      4  6d4a					      ENDIF
      5  6d4a		       00		      .byte.b	0
      0  6d4b					      EVAL8	0
      1  6d4b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4b				  -	      ECHO	"Erroneous position value", 0
      3  6d4b				  -	      ERR
      4  6d4b					      ENDIF
      5  6d4b		       00		      .byte.b	0
      0  6d4c					      EVAL8	0
      1  6d4c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4c				  -	      ECHO	"Erroneous position value", 0
      3  6d4c				  -	      ERR
      4  6d4c					      ENDIF
      5  6d4c		       00		      .byte.b	0
      0  6d4d					      EVAL8	0
      1  6d4d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4d				  -	      ECHO	"Erroneous position value", 0
      3  6d4d				  -	      ERR
      4  6d4d					      ENDIF
      5  6d4d		       00		      .byte.b	0
      0  6d4e					      EVAL8	0
      1  6d4e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4e				  -	      ECHO	"Erroneous position value", 0
      3  6d4e				  -	      ERR
      4  6d4e					      ENDIF
      5  6d4e		       00		      .byte.b	0
      0  6d4f					      EVAL8	0
      1  6d4f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d4f				  -	      ECHO	"Erroneous position value", 0
      3  6d4f				  -	      ERR
      4  6d4f					      ENDIF
      5  6d4f		       00		      .byte.b	0
    125  6d50
    126  6d50
    127  6d50							;---------------------------------------------------------------------------------------------------
    128  6d50
    129  6d50				   PositionalValue_QUEEN
    130  6d50
      0  6d50					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      0  6d50					      EVAL8	-20
      1  6d50				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6d50				  -	      ECHO	"Erroneous position value", -20
      3  6d50				  -	      ERR
      4  6d50					      ENDIF
      5  6d50		       ec		      .byte.b	-20
      0  6d51					      EVAL8	-10
      1  6d51				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d51				  -	      ECHO	"Erroneous position value", -10
      3  6d51				  -	      ERR
      4  6d51					      ENDIF
      5  6d51		       f6		      .byte.b	-10
      0  6d52					      EVAL8	-5
      1  6d52				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d52				  -	      ECHO	"Erroneous position value", -5
      3  6d52				  -	      ERR
      4  6d52					      ENDIF
      5  6d52		       fb		      .byte.b	-5
      0  6d53					      EVAL8	-5
      1  6d53				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d53				  -	      ECHO	"Erroneous position value", -5
      3  6d53				  -	      ERR
      4  6d53					      ENDIF
      5  6d53		       fb		      .byte.b	-5
      0  6d54					      EVAL8	-5
      1  6d54				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d54				  -	      ECHO	"Erroneous position value", -5
      3  6d54				  -	      ERR
      4  6d54					      ENDIF
      5  6d54		       fb		      .byte.b	-5
      0  6d55					      EVAL8	-10
      1  6d55				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d55				  -	      ECHO	"Erroneous position value", -10
      3  6d55				  -	      ERR
      4  6d55					      ENDIF
      5  6d55		       f6		      .byte.b	-10
      0  6d56					      EVAL8	-10
      1  6d56				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d56				  -	      ECHO	"Erroneous position value", -10
      3  6d56				  -	      ERR
      4  6d56					      ENDIF
      5  6d56		       f6		      .byte.b	-10
      0  6d57					      EVAL8	-20
      1  6d57				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6d57				  -	      ECHO	"Erroneous position value", -20
      3  6d57				  -	      ERR
      4  6d57					      ENDIF
      5  6d57		       ec		      .byte.b	-20
      0  6d58					      EVAL8	0
      1  6d58				  -	      IF	(0 > 127) || (0 < -128)
      2  6d58				  -	      ECHO	"Erroneous position value", 0
      3  6d58				  -	      ERR
      4  6d58					      ENDIF
      5  6d58		       00		      .byte.b	0
      0  6d59					      EVAL8	0
      1  6d59				  -	      IF	(0 > 127) || (0 < -128)
      2  6d59				  -	      ECHO	"Erroneous position value", 0
      3  6d59				  -	      ERR
      4  6d59					      ENDIF
      5  6d59		       00		      .byte.b	0
      0  6d5a					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      0  6d5a					      EVAL8	-10
      1  6d5a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d5a				  -	      ECHO	"Erroneous position value", -10
      3  6d5a				  -	      ERR
      4  6d5a					      ENDIF
      5  6d5a		       f6		      .byte.b	-10
      0  6d5b					      EVAL8	0
      1  6d5b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d5b				  -	      ECHO	"Erroneous position value", 0
      3  6d5b				  -	      ERR
      4  6d5b					      ENDIF
      5  6d5b		       00		      .byte.b	0
      0  6d5c					      EVAL8	5
      1  6d5c				  -	      IF	(5 > 127) || (5 < -128)
      2  6d5c				  -	      ECHO	"Erroneous position value", 5
      3  6d5c				  -	      ERR
      4  6d5c					      ENDIF
      5  6d5c		       05		      .byte.b	5
      0  6d5d					      EVAL8	0
      1  6d5d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d5d				  -	      ECHO	"Erroneous position value", 0
      3  6d5d				  -	      ERR
      4  6d5d					      ENDIF
      5  6d5d		       00		      .byte.b	0
      0  6d5e					      EVAL8	0
      1  6d5e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d5e				  -	      ECHO	"Erroneous position value", 0
      3  6d5e				  -	      ERR
      4  6d5e					      ENDIF
      5  6d5e		       00		      .byte.b	0
      0  6d5f					      EVAL8	0
      1  6d5f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d5f				  -	      ECHO	"Erroneous position value", 0
      3  6d5f				  -	      ERR
      4  6d5f					      ENDIF
      5  6d5f		       00		      .byte.b	0
      0  6d60					      EVAL8	0
      1  6d60				  -	      IF	(0 > 127) || (0 < -128)
      2  6d60				  -	      ECHO	"Erroneous position value", 0
      3  6d60				  -	      ERR
      4  6d60					      ENDIF
      5  6d60		       00		      .byte.b	0
      0  6d61					      EVAL8	-10
      1  6d61				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d61				  -	      ECHO	"Erroneous position value", -10
      3  6d61				  -	      ERR
      4  6d61					      ENDIF
      5  6d61		       f6		      .byte.b	-10
      0  6d62					      EVAL8	0
      1  6d62				  -	      IF	(0 > 127) || (0 < -128)
      2  6d62				  -	      ECHO	"Erroneous position value", 0
      3  6d62				  -	      ERR
      4  6d62					      ENDIF
      5  6d62		       00		      .byte.b	0
      0  6d63					      EVAL8	0
      1  6d63				  -	      IF	(0 > 127) || (0 < -128)
      2  6d63				  -	      ECHO	"Erroneous position value", 0
      3  6d63				  -	      ERR
      4  6d63					      ENDIF
      5  6d63		       00		      .byte.b	0
      0  6d64					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      0  6d64					      EVAL8	-10
      1  6d64				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d64				  -	      ECHO	"Erroneous position value", -10
      3  6d64				  -	      ERR
      4  6d64					      ENDIF
      5  6d64		       f6		      .byte.b	-10
      0  6d65					      EVAL8	5
      1  6d65				  -	      IF	(5 > 127) || (5 < -128)
      2  6d65				  -	      ECHO	"Erroneous position value", 5
      3  6d65				  -	      ERR
      4  6d65					      ENDIF
      5  6d65		       05		      .byte.b	5
      0  6d66					      EVAL8	5
      1  6d66				  -	      IF	(5 > 127) || (5 < -128)
      2  6d66				  -	      ECHO	"Erroneous position value", 5
      3  6d66				  -	      ERR
      4  6d66					      ENDIF
      5  6d66		       05		      .byte.b	5
      0  6d67					      EVAL8	5
      1  6d67				  -	      IF	(5 > 127) || (5 < -128)
      2  6d67				  -	      ECHO	"Erroneous position value", 5
      3  6d67				  -	      ERR
      4  6d67					      ENDIF
      5  6d67		       05		      .byte.b	5
      0  6d68					      EVAL8	5
      1  6d68				  -	      IF	(5 > 127) || (5 < -128)
      2  6d68				  -	      ECHO	"Erroneous position value", 5
      3  6d68				  -	      ERR
      4  6d68					      ENDIF
      5  6d68		       05		      .byte.b	5
      0  6d69					      EVAL8	25
      1  6d69				  -	      IF	(25 > 127) || (25 < -128)
      2  6d69				  -	      ECHO	"Erroneous position value", 25
      3  6d69				  -	      ERR
      4  6d69					      ENDIF
      5  6d69		       19		      .byte.b	25
      0  6d6a					      EVAL8	0
      1  6d6a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d6a				  -	      ECHO	"Erroneous position value", 0
      3  6d6a				  -	      ERR
      4  6d6a					      ENDIF
      5  6d6a		       00		      .byte.b	0
      0  6d6b					      EVAL8	-10
      1  6d6b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d6b				  -	      ECHO	"Erroneous position value", -10
      3  6d6b				  -	      ERR
      4  6d6b					      ENDIF
      5  6d6b		       f6		      .byte.b	-10
      0  6d6c					      EVAL8	0
      1  6d6c				  -	      IF	(0 > 127) || (0 < -128)
      2  6d6c				  -	      ECHO	"Erroneous position value", 0
      3  6d6c				  -	      ERR
      4  6d6c					      ENDIF
      5  6d6c		       00		      .byte.b	0
      0  6d6d					      EVAL8	0
      1  6d6d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d6d				  -	      ECHO	"Erroneous position value", 0
      3  6d6d				  -	      ERR
      4  6d6d					      ENDIF
      5  6d6d		       00		      .byte.b	0
      0  6d6e					      PVAL	-10, 0, 25, 25, 25, 25, 0, -10
      0  6d6e					      EVAL8	-10
      1  6d6e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d6e				  -	      ECHO	"Erroneous position value", -10
      3  6d6e				  -	      ERR
      4  6d6e					      ENDIF
      5  6d6e		       f6		      .byte.b	-10
      0  6d6f					      EVAL8	0
      1  6d6f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d6f				  -	      ECHO	"Erroneous position value", 0
      3  6d6f				  -	      ERR
      4  6d6f					      ENDIF
      5  6d6f		       00		      .byte.b	0
      0  6d70					      EVAL8	25
      1  6d70				  -	      IF	(25 > 127) || (25 < -128)
      2  6d70				  -	      ECHO	"Erroneous position value", 25
      3  6d70				  -	      ERR
      4  6d70					      ENDIF
      5  6d70		       19		      .byte.b	25
      0  6d71					      EVAL8	25
      1  6d71				  -	      IF	(25 > 127) || (25 < -128)
      2  6d71				  -	      ECHO	"Erroneous position value", 25
      3  6d71				  -	      ERR
      4  6d71					      ENDIF
      5  6d71		       19		      .byte.b	25
      0  6d72					      EVAL8	25
      1  6d72				  -	      IF	(25 > 127) || (25 < -128)
      2  6d72				  -	      ECHO	"Erroneous position value", 25
      3  6d72				  -	      ERR
      4  6d72					      ENDIF
      5  6d72		       19		      .byte.b	25
      0  6d73					      EVAL8	25
      1  6d73				  -	      IF	(25 > 127) || (25 < -128)
      2  6d73				  -	      ECHO	"Erroneous position value", 25
      3  6d73				  -	      ERR
      4  6d73					      ENDIF
      5  6d73		       19		      .byte.b	25
      0  6d74					      EVAL8	0
      1  6d74				  -	      IF	(0 > 127) || (0 < -128)
      2  6d74				  -	      ECHO	"Erroneous position value", 0
      3  6d74				  -	      ERR
      4  6d74					      ENDIF
      5  6d74		       00		      .byte.b	0
      0  6d75					      EVAL8	-10
      1  6d75				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d75				  -	      ECHO	"Erroneous position value", -10
      3  6d75				  -	      ERR
      4  6d75					      ENDIF
      5  6d75		       f6		      .byte.b	-10
      0  6d76					      EVAL8	0
      1  6d76				  -	      IF	(0 > 127) || (0 < -128)
      2  6d76				  -	      ECHO	"Erroneous position value", 0
      3  6d76				  -	      ERR
      4  6d76					      ENDIF
      5  6d76		       00		      .byte.b	0
      0  6d77					      EVAL8	0
      1  6d77				  -	      IF	(0 > 127) || (0 < -128)
      2  6d77				  -	      ECHO	"Erroneous position value", 0
      3  6d77				  -	      ERR
      4  6d77					      ENDIF
      5  6d77		       00		      .byte.b	0
      0  6d78					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      0  6d78					      EVAL8	-5
      1  6d78				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d78				  -	      ECHO	"Erroneous position value", -5
      3  6d78				  -	      ERR
      4  6d78					      ENDIF
      5  6d78		       fb		      .byte.b	-5
      0  6d79					      EVAL8	0
      1  6d79				  -	      IF	(0 > 127) || (0 < -128)
      2  6d79				  -	      ECHO	"Erroneous position value", 0
      3  6d79				  -	      ERR
      4  6d79					      ENDIF
      5  6d79		       00		      .byte.b	0
      0  6d7a					      EVAL8	15
      1  6d7a				  -	      IF	(15 > 127) || (15 < -128)
      2  6d7a				  -	      ECHO	"Erroneous position value", 15
      3  6d7a				  -	      ERR
      4  6d7a					      ENDIF
      5  6d7a		       0f		      .byte.b	15
      0  6d7b					      EVAL8	55
      1  6d7b				  -	      IF	(55 > 127) || (55 < -128)
      2  6d7b				  -	      ECHO	"Erroneous position value", 55
      3  6d7b				  -	      ERR
      4  6d7b					      ENDIF
      5  6d7b		       37		      .byte.b	55
      0  6d7c					      EVAL8	55
      1  6d7c				  -	      IF	(55 > 127) || (55 < -128)
      2  6d7c				  -	      ECHO	"Erroneous position value", 55
      3  6d7c				  -	      ERR
      4  6d7c					      ENDIF
      5  6d7c		       37		      .byte.b	55
      0  6d7d					      EVAL8	55
      1  6d7d				  -	      IF	(55 > 127) || (55 < -128)
      2  6d7d				  -	      ECHO	"Erroneous position value", 55
      3  6d7d				  -	      ERR
      4  6d7d					      ENDIF
      5  6d7d		       37		      .byte.b	55
      0  6d7e					      EVAL8	0
      1  6d7e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d7e				  -	      ECHO	"Erroneous position value", 0
      3  6d7e				  -	      ERR
      4  6d7e					      ENDIF
      5  6d7e		       00		      .byte.b	0
      0  6d7f					      EVAL8	-5
      1  6d7f				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d7f				  -	      ECHO	"Erroneous position value", -5
      3  6d7f				  -	      ERR
      4  6d7f					      ENDIF
      5  6d7f		       fb		      .byte.b	-5
      0  6d80					      EVAL8	0
      1  6d80				  -	      IF	(0 > 127) || (0 < -128)
      2  6d80				  -	      ECHO	"Erroneous position value", 0
      3  6d80				  -	      ERR
      4  6d80					      ENDIF
      5  6d80		       00		      .byte.b	0
      0  6d81					      EVAL8	0
      1  6d81				  -	      IF	(0 > 127) || (0 < -128)
      2  6d81				  -	      ECHO	"Erroneous position value", 0
      3  6d81				  -	      ERR
      4  6d81					      ENDIF
      5  6d81		       00		      .byte.b	0
      0  6d82					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      0  6d82					      EVAL8	-10
      1  6d82				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d82				  -	      ECHO	"Erroneous position value", -10
      3  6d82				  -	      ERR
      4  6d82					      ENDIF
      5  6d82		       f6		      .byte.b	-10
      0  6d83					      EVAL8	0
      1  6d83				  -	      IF	(0 > 127) || (0 < -128)
      2  6d83				  -	      ECHO	"Erroneous position value", 0
      3  6d83				  -	      ERR
      4  6d83					      ENDIF
      5  6d83		       00		      .byte.b	0
      0  6d84					      EVAL8	25
      1  6d84				  -	      IF	(25 > 127) || (25 < -128)
      2  6d84				  -	      ECHO	"Erroneous position value", 25
      3  6d84				  -	      ERR
      4  6d84					      ENDIF
      5  6d84		       19		      .byte.b	25
      0  6d85					      EVAL8	75
      1  6d85				  -	      IF	(75 > 127) || (75 < -128)
      2  6d85				  -	      ECHO	"Erroneous position value", 75
      3  6d85				  -	      ERR
      4  6d85					      ENDIF
      5  6d85		       4b		      .byte.b	75
      0  6d86					      EVAL8	75
      1  6d86				  -	      IF	(75 > 127) || (75 < -128)
      2  6d86				  -	      ECHO	"Erroneous position value", 75
      3  6d86				  -	      ERR
      4  6d86					      ENDIF
      5  6d86		       4b		      .byte.b	75
      0  6d87					      EVAL8	75
      1  6d87				  -	      IF	(75 > 127) || (75 < -128)
      2  6d87				  -	      ECHO	"Erroneous position value", 75
      3  6d87				  -	      ERR
      4  6d87					      ENDIF
      5  6d87		       4b		      .byte.b	75
      0  6d88					      EVAL8	0
      1  6d88				  -	      IF	(0 > 127) || (0 < -128)
      2  6d88				  -	      ECHO	"Erroneous position value", 0
      3  6d88				  -	      ERR
      4  6d88					      ENDIF
      5  6d88		       00		      .byte.b	0
      0  6d89					      EVAL8	-10
      1  6d89				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d89				  -	      ECHO	"Erroneous position value", -10
      3  6d89				  -	      ERR
      4  6d89					      ENDIF
      5  6d89		       f6		      .byte.b	-10
      0  6d8a					      EVAL8	0
      1  6d8a				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8a				  -	      ECHO	"Erroneous position value", 0
      3  6d8a				  -	      ERR
      4  6d8a					      ENDIF
      5  6d8a		       00		      .byte.b	0
      0  6d8b					      EVAL8	0
      1  6d8b				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8b				  -	      ECHO	"Erroneous position value", 0
      3  6d8b				  -	      ERR
      4  6d8b					      ENDIF
      5  6d8b		       00		      .byte.b	0
      0  6d8c					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      0  6d8c					      EVAL8	-10
      1  6d8c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d8c				  -	      ECHO	"Erroneous position value", -10
      3  6d8c				  -	      ERR
      4  6d8c					      ENDIF
      5  6d8c		       f6		      .byte.b	-10
      0  6d8d					      EVAL8	0
      1  6d8d				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8d				  -	      ECHO	"Erroneous position value", 0
      3  6d8d				  -	      ERR
      4  6d8d					      ENDIF
      5  6d8d		       00		      .byte.b	0
      0  6d8e					      EVAL8	0
      1  6d8e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8e				  -	      ECHO	"Erroneous position value", 0
      3  6d8e				  -	      ERR
      4  6d8e					      ENDIF
      5  6d8e		       00		      .byte.b	0
      0  6d8f					      EVAL8	0
      1  6d8f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d8f				  -	      ECHO	"Erroneous position value", 0
      3  6d8f				  -	      ERR
      4  6d8f					      ENDIF
      5  6d8f		       00		      .byte.b	0
      0  6d90					      EVAL8	0
      1  6d90				  -	      IF	(0 > 127) || (0 < -128)
      2  6d90				  -	      ECHO	"Erroneous position value", 0
      3  6d90				  -	      ERR
      4  6d90					      ENDIF
      5  6d90		       00		      .byte.b	0
      0  6d91					      EVAL8	0
      1  6d91				  -	      IF	(0 > 127) || (0 < -128)
      2  6d91				  -	      ECHO	"Erroneous position value", 0
      3  6d91				  -	      ERR
      4  6d91					      ENDIF
      5  6d91		       00		      .byte.b	0
      0  6d92					      EVAL8	0
      1  6d92				  -	      IF	(0 > 127) || (0 < -128)
      2  6d92				  -	      ECHO	"Erroneous position value", 0
      3  6d92				  -	      ERR
      4  6d92					      ENDIF
      5  6d92		       00		      .byte.b	0
      0  6d93					      EVAL8	-10
      1  6d93				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d93				  -	      ECHO	"Erroneous position value", -10
      3  6d93				  -	      ERR
      4  6d93					      ENDIF
      5  6d93		       f6		      .byte.b	-10
      0  6d94					      EVAL8	0
      1  6d94				  -	      IF	(0 > 127) || (0 < -128)
      2  6d94				  -	      ECHO	"Erroneous position value", 0
      3  6d94				  -	      ERR
      4  6d94					      ENDIF
      5  6d94		       00		      .byte.b	0
      0  6d95					      EVAL8	0
      1  6d95				  -	      IF	(0 > 127) || (0 < -128)
      2  6d95				  -	      ECHO	"Erroneous position value", 0
      3  6d95				  -	      ERR
      4  6d95					      ENDIF
      5  6d95		       00		      .byte.b	0
      0  6d96					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      0  6d96					      EVAL8	-20
      1  6d96				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6d96				  -	      ECHO	"Erroneous position value", -20
      3  6d96				  -	      ERR
      4  6d96					      ENDIF
      5  6d96		       ec		      .byte.b	-20
      0  6d97					      EVAL8	-10
      1  6d97				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d97				  -	      ECHO	"Erroneous position value", -10
      3  6d97				  -	      ERR
      4  6d97					      ENDIF
      5  6d97		       f6		      .byte.b	-10
      0  6d98					      EVAL8	-10
      1  6d98				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d98				  -	      ECHO	"Erroneous position value", -10
      3  6d98				  -	      ERR
      4  6d98					      ENDIF
      5  6d98		       f6		      .byte.b	-10
      0  6d99					      EVAL8	-5
      1  6d99				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d99				  -	      ECHO	"Erroneous position value", -5
      3  6d99				  -	      ERR
      4  6d99					      ENDIF
      5  6d99		       fb		      .byte.b	-5
      0  6d9a					      EVAL8	-5
      1  6d9a				  -	      IF	(-5 > 127) || (-5 < -128)
      2  6d9a				  -	      ECHO	"Erroneous position value", -5
      3  6d9a				  -	      ERR
      4  6d9a					      ENDIF
      5  6d9a		       fb		      .byte.b	-5
      0  6d9b					      EVAL8	-10
      1  6d9b				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d9b				  -	      ECHO	"Erroneous position value", -10
      3  6d9b				  -	      ERR
      4  6d9b					      ENDIF
      5  6d9b		       f6		      .byte.b	-10
      0  6d9c					      EVAL8	-10
      1  6d9c				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6d9c				  -	      ECHO	"Erroneous position value", -10
      3  6d9c				  -	      ERR
      4  6d9c					      ENDIF
      5  6d9c		       f6		      .byte.b	-10
      0  6d9d					      EVAL8	-20
      1  6d9d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6d9d				  -	      ECHO	"Erroneous position value", -20
      3  6d9d				  -	      ERR
      4  6d9d					      ENDIF
      5  6d9d		       ec		      .byte.b	-20
      0  6d9e					      EVAL8	0
      1  6d9e				  -	      IF	(0 > 127) || (0 < -128)
      2  6d9e				  -	      ECHO	"Erroneous position value", 0
      3  6d9e				  -	      ERR
      4  6d9e					      ENDIF
      5  6d9e		       00		      .byte.b	0
      0  6d9f					      EVAL8	0
      1  6d9f				  -	      IF	(0 > 127) || (0 < -128)
      2  6d9f				  -	      ECHO	"Erroneous position value", 0
      3  6d9f				  -	      ERR
      4  6d9f					      ENDIF
      5  6d9f		       00		      .byte.b	0
    139  6da0
    140  6da0
    141  6da0							;---------------------------------------------------------------------------------------------------
    142  6da0
    143  6da0				   PositionalValue_KING_MIDGAME
    144  6da0
      0  6da0					      PVAL	0, 0, 20, -40, -40, -20, 20, 0
      0  6da0					      EVAL8	0
      1  6da0				  -	      IF	(0 > 127) || (0 < -128)
      2  6da0				  -	      ECHO	"Erroneous position value", 0
      3  6da0				  -	      ERR
      4  6da0					      ENDIF
      5  6da0		       00		      .byte.b	0
      0  6da1					      EVAL8	0
      1  6da1				  -	      IF	(0 > 127) || (0 < -128)
      2  6da1				  -	      ECHO	"Erroneous position value", 0
      3  6da1				  -	      ERR
      4  6da1					      ENDIF
      5  6da1		       00		      .byte.b	0
      0  6da2					      EVAL8	20
      1  6da2				  -	      IF	(20 > 127) || (20 < -128)
      2  6da2				  -	      ECHO	"Erroneous position value", 20
      3  6da2				  -	      ERR
      4  6da2					      ENDIF
      5  6da2		       14		      .byte.b	20
      0  6da3					      EVAL8	-40
      1  6da3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6da3				  -	      ECHO	"Erroneous position value", -40
      3  6da3				  -	      ERR
      4  6da3					      ENDIF
      5  6da3		       d8		      .byte.b	-40
      0  6da4					      EVAL8	-40
      1  6da4				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6da4				  -	      ECHO	"Erroneous position value", -40
      3  6da4				  -	      ERR
      4  6da4					      ENDIF
      5  6da4		       d8		      .byte.b	-40
      0  6da5					      EVAL8	-20
      1  6da5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6da5				  -	      ECHO	"Erroneous position value", -20
      3  6da5				  -	      ERR
      4  6da5					      ENDIF
      5  6da5		       ec		      .byte.b	-20
      0  6da6					      EVAL8	20
      1  6da6				  -	      IF	(20 > 127) || (20 < -128)
      2  6da6				  -	      ECHO	"Erroneous position value", 20
      3  6da6				  -	      ERR
      4  6da6					      ENDIF
      5  6da6		       14		      .byte.b	20
      0  6da7					      EVAL8	0
      1  6da7				  -	      IF	(0 > 127) || (0 < -128)
      2  6da7				  -	      ECHO	"Erroneous position value", 0
      3  6da7				  -	      ERR
      4  6da7					      ENDIF
      5  6da7		       00		      .byte.b	0
      0  6da8					      EVAL8	0
      1  6da8				  -	      IF	(0 > 127) || (0 < -128)
      2  6da8				  -	      ECHO	"Erroneous position value", 0
      3  6da8				  -	      ERR
      4  6da8					      ENDIF
      5  6da8		       00		      .byte.b	0
      0  6da9					      EVAL8	0
      1  6da9				  -	      IF	(0 > 127) || (0 < -128)
      2  6da9				  -	      ECHO	"Erroneous position value", 0
      3  6da9				  -	      ERR
      4  6da9					      ENDIF
      5  6da9		       00		      .byte.b	0
      0  6daa					      PVAL	0, 0, -80, -80, -70, -70, 0, 0
      0  6daa					      EVAL8	0
      1  6daa				  -	      IF	(0 > 127) || (0 < -128)
      2  6daa				  -	      ECHO	"Erroneous position value", 0
      3  6daa				  -	      ERR
      4  6daa					      ENDIF
      5  6daa		       00		      .byte.b	0
      0  6dab					      EVAL8	0
      1  6dab				  -	      IF	(0 > 127) || (0 < -128)
      2  6dab				  -	      ECHO	"Erroneous position value", 0
      3  6dab				  -	      ERR
      4  6dab					      ENDIF
      5  6dab		       00		      .byte.b	0
      0  6dac					      EVAL8	-80
      1  6dac				  -	      IF	(-80 > 127) || (-80 < -128)
      2  6dac				  -	      ECHO	"Erroneous position value", -80
      3  6dac				  -	      ERR
      4  6dac					      ENDIF
      5  6dac		       b0		      .byte.b	-80
      0  6dad					      EVAL8	-80
      1  6dad				  -	      IF	(-80 > 127) || (-80 < -128)
      2  6dad				  -	      ECHO	"Erroneous position value", -80
      3  6dad				  -	      ERR
      4  6dad					      ENDIF
      5  6dad		       b0		      .byte.b	-80
      0  6dae					      EVAL8	-70
      1  6dae				  -	      IF	(-70 > 127) || (-70 < -128)
      2  6dae				  -	      ECHO	"Erroneous position value", -70
      3  6dae				  -	      ERR
      4  6dae					      ENDIF
      5  6dae		       ba		      .byte.b	-70
      0  6daf					      EVAL8	-70
      1  6daf				  -	      IF	(-70 > 127) || (-70 < -128)
      2  6daf				  -	      ECHO	"Erroneous position value", -70
      3  6daf				  -	      ERR
      4  6daf					      ENDIF
      5  6daf		       ba		      .byte.b	-70
      0  6db0					      EVAL8	0
      1  6db0				  -	      IF	(0 > 127) || (0 < -128)
      2  6db0				  -	      ECHO	"Erroneous position value", 0
      3  6db0				  -	      ERR
      4  6db0					      ENDIF
      5  6db0		       00		      .byte.b	0
      0  6db1					      EVAL8	0
      1  6db1				  -	      IF	(0 > 127) || (0 < -128)
      2  6db1				  -	      ECHO	"Erroneous position value", 0
      3  6db1				  -	      ERR
      4  6db1					      ENDIF
      5  6db1		       00		      .byte.b	0
      0  6db2					      EVAL8	0
      1  6db2				  -	      IF	(0 > 127) || (0 < -128)
      2  6db2				  -	      ECHO	"Erroneous position value", 0
      3  6db2				  -	      ERR
      4  6db2					      ENDIF
      5  6db2		       00		      .byte.b	0
      0  6db3					      EVAL8	0
      1  6db3				  -	      IF	(0 > 127) || (0 < -128)
      2  6db3				  -	      ECHO	"Erroneous position value", 0
      3  6db3				  -	      ERR
      4  6db3					      ENDIF
      5  6db3		       00		      .byte.b	0
      0  6db4					      PVAL	-10, -20, -20, -50, -60, -60, -20, -10
      0  6db4					      EVAL8	-10
      1  6db4				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6db4				  -	      ECHO	"Erroneous position value", -10
      3  6db4				  -	      ERR
      4  6db4					      ENDIF
      5  6db4		       f6		      .byte.b	-10
      0  6db5					      EVAL8	-20
      1  6db5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6db5				  -	      ECHO	"Erroneous position value", -20
      3  6db5				  -	      ERR
      4  6db5					      ENDIF
      5  6db5		       ec		      .byte.b	-20
      0  6db6					      EVAL8	-20
      1  6db6				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6db6				  -	      ECHO	"Erroneous position value", -20
      3  6db6				  -	      ERR
      4  6db6					      ENDIF
      5  6db6		       ec		      .byte.b	-20
      0  6db7					      EVAL8	-50
      1  6db7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6db7				  -	      ECHO	"Erroneous position value", -50
      3  6db7				  -	      ERR
      4  6db7					      ENDIF
      5  6db7		       ce		      .byte.b	-50
      0  6db8					      EVAL8	-60
      1  6db8				  -	      IF	(-60 > 127) || (-60 < -128)
      2  6db8				  -	      ECHO	"Erroneous position value", -60
      3  6db8				  -	      ERR
      4  6db8					      ENDIF
      5  6db8		       c4		      .byte.b	-60
      0  6db9					      EVAL8	-60
      1  6db9				  -	      IF	(-60 > 127) || (-60 < -128)
      2  6db9				  -	      ECHO	"Erroneous position value", -60
      3  6db9				  -	      ERR
      4  6db9					      ENDIF
      5  6db9		       c4		      .byte.b	-60
      0  6dba					      EVAL8	-20
      1  6dba				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6dba				  -	      ECHO	"Erroneous position value", -20
      3  6dba				  -	      ERR
      4  6dba					      ENDIF
      5  6dba		       ec		      .byte.b	-20
      0  6dbb					      EVAL8	-10
      1  6dbb				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6dbb				  -	      ECHO	"Erroneous position value", -10
      3  6dbb				  -	      ERR
      4  6dbb					      ENDIF
      5  6dbb		       f6		      .byte.b	-10
      0  6dbc					      EVAL8	0
      1  6dbc				  -	      IF	(0 > 127) || (0 < -128)
      2  6dbc				  -	      ECHO	"Erroneous position value", 0
      3  6dbc				  -	      ERR
      4  6dbc					      ENDIF
      5  6dbc		       00		      .byte.b	0
      0  6dbd					      EVAL8	0
      1  6dbd				  -	      IF	(0 > 127) || (0 < -128)
      2  6dbd				  -	      ECHO	"Erroneous position value", 0
      3  6dbd				  -	      ERR
      4  6dbd					      ENDIF
      5  6dbd		       00		      .byte.b	0
      0  6dbe					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      0  6dbe					      EVAL8	-20
      1  6dbe				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6dbe				  -	      ECHO	"Erroneous position value", -20
      3  6dbe				  -	      ERR
      4  6dbe					      ENDIF
      5  6dbe		       ec		      .byte.b	-20
      0  6dbf					      EVAL8	-30
      1  6dbf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dbf				  -	      ECHO	"Erroneous position value", -30
      3  6dbf				  -	      ERR
      4  6dbf					      ENDIF
      5  6dbf		       e2		      .byte.b	-30
      0  6dc0					      EVAL8	-30
      1  6dc0				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dc0				  -	      ECHO	"Erroneous position value", -30
      3  6dc0				  -	      ERR
      4  6dc0					      ENDIF
      5  6dc0		       e2		      .byte.b	-30
      0  6dc1					      EVAL8	-40
      1  6dc1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dc1				  -	      ECHO	"Erroneous position value", -40
      3  6dc1				  -	      ERR
      4  6dc1					      ENDIF
      5  6dc1		       d8		      .byte.b	-40
      0  6dc2					      EVAL8	-40
      1  6dc2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dc2				  -	      ECHO	"Erroneous position value", -40
      3  6dc2				  -	      ERR
      4  6dc2					      ENDIF
      5  6dc2		       d8		      .byte.b	-40
      0  6dc3					      EVAL8	-30
      1  6dc3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dc3				  -	      ECHO	"Erroneous position value", -30
      3  6dc3				  -	      ERR
      4  6dc3					      ENDIF
      5  6dc3		       e2		      .byte.b	-30
      0  6dc4					      EVAL8	-30
      1  6dc4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dc4				  -	      ECHO	"Erroneous position value", -30
      3  6dc4				  -	      ERR
      4  6dc4					      ENDIF
      5  6dc4		       e2		      .byte.b	-30
      0  6dc5					      EVAL8	-20
      1  6dc5				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6dc5				  -	      ECHO	"Erroneous position value", -20
      3  6dc5				  -	      ERR
      4  6dc5					      ENDIF
      5  6dc5		       ec		      .byte.b	-20
      0  6dc6					      EVAL8	0
      1  6dc6				  -	      IF	(0 > 127) || (0 < -128)
      2  6dc6				  -	      ECHO	"Erroneous position value", 0
      3  6dc6				  -	      ERR
      4  6dc6					      ENDIF
      5  6dc6		       00		      .byte.b	0
      0  6dc7					      EVAL8	0
      1  6dc7				  -	      IF	(0 > 127) || (0 < -128)
      2  6dc7				  -	      ECHO	"Erroneous position value", 0
      3  6dc7				  -	      ERR
      4  6dc7					      ENDIF
      5  6dc7		       00		      .byte.b	0
      0  6dc8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  6dc8					      EVAL8	-30
      1  6dc8				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dc8				  -	      ECHO	"Erroneous position value", -30
      3  6dc8				  -	      ERR
      4  6dc8					      ENDIF
      5  6dc8		       e2		      .byte.b	-30
      0  6dc9					      EVAL8	-40
      1  6dc9				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dc9				  -	      ECHO	"Erroneous position value", -40
      3  6dc9				  -	      ERR
      4  6dc9					      ENDIF
      5  6dc9		       d8		      .byte.b	-40
      0  6dca					      EVAL8	-40
      1  6dca				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dca				  -	      ECHO	"Erroneous position value", -40
      3  6dca				  -	      ERR
      4  6dca					      ENDIF
      5  6dca		       d8		      .byte.b	-40
      0  6dcb					      EVAL8	-50
      1  6dcb				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dcb				  -	      ECHO	"Erroneous position value", -50
      3  6dcb				  -	      ERR
      4  6dcb					      ENDIF
      5  6dcb		       ce		      .byte.b	-50
      0  6dcc					      EVAL8	-50
      1  6dcc				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dcc				  -	      ECHO	"Erroneous position value", -50
      3  6dcc				  -	      ERR
      4  6dcc					      ENDIF
      5  6dcc		       ce		      .byte.b	-50
      0  6dcd					      EVAL8	-40
      1  6dcd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dcd				  -	      ECHO	"Erroneous position value", -40
      3  6dcd				  -	      ERR
      4  6dcd					      ENDIF
      5  6dcd		       d8		      .byte.b	-40
      0  6dce					      EVAL8	-40
      1  6dce				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dce				  -	      ECHO	"Erroneous position value", -40
      3  6dce				  -	      ERR
      4  6dce					      ENDIF
      5  6dce		       d8		      .byte.b	-40
      0  6dcf					      EVAL8	-30
      1  6dcf				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dcf				  -	      ECHO	"Erroneous position value", -30
      3  6dcf				  -	      ERR
      4  6dcf					      ENDIF
      5  6dcf		       e2		      .byte.b	-30
      0  6dd0					      EVAL8	0
      1  6dd0				  -	      IF	(0 > 127) || (0 < -128)
      2  6dd0				  -	      ECHO	"Erroneous position value", 0
      3  6dd0				  -	      ERR
      4  6dd0					      ENDIF
      5  6dd0		       00		      .byte.b	0
      0  6dd1					      EVAL8	0
      1  6dd1				  -	      IF	(0 > 127) || (0 < -128)
      2  6dd1				  -	      ECHO	"Erroneous position value", 0
      3  6dd1				  -	      ERR
      4  6dd1					      ENDIF
      5  6dd1		       00		      .byte.b	0
      0  6dd2					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  6dd2					      EVAL8	-30
      1  6dd2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dd2				  -	      ECHO	"Erroneous position value", -30
      3  6dd2				  -	      ERR
      4  6dd2					      ENDIF
      5  6dd2		       e2		      .byte.b	-30
      0  6dd3					      EVAL8	-40
      1  6dd3				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dd3				  -	      ECHO	"Erroneous position value", -40
      3  6dd3				  -	      ERR
      4  6dd3					      ENDIF
      5  6dd3		       d8		      .byte.b	-40
      0  6dd4					      EVAL8	-40
      1  6dd4				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dd4				  -	      ECHO	"Erroneous position value", -40
      3  6dd4				  -	      ERR
      4  6dd4					      ENDIF
      5  6dd4		       d8		      .byte.b	-40
      0  6dd5					      EVAL8	-50
      1  6dd5				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dd5				  -	      ECHO	"Erroneous position value", -50
      3  6dd5				  -	      ERR
      4  6dd5					      ENDIF
      5  6dd5		       ce		      .byte.b	-50
      0  6dd6					      EVAL8	-50
      1  6dd6				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dd6				  -	      ECHO	"Erroneous position value", -50
      3  6dd6				  -	      ERR
      4  6dd6					      ENDIF
      5  6dd6		       ce		      .byte.b	-50
      0  6dd7					      EVAL8	-40
      1  6dd7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dd7				  -	      ECHO	"Erroneous position value", -40
      3  6dd7				  -	      ERR
      4  6dd7					      ENDIF
      5  6dd7		       d8		      .byte.b	-40
      0  6dd8					      EVAL8	-40
      1  6dd8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dd8				  -	      ECHO	"Erroneous position value", -40
      3  6dd8				  -	      ERR
      4  6dd8					      ENDIF
      5  6dd8		       d8		      .byte.b	-40
      0  6dd9					      EVAL8	-30
      1  6dd9				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dd9				  -	      ECHO	"Erroneous position value", -30
      3  6dd9				  -	      ERR
      4  6dd9					      ENDIF
      5  6dd9		       e2		      .byte.b	-30
      0  6dda					      EVAL8	0
      1  6dda				  -	      IF	(0 > 127) || (0 < -128)
      2  6dda				  -	      ECHO	"Erroneous position value", 0
      3  6dda				  -	      ERR
      4  6dda					      ENDIF
      5  6dda		       00		      .byte.b	0
      0  6ddb					      EVAL8	0
      1  6ddb				  -	      IF	(0 > 127) || (0 < -128)
      2  6ddb				  -	      ECHO	"Erroneous position value", 0
      3  6ddb				  -	      ERR
      4  6ddb					      ENDIF
      5  6ddb		       00		      .byte.b	0
      0  6ddc					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  6ddc					      EVAL8	-30
      1  6ddc				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6ddc				  -	      ECHO	"Erroneous position value", -30
      3  6ddc				  -	      ERR
      4  6ddc					      ENDIF
      5  6ddc		       e2		      .byte.b	-30
      0  6ddd					      EVAL8	-40
      1  6ddd				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6ddd				  -	      ECHO	"Erroneous position value", -40
      3  6ddd				  -	      ERR
      4  6ddd					      ENDIF
      5  6ddd		       d8		      .byte.b	-40
      0  6dde					      EVAL8	-40
      1  6dde				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dde				  -	      ECHO	"Erroneous position value", -40
      3  6dde				  -	      ERR
      4  6dde					      ENDIF
      5  6dde		       d8		      .byte.b	-40
      0  6ddf					      EVAL8	-50
      1  6ddf				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6ddf				  -	      ECHO	"Erroneous position value", -50
      3  6ddf				  -	      ERR
      4  6ddf					      ENDIF
      5  6ddf		       ce		      .byte.b	-50
      0  6de0					      EVAL8	-50
      1  6de0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6de0				  -	      ECHO	"Erroneous position value", -50
      3  6de0				  -	      ERR
      4  6de0					      ENDIF
      5  6de0		       ce		      .byte.b	-50
      0  6de1					      EVAL8	-40
      1  6de1				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6de1				  -	      ECHO	"Erroneous position value", -40
      3  6de1				  -	      ERR
      4  6de1					      ENDIF
      5  6de1		       d8		      .byte.b	-40
      0  6de2					      EVAL8	-40
      1  6de2				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6de2				  -	      ECHO	"Erroneous position value", -40
      3  6de2				  -	      ERR
      4  6de2					      ENDIF
      5  6de2		       d8		      .byte.b	-40
      0  6de3					      EVAL8	-30
      1  6de3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6de3				  -	      ECHO	"Erroneous position value", -30
      3  6de3				  -	      ERR
      4  6de3					      ENDIF
      5  6de3		       e2		      .byte.b	-30
      0  6de4					      EVAL8	0
      1  6de4				  -	      IF	(0 > 127) || (0 < -128)
      2  6de4				  -	      ECHO	"Erroneous position value", 0
      3  6de4				  -	      ERR
      4  6de4					      ENDIF
      5  6de4		       00		      .byte.b	0
      0  6de5					      EVAL8	0
      1  6de5				  -	      IF	(0 > 127) || (0 < -128)
      2  6de5				  -	      ECHO	"Erroneous position value", 0
      3  6de5				  -	      ERR
      4  6de5					      ENDIF
      5  6de5		       00		      .byte.b	0
      0  6de6					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      0  6de6					      EVAL8	-30
      1  6de6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6de6				  -	      ECHO	"Erroneous position value", -30
      3  6de6				  -	      ERR
      4  6de6					      ENDIF
      5  6de6		       e2		      .byte.b	-30
      0  6de7					      EVAL8	-40
      1  6de7				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6de7				  -	      ECHO	"Erroneous position value", -40
      3  6de7				  -	      ERR
      4  6de7					      ENDIF
      5  6de7		       d8		      .byte.b	-40
      0  6de8					      EVAL8	-40
      1  6de8				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6de8				  -	      ECHO	"Erroneous position value", -40
      3  6de8				  -	      ERR
      4  6de8					      ENDIF
      5  6de8		       d8		      .byte.b	-40
      0  6de9					      EVAL8	-50
      1  6de9				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6de9				  -	      ECHO	"Erroneous position value", -50
      3  6de9				  -	      ERR
      4  6de9					      ENDIF
      5  6de9		       ce		      .byte.b	-50
      0  6dea					      EVAL8	-50
      1  6dea				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6dea				  -	      ECHO	"Erroneous position value", -50
      3  6dea				  -	      ERR
      4  6dea					      ENDIF
      5  6dea		       ce		      .byte.b	-50
      0  6deb					      EVAL8	-40
      1  6deb				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6deb				  -	      ECHO	"Erroneous position value", -40
      3  6deb				  -	      ERR
      4  6deb					      ENDIF
      5  6deb		       d8		      .byte.b	-40
      0  6dec					      EVAL8	-40
      1  6dec				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6dec				  -	      ECHO	"Erroneous position value", -40
      3  6dec				  -	      ERR
      4  6dec					      ENDIF
      5  6dec		       d8		      .byte.b	-40
      0  6ded					      EVAL8	-30
      1  6ded				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6ded				  -	      ECHO	"Erroneous position value", -30
      3  6ded				  -	      ERR
      4  6ded					      ENDIF
      5  6ded		       e2		      .byte.b	-30
      0  6dee					      EVAL8	0
      1  6dee				  -	      IF	(0 > 127) || (0 < -128)
      2  6dee				  -	      ECHO	"Erroneous position value", 0
      3  6dee				  -	      ERR
      4  6dee					      ENDIF
      5  6dee		       00		      .byte.b	0
      0  6def					      EVAL8	0
      1  6def				  -	      IF	(0 > 127) || (0 < -128)
      2  6def				  -	      ECHO	"Erroneous position value", 0
      3  6def				  -	      ERR
      4  6def					      ENDIF
      5  6def		       00		      .byte.b	0
    153  6df0
    154  6df0
    155  6df0							;---------------------------------------------------------------------------------------------------
    156  6df0
    157  6df0				   PositionalValue_KING_ENDGAME
    158  6df0
      0  6df0					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      0  6df0					      EVAL8	-50
      1  6df0				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6df0				  -	      ECHO	"Erroneous position value", -50
      3  6df0				  -	      ERR
      4  6df0					      ENDIF
      5  6df0		       ce		      .byte.b	-50
      0  6df1					      EVAL8	-30
      1  6df1				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df1				  -	      ECHO	"Erroneous position value", -30
      3  6df1				  -	      ERR
      4  6df1					      ENDIF
      5  6df1		       e2		      .byte.b	-30
      0  6df2					      EVAL8	-30
      1  6df2				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df2				  -	      ECHO	"Erroneous position value", -30
      3  6df2				  -	      ERR
      4  6df2					      ENDIF
      5  6df2		       e2		      .byte.b	-30
      0  6df3					      EVAL8	-30
      1  6df3				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df3				  -	      ECHO	"Erroneous position value", -30
      3  6df3				  -	      ERR
      4  6df3					      ENDIF
      5  6df3		       e2		      .byte.b	-30
      0  6df4					      EVAL8	-30
      1  6df4				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df4				  -	      ECHO	"Erroneous position value", -30
      3  6df4				  -	      ERR
      4  6df4					      ENDIF
      5  6df4		       e2		      .byte.b	-30
      0  6df5					      EVAL8	-30
      1  6df5				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df5				  -	      ECHO	"Erroneous position value", -30
      3  6df5				  -	      ERR
      4  6df5					      ENDIF
      5  6df5		       e2		      .byte.b	-30
      0  6df6					      EVAL8	-30
      1  6df6				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6df6				  -	      ECHO	"Erroneous position value", -30
      3  6df6				  -	      ERR
      4  6df6					      ENDIF
      5  6df6		       e2		      .byte.b	-30
      0  6df7					      EVAL8	-50
      1  6df7				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6df7				  -	      ECHO	"Erroneous position value", -50
      3  6df7				  -	      ERR
      4  6df7					      ENDIF
      5  6df7		       ce		      .byte.b	-50
      0  6df8					      EVAL8	0
      1  6df8				  -	      IF	(0 > 127) || (0 < -128)
      2  6df8				  -	      ECHO	"Erroneous position value", 0
      3  6df8				  -	      ERR
      4  6df8					      ENDIF
      5  6df8		       00		      .byte.b	0
      0  6df9					      EVAL8	0
      1  6df9				  -	      IF	(0 > 127) || (0 < -128)
      2  6df9				  -	      ECHO	"Erroneous position value", 0
      3  6df9				  -	      ERR
      4  6df9					      ENDIF
      5  6df9		       00		      .byte.b	0
      0  6dfa					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      0  6dfa					      EVAL8	-30
      1  6dfa				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dfa				  -	      ECHO	"Erroneous position value", -30
      3  6dfa				  -	      ERR
      4  6dfa					      ENDIF
      5  6dfa		       e2		      .byte.b	-30
      0  6dfb					      EVAL8	-30
      1  6dfb				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6dfb				  -	      ECHO	"Erroneous position value", -30
      3  6dfb				  -	      ERR
      4  6dfb					      ENDIF
      5  6dfb		       e2		      .byte.b	-30
      0  6dfc					      EVAL8	0
      1  6dfc				  -	      IF	(0 > 127) || (0 < -128)
      2  6dfc				  -	      ECHO	"Erroneous position value", 0
      3  6dfc				  -	      ERR
      4  6dfc					      ENDIF
      5  6dfc		       00		      .byte.b	0
      0  6dfd					      EVAL8	0
      1  6dfd				  -	      IF	(0 > 127) || (0 < -128)
      2  6dfd				  -	      ECHO	"Erroneous position value", 0
      3  6dfd				  -	      ERR
      4  6dfd					      ENDIF
      5  6dfd		       00		      .byte.b	0
      0  6dfe					      EVAL8	0
      1  6dfe				  -	      IF	(0 > 127) || (0 < -128)
      2  6dfe				  -	      ECHO	"Erroneous position value", 0
      3  6dfe				  -	      ERR
      4  6dfe					      ENDIF
      5  6dfe		       00		      .byte.b	0
      0  6dff					      EVAL8	0
      1  6dff				  -	      IF	(0 > 127) || (0 < -128)
      2  6dff				  -	      ECHO	"Erroneous position value", 0
      3  6dff				  -	      ERR
      4  6dff					      ENDIF
      5  6dff		       00		      .byte.b	0
      0  6e00					      EVAL8	-30
      1  6e00				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e00				  -	      ECHO	"Erroneous position value", -30
      3  6e00				  -	      ERR
      4  6e00					      ENDIF
      5  6e00		       e2		      .byte.b	-30
      0  6e01					      EVAL8	-30
      1  6e01				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e01				  -	      ECHO	"Erroneous position value", -30
      3  6e01				  -	      ERR
      4  6e01					      ENDIF
      5  6e01		       e2		      .byte.b	-30
      0  6e02					      EVAL8	0
      1  6e02				  -	      IF	(0 > 127) || (0 < -128)
      2  6e02				  -	      ECHO	"Erroneous position value", 0
      3  6e02				  -	      ERR
      4  6e02					      ENDIF
      5  6e02		       00		      .byte.b	0
      0  6e03					      EVAL8	0
      1  6e03				  -	      IF	(0 > 127) || (0 < -128)
      2  6e03				  -	      ECHO	"Erroneous position value", 0
      3  6e03				  -	      ERR
      4  6e03					      ENDIF
      5  6e03		       00		      .byte.b	0
      0  6e04					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  6e04					      EVAL8	-30
      1  6e04				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e04				  -	      ECHO	"Erroneous position value", -30
      3  6e04				  -	      ERR
      4  6e04					      ENDIF
      5  6e04		       e2		      .byte.b	-30
      0  6e05					      EVAL8	-10
      1  6e05				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e05				  -	      ECHO	"Erroneous position value", -10
      3  6e05				  -	      ERR
      4  6e05					      ENDIF
      5  6e05		       f6		      .byte.b	-10
      0  6e06					      EVAL8	20
      1  6e06				  -	      IF	(20 > 127) || (20 < -128)
      2  6e06				  -	      ECHO	"Erroneous position value", 20
      3  6e06				  -	      ERR
      4  6e06					      ENDIF
      5  6e06		       14		      .byte.b	20
      0  6e07					      EVAL8	30
      1  6e07				  -	      IF	(30 > 127) || (30 < -128)
      2  6e07				  -	      ECHO	"Erroneous position value", 30
      3  6e07				  -	      ERR
      4  6e07					      ENDIF
      5  6e07		       1e		      .byte.b	30
      0  6e08					      EVAL8	30
      1  6e08				  -	      IF	(30 > 127) || (30 < -128)
      2  6e08				  -	      ECHO	"Erroneous position value", 30
      3  6e08				  -	      ERR
      4  6e08					      ENDIF
      5  6e08		       1e		      .byte.b	30
      0  6e09					      EVAL8	20
      1  6e09				  -	      IF	(20 > 127) || (20 < -128)
      2  6e09				  -	      ECHO	"Erroneous position value", 20
      3  6e09				  -	      ERR
      4  6e09					      ENDIF
      5  6e09		       14		      .byte.b	20
      0  6e0a					      EVAL8	-10
      1  6e0a				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e0a				  -	      ECHO	"Erroneous position value", -10
      3  6e0a				  -	      ERR
      4  6e0a					      ENDIF
      5  6e0a		       f6		      .byte.b	-10
      0  6e0b					      EVAL8	-30
      1  6e0b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e0b				  -	      ECHO	"Erroneous position value", -30
      3  6e0b				  -	      ERR
      4  6e0b					      ENDIF
      5  6e0b		       e2		      .byte.b	-30
      0  6e0c					      EVAL8	0
      1  6e0c				  -	      IF	(0 > 127) || (0 < -128)
      2  6e0c				  -	      ECHO	"Erroneous position value", 0
      3  6e0c				  -	      ERR
      4  6e0c					      ENDIF
      5  6e0c		       00		      .byte.b	0
      0  6e0d					      EVAL8	0
      1  6e0d				  -	      IF	(0 > 127) || (0 < -128)
      2  6e0d				  -	      ECHO	"Erroneous position value", 0
      3  6e0d				  -	      ERR
      4  6e0d					      ENDIF
      5  6e0d		       00		      .byte.b	0
      0  6e0e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  6e0e					      EVAL8	-30
      1  6e0e				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e0e				  -	      ECHO	"Erroneous position value", -30
      3  6e0e				  -	      ERR
      4  6e0e					      ENDIF
      5  6e0e		       e2		      .byte.b	-30
      0  6e0f					      EVAL8	-10
      1  6e0f				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e0f				  -	      ECHO	"Erroneous position value", -10
      3  6e0f				  -	      ERR
      4  6e0f					      ENDIF
      5  6e0f		       f6		      .byte.b	-10
      0  6e10					      EVAL8	30
      1  6e10				  -	      IF	(30 > 127) || (30 < -128)
      2  6e10				  -	      ECHO	"Erroneous position value", 30
      3  6e10				  -	      ERR
      4  6e10					      ENDIF
      5  6e10		       1e		      .byte.b	30
      0  6e11					      EVAL8	40
      1  6e11				  -	      IF	(40 > 127) || (40 < -128)
      2  6e11				  -	      ECHO	"Erroneous position value", 40
      3  6e11				  -	      ERR
      4  6e11					      ENDIF
      5  6e11		       28		      .byte.b	40
      0  6e12					      EVAL8	40
      1  6e12				  -	      IF	(40 > 127) || (40 < -128)
      2  6e12				  -	      ECHO	"Erroneous position value", 40
      3  6e12				  -	      ERR
      4  6e12					      ENDIF
      5  6e12		       28		      .byte.b	40
      0  6e13					      EVAL8	30
      1  6e13				  -	      IF	(30 > 127) || (30 < -128)
      2  6e13				  -	      ECHO	"Erroneous position value", 30
      3  6e13				  -	      ERR
      4  6e13					      ENDIF
      5  6e13		       1e		      .byte.b	30
      0  6e14					      EVAL8	-10
      1  6e14				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e14				  -	      ECHO	"Erroneous position value", -10
      3  6e14				  -	      ERR
      4  6e14					      ENDIF
      5  6e14		       f6		      .byte.b	-10
      0  6e15					      EVAL8	-30
      1  6e15				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e15				  -	      ECHO	"Erroneous position value", -30
      3  6e15				  -	      ERR
      4  6e15					      ENDIF
      5  6e15		       e2		      .byte.b	-30
      0  6e16					      EVAL8	0
      1  6e16				  -	      IF	(0 > 127) || (0 < -128)
      2  6e16				  -	      ECHO	"Erroneous position value", 0
      3  6e16				  -	      ERR
      4  6e16					      ENDIF
      5  6e16		       00		      .byte.b	0
      0  6e17					      EVAL8	0
      1  6e17				  -	      IF	(0 > 127) || (0 < -128)
      2  6e17				  -	      ECHO	"Erroneous position value", 0
      3  6e17				  -	      ERR
      4  6e17					      ENDIF
      5  6e17		       00		      .byte.b	0
      0  6e18					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      0  6e18					      EVAL8	-30
      1  6e18				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e18				  -	      ECHO	"Erroneous position value", -30
      3  6e18				  -	      ERR
      4  6e18					      ENDIF
      5  6e18		       e2		      .byte.b	-30
      0  6e19					      EVAL8	-10
      1  6e19				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e19				  -	      ECHO	"Erroneous position value", -10
      3  6e19				  -	      ERR
      4  6e19					      ENDIF
      5  6e19		       f6		      .byte.b	-10
      0  6e1a					      EVAL8	30
      1  6e1a				  -	      IF	(30 > 127) || (30 < -128)
      2  6e1a				  -	      ECHO	"Erroneous position value", 30
      3  6e1a				  -	      ERR
      4  6e1a					      ENDIF
      5  6e1a		       1e		      .byte.b	30
      0  6e1b					      EVAL8	40
      1  6e1b				  -	      IF	(40 > 127) || (40 < -128)
      2  6e1b				  -	      ECHO	"Erroneous position value", 40
      3  6e1b				  -	      ERR
      4  6e1b					      ENDIF
      5  6e1b		       28		      .byte.b	40
      0  6e1c					      EVAL8	40
      1  6e1c				  -	      IF	(40 > 127) || (40 < -128)
      2  6e1c				  -	      ECHO	"Erroneous position value", 40
      3  6e1c				  -	      ERR
      4  6e1c					      ENDIF
      5  6e1c		       28		      .byte.b	40
      0  6e1d					      EVAL8	30
      1  6e1d				  -	      IF	(30 > 127) || (30 < -128)
      2  6e1d				  -	      ECHO	"Erroneous position value", 30
      3  6e1d				  -	      ERR
      4  6e1d					      ENDIF
      5  6e1d		       1e		      .byte.b	30
      0  6e1e					      EVAL8	-10
      1  6e1e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e1e				  -	      ECHO	"Erroneous position value", -10
      3  6e1e				  -	      ERR
      4  6e1e					      ENDIF
      5  6e1e		       f6		      .byte.b	-10
      0  6e1f					      EVAL8	-30
      1  6e1f				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e1f				  -	      ECHO	"Erroneous position value", -30
      3  6e1f				  -	      ERR
      4  6e1f					      ENDIF
      5  6e1f		       e2		      .byte.b	-30
      0  6e20					      EVAL8	0
      1  6e20				  -	      IF	(0 > 127) || (0 < -128)
      2  6e20				  -	      ECHO	"Erroneous position value", 0
      3  6e20				  -	      ERR
      4  6e20					      ENDIF
      5  6e20		       00		      .byte.b	0
      0  6e21					      EVAL8	0
      1  6e21				  -	      IF	(0 > 127) || (0 < -128)
      2  6e21				  -	      ECHO	"Erroneous position value", 0
      3  6e21				  -	      ERR
      4  6e21					      ENDIF
      5  6e21		       00		      .byte.b	0
      0  6e22					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      0  6e22					      EVAL8	-30
      1  6e22				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e22				  -	      ECHO	"Erroneous position value", -30
      3  6e22				  -	      ERR
      4  6e22					      ENDIF
      5  6e22		       e2		      .byte.b	-30
      0  6e23					      EVAL8	-10
      1  6e23				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e23				  -	      ECHO	"Erroneous position value", -10
      3  6e23				  -	      ERR
      4  6e23					      ENDIF
      5  6e23		       f6		      .byte.b	-10
      0  6e24					      EVAL8	20
      1  6e24				  -	      IF	(20 > 127) || (20 < -128)
      2  6e24				  -	      ECHO	"Erroneous position value", 20
      3  6e24				  -	      ERR
      4  6e24					      ENDIF
      5  6e24		       14		      .byte.b	20
      0  6e25					      EVAL8	30
      1  6e25				  -	      IF	(30 > 127) || (30 < -128)
      2  6e25				  -	      ECHO	"Erroneous position value", 30
      3  6e25				  -	      ERR
      4  6e25					      ENDIF
      5  6e25		       1e		      .byte.b	30
      0  6e26					      EVAL8	30
      1  6e26				  -	      IF	(30 > 127) || (30 < -128)
      2  6e26				  -	      ECHO	"Erroneous position value", 30
      3  6e26				  -	      ERR
      4  6e26					      ENDIF
      5  6e26		       1e		      .byte.b	30
      0  6e27					      EVAL8	20
      1  6e27				  -	      IF	(20 > 127) || (20 < -128)
      2  6e27				  -	      ECHO	"Erroneous position value", 20
      3  6e27				  -	      ERR
      4  6e27					      ENDIF
      5  6e27		       14		      .byte.b	20
      0  6e28					      EVAL8	-10
      1  6e28				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e28				  -	      ECHO	"Erroneous position value", -10
      3  6e28				  -	      ERR
      4  6e28					      ENDIF
      5  6e28		       f6		      .byte.b	-10
      0  6e29					      EVAL8	-30
      1  6e29				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e29				  -	      ECHO	"Erroneous position value", -30
      3  6e29				  -	      ERR
      4  6e29					      ENDIF
      5  6e29		       e2		      .byte.b	-30
      0  6e2a					      EVAL8	0
      1  6e2a				  -	      IF	(0 > 127) || (0 < -128)
      2  6e2a				  -	      ECHO	"Erroneous position value", 0
      3  6e2a				  -	      ERR
      4  6e2a					      ENDIF
      5  6e2a		       00		      .byte.b	0
      0  6e2b					      EVAL8	0
      1  6e2b				  -	      IF	(0 > 127) || (0 < -128)
      2  6e2b				  -	      ECHO	"Erroneous position value", 0
      3  6e2b				  -	      ERR
      4  6e2b					      ENDIF
      5  6e2b		       00		      .byte.b	0
      0  6e2c					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      0  6e2c					      EVAL8	-30
      1  6e2c				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e2c				  -	      ECHO	"Erroneous position value", -30
      3  6e2c				  -	      ERR
      4  6e2c					      ENDIF
      5  6e2c		       e2		      .byte.b	-30
      0  6e2d					      EVAL8	-20
      1  6e2d				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6e2d				  -	      ECHO	"Erroneous position value", -20
      3  6e2d				  -	      ERR
      4  6e2d					      ENDIF
      5  6e2d		       ec		      .byte.b	-20
      0  6e2e					      EVAL8	-10
      1  6e2e				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e2e				  -	      ECHO	"Erroneous position value", -10
      3  6e2e				  -	      ERR
      4  6e2e					      ENDIF
      5  6e2e		       f6		      .byte.b	-10
      0  6e2f					      EVAL8	0
      1  6e2f				  -	      IF	(0 > 127) || (0 < -128)
      2  6e2f				  -	      ECHO	"Erroneous position value", 0
      3  6e2f				  -	      ERR
      4  6e2f					      ENDIF
      5  6e2f		       00		      .byte.b	0
      0  6e30					      EVAL8	0
      1  6e30				  -	      IF	(0 > 127) || (0 < -128)
      2  6e30				  -	      ECHO	"Erroneous position value", 0
      3  6e30				  -	      ERR
      4  6e30					      ENDIF
      5  6e30		       00		      .byte.b	0
      0  6e31					      EVAL8	-10
      1  6e31				  -	      IF	(-10 > 127) || (-10 < -128)
      2  6e31				  -	      ECHO	"Erroneous position value", -10
      3  6e31				  -	      ERR
      4  6e31					      ENDIF
      5  6e31		       f6		      .byte.b	-10
      0  6e32					      EVAL8	-20
      1  6e32				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6e32				  -	      ECHO	"Erroneous position value", -20
      3  6e32				  -	      ERR
      4  6e32					      ENDIF
      5  6e32		       ec		      .byte.b	-20
      0  6e33					      EVAL8	-30
      1  6e33				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e33				  -	      ECHO	"Erroneous position value", -30
      3  6e33				  -	      ERR
      4  6e33					      ENDIF
      5  6e33		       e2		      .byte.b	-30
      0  6e34					      EVAL8	0
      1  6e34				  -	      IF	(0 > 127) || (0 < -128)
      2  6e34				  -	      ECHO	"Erroneous position value", 0
      3  6e34				  -	      ERR
      4  6e34					      ENDIF
      5  6e34		       00		      .byte.b	0
      0  6e35					      EVAL8	0
      1  6e35				  -	      IF	(0 > 127) || (0 < -128)
      2  6e35				  -	      ECHO	"Erroneous position value", 0
      3  6e35				  -	      ERR
      4  6e35					      ENDIF
      5  6e35		       00		      .byte.b	0
      0  6e36					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      0  6e36					      EVAL8	-50
      1  6e36				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6e36				  -	      ECHO	"Erroneous position value", -50
      3  6e36				  -	      ERR
      4  6e36					      ENDIF
      5  6e36		       ce		      .byte.b	-50
      0  6e37					      EVAL8	-40
      1  6e37				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6e37				  -	      ECHO	"Erroneous position value", -40
      3  6e37				  -	      ERR
      4  6e37					      ENDIF
      5  6e37		       d8		      .byte.b	-40
      0  6e38					      EVAL8	-30
      1  6e38				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e38				  -	      ECHO	"Erroneous position value", -30
      3  6e38				  -	      ERR
      4  6e38					      ENDIF
      5  6e38		       e2		      .byte.b	-30
      0  6e39					      EVAL8	-20
      1  6e39				  -	      IF	(-20 > 127) || (-20 < -128)
      2  6e39				  -	      ECHO	"Erroneous position value", -20
      3  6e39				  -	      ERR
      4  6e39					      ENDIF
      5  6e39		       ec		      .byte.b	-20
      0  6e3a					      EVAL8	- 20
      1  6e3a				  -	      IF	(- 20 > 127) || (- 20 < -128)
      2  6e3a				  -	      ECHO	"Erroneous position value", - 20
      3  6e3a				  -	      ERR
      4  6e3a					      ENDIF
      5  6e3a		       ec		      .byte.b	- 20
      0  6e3b					      EVAL8	-30
      1  6e3b				  -	      IF	(-30 > 127) || (-30 < -128)
      2  6e3b				  -	      ECHO	"Erroneous position value", -30
      3  6e3b				  -	      ERR
      4  6e3b					      ENDIF
      5  6e3b		       e2		      .byte.b	-30
      0  6e3c					      EVAL8	-40
      1  6e3c				  -	      IF	(-40 > 127) || (-40 < -128)
      2  6e3c				  -	      ECHO	"Erroneous position value", -40
      3  6e3c				  -	      ERR
      4  6e3c					      ENDIF
      5  6e3c		       d8		      .byte.b	-40
      0  6e3d					      EVAL8	-50
      1  6e3d				  -	      IF	(-50 > 127) || (-50 < -128)
      2  6e3d				  -	      ECHO	"Erroneous position value", -50
      3  6e3d				  -	      ERR
      4  6e3d					      ENDIF
      5  6e3d		       ce		      .byte.b	-50
      0  6e3e					      EVAL8	0
      1  6e3e				  -	      IF	(0 > 127) || (0 < -128)
      2  6e3e				  -	      ECHO	"Erroneous position value", 0
      3  6e3e				  -	      ERR
      4  6e3e					      ENDIF
      5  6e3e		       00		      .byte.b	0
      0  6e3f					      EVAL8	0
      1  6e3f				  -	      IF	(0 > 127) || (0 < -128)
      2  6e3f				  -	      ECHO	"Erroneous position value", 0
      3  6e3f				  -	      ERR
      4  6e3f					      ENDIF
      5  6e3f		       00		      .byte.b	0
    167  6e40
    168  6e40
    169  6e40							;---------------------------------------------------------------------------------------------------
    170  6e40
      0  6e40					      END_BANK
      1  6e40				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  6e40				  -	      CHECK_RAM_BANK_SIZE
      3  6e40					      ELSE
      0  6e40					      CHECK_BANK_SIZE
      1  6e40		       02 40	   .TEMP      =	* - _BANK_START
 ROM bank # 28 EVALUATE size = $240 free = 447
      2  6e40					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  6e40				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  6e40				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  6e40				  -	      ERR
      6  6e40					      ENDIF
      5  6e40					      ENDIF
    172  6e40
    173  6e40							;---------------------------------------------------------------------------------------------------
    174  6e40							; EOF
------- FILE ./chess.asm
------- FILE @2 WORDS.asm LEVEL 2 PASS 4
      0  6e40					      include	"@2 WORDS.asm"
      1  6e40
      0  6e40					      SLOT	2
      1  6e40
      2  6e40				  -	      IF	(2 < 0) || (2 > 3)
      3  6e40				  -	      ECHO	"Illegal bank address/segment location", 2
      4  6e40				  -	      ERR
      5  6e40					      ENDIF
      6  6e40
      7  6e40				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  6e40				   _BANK_SLOT SET	2 * 64
      9  6e40
      0  6e40					      ROMBANK	WORDS
      1  726e ????				      SEG	ROM_WORDS
      2  7000					      ORG	_ORIGIN
      3  7000					      RORG	_BANK_ADDRESS_ORIGIN
      4  7000				   _BANK_START SET	*
      5  7000				   WORDS_START SET	*
      6  7000				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7000				   ROMBANK_WORDS SET	_BANK_SLOT + _CURRENT_BANK
      8  7000				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7000				   _LAST_BANK SETSTR	WORDS
     10  7000				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      4  7000
      5  7000
      6  7000							;---------------------------------------------------------------------------------------------------
      7  7000
      8  7000							; 'shape' indexes into tables
      9  7000
     10  7000
     11  7000
     12  7000					      MAC	bmlo
     13  7000					      .byte	<{1}
     14  7000					      ENDM
     15  7000
     16  7000					      MAC	bmhi
     17  7000					      .byte	>{1}
     18  7000					      ENDM
     19  7000
     20  7000
     21  7000					      MAC	shapevec
     22  7000					      {1}	Shape1
     23  7000					      {1}	Shape2
     24  7000					      ENDM
     25  7000
     26  7000
      0  7000					      DEF	BitmapShapeLO
      1  7000				   SLOT_BitmapShapeLO SET	_BANK_SLOT
      2  7000				   BANK_BitmapShapeLO SET	SLOT_BitmapShapeLO + _CURRENT_BANK
      3  7000				   BitmapShapeLO
      4  7000				   TEMPORARY_VAR SET	Overlay
      5  7000				   TEMPORARY_OFFSET SET	0
      6  7000				   VAR_BOUNDARY_BitmapShapeLO SET	TEMPORARY_OFFSET
      7  7000				   FUNCTION_NAME SET	BitmapShapeLO
      0  7000					      SHAPEVEC	BMLO
      0  7000					      BMLO	Shape1
      1  7000		       04		      .byte.b	<Shape1
      0  7001					      BMLO	Shape2
      1  7001		       14		      .byte.b	<Shape2
     29  7002
      0  7002					      DEF	BitmapShapeHI
      1  7002				   SLOT_BitmapShapeHI SET	_BANK_SLOT
      2  7002				   BANK_BitmapShapeHI SET	SLOT_BitmapShapeHI + _CURRENT_BANK
      3  7002				   BitmapShapeHI
      4  7002				   TEMPORARY_VAR SET	Overlay
      5  7002				   TEMPORARY_OFFSET SET	0
      6  7002				   VAR_BOUNDARY_BitmapShapeHI SET	TEMPORARY_OFFSET
      7  7002				   FUNCTION_NAME SET	BitmapShapeHI
      0  7002					      SHAPEVEC	BMHI
      0  7002					      BMHI	Shape1
      1  7002		       f8		      .byte.b	>Shape1
      0  7003					      BMHI	Shape2
      1  7003		       f8		      .byte.b	>Shape2
     32  7004
     33  7004
     34  7004
     35  7004
     36  7004				   Shape1
     37  7004							; 8 bytes --> mask ptr (-1 = none)
     38  7004							; 8 bytes --> shape ptr (-1 = none)
     39  7004
     40  7004		       ff ff ff ff*	      .byte.b	-1,-1,-1,-1,-1,-1,-1,-1	; mask (i.e., none)
     41  700c		       00 ff ff ff*	      .byte.b	0,-1,-1,-1,-1,-1,-1,-1	; shape
     42  7014
     43  7014				   Shape2
     44  7014		       00 01 ff ff*	      .byte.b	0,1,-1,-1,-1,-1,-1,-1	; mask
     45  701c		       01 02 ff ff*	      .byte.b	1,2,-1,-1,-1,-1,-1,-1	; shape
     46  7024
     47  7024
     48  7024				   MaskVector
     49  7024		       28 f8		      .word.w	Mask1
     50  7026		       28 f8		      .word.w	Mask2
     51  7028							; ...
     52  7028
     53  7028				   Mask1
     54  7028				   Mask2
     55  7028		       00 00 00 00*	      ds	ROW_BITMAP_SIZE, 0
     56  70b8
     57  70b8				   ShapeVector
     58  70b8		       be f8		      .word.w	Shape0Row0
     59  70ba		       4e f9		      .word.w	Shape1Row0
     60  70bc		       de f9		      .word.w	Shape1Row1
     61  70be							;....
     62  70be
     63  70be				   Shape0Row0
     64  70be		       ff ff ff ff*	      ds	ROW_BITMAP_SIZE, 255
     65  714e
     66  714e				   Shape1Row0
     67  714e		       ff ff ff ff*	      ds	ROW_BITMAP_SIZE, 255
     68  71de
     69  71de				   Shape1Row1
     70  71de		       ff ff ff ff*	      ds	ROW_BITMAP_SIZE, 255
     71  726e
     72  726e							;this gives 256 total, about 32 shapes max
     73  726e
     74  726e
     75  726e							;---------------------------------------------------------------------------------------------------
     76  726e
      0  726e					      END_BANK
      1  726e				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  726e				  -	      CHECK_RAM_BANK_SIZE
      3  726e					      ELSE
      0  726e					      CHECK_BANK_SIZE
      1  726e		       02 6e	   .TEMP      =	* - _BANK_START
 ROM bank # 29 WORDS size = $26e free = 401
      2  726e					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  726e				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  726e				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  726e				  -	      ERR
      6  726e					      ENDIF
      5  726e					      ENDIF
     78  726e
     79  726e							;---------------------------------------------------------------------------------------------------
     80  726e							; EOF
------- FILE ./chess.asm
    212  726e
------- FILE SHADOW_BOARD.asm LEVEL 2 PASS 4
      0  726e					      include	"SHADOW_BOARD.asm"
      1  726e							; Copyright (C)2020 Andrew Davie
      2  726e
      3  726e
      4  726e							;---------------------------------------------------------------------------------------------------
      5  726e
      0  726e					      SLOT	3
      1  726e
      2  726e				  -	      IF	(3 < 0) || (3 > 3)
      3  726e				  -	      ECHO	"Illegal bank address/segment location", 3
      4  726e				  -	      ERR
      5  726e					      ENDIF
      6  726e
      7  726e				   _BANK_ADDRESS_ORIGIN SET	$F000 + (3 * _ROM_BANK_SIZE)
      8  726e				   _BANK_SLOT SET	3 * 64
      9  726e
      0  726e					      RAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1  726e
      2 U2e00 ????				      SEG.U	RAM_BOARD
      3 U2e00					      ORG	ORIGIN_RAM
      4 U2e00					      RORG	_BANK_ADDRESS_ORIGIN
      5 U2e00				   _BANK_START SET	*
      6 U2e00				   _CURRENT_RAMBANK SET	(ORIGIN_RAM / _RAM_BANK_SIZE)
      7 U2e00				   RAMBANK_BOARD SET	_BANK_SLOT + _CURRENT_RAMBANK
      8 U2e00				   ORIGIN_RAM SET	ORIGIN_RAM + _RAM_BANK_SIZE
      9 U2e00				   _LAST_BANK SETSTR	BOARD
     10 U2e00				   _CURRENT_BANK_TYPE SET	_TYPE_RAM
      8 U2e00
      9 U2e00		       fc 15	   ValidSquare =	ShadowValidSquare + $400
     10 U2e00		       fc 79	   Board      =	ShadowBoard + $400
     11 U2e00
      0 U2e00					      END_BANK
      1 U2e00					      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      0 U2e00					      CHECK_RAM_BANK_SIZE
      1 U2e00		       00 00	   .TEMP      =	* - _BANK_START
 RAM bank # 24 BOARD size =  $0 free = $1ff
      2 U2e00					      ECHO	"RAM bank #", [ORIGIN_RAM/_RAM_BANK_SIZE]d, _LAST_BANK, "size = ", .TEMP, "free =", _RAM_BANK_SIZE - .TEMP - 1
      3 U2e00				  -	      IF	( .TEMP ) > _RAM_BANK_SIZE
      4 U2e00				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - ORIGIN_RAM
      5 U2e00				  -	      ERR
      6 U2e00					      ENDIF
      3 U2e00				  -	      ELSE
      4 U2e00				  -	      CHECK_BANK_SIZE
      5 U2e00					      ENDIF
     13 U2e00
     14 U2e00
     15 U2e00							;---------------------------------------------------------------------------------------------------
     16 U2e00
      0 U2e00					      SLOT	2
      1 U2e00
      2 U2e00				  -	      IF	(2 < 0) || (2 > 3)
      3 U2e00				  -	      ECHO	"Illegal bank address/segment location", 2
      4 U2e00				  -	      ERR
      5 U2e00					      ENDIF
      6 U2e00
      7 U2e00				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8 U2e00				   _BANK_SLOT SET	2 * 64
      9 U2e00
      0 U2e00					      ROMBANK	SHADOW_BOARD	; copy the following bank to RAMBANK_BOARD
      1  74dd ????				      SEG	ROM_SHADOW_BOARD
      2  7400					      ORG	_ORIGIN
      3  7400					      RORG	_BANK_ADDRESS_ORIGIN
      4  7400				   _BANK_START SET	*
      5  7400				   SHADOW_BOARD_START SET	*
      6  7400				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7400				   ROMBANK_SHADOW_BOARD SET	_BANK_SLOT + _CURRENT_BANK
      8  7400				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7400				   _LAST_BANK SETSTR	SHADOW_BOARD
     10  7400				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
     19  7400
     20  7400							; Board is a 10 x 12 object which simplifies the generation of moves
     21  7400							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     22  7400							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     23  7400
     24  7400							;     X12 numbering
     25  7400							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     26  7400							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     27  7400							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     28  7400							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     29  7400							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     30  7400							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     31  7400							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     32  7400							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     33  7400							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     34  7400							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     35  7400							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     36  7400							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     37  7400							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     38  7400							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     39  7400							;	0   1	2   3	4   5	6   7	8   9
     40  7400							;		A   B	C   D	E   F	G   H
     41  7400
     42  7400							;     HEX X12
     43  7400							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     44  7400							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     45  7400							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     46  7400							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     47  7400							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     48  7400							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     49  7400							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     50  7400							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     51  7400							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     52  7400							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     53  7400							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     54  7400							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     55  7400							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     56  7400							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     57  7400							;	0   1	2   3	4   5	6   7	8   9
     58  7400							;		A   B	C   D	E   F	G   H
     59  7400
     60  7400
     61  7400							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     62  7400							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     63  7400							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     64  7400							; be re-used for something else - we just need to guarantee there are 21 of them there
     65  7400
      0  7400					      ALLOCATE	Valid, 120 + 80 + 21
      1  7400
      2  7400				   .NAME      SETSTR	Valid
      0  7400					      OPTIONAL_PAGEBREAK	.NAME, 120 + 80 + 21
      1  7400
      2  7400				  -	      IF	(>( * + 120 + 80 + 21 -1 )) > ( >* )
      3  7400				  -.EARLY_LOCATION SET	*
      4  7400				  -	      ALIGN	256
      5  7400				  -	      ECHO	"Page break for", .NAME, "wasted", [* - .EARLY_LOCATION]d, "bytes"
      6  7400					      ENDIF
      0  7400					      DEF	Valid
      1  7400				   SLOT_Valid SET	_BANK_SLOT
      2  7400				   BANK_Valid SET	SLOT_Valid + _CURRENT_BANK
      3  7400				   Valid
      4  7400				   TEMPORARY_VAR SET	Overlay
      5  7400				   TEMPORARY_OFFSET SET	0
      6  7400				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      7  7400				   FUNCTION_NAME SET	Valid
      5  7400
     67  7400		       00 00 00 00*	      ds	21	; so indexing of "ValidSquare-21,x" won't fail
     68  7415							; Note, we will never index INTO the above bytes - x will always be >= 21
     69  7415							; We just need to make sure that the actual indexing will not have an address before
     70  7415							; the index of outside the page.
     71  7415
      0  7415					      DEF	ShadowValidSquare
      1  7415				   SLOT_ShadowValidSquare SET	_BANK_SLOT
      2  7415				   BANK_ShadowValidSquare SET	SLOT_ShadowValidSquare + _CURRENT_BANK
      3  7415				   ShadowValidSquare
      4  7415				   TEMPORARY_VAR SET	Overlay
      5  7415				   TEMPORARY_OFFSET SET	0
      6  7415				   VAR_BOUNDARY_ShadowValidSquare SET	TEMPORARY_OFFSET
      7  7415				   FUNCTION_NAME SET	ShadowValidSquare
     73  7415
     74  7415
     75  7415							; Use this table to
     76  7415							;   a) Determine if a square is valid (-1 = NO)
     77  7415							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     78  7415							;	if a white pawn on square "x" can move "up" the board.
     79  7415
     80  7415		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     81  741f		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
     82  7429		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
     83  7433		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
     84  743d		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
     85  7447		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
     86  7451		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
     87  745b		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
     88  7465		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
     89  746f		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
     90  7479
      0  7479					      DEF	ShadowBoard
      1  7479				   SLOT_ShadowBoard SET	_BANK_SLOT
      2  7479				   BANK_ShadowBoard SET	SLOT_ShadowBoard + _CURRENT_BANK
      3  7479				   ShadowBoard
      4  7479				   TEMPORARY_VAR SET	Overlay
      5  7479				   TEMPORARY_OFFSET SET	0
      6  7479				   VAR_BOUNDARY_ShadowBoard SET	TEMPORARY_OFFSET
      7  7479				   FUNCTION_NAME SET	ShadowBoard
     92  7479
     93  7479							; A 10X10... we should never write using invalid square
     94  7479							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
     95  7479							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
     96  7479
     97  7479		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     98  7483		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
     99  748d
    100  748d					      REPEAT	8
    101  748d		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  748d					      REPEND
    101  7497		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  7497					      REPEND
    101  74a1		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74a1					      REPEND
    101  74ab		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74ab					      REPEND
    101  74b5		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74b5					      REPEND
    101  74bf		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74bf					      REPEND
    101  74c9		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    100  74c9					      REPEND
    101  74d3		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    102  74dd					      REPEND
    103  74dd
    104  74dd							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
    105  74dd
    106  74dd
    107  74dd							;---------------------------------------------------------------------------------------------------
    108  74dd							; EOF
------- FILE ./chess.asm
    214  74dd
    215  74dd
    216  74dd
------- FILE TitleScreen.asm LEVEL 2 PASS 4
      0  74dd					      include	"TitleScreen.asm"
      0  74dd					      SLOT	1
      1  74dd
      2  74dd				  -	      IF	(1 < 0) || (1 > 3)
      3  74dd				  -	      ECHO	"Illegal bank address/segment location", 1
      4  74dd				  -	      ERR
      5  74dd					      ENDIF
      6  74dd
      7  74dd				   _BANK_ADDRESS_ORIGIN SET	$F000 + (1 * _ROM_BANK_SIZE)
      8  74dd				   _BANK_SLOT SET	1 * 64
      9  74dd
      0  74dd					      ROMBANK	TITLESCREEN
      1  7ab0 ????				      SEG	ROM_TITLESCREEN
      2  7800					      ORG	_ORIGIN
      3  7800					      RORG	_BANK_ADDRESS_ORIGIN
      4  7800				   _BANK_START SET	*
      5  7800				   TITLESCREEN_START SET	*
      6  7800				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7800				   ROMBANK_TITLESCREEN SET	_BANK_SLOT + _CURRENT_BANK
      8  7800				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7800				   _LAST_BANK SETSTR	TITLESCREEN
     10  7800				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      3  7800
      4  7800
      5  7800							;---------------------------------------------------------------------------------------------------
      6  7800
      7  7800				   OverscanTime2
      8  7800		       27 1a		      .byte.b	39, 26
      9  7802		       10 20		      .byte.b	16, 32
     10  7804
     11  7804							;colvec
     12  7804							;    .word colr_ntsc2, colr_pal
     13  7804
     14  7804
     15  7804		       2a 32	   VBlankTime .byte.b	42,50
     16  7806
      0  7806					      DEF	TitleScreen
      1  7806				   SLOT_TitleScreen SET	_BANK_SLOT
      2  7806				   BANK_TitleScreen SET	SLOT_TitleScreen + _CURRENT_BANK
      3  7806				   TitleScreen
      4  7806				   TEMPORARY_VAR SET	Overlay
      5  7806				   TEMPORARY_OFFSET SET	0
      6  7806				   VAR_BOUNDARY_TitleScreen SET	TEMPORARY_OFFSET
      7  7806				   FUNCTION_NAME SET	TitleScreen
     18  7806					      SUBROUTINE
     19  7806
      0  7806					      VAR	__colour_table, 2
      1  7806		       00 a6	   __colour_table =	TEMPORARY_VAR
      2  7806				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7806
      4  7806				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7806				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7806				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7806					      ENDIF
      8  7806				  -	      IF	OVERLAY_DELTA + Overlay >= TOP_OF_STACK
      9  7806				  -VNAME      SETSTR	__colour_table
     10  7806				  -	      ECHO	"Temporary Variable", VNAME, "overflow!"
     11  7806				  -	      ERR
     12  7806					      ENDIF
     21  7806
     22  7806							; Start of new frame
     23  7806
     24  7806							; Start of vertical blank processing
     25  7806
     26  7806				   TitleSequence
     27  7806
     28  7806
     29  7806		       a9 9f		      lda	#BANK_TitleData
     30  7808		       85 3f		      sta	SET_BANK
     31  780a
     32  780a
     33  780a		       a9 00		      lda	#%00000000
     34  780c		       85 0a		      sta	CTRLPF
     35  780e
     36  780e		       a9 c0		      lda	#$C0
     37  7810		       85 09		      sta	COLUBK
     38  7812
     39  7812		       a2 00		      ldx	#0	;Platform
     40  7814		       a9 00		      lda	#<colr_ntsc2	;colvec,x
     41  7816		       85 a6		      sta	__colour_table
     42  7818		       a9 f5		      lda	#>colr_ntsc2	;colvec+1,x
     43  781a		       85 a7		      sta	__colour_table+1
     44  781c
     45  781c							;		  sta rndHi
     46  781c							;		  sta rnd
     47  781c
     48  781c
     49  781c				  -	      IF	0
     50  781c				  -	      lda	#0
     51  781c				  -	      sta	digit
     52  781c				  -	      lda	#$10
     53  781c				  -	      sta	digit+1
     54  781c				  -	      lda	#$20
     55  781c				  -	      sta	digit+2
     56  781c					      ENDIF
     57  781c
     58  781c
     59  781c
     60  781c
     61  781c							;RESYNC
     62  781c
     63  781c				   RestartFrame0
     64  781c
     65  781c				  -	      IF	0
     66  781c				  -	      ldx	#2
     67  781c				  -rollcols   clc
     68  781c				  -	      lda	digit+2
     69  781c				  -	      adc	#$10
     70  781c				  -	      sta	digit+2
     71  781c				  -	      bcc	finxc
     72  781c				  -	      dex
     73  781c				  -	      bpl	rollcols
     74  781c				  -finxc
     75  781c					      ENDIF
     76  781c
      0  781c					      DEF	RestartFrame
      1  781c				   SLOT_RestartFrame SET	_BANK_SLOT
      2  781c				   BANK_RestartFrame SET	SLOT_RestartFrame + _CURRENT_BANK
      3  781c				   RestartFrame
      4  781c				   TEMPORARY_VAR SET	Overlay
      5  781c				   TEMPORARY_OFFSET SET	0
      6  781c				   VAR_BOUNDARY_RestartFrame SET	TEMPORARY_OFFSET
      7  781c				   FUNCTION_NAME SET	RestartFrame
     78  781c		       a9 00		      LDA	#0
     79  781e		       a9 0e		      lda	#%1110	; VSYNC ON
     80  7820		       85 02	   .loopVSync2 sta	WSYNC
     81  7822		       85 00		      sta	VSYNC
     82  7824		       4a		      lsr
     83  7825		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     84  7827
     85  7827							;------------------------------------------------------------------
     86  7827
     87  7827		       a2 00		      ldx	#0	;Platform
     88  7829		       bc 04 f4 	      ldy	VBlankTime,x
     89  782c		       8c 96 02 	      sty	TIM64T
     90  782f
     91  782f
     92  782f				  -	      IF	0
     93  782f				  -	      lda	SWCHB
     94  782f				  -	      rol
     95  782f				  -	      rol
     96  782f				  -	      rol
     97  782f				  -	      and	#%11
     98  782f				  -	      eor	#PAL
     99  782f				  -	      cmp	#0	;Platform
    100  782f				  -	      beq	platOK
    101  782f				  -			;sta Platform
    102  782f				  -	      jmp	TitleSequence
    103  782f				  -platOK
    104  782f					      ENDIF
    105  782f
    106  782f		       e6 82	   k2	      inc	rnd
    107  7831		       f0 fc		      beq	k2
    108  7833
    109  7833
    110  7833		       85 02	   VerticalBlank sta	WSYNC
    111  7835		       ad 84 02 	      lda	INTIM
    112  7838		       d0 f9		      bne	VerticalBlank
    113  783a		       85 01		      sta	VBLANK
    114  783c
    115  783c		       a9 00		      lda	#$0
    116  783e		       85 09		      sta	COLUBK
    117  7840
    118  7840							;------------------------------------------------------------------
    119  7840
    120  7840							; Do X scanlines of color-changing (our picture)
    121  7840
    122  7840		       a0 c9		      ldy	#67*3	; this counts our scanline number
    123  7842				   SokoLogo
    124  7842
    125  7842
    126  7842		       a9 24		      lda	#$24
    127  7844
    128  7844		       85 02		      sta	WSYNC
    129  7846		       85 08		      sta	COLUPF	; 3
    130  7848
    131  7848		       b9 00 f8 	      lda	COL_0,y	; 5
    132  784b		       85 0d		      sta	PF0	; 3   @11
    133  784d		       b9 cc f8 	      lda	COL_1,y	; 5
    134  7850		       85 0e		      sta	PF1	; 3   @19
    135  7852		       b9 98 f9 	      lda	COL_2,y	; 5
    136  7855		       85 0f		      sta	PF2	; 3   @27
    137  7857
    138  7857		       b9 00 f8 	      lda	COL_0,y	; 5
    139  785a		       0a		      asl
    140  785b		       0a		      asl
    141  785c		       0a		      asl
    142  785d		       0a		      asl
    143  785e		       85 0d		      sta	PF0	; 3   @35
    144  7860							;		  SLEEP 2      ; @37
    145  7860		       b9 64 fa 	      lda	COL_3,y	; 5
    146  7863		       85 0e		      sta	PF1	; 3   @45
    147  7865							;		  SLEEP 3      ; @45
    148  7865		       b9 30 fb 	      lda	COL_4,y	; 5
    149  7868		       85 0f		      sta	PF2	; 3
    150  786a
    151  786a		       88		      dey
    152  786b
    153  786b		       a9 68		      lda	#$68
    154  786d
    155  786d		       85 02		      sta	WSYNC
    156  786f		       85 08		      sta	COLUPF	; 3
    157  7871
    158  7871		       b9 00 f8 	      lda	COL_0,y	; 5
    159  7874		       85 0d		      sta	PF0	; 3   @11
    160  7876		       b9 cc f8 	      lda	COL_1,y	; 5
    161  7879		       85 0e		      sta	PF1	; 3   @19
    162  787b		       b9 98 f9 	      lda	COL_2,y	; 5
    163  787e		       85 0f		      sta	PF2	; 3   @27
    164  7880
    165  7880		       b9 00 f8 	      lda	COL_0,y	; 5
    166  7883		       0a		      asl
    167  7884		       0a		      asl
    168  7885		       0a		      asl
    169  7886		       0a		      asl
    170  7887		       85 0d		      sta	PF0	; 3   @35
    171  7889							;		  SLEEP 2      ; @37
    172  7889		       b9 64 fa 	      lda	COL_3,y	; 5
    173  788c		       85 0e		      sta	PF1	; 3   @45
    174  788e							;		  SLEEP 3      ; @45
    175  788e		       b9 30 fb 	      lda	COL_4,y	; 5
    176  7891		       85 0f		      sta	PF2	; 3
    177  7893
    178  7893		       88		      dey
    179  7894
    180  7894
    181  7894		       a9 d6		      lda	#$D6
    182  7896
    183  7896		       85 02		      sta	WSYNC
    184  7898		       85 08		      sta	COLUPF	; 3
    185  789a
    186  789a		       b9 00 f8 	      lda	COL_0,y	; 5
    187  789d		       85 0d		      sta	PF0	; 3   @11
    188  789f		       b9 cc f8 	      lda	COL_1,y	; 5
    189  78a2		       85 0e		      sta	PF1	; 3   @19
    190  78a4		       b9 98 f9 	      lda	COL_2,y	; 5
    191  78a7		       85 0f		      sta	PF2	; 3   @27
    192  78a9
    193  78a9		       b9 00 f8 	      lda	COL_0,y	; 5
    194  78ac		       0a		      asl
    195  78ad		       0a		      asl
    196  78ae		       0a		      asl
    197  78af		       0a		      asl
    198  78b0		       85 0d		      sta	PF0	; 3   @35
    199  78b2							;		  SLEEP 2      ; @37
    200  78b2		       b9 64 fa 	      lda	COL_3,y	; 5
    201  78b5		       85 0e		      sta	PF1	; 3   @45
    202  78b7							;		  SLEEP 3      ; @45
    203  78b7		       b9 30 fb 	      lda	COL_4,y	; 5
    204  78ba		       85 0f		      sta	PF2	; 3
    205  78bc
    206  78bc
    207  78bc
    208  78bc		       88		      dey		; 2
    209  78bd		       d0 83		      bne	SokoLogo	; 2(3)
    210  78bf
    211  78bf							;lda #0
    212  78bf							;sta PF0
    213  78bf							;sta PF1
    214  78bf							;sta PF2
    215  78bf
    216  78bf		       a2 00		      ldx	#0	;Platform
    217  78c1		       86 0d		      stx	PF0
    218  78c3		       86 0e		      stx	PF1
    219  78c5		       86 0f		      stx	PF2
    220  78c7
    221  78c7		       85 02		      sta	WSYNC
    222  78c9		       85 02		      sta	WSYNC
    223  78cb		       85 02		      sta	WSYNC
    224  78cd		       85 02		      sta	WSYNC
    225  78cf
    226  78cf		       86 09		      stx	COLUBK
    227  78d1		       bd 00 f4 	      lda	OverscanTime2,x
    228  78d4		       8d 96 02 	      sta	TIM64T
    229  78d7
    230  78d7				  -	      IF	0
    231  78d7				  -	      sta	WSYNC
    232  78d7				  -	      sta	WSYNC
    233  78d7				  -	      sta	WSYNC
    234  78d7				  -	      sta	WSYNC
    235  78d7				  -	      sta	WSYNC
    236  78d7				  -	      SLEEP	8
    237  78d7				  -	      jsr	SokoScreen
    238  78d7				  -
    239  78d7				  -	      lda	#0
    240  78d7				  -	      sta	BoardScrollX
    241  78d7				  -	      sta	BoardScrollY
    242  78d7					      ENDIF
    243  78d7
    244  78d7							;		ldy #63
    245  78d7							;bot2		 sta WSYNC
    246  78d7							;		dey
    247  78d7							;		bpl bot2
    248  78d7
    249  78d7							;--------------------------------------------------------------------------
    250  78d7
    251  78d7		       a9 00		      lda	#0
    252  78d9		       85 0d		      sta	PF0
    253  78db		       85 0e		      sta	PF1
    254  78dd		       85 0f		      sta	PF2
    255  78df
    256  78df
      0  78df					      NEXT_RANDOM
      1  78df
      2  78df		       a5 82		      lda	rnd
      3  78e1		       4a		      lsr
      4  78e2		       90 02		      bcc	.skipEOR
      5  78e4		       49 b4		      eor	#RND_EOR_VAL
      6  78e6		       85 82	   .skipEOR   sta	rnd
      7  78e8
    258  78e8
    259  78e8							; D1 VBLANK turns off beam
    260  78e8							; It needs to be turned on 37 scanlines later
    261  78e8
    262  78e8				   oscan
    263  78e8		       ad 84 02 	      lda	INTIM
    264  78eb		       d0 fb		      bne	oscan
    265  78ed
    266  78ed		       a9 42		      lda	#%01000010	; bit6 is not required
    267  78ef		       85 01		      sta	VBLANK	; end of screen - enter blanking
    268  78f1
    269  78f1				  -	      IF	0
    270  78f1				  -	      inc	rnd
    271  78f1				  -	      bne	rdd
    272  78f1				  -	      inc	rndHi
    273  78f1				  -rdd
    274  78f1				  -
    275  78f1				  -	      dec	digitick
    276  78f1				  -	      bpl	ret2
    277  78f1				  -	      lda	#40
    278  78f1				  -	      sta	digitick
    279  78f1				  -
    280  78f1				  -	      jsr	Random
    281  78f1				  -	      and	#3
    282  78f1				  -	      beq	ret2
    283  78f1				  -	      tax
    284  78f1				  -	      jsr	Random
    285  78f1				  -	      and	#$F0
    286  78f1				  -	      sta	digit-1,x
    287  78f1				  -	      jmp	RestartFrame0
    288  78f1				  -
    289  78f1				  -ret2
    290  78f1					      ENDIF
    291  78f1
    292  78f1
    293  78f1		       a5 0c		      lda	INPT4
    294  78f3		       10 03		      bpl	ret
    295  78f5
    296  78f5		       4c 1c f4 	      jmp	RestartFrame
    297  78f8
    298  78f8				   ret
    299  78f8		       60		      rts
    300  78f9
    301  78f9
    302  78f9
    303  78f9					      MAC	lumtable
    304  78f9							; {4} MIN LUM 1
    305  78f9							; {5} MIN LUM 2
    306  78f9							; {6} MIN LUM 3
    307  78f9
    308  78f9				   .LUM1      SET	{4}*256
    309  78f9				   .LUM2      SET	{5}*256
    310  78f9				   .LUM3      SET	{6}*256
    311  78f9
    312  78f9				   .STEP1     =	(256*({7}-{4}))/72
    313  78f9				   .STEP2     =	(256*({8}-{5}))/72
    314  78f9				   .STEP3     =	(256*({9}-{6}))/72
    315  78f9
    316  78f9					      REPEAT	72
    317  78f9					      .byte	{1}+(.LUM1/256)
    318  78f9					      .byte	{2}+(.LUM2/256)
    319  78f9					      .byte	{3}+(.LUM3/256)
    320  78f9
    321  78f9							;    ECHO {1}+(.LUM1/256)
    322  78f9							;    ECHO {2}+(.LUM1/256)
    323  78f9							;    ECHO {3}+(.LUM1/256)
    324  78f9
    325  78f9				   .LUM1      SET	.LUM1 + .STEP1
    326  78f9				   .LUM2      SET	.LUM2 + .STEP2
    327  78f9				   .LUM3      SET	.LUM3 + .STEP3
    328  78f9					      REPEND
    329  78f9					      ENDM		;{1}{2}{3} base colours
    330  78f9
    331  78f9							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    332  78f9							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    333  78f9
    334  7900		       00 00 00 00*	      align	256
    335  7900							;    ECHO "NTSC LUMS"
    336  7900				   colr_ntsc2
      0  7900					      LUMTABLE	$90,$10,$20,$4,$6,$8,$4,$6,$8
      1  7900
      2  7900
      3  7900
      4  7900
      5  7900				   .LUM1      SET	$4*256
      6  7900				   .LUM2      SET	$6*256
      7  7900				   .LUM3      SET	$8*256
      8  7900
      9  7900		       00 00	   .STEP1     =	(256*($4-$4))/72
     10  7900		       00 00	   .STEP2     =	(256*($6-$6))/72
     11  7900		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  7900
     13  7900					      REPEAT	72
     14  7900		       94		      .byte.b	$90+(.LUM1/256)
     15  7901		       16		      .byte.b	$10+(.LUM2/256)
     16  7902		       28		      .byte.b	$20+(.LUM3/256)
     17  7903
     18  7903
     19  7903
     20  7903
     21  7903
     22  7903				   .LUM1      SET	.LUM1 + .STEP1
     23  7903				   .LUM2      SET	.LUM2 + .STEP2
     24  7903				   .LUM3      SET	.LUM3 + .STEP3
     13  7903					      REPEND
     14  7903		       94		      .byte.b	$90+(.LUM1/256)
     15  7904		       16		      .byte.b	$10+(.LUM2/256)
     16  7905		       28		      .byte.b	$20+(.LUM3/256)
     17  7906
     18  7906
     19  7906
     20  7906
     21  7906
     22  7906				   .LUM1      SET	.LUM1 + .STEP1
     23  7906				   .LUM2      SET	.LUM2 + .STEP2
     24  7906				   .LUM3      SET	.LUM3 + .STEP3
     13  7906					      REPEND
     14  7906		       94		      .byte.b	$90+(.LUM1/256)
     15  7907		       16		      .byte.b	$10+(.LUM2/256)
     16  7908		       28		      .byte.b	$20+(.LUM3/256)
     17  7909
     18  7909
     19  7909
     20  7909
     21  7909
     22  7909				   .LUM1      SET	.LUM1 + .STEP1
     23  7909				   .LUM2      SET	.LUM2 + .STEP2
     24  7909				   .LUM3      SET	.LUM3 + .STEP3
     13  7909					      REPEND
     14  7909		       94		      .byte.b	$90+(.LUM1/256)
     15  790a		       16		      .byte.b	$10+(.LUM2/256)
     16  790b		       28		      .byte.b	$20+(.LUM3/256)
     17  790c
     18  790c
     19  790c
     20  790c
     21  790c
     22  790c				   .LUM1      SET	.LUM1 + .STEP1
     23  790c				   .LUM2      SET	.LUM2 + .STEP2
     24  790c				   .LUM3      SET	.LUM3 + .STEP3
     13  790c					      REPEND
     14  790c		       94		      .byte.b	$90+(.LUM1/256)
     15  790d		       16		      .byte.b	$10+(.LUM2/256)
     16  790e		       28		      .byte.b	$20+(.LUM3/256)
     17  790f
     18  790f
     19  790f
     20  790f
     21  790f
     22  790f				   .LUM1      SET	.LUM1 + .STEP1
     23  790f				   .LUM2      SET	.LUM2 + .STEP2
     24  790f				   .LUM3      SET	.LUM3 + .STEP3
     13  790f					      REPEND
     14  790f		       94		      .byte.b	$90+(.LUM1/256)
     15  7910		       16		      .byte.b	$10+(.LUM2/256)
     16  7911		       28		      .byte.b	$20+(.LUM3/256)
     17  7912
     18  7912
     19  7912
     20  7912
     21  7912
     22  7912				   .LUM1      SET	.LUM1 + .STEP1
     23  7912				   .LUM2      SET	.LUM2 + .STEP2
     24  7912				   .LUM3      SET	.LUM3 + .STEP3
     13  7912					      REPEND
     14  7912		       94		      .byte.b	$90+(.LUM1/256)
     15  7913		       16		      .byte.b	$10+(.LUM2/256)
     16  7914		       28		      .byte.b	$20+(.LUM3/256)
     17  7915
     18  7915
     19  7915
     20  7915
     21  7915
     22  7915				   .LUM1      SET	.LUM1 + .STEP1
     23  7915				   .LUM2      SET	.LUM2 + .STEP2
     24  7915				   .LUM3      SET	.LUM3 + .STEP3
     13  7915					      REPEND
     14  7915		       94		      .byte.b	$90+(.LUM1/256)
     15  7916		       16		      .byte.b	$10+(.LUM2/256)
     16  7917		       28		      .byte.b	$20+(.LUM3/256)
     17  7918
     18  7918
     19  7918
     20  7918
     21  7918
     22  7918				   .LUM1      SET	.LUM1 + .STEP1
     23  7918				   .LUM2      SET	.LUM2 + .STEP2
     24  7918				   .LUM3      SET	.LUM3 + .STEP3
     13  7918					      REPEND
     14  7918		       94		      .byte.b	$90+(.LUM1/256)
     15  7919		       16		      .byte.b	$10+(.LUM2/256)
     16  791a		       28		      .byte.b	$20+(.LUM3/256)
     17  791b
     18  791b
     19  791b
     20  791b
     21  791b
     22  791b				   .LUM1      SET	.LUM1 + .STEP1
     23  791b				   .LUM2      SET	.LUM2 + .STEP2
     24  791b				   .LUM3      SET	.LUM3 + .STEP3
     13  791b					      REPEND
     14  791b		       94		      .byte.b	$90+(.LUM1/256)
     15  791c		       16		      .byte.b	$10+(.LUM2/256)
     16  791d		       28		      .byte.b	$20+(.LUM3/256)
     17  791e
     18  791e
     19  791e
     20  791e
     21  791e
     22  791e				   .LUM1      SET	.LUM1 + .STEP1
     23  791e				   .LUM2      SET	.LUM2 + .STEP2
     24  791e				   .LUM3      SET	.LUM3 + .STEP3
     13  791e					      REPEND
     14  791e		       94		      .byte.b	$90+(.LUM1/256)
     15  791f		       16		      .byte.b	$10+(.LUM2/256)
     16  7920		       28		      .byte.b	$20+(.LUM3/256)
     17  7921
     18  7921
     19  7921
     20  7921
     21  7921
     22  7921				   .LUM1      SET	.LUM1 + .STEP1
     23  7921				   .LUM2      SET	.LUM2 + .STEP2
     24  7921				   .LUM3      SET	.LUM3 + .STEP3
     13  7921					      REPEND
     14  7921		       94		      .byte.b	$90+(.LUM1/256)
     15  7922		       16		      .byte.b	$10+(.LUM2/256)
     16  7923		       28		      .byte.b	$20+(.LUM3/256)
     17  7924
     18  7924
     19  7924
     20  7924
     21  7924
     22  7924				   .LUM1      SET	.LUM1 + .STEP1
     23  7924				   .LUM2      SET	.LUM2 + .STEP2
     24  7924				   .LUM3      SET	.LUM3 + .STEP3
     13  7924					      REPEND
     14  7924		       94		      .byte.b	$90+(.LUM1/256)
     15  7925		       16		      .byte.b	$10+(.LUM2/256)
     16  7926		       28		      .byte.b	$20+(.LUM3/256)
     17  7927
     18  7927
     19  7927
     20  7927
     21  7927
     22  7927				   .LUM1      SET	.LUM1 + .STEP1
     23  7927				   .LUM2      SET	.LUM2 + .STEP2
     24  7927				   .LUM3      SET	.LUM3 + .STEP3
     13  7927					      REPEND
     14  7927		       94		      .byte.b	$90+(.LUM1/256)
     15  7928		       16		      .byte.b	$10+(.LUM2/256)
     16  7929		       28		      .byte.b	$20+(.LUM3/256)
     17  792a
     18  792a
     19  792a
     20  792a
     21  792a
     22  792a				   .LUM1      SET	.LUM1 + .STEP1
     23  792a				   .LUM2      SET	.LUM2 + .STEP2
     24  792a				   .LUM3      SET	.LUM3 + .STEP3
     13  792a					      REPEND
     14  792a		       94		      .byte.b	$90+(.LUM1/256)
     15  792b		       16		      .byte.b	$10+(.LUM2/256)
     16  792c		       28		      .byte.b	$20+(.LUM3/256)
     17  792d
     18  792d
     19  792d
     20  792d
     21  792d
     22  792d				   .LUM1      SET	.LUM1 + .STEP1
     23  792d				   .LUM2      SET	.LUM2 + .STEP2
     24  792d				   .LUM3      SET	.LUM3 + .STEP3
     13  792d					      REPEND
     14  792d		       94		      .byte.b	$90+(.LUM1/256)
     15  792e		       16		      .byte.b	$10+(.LUM2/256)
     16  792f		       28		      .byte.b	$20+(.LUM3/256)
     17  7930
     18  7930
     19  7930
     20  7930
     21  7930
     22  7930				   .LUM1      SET	.LUM1 + .STEP1
     23  7930				   .LUM2      SET	.LUM2 + .STEP2
     24  7930				   .LUM3      SET	.LUM3 + .STEP3
     13  7930					      REPEND
     14  7930		       94		      .byte.b	$90+(.LUM1/256)
     15  7931		       16		      .byte.b	$10+(.LUM2/256)
     16  7932		       28		      .byte.b	$20+(.LUM3/256)
     17  7933
     18  7933
     19  7933
     20  7933
     21  7933
     22  7933				   .LUM1      SET	.LUM1 + .STEP1
     23  7933				   .LUM2      SET	.LUM2 + .STEP2
     24  7933				   .LUM3      SET	.LUM3 + .STEP3
     13  7933					      REPEND
     14  7933		       94		      .byte.b	$90+(.LUM1/256)
     15  7934		       16		      .byte.b	$10+(.LUM2/256)
     16  7935		       28		      .byte.b	$20+(.LUM3/256)
     17  7936
     18  7936
     19  7936
     20  7936
     21  7936
     22  7936				   .LUM1      SET	.LUM1 + .STEP1
     23  7936				   .LUM2      SET	.LUM2 + .STEP2
     24  7936				   .LUM3      SET	.LUM3 + .STEP3
     13  7936					      REPEND
     14  7936		       94		      .byte.b	$90+(.LUM1/256)
     15  7937		       16		      .byte.b	$10+(.LUM2/256)
     16  7938		       28		      .byte.b	$20+(.LUM3/256)
     17  7939
     18  7939
     19  7939
     20  7939
     21  7939
     22  7939				   .LUM1      SET	.LUM1 + .STEP1
     23  7939				   .LUM2      SET	.LUM2 + .STEP2
     24  7939				   .LUM3      SET	.LUM3 + .STEP3
     13  7939					      REPEND
     14  7939		       94		      .byte.b	$90+(.LUM1/256)
     15  793a		       16		      .byte.b	$10+(.LUM2/256)
     16  793b		       28		      .byte.b	$20+(.LUM3/256)
     17  793c
     18  793c
     19  793c
     20  793c
     21  793c
     22  793c				   .LUM1      SET	.LUM1 + .STEP1
     23  793c				   .LUM2      SET	.LUM2 + .STEP2
     24  793c				   .LUM3      SET	.LUM3 + .STEP3
     13  793c					      REPEND
     14  793c		       94		      .byte.b	$90+(.LUM1/256)
     15  793d		       16		      .byte.b	$10+(.LUM2/256)
     16  793e		       28		      .byte.b	$20+(.LUM3/256)
     17  793f
     18  793f
     19  793f
     20  793f
     21  793f
     22  793f				   .LUM1      SET	.LUM1 + .STEP1
     23  793f				   .LUM2      SET	.LUM2 + .STEP2
     24  793f				   .LUM3      SET	.LUM3 + .STEP3
     13  793f					      REPEND
     14  793f		       94		      .byte.b	$90+(.LUM1/256)
     15  7940		       16		      .byte.b	$10+(.LUM2/256)
     16  7941		       28		      .byte.b	$20+(.LUM3/256)
     17  7942
     18  7942
     19  7942
     20  7942
     21  7942
     22  7942				   .LUM1      SET	.LUM1 + .STEP1
     23  7942				   .LUM2      SET	.LUM2 + .STEP2
     24  7942				   .LUM3      SET	.LUM3 + .STEP3
     13  7942					      REPEND
     14  7942		       94		      .byte.b	$90+(.LUM1/256)
     15  7943		       16		      .byte.b	$10+(.LUM2/256)
     16  7944		       28		      .byte.b	$20+(.LUM3/256)
     17  7945
     18  7945
     19  7945
     20  7945
     21  7945
     22  7945				   .LUM1      SET	.LUM1 + .STEP1
     23  7945				   .LUM2      SET	.LUM2 + .STEP2
     24  7945				   .LUM3      SET	.LUM3 + .STEP3
     13  7945					      REPEND
     14  7945		       94		      .byte.b	$90+(.LUM1/256)
     15  7946		       16		      .byte.b	$10+(.LUM2/256)
     16  7947		       28		      .byte.b	$20+(.LUM3/256)
     17  7948
     18  7948
     19  7948
     20  7948
     21  7948
     22  7948				   .LUM1      SET	.LUM1 + .STEP1
     23  7948				   .LUM2      SET	.LUM2 + .STEP2
     24  7948				   .LUM3      SET	.LUM3 + .STEP3
     13  7948					      REPEND
     14  7948		       94		      .byte.b	$90+(.LUM1/256)
     15  7949		       16		      .byte.b	$10+(.LUM2/256)
     16  794a		       28		      .byte.b	$20+(.LUM3/256)
     17  794b
     18  794b
     19  794b
     20  794b
     21  794b
     22  794b				   .LUM1      SET	.LUM1 + .STEP1
     23  794b				   .LUM2      SET	.LUM2 + .STEP2
     24  794b				   .LUM3      SET	.LUM3 + .STEP3
     13  794b					      REPEND
     14  794b		       94		      .byte.b	$90+(.LUM1/256)
     15  794c		       16		      .byte.b	$10+(.LUM2/256)
     16  794d		       28		      .byte.b	$20+(.LUM3/256)
     17  794e
     18  794e
     19  794e
     20  794e
     21  794e
     22  794e				   .LUM1      SET	.LUM1 + .STEP1
     23  794e				   .LUM2      SET	.LUM2 + .STEP2
     24  794e				   .LUM3      SET	.LUM3 + .STEP3
     13  794e					      REPEND
     14  794e		       94		      .byte.b	$90+(.LUM1/256)
     15  794f		       16		      .byte.b	$10+(.LUM2/256)
     16  7950		       28		      .byte.b	$20+(.LUM3/256)
     17  7951
     18  7951
     19  7951
     20  7951
     21  7951
     22  7951				   .LUM1      SET	.LUM1 + .STEP1
     23  7951				   .LUM2      SET	.LUM2 + .STEP2
     24  7951				   .LUM3      SET	.LUM3 + .STEP3
     13  7951					      REPEND
     14  7951		       94		      .byte.b	$90+(.LUM1/256)
     15  7952		       16		      .byte.b	$10+(.LUM2/256)
     16  7953		       28		      .byte.b	$20+(.LUM3/256)
     17  7954
     18  7954
     19  7954
     20  7954
     21  7954
     22  7954				   .LUM1      SET	.LUM1 + .STEP1
     23  7954				   .LUM2      SET	.LUM2 + .STEP2
     24  7954				   .LUM3      SET	.LUM3 + .STEP3
     13  7954					      REPEND
     14  7954		       94		      .byte.b	$90+(.LUM1/256)
     15  7955		       16		      .byte.b	$10+(.LUM2/256)
     16  7956		       28		      .byte.b	$20+(.LUM3/256)
     17  7957
     18  7957
     19  7957
     20  7957
     21  7957
     22  7957				   .LUM1      SET	.LUM1 + .STEP1
     23  7957				   .LUM2      SET	.LUM2 + .STEP2
     24  7957				   .LUM3      SET	.LUM3 + .STEP3
     13  7957					      REPEND
     14  7957		       94		      .byte.b	$90+(.LUM1/256)
     15  7958		       16		      .byte.b	$10+(.LUM2/256)
     16  7959		       28		      .byte.b	$20+(.LUM3/256)
     17  795a
     18  795a
     19  795a
     20  795a
     21  795a
     22  795a				   .LUM1      SET	.LUM1 + .STEP1
     23  795a				   .LUM2      SET	.LUM2 + .STEP2
     24  795a				   .LUM3      SET	.LUM3 + .STEP3
     13  795a					      REPEND
     14  795a		       94		      .byte.b	$90+(.LUM1/256)
     15  795b		       16		      .byte.b	$10+(.LUM2/256)
     16  795c		       28		      .byte.b	$20+(.LUM3/256)
     17  795d
     18  795d
     19  795d
     20  795d
     21  795d
     22  795d				   .LUM1      SET	.LUM1 + .STEP1
     23  795d				   .LUM2      SET	.LUM2 + .STEP2
     24  795d				   .LUM3      SET	.LUM3 + .STEP3
     13  795d					      REPEND
     14  795d		       94		      .byte.b	$90+(.LUM1/256)
     15  795e		       16		      .byte.b	$10+(.LUM2/256)
     16  795f		       28		      .byte.b	$20+(.LUM3/256)
     17  7960
     18  7960
     19  7960
     20  7960
     21  7960
     22  7960				   .LUM1      SET	.LUM1 + .STEP1
     23  7960				   .LUM2      SET	.LUM2 + .STEP2
     24  7960				   .LUM3      SET	.LUM3 + .STEP3
     13  7960					      REPEND
     14  7960		       94		      .byte.b	$90+(.LUM1/256)
     15  7961		       16		      .byte.b	$10+(.LUM2/256)
     16  7962		       28		      .byte.b	$20+(.LUM3/256)
     17  7963
     18  7963
     19  7963
     20  7963
     21  7963
     22  7963				   .LUM1      SET	.LUM1 + .STEP1
     23  7963				   .LUM2      SET	.LUM2 + .STEP2
     24  7963				   .LUM3      SET	.LUM3 + .STEP3
     13  7963					      REPEND
     14  7963		       94		      .byte.b	$90+(.LUM1/256)
     15  7964		       16		      .byte.b	$10+(.LUM2/256)
     16  7965		       28		      .byte.b	$20+(.LUM3/256)
     17  7966
     18  7966
     19  7966
     20  7966
     21  7966
     22  7966				   .LUM1      SET	.LUM1 + .STEP1
     23  7966				   .LUM2      SET	.LUM2 + .STEP2
     24  7966				   .LUM3      SET	.LUM3 + .STEP3
     13  7966					      REPEND
     14  7966		       94		      .byte.b	$90+(.LUM1/256)
     15  7967		       16		      .byte.b	$10+(.LUM2/256)
     16  7968		       28		      .byte.b	$20+(.LUM3/256)
     17  7969
     18  7969
     19  7969
     20  7969
     21  7969
     22  7969				   .LUM1      SET	.LUM1 + .STEP1
     23  7969				   .LUM2      SET	.LUM2 + .STEP2
     24  7969				   .LUM3      SET	.LUM3 + .STEP3
     13  7969					      REPEND
     14  7969		       94		      .byte.b	$90+(.LUM1/256)
     15  796a		       16		      .byte.b	$10+(.LUM2/256)
     16  796b		       28		      .byte.b	$20+(.LUM3/256)
     17  796c
     18  796c
     19  796c
     20  796c
     21  796c
     22  796c				   .LUM1      SET	.LUM1 + .STEP1
     23  796c				   .LUM2      SET	.LUM2 + .STEP2
     24  796c				   .LUM3      SET	.LUM3 + .STEP3
     13  796c					      REPEND
     14  796c		       94		      .byte.b	$90+(.LUM1/256)
     15  796d		       16		      .byte.b	$10+(.LUM2/256)
     16  796e		       28		      .byte.b	$20+(.LUM3/256)
     17  796f
     18  796f
     19  796f
     20  796f
     21  796f
     22  796f				   .LUM1      SET	.LUM1 + .STEP1
     23  796f				   .LUM2      SET	.LUM2 + .STEP2
     24  796f				   .LUM3      SET	.LUM3 + .STEP3
     13  796f					      REPEND
     14  796f		       94		      .byte.b	$90+(.LUM1/256)
     15  7970		       16		      .byte.b	$10+(.LUM2/256)
     16  7971		       28		      .byte.b	$20+(.LUM3/256)
     17  7972
     18  7972
     19  7972
     20  7972
     21  7972
     22  7972				   .LUM1      SET	.LUM1 + .STEP1
     23  7972				   .LUM2      SET	.LUM2 + .STEP2
     24  7972				   .LUM3      SET	.LUM3 + .STEP3
     13  7972					      REPEND
     14  7972		       94		      .byte.b	$90+(.LUM1/256)
     15  7973		       16		      .byte.b	$10+(.LUM2/256)
     16  7974		       28		      .byte.b	$20+(.LUM3/256)
     17  7975
     18  7975
     19  7975
     20  7975
     21  7975
     22  7975				   .LUM1      SET	.LUM1 + .STEP1
     23  7975				   .LUM2      SET	.LUM2 + .STEP2
     24  7975				   .LUM3      SET	.LUM3 + .STEP3
     13  7975					      REPEND
     14  7975		       94		      .byte.b	$90+(.LUM1/256)
     15  7976		       16		      .byte.b	$10+(.LUM2/256)
     16  7977		       28		      .byte.b	$20+(.LUM3/256)
     17  7978
     18  7978
     19  7978
     20  7978
     21  7978
     22  7978				   .LUM1      SET	.LUM1 + .STEP1
     23  7978				   .LUM2      SET	.LUM2 + .STEP2
     24  7978				   .LUM3      SET	.LUM3 + .STEP3
     13  7978					      REPEND
     14  7978		       94		      .byte.b	$90+(.LUM1/256)
     15  7979		       16		      .byte.b	$10+(.LUM2/256)
     16  797a		       28		      .byte.b	$20+(.LUM3/256)
     17  797b
     18  797b
     19  797b
     20  797b
     21  797b
     22  797b				   .LUM1      SET	.LUM1 + .STEP1
     23  797b				   .LUM2      SET	.LUM2 + .STEP2
     24  797b				   .LUM3      SET	.LUM3 + .STEP3
     13  797b					      REPEND
     14  797b		       94		      .byte.b	$90+(.LUM1/256)
     15  797c		       16		      .byte.b	$10+(.LUM2/256)
     16  797d		       28		      .byte.b	$20+(.LUM3/256)
     17  797e
     18  797e
     19  797e
     20  797e
     21  797e
     22  797e				   .LUM1      SET	.LUM1 + .STEP1
     23  797e				   .LUM2      SET	.LUM2 + .STEP2
     24  797e				   .LUM3      SET	.LUM3 + .STEP3
     13  797e					      REPEND
     14  797e		       94		      .byte.b	$90+(.LUM1/256)
     15  797f		       16		      .byte.b	$10+(.LUM2/256)
     16  7980		       28		      .byte.b	$20+(.LUM3/256)
     17  7981
     18  7981
     19  7981
     20  7981
     21  7981
     22  7981				   .LUM1      SET	.LUM1 + .STEP1
     23  7981				   .LUM2      SET	.LUM2 + .STEP2
     24  7981				   .LUM3      SET	.LUM3 + .STEP3
     13  7981					      REPEND
     14  7981		       94		      .byte.b	$90+(.LUM1/256)
     15  7982		       16		      .byte.b	$10+(.LUM2/256)
     16  7983		       28		      .byte.b	$20+(.LUM3/256)
     17  7984
     18  7984
     19  7984
     20  7984
     21  7984
     22  7984				   .LUM1      SET	.LUM1 + .STEP1
     23  7984				   .LUM2      SET	.LUM2 + .STEP2
     24  7984				   .LUM3      SET	.LUM3 + .STEP3
     13  7984					      REPEND
     14  7984		       94		      .byte.b	$90+(.LUM1/256)
     15  7985		       16		      .byte.b	$10+(.LUM2/256)
     16  7986		       28		      .byte.b	$20+(.LUM3/256)
     17  7987
     18  7987
     19  7987
     20  7987
     21  7987
     22  7987				   .LUM1      SET	.LUM1 + .STEP1
     23  7987				   .LUM2      SET	.LUM2 + .STEP2
     24  7987				   .LUM3      SET	.LUM3 + .STEP3
     13  7987					      REPEND
     14  7987		       94		      .byte.b	$90+(.LUM1/256)
     15  7988		       16		      .byte.b	$10+(.LUM2/256)
     16  7989		       28		      .byte.b	$20+(.LUM3/256)
     17  798a
     18  798a
     19  798a
     20  798a
     21  798a
     22  798a				   .LUM1      SET	.LUM1 + .STEP1
     23  798a				   .LUM2      SET	.LUM2 + .STEP2
     24  798a				   .LUM3      SET	.LUM3 + .STEP3
     13  798a					      REPEND
     14  798a		       94		      .byte.b	$90+(.LUM1/256)
     15  798b		       16		      .byte.b	$10+(.LUM2/256)
     16  798c		       28		      .byte.b	$20+(.LUM3/256)
     17  798d
     18  798d
     19  798d
     20  798d
     21  798d
     22  798d				   .LUM1      SET	.LUM1 + .STEP1
     23  798d				   .LUM2      SET	.LUM2 + .STEP2
     24  798d				   .LUM3      SET	.LUM3 + .STEP3
     13  798d					      REPEND
     14  798d		       94		      .byte.b	$90+(.LUM1/256)
     15  798e		       16		      .byte.b	$10+(.LUM2/256)
     16  798f		       28		      .byte.b	$20+(.LUM3/256)
     17  7990
     18  7990
     19  7990
     20  7990
     21  7990
     22  7990				   .LUM1      SET	.LUM1 + .STEP1
     23  7990				   .LUM2      SET	.LUM2 + .STEP2
     24  7990				   .LUM3      SET	.LUM3 + .STEP3
     13  7990					      REPEND
     14  7990		       94		      .byte.b	$90+(.LUM1/256)
     15  7991		       16		      .byte.b	$10+(.LUM2/256)
     16  7992		       28		      .byte.b	$20+(.LUM3/256)
     17  7993
     18  7993
     19  7993
     20  7993
     21  7993
     22  7993				   .LUM1      SET	.LUM1 + .STEP1
     23  7993				   .LUM2      SET	.LUM2 + .STEP2
     24  7993				   .LUM3      SET	.LUM3 + .STEP3
     13  7993					      REPEND
     14  7993		       94		      .byte.b	$90+(.LUM1/256)
     15  7994		       16		      .byte.b	$10+(.LUM2/256)
     16  7995		       28		      .byte.b	$20+(.LUM3/256)
     17  7996
     18  7996
     19  7996
     20  7996
     21  7996
     22  7996				   .LUM1      SET	.LUM1 + .STEP1
     23  7996				   .LUM2      SET	.LUM2 + .STEP2
     24  7996				   .LUM3      SET	.LUM3 + .STEP3
     13  7996					      REPEND
     14  7996		       94		      .byte.b	$90+(.LUM1/256)
     15  7997		       16		      .byte.b	$10+(.LUM2/256)
     16  7998		       28		      .byte.b	$20+(.LUM3/256)
     17  7999
     18  7999
     19  7999
     20  7999
     21  7999
     22  7999				   .LUM1      SET	.LUM1 + .STEP1
     23  7999				   .LUM2      SET	.LUM2 + .STEP2
     24  7999				   .LUM3      SET	.LUM3 + .STEP3
     13  7999					      REPEND
     14  7999		       94		      .byte.b	$90+(.LUM1/256)
     15  799a		       16		      .byte.b	$10+(.LUM2/256)
     16  799b		       28		      .byte.b	$20+(.LUM3/256)
     17  799c
     18  799c
     19  799c
     20  799c
     21  799c
     22  799c				   .LUM1      SET	.LUM1 + .STEP1
     23  799c				   .LUM2      SET	.LUM2 + .STEP2
     24  799c				   .LUM3      SET	.LUM3 + .STEP3
     13  799c					      REPEND
     14  799c		       94		      .byte.b	$90+(.LUM1/256)
     15  799d		       16		      .byte.b	$10+(.LUM2/256)
     16  799e		       28		      .byte.b	$20+(.LUM3/256)
     17  799f
     18  799f
     19  799f
     20  799f
     21  799f
     22  799f				   .LUM1      SET	.LUM1 + .STEP1
     23  799f				   .LUM2      SET	.LUM2 + .STEP2
     24  799f				   .LUM3      SET	.LUM3 + .STEP3
     13  799f					      REPEND
     14  799f		       94		      .byte.b	$90+(.LUM1/256)
     15  79a0		       16		      .byte.b	$10+(.LUM2/256)
     16  79a1		       28		      .byte.b	$20+(.LUM3/256)
     17  79a2
     18  79a2
     19  79a2
     20  79a2
     21  79a2
     22  79a2				   .LUM1      SET	.LUM1 + .STEP1
     23  79a2				   .LUM2      SET	.LUM2 + .STEP2
     24  79a2				   .LUM3      SET	.LUM3 + .STEP3
     13  79a2					      REPEND
     14  79a2		       94		      .byte.b	$90+(.LUM1/256)
     15  79a3		       16		      .byte.b	$10+(.LUM2/256)
     16  79a4		       28		      .byte.b	$20+(.LUM3/256)
     17  79a5
     18  79a5
     19  79a5
     20  79a5
     21  79a5
     22  79a5				   .LUM1      SET	.LUM1 + .STEP1
     23  79a5				   .LUM2      SET	.LUM2 + .STEP2
     24  79a5				   .LUM3      SET	.LUM3 + .STEP3
     13  79a5					      REPEND
     14  79a5		       94		      .byte.b	$90+(.LUM1/256)
     15  79a6		       16		      .byte.b	$10+(.LUM2/256)
     16  79a7		       28		      .byte.b	$20+(.LUM3/256)
     17  79a8
     18  79a8
     19  79a8
     20  79a8
     21  79a8
     22  79a8				   .LUM1      SET	.LUM1 + .STEP1
     23  79a8				   .LUM2      SET	.LUM2 + .STEP2
     24  79a8				   .LUM3      SET	.LUM3 + .STEP3
     13  79a8					      REPEND
     14  79a8		       94		      .byte.b	$90+(.LUM1/256)
     15  79a9		       16		      .byte.b	$10+(.LUM2/256)
     16  79aa		       28		      .byte.b	$20+(.LUM3/256)
     17  79ab
     18  79ab
     19  79ab
     20  79ab
     21  79ab
     22  79ab				   .LUM1      SET	.LUM1 + .STEP1
     23  79ab				   .LUM2      SET	.LUM2 + .STEP2
     24  79ab				   .LUM3      SET	.LUM3 + .STEP3
     13  79ab					      REPEND
     14  79ab		       94		      .byte.b	$90+(.LUM1/256)
     15  79ac		       16		      .byte.b	$10+(.LUM2/256)
     16  79ad		       28		      .byte.b	$20+(.LUM3/256)
     17  79ae
     18  79ae
     19  79ae
     20  79ae
     21  79ae
     22  79ae				   .LUM1      SET	.LUM1 + .STEP1
     23  79ae				   .LUM2      SET	.LUM2 + .STEP2
     24  79ae				   .LUM3      SET	.LUM3 + .STEP3
     13  79ae					      REPEND
     14  79ae		       94		      .byte.b	$90+(.LUM1/256)
     15  79af		       16		      .byte.b	$10+(.LUM2/256)
     16  79b0		       28		      .byte.b	$20+(.LUM3/256)
     17  79b1
     18  79b1
     19  79b1
     20  79b1
     21  79b1
     22  79b1				   .LUM1      SET	.LUM1 + .STEP1
     23  79b1				   .LUM2      SET	.LUM2 + .STEP2
     24  79b1				   .LUM3      SET	.LUM3 + .STEP3
     13  79b1					      REPEND
     14  79b1		       94		      .byte.b	$90+(.LUM1/256)
     15  79b2		       16		      .byte.b	$10+(.LUM2/256)
     16  79b3		       28		      .byte.b	$20+(.LUM3/256)
     17  79b4
     18  79b4
     19  79b4
     20  79b4
     21  79b4
     22  79b4				   .LUM1      SET	.LUM1 + .STEP1
     23  79b4				   .LUM2      SET	.LUM2 + .STEP2
     24  79b4				   .LUM3      SET	.LUM3 + .STEP3
     13  79b4					      REPEND
     14  79b4		       94		      .byte.b	$90+(.LUM1/256)
     15  79b5		       16		      .byte.b	$10+(.LUM2/256)
     16  79b6		       28		      .byte.b	$20+(.LUM3/256)
     17  79b7
     18  79b7
     19  79b7
     20  79b7
     21  79b7
     22  79b7				   .LUM1      SET	.LUM1 + .STEP1
     23  79b7				   .LUM2      SET	.LUM2 + .STEP2
     24  79b7				   .LUM3      SET	.LUM3 + .STEP3
     13  79b7					      REPEND
     14  79b7		       94		      .byte.b	$90+(.LUM1/256)
     15  79b8		       16		      .byte.b	$10+(.LUM2/256)
     16  79b9		       28		      .byte.b	$20+(.LUM3/256)
     17  79ba
     18  79ba
     19  79ba
     20  79ba
     21  79ba
     22  79ba				   .LUM1      SET	.LUM1 + .STEP1
     23  79ba				   .LUM2      SET	.LUM2 + .STEP2
     24  79ba				   .LUM3      SET	.LUM3 + .STEP3
     13  79ba					      REPEND
     14  79ba		       94		      .byte.b	$90+(.LUM1/256)
     15  79bb		       16		      .byte.b	$10+(.LUM2/256)
     16  79bc		       28		      .byte.b	$20+(.LUM3/256)
     17  79bd
     18  79bd
     19  79bd
     20  79bd
     21  79bd
     22  79bd				   .LUM1      SET	.LUM1 + .STEP1
     23  79bd				   .LUM2      SET	.LUM2 + .STEP2
     24  79bd				   .LUM3      SET	.LUM3 + .STEP3
     13  79bd					      REPEND
     14  79bd		       94		      .byte.b	$90+(.LUM1/256)
     15  79be		       16		      .byte.b	$10+(.LUM2/256)
     16  79bf		       28		      .byte.b	$20+(.LUM3/256)
     17  79c0
     18  79c0
     19  79c0
     20  79c0
     21  79c0
     22  79c0				   .LUM1      SET	.LUM1 + .STEP1
     23  79c0				   .LUM2      SET	.LUM2 + .STEP2
     24  79c0				   .LUM3      SET	.LUM3 + .STEP3
     13  79c0					      REPEND
     14  79c0		       94		      .byte.b	$90+(.LUM1/256)
     15  79c1		       16		      .byte.b	$10+(.LUM2/256)
     16  79c2		       28		      .byte.b	$20+(.LUM3/256)
     17  79c3
     18  79c3
     19  79c3
     20  79c3
     21  79c3
     22  79c3				   .LUM1      SET	.LUM1 + .STEP1
     23  79c3				   .LUM2      SET	.LUM2 + .STEP2
     24  79c3				   .LUM3      SET	.LUM3 + .STEP3
     13  79c3					      REPEND
     14  79c3		       94		      .byte.b	$90+(.LUM1/256)
     15  79c4		       16		      .byte.b	$10+(.LUM2/256)
     16  79c5		       28		      .byte.b	$20+(.LUM3/256)
     17  79c6
     18  79c6
     19  79c6
     20  79c6
     21  79c6
     22  79c6				   .LUM1      SET	.LUM1 + .STEP1
     23  79c6				   .LUM2      SET	.LUM2 + .STEP2
     24  79c6				   .LUM3      SET	.LUM3 + .STEP3
     13  79c6					      REPEND
     14  79c6		       94		      .byte.b	$90+(.LUM1/256)
     15  79c7		       16		      .byte.b	$10+(.LUM2/256)
     16  79c8		       28		      .byte.b	$20+(.LUM3/256)
     17  79c9
     18  79c9
     19  79c9
     20  79c9
     21  79c9
     22  79c9				   .LUM1      SET	.LUM1 + .STEP1
     23  79c9				   .LUM2      SET	.LUM2 + .STEP2
     24  79c9				   .LUM3      SET	.LUM3 + .STEP3
     13  79c9					      REPEND
     14  79c9		       94		      .byte.b	$90+(.LUM1/256)
     15  79ca		       16		      .byte.b	$10+(.LUM2/256)
     16  79cb		       28		      .byte.b	$20+(.LUM3/256)
     17  79cc
     18  79cc
     19  79cc
     20  79cc
     21  79cc
     22  79cc				   .LUM1      SET	.LUM1 + .STEP1
     23  79cc				   .LUM2      SET	.LUM2 + .STEP2
     24  79cc				   .LUM3      SET	.LUM3 + .STEP3
     13  79cc					      REPEND
     14  79cc		       94		      .byte.b	$90+(.LUM1/256)
     15  79cd		       16		      .byte.b	$10+(.LUM2/256)
     16  79ce		       28		      .byte.b	$20+(.LUM3/256)
     17  79cf
     18  79cf
     19  79cf
     20  79cf
     21  79cf
     22  79cf				   .LUM1      SET	.LUM1 + .STEP1
     23  79cf				   .LUM2      SET	.LUM2 + .STEP2
     24  79cf				   .LUM3      SET	.LUM3 + .STEP3
     13  79cf					      REPEND
     14  79cf		       94		      .byte.b	$90+(.LUM1/256)
     15  79d0		       16		      .byte.b	$10+(.LUM2/256)
     16  79d1		       28		      .byte.b	$20+(.LUM3/256)
     17  79d2
     18  79d2
     19  79d2
     20  79d2
     21  79d2
     22  79d2				   .LUM1      SET	.LUM1 + .STEP1
     23  79d2				   .LUM2      SET	.LUM2 + .STEP2
     24  79d2				   .LUM3      SET	.LUM3 + .STEP3
     13  79d2					      REPEND
     14  79d2		       94		      .byte.b	$90+(.LUM1/256)
     15  79d3		       16		      .byte.b	$10+(.LUM2/256)
     16  79d4		       28		      .byte.b	$20+(.LUM3/256)
     17  79d5
     18  79d5
     19  79d5
     20  79d5
     21  79d5
     22  79d5				   .LUM1      SET	.LUM1 + .STEP1
     23  79d5				   .LUM2      SET	.LUM2 + .STEP2
     24  79d5				   .LUM3      SET	.LUM3 + .STEP3
     13  79d5					      REPEND
     14  79d5		       94		      .byte.b	$90+(.LUM1/256)
     15  79d6		       16		      .byte.b	$10+(.LUM2/256)
     16  79d7		       28		      .byte.b	$20+(.LUM3/256)
     17  79d8
     18  79d8
     19  79d8
     20  79d8
     21  79d8
     22  79d8				   .LUM1      SET	.LUM1 + .STEP1
     23  79d8				   .LUM2      SET	.LUM2 + .STEP2
     24  79d8				   .LUM3      SET	.LUM3 + .STEP3
     25  79d8					      REPEND
    338  79d8							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    339  79d8
    340  79d8							;    ECHO "PAL LUMS"
    341  79d8							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
      0  79d8				   colr_pal   LUMTABLE	$60, $80, $10, $6,$4,$8,$6,$4,$8
      1  79d8
      2  79d8
      3  79d8
      4  79d8
      5  79d8				   .LUM1      SET	$6*256
      6  79d8				   .LUM2      SET	$4*256
      7  79d8				   .LUM3      SET	$8*256
      8  79d8
      9  79d8		       00 00	   .STEP1     =	(256*($6-$6))/72
     10  79d8		       00 00	   .STEP2     =	(256*($4-$4))/72
     11  79d8		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  79d8
     13  79d8					      REPEAT	72
     14  79d8		       66		      .byte.b	$60+(.LUM1/256)
     15  79d9		       84		      .byte.b	$80+(.LUM2/256)
     16  79da		       18		      .byte.b	$10+(.LUM3/256)
     17  79db
     18  79db
     19  79db
     20  79db
     21  79db
     22  79db				   .LUM1      SET	.LUM1 + .STEP1
     23  79db				   .LUM2      SET	.LUM2 + .STEP2
     24  79db				   .LUM3      SET	.LUM3 + .STEP3
     13  79db					      REPEND
     14  79db		       66		      .byte.b	$60+(.LUM1/256)
     15  79dc		       84		      .byte.b	$80+(.LUM2/256)
     16  79dd		       18		      .byte.b	$10+(.LUM3/256)
     17  79de
     18  79de
     19  79de
     20  79de
     21  79de
     22  79de				   .LUM1      SET	.LUM1 + .STEP1
     23  79de				   .LUM2      SET	.LUM2 + .STEP2
     24  79de				   .LUM3      SET	.LUM3 + .STEP3
     13  79de					      REPEND
     14  79de		       66		      .byte.b	$60+(.LUM1/256)
     15  79df		       84		      .byte.b	$80+(.LUM2/256)
     16  79e0		       18		      .byte.b	$10+(.LUM3/256)
     17  79e1
     18  79e1
     19  79e1
     20  79e1
     21  79e1
     22  79e1				   .LUM1      SET	.LUM1 + .STEP1
     23  79e1				   .LUM2      SET	.LUM2 + .STEP2
     24  79e1				   .LUM3      SET	.LUM3 + .STEP3
     13  79e1					      REPEND
     14  79e1		       66		      .byte.b	$60+(.LUM1/256)
     15  79e2		       84		      .byte.b	$80+(.LUM2/256)
     16  79e3		       18		      .byte.b	$10+(.LUM3/256)
     17  79e4
     18  79e4
     19  79e4
     20  79e4
     21  79e4
     22  79e4				   .LUM1      SET	.LUM1 + .STEP1
     23  79e4				   .LUM2      SET	.LUM2 + .STEP2
     24  79e4				   .LUM3      SET	.LUM3 + .STEP3
     13  79e4					      REPEND
     14  79e4		       66		      .byte.b	$60+(.LUM1/256)
     15  79e5		       84		      .byte.b	$80+(.LUM2/256)
     16  79e6		       18		      .byte.b	$10+(.LUM3/256)
     17  79e7
     18  79e7
     19  79e7
     20  79e7
     21  79e7
     22  79e7				   .LUM1      SET	.LUM1 + .STEP1
     23  79e7				   .LUM2      SET	.LUM2 + .STEP2
     24  79e7				   .LUM3      SET	.LUM3 + .STEP3
     13  79e7					      REPEND
     14  79e7		       66		      .byte.b	$60+(.LUM1/256)
     15  79e8		       84		      .byte.b	$80+(.LUM2/256)
     16  79e9		       18		      .byte.b	$10+(.LUM3/256)
     17  79ea
     18  79ea
     19  79ea
     20  79ea
     21  79ea
     22  79ea				   .LUM1      SET	.LUM1 + .STEP1
     23  79ea				   .LUM2      SET	.LUM2 + .STEP2
     24  79ea				   .LUM3      SET	.LUM3 + .STEP3
     13  79ea					      REPEND
     14  79ea		       66		      .byte.b	$60+(.LUM1/256)
     15  79eb		       84		      .byte.b	$80+(.LUM2/256)
     16  79ec		       18		      .byte.b	$10+(.LUM3/256)
     17  79ed
     18  79ed
     19  79ed
     20  79ed
     21  79ed
     22  79ed				   .LUM1      SET	.LUM1 + .STEP1
     23  79ed				   .LUM2      SET	.LUM2 + .STEP2
     24  79ed				   .LUM3      SET	.LUM3 + .STEP3
     13  79ed					      REPEND
     14  79ed		       66		      .byte.b	$60+(.LUM1/256)
     15  79ee		       84		      .byte.b	$80+(.LUM2/256)
     16  79ef		       18		      .byte.b	$10+(.LUM3/256)
     17  79f0
     18  79f0
     19  79f0
     20  79f0
     21  79f0
     22  79f0				   .LUM1      SET	.LUM1 + .STEP1
     23  79f0				   .LUM2      SET	.LUM2 + .STEP2
     24  79f0				   .LUM3      SET	.LUM3 + .STEP3
     13  79f0					      REPEND
     14  79f0		       66		      .byte.b	$60+(.LUM1/256)
     15  79f1		       84		      .byte.b	$80+(.LUM2/256)
     16  79f2		       18		      .byte.b	$10+(.LUM3/256)
     17  79f3
     18  79f3
     19  79f3
     20  79f3
     21  79f3
     22  79f3				   .LUM1      SET	.LUM1 + .STEP1
     23  79f3				   .LUM2      SET	.LUM2 + .STEP2
     24  79f3				   .LUM3      SET	.LUM3 + .STEP3
     13  79f3					      REPEND
     14  79f3		       66		      .byte.b	$60+(.LUM1/256)
     15  79f4		       84		      .byte.b	$80+(.LUM2/256)
     16  79f5		       18		      .byte.b	$10+(.LUM3/256)
     17  79f6
     18  79f6
     19  79f6
     20  79f6
     21  79f6
     22  79f6				   .LUM1      SET	.LUM1 + .STEP1
     23  79f6				   .LUM2      SET	.LUM2 + .STEP2
     24  79f6				   .LUM3      SET	.LUM3 + .STEP3
     13  79f6					      REPEND
     14  79f6		       66		      .byte.b	$60+(.LUM1/256)
     15  79f7		       84		      .byte.b	$80+(.LUM2/256)
     16  79f8		       18		      .byte.b	$10+(.LUM3/256)
     17  79f9
     18  79f9
     19  79f9
     20  79f9
     21  79f9
     22  79f9				   .LUM1      SET	.LUM1 + .STEP1
     23  79f9				   .LUM2      SET	.LUM2 + .STEP2
     24  79f9				   .LUM3      SET	.LUM3 + .STEP3
     13  79f9					      REPEND
     14  79f9		       66		      .byte.b	$60+(.LUM1/256)
     15  79fa		       84		      .byte.b	$80+(.LUM2/256)
     16  79fb		       18		      .byte.b	$10+(.LUM3/256)
     17  79fc
     18  79fc
     19  79fc
     20  79fc
     21  79fc
     22  79fc				   .LUM1      SET	.LUM1 + .STEP1
     23  79fc				   .LUM2      SET	.LUM2 + .STEP2
     24  79fc				   .LUM3      SET	.LUM3 + .STEP3
     13  79fc					      REPEND
     14  79fc		       66		      .byte.b	$60+(.LUM1/256)
     15  79fd		       84		      .byte.b	$80+(.LUM2/256)
     16  79fe		       18		      .byte.b	$10+(.LUM3/256)
     17  79ff
     18  79ff
     19  79ff
     20  79ff
     21  79ff
     22  79ff				   .LUM1      SET	.LUM1 + .STEP1
     23  79ff				   .LUM2      SET	.LUM2 + .STEP2
     24  79ff				   .LUM3      SET	.LUM3 + .STEP3
     13  79ff					      REPEND
     14  79ff		       66		      .byte.b	$60+(.LUM1/256)
     15  7a00		       84		      .byte.b	$80+(.LUM2/256)
     16  7a01		       18		      .byte.b	$10+(.LUM3/256)
     17  7a02
     18  7a02
     19  7a02
     20  7a02
     21  7a02
     22  7a02				   .LUM1      SET	.LUM1 + .STEP1
     23  7a02				   .LUM2      SET	.LUM2 + .STEP2
     24  7a02				   .LUM3      SET	.LUM3 + .STEP3
     13  7a02					      REPEND
     14  7a02		       66		      .byte.b	$60+(.LUM1/256)
     15  7a03		       84		      .byte.b	$80+(.LUM2/256)
     16  7a04		       18		      .byte.b	$10+(.LUM3/256)
     17  7a05
     18  7a05
     19  7a05
     20  7a05
     21  7a05
     22  7a05				   .LUM1      SET	.LUM1 + .STEP1
     23  7a05				   .LUM2      SET	.LUM2 + .STEP2
     24  7a05				   .LUM3      SET	.LUM3 + .STEP3
     13  7a05					      REPEND
     14  7a05		       66		      .byte.b	$60+(.LUM1/256)
     15  7a06		       84		      .byte.b	$80+(.LUM2/256)
     16  7a07		       18		      .byte.b	$10+(.LUM3/256)
     17  7a08
     18  7a08
     19  7a08
     20  7a08
     21  7a08
     22  7a08				   .LUM1      SET	.LUM1 + .STEP1
     23  7a08				   .LUM2      SET	.LUM2 + .STEP2
     24  7a08				   .LUM3      SET	.LUM3 + .STEP3
     13  7a08					      REPEND
     14  7a08		       66		      .byte.b	$60+(.LUM1/256)
     15  7a09		       84		      .byte.b	$80+(.LUM2/256)
     16  7a0a		       18		      .byte.b	$10+(.LUM3/256)
     17  7a0b
     18  7a0b
     19  7a0b
     20  7a0b
     21  7a0b
     22  7a0b				   .LUM1      SET	.LUM1 + .STEP1
     23  7a0b				   .LUM2      SET	.LUM2 + .STEP2
     24  7a0b				   .LUM3      SET	.LUM3 + .STEP3
     13  7a0b					      REPEND
     14  7a0b		       66		      .byte.b	$60+(.LUM1/256)
     15  7a0c		       84		      .byte.b	$80+(.LUM2/256)
     16  7a0d		       18		      .byte.b	$10+(.LUM3/256)
     17  7a0e
     18  7a0e
     19  7a0e
     20  7a0e
     21  7a0e
     22  7a0e				   .LUM1      SET	.LUM1 + .STEP1
     23  7a0e				   .LUM2      SET	.LUM2 + .STEP2
     24  7a0e				   .LUM3      SET	.LUM3 + .STEP3
     13  7a0e					      REPEND
     14  7a0e		       66		      .byte.b	$60+(.LUM1/256)
     15  7a0f		       84		      .byte.b	$80+(.LUM2/256)
     16  7a10		       18		      .byte.b	$10+(.LUM3/256)
     17  7a11
     18  7a11
     19  7a11
     20  7a11
     21  7a11
     22  7a11				   .LUM1      SET	.LUM1 + .STEP1
     23  7a11				   .LUM2      SET	.LUM2 + .STEP2
     24  7a11				   .LUM3      SET	.LUM3 + .STEP3
     13  7a11					      REPEND
     14  7a11		       66		      .byte.b	$60+(.LUM1/256)
     15  7a12		       84		      .byte.b	$80+(.LUM2/256)
     16  7a13		       18		      .byte.b	$10+(.LUM3/256)
     17  7a14
     18  7a14
     19  7a14
     20  7a14
     21  7a14
     22  7a14				   .LUM1      SET	.LUM1 + .STEP1
     23  7a14				   .LUM2      SET	.LUM2 + .STEP2
     24  7a14				   .LUM3      SET	.LUM3 + .STEP3
     13  7a14					      REPEND
     14  7a14		       66		      .byte.b	$60+(.LUM1/256)
     15  7a15		       84		      .byte.b	$80+(.LUM2/256)
     16  7a16		       18		      .byte.b	$10+(.LUM3/256)
     17  7a17
     18  7a17
     19  7a17
     20  7a17
     21  7a17
     22  7a17				   .LUM1      SET	.LUM1 + .STEP1
     23  7a17				   .LUM2      SET	.LUM2 + .STEP2
     24  7a17				   .LUM3      SET	.LUM3 + .STEP3
     13  7a17					      REPEND
     14  7a17		       66		      .byte.b	$60+(.LUM1/256)
     15  7a18		       84		      .byte.b	$80+(.LUM2/256)
     16  7a19		       18		      .byte.b	$10+(.LUM3/256)
     17  7a1a
     18  7a1a
     19  7a1a
     20  7a1a
     21  7a1a
     22  7a1a				   .LUM1      SET	.LUM1 + .STEP1
     23  7a1a				   .LUM2      SET	.LUM2 + .STEP2
     24  7a1a				   .LUM3      SET	.LUM3 + .STEP3
     13  7a1a					      REPEND
     14  7a1a		       66		      .byte.b	$60+(.LUM1/256)
     15  7a1b		       84		      .byte.b	$80+(.LUM2/256)
     16  7a1c		       18		      .byte.b	$10+(.LUM3/256)
     17  7a1d
     18  7a1d
     19  7a1d
     20  7a1d
     21  7a1d
     22  7a1d				   .LUM1      SET	.LUM1 + .STEP1
     23  7a1d				   .LUM2      SET	.LUM2 + .STEP2
     24  7a1d				   .LUM3      SET	.LUM3 + .STEP3
     13  7a1d					      REPEND
     14  7a1d		       66		      .byte.b	$60+(.LUM1/256)
     15  7a1e		       84		      .byte.b	$80+(.LUM2/256)
     16  7a1f		       18		      .byte.b	$10+(.LUM3/256)
     17  7a20
     18  7a20
     19  7a20
     20  7a20
     21  7a20
     22  7a20				   .LUM1      SET	.LUM1 + .STEP1
     23  7a20				   .LUM2      SET	.LUM2 + .STEP2
     24  7a20				   .LUM3      SET	.LUM3 + .STEP3
     13  7a20					      REPEND
     14  7a20		       66		      .byte.b	$60+(.LUM1/256)
     15  7a21		       84		      .byte.b	$80+(.LUM2/256)
     16  7a22		       18		      .byte.b	$10+(.LUM3/256)
     17  7a23
     18  7a23
     19  7a23
     20  7a23
     21  7a23
     22  7a23				   .LUM1      SET	.LUM1 + .STEP1
     23  7a23				   .LUM2      SET	.LUM2 + .STEP2
     24  7a23				   .LUM3      SET	.LUM3 + .STEP3
     13  7a23					      REPEND
     14  7a23		       66		      .byte.b	$60+(.LUM1/256)
     15  7a24		       84		      .byte.b	$80+(.LUM2/256)
     16  7a25		       18		      .byte.b	$10+(.LUM3/256)
     17  7a26
     18  7a26
     19  7a26
     20  7a26
     21  7a26
     22  7a26				   .LUM1      SET	.LUM1 + .STEP1
     23  7a26				   .LUM2      SET	.LUM2 + .STEP2
     24  7a26				   .LUM3      SET	.LUM3 + .STEP3
     13  7a26					      REPEND
     14  7a26		       66		      .byte.b	$60+(.LUM1/256)
     15  7a27		       84		      .byte.b	$80+(.LUM2/256)
     16  7a28		       18		      .byte.b	$10+(.LUM3/256)
     17  7a29
     18  7a29
     19  7a29
     20  7a29
     21  7a29
     22  7a29				   .LUM1      SET	.LUM1 + .STEP1
     23  7a29				   .LUM2      SET	.LUM2 + .STEP2
     24  7a29				   .LUM3      SET	.LUM3 + .STEP3
     13  7a29					      REPEND
     14  7a29		       66		      .byte.b	$60+(.LUM1/256)
     15  7a2a		       84		      .byte.b	$80+(.LUM2/256)
     16  7a2b		       18		      .byte.b	$10+(.LUM3/256)
     17  7a2c
     18  7a2c
     19  7a2c
     20  7a2c
     21  7a2c
     22  7a2c				   .LUM1      SET	.LUM1 + .STEP1
     23  7a2c				   .LUM2      SET	.LUM2 + .STEP2
     24  7a2c				   .LUM3      SET	.LUM3 + .STEP3
     13  7a2c					      REPEND
     14  7a2c		       66		      .byte.b	$60+(.LUM1/256)
     15  7a2d		       84		      .byte.b	$80+(.LUM2/256)
     16  7a2e		       18		      .byte.b	$10+(.LUM3/256)
     17  7a2f
     18  7a2f
     19  7a2f
     20  7a2f
     21  7a2f
     22  7a2f				   .LUM1      SET	.LUM1 + .STEP1
     23  7a2f				   .LUM2      SET	.LUM2 + .STEP2
     24  7a2f				   .LUM3      SET	.LUM3 + .STEP3
     13  7a2f					      REPEND
     14  7a2f		       66		      .byte.b	$60+(.LUM1/256)
     15  7a30		       84		      .byte.b	$80+(.LUM2/256)
     16  7a31		       18		      .byte.b	$10+(.LUM3/256)
     17  7a32
     18  7a32
     19  7a32
     20  7a32
     21  7a32
     22  7a32				   .LUM1      SET	.LUM1 + .STEP1
     23  7a32				   .LUM2      SET	.LUM2 + .STEP2
     24  7a32				   .LUM3      SET	.LUM3 + .STEP3
     13  7a32					      REPEND
     14  7a32		       66		      .byte.b	$60+(.LUM1/256)
     15  7a33		       84		      .byte.b	$80+(.LUM2/256)
     16  7a34		       18		      .byte.b	$10+(.LUM3/256)
     17  7a35
     18  7a35
     19  7a35
     20  7a35
     21  7a35
     22  7a35				   .LUM1      SET	.LUM1 + .STEP1
     23  7a35				   .LUM2      SET	.LUM2 + .STEP2
     24  7a35				   .LUM3      SET	.LUM3 + .STEP3
     13  7a35					      REPEND
     14  7a35		       66		      .byte.b	$60+(.LUM1/256)
     15  7a36		       84		      .byte.b	$80+(.LUM2/256)
     16  7a37		       18		      .byte.b	$10+(.LUM3/256)
     17  7a38
     18  7a38
     19  7a38
     20  7a38
     21  7a38
     22  7a38				   .LUM1      SET	.LUM1 + .STEP1
     23  7a38				   .LUM2      SET	.LUM2 + .STEP2
     24  7a38				   .LUM3      SET	.LUM3 + .STEP3
     13  7a38					      REPEND
     14  7a38		       66		      .byte.b	$60+(.LUM1/256)
     15  7a39		       84		      .byte.b	$80+(.LUM2/256)
     16  7a3a		       18		      .byte.b	$10+(.LUM3/256)
     17  7a3b
     18  7a3b
     19  7a3b
     20  7a3b
     21  7a3b
     22  7a3b				   .LUM1      SET	.LUM1 + .STEP1
     23  7a3b				   .LUM2      SET	.LUM2 + .STEP2
     24  7a3b				   .LUM3      SET	.LUM3 + .STEP3
     13  7a3b					      REPEND
     14  7a3b		       66		      .byte.b	$60+(.LUM1/256)
     15  7a3c		       84		      .byte.b	$80+(.LUM2/256)
     16  7a3d		       18		      .byte.b	$10+(.LUM3/256)
     17  7a3e
     18  7a3e
     19  7a3e
     20  7a3e
     21  7a3e
     22  7a3e				   .LUM1      SET	.LUM1 + .STEP1
     23  7a3e				   .LUM2      SET	.LUM2 + .STEP2
     24  7a3e				   .LUM3      SET	.LUM3 + .STEP3
     13  7a3e					      REPEND
     14  7a3e		       66		      .byte.b	$60+(.LUM1/256)
     15  7a3f		       84		      .byte.b	$80+(.LUM2/256)
     16  7a40		       18		      .byte.b	$10+(.LUM3/256)
     17  7a41
     18  7a41
     19  7a41
     20  7a41
     21  7a41
     22  7a41				   .LUM1      SET	.LUM1 + .STEP1
     23  7a41				   .LUM2      SET	.LUM2 + .STEP2
     24  7a41				   .LUM3      SET	.LUM3 + .STEP3
     13  7a41					      REPEND
     14  7a41		       66		      .byte.b	$60+(.LUM1/256)
     15  7a42		       84		      .byte.b	$80+(.LUM2/256)
     16  7a43		       18		      .byte.b	$10+(.LUM3/256)
     17  7a44
     18  7a44
     19  7a44
     20  7a44
     21  7a44
     22  7a44				   .LUM1      SET	.LUM1 + .STEP1
     23  7a44				   .LUM2      SET	.LUM2 + .STEP2
     24  7a44				   .LUM3      SET	.LUM3 + .STEP3
     13  7a44					      REPEND
     14  7a44		       66		      .byte.b	$60+(.LUM1/256)
     15  7a45		       84		      .byte.b	$80+(.LUM2/256)
     16  7a46		       18		      .byte.b	$10+(.LUM3/256)
     17  7a47
     18  7a47
     19  7a47
     20  7a47
     21  7a47
     22  7a47				   .LUM1      SET	.LUM1 + .STEP1
     23  7a47				   .LUM2      SET	.LUM2 + .STEP2
     24  7a47				   .LUM3      SET	.LUM3 + .STEP3
     13  7a47					      REPEND
     14  7a47		       66		      .byte.b	$60+(.LUM1/256)
     15  7a48		       84		      .byte.b	$80+(.LUM2/256)
     16  7a49		       18		      .byte.b	$10+(.LUM3/256)
     17  7a4a
     18  7a4a
     19  7a4a
     20  7a4a
     21  7a4a
     22  7a4a				   .LUM1      SET	.LUM1 + .STEP1
     23  7a4a				   .LUM2      SET	.LUM2 + .STEP2
     24  7a4a				   .LUM3      SET	.LUM3 + .STEP3
     13  7a4a					      REPEND
     14  7a4a		       66		      .byte.b	$60+(.LUM1/256)
     15  7a4b		       84		      .byte.b	$80+(.LUM2/256)
     16  7a4c		       18		      .byte.b	$10+(.LUM3/256)
     17  7a4d
     18  7a4d
     19  7a4d
     20  7a4d
     21  7a4d
     22  7a4d				   .LUM1      SET	.LUM1 + .STEP1
     23  7a4d				   .LUM2      SET	.LUM2 + .STEP2
     24  7a4d				   .LUM3      SET	.LUM3 + .STEP3
     13  7a4d					      REPEND
     14  7a4d		       66		      .byte.b	$60+(.LUM1/256)
     15  7a4e		       84		      .byte.b	$80+(.LUM2/256)
     16  7a4f		       18		      .byte.b	$10+(.LUM3/256)
     17  7a50
     18  7a50
     19  7a50
     20  7a50
     21  7a50
     22  7a50				   .LUM1      SET	.LUM1 + .STEP1
     23  7a50				   .LUM2      SET	.LUM2 + .STEP2
     24  7a50				   .LUM3      SET	.LUM3 + .STEP3
     13  7a50					      REPEND
     14  7a50		       66		      .byte.b	$60+(.LUM1/256)
     15  7a51		       84		      .byte.b	$80+(.LUM2/256)
     16  7a52		       18		      .byte.b	$10+(.LUM3/256)
     17  7a53
     18  7a53
     19  7a53
     20  7a53
     21  7a53
     22  7a53				   .LUM1      SET	.LUM1 + .STEP1
     23  7a53				   .LUM2      SET	.LUM2 + .STEP2
     24  7a53				   .LUM3      SET	.LUM3 + .STEP3
     13  7a53					      REPEND
     14  7a53		       66		      .byte.b	$60+(.LUM1/256)
     15  7a54		       84		      .byte.b	$80+(.LUM2/256)
     16  7a55		       18		      .byte.b	$10+(.LUM3/256)
     17  7a56
     18  7a56
     19  7a56
     20  7a56
     21  7a56
     22  7a56				   .LUM1      SET	.LUM1 + .STEP1
     23  7a56				   .LUM2      SET	.LUM2 + .STEP2
     24  7a56				   .LUM3      SET	.LUM3 + .STEP3
     13  7a56					      REPEND
     14  7a56		       66		      .byte.b	$60+(.LUM1/256)
     15  7a57		       84		      .byte.b	$80+(.LUM2/256)
     16  7a58		       18		      .byte.b	$10+(.LUM3/256)
     17  7a59
     18  7a59
     19  7a59
     20  7a59
     21  7a59
     22  7a59				   .LUM1      SET	.LUM1 + .STEP1
     23  7a59				   .LUM2      SET	.LUM2 + .STEP2
     24  7a59				   .LUM3      SET	.LUM3 + .STEP3
     13  7a59					      REPEND
     14  7a59		       66		      .byte.b	$60+(.LUM1/256)
     15  7a5a		       84		      .byte.b	$80+(.LUM2/256)
     16  7a5b		       18		      .byte.b	$10+(.LUM3/256)
     17  7a5c
     18  7a5c
     19  7a5c
     20  7a5c
     21  7a5c
     22  7a5c				   .LUM1      SET	.LUM1 + .STEP1
     23  7a5c				   .LUM2      SET	.LUM2 + .STEP2
     24  7a5c				   .LUM3      SET	.LUM3 + .STEP3
     13  7a5c					      REPEND
     14  7a5c		       66		      .byte.b	$60+(.LUM1/256)
     15  7a5d		       84		      .byte.b	$80+(.LUM2/256)
     16  7a5e		       18		      .byte.b	$10+(.LUM3/256)
     17  7a5f
     18  7a5f
     19  7a5f
     20  7a5f
     21  7a5f
     22  7a5f				   .LUM1      SET	.LUM1 + .STEP1
     23  7a5f				   .LUM2      SET	.LUM2 + .STEP2
     24  7a5f				   .LUM3      SET	.LUM3 + .STEP3
     13  7a5f					      REPEND
     14  7a5f		       66		      .byte.b	$60+(.LUM1/256)
     15  7a60		       84		      .byte.b	$80+(.LUM2/256)
     16  7a61		       18		      .byte.b	$10+(.LUM3/256)
     17  7a62
     18  7a62
     19  7a62
     20  7a62
     21  7a62
     22  7a62				   .LUM1      SET	.LUM1 + .STEP1
     23  7a62				   .LUM2      SET	.LUM2 + .STEP2
     24  7a62				   .LUM3      SET	.LUM3 + .STEP3
     13  7a62					      REPEND
     14  7a62		       66		      .byte.b	$60+(.LUM1/256)
     15  7a63		       84		      .byte.b	$80+(.LUM2/256)
     16  7a64		       18		      .byte.b	$10+(.LUM3/256)
     17  7a65
     18  7a65
     19  7a65
     20  7a65
     21  7a65
     22  7a65				   .LUM1      SET	.LUM1 + .STEP1
     23  7a65				   .LUM2      SET	.LUM2 + .STEP2
     24  7a65				   .LUM3      SET	.LUM3 + .STEP3
     13  7a65					      REPEND
     14  7a65		       66		      .byte.b	$60+(.LUM1/256)
     15  7a66		       84		      .byte.b	$80+(.LUM2/256)
     16  7a67		       18		      .byte.b	$10+(.LUM3/256)
     17  7a68
     18  7a68
     19  7a68
     20  7a68
     21  7a68
     22  7a68				   .LUM1      SET	.LUM1 + .STEP1
     23  7a68				   .LUM2      SET	.LUM2 + .STEP2
     24  7a68				   .LUM3      SET	.LUM3 + .STEP3
     13  7a68					      REPEND
     14  7a68		       66		      .byte.b	$60+(.LUM1/256)
     15  7a69		       84		      .byte.b	$80+(.LUM2/256)
     16  7a6a		       18		      .byte.b	$10+(.LUM3/256)
     17  7a6b
     18  7a6b
     19  7a6b
     20  7a6b
     21  7a6b
     22  7a6b				   .LUM1      SET	.LUM1 + .STEP1
     23  7a6b				   .LUM2      SET	.LUM2 + .STEP2
     24  7a6b				   .LUM3      SET	.LUM3 + .STEP3
     13  7a6b					      REPEND
     14  7a6b		       66		      .byte.b	$60+(.LUM1/256)
     15  7a6c		       84		      .byte.b	$80+(.LUM2/256)
     16  7a6d		       18		      .byte.b	$10+(.LUM3/256)
     17  7a6e
     18  7a6e
     19  7a6e
     20  7a6e
     21  7a6e
     22  7a6e				   .LUM1      SET	.LUM1 + .STEP1
     23  7a6e				   .LUM2      SET	.LUM2 + .STEP2
     24  7a6e				   .LUM3      SET	.LUM3 + .STEP3
     13  7a6e					      REPEND
     14  7a6e		       66		      .byte.b	$60+(.LUM1/256)
     15  7a6f		       84		      .byte.b	$80+(.LUM2/256)
     16  7a70		       18		      .byte.b	$10+(.LUM3/256)
     17  7a71
     18  7a71
     19  7a71
     20  7a71
     21  7a71
     22  7a71				   .LUM1      SET	.LUM1 + .STEP1
     23  7a71				   .LUM2      SET	.LUM2 + .STEP2
     24  7a71				   .LUM3      SET	.LUM3 + .STEP3
     13  7a71					      REPEND
     14  7a71		       66		      .byte.b	$60+(.LUM1/256)
     15  7a72		       84		      .byte.b	$80+(.LUM2/256)
     16  7a73		       18		      .byte.b	$10+(.LUM3/256)
     17  7a74
     18  7a74
     19  7a74
     20  7a74
     21  7a74
     22  7a74				   .LUM1      SET	.LUM1 + .STEP1
     23  7a74				   .LUM2      SET	.LUM2 + .STEP2
     24  7a74				   .LUM3      SET	.LUM3 + .STEP3
     13  7a74					      REPEND
     14  7a74		       66		      .byte.b	$60+(.LUM1/256)
     15  7a75		       84		      .byte.b	$80+(.LUM2/256)
     16  7a76		       18		      .byte.b	$10+(.LUM3/256)
     17  7a77
     18  7a77
     19  7a77
     20  7a77
     21  7a77
     22  7a77				   .LUM1      SET	.LUM1 + .STEP1
     23  7a77				   .LUM2      SET	.LUM2 + .STEP2
     24  7a77				   .LUM3      SET	.LUM3 + .STEP3
     13  7a77					      REPEND
     14  7a77		       66		      .byte.b	$60+(.LUM1/256)
     15  7a78		       84		      .byte.b	$80+(.LUM2/256)
     16  7a79		       18		      .byte.b	$10+(.LUM3/256)
     17  7a7a
     18  7a7a
     19  7a7a
     20  7a7a
     21  7a7a
     22  7a7a				   .LUM1      SET	.LUM1 + .STEP1
     23  7a7a				   .LUM2      SET	.LUM2 + .STEP2
     24  7a7a				   .LUM3      SET	.LUM3 + .STEP3
     13  7a7a					      REPEND
     14  7a7a		       66		      .byte.b	$60+(.LUM1/256)
     15  7a7b		       84		      .byte.b	$80+(.LUM2/256)
     16  7a7c		       18		      .byte.b	$10+(.LUM3/256)
     17  7a7d
     18  7a7d
     19  7a7d
     20  7a7d
     21  7a7d
     22  7a7d				   .LUM1      SET	.LUM1 + .STEP1
     23  7a7d				   .LUM2      SET	.LUM2 + .STEP2
     24  7a7d				   .LUM3      SET	.LUM3 + .STEP3
     13  7a7d					      REPEND
     14  7a7d		       66		      .byte.b	$60+(.LUM1/256)
     15  7a7e		       84		      .byte.b	$80+(.LUM2/256)
     16  7a7f		       18		      .byte.b	$10+(.LUM3/256)
     17  7a80
     18  7a80
     19  7a80
     20  7a80
     21  7a80
     22  7a80				   .LUM1      SET	.LUM1 + .STEP1
     23  7a80				   .LUM2      SET	.LUM2 + .STEP2
     24  7a80				   .LUM3      SET	.LUM3 + .STEP3
     13  7a80					      REPEND
     14  7a80		       66		      .byte.b	$60+(.LUM1/256)
     15  7a81		       84		      .byte.b	$80+(.LUM2/256)
     16  7a82		       18		      .byte.b	$10+(.LUM3/256)
     17  7a83
     18  7a83
     19  7a83
     20  7a83
     21  7a83
     22  7a83				   .LUM1      SET	.LUM1 + .STEP1
     23  7a83				   .LUM2      SET	.LUM2 + .STEP2
     24  7a83				   .LUM3      SET	.LUM3 + .STEP3
     13  7a83					      REPEND
     14  7a83		       66		      .byte.b	$60+(.LUM1/256)
     15  7a84		       84		      .byte.b	$80+(.LUM2/256)
     16  7a85		       18		      .byte.b	$10+(.LUM3/256)
     17  7a86
     18  7a86
     19  7a86
     20  7a86
     21  7a86
     22  7a86				   .LUM1      SET	.LUM1 + .STEP1
     23  7a86				   .LUM2      SET	.LUM2 + .STEP2
     24  7a86				   .LUM3      SET	.LUM3 + .STEP3
     13  7a86					      REPEND
     14  7a86		       66		      .byte.b	$60+(.LUM1/256)
     15  7a87		       84		      .byte.b	$80+(.LUM2/256)
     16  7a88		       18		      .byte.b	$10+(.LUM3/256)
     17  7a89
     18  7a89
     19  7a89
     20  7a89
     21  7a89
     22  7a89				   .LUM1      SET	.LUM1 + .STEP1
     23  7a89				   .LUM2      SET	.LUM2 + .STEP2
     24  7a89				   .LUM3      SET	.LUM3 + .STEP3
     13  7a89					      REPEND
     14  7a89		       66		      .byte.b	$60+(.LUM1/256)
     15  7a8a		       84		      .byte.b	$80+(.LUM2/256)
     16  7a8b		       18		      .byte.b	$10+(.LUM3/256)
     17  7a8c
     18  7a8c
     19  7a8c
     20  7a8c
     21  7a8c
     22  7a8c				   .LUM1      SET	.LUM1 + .STEP1
     23  7a8c				   .LUM2      SET	.LUM2 + .STEP2
     24  7a8c				   .LUM3      SET	.LUM3 + .STEP3
     13  7a8c					      REPEND
     14  7a8c		       66		      .byte.b	$60+(.LUM1/256)
     15  7a8d		       84		      .byte.b	$80+(.LUM2/256)
     16  7a8e		       18		      .byte.b	$10+(.LUM3/256)
     17  7a8f
     18  7a8f
     19  7a8f
     20  7a8f
     21  7a8f
     22  7a8f				   .LUM1      SET	.LUM1 + .STEP1
     23  7a8f				   .LUM2      SET	.LUM2 + .STEP2
     24  7a8f				   .LUM3      SET	.LUM3 + .STEP3
     13  7a8f					      REPEND
     14  7a8f		       66		      .byte.b	$60+(.LUM1/256)
     15  7a90		       84		      .byte.b	$80+(.LUM2/256)
     16  7a91		       18		      .byte.b	$10+(.LUM3/256)
     17  7a92
     18  7a92
     19  7a92
     20  7a92
     21  7a92
     22  7a92				   .LUM1      SET	.LUM1 + .STEP1
     23  7a92				   .LUM2      SET	.LUM2 + .STEP2
     24  7a92				   .LUM3      SET	.LUM3 + .STEP3
     13  7a92					      REPEND
     14  7a92		       66		      .byte.b	$60+(.LUM1/256)
     15  7a93		       84		      .byte.b	$80+(.LUM2/256)
     16  7a94		       18		      .byte.b	$10+(.LUM3/256)
     17  7a95
     18  7a95
     19  7a95
     20  7a95
     21  7a95
     22  7a95				   .LUM1      SET	.LUM1 + .STEP1
     23  7a95				   .LUM2      SET	.LUM2 + .STEP2
     24  7a95				   .LUM3      SET	.LUM3 + .STEP3
     13  7a95					      REPEND
     14  7a95		       66		      .byte.b	$60+(.LUM1/256)
     15  7a96		       84		      .byte.b	$80+(.LUM2/256)
     16  7a97		       18		      .byte.b	$10+(.LUM3/256)
     17  7a98
     18  7a98
     19  7a98
     20  7a98
     21  7a98
     22  7a98				   .LUM1      SET	.LUM1 + .STEP1
     23  7a98				   .LUM2      SET	.LUM2 + .STEP2
     24  7a98				   .LUM3      SET	.LUM3 + .STEP3
     13  7a98					      REPEND
     14  7a98		       66		      .byte.b	$60+(.LUM1/256)
     15  7a99		       84		      .byte.b	$80+(.LUM2/256)
     16  7a9a		       18		      .byte.b	$10+(.LUM3/256)
     17  7a9b
     18  7a9b
     19  7a9b
     20  7a9b
     21  7a9b
     22  7a9b				   .LUM1      SET	.LUM1 + .STEP1
     23  7a9b				   .LUM2      SET	.LUM2 + .STEP2
     24  7a9b				   .LUM3      SET	.LUM3 + .STEP3
     13  7a9b					      REPEND
     14  7a9b		       66		      .byte.b	$60+(.LUM1/256)
     15  7a9c		       84		      .byte.b	$80+(.LUM2/256)
     16  7a9d		       18		      .byte.b	$10+(.LUM3/256)
     17  7a9e
     18  7a9e
     19  7a9e
     20  7a9e
     21  7a9e
     22  7a9e				   .LUM1      SET	.LUM1 + .STEP1
     23  7a9e				   .LUM2      SET	.LUM2 + .STEP2
     24  7a9e				   .LUM3      SET	.LUM3 + .STEP3
     13  7a9e					      REPEND
     14  7a9e		       66		      .byte.b	$60+(.LUM1/256)
     15  7a9f		       84		      .byte.b	$80+(.LUM2/256)
     16  7aa0		       18		      .byte.b	$10+(.LUM3/256)
     17  7aa1
     18  7aa1
     19  7aa1
     20  7aa1
     21  7aa1
     22  7aa1				   .LUM1      SET	.LUM1 + .STEP1
     23  7aa1				   .LUM2      SET	.LUM2 + .STEP2
     24  7aa1				   .LUM3      SET	.LUM3 + .STEP3
     13  7aa1					      REPEND
     14  7aa1		       66		      .byte.b	$60+(.LUM1/256)
     15  7aa2		       84		      .byte.b	$80+(.LUM2/256)
     16  7aa3		       18		      .byte.b	$10+(.LUM3/256)
     17  7aa4
     18  7aa4
     19  7aa4
     20  7aa4
     21  7aa4
     22  7aa4				   .LUM1      SET	.LUM1 + .STEP1
     23  7aa4				   .LUM2      SET	.LUM2 + .STEP2
     24  7aa4				   .LUM3      SET	.LUM3 + .STEP3
     13  7aa4					      REPEND
     14  7aa4		       66		      .byte.b	$60+(.LUM1/256)
     15  7aa5		       84		      .byte.b	$80+(.LUM2/256)
     16  7aa6		       18		      .byte.b	$10+(.LUM3/256)
     17  7aa7
     18  7aa7
     19  7aa7
     20  7aa7
     21  7aa7
     22  7aa7				   .LUM1      SET	.LUM1 + .STEP1
     23  7aa7				   .LUM2      SET	.LUM2 + .STEP2
     24  7aa7				   .LUM3      SET	.LUM3 + .STEP3
     13  7aa7					      REPEND
     14  7aa7		       66		      .byte.b	$60+(.LUM1/256)
     15  7aa8		       84		      .byte.b	$80+(.LUM2/256)
     16  7aa9		       18		      .byte.b	$10+(.LUM3/256)
     17  7aaa
     18  7aaa
     19  7aaa
     20  7aaa
     21  7aaa
     22  7aaa				   .LUM1      SET	.LUM1 + .STEP1
     23  7aaa				   .LUM2      SET	.LUM2 + .STEP2
     24  7aaa				   .LUM3      SET	.LUM3 + .STEP3
     13  7aaa					      REPEND
     14  7aaa		       66		      .byte.b	$60+(.LUM1/256)
     15  7aab		       84		      .byte.b	$80+(.LUM2/256)
     16  7aac		       18		      .byte.b	$10+(.LUM3/256)
     17  7aad
     18  7aad
     19  7aad
     20  7aad
     21  7aad
     22  7aad				   .LUM1      SET	.LUM1 + .STEP1
     23  7aad				   .LUM2      SET	.LUM2 + .STEP2
     24  7aad				   .LUM3      SET	.LUM3 + .STEP3
     13  7aad					      REPEND
     14  7aad		       66		      .byte.b	$60+(.LUM1/256)
     15  7aae		       84		      .byte.b	$80+(.LUM2/256)
     16  7aaf		       18		      .byte.b	$10+(.LUM3/256)
     17  7ab0
     18  7ab0
     19  7ab0
     20  7ab0
     21  7ab0
     22  7ab0				   .LUM1      SET	.LUM1 + .STEP1
     23  7ab0				   .LUM2      SET	.LUM2 + .STEP2
     24  7ab0				   .LUM3      SET	.LUM3 + .STEP3
     25  7ab0					      REPEND
    343  7ab0							;colr_pal	  LUMTABLE $90, $20, $60, $6,$A,$a,$C,$6,$8
    344  7ab0
    345  7ab0
    346  7ab0							;---------------------------------------------------------------------------------------------------
    347  7ab0
      0  7ab0					      END_BANK
      1  7ab0				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  7ab0				  -	      CHECK_RAM_BANK_SIZE
      3  7ab0					      ELSE
      0  7ab0					      CHECK_BANK_SIZE
      1  7ab0		       02 b0	   .TEMP      =	* - _BANK_START
 ROM bank # 31 TITLESCREEN size = $2b0 free = 335
      2  7ab0					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  7ab0				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7ab0				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  7ab0				  -	      ERR
      6  7ab0					      ENDIF
      5  7ab0					      ENDIF
    349  7ab0
    350  7ab0							;---------------------------------------------------------------------------------------------------
    351  7ab0							;EOF
------- FILE ./chess.asm
------- FILE TitleScreen@2.asm LEVEL 2 PASS 4
      0  7ab0					      include	"TitleScreen@2.asm"
      0  7ab0					      SLOT	2
      1  7ab0
      2  7ab0				  -	      IF	(2 < 0) || (2 > 3)
      3  7ab0				  -	      ECHO	"Illegal bank address/segment location", 2
      4  7ab0				  -	      ERR
      5  7ab0					      ENDIF
      6  7ab0
      7  7ab0				   _BANK_ADDRESS_ORIGIN SET	$F000 + (2 * _ROM_BANK_SIZE)
      8  7ab0				   _BANK_SLOT SET	2 * 64
      9  7ab0
      0  7ab0					      ROMBANK	TITLEDATA2
      1  8000 ????				      SEG	ROM_TITLEDATA2
      2  7c00					      ORG	_ORIGIN
      3  7c00					      RORG	_BANK_ADDRESS_ORIGIN
      4  7c00				   _BANK_START SET	*
      5  7c00				   TITLEDATA2_START SET	*
      6  7c00				   _CURRENT_BANK SET	(_ORIGIN - _FIRST_BANK ) / _ROM_BANK_SIZE
      7  7c00				   ROMBANK_TITLEDATA2 SET	_BANK_SLOT + _CURRENT_BANK
      8  7c00				   _ORIGIN    SET	_ORIGIN + _ROM_BANK_SIZE
      9  7c00				   _LAST_BANK SETSTR	TITLEDATA2
     10  7c00				   _CURRENT_BANK_TYPE SET	_TYPE_ROM
      3  7c00
      0  7c00					      DEF	TitleData
      1  7c00				   SLOT_TitleData SET	_BANK_SLOT
      2  7c00				   BANK_TitleData SET	SLOT_TitleData + _CURRENT_BANK
      3  7c00				   TitleData
      4  7c00				   TEMPORARY_VAR SET	Overlay
      5  7c00				   TEMPORARY_OFFSET SET	0
      6  7c00				   VAR_BOUNDARY_TitleData SET	TEMPORARY_OFFSET
      7  7c00				   FUNCTION_NAME SET	TitleData
------- FILE titleData.asm LEVEL 3 PASS 4
      0  7c00					      include	"titleData.asm"
      1  7c00				   COL_0
      2  7c00		       07		      .byte.b	7	;R (67)
      3  7c01		       06		      .byte.b	6	;G
      4  7c02		       00		      .byte.b	0	;B
      5  7c03		       02		      .byte.b	2	;R (66)
      6  7c04		       00		      .byte.b	0	;G
      7  7c05		       00		      .byte.b	0	;B
      8  7c06		       00		      .byte.b	0	;R (65)
      9  7c07		       00		      .byte.b	0	;G
     10  7c08		       0b		      .byte.b	11	;B
     11  7c09		       00		      .byte.b	0	;R (64)
     12  7c0a		       00		      .byte.b	0	;G
     13  7c0b		       00		      .byte.b	0	;B
     14  7c0c		       00		      .byte.b	0	;R (63)
     15  7c0d		       00		      .byte.b	0	;G
     16  7c0e		       0b		      .byte.b	11	;B
     17  7c0f		       00		      .byte.b	0	;R (62)
     18  7c10		       00		      .byte.b	0	;G
     19  7c11		       08		      .byte.b	8	;B
     20  7c12		       00		      .byte.b	0	;R (61)
     21  7c13		       00		      .byte.b	0	;G
     22  7c14		       0b		      .byte.b	11	;B
     23  7c15		       00		      .byte.b	0	;R (60)
     24  7c16		       00		      .byte.b	0	;G
     25  7c17		       00		      .byte.b	0	;B
     26  7c18		       00		      .byte.b	0	;R (59)
     27  7c19		       00		      .byte.b	0	;G
     28  7c1a		       00		      .byte.b	0	;B
     29  7c1b		       04		      .byte.b	4	;R (58)
     30  7c1c		       04		      .byte.b	4	;G
     31  7c1d		       00		      .byte.b	0	;B
     32  7c1e		       0f		      .byte.b	15	;R (57)
     33  7c1f		       00		      .byte.b	0	;G
     34  7c20		       00		      .byte.b	0	;B
     35  7c21		       0f		      .byte.b	15	;R (56)
     36  7c22		       00		      .byte.b	0	;G
     37  7c23		       00		      .byte.b	0	;B
     38  7c24		       8f		      .byte.b	143	;R (55)
     39  7c25		       80		      .byte.b	128	;G
     40  7c26		       00		      .byte.b	0	;B
     41  7c27		       8f		      .byte.b	143	;R (54)
     42  7c28		       00		      .byte.b	0	;G
     43  7c29		       00		      .byte.b	0	;B
     44  7c2a		       cf		      .byte.b	207	;R (53)
     45  7c2b		       40		      .byte.b	64	;G
     46  7c2c		       00		      .byte.b	0	;B
     47  7c2d		       0f		      .byte.b	15	;R (52)
     48  7c2e		       00		      .byte.b	0	;G
     49  7c2f		       00		      .byte.b	0	;B
     50  7c30		       0f		      .byte.b	15	;R (51)
     51  7c31		       00		      .byte.b	0	;G
     52  7c32		       00		      .byte.b	0	;B
     53  7c33		       0f		      .byte.b	15	;R (50)
     54  7c34		       00		      .byte.b	0	;G
     55  7c35		       00		      .byte.b	0	;B
     56  7c36		       0f		      .byte.b	15	;R (49)
     57  7c37		       08		      .byte.b	8	;G
     58  7c38		       00		      .byte.b	0	;B
     59  7c39		       07		      .byte.b	7	;R (48)
     60  7c3a		       00		      .byte.b	0	;G
     61  7c3b		       00		      .byte.b	0	;B
     62  7c3c		       07		      .byte.b	7	;R (47)
     63  7c3d		       00		      .byte.b	0	;G
     64  7c3e		       00		      .byte.b	0	;B
     65  7c3f		       07		      .byte.b	7	;R (46)
     66  7c40		       00		      .byte.b	0	;G
     67  7c41		       00		      .byte.b	0	;B
     68  7c42		       07		      .byte.b	7	;R (45)
     69  7c43		       00		      .byte.b	0	;G
     70  7c44		       00		      .byte.b	0	;B
     71  7c45		       07		      .byte.b	7	;R (44)
     72  7c46		       00		      .byte.b	0	;G
     73  7c47		       00		      .byte.b	0	;B
     74  7c48		       07		      .byte.b	7	;R (43)
     75  7c49		       00		      .byte.b	0	;G
     76  7c4a		       00		      .byte.b	0	;B
     77  7c4b		       8f		      .byte.b	143	;R (42)
     78  7c4c		       88		      .byte.b	136	;G
     79  7c4d		       00		      .byte.b	0	;B
     80  7c4e		       cf		      .byte.b	207	;R (41)
     81  7c4f		       40		      .byte.b	64	;G
     82  7c50		       00		      .byte.b	0	;B
     83  7c51		       0f		      .byte.b	15	;R (40)
     84  7c52		       00		      .byte.b	0	;G
     85  7c53		       00		      .byte.b	0	;B
     86  7c54		       0f		      .byte.b	15	;R (39)
     87  7c55		       00		      .byte.b	0	;G
     88  7c56		       00		      .byte.b	0	;B
     89  7c57		       0f		      .byte.b	15	;R (38)
     90  7c58		       02		      .byte.b	2	;G
     91  7c59		       00		      .byte.b	0	;B
     92  7c5a		       cf		      .byte.b	207	;R (37)
     93  7c5b		       c0		      .byte.b	192	;G
     94  7c5c		       00		      .byte.b	0	;B
     95  7c5d		       ef		      .byte.b	239	;R (36)
     96  7c5e		       a0		      .byte.b	160	;G
     97  7c5f		       00		      .byte.b	0	;B
     98  7c60		       ef		      .byte.b	239	;R (35)
     99  7c61		       ea		      .byte.b	234	;G
    100  7c62		       00		      .byte.b	0	;B
    101  7c63		       6f		      .byte.b	111	;R (34)
    102  7c64		       40		      .byte.b	64	;G
    103  7c65		       00		      .byte.b	0	;B
    104  7c66		       0f		      .byte.b	15	;R (33)
    105  7c67		       0a		      .byte.b	10	;G
    106  7c68		       00		      .byte.b	0	;B
    107  7c69		       0f		      .byte.b	15	;R (32)
    108  7c6a		       00		      .byte.b	0	;G
    109  7c6b		       00		      .byte.b	0	;B
    110  7c6c		       4f		      .byte.b	79	;R (31)
    111  7c6d		       41		      .byte.b	65	;G
    112  7c6e		       00		      .byte.b	0	;B
    113  7c6f		       67		      .byte.b	103	;R (30)
    114  7c70		       63		      .byte.b	99	;G
    115  7c71		       08		      .byte.b	8	;B
    116  7c72		       6f		      .byte.b	111	;R (29)
    117  7c73		       41		      .byte.b	65	;G
    118  7c74		       00		      .byte.b	0	;B
    119  7c75		       af		      .byte.b	175	;R (28)
    120  7c76		       89		      .byte.b	137	;G
    121  7c77		       00		      .byte.b	0	;B
    122  7c78		       3f		      .byte.b	63	;R (27)
    123  7c79		       33		      .byte.b	51	;G
    124  7c7a		       00		      .byte.b	0	;B
    125  7c7b		       0f		      .byte.b	15	;R (26)
    126  7c7c		       01		      .byte.b	1	;G
    127  7c7d		       00		      .byte.b	0	;B
    128  7c7e		       cd		      .byte.b	205	;R (25)
    129  7c7f		       c9		      .byte.b	201	;G
    130  7c80		       02		      .byte.b	2	;B
    131  7c81		       cf		      .byte.b	207	;R (24)
    132  7c82		       81		      .byte.b	129	;G
    133  7c83		       00		      .byte.b	0	;B
    134  7c84		       ef		      .byte.b	239	;R (23)
    135  7c85		       e5		      .byte.b	229	;G
    136  7c86		       00		      .byte.b	0	;B
    137  7c87		       4f		      .byte.b	79	;R (22)
    138  7c88		       01		      .byte.b	1	;G
    139  7c89		       00		      .byte.b	0	;B
    140  7c8a		       4f		      .byte.b	79	;R (21)
    141  7c8b		       40		      .byte.b	64	;G
    142  7c8c		       00		      .byte.b	0	;B
    143  7c8d		       8f		      .byte.b	143	;R (20)
    144  7c8e		       8e		      .byte.b	142	;G
    145  7c8f		       00		      .byte.b	0	;B
    146  7c90		       87		      .byte.b	135	;R (19)
    147  7c91		       84		      .byte.b	132	;G
    148  7c92		       00		      .byte.b	0	;B
    149  7c93		       87		      .byte.b	135	;R (18)
    150  7c94		       04		      .byte.b	4	;G
    151  7c95		       00		      .byte.b	0	;B
    152  7c96		       8f		      .byte.b	143	;R (17)
    153  7c97		       0e		      .byte.b	14	;G
    154  7c98		       00		      .byte.b	0	;B
    155  7c99		       8a		      .byte.b	138	;R (16)
    156  7c9a		       8a		      .byte.b	138	;G
    157  7c9b		       00		      .byte.b	0	;B
    158  7c9c		       06		      .byte.b	6	;R (15)
    159  7c9d		       06		      .byte.b	6	;G
    160  7c9e		       00		      .byte.b	0	;B
    161  7c9f		       02		      .byte.b	2	;R (14)
    162  7ca0		       02		      .byte.b	2	;G
    163  7ca1		       00		      .byte.b	0	;B
    164  7ca2		       00		      .byte.b	0	;R (13)
    165  7ca3		       00		      .byte.b	0	;G
    166  7ca4		       00		      .byte.b	0	;B
    167  7ca5		       00		      .byte.b	0	;R (12)
    168  7ca6		       00		      .byte.b	0	;G
    169  7ca7		       00		      .byte.b	0	;B
    170  7ca8		       00		      .byte.b	0	;R (11)
    171  7ca9		       00		      .byte.b	0	;G
    172  7caa		       00		      .byte.b	0	;B
    173  7cab		       00		      .byte.b	0	;R (10)
    174  7cac		       00		      .byte.b	0	;G
    175  7cad		       00		      .byte.b	0	;B
    176  7cae		       00		      .byte.b	0	;R (9)
    177  7caf		       00		      .byte.b	0	;G
    178  7cb0		       00		      .byte.b	0	;B
    179  7cb1		       00		      .byte.b	0	;R (8)
    180  7cb2		       00		      .byte.b	0	;G
    181  7cb3		       07		      .byte.b	7	;B
    182  7cb4		       00		      .byte.b	0	;R (7)
    183  7cb5		       00		      .byte.b	0	;G
    184  7cb6		       05		      .byte.b	5	;B
    185  7cb7		       00		      .byte.b	0	;R (6)
    186  7cb8		       00		      .byte.b	0	;G
    187  7cb9		       05		      .byte.b	5	;B
    188  7cba		       00		      .byte.b	0	;R (5)
    189  7cbb		       00		      .byte.b	0	;G
    190  7cbc		       05		      .byte.b	5	;B
    191  7cbd		       00		      .byte.b	0	;R (4)
    192  7cbe		       00		      .byte.b	0	;G
    193  7cbf		       05		      .byte.b	5	;B
    194  7cc0		       00		      .byte.b	0	;R (3)
    195  7cc1		       00		      .byte.b	0	;G
    196  7cc2		       07		      .byte.b	7	;B
    197  7cc3		       00		      .byte.b	0	;R (2)
    198  7cc4		       00		      .byte.b	0	;G
    199  7cc5		       00		      .byte.b	0	;B
    200  7cc6		       00		      .byte.b	0	;R (1)
    201  7cc7		       00		      .byte.b	0	;G
    202  7cc8		       00		      .byte.b	0	;B
    203  7cc9		       00		      .byte.b	0	;R (0)
    204  7cca		       00		      .byte.b	0	;G
    205  7ccb		       00		      .byte.b	0	;B
    206  7ccc				   COL_1
    207  7ccc		       00		      .byte.b	0	;R (67)
    208  7ccd		       00		      .byte.b	0	;G
    209  7cce		       00		      .byte.b	0	;B
    210  7ccf		       00		      .byte.b	0	;R (66)
    211  7cd0		       00		      .byte.b	0	;G
    212  7cd1		       00		      .byte.b	0	;B
    213  7cd2		       04		      .byte.b	4	;R (65)
    214  7cd3		       00		      .byte.b	0	;G
    215  7cd4		       00		      .byte.b	0	;B
    216  7cd5		       1c		      .byte.b	28	;R (64)
    217  7cd6		       18		      .byte.b	24	;G
    218  7cd7		       01		      .byte.b	1	;B
    219  7cd8		       3c		      .byte.b	60	;R (63)
    220  7cd9		       30		      .byte.b	48	;G
    221  7cda		       01		      .byte.b	1	;B
    222  7cdb		       1c		      .byte.b	28	;R (62)
    223  7cdc		       00		      .byte.b	0	;G
    224  7cdd		       01		      .byte.b	1	;B
    225  7cde		       1c		      .byte.b	28	;R (61)
    226  7cdf		       04		      .byte.b	4	;G
    227  7ce0		       21		      .byte.b	33	;B
    228  7ce1		       1c		      .byte.b	28	;R (60)
    229  7ce2		       08		      .byte.b	8	;G
    230  7ce3		       01		      .byte.b	1	;B
    231  7ce4		       1c		      .byte.b	28	;R (59)
    232  7ce5		       00		      .byte.b	0	;G
    233  7ce6		       00		      .byte.b	0	;B
    234  7ce7		       1b		      .byte.b	27	;R (58)
    235  7ce8		       0b		      .byte.b	11	;G
    236  7ce9		       04		      .byte.b	4	;B
    237  7cea		       1f		      .byte.b	31	;R (57)
    238  7ceb		       1d		      .byte.b	29	;G
    239  7cec		       00		      .byte.b	0	;B
    240  7ced		       df		      .byte.b	223	;R (56)
    241  7cee		       d2		      .byte.b	210	;G
    242  7cef		       20		      .byte.b	32	;B
    243  7cf0		       ff		      .byte.b	255	;R (55)
    244  7cf1		       3c		      .byte.b	60	;G
    245  7cf2		       00		      .byte.b	0	;B
    246  7cf3		       ff		      .byte.b	255	;R (54)
    247  7cf4		       4f		      .byte.b	79	;G
    248  7cf5		       00		      .byte.b	0	;B
    249  7cf6		       ff		      .byte.b	255	;R (53)
    250  7cf7		       93		      .byte.b	147	;G
    251  7cf8		       00		      .byte.b	0	;B
    252  7cf9		       1f		      .byte.b	31	;R (52)
    253  7cfa		       1f		      .byte.b	31	;G
    254  7cfb		       00		      .byte.b	0	;B
    255  7cfc		       00		      .byte.b	0	;R (51)
    256  7cfd		       00		      .byte.b	0	;G
    257  7cfe		       00		      .byte.b	0	;B
    258  7cff		       00		      .byte.b	0	;R (50)
    259  7d00		       00		      .byte.b	0	;G
    260  7d01		       00		      .byte.b	0	;B
    261  7d02		       1a		      .byte.b	26	;R (49)
    262  7d03		       1a		      .byte.b	26	;G
    263  7d04		       00		      .byte.b	0	;B
    264  7d05		       38		      .byte.b	56	;R (48)
    265  7d06		       28		      .byte.b	40	;G
    266  7d07		       00		      .byte.b	0	;B
    267  7d08		       71		      .byte.b	113	;R (47)
    268  7d09		       51		      .byte.b	81	;G
    269  7d0a		       00		      .byte.b	0	;B
    270  7d0b		       0b		      .byte.b	11	;R (46)
    271  7d0c		       0b		      .byte.b	11	;G
    272  7d0d		       00		      .byte.b	0	;B
    273  7d0e		       03		      .byte.b	3	;R (45)
    274  7d0f		       03		      .byte.b	3	;G
    275  7d10		       00		      .byte.b	0	;B
    276  7d11		       ca		      .byte.b	202	;R (44)
    277  7d12		       ca		      .byte.b	202	;G
    278  7d13		       00		      .byte.b	0	;B
    279  7d14		       c8		      .byte.b	200	;R (43)
    280  7d15		       c8		      .byte.b	200	;G
    281  7d16		       00		      .byte.b	0	;B
    282  7d17		       c8		      .byte.b	200	;R (42)
    283  7d18		       40		      .byte.b	64	;G
    284  7d19		       00		      .byte.b	0	;B
    285  7d1a		       48		      .byte.b	72	;R (41)
    286  7d1b		       40		      .byte.b	64	;G
    287  7d1c		       00		      .byte.b	0	;B
    288  7d1d		       08		      .byte.b	8	;R (40)
    289  7d1e		       08		      .byte.b	8	;G
    290  7d1f		       00		      .byte.b	0	;B
    291  7d20		       a0		      .byte.b	160	;R (39)
    292  7d21		       a0		      .byte.b	160	;G
    293  7d22		       00		      .byte.b	0	;B
    294  7d23		       20		      .byte.b	32	;R (38)
    295  7d24		       00		      .byte.b	0	;G
    296  7d25		       00		      .byte.b	0	;B
    297  7d26		       20		      .byte.b	32	;R (37)
    298  7d27		       00		      .byte.b	0	;G
    299  7d28		       00		      .byte.b	0	;B
    300  7d29		       20		      .byte.b	32	;R (36)
    301  7d2a		       20		      .byte.b	32	;G
    302  7d2b		       00		      .byte.b	0	;B
    303  7d2c		       40		      .byte.b	64	;R (35)
    304  7d2d		       40		      .byte.b	64	;G
    305  7d2e		       00		      .byte.b	0	;B
    306  7d2f		       c0		      .byte.b	192	;R (34)
    307  7d30		       c0		      .byte.b	192	;G
    308  7d31		       00		      .byte.b	0	;B
    309  7d32		       40		      .byte.b	64	;R (33)
    310  7d33		       00		      .byte.b	0	;G
    311  7d34		       00		      .byte.b	0	;B
    312  7d35		       40		      .byte.b	64	;R (32)
    313  7d36		       40		      .byte.b	64	;G
    314  7d37		       00		      .byte.b	0	;B
    315  7d38		       00		      .byte.b	0	;R (31)
    316  7d39		       00		      .byte.b	0	;G
    317  7d3a		       00		      .byte.b	0	;B
    318  7d3b		       80		      .byte.b	128	;R (30)
    319  7d3c		       80		      .byte.b	128	;G
    320  7d3d		       00		      .byte.b	0	;B
    321  7d3e		       c0		      .byte.b	192	;R (29)
    322  7d3f		       40		      .byte.b	64	;G
    323  7d40		       00		      .byte.b	0	;B
    324  7d41		       c0		      .byte.b	192	;R (28)
    325  7d42		       c0		      .byte.b	192	;G
    326  7d43		       00		      .byte.b	0	;B
    327  7d44		       40		      .byte.b	64	;R (27)
    328  7d45		       40		      .byte.b	64	;G
    329  7d46		       00		      .byte.b	0	;B
    330  7d47		       00		      .byte.b	0	;R (26)
    331  7d48		       00		      .byte.b	0	;G
    332  7d49		       00		      .byte.b	0	;B
    333  7d4a		       00		      .byte.b	0	;R (25)
    334  7d4b		       00		      .byte.b	0	;G
    335  7d4c		       00		      .byte.b	0	;B
    336  7d4d		       60		      .byte.b	96	;R (24)
    337  7d4e		       20		      .byte.b	32	;G
    338  7d4f		       00		      .byte.b	0	;B
    339  7d50		       60		      .byte.b	96	;R (23)
    340  7d51		       60		      .byte.b	96	;G
    341  7d52		       00		      .byte.b	0	;B
    342  7d53		       00		      .byte.b	0	;R (22)
    343  7d54		       00		      .byte.b	0	;G
    344  7d55		       00		      .byte.b	0	;B
    345  7d56		       a0		      .byte.b	160	;R (21)
    346  7d57		       a0		      .byte.b	160	;G
    347  7d58		       00		      .byte.b	0	;B
    348  7d59		       70		      .byte.b	112	;R (20)
    349  7d5a		       50		      .byte.b	80	;G
    350  7d5b		       00		      .byte.b	0	;B
    351  7d5c		       c0		      .byte.b	192	;R (19)
    352  7d5d		       c0		      .byte.b	192	;G
    353  7d5e		       00		      .byte.b	0	;B
    354  7d5f		       80		      .byte.b	128	;R (18)
    355  7d60		       80		      .byte.b	128	;G
    356  7d61		       00		      .byte.b	0	;B
    357  7d62		       4c		      .byte.b	76	;R (17)
    358  7d63		       4c		      .byte.b	76	;G
    359  7d64		       00		      .byte.b	0	;B
    360  7d65		       5c		      .byte.b	92	;R (16)
    361  7d66		       1c		      .byte.b	28	;G
    362  7d67		       00		      .byte.b	0	;B
    363  7d68		       60		      .byte.b	96	;R (15)
    364  7d69		       60		      .byte.b	96	;G
    365  7d6a		       00		      .byte.b	0	;B
    366  7d6b		       60		      .byte.b	96	;R (14)
    367  7d6c		       20		      .byte.b	32	;G
    368  7d6d		       00		      .byte.b	0	;B
    369  7d6e		       50		      .byte.b	80	;R (13)
    370  7d6f		       50		      .byte.b	80	;G
    371  7d70		       06		      .byte.b	6	;B
    372  7d71		       40		      .byte.b	64	;R (12)
    373  7d72		       40		      .byte.b	64	;G
    374  7d73		       08		      .byte.b	8	;B
    375  7d74		       00		      .byte.b	0	;R (11)
    376  7d75		       00		      .byte.b	0	;G
    377  7d76		       08		      .byte.b	8	;B
    378  7d77		       00		      .byte.b	0	;R (10)
    379  7d78		       00		      .byte.b	0	;G
    380  7d79		       08		      .byte.b	8	;B
    381  7d7a		       00		      .byte.b	0	;R (9)
    382  7d7b		       00		      .byte.b	0	;G
    383  7d7c		       08		      .byte.b	8	;B
    384  7d7d		       00		      .byte.b	0	;R (8)
    385  7d7e		       00		      .byte.b	0	;G
    386  7d7f		       06		      .byte.b	6	;B
    387  7d80		       00		      .byte.b	0	;R (7)
    388  7d81		       00		      .byte.b	0	;G
    389  7d82		       00		      .byte.b	0	;B
    390  7d83		       00		      .byte.b	0	;R (6)
    391  7d84		       00		      .byte.b	0	;G
    392  7d85		       00		      .byte.b	0	;B
    393  7d86		       00		      .byte.b	0	;R (5)
    394  7d87		       00		      .byte.b	0	;G
    395  7d88		       00		      .byte.b	0	;B
    396  7d89		       00		      .byte.b	0	;R (4)
    397  7d8a		       00		      .byte.b	0	;G
    398  7d8b		       00		      .byte.b	0	;B
    399  7d8c		       00		      .byte.b	0	;R (3)
    400  7d8d		       00		      .byte.b	0	;G
    401  7d8e		       00		      .byte.b	0	;B
    402  7d8f		       00		      .byte.b	0	;R (2)
    403  7d90		       00		      .byte.b	0	;G
    404  7d91		       00		      .byte.b	0	;B
    405  7d92		       00		      .byte.b	0	;R (1)
    406  7d93		       00		      .byte.b	0	;G
    407  7d94		       00		      .byte.b	0	;B
    408  7d95		       00		      .byte.b	0	;R (0)
    409  7d96		       00		      .byte.b	0	;G
    410  7d97		       00		      .byte.b	0	;B
    411  7d98				   COL_2
    412  7d98		       f0		      .byte.b	240	;R (67)
    413  7d99		       f0		      .byte.b	240	;G
    414  7d9a		       00		      .byte.b	0	;B
    415  7d9b		       7f		      .byte.b	127	;R (66)
    416  7d9c		       21		      .byte.b	33	;G
    417  7d9d		       00		      .byte.b	0	;B
    418  7d9e		       00		      .byte.b	0	;R (65)
    419  7d9f		       00		      .byte.b	0	;G
    420  7da0		       a8		      .byte.b	168	;B
    421  7da1		       00		      .byte.b	0	;R (64)
    422  7da2		       00		      .byte.b	0	;G
    423  7da3		       ab		      .byte.b	171	;B
    424  7da4		       00		      .byte.b	0	;R (63)
    425  7da5		       00		      .byte.b	0	;G
    426  7da6		       b8		      .byte.b	184	;B
    427  7da7		       00		      .byte.b	0	;R (62)
    428  7da8		       00		      .byte.b	0	;G
    429  7da9		       a8		      .byte.b	168	;B
    430  7daa		       00		      .byte.b	0	;R (61)
    431  7dab		       00		      .byte.b	0	;G
    432  7dac		       a8		      .byte.b	168	;B
    433  7dad		       00		      .byte.b	0	;R (60)
    434  7dae		       00		      .byte.b	0	;G
    435  7daf		       03		      .byte.b	3	;B
    436  7db0		       01		      .byte.b	1	;R (59)
    437  7db1		       01		      .byte.b	1	;G
    438  7db2		       00		      .byte.b	0	;B
    439  7db3		       89		      .byte.b	137	;R (58)
    440  7db4		       89		      .byte.b	137	;G
    441  7db5		       00		      .byte.b	0	;B
    442  7db6		       fd		      .byte.b	253	;R (57)
    443  7db7		       00		      .byte.b	0	;G
    444  7db8		       00		      .byte.b	0	;B
    445  7db9		       fd		      .byte.b	253	;R (56)
    446  7dba		       00		      .byte.b	0	;G
    447  7dbb		       00		      .byte.b	0	;B
    448  7dbc		       fd		      .byte.b	253	;R (55)
    449  7dbd		       00		      .byte.b	0	;G
    450  7dbe		       00		      .byte.b	0	;B
    451  7dbf		       fd		      .byte.b	253	;R (54)
    452  7dc0		       00		      .byte.b	0	;G
    453  7dc1		       00		      .byte.b	0	;B
    454  7dc2		       fd		      .byte.b	253	;R (53)
    455  7dc3		       01		      .byte.b	1	;G
    456  7dc4		       00		      .byte.b	0	;B
    457  7dc5		       fe		      .byte.b	254	;R (52)
    458  7dc6		       06		      .byte.b	6	;G
    459  7dc7		       00		      .byte.b	0	;B
    460  7dc8		       f9		      .byte.b	249	;R (51)
    461  7dc9		       09		      .byte.b	9	;G
    462  7dca		       00		      .byte.b	0	;B
    463  7dcb		       f8		      .byte.b	248	;R (50)
    464  7dcc		       08		      .byte.b	8	;G
    465  7dcd		       00		      .byte.b	0	;B
    466  7dce		       f8		      .byte.b	248	;R (49)
    467  7dcf		       00		      .byte.b	0	;G
    468  7dd0		       00		      .byte.b	0	;B
    469  7dd1		       f8		      .byte.b	248	;R (48)
    470  7dd2		       00		      .byte.b	0	;G
    471  7dd3		       00		      .byte.b	0	;B
    472  7dd4		       fc		      .byte.b	252	;R (47)
    473  7dd5		       04		      .byte.b	4	;G
    474  7dd6		       00		      .byte.b	0	;B
    475  7dd7		       fc		      .byte.b	252	;R (46)
    476  7dd8		       04		      .byte.b	4	;G
    477  7dd9		       00		      .byte.b	0	;B
    478  7dda		       fc		      .byte.b	252	;R (45)
    479  7ddb		       04		      .byte.b	4	;G
    480  7ddc		       00		      .byte.b	0	;B
    481  7ddd		       fc		      .byte.b	252	;R (44)
    482  7dde		       84		      .byte.b	132	;G
    483  7ddf		       00		      .byte.b	0	;B
    484  7de0		       fc		      .byte.b	252	;R (43)
    485  7de1		       00		      .byte.b	0	;G
    486  7de2		       00		      .byte.b	0	;B
    487  7de3		       fc		      .byte.b	252	;R (42)
    488  7de4		       00		      .byte.b	0	;G
    489  7de5		       00		      .byte.b	0	;B
    490  7de6		       fc		      .byte.b	252	;R (41)
    491  7de7		       00		      .byte.b	0	;G
    492  7de8		       00		      .byte.b	0	;B
    493  7de9		       fc		      .byte.b	252	;R (40)
    494  7dea		       04		      .byte.b	4	;G
    495  7deb		       00		      .byte.b	0	;B
    496  7dec		       f8		      .byte.b	248	;R (39)
    497  7ded		       00		      .byte.b	0	;G
    498  7dee		       00		      .byte.b	0	;B
    499  7def		       f8		      .byte.b	248	;R (38)
    500  7df0		       00		      .byte.b	0	;G
    501  7df1		       00		      .byte.b	0	;B
    502  7df2		       f8		      .byte.b	248	;R (37)
    503  7df3		       08		      .byte.b	8	;G
    504  7df4		       00		      .byte.b	0	;B
    505  7df5		       f0		      .byte.b	240	;R (36)
    506  7df6		       00		      .byte.b	0	;G
    507  7df7		       00		      .byte.b	0	;B
    508  7df8		       e0		      .byte.b	224	;R (35)
    509  7df9		       20		      .byte.b	32	;G
    510  7dfa		       00		      .byte.b	0	;B
    511  7dfb		       c0		      .byte.b	192	;R (34)
    512  7dfc		       40		      .byte.b	64	;G
    513  7dfd		       00		      .byte.b	0	;B
    514  7dfe		       00		      .byte.b	0	;R (33)
    515  7dff		       00		      .byte.b	0	;G
    516  7e00		       80		      .byte.b	128	;B
    517  7e01		       02		      .byte.b	2	;R (32)
    518  7e02		       02		      .byte.b	2	;G
    519  7e03		       00		      .byte.b	0	;B
    520  7e04		       67		      .byte.b	103	;R (31)
    521  7e05		       07		      .byte.b	7	;G
    522  7e06		       10		      .byte.b	16	;B
    523  7e07		       7f		      .byte.b	127	;R (30)
    524  7e08		       0a		      .byte.b	10	;G
    525  7e09		       80		      .byte.b	128	;B
    526  7e0a		       ff		      .byte.b	255	;R (29)
    527  7e0b		       20		      .byte.b	32	;G
    528  7e0c		       00		      .byte.b	0	;B
    529  7e0d		       ff		      .byte.b	255	;R (28)
    530  7e0e		       12		      .byte.b	18	;G
    531  7e0f		       00		      .byte.b	0	;B
    532  7e10		       ff		      .byte.b	255	;R (27)
    533  7e11		       44		      .byte.b	68	;G
    534  7e12		       00		      .byte.b	0	;B
    535  7e13		       fc		      .byte.b	252	;R (26)
    536  7e14		       20		      .byte.b	32	;G
    537  7e15		       00		      .byte.b	0	;B
    538  7e16		       f8		      .byte.b	248	;R (25)
    539  7e17		       e8		      .byte.b	232	;G
    540  7e18		       00		      .byte.b	0	;B
    541  7e19		       b0		      .byte.b	176	;R (24)
    542  7e1a		       a0		      .byte.b	160	;G
    543  7e1b		       00		      .byte.b	0	;B
    544  7e1c		       40		      .byte.b	64	;R (23)
    545  7e1d		       40		      .byte.b	64	;G
    546  7e1e		       80		      .byte.b	128	;B
    547  7e1f		       e0		      .byte.b	224	;R (22)
    548  7e20		       00		      .byte.b	0	;G
    549  7e21		       00		      .byte.b	0	;B
    550  7e22		       b0		      .byte.b	176	;R (21)
    551  7e23		       10		      .byte.b	16	;G
    552  7e24		       40		      .byte.b	64	;B
    553  7e25		       e0		      .byte.b	224	;R (20)
    554  7e26		       20		      .byte.b	32	;G
    555  7e27		       00		      .byte.b	0	;B
    556  7e28		       c0		      .byte.b	192	;R (19)
    557  7e29		       c0		      .byte.b	192	;G
    558  7e2a		       00		      .byte.b	0	;B
    559  7e2b		       80		      .byte.b	128	;R (18)
    560  7e2c		       00		      .byte.b	0	;G
    561  7e2d		       00		      .byte.b	0	;B
    562  7e2e		       c0		      .byte.b	192	;R (17)
    563  7e2f		       c0		      .byte.b	192	;G
    564  7e30		       00		      .byte.b	0	;B
    565  7e31		       00		      .byte.b	0	;R (16)
    566  7e32		       00		      .byte.b	0	;G
    567  7e33		       00		      .byte.b	0	;B
    568  7e34		       00		      .byte.b	0	;R (15)
    569  7e35		       00		      .byte.b	0	;G
    570  7e36		       00		      .byte.b	0	;B
    571  7e37		       00		      .byte.b	0	;R (14)
    572  7e38		       00		      .byte.b	0	;G
    573  7e39		       00		      .byte.b	0	;B
    574  7e3a		       00		      .byte.b	0	;R (13)
    575  7e3b		       00		      .byte.b	0	;G
    576  7e3c		       00		      .byte.b	0	;B
    577  7e3d		       00		      .byte.b	0	;R (12)
    578  7e3e		       00		      .byte.b	0	;G
    579  7e3f		       00		      .byte.b	0	;B
    580  7e40		       00		      .byte.b	0	;R (11)
    581  7e41		       00		      .byte.b	0	;G
    582  7e42		       00		      .byte.b	0	;B
    583  7e43		       00		      .byte.b	0	;R (10)
    584  7e44		       00		      .byte.b	0	;G
    585  7e45		       07		      .byte.b	7	;B
    586  7e46		       00		      .byte.b	0	;R (9)
    587  7e47		       00		      .byte.b	0	;G
    588  7e48		       05		      .byte.b	5	;B
    589  7e49		       00		      .byte.b	0	;R (8)
    590  7e4a		       00		      .byte.b	0	;G
    591  7e4b		       55		      .byte.b	85	;B
    592  7e4c		       00		      .byte.b	0	;R (7)
    593  7e4d		       00		      .byte.b	0	;G
    594  7e4e		       55		      .byte.b	85	;B
    595  7e4f		       00		      .byte.b	0	;R (6)
    596  7e50		       00		      .byte.b	0	;G
    597  7e51		       35		      .byte.b	53	;B
    598  7e52		       00		      .byte.b	0	;R (5)
    599  7e53		       00		      .byte.b	0	;G
    600  7e54		       57		      .byte.b	87	;B
    601  7e55		       00		      .byte.b	0	;R (4)
    602  7e56		       00		      .byte.b	0	;G
    603  7e57		       50		      .byte.b	80	;B
    604  7e58		       00		      .byte.b	0	;R (3)
    605  7e59		       00		      .byte.b	0	;G
    606  7e5a		       30		      .byte.b	48	;B
    607  7e5b		       00		      .byte.b	0	;R (2)
    608  7e5c		       00		      .byte.b	0	;G
    609  7e5d		       00		      .byte.b	0	;B
    610  7e5e		       00		      .byte.b	0	;R (1)
    611  7e5f		       00		      .byte.b	0	;G
    612  7e60		       00		      .byte.b	0	;B
    613  7e61		       00		      .byte.b	0	;R (0)
    614  7e62		       00		      .byte.b	0	;G
    615  7e63		       00		      .byte.b	0	;B
    616  7e64				   COL_3
    617  7e64		       80		      .byte.b	128	;R (67)
    618  7e65		       80		      .byte.b	128	;G
    619  7e66		       00		      .byte.b	0	;B
    620  7e67		       78		      .byte.b	120	;R (66)
    621  7e68		       10		      .byte.b	16	;G
    622  7e69		       00		      .byte.b	0	;B
    623  7e6a		       02		      .byte.b	2	;R (65)
    624  7e6b		       02		      .byte.b	2	;G
    625  7e6c		       c0		      .byte.b	192	;B
    626  7e6d		       03		      .byte.b	3	;R (64)
    627  7e6e		       00		      .byte.b	0	;G
    628  7e6f		       5c		      .byte.b	92	;B
    629  7e70		       01		      .byte.b	1	;R (63)
    630  7e71		       00		      .byte.b	0	;G
    631  7e72		       c4		      .byte.b	196	;B
    632  7e73		       01		      .byte.b	1	;R (62)
    633  7e74		       00		      .byte.b	0	;G
    634  7e75		       1c		      .byte.b	28	;B
    635  7e76		       01		      .byte.b	1	;R (61)
    636  7e77		       00		      .byte.b	0	;G
    637  7e78		       d0		      .byte.b	208	;B
    638  7e79		       01		      .byte.b	1	;R (60)
    639  7e7a		       00		      .byte.b	0	;G
    640  7e7b		       1c		      .byte.b	28	;B
    641  7e7c		       01		      .byte.b	1	;R (59)
    642  7e7d		       00		      .byte.b	0	;G
    643  7e7e		       00		      .byte.b	0	;B
    644  7e7f		       1f		      .byte.b	31	;R (58)
    645  7e80		       1f		      .byte.b	31	;G
    646  7e81		       00		      .byte.b	0	;B
    647  7e82		       df		      .byte.b	223	;R (57)
    648  7e83		       53		      .byte.b	83	;G
    649  7e84		       00		      .byte.b	0	;B
    650  7e85		       df		      .byte.b	223	;R (56)
    651  7e86		       14		      .byte.b	20	;G
    652  7e87		       00		      .byte.b	0	;B
    653  7e88		       df		      .byte.b	223	;R (55)
    654  7e89		       13		      .byte.b	19	;G
    655  7e8a		       00		      .byte.b	0	;B
    656  7e8b		       df		      .byte.b	223	;R (54)
    657  7e8c		       1f		      .byte.b	31	;G
    658  7e8d		       00		      .byte.b	0	;B
    659  7e8e		       cf		      .byte.b	207	;R (53)
    660  7e8f		       4e		      .byte.b	78	;G
    661  7e90		       00		      .byte.b	0	;B
    662  7e91		       ef		      .byte.b	239	;R (52)
    663  7e92		       6f		      .byte.b	111	;G
    664  7e93		       00		      .byte.b	0	;B
    665  7e94		       90		      .byte.b	144	;R (51)
    666  7e95		       10		      .byte.b	16	;G
    667  7e96		       00		      .byte.b	0	;B
    668  7e97		       88		      .byte.b	136	;R (50)
    669  7e98		       88		      .byte.b	136	;G
    670  7e99		       00		      .byte.b	0	;B
    671  7e9a		       01		      .byte.b	1	;R (49)
    672  7e9b		       01		      .byte.b	1	;G
    673  7e9c		       00		      .byte.b	0	;B
    674  7e9d		       03		      .byte.b	3	;R (48)
    675  7e9e		       03		      .byte.b	3	;G
    676  7e9f		       00		      .byte.b	0	;B
    677  7ea0		       09		      .byte.b	9	;R (47)
    678  7ea1		       09		      .byte.b	9	;G
    679  7ea2		       00		      .byte.b	0	;B
    680  7ea3		       08		      .byte.b	8	;R (46)
    681  7ea4		       08		      .byte.b	8	;G
    682  7ea5		       00		      .byte.b	0	;B
    683  7ea6		       0c		      .byte.b	12	;R (45)
    684  7ea7		       0c		      .byte.b	12	;G
    685  7ea8		       00		      .byte.b	0	;B
    686  7ea9		       05		      .byte.b	5	;R (44)
    687  7eaa		       05		      .byte.b	5	;G
    688  7eab		       00		      .byte.b	0	;B
    689  7eac		       01		      .byte.b	1	;R (43)
    690  7ead		       00		      .byte.b	0	;G
    691  7eae		       00		      .byte.b	0	;B
    692  7eaf		       01		      .byte.b	1	;R (42)
    693  7eb0		       00		      .byte.b	0	;G
    694  7eb1		       00		      .byte.b	0	;B
    695  7eb2		       01		      .byte.b	1	;R (41)
    696  7eb3		       00		      .byte.b	0	;G
    697  7eb4		       00		      .byte.b	0	;B
    698  7eb5		       81		      .byte.b	129	;R (40)
    699  7eb6		       81		      .byte.b	129	;G
    700  7eb7		       00		      .byte.b	0	;B
    701  7eb8		       c0		      .byte.b	192	;R (39)
    702  7eb9		       40		      .byte.b	64	;G
    703  7eba		       00		      .byte.b	0	;B
    704  7ebb		       c0		      .byte.b	192	;R (38)
    705  7ebc		       00		      .byte.b	0	;G
    706  7ebd		       00		      .byte.b	0	;B
    707  7ebe		       e0		      .byte.b	224	;R (37)
    708  7ebf		       20		      .byte.b	32	;G
    709  7ec0		       00		      .byte.b	0	;B
    710  7ec1		       e0		      .byte.b	224	;R (36)
    711  7ec2		       00		      .byte.b	0	;G
    712  7ec3		       00		      .byte.b	0	;B
    713  7ec4		       f0		      .byte.b	240	;R (35)
    714  7ec5		       10		      .byte.b	16	;G
    715  7ec6		       00		      .byte.b	0	;B
    716  7ec7		       f0		      .byte.b	240	;R (34)
    717  7ec8		       00		      .byte.b	0	;G
    718  7ec9		       00		      .byte.b	0	;B
    719  7eca		       f8		      .byte.b	248	;R (33)
    720  7ecb		       08		      .byte.b	8	;G
    721  7ecc		       00		      .byte.b	0	;B
    722  7ecd		       f8		      .byte.b	248	;R (32)
    723  7ece		       08		      .byte.b	8	;G
    724  7ecf		       00		      .byte.b	0	;B
    725  7ed0		       f0		      .byte.b	240	;R (31)
    726  7ed1		       80		      .byte.b	128	;G
    727  7ed2		       00		      .byte.b	0	;B
    728  7ed3		       f0		      .byte.b	240	;R (30)
    729  7ed4		       00		      .byte.b	0	;G
    730  7ed5		       00		      .byte.b	0	;B
    731  7ed6		       f8		      .byte.b	248	;R (29)
    732  7ed7		       88		      .byte.b	136	;G
    733  7ed8		       00		      .byte.b	0	;B
    734  7ed9		       f8		      .byte.b	248	;R (28)
    735  7eda		       08		      .byte.b	8	;G
    736  7edb		       00		      .byte.b	0	;B
    737  7edc		       f8		      .byte.b	248	;R (27)
    738  7edd		       08		      .byte.b	8	;G
    739  7ede		       00		      .byte.b	0	;B
    740  7edf		       f8		      .byte.b	248	;R (26)
    741  7ee0		       88		      .byte.b	136	;G
    742  7ee1		       00		      .byte.b	0	;B
    743  7ee2		       f8		      .byte.b	248	;R (25)
    744  7ee3		       08		      .byte.b	8	;G
    745  7ee4		       00		      .byte.b	0	;B
    746  7ee5		       f8		      .byte.b	248	;R (24)
    747  7ee6		       08		      .byte.b	8	;G
    748  7ee7		       00		      .byte.b	0	;B
    749  7ee8		       f8		      .byte.b	248	;R (23)
    750  7ee9		       08		      .byte.b	8	;G
    751  7eea		       00		      .byte.b	0	;B
    752  7eeb		       f0		      .byte.b	240	;R (22)
    753  7eec		       00		      .byte.b	0	;G
    754  7eed		       00		      .byte.b	0	;B
    755  7eee		       f0		      .byte.b	240	;R (21)
    756  7eef		       10		      .byte.b	16	;G
    757  7ef0		       00		      .byte.b	0	;B
    758  7ef1		       e0		      .byte.b	224	;R (20)
    759  7ef2		       20		      .byte.b	32	;G
    760  7ef3		       00		      .byte.b	0	;B
    761  7ef4		       c0		      .byte.b	192	;R (19)
    762  7ef5		       00		      .byte.b	0	;G
    763  7ef6		       00		      .byte.b	0	;B
    764  7ef7		       c0		      .byte.b	192	;R (18)
    765  7ef8		       40		      .byte.b	64	;G
    766  7ef9		       00		      .byte.b	0	;B
    767  7efa		       83		      .byte.b	131	;R (17)
    768  7efb		       83		      .byte.b	131	;G
    769  7efc		       00		      .byte.b	0	;B
    770  7efd		       03		      .byte.b	3	;R (16)
    771  7efe		       03		      .byte.b	3	;G
    772  7eff		       00		      .byte.b	0	;B
    773  7f00		       01		      .byte.b	1	;R (15)
    774  7f01		       01		      .byte.b	1	;G
    775  7f02		       00		      .byte.b	0	;B
    776  7f03		       00		      .byte.b	0	;R (14)
    777  7f04		       00		      .byte.b	0	;G
    778  7f05		       00		      .byte.b	0	;B
    779  7f06		       00		      .byte.b	0	;R (13)
    780  7f07		       00		      .byte.b	0	;G
    781  7f08		       0a		      .byte.b	10	;B
    782  7f09		       00		      .byte.b	0	;R (12)
    783  7f0a		       00		      .byte.b	0	;G
    784  7f0b		       0a		      .byte.b	10	;B
    785  7f0c		       00		      .byte.b	0	;R (11)
    786  7f0d		       00		      .byte.b	0	;G
    787  7f0e		       0e		      .byte.b	14	;B
    788  7f0f		       00		      .byte.b	0	;R (10)
    789  7f10		       00		      .byte.b	0	;G
    790  7f11		       aa		      .byte.b	170	;B
    791  7f12		       00		      .byte.b	0	;R (9)
    792  7f13		       00		      .byte.b	0	;G
    793  7f14		       ae		      .byte.b	174	;B
    794  7f15		       00		      .byte.b	0	;R (8)
    795  7f16		       00		      .byte.b	0	;G
    796  7f17		       a4		      .byte.b	164	;B
    797  7f18		       00		      .byte.b	0	;R (7)
    798  7f19		       00		      .byte.b	0	;G
    799  7f1a		       a0		      .byte.b	160	;B
    800  7f1b		       00		      .byte.b	0	;R (6)
    801  7f1c		       00		      .byte.b	0	;G
    802  7f1d		       a0		      .byte.b	160	;B
    803  7f1e		       00		      .byte.b	0	;R (5)
    804  7f1f		       00		      .byte.b	0	;G
    805  7f20		       c0		      .byte.b	192	;B
    806  7f21		       00		      .byte.b	0	;R (4)
    807  7f22		       00		      .byte.b	0	;G
    808  7f23		       00		      .byte.b	0	;B
    809  7f24		       00		      .byte.b	0	;R (3)
    810  7f25		       00		      .byte.b	0	;G
    811  7f26		       00		      .byte.b	0	;B
    812  7f27		       00		      .byte.b	0	;R (2)
    813  7f28		       00		      .byte.b	0	;G
    814  7f29		       00		      .byte.b	0	;B
    815  7f2a		       00		      .byte.b	0	;R (1)
    816  7f2b		       00		      .byte.b	0	;G
    817  7f2c		       00		      .byte.b	0	;B
    818  7f2d		       00		      .byte.b	0	;R (0)
    819  7f2e		       00		      .byte.b	0	;G
    820  7f2f		       00		      .byte.b	0	;B
    821  7f30				   COL_4
    822  7f30		       00		      .byte.b	0	;R (67)
    823  7f31		       00		      .byte.b	0	;G
    824  7f32		       00		      .byte.b	0	;B
    825  7f33		       00		      .byte.b	0	;R (66)
    826  7f34		       00		      .byte.b	0	;G
    827  7f35		       00		      .byte.b	0	;B
    828  7f36		       00		      .byte.b	0	;R (65)
    829  7f37		       00		      .byte.b	0	;G
    830  7f38		       00		      .byte.b	0	;B
    831  7f39		       01		      .byte.b	1	;R (64)
    832  7f3a		       01		      .byte.b	1	;G
    833  7f3b		       00		      .byte.b	0	;B
    834  7f3c		       03		      .byte.b	3	;R (63)
    835  7f3d		       02		      .byte.b	2	;G
    836  7f3e		       00		      .byte.b	0	;B
    837  7f3f		       03		      .byte.b	3	;R (62)
    838  7f40		       03		      .byte.b	3	;G
    839  7f41		       00		      .byte.b	0	;B
    840  7f42		       03		      .byte.b	3	;R (61)
    841  7f43		       02		      .byte.b	2	;G
    842  7f44		       00		      .byte.b	0	;B
    843  7f45		       03		      .byte.b	3	;R (60)
    844  7f46		       03		      .byte.b	3	;G
    845  7f47		       00		      .byte.b	0	;B
    846  7f48		       03		      .byte.b	3	;R (59)
    847  7f49		       02		      .byte.b	2	;G
    848  7f4a		       00		      .byte.b	0	;B
    849  7f4b		       03		      .byte.b	3	;R (58)
    850  7f4c		       03		      .byte.b	3	;G
    851  7f4d		       00		      .byte.b	0	;B
    852  7f4e		       03		      .byte.b	3	;R (57)
    853  7f4f		       03		      .byte.b	3	;G
    854  7f50		       00		      .byte.b	0	;B
    855  7f51		       0d		      .byte.b	13	;R (56)
    856  7f52		       0d		      .byte.b	13	;G
    857  7f53		       00		      .byte.b	0	;B
    858  7f54		       1f		      .byte.b	31	;R (55)
    859  7f55		       0b		      .byte.b	11	;G
    860  7f56		       00		      .byte.b	0	;B
    861  7f57		       3f		      .byte.b	63	;R (54)
    862  7f58		       25		      .byte.b	37	;G
    863  7f59		       00		      .byte.b	0	;B
    864  7f5a		       3f		      .byte.b	63	;R (53)
    865  7f5b		       30		      .byte.b	48	;G
    866  7f5c		       00		      .byte.b	0	;B
    867  7f5d		       21		      .byte.b	33	;R (52)
    868  7f5e		       21		      .byte.b	33	;G
    869  7f5f		       00		      .byte.b	0	;B
    870  7f60		       00		      .byte.b	0	;R (51)
    871  7f61		       00		      .byte.b	0	;G
    872  7f62		       00		      .byte.b	0	;B
    873  7f63		       00		      .byte.b	0	;R (50)
    874  7f64		       00		      .byte.b	0	;G
    875  7f65		       00		      .byte.b	0	;B
    876  7f66		       01		      .byte.b	1	;R (49)
    877  7f67		       01		      .byte.b	1	;G
    878  7f68		       00		      .byte.b	0	;B
    879  7f69		       03		      .byte.b	3	;R (48)
    880  7f6a		       02		      .byte.b	2	;G
    881  7f6b		       00		      .byte.b	0	;B
    882  7f6c		       07		      .byte.b	7	;R (47)
    883  7f6d		       07		      .byte.b	7	;G
    884  7f6e		       00		      .byte.b	0	;B
    885  7f6f		       00		      .byte.b	0	;R (46)
    886  7f70		       00		      .byte.b	0	;G
    887  7f71		       00		      .byte.b	0	;B
    888  7f72		       00		      .byte.b	0	;R (45)
    889  7f73		       00		      .byte.b	0	;G
    890  7f74		       00		      .byte.b	0	;B
    891  7f75		       06		      .byte.b	6	;R (44)
    892  7f76		       06		      .byte.b	6	;G
    893  7f77		       00		      .byte.b	0	;B
    894  7f78		       0c		      .byte.b	12	;R (43)
    895  7f79		       04		      .byte.b	4	;G
    896  7f7a		       00		      .byte.b	0	;B
    897  7f7b		       1c		      .byte.b	28	;R (42)
    898  7f7c		       1c		      .byte.b	28	;G
    899  7f7d		       00		      .byte.b	0	;B
    900  7f7e		       38		      .byte.b	56	;R (41)
    901  7f7f		       38		      .byte.b	56	;G
    902  7f80		       00		      .byte.b	0	;B
    903  7f81		       00		      .byte.b	0	;R (40)
    904  7f82		       00		      .byte.b	0	;G
    905  7f83		       00		      .byte.b	0	;B
    906  7f84		       0a		      .byte.b	10	;R (39)
    907  7f85		       0a		      .byte.b	10	;G
    908  7f86		       00		      .byte.b	0	;B
    909  7f87		       02		      .byte.b	2	;R (38)
    910  7f88		       00		      .byte.b	0	;G
    911  7f89		       00		      .byte.b	0	;B
    912  7f8a		       32		      .byte.b	50	;R (37)
    913  7f8b		       30		      .byte.b	48	;G
    914  7f8c		       00		      .byte.b	0	;B
    915  7f8d		       72		      .byte.b	114	;R (36)
    916  7f8e		       72		      .byte.b	114	;G
    917  7f8f		       00		      .byte.b	0	;B
    918  7f90		       74		      .byte.b	116	;R (35)
    919  7f91		       54		      .byte.b	84	;G
    920  7f92		       00		      .byte.b	0	;B
    921  7f93		       54		      .byte.b	84	;R (34)
    922  7f94		       10		      .byte.b	16	;G
    923  7f95		       00		      .byte.b	0	;B
    924  7f96		       04		      .byte.b	4	;R (33)
    925  7f97		       00		      .byte.b	0	;G
    926  7f98		       00		      .byte.b	0	;B
    927  7f99		       02		      .byte.b	2	;R (32)
    928  7f9a		       02		      .byte.b	2	;G
    929  7f9b		       00		      .byte.b	0	;B
    930  7f9c		       10		      .byte.b	16	;R (31)
    931  7f9d		       10		      .byte.b	16	;G
    932  7f9e		       00		      .byte.b	0	;B
    933  7f9f		       68		      .byte.b	104	;R (30)
    934  7fa0		       68		      .byte.b	104	;G
    935  7fa1		       00		      .byte.b	0	;B
    936  7fa2		       6c		      .byte.b	108	;R (29)
    937  7fa3		       24		      .byte.b	36	;G
    938  7fa4		       00		      .byte.b	0	;B
    939  7fa5		       4c		      .byte.b	76	;R (28)
    940  7fa6		       08		      .byte.b	8	;G
    941  7fa7		       00		      .byte.b	0	;B
    942  7fa8		       d4		      .byte.b	212	;R (27)
    943  7fa9		       d4		      .byte.b	212	;G
    944  7faa		       00		      .byte.b	0	;B
    945  7fab		       00		      .byte.b	0	;R (26)
    946  7fac		       00		      .byte.b	0	;G
    947  7fad		       00		      .byte.b	0	;B
    948  7fae		       2c		      .byte.b	44	;R (25)
    949  7faf		       2c		      .byte.b	44	;G
    950  7fb0		       00		      .byte.b	0	;B
    951  7fb1		       36		      .byte.b	54	;R (24)
    952  7fb2		       16		      .byte.b	22	;G
    953  7fb3		       00		      .byte.b	0	;B
    954  7fb4		       2e		      .byte.b	46	;R (23)
    955  7fb5		       0e		      .byte.b	14	;G
    956  7fb6		       00		      .byte.b	0	;B
    957  7fb7		       60		      .byte.b	96	;R (22)
    958  7fb8		       40		      .byte.b	64	;G
    959  7fb9		       00		      .byte.b	0	;B
    960  7fba		       28		      .byte.b	40	;R (21)
    961  7fbb		       28		      .byte.b	40	;G
    962  7fbc		       00		      .byte.b	0	;B
    963  7fbd		       0f		      .byte.b	15	;R (20)
    964  7fbe		       0d		      .byte.b	13	;G
    965  7fbf		       00		      .byte.b	0	;B
    966  7fc0		       1a		      .byte.b	26	;R (19)
    967  7fc1		       1a		      .byte.b	26	;G
    968  7fc2		       00		      .byte.b	0	;B
    969  7fc3		       18		      .byte.b	24	;R (18)
    970  7fc4		       08		      .byte.b	8	;G
    971  7fc5		       00		      .byte.b	0	;B
    972  7fc6		       14		      .byte.b	20	;R (17)
    973  7fc7		       04		      .byte.b	4	;G
    974  7fc8		       00		      .byte.b	0	;B
    975  7fc9		       16		      .byte.b	22	;R (16)
    976  7fca		       16		      .byte.b	22	;G
    977  7fcb		       00		      .byte.b	0	;B
    978  7fcc		       04		      .byte.b	4	;R (15)
    979  7fcd		       00		      .byte.b	0	;G
    980  7fce		       00		      .byte.b	0	;B
    981  7fcf		       06		      .byte.b	6	;R (14)
    982  7fd0		       02		      .byte.b	2	;G
    983  7fd1		       00		      .byte.b	0	;B
    984  7fd2		       05		      .byte.b	5	;R (13)
    985  7fd3		       05		      .byte.b	5	;G
    986  7fd4		       00		      .byte.b	0	;B
    987  7fd5		       05		      .byte.b	5	;R (12)
    988  7fd6		       05		      .byte.b	5	;G
    989  7fd7		       00		      .byte.b	0	;B
    990  7fd8		       00		      .byte.b	0	;R (11)
    991  7fd9		       00		      .byte.b	0	;G
    992  7fda		       00		      .byte.b	0	;B
    993  7fdb		       00		      .byte.b	0	;R (10)
    994  7fdc		       00		      .byte.b	0	;G
    995  7fdd		       00		      .byte.b	0	;B
    996  7fde		       00		      .byte.b	0	;R (9)
    997  7fdf		       00		      .byte.b	0	;G
    998  7fe0		       00		      .byte.b	0	;B
    999  7fe1		       00		      .byte.b	0	;R (8)
   1000  7fe2		       00		      .byte.b	0	;G
   1001  7fe3		       00		      .byte.b	0	;B
   1002  7fe4		       00		      .byte.b	0	;R (7)
   1003  7fe5		       00		      .byte.b	0	;G
   1004  7fe6		       00		      .byte.b	0	;B
   1005  7fe7		       00		      .byte.b	0	;R (6)
   1006  7fe8		       00		      .byte.b	0	;G
   1007  7fe9		       00		      .byte.b	0	;B
   1008  7fea		       00		      .byte.b	0	;R (5)
   1009  7feb		       00		      .byte.b	0	;G
   1010  7fec		       00		      .byte.b	0	;B
   1011  7fed		       00		      .byte.b	0	;R (4)
   1012  7fee		       00		      .byte.b	0	;G
   1013  7fef		       00		      .byte.b	0	;B
   1014  7ff0		       00		      .byte.b	0	;R (3)
   1015  7ff1		       00		      .byte.b	0	;G
   1016  7ff2		       00		      .byte.b	0	;B
   1017  7ff3		       00		      .byte.b	0	;R (2)
   1018  7ff4		       00		      .byte.b	0	;G
   1019  7ff5		       00		      .byte.b	0	;B
   1020  7ff6		       00		      .byte.b	0	;R (1)
   1021  7ff7		       00		      .byte.b	0	;G
   1022  7ff8		       00		      .byte.b	0	;B
   1023  7ff9		       00		      .byte.b	0	;R (0)
   1024  7ffa		       00		      .byte.b	0	;G
   1025  7ffb		       00		      .byte.b	0	;B
------- FILE TitleScreen@2.asm
      6  7ffc
      0  7ffc					      END_BANK
      1  7ffc				  -	      IF	_CURRENT_BANK_TYPE = _TYPE_RAM
      2  7ffc				  -	      CHECK_RAM_BANK_SIZE
      3  7ffc					      ELSE
      0  7ffc					      CHECK_BANK_SIZE
      1  7ffc		       03 fc	   .TEMP      =	* - _BANK_START
 ROM bank # 32 TITLEDATA2 size = $3fc free = 3
      2  7ffc					      ECHO	"ROM bank #", [_ORIGIN/_ROM_BANK_SIZE]d, _LAST_BANK, "size =", .TEMP, "free =", [_ROM_BANK_SIZE - .TEMP - 1]d
      3  7ffc				  -	      IF	( .TEMP ) > _ROM_BANK_SIZE
      4  7ffc				  -	      ECHO	"BANK OVERFLOW @", _LAST_BANK, " size=", * - _ORIGIN
      5  7ffc				  -	      ERR
      6  7ffc					      ENDIF
      5  7ffc					      ENDIF
------- FILE ./chess.asm
    219  7ffc
    220  7ffc
    221  7ffc
    222  8000		       00 00 00 00	      ALIGN	_ROM_BANK_SIZE
    223  8000
 32 ROM BANKS
    224  8000					      ECHO	[_ORIGIN/_ROM_BANK_SIZE]d, "ROM BANKS"
 24 RAM BANKS
    225  8000					      ECHO	[ORIGIN_RAM / _RAM_BANK_SIZE]d, "RAM BANKS"
    226  8000
    227  8000							;---------------------------------------------------------------------------------------------------
    228  8000							;EOF
