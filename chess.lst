------- FILE ./chess.asm LEVEL 1 PASS 5
      1  10000 ????						; Chess
      2  10000 ????						; Atari 2600 Chess display system
      3  10000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  10000 ????						; andrew@taswegian.com
      5  10000 ????
      6  10000 ????
      7  10000 ????		00 40	    TIA_BASE_ADDRESS =	$40
      8  10000 ????
      9  10000 ????				       processor	6502
------- FILE vcs.h LEVEL 2 PASS 5
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; This file defines hardware registers and memory mapping for the
      7  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  10000 ????						; available at at http://www.atari2600.org/dasm
     10  10000 ????						;
     11  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  10000 ????						; with your views.  Please contribute, if you think you can improve this
     15  10000 ????						; file!
     16  10000 ????						;
     17  10000 ????						; Latest Revisions...
     18  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  10000 ????						;			    This will allow conditional code to verify VCS.H being
     21  10000 ????						;			    used for code assembly.
     22  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  10000 ????						;			 mirrored reading/writing differences.	This is more a
     25  10000 ????						;			 readability issue, and binary compatibility with disassembled
     26  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  10000 ????						;			 which was broken by the use of segments in this file, as
     29  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  10000 ????						;						   it is safe to leave it undefined, and the base address will
     34  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  10000 ????						;			  - register definitions are now generated through assignment
     37  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  10000 ????						;			    address architecture.
     39  10000 ????						; 1.0	22/MAR/2003		Initial release
     40  10000 ????
     41  10000 ????
     42  10000 ????						;-------------------------------------------------------------------------------
     43  10000 ????
     44  10000 ????						; TIA_BASE_ADDRESS
     45  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  10000 ????						; Normally 0, the base address should (externally, before including this file)
     47  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  10000 ????						; < $40 as a bankswitch.
     50  10000 ????
     51  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     52  10000 ????			   -TIA_BASE_ADDRESS =	0
     53  10000 ????				       ENDIF
     54  10000 ????
     55  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  10000 ????						; *OR* by declaring the label before including this file, eg:
     58  10000 ????						; TIA_BASE_ADDRESS = $40
     59  10000 ????						;   include "vcs.h"
     60  10000 ????
     61  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  10000 ????						; for the mirrored ROM hardware registers.
     64  10000 ????
     65  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  10000 ????
     69  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     70  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  10000 ????				       ENDIF
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????						;-------------------------------------------------------------------------------
     78  10000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE macro.h LEVEL 2 PASS 5
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./chess.asm
------- FILE piece_defines.h LEVEL 2 PASS 5
      0  0000 ????				      include	"piece_defines.h"
      1  0000 ????						; Copyright (C)2020 Andrew Davie
      2  0000 ????
      3  0000 ????	       00 80	   BLACK      =	128
      4  0000 ????	       00 00	   WHITE      =	0
      5  0000 ????
      6  0000 ????	       00 80	   FLAG_COLOUR =	128	; mask
      7  0000 ????	       00 40	   FLAG_MOVED =	64	; mark ALL pieces when moved. Used for castling
      8  0000 ????						; but maybe useful for evaluation of development
      9  0000 ????	       00 20	   FLAG_ENPASSANT =	32
     10  0000 ????	       00 10	   FLAG_CASTLE =	16
     11  0000 ????
     12  0000 ????						;---------------------------------------------------------------------------------------------------
     13  0000 ????						; DEFINE THE PIECES
     14  0000 ????						; ID lives in bits 0-2
     15  0000 ????
     16  0000 ????	       00 00	   BLANK      =	0
     17  0000 ????	       00 00	   ███  =	BLANK
     18  0000 ????
     19  0000 ????	       00 01	   WPAWN      =	1
     20  0000 ????	       00 01	   WP	      =	WPAWN
     21  0000 ????	       00 02	   BPAWN      =	2
     22  0000 ????	       00 02	   BP	      =	BPAWN
     23  0000 ????	       00 03	   KNIGHT     =	3
     24  0000 ????	       00 03	   N	      =	KNIGHT
     25  0000 ????	       00 04	   BISHOP     =	4
     26  0000 ????	       00 04	   B	      =	BISHOP
     27  0000 ????	       00 05	   ROOK       =	5
     28  0000 ????	       00 05	   R	      =	ROOK
     29  0000 ????	       00 06	   QUEEN      =	6
     30  0000 ????	       00 06	   Q	      =	QUEEN
     31  0000 ????	       00 07	   KING       =	7
     32  0000 ????	       00 07	   K	      =	KING
     33  0000 ????
     34  0000 ????	       00 0f	   PIECE_MASK =	15	; trim off the flags leaving just piece ID
     35  0000 ????
     36  0000 ????						;---------------------------------------------------------------------------------------------------
     37  0000 ????
     38  0000 ????						; Movements
     39  0000 ????
     40  0000 ????	       00 0a	   _UP	      =	10	; up
     41  0000 ????	       ff ff ff ff _LEFT      =	-1	; left
     42  0000 ????	       ff ff ff f6 _DOWN      =	-10	; down
     43  0000 ????	       00 01	   _RIGHT     =	1	; right
     44  0000 ????
     45  0000 ????						; EOF
------- FILE ./chess.asm
     13  0000 ????
     14  0000 ????	       00 00	   VERBOSE    =	0	; set to 1 for compile messages
     15  0000 ????
     16  0000 ????			   ORIGIN     SET	0
     17  0000 ????			   ORIGIN_RAM SET	0
     18  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 5
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						; Pathways
     94  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
     95  0000 ????						; if QuickDraw does immediate exit, 58✅
     96  0000 ????
     97  0000 ????						;---------------------------------------------------------------------------------------------------
     98  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,22	;18 ;12	  ;NFI
      1  0000 ????			   SEGTIME_MAN SET	22
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./chess.asm
     20  0000 ????
     21  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     22  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     23  0000 ????						;FIXED_BANK		 = 15 * 2048	       ; ->> 32K
     24  0000 ????	       f8 00	   FIXED_BANK =	31 * 2048	; ->> 64K
     25  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     26  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     27  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     28  0000 ????
     29  0000 ????	       00 01	   YES	      =	1
     30  0000 ????	       00 00	   NO	      =	0
     31  0000 ????
     32  0000 ????	       70 00	   INFINITY   =	$7000	;32767
     33  0000 ????
     34  0000 ????
     35  0000 ????						; assemble diagnostics. Remove for release.
     36  0000 ????
     37  0000 ????	       00 00	   TEST_POSITION =	0	; 0=normal, 1 = setup test position
     38  0000 ????	       00 00	   DIAGNOSTICS =	0
     39  0000 ????	       00 01	   QUIESCENCE =	1
     40  0000 ????	       00 00	   ASSERTS    =	0
     41  0000 ????	       00 00	   PVSP       =	0	; player versus player =1
     42  0000 ????	       00 01	   ENPASSANT_ENABLED =	1
     43  0000 ????	       00 01	   CASTLING_ENABLED =	1
     44  0000 ????
     45  0000 ????	       00 05	   SEARCH_DEPTH =	5
     46  0000 ????	       00 08	   QUIESCE_EXTRA_DEPTH =	8
     47  0000 ????
     48  0000 ????
     49  0000 ????
     50  0000 ????	       00 0d	   PLY_BANKS  =	SEARCH_DEPTH + QUIESCE_EXTRA_DEPTH
     51  0000 ????	       00 17	   MAX_PLY_DEPTH_BANK =	RAMBANK_PLY + PLY_BANKS
     52  0000 ????
     53  0000 ????			  -	      IF	MAX_PLY_DEPTH_BANK > 31
     54  0000 ????			  -	      ERR	"Not enough RAM for PLY banks"
     55  0000 ????				      ENDIF
     56  0000 ????
     57  0000 ????
     58  0000 ????
     59  0000 ????
     60  0000 ????	       00 81	   SWAP_SIDE  =	128 + (RAMBANK_PLY ^ (RAMBANK_PLY+1))
     61  0000 ????
     62  0000 ????
     63  0000 ????
     64  0000 ????						; DELAYS
     65  0000 ????
     66  0000 ????	       00 0a	   READY_TO_MOVE_FLASH =	10
     67  0000 ????
     68  0000 ????						;===================================
     69  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     70  0000 ????						;===================================
     71  0000 ????
     72  0000 ????						;-------------------------------------------------------------------------------
     73  0000 ????						; The following are optional YES/NO depending on phase of the moon
     74  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     75  0000 ????						;-------------------------------------------------------------------------------
     76  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     77  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     78  0000 ????			  -	      IF	FINAL_VERSION = YES
     79  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     80  0000 ????				      ENDIF
     81  0000 ????
     82  0000 ????						;-------------------------------------------------------------------------------
     83  0000 ????
     84  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     85  0000 ????
     86  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     87  0000 ????
     88  0000 ????						;------------------------------------------------------------------------------
     89  0000 ????
     90  0000 ????	       00 01	   PLUSCART   =	YES
     91  0000 ????
     92  0000 ????						;------------------------------------------------------------------------------
     93  0000 ????
     94  0000 ????
     95  0000 ????	       00 08	   CHESSBOARD_ROWS =	8	; number of ROWS of chessboard
     96  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
     97  0000 ????	       00 48	   PIECE_SHAPE_SIZE =	72	; 3 PF bytes x 24 scanlines
     98  0000 ????
     99  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    100  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    101  0000 ????
    102  0000 ????
    103  0000 ????	       10 00	   RAM_3E     =	$1000
    104  0000 ????	       04 00	   RAM_SIZE   =	$400
    105  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    106  0000 ????	       04 00	   RAM	      =	RAM_WRITE
    107  0000 ????
    108  0000 ????
    109  0000 ????
    110  0000 ????						; Platform constants:
    111  0000 ????	       00 02	   PAL	      =	%10
    112  0000 ????	       00 02	   PAL_50     =	PAL|0
    113  0000 ????	       00 03	   PAL_60     =	PAL|1
    114  0000 ????
    115  0000 ????
    116  0000 ????				      IF	L276
    117  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    118  0000 ????			  -	      ELSE
    119  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    120  0000 ????				      ENDIF
    121  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    122  0000 ????
    123  0000 ????				      IF	L276
    124  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    125  0000 ????			  -	      ELSE
    126  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    127  0000 ????				      ENDIF
    128  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    129  0000 ????
    130  0000 ????				      IF	L276
    131  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    132  0000 ????			  -	      ELSE
    133  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    134  0000 ????				      ENDIF
    135  0000 ????	       01 38	   SCANLINES_PAL =	312
    136  0000 ????
    137  0000 ????
    138  0000 ????	       00 2e	   TIME_PART_2 =	46
    139  0000 ????	       00 2e	   TIME_PART_1 =	46
    140  0000 ????
    141  0000 ????
    142  0000 ????						;------------------------------------------------------------------------------
    143  0000 ????						; MACRO definitions
    144  0000 ????
    145  0000 ????
    146  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    147  0000 ????
    148  0000 ????				      MAC	newbank
    149  0000 ????				      SEG	{1}
    150  0000 ????				      ORG	ORIGIN
    151  0000 ????				      RORG	$F000
    152  0000 ????			   BANK_START SET	*
    153  0000 ????			   {1}	      SET	ORIGIN / 2048
    154  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    155  0000 ????			   _CURRENT_BANK SET	{1}
    156  0000 ????				      ENDM		; bank name
    157  0000 ????
    158  0000 ????				      MAC	define_1k_segment
    159  0000 ????				      ALIGN	$400
    160  0000 ????			   SEGMENT_{1} SET	*
    161  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    162  0000 ????				      ENDM		; {seg name}
    163  0000 ????
    164  0000 ????				      MAC	check_bank_size
    165  0000 ????			   .TEMP      =	* - BANK_START
    166  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    167  0000 ????				      IF	( .TEMP ) > ROM_BANK_SIZE
    168  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    169  0000 ????				      ERR
    170  0000 ????				      ENDIF
    171  0000 ????
    172  0000 ????				      ENDM		; name
    173  0000 ????
    174  0000 ????
    175  0000 ????				      MAC	check_half_bank_size
    176  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    177  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    178  0000 ????			   .TEMP      =	* - BANK_START
    179  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    180  0000 ????				      IF	( .TEMP ) > ROM_BANK_SIZE/2
    181  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    182  0000 ????				      ERR
    183  0000 ????				      ENDIF
    184  0000 ????				      ENDM		; name
    185  0000 ????
    186  0000 ????
    187  0000 ????						;---------------------------------------------------------------------------------------------------
    188  0000 ????
    189  0000 ????						; Macro inserts a page break if the object would overlap a page
    190  0000 ????
    191  0000 ????				      MAC	optional_pagebreak
    192  0000 ????				      LIST	OFF
    193  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    194  0000 ????			   EARLY_LOCATION SET	*
    195  0000 ????				      ALIGN	256
    196  0000 ????				      IF	VERBOSE=1
    197  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR", {1}
    198  0000 ????				      ECHO	"REQUESTED SIZE =", {2}
    199  0000 ????				      ECHO	"WASTED SPACE =", *-EARLY_LOCATION
    200  0000 ????				      ECHO	"PAGEBREAK LOCATION =", *
    201  0000 ????				      ENDIF
    202  0000 ????				      ENDIF
    203  0000 ????				      LIST	ON
    204  0000 ????				      ENDM		; { string, size }
    205  0000 ????
    206  0000 ????
    207  0000 ????				      MAC	check_page_crossing
    208  0000 ????				      LIST	OFF
    209  0000 ????				      IF	( >BLOCK_END != >BLOCK_START )
    210  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    211  0000 ????				      ENDIF
    212  0000 ????				      LIST	ON
    213  0000 ????				      ENDM
    214  0000 ????
    215  0000 ????				      MAC	checkpage
    216  0000 ????				      LIST	OFF
    217  0000 ????				      IF	>. != >{1}
    218  0000 ????				      ECHO	""
    219  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    220  0000 ????				      ECHO	""
    221  0000 ????				      ERR
    222  0000 ????				      ENDIF
    223  0000 ????				      LIST	ON
    224  0000 ????				      ENDM
    225  0000 ????
    226  0000 ????				      MAC	checkpagex
    227  0000 ????				      LIST	OFF
    228  0000 ????				      IF	>. != >{1}
    229  0000 ????				      ECHO	""
    230  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    231  0000 ????				      ECHO	{2}
    232  0000 ????				      ECHO	""
    233  0000 ????				      ERR
    234  0000 ????				      ENDIF
    235  0000 ????				      LIST	ON
    236  0000 ????				      ENDM
    237  0000 ????
    238  0000 ????						;---------------------------------------------------------------------------------------------------
    239  0000 ????
    240  0000 ????						; Defines a variable of the given size, making sure it doesn't cross a page
    241  0000 ????				      MAC	variable
    242  0000 ????				      OPTIONAL_PAGEBREAK	"Variable", {2}
    243  0000 ????			   {1}	      ds	{2}
    244  0000 ????				      ENDM		; {name, size}
    245  0000 ????
    246  0000 ????
    247  0000 ????						;---------------------------------------------------------------------------------------------------
    248  0000 ????
    249  0000 ????				      MAC	def
    250  0000 ????			   BANK_{1}   SET	_CURRENT_BANK	; bank in which this subroutine resides
    251  0000 ????			   {1}			; entry point
    252  0000 ????			   TEMPORARY_VAR SET	Overlay
    253  0000 ????			   TEMPORARY_OFFSET SET	0
    254  0000 ????			   VAR_BOUNDARY_{1} SET	TEMPORARY_OFFSET
    255  0000 ????			   FUNCTION_NAME SET	{1}
    256  0000 ????				      SUBROUTINE
    257  0000 ????				      ENDM		; name of subroutine
    258  0000 ????
    259  0000 ????
    260  0000 ????						;---------------------------------------------------------------------------------------------------
    261  0000 ????
    262  0000 ????				      MAC	allocate
    263  0000 ????				      OPTIONAL_PAGEBREAK	"Table", {2}
    264  0000 ????				      DEF	{1}
    265  0000 ????				      ENDM
    266  0000 ????
    267  0000 ????
    268  0000 ????						;---------------------------------------------------------------------------------------------------
    269  0000 ????
    270  0000 ????				      MAC	negeval
    271  0000 ????
    272  0000 ????				      sec
    273  0000 ????				      lda	#0
    274  0000 ????				      sbc	Evaluation
    275  0000 ????				      sta	Evaluation
    276  0000 ????				      lda	#0
    277  0000 ????				      sbc	Evaluation+1
    278  0000 ????				      sta	Evaluation+1
    279  0000 ????				      ENDM
    280  0000 ????
    281  0000 ????
    282  0000 ????				      MAC	swap
    283  0000 ????				      lda	sideToMove
    284  0000 ????				      eor	#SWAP_SIDE
    285  0000 ????				      sta	sideToMove
    286  0000 ????				      ENDM
    287  0000 ????
    288  0000 ????
    289  0000 ????						;---------------------------------------------------------------------------------------------------
    290  0000 ????
    291  0000 ????			   TEMPORARY_OFFSET SET	0
    292  0000 ????
    293  0000 ????
    294  0000 ????				      MAC	vend
    295  0000 ????				      IFNCONST	{1}
    296  0000 ????				      ECHO	"Incorrect VEND label", {1}
    297  0000 ????				      ERR
    298  0000 ????				      ENDIF
    299  0000 ????			   VAREND_{1} =	TEMPORARY_VAR
    300  0000 ????				      ENDM		; {1}
    301  0000 ????
    302  0000 ????
    303  0000 ????				      MAC	refer
    304  0000 ????				      IF	VAREND_{1} > TEMPORARY_VAR
    305  0000 ????			   TEMPORARY_VAR SET	VAREND_{1}
    306  0000 ????				      ENDIF
    307  0000 ????				      ENDM		; {1}
    308  0000 ????
    309  0000 ????
    310  0000 ????
    311  0000 ????						; Define a temporary variable for use in a subroutine
    312  0000 ????						; Will allocate appropriate bytes, and also check for overflow of the available overlay buffer
    313  0000 ????
    314  0000 ????				      MAC	var
    315  0000 ????			   {1}	      =	TEMPORARY_VAR
    316  0000 ????			   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + {2}
    317  0000 ????
    318  0000 ????			   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
    319  0000 ????				      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
    320  0000 ????			   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
    321  0000 ????				      ENDIF
    322  0000 ????				      IF	OVERLAY_DELTA > OVERLAY_SIZE
    323  0000 ????				      ECHO	"Temporary Variable", {1}, "overflow!"
    324  0000 ????				      ERR
    325  0000 ????				      ENDIF
    326  0000 ????				      LIST	ON
    327  0000 ????				      ENDM		; { name, size }
    328  0000 ????
    329  0000 ????
    330  0000 ????						;---------------------------------------------------------------------------------------------------
    331  0000 ????
    332  0000 ????				      MAC	tag
    333  0000 ????						; {0}
    334  0000 ????				      ENDM		; {ident/tag}
    335  0000 ????
    336  0000 ????						;---------------------------------------------------------------------------------------------------
    337  0000 ????
    338  0000 ????				      MAC	sta@ram
    339  0000 ????				      sta	[RAM]+{0}
    340  0000 ????				      ENDM		;{}
    341  0000 ????
    342  0000 ????				      MAC	stx@ram
    343  0000 ????				      stx	[RAM]+{0}
    344  0000 ????				      ENDM
    345  0000 ????
    346  0000 ????				      MAC	sty@ram
    347  0000 ????				      sty	[RAM]+{0}
    348  0000 ????				      ENDM
    349  0000 ????
    350  0000 ????				      MAC	sta@ply
    351  0000 ????				      sta	[RAM]+{0}
    352  0000 ????				      ENDM		;{}
    353  0000 ????
    354  0000 ????				      MAC	stx@ply
    355  0000 ????				      stx	[RAM]+{0}
    356  0000 ????				      ENDM
    357  0000 ????
    358  0000 ????				      MAC	sty@ply
    359  0000 ????				      sty	[RAM]+{0}
    360  0000 ????				      ENDM
    361  0000 ????
    362  0000 ????
    363  0000 ????				      MAC	lda@ram
    364  0000 ????				      lda	{0}
    365  0000 ????				      ENDM		;{}
    366  0000 ????
    367  0000 ????				      MAC	ldx@ram
    368  0000 ????				      ldx	{0}
    369  0000 ????				      ENDM		;{}
    370  0000 ????
    371  0000 ????				      MAC	ldy@ram
    372  0000 ????				      ldy	{0}
    373  0000 ????				      ENDM		;{}
    374  0000 ????
    375  0000 ????
    376  0000 ????				      MAC	lda@ply
    377  0000 ????				      lda	{0}
    378  0000 ????				      ENDM		;{}
    379  0000 ????
    380  0000 ????				      MAC	ldx@ply
    381  0000 ????				      ldx	{0}
    382  0000 ????				      ENDM		;{}
    383  0000 ????
    384  0000 ????				      MAC	ldy@ply
    385  0000 ????				      ldy	{0}
    386  0000 ????				      ENDM		;{}
    387  0000 ????
    388  0000 ????
    389  0000 ????				      MAC	adc@ply
    390  0000 ????				      adc	{0}
    391  0000 ????				      ENDM		;{}
    392  0000 ????
    393  0000 ????				      MAC	sbc@ply
    394  0000 ????				      sbc	{0}
    395  0000 ????				      ENDM		;{}
    396  0000 ????
    397  0000 ????				      MAC	cmp@ply
    398  0000 ????				      cmp	{0}
    399  0000 ????				      ENDM		;{}
    400  0000 ????
    401  0000 ????						;---------------------------------------------------------------------------------------------------
    402  0000 ????
    403  0000 ????				      MAC	newrambank
    404  0000 ????						; {1}	     bank name
    405  0000 ????						; {2}	     RAM bank number
    406  0000 ????
    407  0000 ????				      SEG.U	{1}
    408  0000 ????				      ORG	ORIGIN_RAM
    409  0000 ????				      RORG	RAM_3E
    410  0000 ????			   BANK_START SET	*
    411  0000 ????			   RAMBANK_{1} SET	ORIGIN_RAM / RAM_SIZE
    412  0000 ????			   _CURRENT_RAMBANK SET	RAMBANK_{1}
    413  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    414  0000 ????				      ENDM		; bank name
    415  0000 ????
    416  0000 ????						; TODO - fix - this is faulty....
    417  0000 ????				      MAC	validate_ram_size
    418  0000 ????			   .RAM_BANK_SIZE SET	* - RAM_3E
    419  0000 ????				      IF	.RAM_BANK_SIZE > RAM_SIZE
    420  0000 ????				      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
    421  0000 ????				      ERR
    422  0000 ????				      ENDIF
    423  0000 ????				      ENDM
    424  0000 ????
    425  0000 ????						;---------------------------------------------------------------------------------------------------
    426  0000 ????
    427  0000 ????				      MAC	resync
    428  0000 ????						; resync screen, X and Y == 0 afterwards
    429  0000 ????				      lda	#%10	; make sure VBLANK is ON
    430  0000 ????				      sta	VBLANK
    431  0000 ????
    432  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    433  0000 ????			   .loopResync
    434  0000 ????				      VERTICAL_SYNC
    435  0000 ????
    436  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    437  0000 ????				      lda	Platform
    438  0000 ????				      eor	#PAL_50	; PAL-50?
    439  0000 ????				      bne	.ntsc
    440  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    441  0000 ????			   .ntsc
    442  0000 ????			   .loopWait
    443  0000 ????				      sta	WSYNC
    444  0000 ????				      sta	WSYNC
    445  0000 ????				      dey
    446  0000 ????				      bne	.loopWait
    447  0000 ????				      dex
    448  0000 ????				      bne	.loopResync
    449  0000 ????				      ENDM
    450  0000 ????
    451  0000 ????				      MAC	set_platform
    452  0000 ????						; 00 = NTSC
    453  0000 ????						; 01 = NTSC
    454  0000 ????						; 10 = PAL-50
    455  0000 ????						; 11 = PAL-60
    456  0000 ????				      lda	SWCHB
    457  0000 ????				      rol
    458  0000 ????				      rol
    459  0000 ????				      rol
    460  0000 ????				      and	#%11
    461  0000 ????				      eor	#PAL
    462  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    463  0000 ????				      ENDM
    464  0000 ????
    465  0000 ????
    466  0000 ????						;---------------------------------------------------------------------------------------------------
    467  0000 ????
    468  0000 ????				      MAC	jsrom_safe
    469  0000 ????						; Saves bank of routine to variable for later restore.
    470  0000 ????						; Switches to the bank and does a JSR to the routine.
    471  0000 ????
    472  0000 ????				      lda	#BANK_{1}
    473  0000 ????				      sta	savedBank
    474  0000 ????				      sta	SET_BANK
    475  0000 ????				      jsr	{1}
    476  0000 ????				      ENDM		; {routine}
    477  0000 ????
    478  0000 ????
    479  0000 ????				      MAC	jsrom
    480  0000 ????
    481  0000 ????				      lda	#BANK_{1}
    482  0000 ????				      sta	SET_BANK
    483  0000 ????				      jsr	{1}
    484  0000 ????				      ENDM		; {routine}
    485  0000 ????
    486  0000 ????
    487  0000 ????				      MAC	jsram
    488  0000 ????				      lda	#BANK_{1}
    489  0000 ????				      sta	SET_BANK_RAM
    490  0000 ????				      jsr	{1}
    491  0000 ????				      ENDM
    492  0000 ????
    493  0000 ????
    494  0000 ????
    495  0000 ????				      MAC	timecheck
    496  0000 ????				      lda	INTIM
    497  0000 ????				      cmp	#SPEEDOF_{1}
    498  0000 ????				      bcc	{2}
    499  0000 ????				      ENDM		; {ident}, {branch if out of time}
    500  0000 ????
    501  0000 ????
    502  0000 ????				      MAC	timing
    503  0000 ????			   SPEEDOF_{1} =	({2}/64) + 1
    504  0000 ????				      ENDM		; {label}, {cycles}
    505  0000 ????
    506  0000 ????
    507  0000 ????						;---------------------------------------------------------------------------------------------------
    508  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 5
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						; Chess
      2  0000 ????						; Atari 2600 Chess display system
      3  0000 ????						; Copyright (c) 2019-2020 Andrew Davie
      4  0000 ????						; andrew@taswegian.com
      5  0000 ????
      6 U00fa ????				      SEG.U	variables
      7 U0080					      ORG	$80
      8 U0080
      9 U0080		       00	   squareToDraw ds	1
     10 U0081		       00	   rnd	      ds	1	; random
     11 U0082		       00	   drawDelay  ds	1
     12 U0083		       00	   lastSquareX12 ds	1
     13 U0084
     14 U0084		       00	   drawCount  ds	1
     15 U0085		       00	   fromX12    ds	1
     16 U0086		       00	   toX12      ds	1
     17 U0087		       00	   originX12  ds	1
     18 U0088
     19 U0088		       00	   cursorX12  ds	1
     20 U0089
     21 U0089		       00	   mdelay     ds	1
     22 U008a		       00	   ccur       ds	1
     23 U008b		       00	   savedBank  ds	1	; switched-in bank for FIXED returns
     24 U008c		       00	   aiState    ds	1	; state
     25 U008d		       00	   aiFlashDelay ds	1
     26 U008e
     27 U008e		       00	   aiMoveIndex ds	1
     28 U008f
     29 U008f		       00	   aiFlashPhase ds	1
     30 U0090
     31 U0090		       00 00	   Evaluation ds	2	; tracks value of the board position
     32 U0092
     33 U0092		       00	   currentPiece ds	1
     34 U0093		       00	   currentSquare ds	1
     35 U0094		       00	   enPassantPawn ds	1	; TODO - this belongs in PLY bank
     36 U0095		       00	   currentPly ds	1
     37 U0096
     38 U0096		       00	   sideToMove ds	1	; d7 == side, 0=white, 128 = black
     39 U0097		       00	   fromPiece  ds	1
     40 U0098		       00	   lastPiece  ds	1
     41 U0099		       00	   previousPiece ds	1
     42 U009a
     43 U009a		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     44 U009b		       00 00	   speech_addr ds	2
     45 U009d		       00	   bg	      ds	1
     46 U009e
     47 U009e		       00	   capture    ds	1
     48 U009f
     49 U009f				  -	      IF	DIAGNOSTICS
     50 U009f				  -positionCount ds	3
     51 U009f					      ENDIF
     52 U009f
     53 U009f							;maxPly			  ds 1
     54 U009f		       00	   flagCheck  ds	1	; -1 = no, #KING = yes
     55 U00a0		       00	   protecting ds	1
     56 U00a1		       00	   randomness ds	1
------- FILE ./chess.asm
------- FILE overlays.asm LEVEL 2 PASS 5
      0 U00a2					      include	"overlays.asm"
      1 U00a2							; Chess
      2 U00a2							; Atari 2600 Chess display system
      3 U00a2							; Copyright (c) 2019-2020 Andrew Davie
      4 U00a2							; andrew@taswegian.com
      5 U00a2
      6 U00a2							;---------------------------------------------------------------------------------------------------
      7 U00a2							; OVERLAYS!
      8 U00a2							; These variables are overlays, and should be managed with care
      9 U00a2							; They co-exist (each "OVERLAY" starts at the zero-page variable "Overlay"
     10 U00a2							; and thus, overlays cannot be used at the same time (that is, you cannot
     11 U00a2							; use a variable in overlay #1 while at the same time using a variable in
     12 U00a2							; overlay #2
     13 U00a2
     14 U00a2							; for clarity, prefix ALL overlay variables with double-underscore (__)
     15 U00a2
     16 U00a2							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
     17 U00a2							; ensure this by using the VALIDATE_OVERLAY macro
     18 U00a2							;---------------------------------------------------------------------------------------------------
     19 U00a2
     20 U00a2					      MAC	overlay
     21 U00a2				   OVERLAY_NAME SET	{1}
     22 U00a2					      SEG.U	OVERLAY_{1}
     23 U00a2					      org	Overlay
     24 U00a2					      ENDM		; {name}
     25 U00a2
     26 U00a2							;---------------------------------------------------------------------------------------------------
     27 U00a2
     28 U00a2					      MAC	validate_overlay
     29 U00a2					      LIST	OFF
     30 U00a2				   OVERLAY_DELTA SET	* - Overlay
     31 U00a2					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
     32 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
     33 U00a2					      ENDIF
     34 U00a2					      IF	OVERLAY_DELTA > OVERLAY_SIZE
     35 U00a2					      ECHO	"Overlay", OVERLAY_NAME, "is too big!"
     36 U00a2					      ECHO	"REQUIRED SIZE =", OVERLAY_DELTA
     37 U00a2					      ERR
     38 U00a2					      ENDIF
     39 U00a2					      LIST	ON
     40 U00a2					      ECHO	OVERLAY_NAME, "-", OVERLAY_SIZE - ( * - Overlay ), "bytes available"
     41 U00a2					      ENDM
     42 U00a2
     43 U00a2							;---------------------------------------------------------------------------------------------------
     44 U00a2
     45 U00a2				   OVERLAY_SIZE SET	$4C	; maximum size
     46 U00a2				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	0
     47 U00a2
     48 U00a2
     49 U00a2							; This overlay variable is used for the overlay variables.  That's OK.
     50 U00a2							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
     51 U00a2							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
     52 U00a2							; (especially the latter ones) are only used in rare occasions.
     53 U00a2
     54 U00a2							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
     55 U00a2							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
     56 U00a2
      0 U00a2					      DEF	Overlay
      1 U00a2				   BANK_Overlay SET	_CURRENT_BANK
      2 U00a2				   Overlay
      3 U00a2				   TEMPORARY_VAR SET	Overlay
      4 U00a2				   TEMPORARY_OFFSET SET	0
      5 U00a2				   VAR_BOUNDARY_Overlay SET	TEMPORARY_OFFSET
      6 U00a2				   FUNCTION_NAME SET	Overlay
      7 U00a2					      SUBROUTINE
     58 U00a2		       00 00 00 00*	      ds	OVERLAY_SIZE	;--> overlay (share) variables
     59 U00ee				   END_OF_OVERLAY
     60 U00ee
     61 U00ee							;---------------------------------------------------------------------------------------------------
     62 U00ee							; And now... the overlays....
     63 U00ee
 ---- OVERLAYS ( $4c bytes ) ----
     64 U00ee					      ECHO	"---- OVERLAYS (", OVERLAY_SIZE, "bytes ) ----"
     65 U00ee
     66 U00ee							;---------------------------------------------------------------------------------------------------
     67 U00ee
     68 U00ee							; Some overlays are used across multiple routines/calls, and they will need to be defined
     69 U00ee							; "globally" in this file.
     70 U00ee
      0 U00ee					      VAR	__pieceShapeBuffer, PIECE_SHAPE_SIZE
      1 U00ee		       00 a2	   __pieceShapeBuffer =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + PIECE_SHAPE_SIZE
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __pieceShapeBuffer, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr, 2
      1 U00ee		       00 ea	   __ptr      =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
      0 U00ee					      VAR	__ptr2, 2
      1 U00ee		       00 ec	   __ptr2     =	TEMPORARY_VAR
      2 U00ee				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3 U00ee
      4 U00ee				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5 U00ee					      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6 U00ee				   MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7 U00ee					      ENDIF
      8 U00ee				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9 U00ee				  -	      ECHO	"Temporary Variable", __ptr2, "overflow!"
     10 U00ee				  -	      ERR
     11 U00ee					      ENDIF
     12 U00ee					      LIST	ON
     74 U00ee
     75 U00ee							;---------------------------------------------------------------------------------------------------
     76 U00ee
     77 U00ee
     78 U00ee					      ORG	END_OF_OVERLAY
 ---- END OF OVERLAYS ----
     79 U00ee					      ECHO	"---- END OF OVERLAYS ----"
 MAXIMUM OVERLAY SIZE NEEDED =  $4c
     80 U00ee					      ECHO	"MAXIMUM OVERLAY SIZE NEEDED = ", MAXIMUM_REQUIRED_OVERLAY_SIZE
     81 U00ee
     82 U00ee							;EOF
------- FILE ./chess.asm
------- FILE stack.asm LEVEL 2 PASS 5
      0 U00ee					      include	"stack.asm"
      1 U00ee							; Chess
      2 U00ee							; Atari 2600 Chess display system
      3 U00ee							; Copyright (c) 2019-2020 Andrew Davie
      4 U00ee							; andrew@taswegian.com
      5 U00ee
      6 U00ee
      7 U00ee		       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
      8 U00ee
      9 U00ee		       00 00 00 00*	      ds	RESERVED_FOR_STACK
     10 U00fa
     11 U00fa							; WARNING/NOTE - the alphabeta search violates the above size constraints
     12 U00fa							; HOWEVER, the "OVERLAY" segment is beneath this, and will be stomped, depending on # plys
     13 U00fa							;  but since overlay is not generally stressed during alphabeta, we're good.
------- FILE ./chess.asm
    512 U00fa
 FREE BYTES IN ZERO PAGE =  $5
    513 U00fa					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    514 U00fa				  -	      IF	* > $FF
    515 U00fa				  -	      ERR	"Zero Page overflow!"
    516 U00fa					      ENDIF
    517 U00fa
    518 U00fa							;------------------------------------------------------------------------------
    519 U00fa							;##############################################################################
    520 U00fa							;------------------------------------------------------------------------------
    521 U00fa
    522 U00fa							; NOW THE VERY INTERESTING '3E' RAM BANKS
    523 U00fa							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 1k TOTAL ACCESSIBLE
    524 U00fa							; IN A 2K MEMORY SPACE
    525 U00fa
      0 U00fa					      NEWRAMBANK	CHESS_BOARD_ROW
      1 U00fa
      2 U00fa
      3 U00fa
      4 U0000 ????				      SEG.U	CHESS_BOARD_ROW
      5 U0000					      ORG	ORIGIN_RAM
      6 U0000					      RORG	RAM_3E
      7 U0000				   BANK_START SET	*
      8 U0000				   RAMBANK_CHESS_BOARD_ROW SET	ORIGIN_RAM / RAM_SIZE
      9 U0000				   _CURRENT_RAMBANK SET	RAMBANK_CHESS_BOARD_ROW
     10 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    527 U0000					      REPEAT	(CHESSBOARD_ROWS) - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U0000
      2 U0000
      3 U0000
      4 U1c00 ????				      SEG.U	.DUMMY
      5 U0400					      ORG	ORIGIN_RAM
      6 U0400					      RORG	RAM_3E
      7 U0400				   BANK_START SET	*
      8 U0400				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0400				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0400				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0400				  -	      ERR
      5 U0400					      ENDIF
    527 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400
      2 U0400
      3 U0400
      4 U0400					      SEG.U	.DUMMY
      5 U0800					      ORG	ORIGIN_RAM
      6 U0800					      RORG	RAM_3E
      7 U0800				   BANK_START SET	*
      8 U0800				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0800				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0800				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0800				  -	      ERR
      5 U0800					      ENDIF
    527 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800
      2 U0800
      3 U0800
      4 U0800					      SEG.U	.DUMMY
      5 U0c00					      ORG	ORIGIN_RAM
      6 U0c00					      RORG	RAM_3E
      7 U0c00				   BANK_START SET	*
      8 U0c00				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U0c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U0c00				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U0c00				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U0c00				  -	      ERR
      5 U0c00					      ENDIF
    527 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00
      2 U0c00
      3 U0c00
      4 U0c00					      SEG.U	.DUMMY
      5 U1000					      ORG	ORIGIN_RAM
      6 U1000					      RORG	RAM_3E
      7 U1000				   BANK_START SET	*
      8 U1000				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1000				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1000				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1000				  -	      ERR
      5 U1000					      ENDIF
    527 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000
      2 U1000
      3 U1000
      4 U1000					      SEG.U	.DUMMY
      5 U1400					      ORG	ORIGIN_RAM
      6 U1400					      RORG	RAM_3E
      7 U1400				   BANK_START SET	*
      8 U1400				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1400				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1400				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1400				  -	      ERR
      5 U1400					      ENDIF
    527 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400
      2 U1400
      3 U1400
      4 U1400					      SEG.U	.DUMMY
      5 U1800					      ORG	ORIGIN_RAM
      6 U1800					      RORG	RAM_3E
      7 U1800				   BANK_START SET	*
      8 U1800				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1800				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1800				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1800				  -	      ERR
      5 U1800					      ENDIF
    527 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800
      2 U1800
      3 U1800
      4 U1800					      SEG.U	.DUMMY
      5 U1c00					      ORG	ORIGIN_RAM
      6 U1c00					      RORG	RAM_3E
      7 U1c00				   BANK_START SET	*
      8 U1c00				   RAMBANK_.DUMMY SET	ORIGIN_RAM / RAM_SIZE
      9 U1c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY
     10 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				   .RAM_BANK_SIZE SET	* - RAM_3E
      2 U1c00				  -	      IF	.RAM_BANK_SIZE > RAM_SIZE
      3 U1c00				  -	      ECHO	"RAM BANK OVERFLOW @ ", (* - RAM_3E)
      4 U1c00				  -	      ERR
      5 U1c00					      ENDIF
    530 U1c00					      REPEND
    531 U1c00
    532 U1c00							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    533 U1c00							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    534 U1c00							; The variable definitions are also in that ROM bank (even though they're RAM :)
    535 U1c00
    536 U1c00							; A neat feature of having multiple copies of the same code in different RAM banks
    537 U1c00							; is that we can use that code to switch between banks, and the system will happily
    538 U1c00							; execute the next instruction from the newly switched-in bank without a problem.
    539 U1c00
    540 U1c00							; Now we have the actual graphics data for each of the rows.  This consists of an
    541 U1c00							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    542 U1c00							; character shapes are masked/copied. The depth of the character shapes may be
    543 U1c00							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    544 U1c00							; a multiple of 3, so that the RGB scanlines match at character joins.
    545 U1c00
    546 U1c00							; We have one bank for each chessboard row.  These banks are duplicates of the above,
    547 U1c00							; accessed via the above labels but with the appropriate bank switched in.
    548 U1c00
    549 U1c00							;------------------------------------------------------------------------------
    550 U1c00
    551 U1c00
    552 U1c00							;---------------------------------------------------------------------------------------------------
    553 U1c00
    554 U1c00
    555 U1c00		       00 fe	   RND_EOR_VAL =	$FE	;B4
    556 U1c00
    557 U1c00					      MAC	next_random
    558 U1c00					      lda	rnd
    559 U1c00					      lsr
    560 U1c00					      bcc	.skipEOR
    561 U1c00					      eor	#RND_EOR_VAL
    562 U1c00				   .skipEOR   sta	rnd
    563 U1c00					      ENDM
    564 U1c00
    565 U1c00							;--------------------------------------------------------------------------------
    566 U1c00
    567 U1c00					      MAC	phase
    568 U1c00					      lda	#{1}
    569 U1c00					      sta	aiState
    570 U1c00					      ENDM		;#
    571 U1c00
    572 U1c00
    573 U1c00							;--------------------------------------------------------------------------------
    574 U1c00
    575 U1c00					      MAC	common_vars_alphabeta
    576 U1c00
    577 U1c00					      VAR	__thinkbar, 1
    578 U1c00					      VAR	__toggle, 1
    579 U1c00
    580 U1c00					      VAR	__bestMove, 1
    581 U1c00					      VAR	__alpha, 2
    582 U1c00					      VAR	__beta, 2
    583 U1c00					      VAR	__negaMax, 2
    584 U1c00					      VAR	__value, 2
    585 U1c00
    586 U1c00					      VAR	__quiesceCapOnly, 1
    587 U1c00
    588 U1c00					      ENDM
    589 U1c00
    590 U1c00
    591 U1c00							;--------------------------------------------------------------------------------
    592 U1c00
    593 U1c00							;ORIGIN      SET 0
    594 U1c00
------- FILE Handler_MACROS.asm LEVEL 2 PASS 5
      0 U1c00					      include	"Handler_MACROS.asm"
      1 U1c00							; Copyright (C)2020 Andrew Davie
      2 U1c00							; Common macros for piece move handlers
      3 U1c00
      4 U1c00							;---------------------------------------------------------------------------------------------------
      5 U1c00							; Looks at a square offset {1} to see if piece can move to it
      6 U1c00							; Adds the square to the movelist if it can
      7 U1c00							; Keeps moving in the same direction until it's blocked/off=board
      8 U1c00
      9 U1c00					      MAC	move_towards
     10 U1c00					      SUBROUTINE
     11 U1c00
     12 U1c00							; = 76 for single square (empty/take)
     13 U1c00
     14 U1c00					      lda	#0
     15 U1c00					      sta	capture
     16 U1c00
     17 U1c00					      ldx	currentSquare	; 3
     18 U1c00					      bne	.project	; 3   unconditional
     19 U1c00
     20 U1c00				   .empty     jsr	AddMove	; 57
     21 U1c00				   .project   ldy	ValidSquare+{1},x	; 4
     22 U1c00					      bmi	.invalid	; 2/3 off board!
     23 U1c00					      lda	Board,y	; 4   piece @ destination
     24 U1c00					      beq	.empty	; 2/3
     25 U1c00					      sta	capture
     26 U1c00					      eor	currentPiece	; 3
     27 U1c00					      bpl	.invalid	; 2/3 same colour
     28 U1c00					      jsr	AddMove	; 57  and exit
     29 U1c00
     30 U1c00				   .invalid
     31 U1c00					      ENDM
     32 U1c00
     33 U1c00
     34 U1c00							;---------------------------------------------------------------------------------------------------
     35 U1c00
     36 U1c00					      MAC	move_to
     37 U1c00					      SUBROUTINE
     38 U1c00					      ldy	ValidSquare+{1},x
     39 U1c00					      bmi	.invalid	; off board!
     40 U1c00					      lda	Board,y	; piece @ destination
     41 U1c00					      sta	capture
     42 U1c00					      beq	.squareEmpty
     43 U1c00					      eor	currentPiece
     44 U1c00					      bpl	.invalid	; same colour
     45 U1c00				   .squareEmpty jsr	AddMove
     46 U1c00				   .invalid
     47 U1c00					      ENDM
     48 U1c00
     49 U1c00
     50 U1c00							;---------------------------------------------------------------------------------------------------
     51 U1c00
     52 U1c00					      MAC	move_to_x
     53 U1c00					      ldx	currentSquare
     54 U1c00					      MOVE_TO	{1}
     55 U1c00					      ENDM
     56 U1c00
     57 U1c00
     58 U1c00							;---------------------------------------------------------------------------------------------------
     59 U1c00							; EOF
------- FILE ./chess.asm
    596 U1c00
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 5
      0 U1c00					      include	"BANK_GENERIC.asm"
      1 U1c00
      0 U1c00					      NEWBANK	GENERIC_BANK_1
      1  07d8 ????				      SEG	GENERIC_BANK_1
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	GENERIC_BANK_1
      3  0000
      0  0000					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  0000					      ALIGN	$400
      2  0000				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  0000				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
      5  0000
      6  0000				  -	      IF	0
      7  0000				  -	      IF	PLUSCART = YES
      8  0000				  -	      .byte	"ChessAPI.php", #0 //TODO: change!
      9  0000				  -	      .byte	"pluscart.firmaplus.de", #0
     10  0000				  -	      ENDIF
     11  0000					      ENDIF
     12  0000
     13  0000		       85 3e a9 00 STELLA_AUTODETECT .byte.b	$85,$3e,$a9,$00	; 3E
     14  0004
     15  0004
     16  0004							;---------------------------------------------------------------------------------------------------
     17  0004							; ... the above is a (potentially) RAM-copied section -- the following is ROM-only.  Note that
     18  0004							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     19  0004							; bank finishes.  Just continue on from where it left off...
     20  0004							;---------------------------------------------------------------------------------------------------
     21  0004
      0  0004					      DEF	cartInit
      1  0004				   BANK_cartInit SET	_CURRENT_BANK
      2  0004				   cartInit
      3  0004				   TEMPORARY_VAR SET	Overlay
      4  0004				   TEMPORARY_OFFSET SET	0
      5  0004				   VAR_BOUNDARY_cartInit SET	TEMPORARY_OFFSET
      6  0004				   FUNCTION_NAME SET	cartInit
      7  0004					      SUBROUTINE
     23  0004					      SUBROUTINE
     24  0004
      0  0004					      REFER	Reset
      1  0004				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  0004				  -TEMPORARY_VAR SET	VAREND_Reset
      3  0004					      ENDIF
      0  0004					      VEND	cartInit
      1  0004				  -	      IFNCONST	cartInit
      2  0004				  -	      ECHO	"Incorrect VEND label", cartInit
      3  0004				  -	      ERR
      4  0004					      ENDIF
      5  0004		       00 a2	   VAREND_cartInit =	TEMPORARY_VAR
     27  0004
     28  0004		       78		      sei
     29  0005		       d8		      cld
     30  0006
     31  0006							; See if we can come up with something 'random' for startup
     32  0006
     33  0006		       ac 84 02 	      ldy	INTIM
     34  0009		       d0 02		      bne	.toR
     35  000b		       a0 9a		      ldy	#$9A
     36  000d		       84 81	   .toR       sty	rnd
     37  000f
     38  000f
     39  000f		       a9 00		      lda	#0
     40  0011		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     41  0014		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     42  0017		       85 6b		      sta	HMCLR
     43  0019
     44  0019							; cleanup remains of title screen
     45  0019		       85 5b		      sta	GRP0
     46  001b		       85 5c		      sta	GRP1
     47  001d
     48  001d		       a9 10		      lda	#%00010000	; double width missile, double width player
     49  001f		       85 44		      sta	NUSIZ0
     50  0021		       85 45		      sta	NUSIZ1
     51  0023
     52  0023		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     53  0025		       85 4a		      sta	CTRLPF
     54  0027
     55  0027		       a9 0a		      lda	#WHITE+RAMBANK_PLY
     56  0029		       85 96		      sta	sideToMove
     57  002b
     58  002b
     59  002b							;		      rts
     60  002b							;   ; fall through...
     61  002b
     62  002b							;---------------------------------------------------------------------------------------------------
     63  002b
      0  002b					      DEF	SetupBanks
      1  002b				   BANK_SetupBanks SET	_CURRENT_BANK
      2  002b				   SetupBanks
      3  002b				   TEMPORARY_VAR SET	Overlay
      4  002b				   TEMPORARY_OFFSET SET	0
      5  002b				   VAR_BOUNDARY_SetupBanks SET	TEMPORARY_OFFSET
      6  002b				   FUNCTION_NAME SET	SetupBanks
      7  002b					      SUBROUTINE
     65  002b					      SUBROUTINE
     66  002b
     67  002b							; Move a copy of the row bank template to the first 8 banks of RAM
     68  002b							; and then terminate the draw subroutine by substituting in a RTS on the last one
     69  002b
      0  002b					      REFER	Reset
      1  002b				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  002b				  -TEMPORARY_VAR SET	VAREND_Reset
      3  002b					      ENDIF
      0  002b					      VAR	__plyBank, 1
      1  002b		       00 a2	   __plyBank  =	TEMPORARY_VAR
      2  002b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  002b
      4  002b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  002b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  002b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  002b					      ENDIF
      8  002b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  002b				  -	      ECHO	"Temporary Variable", __plyBank, "overflow!"
     10  002b				  -	      ERR
     11  002b					      ENDIF
     12  002b					      LIST	ON
      0  002b					      VEND	SetupBanks
      1  002b				  -	      IFNCONST	SetupBanks
      2  002b				  -	      ECHO	"Incorrect VEND label", SetupBanks
      3  002b				  -	      ERR
      4  002b					      ENDIF
      5  002b		       00 a3	   VAREND_SetupBanks =	TEMPORARY_VAR
     73  002b
     74  002b							; SAFE
     75  002b
     76  002b		       a0 07		      ldy	#7
     77  002d		       a2 02	   .copyRowBanks ldx	#BANK_ROM_SHADOW_OF_CHESS_BITMAP
     78  002f		       20 10 fd 	      jsr	CopyShadowROMtoRAM
     79  0032		       88		      dey
     80  0033		       10 f8		      bpl	.copyRowBanks
     81  0035
     82  0035
     83  0035							; copy the BOARD/MOVES bank
     84  0035
     85  0035		       a0 09		      ldy	#RAMBANK_BOARD
     86  0037		       a2 0c		      ldx	#MOVES
     87  0039		       20 10 fd 	      jsr	CopyShadowROMtoRAM	; this auto-initialises Board too
     88  003c
     89  003c							; copy the PLY banks
     90  003c
     91  003c		       a9 0d		      lda	#PLY_BANKS
     92  003e		       85 a2		      sta	__plyBank
     93  0040		       a0 0a		      ldy	#RAMBANK_PLY
     94  0042		       84 95		      sty	currentPly
     95  0044		       a2 0d	   .copyPlyBanks ldx	#BANK_PLY
     96  0046		       20 10 fd 	      jsr	CopyShadowROMtoRAM
     97  0049		       c8		      iny
     98  004a		       c6 a2		      dec	__plyBank
     99  004c		       d0 f6		      bne	.copyPlyBanks
    100  004e
    101  004e							; copy the evaluation code/tables
    102  004e
    103  004e		       a0 17		      ldy	#RAMBANK_BANK_EVAL
    104  0050		       a2 0e		      ldx	#EVAL
    105  0052		       20 10 fd 	      jsr	CopyShadowROMtoRAM
    106  0055
    107  0055		       a0 08		      ldy	#RAMBANK_RAM_PIECELIST
    108  0057		       a2 09		      ldx	#ROM_PIECELIST
    109  0059		       20 10 fd 	      jsr	CopyShadowROMtoRAM
    110  005c
    111  005c		       60		      rts
    112  005d
    113  005d
    114  005d							;---------------------------------------------------------------------------------------------------
    115  005d
      0  005d					      DEF	tidySc
      1  005d				   BANK_tidySc SET	_CURRENT_BANK
      2  005d				   tidySc
      3  005d				   TEMPORARY_VAR SET	Overlay
      4  005d				   TEMPORARY_OFFSET SET	0
      5  005d				   VAR_BOUNDARY_tidySc SET	TEMPORARY_OFFSET
      6  005d				   FUNCTION_NAME SET	tidySc
      7  005d					      SUBROUTINE
    117  005d					      SUBROUTINE
    118  005d
    119  005d		       a9 00		      lda	#0
    120  005f		       85 4d		      sta	PF0
    121  0061		       85 4e		      sta	PF1
    122  0063		       85 4f		      sta	PF2
    123  0065		       85 5b		      sta	GRP0
    124  0067		       85 5c		      sta	GRP1
    125  0069
    126  0069		       a9 42		      lda	#%01000010	; bit6 is not required
    127  006b							;sta VBLANK			  ; end of screen - enter blanking
    128  006b
    129  006b
    130  006b							; END OF VISIBLE SCREEN
    131  006b							; HERE'S SOME TIME TO DO STUFF
    132  006b
    133  006b		       a9 2e		      lda	#TIME_PART_2
    134  006d		       8d 96 02 	      sta	TIM64T
    135  0070		       60		      rts
    136  0071
    137  0071
    138  0071							;---------------------------------------------------------------------------------------------------
    139  0071
      0  0071					      DEF	longD
      1  0071				   BANK_longD SET	_CURRENT_BANK
      2  0071				   longD
      3  0071				   TEMPORARY_VAR SET	Overlay
      4  0071				   TEMPORARY_OFFSET SET	0
      5  0071				   VAR_BOUNDARY_longD SET	TEMPORARY_OFFSET
      6  0071				   FUNCTION_NAME SET	longD
      7  0071					      SUBROUTINE
    141  0071					      SUBROUTINE
    142  0071
    143  0071		       85 42		      sta	WSYNC
    144  0073
    145  0073		       20 70 f8 	      jsr	_rts
    146  0076		       20 70 f8 	      jsr	_rts
    147  0079		       20 70 f8 	      jsr	_rts
      0  007c					      SLEEP	7
      1  007c				   .CYCLES    SET	7
      2  007c
      3  007c				  -	      IF	.CYCLES < 2
      4  007c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  007c				  -	      ERR
      6  007c					      ENDIF
      7  007c
      8  007c					      IF	.CYCLES & 1
      9  007c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  007c		       04 00		      nop	0
     11  007e				  -	      ELSE
     12  007e				  -	      bit	VSYNC
     13  007e					      ENDIF
     14  007e				   .CYCLES    SET	.CYCLES - 3
     15  007e					      ENDIF
     16  007e
     17  007e					      REPEAT	.CYCLES / 2
     18  007e		       ea		      nop
     17  007e					      REPEND
     18  007f		       ea		      nop
     19  0080					      REPEND
    149  0080
    150  0080		       a2 00		      ldx	#0
    151  0082		       86 41		      stx	VBLANK
    152  0084		       60		      rts
    153  0085
    154  0085				  -	      IF	0
    155  0085				  -	      DEF	Resync
    156  0085				  -	      SUBROUTINE
    157  0085				  -
    158  0085				  -	      RESYNC
    159  0085				  -	      rts
    160  0085					      ENDIF
    161  0085
    162  0085
    163  0085							;---------------------------------------------------------------------------------------------------
    164  0085
      0  0085					      DEF	aiStartClearBoard
      1  0085				   BANK_aiStartClearBoard SET	_CURRENT_BANK
      2  0085				   aiStartClearBoard
      3  0085				   TEMPORARY_VAR SET	Overlay
      4  0085				   TEMPORARY_OFFSET SET	0
      5  0085				   VAR_BOUNDARY_aiStartClearBoard SET	TEMPORARY_OFFSET
      6  0085				   FUNCTION_NAME SET	aiStartClearBoard
      7  0085					      SUBROUTINE
    166  0085					      SUBROUTINE
    167  0085
      0  0085					      REFER	AiStateMachine
      1  0085				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0085				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0085					      ENDIF
      0  0085					      VEND	aiStartClearBoard
      1  0085				  -	      IFNCONST	aiStartClearBoard
      2  0085				  -	      ECHO	"Incorrect VEND label", aiStartClearBoard
      3  0085				  -	      ERR
      4  0085					      ENDIF
      5  0085		       00 a2	   VAREND_aiStartClearBoard =	TEMPORARY_VAR
    170  0085
    171  0085		       a2 08		      ldx	#8
    172  0087		       86 84		      stx	drawCount	; = bank
    173  0089
    174  0089		       a9 ff		      lda	#-1
    175  008b		       85 88		      sta	cursorX12
    176  008d
      0  008d					      PHASE	AI_ClearEachRow
      1  008d		       a9 0e		      lda	#AI_ClearEachRow
      2  008f		       85 8c		      sta	aiState
    178  0091		       60		      rts
    179  0092
    180  0092							;---------------------------------------------------------------------------------------------------
    181  0092
      0  0092					      DEF	aiClearEachRow
      1  0092				   BANK_aiClearEachRow SET	_CURRENT_BANK
      2  0092				   aiClearEachRow
      3  0092				   TEMPORARY_VAR SET	Overlay
      4  0092				   TEMPORARY_OFFSET SET	0
      5  0092				   VAR_BOUNDARY_aiClearEachRow SET	TEMPORARY_OFFSET
      6  0092				   FUNCTION_NAME SET	aiClearEachRow
      7  0092					      SUBROUTINE
    183  0092					      SUBROUTINE
    184  0092
      0  0092					      REFER	AiStateMachine
      1  0092				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  0092				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  0092					      ENDIF
      0  0092					      VEND	aiClearEachRow
      1  0092				  -	      IFNCONST	aiClearEachRow
      2  0092				  -	      ECHO	"Incorrect VEND label", aiClearEachRow
      3  0092				  -	      ERR
      4  0092					      ENDIF
      5  0092		       00 a2	   VAREND_aiClearEachRow =	TEMPORARY_VAR
    187  0092
    188  0092		       c6 84		      dec	drawCount
    189  0094		       30 05		      bmi	.bitmapCleared
    190  0096		       a4 84		      ldy	drawCount
    191  0098		       4c 7d f8 	      jmp	CallClear
    192  009b
    193  009b				   .bitmapCleared
    194  009b
    195  009b		       a9 63		      lda	#99
    196  009d		       85 80		      sta	squareToDraw
    197  009f
      0  009f					      PHASE	AI_DrawEntireBoard
      1  009f		       a9 0f		      lda	#AI_DrawEntireBoard
      2  00a1		       85 8c		      sta	aiState
    199  00a3		       60		      rts
    200  00a4
    201  00a4
    202  00a4
    203  00a4							;---------------------------------------------------------------------------------------------------
    204  00a4
      0  00a4					      DEF	aiMoveIsSelected
      1  00a4				   BANK_aiMoveIsSelected SET	_CURRENT_BANK
      2  00a4				   aiMoveIsSelected
      3  00a4				   TEMPORARY_VAR SET	Overlay
      4  00a4				   TEMPORARY_OFFSET SET	0
      5  00a4				   VAR_BOUNDARY_aiMoveIsSelected SET	TEMPORARY_OFFSET
      6  00a4				   FUNCTION_NAME SET	aiMoveIsSelected
      7  00a4					      SUBROUTINE
    206  00a4					      SUBROUTINE
    207  00a4
      0  00a4					      REFER	AiStateMachine
      1  00a4				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00a4				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00a4					      ENDIF
      0  00a4					      VEND	aiMoveIsSelected
      1  00a4				  -	      IFNCONST	aiMoveIsSelected
      2  00a4				  -	      ECHO	"Incorrect VEND label", aiMoveIsSelected
      3  00a4				  -	      ERR
      4  00a4					      ENDIF
      5  00a4		       00 a2	   VAREND_aiMoveIsSelected =	TEMPORARY_VAR
    210  00a4
    211  00a4
    212  00a4							; Both computer and human have now seleted a move, and converge here
    213  00a4
    214  00a4
    215  00a4							; fromPiece	 piece doing the move
    216  00a4							; fromX12	 current square X12
    217  00a4							; originX12	 starting square X12
    218  00a4							; toX12	 ending square X12
    219  00a4
    220  00a4
    221  00a4
    222  00a4		       20 81 f9 	      jsr	AdjustMaterialPositionalValue
    223  00a7
    224  00a7		       a9 00		      lda	#0
    225  00a9		       85 99		      sta	previousPiece
    226  00ab		       85 82		      sta	drawDelay
    227  00ad
    228  00ad		       a9 0a		      lda	#10	; on/off count
    229  00af		       85 84		      sta	drawCount	; flashing for piece about to move
    230  00b1
      0  00b1					      PHASE	AI_WriteStartPieceBlank
      1  00b1		       a9 15		      lda	#AI_WriteStartPieceBlank
      2  00b3		       85 8c		      sta	aiState
    232  00b5		       60	   .idleErase rts
    233  00b6
    234  00b6
    235  00b6							;---------------------------------------------------------------------------------------------------
    236  00b6
      0  00b6					      DEF	aiWriteStartPieceBlank
      1  00b6				   BANK_aiWriteStartPieceBlank SET	_CURRENT_BANK
      2  00b6				   aiWriteStartPieceBlank
      3  00b6				   TEMPORARY_VAR SET	Overlay
      4  00b6				   TEMPORARY_OFFSET SET	0
      5  00b6				   VAR_BOUNDARY_aiWriteStartPieceBlank SET	TEMPORARY_OFFSET
      6  00b6				   FUNCTION_NAME SET	aiWriteStartPieceBlank
      7  00b6					      SUBROUTINE
    238  00b6					      SUBROUTINE
    239  00b6
      0  00b6					      REFER	AiStateMachine
      1  00b6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00b6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00b6					      ENDIF
      0  00b6					      VEND	aiWriteStartPieceBlank
      1  00b6				  -	      IFNCONST	aiWriteStartPieceBlank
      2  00b6				  -	      ECHO	"Incorrect VEND label", aiWriteStartPieceBlank
      3  00b6				  -	      ERR
      4  00b6					      ENDIF
      5  00b6		       00 a2	   VAREND_aiWriteStartPieceBlank =	TEMPORARY_VAR
    242  00b6
    243  00b6							; Flash the piece in-place preparatory to moving it.
    244  00b6							; drawDelay = flash speed
    245  00b6							; drawCount = # of flashes
    246  00b6
    247  00b6		       a5 87		      lda	originX12
    248  00b8		       85 88		      sta	cursorX12
    249  00ba
    250  00ba		       a9 04		      lda	#%100
    251  00bc		       85 4a		      sta	CTRLPF
    252  00be		       a9 02		      lda	#2
    253  00c0		       85 46		      sta	COLUP0
    254  00c2
    255  00c2
    256  00c2		       a5 82		      lda	drawDelay
    257  00c4		       f0 03		      beq	deCount
    258  00c6		       c6 82		      dec	drawDelay
    259  00c8		       60		      rts
    260  00c9				   deCount
    261  00c9
    262  00c9		       a5 84		      lda	drawCount
    263  00cb		       f0 0e		      beq	flashDone
    264  00cd		       c6 84		      dec	drawCount
    265  00cf
    266  00cf		       a9 0a		      lda	#READY_TO_MOVE_FLASH
    267  00d1		       85 82		      sta	drawDelay	; "getting ready to move" flash
    268  00d3
    269  00d3		       a5 85		      lda	fromX12
    270  00d5		       85 80		      sta	squareToDraw
    271  00d7
    272  00d7		       20 40 fd 	      jsr	CopySinglePiece	; EOR-draw = flash
    273  00da		       60		      rts
    274  00db
    275  00db				   flashDone
    276  00db
      0  00db					      PHASE	AI_MarchToTargetA
      1  00db		       a9 16		      lda	#AI_MarchToTargetA
      2  00dd		       85 8c		      sta	aiState
    278  00df		       60		      rts
    279  00e0
    280  00e0
    281  00e0							;---------------------------------------------------------------------------------------------------
    282  00e0
      0  00e0					      DEF	aiDrawPart2
      1  00e0				   BANK_aiDrawPart2 SET	_CURRENT_BANK
      2  00e0				   aiDrawPart2
      3  00e0				   TEMPORARY_VAR SET	Overlay
      4  00e0				   TEMPORARY_OFFSET SET	0
      5  00e0				   VAR_BOUNDARY_aiDrawPart2 SET	TEMPORARY_OFFSET
      6  00e0				   FUNCTION_NAME SET	aiDrawPart2
      7  00e0					      SUBROUTINE
    284  00e0					      SUBROUTINE
    285  00e0
      0  00e0					      REFER	AiStateMachine
      1  00e0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00e0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00e0					      ENDIF
      0  00e0					      VEND	aiDrawPart2
      1  00e0				  -	      IFNCONST	aiDrawPart2
      2  00e0				  -	      ECHO	"Incorrect VEND label", aiDrawPart2
      3  00e0				  -	      ERR
      4  00e0					      ENDIF
      5  00e0		       00 a2	   VAREND_aiDrawPart2 =	TEMPORARY_VAR
    288  00e0
    289  00e0		       20 40 fd 	      jsr	CopySinglePiece
    290  00e3
      0  00e3					      DEF	aiDrawPart3
      1  00e3				   BANK_aiDrawPart3 SET	_CURRENT_BANK
      2  00e3				   aiDrawPart3
      3  00e3				   TEMPORARY_VAR SET	Overlay
      4  00e3				   TEMPORARY_OFFSET SET	0
      5  00e3				   VAR_BOUNDARY_aiDrawPart3 SET	TEMPORARY_OFFSET
      6  00e3				   FUNCTION_NAME SET	aiDrawPart3
      7  00e3					      SUBROUTINE
    292  00e3					      SUBROUTINE
    293  00e3
    294  00e3		       c6 80		      dec	squareToDraw
    295  00e5		       a5 80		      lda	squareToDraw
    296  00e7		       c9 16		      cmp	#22
    297  00e9		       90 05		      bcc	.comp
    298  00eb
      0  00eb					      PHASE	AI_DrawEntireBoard
      1  00eb		       a9 0f		      lda	#AI_DrawEntireBoard
      2  00ed		       85 8c		      sta	aiState
    300  00ef		       60		      rts
    301  00f0
    302  00f0				   .comp
    303  00f0
    304  00f0		       a9 ff		      lda	#-1
    305  00f2		       85 86		      sta	toX12	; becomes startup flash square
    306  00f4		       a9 24		      lda	#36	; becomes cursor position
    307  00f6		       85 87		      sta	originX12
    308  00f8
    309  00f8
      0  00f8					      PHASE	AI_GenerateMoves
      1  00f8		       a9 12		      lda	#AI_GenerateMoves
      2  00fa		       85 8c		      sta	aiState
    311  00fc		       60		      rts
    312  00fd
    313  00fd
    314  00fd
    315  00fd
    316  00fd							;---------------------------------------------------------------------------------------------------
    317  00fd
      0  00fd					      DEF	aiMarchB
      1  00fd				   BANK_aiMarchB SET	_CURRENT_BANK
      2  00fd				   aiMarchB
      3  00fd				   TEMPORARY_VAR SET	Overlay
      4  00fd				   TEMPORARY_OFFSET SET	0
      5  00fd				   VAR_BOUNDARY_aiMarchB SET	TEMPORARY_OFFSET
      6  00fd				   FUNCTION_NAME SET	aiMarchB
      7  00fd					      SUBROUTINE
    319  00fd					      SUBROUTINE
    320  00fd
      0  00fd					      REFER	AiStateMachine
      1  00fd				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  00fd				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  00fd					      ENDIF
      0  00fd					      VEND	aiMarchB
      1  00fd				  -	      IFNCONST	aiMarchB
      2  00fd				  -	      ECHO	"Incorrect VEND label", aiMarchB
      3  00fd				  -	      ERR
      4  00fd					      ENDIF
      5  00fd		       00 a2	   VAREND_aiMarchB =	TEMPORARY_VAR
    323  00fd
    324  00fd							; Draw the piece in the new square
    325  00fd
    326  00fd		       a5 85		      lda	fromX12
    327  00ff		       85 80		      sta	squareToDraw
    328  0101
    329  0101		       20 40 fd 	      jsr	CopySinglePiece	; draw the moving piece into the new square
    330  0104
    331  0104		       a9 06		      lda	#6	; snail trail delay
    332  0106		       85 82		      sta	drawDelay
    333  0108
      0  0108					      PHASE	AI_MarchToTargetB
      1  0108		       a9 19		      lda	#AI_MarchToTargetB
      2  010a		       85 8c		      sta	aiState
    335  010c		       60		      rts
    336  010d
    337  010d
    338  010d							;---------------------------------------------------------------------------------------------------
    339  010d
      0  010d					      DEF	aiFinalFlash
      1  010d				   BANK_aiFinalFlash SET	_CURRENT_BANK
      2  010d				   aiFinalFlash
      3  010d				   TEMPORARY_VAR SET	Overlay
      4  010d				   TEMPORARY_OFFSET SET	0
      5  010d				   VAR_BOUNDARY_aiFinalFlash SET	TEMPORARY_OFFSET
      6  010d				   FUNCTION_NAME SET	aiFinalFlash
      7  010d					      SUBROUTINE
    341  010d					      SUBROUTINE
    342  010d
      0  010d					      REFER	AiStateMachine
      1  010d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  010d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  010d					      ENDIF
      0  010d					      VEND	aiFinalFlash
      1  010d				  -	      IFNCONST	aiFinalFlash
      2  010d				  -	      ECHO	"Incorrect VEND label", aiFinalFlash
      3  010d				  -	      ERR
      4  010d					      ENDIF
      5  010d		       00 a2	   VAREND_aiFinalFlash =	TEMPORARY_VAR
    345  010d
    346  010d
    347  010d		       a5 82		      lda	drawDelay
    348  010f		       f0 03		      beq	.deCount
    349  0111		       c6 82		      dec	drawDelay
    350  0113		       60		      rts
    351  0114
    352  0114		       a5 84	   .deCount   lda	drawCount
    353  0116		       f0 0e		      beq	.flashDone2
    354  0118		       c6 84		      dec	drawCount
    355  011a
    356  011a		       a9 0a		      lda	#10
    357  011c		       85 82		      sta	drawDelay	; "getting ready to move" flash
    358  011e
    359  011e		       a5 85		      lda	fromX12
    360  0120		       85 80		      sta	squareToDraw
    361  0122
    362  0122		       20 40 fd 	      jsr	CopySinglePiece
    363  0125		       60		      rts
    364  0126
    365  0126				   .flashDone2
    366  0126
    367  0126		       a9 64		      lda	#100
    368  0128		       85 8d		      sta	aiFlashDelay
    369  012a
      0  012a					      PHASE	AI_SpecialMoveFixup
      1  012a		       a9 1c		      lda	#AI_SpecialMoveFixup
      2  012c		       85 8c		      sta	aiState
    371  012e		       60		      rts
    372  012f
    373  012f
    374  012f							;---------------------------------------------------------------------------------------------------
    375  012f
      0  012f					      DEF	aiDraw
      1  012f				   BANK_aiDraw SET	_CURRENT_BANK
      2  012f				   aiDraw
      3  012f				   TEMPORARY_VAR SET	Overlay
      4  012f				   TEMPORARY_OFFSET SET	0
      5  012f				   VAR_BOUNDARY_aiDraw SET	TEMPORARY_OFFSET
      6  012f				   FUNCTION_NAME SET	aiDraw
      7  012f					      SUBROUTINE
    377  012f					      SUBROUTINE
    378  012f		       a9 c0		      lda	#$C0
    379  0131		       85 49		      sta	COLUBK
    380  0133		       60		      rts
    381  0134
    382  0134
    383  0134							;---------------------------------------------------------------------------------------------------
    384  0134
      0  0134					      DEF	aiCheckMate
      1  0134				   BANK_aiCheckMate SET	_CURRENT_BANK
      2  0134				   aiCheckMate
      3  0134				   TEMPORARY_VAR SET	Overlay
      4  0134				   TEMPORARY_OFFSET SET	0
      5  0134				   VAR_BOUNDARY_aiCheckMate SET	TEMPORARY_OFFSET
      6  0134				   FUNCTION_NAME SET	aiCheckMate
      7  0134					      SUBROUTINE
    386  0134					      SUBROUTINE
    387  0134		       a9 44		      lda	#$44
    388  0136		       85 49		      sta	COLUBK
    389  0138		       60		      rts
    390  0139
    391  0139
    392  0139							;---------------------------------------------------------------------------------------------------
    393  0139
      0  0139					      DEF	InitPieceLists
      1  0139				   BANK_InitPieceLists SET	_CURRENT_BANK
      2  0139				   InitPieceLists
      3  0139				   TEMPORARY_VAR SET	Overlay
      4  0139				   TEMPORARY_OFFSET SET	0
      5  0139				   VAR_BOUNDARY_InitPieceLists SET	TEMPORARY_OFFSET
      6  0139				   FUNCTION_NAME SET	InitPieceLists
      7  0139					      SUBROUTINE
    395  0139					      SUBROUTINE
    396  0139
      0  0139					      REFER	InitialisePieceSquares
      1  0139					      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  0139				   TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  0139					      ENDIF
      0  0139					      VEND	InitPieceLists
      1  0139				  -	      IFNCONST	InitPieceLists
      2  0139				  -	      ECHO	"Incorrect VEND label", InitPieceLists
      3  0139				  -	      ERR
      4  0139					      ENDIF
      5  0139		       00 a5	   VAREND_InitPieceLists =	TEMPORARY_VAR
    399  0139
    400  0139							;lda #-1
    401  0139							;sta@RAM SquarePtr ;PieceListPtr
    402  0139
    403  0139							; TODO: move the following as they're called 2x due to double-call of InitPiecLists
    404  0139
    405  0139		       a9 00		      lda	#0
    406  013b		       85 90		      sta	Evaluation
    407  013d		       85 91		      sta	Evaluation+1	; tracks CURRENT value of everything (signed 16-bit)
    408  013f
    409  013f
    410  013f							; General inits that are moved out of FIXED....
    411  013f
    412  013f		       a9 07		      lda	#%111
    413  0141		       85 44		      sta	NUSIZ0
    414  0143		       85 45		      sta	NUSIZ1	; quad-width
    415  0145
    416  0145		       a9 04		      lda	#%00000100
    417  0147		       85 4a		      sta	CTRLPF
    418  0149		       a9 00		      lda	#BACKGCOL
    419  014b		       85 49		      sta	COLUBK
    420  014d
    421  014d		       a9 ff		      lda	#255
    422  014f		       85 a1		      sta	randomness
    423  0151
      0  0151					      PHASE	AI_StartClearBoard
      1  0151		       a9 0d		      lda	#AI_StartClearBoard
      2  0153		       85 8c		      sta	aiState
    425  0155		       60		      rts
    426  0156
    427  0156							;---------------------------------------------------------------------------------------------------
    428  0156
    429  0156
      0  0156					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1"
      1  0156
      2  0156
      3  0156		       01 56	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (1K) SIZE =  $156 , FREE= $2aa
      4  0156					      ECHO	"GENERIC_BANK_1", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0156				  -	      IF	( .TEMP ) > ROM_BANK_SIZE/2
      6  0156				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0156				  -	      ERR
      8  0156					      ENDIF
    431  0156
    432  0156
    433  0156							;---------------------------------------------------------------------------------------------------
    434  0156
------- FILE piece_vectors.asm LEVEL 3 PASS 5
      0  0156					      include	"piece_vectors.asm"
      1  0156							; Created by ConvertChessPieces.py
      0  0156					      DEF	PIECE_VECTOR_LO
      1  0156				   BANK_PIECE_VECTOR_LO SET	_CURRENT_BANK
      2  0156				   PIECE_VECTOR_LO
      3  0156				   TEMPORARY_VAR SET	Overlay
      4  0156				   TEMPORARY_OFFSET SET	0
      5  0156				   VAR_BOUNDARY_PIECE_VECTOR_LO SET	TEMPORARY_OFFSET
      6  0156				   FUNCTION_NAME SET	PIECE_VECTOR_LO
      7  0156					      SUBROUTINE
      3  0156		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_0
      4  0157		       48		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_1
      5  0158		       90		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_2
      6  0159		       00		      .byte.b	<WHITE_BLANK_on_WHITE_SQUARE_3
      7  015a		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_0
      8  015b		       90		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_1
      9  015c		       00		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_2
     10  015d		       48		      .byte.b	<WHITE_PAWN_on_WHITE_SQUARE_3
     11  015e		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_0
     12  015f		       00		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_1
     13  0160		       48		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_2
     14  0161		       90		      .byte.b	<WHITE_KNIGHT_on_WHITE_SQUARE_3
     15  0162		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_0
     16  0163		       48		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_1
     17  0164		       90		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_2
     18  0165		       00		      .byte.b	<WHITE_BISHOP_on_WHITE_SQUARE_3
     19  0166		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_0
     20  0167		       90		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_1
     21  0168		       00		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_2
     22  0169		       48		      .byte.b	<WHITE_ROOK_on_WHITE_SQUARE_3
     23  016a		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_0
     24  016b		       00		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_1
     25  016c		       48		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_2
     26  016d		       90		      .byte.b	<WHITE_QUEEN_on_WHITE_SQUARE_3
     27  016e		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_0
     28  016f		       48		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_1
     29  0170		       90		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_2
     30  0171		       00		      .byte.b	<WHITE_KING_on_WHITE_SQUARE_3
     31  0172		       00		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_0
     32  0173		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_1
     33  0174		       90		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_2
     34  0175		       48		      .byte.b	<WHITE_MARKER_on_WHITE_SQUARE_3
     35  0176		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_0
     36  0177		       90		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_1
     37  0178		       00		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_2
     38  0179		       48		      .byte.b	<WHITE_PROMOTE_on_WHITE_SQUARE_3
     39  017a		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_0
     40  017b		       90		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_1
     41  017c		       00		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_2
     42  017d		       48		      .byte.b	<WHITE_BLANK_on_BLACK_SQUARE_3
     43  017e		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_0
     44  017f		       00		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_1
     45  0180		       48		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_2
     46  0181		       90		      .byte.b	<WHITE_PAWN_on_BLACK_SQUARE_3
     47  0182		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_0
     48  0183		       48		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_1
     49  0184		       90		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_2
     50  0185		       00		      .byte.b	<WHITE_KNIGHT_on_BLACK_SQUARE_3
     51  0186		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_0
     52  0187		       90		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_1
     53  0188		       00		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_2
     54  0189		       48		      .byte.b	<WHITE_BISHOP_on_BLACK_SQUARE_3
     55  018a		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_0
     56  018b		       00		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_1
     57  018c		       48		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_2
     58  018d		       90		      .byte.b	<WHITE_ROOK_on_BLACK_SQUARE_3
     59  018e		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_0
     60  018f		       48		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_1
     61  0190		       90		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_2
     62  0191		       00		      .byte.b	<WHITE_QUEEN_on_BLACK_SQUARE_3
     63  0192		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_0
     64  0193		       90		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_1
     65  0194		       00		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_2
     66  0195		       48		      .byte.b	<WHITE_KING_on_BLACK_SQUARE_3
     67  0196		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_0
     68  0197		       00		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_1
     69  0198		       48		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_2
     70  0199		       90		      .byte.b	<WHITE_MARKER_on_BLACK_SQUARE_3
     71  019a		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_0
     72  019b		       48		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_1
     73  019c		       90		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_2
     74  019d		       00		      .byte.b	<WHITE_PROMOTE_on_BLACK_SQUARE_3
     75  019e		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_0
     76  019f		       00		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_1
     77  01a0		       48		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_2
     78  01a1		       90		      .byte.b	<BLACK_BLANK_on_WHITE_SQUARE_3
     79  01a2		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_0
     80  01a3		       48		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_1
     81  01a4		       90		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_2
     82  01a5		       00		      .byte.b	<BLACK_PAWN_on_WHITE_SQUARE_3
     83  01a6		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_0
     84  01a7		       90		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_1
     85  01a8		       00		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_2
     86  01a9		       48		      .byte.b	<BLACK_KNIGHT_on_WHITE_SQUARE_3
     87  01aa		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_0
     88  01ab		       00		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_1
     89  01ac		       48		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_2
     90  01ad		       90		      .byte.b	<BLACK_BISHOP_on_WHITE_SQUARE_3
     91  01ae		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_0
     92  01af		       48		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_1
     93  01b0		       90		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_2
     94  01b1		       00		      .byte.b	<BLACK_ROOK_on_WHITE_SQUARE_3
     95  01b2		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_0
     96  01b3		       90		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_1
     97  01b4		       00		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_2
     98  01b5		       48		      .byte.b	<BLACK_QUEEN_on_WHITE_SQUARE_3
     99  01b6		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_0
    100  01b7		       00		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_1
    101  01b8		       48		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_2
    102  01b9		       90		      .byte.b	<BLACK_KING_on_WHITE_SQUARE_3
    103  01ba		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_0
    104  01bb		       00		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_1
    105  01bc		       48		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_2
    106  01bd		       90		      .byte.b	<BLACK_MARKER_on_WHITE_SQUARE_3
    107  01be		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_0
    108  01bf		       90		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_1
    109  01c0		       00		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_2
    110  01c1		       48		      .byte.b	<BLACK_PROMOTE_on_WHITE_SQUARE_3
    111  01c2		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_0
    112  01c3		       48		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_1
    113  01c4		       90		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_2
    114  01c5		       00		      .byte.b	<BLACK_BLANK_on_BLACK_SQUARE_3
    115  01c6		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_0
    116  01c7		       90		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_1
    117  01c8		       00		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_2
    118  01c9		       48		      .byte.b	<BLACK_PAWN_on_BLACK_SQUARE_3
    119  01ca		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_0
    120  01cb		       00		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_1
    121  01cc		       48		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_2
    122  01cd		       90		      .byte.b	<BLACK_KNIGHT_on_BLACK_SQUARE_3
    123  01ce		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_0
    124  01cf		       48		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_1
    125  01d0		       90		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_2
    126  01d1		       00		      .byte.b	<BLACK_BISHOP_on_BLACK_SQUARE_3
    127  01d2		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_0
    128  01d3		       90		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_1
    129  01d4		       00		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_2
    130  01d5		       48		      .byte.b	<BLACK_ROOK_on_BLACK_SQUARE_3
    131  01d6		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_0
    132  01d7		       00		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_1
    133  01d8		       48		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_2
    134  01d9		       90		      .byte.b	<BLACK_QUEEN_on_BLACK_SQUARE_3
    135  01da		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_0
    136  01db		       48		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_1
    137  01dc		       90		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_2
    138  01dd		       00		      .byte.b	<BLACK_KING_on_BLACK_SQUARE_3
    139  01de		       38		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_0
    140  01df		       80		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_1
    141  01e0		       00		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_2
    142  01e1		       48		      .byte.b	<BLACK_MARKER_on_BLACK_SQUARE_3
    143  01e2		       06		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_0
    144  01e3		       4e		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_1
    145  01e4		       96		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_2
    146  01e5		       00		      .byte.b	<BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  01e6					      DEF	PIECE_VECTOR_HI
      1  01e6				   BANK_PIECE_VECTOR_HI SET	_CURRENT_BANK
      2  01e6				   PIECE_VECTOR_HI
      3  01e6				   TEMPORARY_VAR SET	Overlay
      4  01e6				   TEMPORARY_OFFSET SET	0
      5  01e6				   VAR_BOUNDARY_PIECE_VECTOR_HI SET	TEMPORARY_OFFSET
      6  01e6				   FUNCTION_NAME SET	PIECE_VECTOR_HI
      7  01e6					      SUBROUTINE
    148  01e6		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_0
    149  01e7		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_1
    150  01e8		       f0		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_2
    151  01e9		       f1		      .byte.b	>WHITE_BLANK_on_WHITE_SQUARE_3
    152  01ea		       f1		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_0
    153  01eb		       f1		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_1
    154  01ec		       f2		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_2
    155  01ed		       f2		      .byte.b	>WHITE_PAWN_on_WHITE_SQUARE_3
    156  01ee		       f2		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_0
    157  01ef		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_1
    158  01f0		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_2
    159  01f1		       f3		      .byte.b	>WHITE_KNIGHT_on_WHITE_SQUARE_3
    160  01f2		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_0
    161  01f3		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_1
    162  01f4		       f4		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_2
    163  01f5		       f5		      .byte.b	>WHITE_BISHOP_on_WHITE_SQUARE_3
    164  01f6		       f5		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_0
    165  01f7		       f5		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_1
    166  01f8		       f6		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_2
    167  01f9		       f6		      .byte.b	>WHITE_ROOK_on_WHITE_SQUARE_3
    168  01fa		       f6		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_0
    169  01fb		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_1
    170  01fc		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_2
    171  01fd		       f7		      .byte.b	>WHITE_QUEEN_on_WHITE_SQUARE_3
    172  01fe		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_0
    173  01ff		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_1
    174  0200		       f0		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_2
    175  0201		       f1		      .byte.b	>WHITE_KING_on_WHITE_SQUARE_3
    176  0202		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_0
    177  0203		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_1
    178  0204		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_2
    179  0205		       f7		      .byte.b	>WHITE_MARKER_on_WHITE_SQUARE_3
    180  0206		       f5		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_0
    181  0207		       f5		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_1
    182  0208		       f6		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_2
    183  0209		       f6		      .byte.b	>WHITE_PROMOTE_on_WHITE_SQUARE_3
    184  020a		       f1		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_0
    185  020b		       f1		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_1
    186  020c		       f2		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_2
    187  020d		       f2		      .byte.b	>WHITE_BLANK_on_BLACK_SQUARE_3
    188  020e		       f2		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_0
    189  020f		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_1
    190  0210		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_2
    191  0211		       f3		      .byte.b	>WHITE_PAWN_on_BLACK_SQUARE_3
    192  0212		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_0
    193  0213		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_1
    194  0214		       f4		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_2
    195  0215		       f5		      .byte.b	>WHITE_KNIGHT_on_BLACK_SQUARE_3
    196  0216		       f5		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_0
    197  0217		       f5		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_1
    198  0218		       f6		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_2
    199  0219		       f6		      .byte.b	>WHITE_BISHOP_on_BLACK_SQUARE_3
    200  021a		       f6		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_0
    201  021b		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_1
    202  021c		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_2
    203  021d		       f7		      .byte.b	>WHITE_ROOK_on_BLACK_SQUARE_3
    204  021e		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_0
    205  021f		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_1
    206  0220		       f0		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_2
    207  0221		       f1		      .byte.b	>WHITE_QUEEN_on_BLACK_SQUARE_3
    208  0222		       f1		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_0
    209  0223		       f1		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_1
    210  0224		       f2		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_2
    211  0225		       f2		      .byte.b	>WHITE_KING_on_BLACK_SQUARE_3
    212  0226		       f5		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_0
    213  0227		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_1
    214  0228		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_2
    215  0229		       f6		      .byte.b	>WHITE_MARKER_on_BLACK_SQUARE_3
    216  022a		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_0
    217  022b		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_1
    218  022c		       f4		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_2
    219  022d		       f5		      .byte.b	>WHITE_PROMOTE_on_BLACK_SQUARE_3
    220  022e		       f2		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_0
    221  022f		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_1
    222  0230		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_2
    223  0231		       f3		      .byte.b	>BLACK_BLANK_on_WHITE_SQUARE_3
    224  0232		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_0
    225  0233		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_1
    226  0234		       f4		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_2
    227  0235		       f5		      .byte.b	>BLACK_PAWN_on_WHITE_SQUARE_3
    228  0236		       f5		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_0
    229  0237		       f5		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_1
    230  0238		       f6		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_2
    231  0239		       f6		      .byte.b	>BLACK_KNIGHT_on_WHITE_SQUARE_3
    232  023a		       f6		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_0
    233  023b		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_1
    234  023c		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_2
    235  023d		       f7		      .byte.b	>BLACK_BISHOP_on_WHITE_SQUARE_3
    236  023e		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_0
    237  023f		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_1
    238  0240		       f0		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_2
    239  0241		       f1		      .byte.b	>BLACK_ROOK_on_WHITE_SQUARE_3
    240  0242		       f1		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_0
    241  0243		       f1		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_1
    242  0244		       f2		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_2
    243  0245		       f2		      .byte.b	>BLACK_QUEEN_on_WHITE_SQUARE_3
    244  0246		       f2		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_0
    245  0247		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_1
    246  0248		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_2
    247  0249		       f3		      .byte.b	>BLACK_KING_on_WHITE_SQUARE_3
    248  024a		       f6		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_0
    249  024b		       f7		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_1
    250  024c		       f7		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_2
    251  024d		       f7		      .byte.b	>BLACK_MARKER_on_WHITE_SQUARE_3
    252  024e		       f4		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_0
    253  024f		       f4		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_1
    254  0250		       f5		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_2
    255  0251		       f5		      .byte.b	>BLACK_PROMOTE_on_WHITE_SQUARE_3
    256  0252		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_0
    257  0253		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_1
    258  0254		       f4		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_2
    259  0255		       f5		      .byte.b	>BLACK_BLANK_on_BLACK_SQUARE_3
    260  0256		       f5		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_0
    261  0257		       f5		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_1
    262  0258		       f6		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_2
    263  0259		       f6		      .byte.b	>BLACK_PAWN_on_BLACK_SQUARE_3
    264  025a		       f6		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_0
    265  025b		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_1
    266  025c		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_2
    267  025d		       f7		      .byte.b	>BLACK_KNIGHT_on_BLACK_SQUARE_3
    268  025e		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_0
    269  025f		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_1
    270  0260		       f2		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_2
    271  0261		       f3		      .byte.b	>BLACK_BISHOP_on_BLACK_SQUARE_3
    272  0262		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_0
    273  0263		       f3		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_1
    274  0264		       f4		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_2
    275  0265		       f4		      .byte.b	>BLACK_ROOK_on_BLACK_SQUARE_3
    276  0266		       f4		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_0
    277  0267		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_1
    278  0268		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_2
    279  0269		       f5		      .byte.b	>BLACK_QUEEN_on_BLACK_SQUARE_3
    280  026a		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_0
    281  026b		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_1
    282  026c		       f6		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_2
    283  026d		       f7		      .byte.b	>BLACK_KING_on_BLACK_SQUARE_3
    284  026e		       f5		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_0
    285  026f		       f5		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_1
    286  0270		       f6		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_2
    287  0271		       f6		      .byte.b	>BLACK_MARKER_on_BLACK_SQUARE_3
    288  0272		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_0
    289  0273		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_1
    290  0274		       f3		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_2
    291  0275		       f4		      .byte.b	>BLACK_PROMOTE_on_BLACK_SQUARE_3
      0  0276					      DEF	PIECE_VECTOR_BANK
      1  0276				   BANK_PIECE_VECTOR_BANK SET	_CURRENT_BANK
      2  0276				   PIECE_VECTOR_BANK
      3  0276				   TEMPORARY_VAR SET	Overlay
      4  0276				   TEMPORARY_OFFSET SET	0
      5  0276				   VAR_BOUNDARY_PIECE_VECTOR_BANK SET	TEMPORARY_OFFSET
      6  0276				   FUNCTION_NAME SET	PIECE_VECTOR_BANK
      7  0276					      SUBROUTINE
    293  0276		       03		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_0
    294  0277		       03		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_1
    295  0278		       03		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_2
    296  0279		       03		      .byte.b	BANK_WHITE_BLANK_on_WHITE_SQUARE_3
    297  027a		       03		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_0
    298  027b		       03		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_1
    299  027c		       03		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_2
    300  027d		       03		      .byte.b	BANK_WHITE_PAWN_on_WHITE_SQUARE_3
    301  027e		       03		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0
    302  027f		       03		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1
    303  0280		       03		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2
    304  0281		       03		      .byte.b	BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3
    305  0282		       03		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_0
    306  0283		       03		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_1
    307  0284		       03		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_2
    308  0285		       03		      .byte.b	BANK_WHITE_BISHOP_on_WHITE_SQUARE_3
    309  0286		       03		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_0
    310  0287		       03		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_1
    311  0288		       03		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_2
    312  0289		       03		      .byte.b	BANK_WHITE_ROOK_on_WHITE_SQUARE_3
    313  028a		       03		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_0
    314  028b		       03		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_1
    315  028c		       03		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_2
    316  028d		       03		      .byte.b	BANK_WHITE_QUEEN_on_WHITE_SQUARE_3
    317  028e		       04		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_0
    318  028f		       04		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_1
    319  0290		       04		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_2
    320  0291		       04		      .byte.b	BANK_WHITE_KING_on_WHITE_SQUARE_3
    321  0292		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_0
    322  0293		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_1
    323  0294		       00		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_2
    324  0295		       0b		      .byte.b	BANK_WHITE_MARKER_on_WHITE_SQUARE_3
    325  0296		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0
    326  0297		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1
    327  0298		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2
    328  0299		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3
    329  029a		       04		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_0
    330  029b		       04		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_1
    331  029c		       04		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_2
    332  029d		       04		      .byte.b	BANK_WHITE_BLANK_on_BLACK_SQUARE_3
    333  029e		       04		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_0
    334  029f		       04		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_1
    335  02a0		       04		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_2
    336  02a1		       04		      .byte.b	BANK_WHITE_PAWN_on_BLACK_SQUARE_3
    337  02a2		       04		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0
    338  02a3		       04		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1
    339  02a4		       04		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2
    340  02a5		       04		      .byte.b	BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3
    341  02a6		       04		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_0
    342  02a7		       04		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_1
    343  02a8		       04		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_2
    344  02a9		       04		      .byte.b	BANK_WHITE_BISHOP_on_BLACK_SQUARE_3
    345  02aa		       04		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_0
    346  02ab		       04		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_1
    347  02ac		       04		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_2
    348  02ad		       04		      .byte.b	BANK_WHITE_ROOK_on_BLACK_SQUARE_3
    349  02ae		       05		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_0
    350  02af		       05		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_1
    351  02b0		       05		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_2
    352  02b1		       05		      .byte.b	BANK_WHITE_QUEEN_on_BLACK_SQUARE_3
    353  02b2		       05		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_0
    354  02b3		       05		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_1
    355  02b4		       05		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_2
    356  02b5		       05		      .byte.b	BANK_WHITE_KING_on_BLACK_SQUARE_3
    357  02b6		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_0
    358  02b7		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_1
    359  02b8		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_2
    360  02b9		       00		      .byte.b	BANK_WHITE_MARKER_on_BLACK_SQUARE_3
    361  02ba		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0
    362  02bb		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1
    363  02bc		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2
    364  02bd		       0c		      .byte.b	BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3
    365  02be		       05		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_0
    366  02bf		       05		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_1
    367  02c0		       05		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_2
    368  02c1		       05		      .byte.b	BANK_BLACK_BLANK_on_WHITE_SQUARE_3
    369  02c2		       05		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_0
    370  02c3		       05		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_1
    371  02c4		       05		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_2
    372  02c5		       05		      .byte.b	BANK_BLACK_PAWN_on_WHITE_SQUARE_3
    373  02c6		       05		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0
    374  02c7		       05		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1
    375  02c8		       05		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2
    376  02c9		       05		      .byte.b	BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3
    377  02ca		       05		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_0
    378  02cb		       05		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_1
    379  02cc		       05		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_2
    380  02cd		       05		      .byte.b	BANK_BLACK_BISHOP_on_WHITE_SQUARE_3
    381  02ce		       06		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_0
    382  02cf		       06		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_1
    383  02d0		       06		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_2
    384  02d1		       06		      .byte.b	BANK_BLACK_ROOK_on_WHITE_SQUARE_3
    385  02d2		       06		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_0
    386  02d3		       06		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_1
    387  02d4		       06		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_2
    388  02d5		       06		      .byte.b	BANK_BLACK_QUEEN_on_WHITE_SQUARE_3
    389  02d6		       06		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_0
    390  02d7		       06		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_1
    391  02d8		       06		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_2
    392  02d9		       06		      .byte.b	BANK_BLACK_KING_on_WHITE_SQUARE_3
    393  02da		       07		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_0
    394  02db		       07		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_1
    395  02dc		       07		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_2
    396  02dd		       07		      .byte.b	BANK_BLACK_MARKER_on_WHITE_SQUARE_3
    397  02de		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0
    398  02df		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1
    399  02e0		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2
    400  02e1		       00		      .byte.b	BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3
    401  02e2		       06		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_0
    402  02e3		       06		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_1
    403  02e4		       06		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_2
    404  02e5		       06		      .byte.b	BANK_BLACK_BLANK_on_BLACK_SQUARE_3
    405  02e6		       06		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_0
    406  02e7		       06		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_1
    407  02e8		       06		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_2
    408  02e9		       06		      .byte.b	BANK_BLACK_PAWN_on_BLACK_SQUARE_3
    409  02ea		       06		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0
    410  02eb		       06		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1
    411  02ec		       06		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2
    412  02ed		       06		      .byte.b	BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3
    413  02ee		       0b		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_0
    414  02ef		       0b		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_1
    415  02f0		       0b		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_2
    416  02f1		       0b		      .byte.b	BANK_BLACK_BISHOP_on_BLACK_SQUARE_3
    417  02f2		       0b		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_0
    418  02f3		       0b		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_1
    419  02f4		       0b		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_2
    420  02f5		       0b		      .byte.b	BANK_BLACK_ROOK_on_BLACK_SQUARE_3
    421  02f6		       0b		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_0
    422  02f7		       0b		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_1
    423  02f8		       0b		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_2
    424  02f9		       0b		      .byte.b	BANK_BLACK_QUEEN_on_BLACK_SQUARE_3
    425  02fa		       0b		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_0
    426  02fb		       0b		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_1
    427  02fc		       0b		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_2
    428  02fd		       0b		      .byte.b	BANK_BLACK_KING_on_BLACK_SQUARE_3
    429  02fe		       07		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_0
    430  02ff		       07		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_1
    431  0300		       07		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_2
    432  0301		       07		      .byte.b	BANK_BLACK_MARKER_on_BLACK_SQUARE_3
    433  0302		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0
    434  0303		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1
    435  0304		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2
    436  0305		       00		      .byte.b	BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3
    437  0306
    438  0306							; piece index equates...
    439  0306		       00 00	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_0 =	0
    440  0306		       00 01	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_1 =	1
    441  0306		       00 02	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_2 =	2
    442  0306		       00 03	   INDEX_WHITE_BLANK_on_WHITE_SQUARE_3 =	3
    443  0306		       00 04	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_0 =	4
    444  0306		       00 05	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_1 =	5
    445  0306		       00 06	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_2 =	6
    446  0306		       00 07	   INDEX_WHITE_PAWN_on_WHITE_SQUARE_3 =	7
    447  0306		       00 08	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0 =	8
    448  0306		       00 09	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_1 =	9
    449  0306		       00 0a	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_2 =	10
    450  0306		       00 0b	   INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_3 =	11
    451  0306		       00 0c	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0 =	12
    452  0306		       00 0d	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_1 =	13
    453  0306		       00 0e	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_2 =	14
    454  0306		       00 0f	   INDEX_WHITE_BISHOP_on_WHITE_SQUARE_3 =	15
    455  0306		       00 10	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_0 =	16
    456  0306		       00 11	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_1 =	17
    457  0306		       00 12	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_2 =	18
    458  0306		       00 13	   INDEX_WHITE_ROOK_on_WHITE_SQUARE_3 =	19
    459  0306		       00 14	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0 =	20
    460  0306		       00 15	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_1 =	21
    461  0306		       00 16	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_2 =	22
    462  0306		       00 17	   INDEX_WHITE_QUEEN_on_WHITE_SQUARE_3 =	23
    463  0306		       00 18	   INDEX_WHITE_KING_on_WHITE_SQUARE_0 =	24
    464  0306		       00 19	   INDEX_WHITE_KING_on_WHITE_SQUARE_1 =	25
    465  0306		       00 1a	   INDEX_WHITE_KING_on_WHITE_SQUARE_2 =	26
    466  0306		       00 1b	   INDEX_WHITE_KING_on_WHITE_SQUARE_3 =	27
    467  0306		       00 1c	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_0 =	28
    468  0306		       00 1d	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_1 =	29
    469  0306		       00 1e	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_2 =	30
    470  0306		       00 1f	   INDEX_WHITE_MARKER_on_WHITE_SQUARE_3 =	31
    471  0306		       00 20	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0 =	32
    472  0306		       00 21	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_1 =	33
    473  0306		       00 22	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_2 =	34
    474  0306		       00 23	   INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_3 =	35
    475  0306		       00 24	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_0 =	36
    476  0306		       00 25	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_1 =	37
    477  0306		       00 26	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_2 =	38
    478  0306		       00 27	   INDEX_WHITE_BLANK_on_BLACK_SQUARE_3 =	39
    479  0306		       00 28	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_0 =	40
    480  0306		       00 29	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_1 =	41
    481  0306		       00 2a	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_2 =	42
    482  0306		       00 2b	   INDEX_WHITE_PAWN_on_BLACK_SQUARE_3 =	43
    483  0306		       00 2c	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_0 =	44
    484  0306		       00 2d	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_1 =	45
    485  0306		       00 2e	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_2 =	46
    486  0306		       00 2f	   INDEX_WHITE_KNIGHT_on_BLACK_SQUARE_3 =	47
    487  0306		       00 30	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_0 =	48
    488  0306		       00 31	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_1 =	49
    489  0306		       00 32	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_2 =	50
    490  0306		       00 33	   INDEX_WHITE_BISHOP_on_BLACK_SQUARE_3 =	51
    491  0306		       00 34	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_0 =	52
    492  0306		       00 35	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_1 =	53
    493  0306		       00 36	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_2 =	54
    494  0306		       00 37	   INDEX_WHITE_ROOK_on_BLACK_SQUARE_3 =	55
    495  0306		       00 38	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_0 =	56
    496  0306		       00 39	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_1 =	57
    497  0306		       00 3a	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_2 =	58
    498  0306		       00 3b	   INDEX_WHITE_QUEEN_on_BLACK_SQUARE_3 =	59
    499  0306		       00 3c	   INDEX_WHITE_KING_on_BLACK_SQUARE_0 =	60
    500  0306		       00 3d	   INDEX_WHITE_KING_on_BLACK_SQUARE_1 =	61
    501  0306		       00 3e	   INDEX_WHITE_KING_on_BLACK_SQUARE_2 =	62
    502  0306		       00 3f	   INDEX_WHITE_KING_on_BLACK_SQUARE_3 =	63
    503  0306		       00 40	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_0 =	64
    504  0306		       00 41	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_1 =	65
    505  0306		       00 42	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_2 =	66
    506  0306		       00 43	   INDEX_WHITE_MARKER_on_BLACK_SQUARE_3 =	67
    507  0306		       00 44	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_0 =	68
    508  0306		       00 45	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_1 =	69
    509  0306		       00 46	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_2 =	70
    510  0306		       00 47	   INDEX_WHITE_PROMOTE_on_BLACK_SQUARE_3 =	71
    511  0306		       00 48	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_0 =	72
    512  0306		       00 49	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_1 =	73
    513  0306		       00 4a	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_2 =	74
    514  0306		       00 4b	   INDEX_BLACK_BLANK_on_WHITE_SQUARE_3 =	75
    515  0306		       00 4c	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_0 =	76
    516  0306		       00 4d	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_1 =	77
    517  0306		       00 4e	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_2 =	78
    518  0306		       00 4f	   INDEX_BLACK_PAWN_on_WHITE_SQUARE_3 =	79
    519  0306		       00 50	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0 =	80
    520  0306		       00 51	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_1 =	81
    521  0306		       00 52	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_2 =	82
    522  0306		       00 53	   INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_3 =	83
    523  0306		       00 54	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0 =	84
    524  0306		       00 55	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_1 =	85
    525  0306		       00 56	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_2 =	86
    526  0306		       00 57	   INDEX_BLACK_BISHOP_on_WHITE_SQUARE_3 =	87
    527  0306		       00 58	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_0 =	88
    528  0306		       00 59	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_1 =	89
    529  0306		       00 5a	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_2 =	90
    530  0306		       00 5b	   INDEX_BLACK_ROOK_on_WHITE_SQUARE_3 =	91
    531  0306		       00 5c	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0 =	92
    532  0306		       00 5d	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_1 =	93
    533  0306		       00 5e	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_2 =	94
    534  0306		       00 5f	   INDEX_BLACK_QUEEN_on_WHITE_SQUARE_3 =	95
    535  0306		       00 60	   INDEX_BLACK_KING_on_WHITE_SQUARE_0 =	96
    536  0306		       00 61	   INDEX_BLACK_KING_on_WHITE_SQUARE_1 =	97
    537  0306		       00 62	   INDEX_BLACK_KING_on_WHITE_SQUARE_2 =	98
    538  0306		       00 63	   INDEX_BLACK_KING_on_WHITE_SQUARE_3 =	99
    539  0306		       00 64	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_0 =	100
    540  0306		       00 65	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_1 =	101
    541  0306		       00 66	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_2 =	102
    542  0306		       00 67	   INDEX_BLACK_MARKER_on_WHITE_SQUARE_3 =	103
    543  0306		       00 68	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0 =	104
    544  0306		       00 69	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_1 =	105
    545  0306		       00 6a	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_2 =	106
    546  0306		       00 6b	   INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_3 =	107
    547  0306		       00 6c	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_0 =	108
    548  0306		       00 6d	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_1 =	109
    549  0306		       00 6e	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_2 =	110
    550  0306		       00 6f	   INDEX_BLACK_BLANK_on_BLACK_SQUARE_3 =	111
    551  0306		       00 70	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_0 =	112
    552  0306		       00 71	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_1 =	113
    553  0306		       00 72	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_2 =	114
    554  0306		       00 73	   INDEX_BLACK_PAWN_on_BLACK_SQUARE_3 =	115
    555  0306		       00 74	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_0 =	116
    556  0306		       00 75	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_1 =	117
    557  0306		       00 76	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_2 =	118
    558  0306		       00 77	   INDEX_BLACK_KNIGHT_on_BLACK_SQUARE_3 =	119
    559  0306		       00 78	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_0 =	120
    560  0306		       00 79	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_1 =	121
    561  0306		       00 7a	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_2 =	122
    562  0306		       00 7b	   INDEX_BLACK_BISHOP_on_BLACK_SQUARE_3 =	123
    563  0306		       00 7c	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_0 =	124
    564  0306		       00 7d	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_1 =	125
    565  0306		       00 7e	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_2 =	126
    566  0306		       00 7f	   INDEX_BLACK_ROOK_on_BLACK_SQUARE_3 =	127
    567  0306		       00 80	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_0 =	128
    568  0306		       00 81	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_1 =	129
    569  0306		       00 82	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_2 =	130
    570  0306		       00 83	   INDEX_BLACK_QUEEN_on_BLACK_SQUARE_3 =	131
    571  0306		       00 84	   INDEX_BLACK_KING_on_BLACK_SQUARE_0 =	132
    572  0306		       00 85	   INDEX_BLACK_KING_on_BLACK_SQUARE_1 =	133
    573  0306		       00 86	   INDEX_BLACK_KING_on_BLACK_SQUARE_2 =	134
    574  0306		       00 87	   INDEX_BLACK_KING_on_BLACK_SQUARE_3 =	135
    575  0306		       00 88	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_0 =	136
    576  0306		       00 89	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_1 =	137
    577  0306		       00 8a	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_2 =	138
    578  0306		       00 8b	   INDEX_BLACK_MARKER_on_BLACK_SQUARE_3 =	139
    579  0306		       00 8c	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_0 =	140
    580  0306		       00 8d	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_1 =	141
    581  0306		       00 8e	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_2 =	142
    582  0306		       00 8f	   INDEX_BLACK_PROMOTE_on_BLACK_SQUARE_3 =	143
------- FILE BANK_GENERIC.asm
    436  0306
    437  0306							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
    438  0306							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
    439  0306							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
    440  0306							; include "gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
    441  0306							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
    442  0306							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
    443  0306							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
    444  0306							; include "gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
    445  0306
    446  0306							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
    447  0306							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
    448  0306							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
    449  0306							; include "gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
    450  0306							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
    451  0306							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
    452  0306							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
    453  0306							; include "gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
    454  0306
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  0306					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  0306					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_0", 72
     12  0306					      LIST	ON
      0  0306					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_0
      1  0306				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  0306				   BLACK_PROMOTE_on_BLACK_SQUARE_0
      3  0306				   TEMPORARY_VAR SET	Overlay
      4  0306				   TEMPORARY_OFFSET SET	0
      5  0306				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0306				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_0
      7  0306					      SUBROUTINE
      3  0306		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  031e		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0336		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  034e					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  034e					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_1", 72
     12  034e					      LIST	ON
      0  034e					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_1
      1  034e				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  034e				   BLACK_PROMOTE_on_BLACK_SQUARE_1
      3  034e				   TEMPORARY_VAR SET	Overlay
      4  034e				   TEMPORARY_OFFSET SET	0
      5  034e				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  034e				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_1
      7  034e					      SUBROUTINE
      3  034e		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0366		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  037e		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  0396					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  0396					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_2", 72
     12  0396					      LIST	ON
      0  0396					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_2
      1  0396				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  0396				   BLACK_PROMOTE_on_BLACK_SQUARE_2
      3  0396				   TEMPORARY_VAR SET	Overlay
      4  0396				   TEMPORARY_OFFSET SET	0
      5  0396				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0396				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_2
      7  0396					      SUBROUTINE
      3  0396		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  03ae		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  03c6		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  03de					      include	"gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  03de					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_BLACK_SQUARE_3", 72
     12  0400					      LIST	ON
      0  0400					      DEF	BLACK_PROMOTE_on_BLACK_SQUARE_3
      1  0400				   BANK_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  0400				   BLACK_PROMOTE_on_BLACK_SQUARE_3
      3  0400				   TEMPORARY_VAR SET	Overlay
      4  0400				   TEMPORARY_OFFSET SET	0
      5  0400				   VAR_BOUNDARY_BLACK_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0400				   FUNCTION_NAME SET	BLACK_PROMOTE_on_BLACK_SQUARE_3
      7  0400					      SUBROUTINE
      3  0400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0430		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  0448					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  0448					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_0", 72
     12  0448					      LIST	ON
      0  0448					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_0
      1  0448				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  0448				   BLACK_PROMOTE_on_WHITE_SQUARE_0
      3  0448				   TEMPORARY_VAR SET	Overlay
      4  0448				   TEMPORARY_OFFSET SET	0
      5  0448				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0448				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_0
      7  0448					      SUBROUTINE
      3  0448		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  0460		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  0490					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  0490					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_1", 72
     12  0490					      LIST	ON
      0  0490					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_1
      1  0490				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  0490				   BLACK_PROMOTE_on_WHITE_SQUARE_1
      3  0490				   TEMPORARY_VAR SET	Overlay
      4  0490				   TEMPORARY_OFFSET SET	0
      5  0490				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0490				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_1
      7  0490					      SUBROUTINE
      3  0490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  04a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  04c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  04d8					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  04d8					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_2", 72
     12  0500					      LIST	ON
      0  0500					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_2
      1  0500				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  0500				   BLACK_PROMOTE_on_WHITE_SQUARE_2
      3  0500				   TEMPORARY_VAR SET	Overlay
      4  0500				   TEMPORARY_OFFSET SET	0
      5  0500				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0500				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_2
      7  0500					      SUBROUTINE
      3  0500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  0530		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  0548					      include	"gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  0548					      OPTIONAL_PAGEBREAK	"BLACK_PROMOTE_on_WHITE_SQUARE_3", 72
     12  0548					      LIST	ON
      0  0548					      DEF	BLACK_PROMOTE_on_WHITE_SQUARE_3
      1  0548				   BANK_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  0548				   BLACK_PROMOTE_on_WHITE_SQUARE_3
      3  0548				   TEMPORARY_VAR SET	Overlay
      4  0548				   TEMPORARY_OFFSET SET	0
      5  0548				   VAR_BOUNDARY_BLACK_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0548				   FUNCTION_NAME SET	BLACK_PROMOTE_on_WHITE_SQUARE_3
      7  0548					      SUBROUTINE
      3  0548		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0578		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE BANK_GENERIC.asm
    463  0590
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  0590					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_0.asm"
      0  0590					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_0", 72
     12  0590					      LIST	ON
      0  0590					      DEF	WHITE_MARKER_on_BLACK_SQUARE_0
      1  0590				   BANK_WHITE_MARKER_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  0590				   WHITE_MARKER_on_BLACK_SQUARE_0
      3  0590				   TEMPORARY_VAR SET	Overlay
      4  0590				   TEMPORARY_OFFSET SET	0
      5  0590				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0590				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_0
      7  0590					      SUBROUTINE
      3  0590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$e0,$e0,$e0,$e0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  05a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  05c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  05d8					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_1.asm"
      0  05d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_1", 72
     12  0600					      LIST	ON
      0  0600					      DEF	WHITE_MARKER_on_BLACK_SQUARE_1
      1  0600				   BANK_WHITE_MARKER_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  0600				   WHITE_MARKER_on_BLACK_SQUARE_1
      3  0600				   TEMPORARY_VAR SET	Overlay
      4  0600				   TEMPORARY_OFFSET SET	0
      5  0600				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0600				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_1
      7  0600					      SUBROUTINE
      3  0600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$38,$38,$38,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0630		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  0648					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_2.asm"
      0  0648					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_2", 72
     12  0648					      LIST	ON
      0  0648					      DEF	WHITE_MARKER_on_BLACK_SQUARE_2
      1  0648				   BANK_WHITE_MARKER_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  0648				   WHITE_MARKER_on_BLACK_SQUARE_2
      3  0648				   TEMPORARY_VAR SET	Overlay
      4  0648				   TEMPORARY_OFFSET SET	0
      5  0648				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0648				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_2
      7  0648					      SUBROUTINE
      3  0648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0678		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  0690					      include	"gfx/WHITE_MARKER_on_BLACK_SQUARE_3.asm"
      0  0690					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_BLACK_SQUARE_3", 72
     12  0690					      LIST	ON
      0  0690					      DEF	WHITE_MARKER_on_BLACK_SQUARE_3
      1  0690				   BANK_WHITE_MARKER_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  0690				   WHITE_MARKER_on_BLACK_SQUARE_3
      3  0690				   TEMPORARY_VAR SET	Overlay
      4  0690				   TEMPORARY_OFFSET SET	0
      5  0690				   VAR_BOUNDARY_WHITE_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  0690				   FUNCTION_NAME SET	WHITE_MARKER_on_BLACK_SQUARE_3
      7  0690					      SUBROUTINE
      3  0690		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  06a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  06c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$70,$70,$70,$70,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  06d8					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_0.asm"
      0  06d8					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_0", 72
     12  0700					      LIST	ON
      0  0700					      DEF	WHITE_MARKER_on_WHITE_SQUARE_0
      1  0700				   BANK_WHITE_MARKER_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  0700				   WHITE_MARKER_on_WHITE_SQUARE_0
      3  0700				   TEMPORARY_VAR SET	Overlay
      4  0700				   TEMPORARY_OFFSET SET	0
      5  0700				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  0700				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_0
      7  0700					      SUBROUTINE
      3  0700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$e0,$e0,$e0,$e0,$e0,$00,$00,$00,$e0,$e0,$e0,$e0,$e0,$00,$00	;PF0
      4  0718		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  0730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  0748					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_1.asm"
      0  0748					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_1", 72
     12  0748					      LIST	ON
      0  0748					      DEF	WHITE_MARKER_on_WHITE_SQUARE_1
      1  0748				   BANK_WHITE_MARKER_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  0748				   WHITE_MARKER_on_WHITE_SQUARE_1
      3  0748				   TEMPORARY_VAR SET	Overlay
      4  0748				   TEMPORARY_OFFSET SET	0
      5  0748				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  0748				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_1
      7  0748					      SUBROUTINE
      3  0748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  0760		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$38,$38,$38,$38,$38,$00,$00,$00,$38,$38,$38,$38,$38,$00,$00	;PF1
      5  0778		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  0790					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_2.asm"
      0  0790					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_2", 72
     12  0790					      LIST	ON
      0  0790					      DEF	WHITE_MARKER_on_WHITE_SQUARE_2
      1  0790				   BANK_WHITE_MARKER_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  0790				   WHITE_MARKER_on_WHITE_SQUARE_2
      3  0790				   TEMPORARY_VAR SET	Overlay
      4  0790				   TEMPORARY_OFFSET SET	0
      5  0790				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  0790				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_2
      7  0790					      SUBROUTINE
      3  0790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  07a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$00,$00,$00,$01,$01,$01,$01,$01,$00,$00	;PF1
      5  07c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$00,$00,$00,$03,$03,$03,$03,$03,$00,$00	;PF2
------- FILE BANK_GENERIC.asm
    471  07d8
      0  07d8					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  07d8		       07 d8	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $7d8 , FREE= $28
      2  07d8					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  07d8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  07d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  07d8				  -	      ERR
      6  07d8					      ENDIF
      7  07d8
------- FILE ./chess.asm
------- FILE BANK_GENERIC2.asm LEVEL 2 PASS 5
      0  07d8					      include	"BANK_GENERIC2.asm"
      1  07d8
      0  07d8					      NEWBANK	GENERIC_BANK_2
      1  0850 ????				      SEG	GENERIC_BANK_2
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   GENERIC_BANK_2 SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	GENERIC_BANK_2
      3  0800
      4  0800					      IF	ENPASSANT_ENABLED
      5  0800
      0  0800					      DEF	EnPassantCheck
      1  0800				   BANK_EnPassantCheck SET	_CURRENT_BANK
      2  0800				   EnPassantCheck
      3  0800				   TEMPORARY_VAR SET	Overlay
      4  0800				   TEMPORARY_OFFSET SET	0
      5  0800				   VAR_BOUNDARY_EnPassantCheck SET	TEMPORARY_OFFSET
      6  0800				   FUNCTION_NAME SET	EnPassantCheck
      7  0800					      SUBROUTINE
      7  0800					      SUBROUTINE
      8  0800
      0  0800					      REFER	MakeMove
      1  0800					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  0800				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  0800					      ENDIF
      0  0800					      REFER	aiSpecialMoveFixup
      1  0800				  -	      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  0800				  -TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  0800					      ENDIF
      0  0800					      VEND	EnPassantCheck
      1  0800				  -	      IFNCONST	EnPassantCheck
      2  0800				  -	      ECHO	"Incorrect VEND label", EnPassantCheck
      3  0800				  -	      ERR
      4  0800					      ENDIF
      5  0800		       00 b0	   VAREND_EnPassantCheck =	TEMPORARY_VAR
     12  0800
     13  0800							; {
     14  0800							; With en-passant flag, it is essentially dual-use.
     15  0800							; First, it marks if the move is *involved* somehow in an en-passant
     16  0800							; if the piece has MOVED already, then it's an en-passant capture
     17  0800							; if it has NOT moved, then it's a pawn leaving home rank, and sets the en-passant square
     18  0800
     19  0800		       a4 94		      ldy	enPassantPawn	; save from previous side move
     20  0802
     21  0802		       a2 00		      ldx	#0	; (probably) NO en-passant this time
     22  0804		       a5 97		      lda	fromPiece
     23  0806		       29 60		      and	#FLAG_ENPASSANT|FLAG_MOVED
     24  0808		       c9 20		      cmp	#FLAG_ENPASSANT
     25  080a		       d0 06		      bne	.noep	; HAS moved, or not en-passant
     26  080c
     27  080c		       45 97		      eor	fromPiece	; clear FLAG_ENPASSANT
     28  080e		       85 97		      sta	fromPiece
     29  0810
     30  0810		       a6 85		      ldx	fromX12	; this IS an en-passantable opening, so record the square
     31  0812		       86 94	   .noep      stx	enPassantPawn	; capturable square for en-passant move (or none)
     32  0814
     33  0814							; }
     34  0814
     35  0814
     36  0814							; Check to see if we are doing an actual en-passant capture...
     37  0814
     38  0814							; NOTE: If using test boards for debugging, the FLAG_MOVED flag is IMPORTANT
     39  0814							;  as the en-passant will fail if the taking piece does not have this flag set correctly
     40  0814
     41  0814		       a5 97		      lda	fromPiece
     42  0816		       29 20		      and	#FLAG_ENPASSANT
     43  0818		       f0 10		      beq	.notEnPassant	; not an en-passant, or it's enpassant by a MOVED piece
     44  081a
     45  081a
     46  081a							; {
     47  081a
     48  081a							; Here we are the aggressor and we need to take the pawn 'en passant' fashion
     49  081a							; y = the square containing the pawn to capture (i.e., previous value of 'enPassantPawn')
     50  081a
     51  081a							; Remove the pawn from the board and piecelist, and undraw
     52  081a
     53  081a		       84 80		      sty	squareToDraw
     54  081c		       20 40 fd 	      jsr	CopySinglePiece	; undraw captured pawn
     55  081f
     56  081f		       a9 17		      lda	#RAMBANK_BANK_EVAL
     57  0821		       85 3e		      sta	SET_BANK_RAM
     58  0823		       85 8b		      sta	savedBank
     59  0825
     60  0825		       a4 87		      ldy	originX12	; taken pawn's square
     61  0827		       20 10 f0 	      jsr	EnPassantRemovePiece
     62  082a
     63  082a				   .notEnPassant
     64  082a							; }
     65  082a
     66  082a		       60		      rts
     67  082b
     68  082b					      ENDIF
     69  082b
     70  082b
     71  082b							;---------------------------------------------------------------------------------------------------
     72  082b
      0  082b					      DEF	ThinkBar
      1  082b				   BANK_ThinkBar SET	_CURRENT_BANK
      2  082b				   ThinkBar
      3  082b				   TEMPORARY_VAR SET	Overlay
      4  082b				   TEMPORARY_OFFSET SET	0
      5  082b				   VAR_BOUNDARY_ThinkBar SET	TEMPORARY_OFFSET
      6  082b				   FUNCTION_NAME SET	ThinkBar
      7  082b					      SUBROUTINE
     74  082b					      SUBROUTINE
     75  082b
     76  082b				  -	      IF	DIAGNOSTICS
     77  082b				  -
     78  082b				  -	      inc	positionCount
     79  082b				  -	      bne	.p1
     80  082b				  -	      inc	positionCount+1
     81  082b				  -	      bne	.p1
     82  082b				  -	      inc	positionCount+2
     83  082b				  -.p1
     84  082b					      ENDIF
     85  082b
     86  082b							; The 'thinkbar' pattern...
     87  082b
     88  082b		       a9 00		      lda	#0
     89  082d		       a4 4c		      ldy	INPT4
     90  082f		       30 0a		      bmi	.doThink
     91  0831
     92  0831		       e6 a2		      inc	__thinkbar
     93  0833		       a5 a2		      lda	__thinkbar
     94  0835		       29 0f		      and	#15
     95  0837		       a8		      tay
     96  0838		       b9 40 f0 	      lda	SynapsePattern,y
     97  083b
     98  083b		       85 4f	   .doThink   sta	PF2
     99  083d		       85 4e		      sta	PF1
    100  083f		       60		      rts
    101  0840
    102  0840
    103  0840
    104  0840				   SynapsePattern
    105  0840
    106  0840		       c1		      .byte.b	%11000001
    107  0841		       60		      .byte.b	%01100000
    108  0842		       30		      .byte.b	%00110000
    109  0843		       18		      .byte.b	%00011000
    110  0844		       0c		      .byte.b	%00001100
    111  0845		       06		      .byte.b	%00000110
    112  0846		       83		      .byte.b	%10000011
    113  0847		       c1		      .byte.b	%11000001
    114  0848
    115  0848		       83		      .byte.b	%10000011
    116  0849		       06		      .byte.b	%00000110
    117  084a		       0c		      .byte.b	%00001100
    118  084b		       18		      .byte.b	%00011000
    119  084c		       30		      .byte.b	%00110000
    120  084d		       60		      .byte.b	%01100000
    121  084e		       c1		      .byte.b	%11000001
    122  084f		       83		      .byte.b	%10000011
    123  0850
    124  0850
    125  0850							;---------------------------------------------------------------------------------------------------
    126  0850
      0  0850					      CHECK_BANK_SIZE	"GENERIC_BANK_2 -- full 2K"
      1  0850		       00 50	   .TEMP      =	* - BANK_START
 GENERIC_BANK_2 -- full 2K (2K) SIZE =  $50 , FREE= $7b0
      2  0850					      ECHO	"GENERIC_BANK_2 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0850				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  0850				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0850				  -	      ERR
      6  0850					      ENDIF
      7  0850
    128  0850
    129  0850							;---------------------------------------------------------------------------------------------------
    130  0850							;EOF
------- FILE ./chess.asm
------- FILE BANK_ROM_SHADOW_SCREEN.asm LEVEL 2 PASS 5
      0  0850					      include	"BANK_ROM_SHADOW_SCREEN.asm"
      1  0850
      0  0850					      NEWBANK	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      1  1306 ????				      SEG	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   BANK_ROM_SHADOW_OF_CHESS_BITMAP SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	BANK_ROM_SHADOW_OF_CHESS_BITMAP
      3  1000
      4  1000							; Template bank for a SINGLE ROW of the chessboard display.
      5  1000							; There are 8x of these.
      6  1000							; The bank contains the definition of the bitmap, and also the code to draw the bitmap
      7  1000							; The bank is copied from ROM into RAM at startup.
      8  1000							; The draw switches between consecutive row banks, with the last returning
      9  1000							; we effectively have 1K
     10  1000							;---------------------------------------------------------------------------------------------------
     11  1000
     12  1000		       00 84	   COLOUR_LINE_1 =	$84
     13  1000		       00 4a	   COLOUR_LINE_2 =	$4A
     14  1000		       00 18	   COLOUR_LINE_3 =	$18
     15  1000		       00 00	   BACKGCOL   =	$00
     16  1000
     17  1000							;COLOUR_LINE_1 = $94
     18  1000							;COLOUR_LINE_2 = $48
     19  1000							;COLOUR_LINE_3 = $2C
     20  1000							;BACKGCOL	= $00
     21  1000
     22  1000							;
     23  1000
     24  1000							; good/contrast
     25  1000							;COLOUR_LINE_1 = $a6
     26  1000							;COLOUR_LINE_2 = $4a
     27  1000							;COLOUR_LINE_3 = $2A
     28  1000
     29  1000							;COLOUR_LINE_1 = $94 ; square col
     30  1000							;COLOUR_LINE_2 = $C6
     31  1000							;COLOUR_LINE_3 = $48
     32  1000							;BACKGCOL	= 0 ;$F0
     33  1000
     34  1000
     35  1000							; good 94/46/28/0
     36  1000							; good 94/44/26/0
     37  1000
     38  1000
     39  1000		       00 90	   ROW_BITMAP_SIZE =	6 * 24	; PF0/PF1/PF2/(PF0)/(PF1)/(PF2) x 8 ICC pixels
     40  1000
     41  1000
      0  1000					      ALLOCATE	ChessBitmap, ROW_BITMAP_SIZE
      0  1000					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  1000					      LIST	ON
      0  1000					      DEF	ChessBitmap
      1  1000				   BANK_ChessBitmap SET	_CURRENT_BANK
      2  1000				   ChessBitmap
      3  1000				   TEMPORARY_VAR SET	Overlay
      4  1000				   TEMPORARY_OFFSET SET	0
      5  1000				   VAR_BOUNDARY_ChessBitmap SET	TEMPORARY_OFFSET
      6  1000				   FUNCTION_NAME SET	ChessBitmap
      7  1000					      SUBROUTINE
     43  1000		       00 00 00 00*ChessBitmap0 ds	24
     44  1018		       00 00 00 00*ChessBitmap1 ds	24
     45  1030		       00 00 00 00*ChessBitmap2 ds	24
     46  1048		       00 00 00 00*ChessBitmap3 ds	24
     47  1060		       00 00 00 00*ChessBitmap4 ds	24
     48  1078		       00 00 00 00*ChessBitmap5 ds	24
     49  1090
      0  1090					      ALLOCATE	BlankSprite, 8
      0  1090					      OPTIONAL_PAGEBREAK	"Table", 8
     12  1090					      LIST	ON
      0  1090					      DEF	BlankSprite
      1  1090				   BANK_BlankSprite SET	_CURRENT_BANK
      2  1090				   BlankSprite
      3  1090				   TEMPORARY_VAR SET	Overlay
      4  1090				   TEMPORARY_OFFSET SET	0
      5  1090				   VAR_BOUNDARY_BlankSprite SET	TEMPORARY_OFFSET
      6  1090				   FUNCTION_NAME SET	BlankSprite
      7  1090					      SUBROUTINE
     51  1090		       00 00 00 00*	      ds	8, 0
     52  1098
      0  1098					      ALLOCATE	SpriteBuffer, 24
      0  1098					      OPTIONAL_PAGEBREAK	"Table", 24
     12  1098					      LIST	ON
      0  1098					      DEF	SpriteBuffer
      1  1098				   BANK_SpriteBuffer SET	_CURRENT_BANK
      2  1098				   SpriteBuffer
      3  1098				   TEMPORARY_VAR SET	Overlay
      4  1098				   TEMPORARY_OFFSET SET	0
      5  1098				   VAR_BOUNDARY_SpriteBuffer SET	TEMPORARY_OFFSET
      6  1098				   FUNCTION_NAME SET	SpriteBuffer
      7  1098					      SUBROUTINE
     54  1098				   SpriteBuffer2
     55  1098					      REPEAT	24
     56  1098		       f8		      .byte.b	%11111000
     55  1098					      REPEND
     56  1099		       f8		      .byte.b	%11111000
     55  1099					      REPEND
     56  109a		       f8		      .byte.b	%11111000
     55  109a					      REPEND
     56  109b		       f8		      .byte.b	%11111000
     55  109b					      REPEND
     56  109c		       f8		      .byte.b	%11111000
     55  109c					      REPEND
     56  109d		       f8		      .byte.b	%11111000
     55  109d					      REPEND
     56  109e		       f8		      .byte.b	%11111000
     55  109e					      REPEND
     56  109f		       f8		      .byte.b	%11111000
     55  109f					      REPEND
     56  10a0		       f8		      .byte.b	%11111000
     55  10a0					      REPEND
     56  10a1		       f8		      .byte.b	%11111000
     55  10a1					      REPEND
     56  10a2		       f8		      .byte.b	%11111000
     55  10a2					      REPEND
     56  10a3		       f8		      .byte.b	%11111000
     55  10a3					      REPEND
     56  10a4		       f8		      .byte.b	%11111000
     55  10a4					      REPEND
     56  10a5		       f8		      .byte.b	%11111000
     55  10a5					      REPEND
     56  10a6		       f8		      .byte.b	%11111000
     55  10a6					      REPEND
     56  10a7		       f8		      .byte.b	%11111000
     55  10a7					      REPEND
     56  10a8		       f8		      .byte.b	%11111000
     55  10a8					      REPEND
     56  10a9		       f8		      .byte.b	%11111000
     55  10a9					      REPEND
     56  10aa		       f8		      .byte.b	%11111000
     55  10aa					      REPEND
     56  10ab		       f8		      .byte.b	%11111000
     55  10ab					      REPEND
     56  10ac		       f8		      .byte.b	%11111000
     55  10ac					      REPEND
     56  10ad		       f8		      .byte.b	%11111000
     55  10ad					      REPEND
     56  10ae		       f8		      .byte.b	%11111000
     55  10ae					      REPEND
     56  10af		       f8		      .byte.b	%11111000
     57  10b0					      REPEND
     58  10b0
      0  10b0					      ALLOCATE	BackupBitmap, ROW_BITMAP_SIZE
      0  10b0					      OPTIONAL_PAGEBREAK	"Table", ROW_BITMAP_SIZE
     12  1100					      LIST	ON
      0  1100					      DEF	BackupBitmap
      1  1100				   BANK_BackupBitmap SET	_CURRENT_BANK
      2  1100				   BackupBitmap
      3  1100				   TEMPORARY_VAR SET	Overlay
      4  1100				   TEMPORARY_OFFSET SET	0
      5  1100				   VAR_BOUNDARY_BackupBitmap SET	TEMPORARY_OFFSET
      6  1100				   FUNCTION_NAME SET	BackupBitmap
      7  1100					      SUBROUTINE
     60  1100		       00 00 00 00*	      ds	ROW_BITMAP_SIZE, 0
     61  1190
     62  1190							;---------------------------------------------------------------------------------------------------
     63  1190
      0  1190					      DEF	ClearRowBitmap
      1  1190				   BANK_ClearRowBitmap SET	_CURRENT_BANK
      2  1190				   ClearRowBitmap
      3  1190				   TEMPORARY_VAR SET	Overlay
      4  1190				   TEMPORARY_OFFSET SET	0
      5  1190				   VAR_BOUNDARY_ClearRowBitmap SET	TEMPORARY_OFFSET
      6  1190				   FUNCTION_NAME SET	ClearRowBitmap
      7  1190					      SUBROUTINE
     65  1190					      SUBROUTINE
     66  1190
      0  1190					      REFER	CallClear
      1  1190				  -	      IF	VAREND_CallClear > TEMPORARY_VAR
      2  1190				  -TEMPORARY_VAR SET	VAREND_CallClear
      3  1190					      ENDIF
      0  1190					      VEND	ClearRowBitmap
      1  1190				  -	      IFNCONST	ClearRowBitmap
      2  1190				  -	      ECHO	"Incorrect VEND label", ClearRowBitmap
      3  1190				  -	      ERR
      4  1190					      ENDIF
      5  1190		       00 a2	   VAREND_ClearRowBitmap =	TEMPORARY_VAR
     69  1190
     70  1190							; No transient variable dependencies/calls
     71  1190
     72  1190		       a9 00		      lda	#0
     73  1192		       a0 90		      ldy	#ROW_BITMAP_SIZE
      0  1194				   .clearRow  sta@RAM	ChessBitmap-1,y
      1  1194		       99 ff f3 	      sta	[RAM]+ChessBitmap-1,y
     75  1197		       88		      dey
     76  1198		       d0 fa		      bne	.clearRow
     77  119a		       60		      rts
     78  119b
     79  119b
     80  119b							;---------------------------------------------------------------------------------------------------
     81  119b
      0  119b					      DEF	CopyPieceToRowBitmap
      1  119b				   BANK_CopyPieceToRowBitmap SET	_CURRENT_BANK
      2  119b				   CopyPieceToRowBitmap
      3  119b				   TEMPORARY_VAR SET	Overlay
      4  119b				   TEMPORARY_OFFSET SET	0
      5  119b				   VAR_BOUNDARY_CopyPieceToRowBitmap SET	TEMPORARY_OFFSET
      6  119b				   FUNCTION_NAME SET	CopyPieceToRowBitmap
      7  119b					      SUBROUTINE
     83  119b					      SUBROUTINE
     84  119b
      0  119b					      REFER	CopySinglePiece	; special-case due to 'intercept'
      1  119b					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  119b				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  119b					      ENDIF
      0  119b					      VEND	CopyPieceToRowBitmap
      1  119b				  -	      IFNCONST	CopyPieceToRowBitmap
      2  119b				  -	      ECHO	"Incorrect VEND label", CopyPieceToRowBitmap
      3  119b				  -	      ERR
      4  119b					      ENDIF
      5  119b		       00 ae	   VAREND_CopyPieceToRowBitmap =	TEMPORARY_VAR
     87  119b
     88  119b		       a0 11		      ldy	#17
     89  119d		       b0 30		      bcs	.rightSide
     90  119f
     91  119f		       b9 a2 00    .copyPiece lda	__pieceShapeBuffer,y
     92  11a2		       f0 06		      beq	.blank1
     93  11a4		       59 00 f0 	      eor	ChessBitmap,y
      0  11a7					      sta@RAM	ChessBitmap,y
      1  11a7		       99 00 f4 	      sta	[RAM]+ChessBitmap,y
     95  11aa
     96  11aa		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
     97  11ad		       f0 06		      beq	.blank2
     98  11af		       59 12 f0 	      eor	ChessBitmap+18,y
      0  11b2					      sta@RAM	ChessBitmap+18,y
      1  11b2		       99 12 f4 	      sta	[RAM]+ChessBitmap+18,y
    100  11b5
    101  11b5		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
    102  11b8		       f0 06		      beq	.blank3
    103  11ba		       59 24 f0 	      eor	ChessBitmap+36,y
      0  11bd					      sta@RAM	ChessBitmap+36,y
      1  11bd		       99 24 f4 	      sta	[RAM]+ChessBitmap+36,y
    105  11c0
    106  11c0		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
    107  11c3		       f0 06		      beq	.blank4
    108  11c5		       59 36 f0 	      eor	ChessBitmap+54,y
      0  11c8					      sta@RAM	ChessBitmap+54,y
      1  11c8		       99 36 f4 	      sta	[RAM]+ChessBitmap+54,y
    110  11cb
    111  11cb		       88	   .blank4    dey
    112  11cc		       10 d1		      bpl	.copyPiece
    113  11ce		       60		      rts
    114  11cf
    115  11cf				   .rightSide
    116  11cf
    117  11cf					      SUBROUTINE
    118  11cf
    119  11cf		       b9 a2 00    .copyPieceR lda	__pieceShapeBuffer,y
    120  11d2		       f0 06		      beq	.blank1
    121  11d4		       59 48 f0 	      eor	ChessBitmap+72,y
      0  11d7					      sta@RAM	ChessBitmap+72,y
      1  11d7		       99 48 f4 	      sta	[RAM]+ChessBitmap+72,y
    123  11da
    124  11da		       b9 b4 00    .blank1    lda	__pieceShapeBuffer+18,y
    125  11dd		       f0 06		      beq	.blank2
    126  11df		       59 5a f0 	      eor	ChessBitmap+72+18,y
      0  11e2					      sta@RAM	ChessBitmap+72+18,y
      1  11e2		       99 5a f4 	      sta	[RAM]+ChessBitmap+72+18,y
    128  11e5
    129  11e5		       b9 c6 00    .blank2    lda	__pieceShapeBuffer+36,y
    130  11e8		       f0 06		      beq	.blank3
    131  11ea		       59 6c f0 	      eor	ChessBitmap+72+36,y
      0  11ed					      sta@RAM	ChessBitmap+72+36,y
      1  11ed		       99 6c f4 	      sta	[RAM]+ChessBitmap+72+36,y
    133  11f0
    134  11f0		       b9 d8 00    .blank3    lda	__pieceShapeBuffer+54,y
    135  11f3		       f0 06		      beq	.blank4
    136  11f5		       59 7e f0 	      eor	ChessBitmap+72+54,y
      0  11f8					      sta@RAM	ChessBitmap+72+54,y
      1  11f8		       99 7e f4 	      sta	[RAM]+ChessBitmap+72+54,y
    138  11fb
    139  11fb		       88	   .blank4    dey
    140  11fc		       10 d1		      bpl	.copyPieceR
    141  11fe		       60		      rts
    142  11ff
    143  11ff
    144  11ff							;---------------------------------------------------------------------------------------------------
    145  11ff
    146  1200		       00		      ALIGN	256
    147  1200					      SUBROUTINE
    148  1200
      0  1200					      REFER	Reset
      1  1200				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  1200				  -TEMPORARY_VAR SET	VAREND_Reset
      3  1200					      ENDIF
    150  1200				   __dummy
      0  1200					      VEND	__dummy
      1  1200				  -	      IFNCONST	__dummy
      2  1200				  -	      ECHO	"Incorrect VEND label", __dummy
      3  1200				  -	      ERR
      4  1200					      ENDIF
      5  1200		       00 ae	   VAREND___dummy =	TEMPORARY_VAR
    152  1200
    153  1200							; x = row # (and bank#)
    154  1200
    155  1200				   .endline
    156  1200
    157  1200							;@59
    158  1200
    159  1200							; The following 'inx' is replaced in the LAST row bank with a 'RTS', thus ending the draw loop
    160  1200							; Note that the other 7 row banks are unmodified (keeping the 'inx')
    161  1200				   SELFMOD_RTS_ON_LAST_ROW
    162  1200
    163  1200		       e8		      inx		; 2
    164  1201		       86 3e		      stx	SET_BANK_RAM	; 3 @64     BANK switch to next row
    165  1203
      0  1203					      DEF	DrawRow
      1  1203				   BANK_DrawRow SET	_CURRENT_BANK
      2  1203				   DrawRow
      3  1203				   TEMPORARY_VAR SET	Overlay
      4  1203				   TEMPORARY_OFFSET SET	0
      5  1203				   VAR_BOUNDARY_DrawRow SET	TEMPORARY_OFFSET
      6  1203				   FUNCTION_NAME SET	DrawRow
      7  1203					      SUBROUTINE
    167  1203
    168  1203							;@64
    169  1203		       a0 07		      ldy	#7	; 2
    170  1205		       10 3b		      bpl	.dl2	; 3   (must be 69 here)
    171  1207
    172  1207							;@58...
    173  1207
    174  1207				   .l3
    175  1207
    176  1207		       b9 a8 f0    SMSPRITE16_0 lda	SpriteBuffer+16,y	; 4
    177  120a		       85 5b		      sta	GRP0	; 3
    178  120c		       b9 a8 f0    SMSPRITE16_1 lda	SpriteBuffer2+16,y	; 4
    179  120f		       85 5c		      sta	GRP1	; 3
    180  1211
    181  1211							;@-4
    182  1211
    183  1211		       a9 84		      lda	#COLOUR_LINE_1	;#$94			  ; 2
    184  1213		       85 48		      sta	COLUPF	; 3 @1
    185  1215
    186  1215		       b9 10 f0 	      lda	ChessBitmap0+16,y	; 4
    187  1218		       85 4d		      sta	PF0	; 3
    188  121a		       b9 28 f0 	      lda	ChessBitmap1+16,y	; 4
    189  121d		       85 4e		      sta	PF1	; 3
    190  121f		       b9 40 f0 	      lda	ChessBitmap2+16,y	; 4
    191  1222		       85 4f		      sta	PF2	; 3 @22
    192  1224
      0  1224					      SLEEP	6	; 6 @28
      1  1224				   .CYCLES    SET	6
      2  1224
      3  1224				  -	      IF	.CYCLES < 2
      4  1224				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1224				  -	      ERR
      6  1224					      ENDIF
      7  1224
      8  1224				  -	      IF	.CYCLES & 1
      9  1224				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1224				  -	      nop	0
     11  1224				  -	      ELSE
     12  1224				  -	      bit	VSYNC
     13  1224				  -	      ENDIF
     14  1224				  -.CYCLES    SET	.CYCLES - 3
     15  1224					      ENDIF
     16  1224
     17  1224					      REPEAT	.CYCLES / 2
     18  1224		       ea		      nop
     17  1224					      REPEND
     18  1225		       ea		      nop
     17  1225					      REPEND
     18  1226		       ea		      nop
     19  1227					      REPEND
    194  1227
    195  1227		       b9 58 f0 	      lda	ChessBitmap3+16,y	; 4
    196  122a		       85 4d		      sta	PF0	; 3
    197  122c		       b9 70 f0 	      lda	ChessBitmap4+16,y	; 4
    198  122f		       85 4e		      sta	PF1	; 3
    199  1231		       b9 88 f0 	      lda	ChessBitmap5+16,y	; 4
    200  1234		       8d 4f 00 	      sta.w	PF2	; 4 @50
    201  1237
      0  1237					      SLEEP	4	; 4
      1  1237				   .CYCLES    SET	4
      2  1237
      3  1237				  -	      IF	.CYCLES < 2
      4  1237				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1237				  -	      ERR
      6  1237					      ENDIF
      7  1237
      8  1237				  -	      IF	.CYCLES & 1
      9  1237				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1237				  -	      nop	0
     11  1237				  -	      ELSE
     12  1237				  -	      bit	VSYNC
     13  1237				  -	      ENDIF
     14  1237				  -.CYCLES    SET	.CYCLES - 3
     15  1237					      ENDIF
     16  1237
     17  1237					      REPEAT	.CYCLES / 2
     18  1237		       ea		      nop
     17  1237					      REPEND
     18  1238		       ea		      nop
     19  1239					      REPEND
    203  1239
    204  1239		       88		      dey		; 2
    205  123a		       30 c4		      bmi	.endline	; 2 (3)
    206  123c
    207  123c							;@57
    208  123c				   .drawLine
    209  123c
      0  123c					      SLEEP	11
      1  123c				   .CYCLES    SET	11
      2  123c
      3  123c				  -	      IF	.CYCLES < 2
      4  123c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  123c				  -	      ERR
      6  123c					      ENDIF
      7  123c
      8  123c					      IF	.CYCLES & 1
      9  123c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  123c		       04 00		      nop	0
     11  123e				  -	      ELSE
     12  123e				  -	      bit	VSYNC
     13  123e					      ENDIF
     14  123e				   .CYCLES    SET	.CYCLES - 3
     15  123e					      ENDIF
     16  123e
     17  123e					      REPEAT	.CYCLES / 2
     18  123e		       ea		      nop
     17  123e					      REPEND
     18  123f		       ea		      nop
     17  123f					      REPEND
     18  1240		       ea		      nop
     17  1240					      REPEND
     18  1241		       ea		      nop
     19  1242					      REPEND
    211  1242
    212  1242				   .dl2
    213  1242		       b9 98 f0    SMSPRITE0_0 lda	SpriteBuffer,y	; 4
    214  1245		       85 5b		      sta	GRP0	; 3
    215  1247		       b9 98 f0    SMSPRITE0_1 lda	SpriteBuffer2,y	; 4
    216  124a		       85 5c		      sta	GRP1	; 3
    217  124c
    218  124c							;@7
    219  124c
    220  124c		       a9 4a		      lda	#COLOUR_LINE_2	;#$4A			  ; 2
    221  124e		       85 48		      sta	COLUPF	; 3 @12
    222  1250
    223  1250		       b9 00 f0 	      lda	ChessBitmap0,y	; 4
    224  1253		       85 4d		      sta	PF0	; 3
    225  1255		       b9 18 f0 	      lda	ChessBitmap1,y	; 4
    226  1258		       85 4e		      sta	PF1	; 3
    227  125a		       b9 30 f0 	      lda	ChessBitmap2,y	; 4
    228  125d		       85 4f		      sta	PF2	; 3 @33
    229  125f
      0  125f					      SLEEP	3	; 3 @36
      1  125f				   .CYCLES    SET	3
      2  125f
      3  125f				  -	      IF	.CYCLES < 2
      4  125f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  125f				  -	      ERR
      6  125f					      ENDIF
      7  125f
      8  125f					      IF	.CYCLES & 1
      9  125f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  125f		       04 00		      nop	0
     11  1261				  -	      ELSE
     12  1261				  -	      bit	VSYNC
     13  1261					      ENDIF
     14  1261				   .CYCLES    SET	.CYCLES - 3
     15  1261					      ENDIF
     16  1261
     17  1261				  -	      REPEAT	.CYCLES / 2
     18  1261				  -	      nop
     19  1261					      REPEND
    231  1261
    232  1261		       b9 48 f0 	      lda	ChessBitmap3,y	; 4
    233  1264		       85 4d		      sta	PF0	; 3
    234  1266		       b9 60 f0 	      lda	ChessBitmap4,y	; 4
    235  1269		       85 4e		      sta	PF1	; 3
    236  126b		       b9 78 f0 	      lda	ChessBitmap5,y	; 4
    237  126e		       85 4f		      sta	PF2	; 3 @57
    238  1270
      0  1270					      SLEEP	5
      1  1270				   .CYCLES    SET	5
      2  1270
      3  1270				  -	      IF	.CYCLES < 2
      4  1270				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1270				  -	      ERR
      6  1270					      ENDIF
      7  1270
      8  1270					      IF	.CYCLES & 1
      9  1270					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1270		       04 00		      nop	0
     11  1272				  -	      ELSE
     12  1272				  -	      bit	VSYNC
     13  1272					      ENDIF
     14  1272				   .CYCLES    SET	.CYCLES - 3
     15  1272					      ENDIF
     16  1272
     17  1272					      REPEAT	.CYCLES / 2
     18  1272		       ea		      nop
     19  1273					      REPEND
    240  1273
    241  1273		       b9 a0 f0    SMSPRITE8_0 lda	SpriteBuffer+8,y	; 4
    242  1276		       85 5b		      sta	GRP0	; 3
    243  1278		       b9 a0 f0    SMSPRITE8_1 lda	SpriteBuffer2+8,y	; 4
    244  127b		       85 5c		      sta	GRP1	; 3
    245  127d
    246  127d							;@0
    247  127d		       a9 18		      lda	#COLOUR_LINE_3	;#$28			  ; 2
    248  127f		       85 48		      sta	COLUPF	; 3 @5
    249  1281
    250  1281		       b9 08 f0 	      lda	ChessBitmap0+8,y	; 4
    251  1284		       85 4d		      sta	PF0	; 3
    252  1286		       b9 20 f0 	      lda	ChessBitmap1+8,y	; 4
    253  1289		       85 4e		      sta	PF1	; 3
    254  128b		       b9 38 f0 	      lda	ChessBitmap2+8,y	; 4
    255  128e		       85 4f		      sta	PF2	; 3 @26
    256  1290
      0  1290					      SLEEP	8	; 6 @34
      1  1290				   .CYCLES    SET	8
      2  1290
      3  1290				  -	      IF	.CYCLES < 2
      4  1290				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1290				  -	      ERR
      6  1290					      ENDIF
      7  1290
      8  1290				  -	      IF	.CYCLES & 1
      9  1290				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1290				  -	      nop	0
     11  1290				  -	      ELSE
     12  1290				  -	      bit	VSYNC
     13  1290				  -	      ENDIF
     14  1290				  -.CYCLES    SET	.CYCLES - 3
     15  1290					      ENDIF
     16  1290
     17  1290					      REPEAT	.CYCLES / 2
     18  1290		       ea		      nop
     17  1290					      REPEND
     18  1291		       ea		      nop
     17  1291					      REPEND
     18  1292		       ea		      nop
     17  1292					      REPEND
     18  1293		       ea		      nop
     19  1294					      REPEND
    258  1294
    259  1294		       b9 50 f0 	      lda	ChessBitmap3+8,y	; 4
    260  1297		       85 4d		      sta	PF0	; 3
    261  1299		       b9 68 f0 	      lda	ChessBitmap4+8,y	; 4
    262  129c		       85 4e		      sta	PF1	; 3
    263  129e		       b9 80 f0 	      lda	ChessBitmap5+8,y	; 4
    264  12a1		       85 4f		      sta	PF2	; 3 @55
    265  12a3
    266  12a3		       4c 07 f2 	      jmp	.l3	; 3 @58
    267  12a6
    268  12a6
    269  12a6							;---------------------------------------------------------------------------------------------------
    270  12a6
      0  12a6					      DEF	WriteBlank
      1  12a6				   BANK_WriteBlank SET	_CURRENT_BANK
      2  12a6				   WriteBlank
      3  12a6				   TEMPORARY_VAR SET	Overlay
      4  12a6				   TEMPORARY_OFFSET SET	0
      5  12a6				   VAR_BOUNDARY_WriteBlank SET	TEMPORARY_OFFSET
      6  12a6				   FUNCTION_NAME SET	WriteBlank
      7  12a6					      SUBROUTINE
    272  12a6					      SUBROUTINE
    273  12a6
      0  12a6					      REFER	Reset
      1  12a6				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  12a6				  -TEMPORARY_VAR SET	VAREND_Reset
      3  12a6					      ENDIF
      0  12a6					      VEND	WriteBlank
      1  12a6				  -	      IFNCONST	WriteBlank
      2  12a6				  -	      ECHO	"Incorrect VEND label", WriteBlank
      3  12a6				  -	      ERR
      4  12a6					      ENDIF
      5  12a6		       00 a2	   VAREND_WriteBlank =	TEMPORARY_VAR
    276  12a6
    277  12a6		       a9 90		      lda	#<BlankSprite
      0  12a8					      sta@RAM	SMSPRITE0_0+1
      1  12a8		       8d 43 f6 	      sta	[RAM]+SMSPRITE0_0+1
      0  12ab					      sta@RAM	SMSPRITE8_0+1
      1  12ab		       8d 74 f6 	      sta	[RAM]+SMSPRITE8_0+1
      0  12ae					      sta@RAM	SMSPRITE16_0+1
      1  12ae		       8d 08 f6 	      sta	[RAM]+SMSPRITE16_0+1
      0  12b1					      sta@RAM	SMSPRITE0_1+1
      1  12b1		       8d 48 f6 	      sta	[RAM]+SMSPRITE0_1+1
      0  12b4					      sta@RAM	SMSPRITE8_1+1
      1  12b4		       8d 79 f6 	      sta	[RAM]+SMSPRITE8_1+1
      0  12b7					      sta@RAM	SMSPRITE16_1+1
      1  12b7		       8d 0d f6 	      sta	[RAM]+SMSPRITE16_1+1
    284  12ba
    285  12ba		       a9 f0		      lda	#>BlankSprite
      0  12bc					      sta@RAM	SMSPRITE0_0+2
      1  12bc		       8d 44 f6 	      sta	[RAM]+SMSPRITE0_0+2
      0  12bf					      sta@RAM	SMSPRITE8_0+2
      1  12bf		       8d 75 f6 	      sta	[RAM]+SMSPRITE8_0+2
      0  12c2					      sta@RAM	SMSPRITE16_0+2
      1  12c2		       8d 09 f6 	      sta	[RAM]+SMSPRITE16_0+2
      0  12c5					      sta@RAM	SMSPRITE0_1+2
      1  12c5		       8d 49 f6 	      sta	[RAM]+SMSPRITE0_1+2
      0  12c8					      sta@RAM	SMSPRITE8_1+2
      1  12c8		       8d 7a f6 	      sta	[RAM]+SMSPRITE8_1+2
      0  12cb					      sta@RAM	SMSPRITE16_1+2
      1  12cb		       8d 0e f6 	      sta	[RAM]+SMSPRITE16_1+2
    292  12ce
    293  12ce		       60		      rts
    294  12cf
    295  12cf
    296  12cf							;---------------------------------------------------------------------------------------------------
    297  12cf
      0  12cf					      DEF	WriteCursor
      1  12cf				   BANK_WriteCursor SET	_CURRENT_BANK
      2  12cf				   WriteCursor
      3  12cf				   TEMPORARY_VAR SET	Overlay
      4  12cf				   TEMPORARY_OFFSET SET	0
      5  12cf				   VAR_BOUNDARY_WriteCursor SET	TEMPORARY_OFFSET
      6  12cf				   FUNCTION_NAME SET	WriteCursor
      7  12cf					      SUBROUTINE
    299  12cf					      SUBROUTINE
    300  12cf
      0  12cf					      REFER	Reset
      1  12cf				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  12cf				  -TEMPORARY_VAR SET	VAREND_Reset
      3  12cf					      ENDIF
      0  12cf					      VEND	WriteCursor
      1  12cf				  -	      IFNCONST	WriteCursor
      2  12cf				  -	      ECHO	"Incorrect VEND label", WriteCursor
      3  12cf				  -	      ERR
      4  12cf					      ENDIF
      5  12cf		       00 a2	   VAREND_WriteCursor =	TEMPORARY_VAR
    303  12cf
    304  12cf		       38		      sec
    305  12d0		       a5 88		      lda	cursorX12
    306  12d2		       30 1f		      bmi	.exit
    307  12d4		       a2 0a		      ldx	#10
    308  12d6		       e9 0a	   .sub10     sbc	#10
    309  12d8		       ca		      dex
    310  12d9		       b0 fb		      bcs	.sub10
    311  12db
    312  12db		       86 3e		      stx	SET_BANK_RAM
    313  12dd		       a9 98		      lda	#<SpriteBuffer
      0  12df					      sta@RAM	SMSPRITE0_0+1
      1  12df		       8d 43 f6 	      sta	[RAM]+SMSPRITE0_0+1
      0  12e2					      sta@RAM	SMSPRITE8_0+1
      1  12e2		       8d 74 f6 	      sta	[RAM]+SMSPRITE8_0+1
      0  12e5					      sta@RAM	SMSPRITE16_0+1
      1  12e5		       8d 08 f6 	      sta	[RAM]+SMSPRITE16_0+1
    317  12e8		       a9 f0		      lda	#>SpriteBuffer
      0  12ea					      sta@RAM	SMSPRITE0_0+2
      1  12ea		       8d 44 f6 	      sta	[RAM]+SMSPRITE0_0+2
      0  12ed					      sta@RAM	SMSPRITE8_0+2
      1  12ed		       8d 75 f6 	      sta	[RAM]+SMSPRITE8_0+2
      0  12f0					      sta@RAM	SMSPRITE16_0+2
      1  12f0		       8d 09 f6 	      sta	[RAM]+SMSPRITE16_0+2
    321  12f3
    322  12f3		       60	   .exit      rts
    323  12f4
    324  12f4
    325  12f4							;---------------------------------------------------------------------------------------------------
    326  12f4
      0  12f4					      DEF	SaveBitmap
      1  12f4				   BANK_SaveBitmap SET	_CURRENT_BANK
      2  12f4				   SaveBitmap
      3  12f4				   TEMPORARY_VAR SET	Overlay
      4  12f4				   TEMPORARY_OFFSET SET	0
      5  12f4				   VAR_BOUNDARY_SaveBitmap SET	TEMPORARY_OFFSET
      6  12f4				   FUNCTION_NAME SET	SaveBitmap
      7  12f4					      SUBROUTINE
    328  12f4					      SUBROUTINE
    329  12f4
      0  12f4					      REFER	SAFE_BackupBitmaps
      1  12f4				  -	      IF	VAREND_SAFE_BackupBitmaps > TEMPORARY_VAR
      2  12f4				  -TEMPORARY_VAR SET	VAREND_SAFE_BackupBitmaps
      3  12f4					      ENDIF
      0  12f4					      VEND	SaveBitmap
      1  12f4				  -	      IFNCONST	SaveBitmap
      2  12f4				  -	      ECHO	"Incorrect VEND label", SaveBitmap
      3  12f4				  -	      ERR
      4  12f4					      ENDIF
      5  12f4		       00 a2	   VAREND_SaveBitmap =	TEMPORARY_VAR
    332  12f4
    333  12f4		       a0 47		      ldy	#71
    334  12f6		       b9 00 f0    .fromTo    lda	ChessBitmap,y
      0  12f9					      sta@RAM	BackupBitmap,y
      1  12f9		       99 00 f5 	      sta	[RAM]+BackupBitmap,y
    336  12fc		       b9 48 f0 	      lda	ChessBitmap+72,y
      0  12ff					      sta@RAM	BackupBitmap+72,y
      1  12ff		       99 48 f5 	      sta	[RAM]+BackupBitmap+72,y
    338  1302		       88		      dey
    339  1303		       10 f1		      bpl	.fromTo
    340  1305		       60		      rts
    341  1306
    342  1306
    343  1306							;---------------------------------------------------------------------------------------------------
    344  1306
    345  1306				  -	      IF	0
    346  1306				  -
    347  1306				  -	      DEF	RestoreBitmap
    348  1306				  -	      SUBROUTINE
    349  1306				  -
    350  1306				  -	      VEND	RestoreBitmap
    351  1306				  -
    352  1306				  -	      ldy	#71
    353  1306				  -.fromTo    lda	BackupBitmap,y
    354  1306				  -	      sta@RAM	ChessBitmap,y
    355  1306				  -	      lda	BackupBitmap+72,y
    356  1306				  -	      sta@RAM	ChessBitmap+72,y
    357  1306				  -	      dey
    358  1306				  -	      bpl	.fromTo
    359  1306				  -	      rts
    360  1306					      ENDIF
    361  1306
    362  1306							;---------------------------------------------------------------------------------------------------
    363  1306
    364  1306				  -	      IF	0
    365  1306				  -
    366  1306				  -	      DEF	CopyTextToRowBitmap
    367  1306				  -	      SUBROUTINE
    368  1306				  -
    369  1306				  -	      VEND	CopyTextToRowBitmap
    370  1306				  -
    371  1306				  -			; An OR-draw, used for placing matricies/text onscreen
    372  1306				  -			; Similar to the EOR - first copy data into __pieceShapeBuffer, then call this function
    373  1306				  -			; The draw can be bracketed by "SaveBitmap" and "RestoreBitmap" to leave screen
    374  1306				  -			; in original state once text disappears
    375  1306				  -
    376  1306				  -	      ldy	#71
    377  1306				  -	      bcs	.rightSide
    378  1306				  -
    379  1306				  -.copy      lda	__pieceShapeBuffer,y
    380  1306				  -	      ora	ChessBitmap,y
    381  1306				  -	      sta@RAM	ChessBitmap,y
    382  1306				  -	      dey
    383  1306				  -	      bpl	.copy
    384  1306				  -
    385  1306				  -	      rts
    386  1306				  -
    387  1306				  -.rightSide
    388  1306				  -
    389  1306				  -	      SUBROUTINE
    390  1306				  -
    391  1306				  -.copy      lda	__pieceShapeBuffer,y
    392  1306				  -	      ora	ChessBitmap+72,y
    393  1306				  -	      sta@RAM	ChessBitmap+72,y
    394  1306				  -	      dey
    395  1306				  -	      bpl	.copy
    396  1306				  -
    397  1306				  -	      rts
    398  1306				  -
    399  1306					      ENDIF
    400  1306
    401  1306							;---------------------------------------------------------------------------------------------------
    402  1306
      0  1306					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_SCREEN"
      1  1306
      2  1306
      3  1306		       03 06	   .TEMP      =	* - BANK_START
 ROM_SHADOW_SCREEN (1K) SIZE =  $306 , FREE= $fa
      4  1306					      ECHO	"ROM_SHADOW_SCREEN", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1306				  -	      IF	( .TEMP ) > ROM_BANK_SIZE/2
      6  1306				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1306				  -	      ERR
      8  1306					      ENDIF
    404  1306							;VALIDATE_RAM_SIZE
------- FILE ./chess.asm
------- FILE BANK_CHESS_INCLUDES.asm LEVEL 2 PASS 5
      0  1306					      include	"BANK_CHESS_INCLUDES.asm"
      1  1306							; Copyright (c) 2019-2020 Andrew Davie
      2  1306							; andrew@taswegian.com
      3  1306
      4  1306
      5  1306							; Each piece is defined as 3 PF bytes (horizontal) x 24 scanlines (vertical)
      6  1306							; The pieces are converted by ConvertChessPieces.py (in tools), which takes
      7  1306							; a single gif of the format..
      8  1306							; a row of white pieces on black squares
      9  1306							; a row of white pieces on white squares
     10  1306							; a row of black pieces on black squares
     11  1306							; a row of black pieces on white squares
     12  1306
     13  1306							; each row has the pieces ordered thus:
     14  1306							; a blank, then pawn, knight, bishop, rook, queen, king
     15  1306							; each piece is 5 pixels wide x 8 pixels deep
     16  1306							; each pixel is from an 8-colour palette.
     17  1306							; Given a pixel colour 0-7 (represented in binary 000 - 111) then if the bits
     18  1306							; for the colour are abc (i.e., colour #3 = binary 011 = bits 0bc)
     19  1306							; then bit "a" becomes the first interleaved chronocolour pixel (line 1)
     20  1306							; bit "b" becomes the second ICC pixel line (2)
     21  1306							; bit "c" becomes the third ICC pixel line (3)
     22  1306							; Thus, a 5 pxel x 8 pixel shape becomes 24 lines deep
     23  1306							; The tool produces 4 variants of the piece; shifted into the 4 squares
     24  1306							; in the PF - thus, at pixel 0, pixel 5, pixel 10, pixel 15.
     25  1306							; These 4 shifted positions are stored consecutively in the shape definition
     26  1306
     27  1306							; Example...
     28  1306							;DEF WHITE_BISHOP_on_BLACK_SQUARE_0
     29  1306							;.byte $00,$40,$40,$40,$00,$00,$e0,$e0,$e0,$d0,$d0,$d0,$b0,$b0,$b0,$f0,$f0,$f0,$e0,$60,$e0,$f0,$f0,$f0 ;PF0
     30  1306							;.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$80,$80,$00,$80,$80,$00,$80,$00,$00,$00,$00,$80,$00 ;PF1
     31  1306							;.byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00 ;PF2
     32  1306
     33  1306							; The above defines the three 24-byte vertical strips for the 3 PF bytes that
     34  1306							; the piece (could) overlay. In this case, on square 0 (leftmost), it doesn't
     35  1306							; actually have any data in PF1 or PF2.
     36  1306
------- FILE piece_graphics.asm LEVEL 3 PASS 5
      0  1306					      include	"piece_graphics.asm"
      1  1306							; Import the graphics definitions generated by ConvertChessPieces.py
      0  1306					      NEWBANK	PIECES_0
      1  1fd8 ????				      SEG	PIECES_0
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   PIECES_0   SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	PIECES_0
      3  1800
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1800					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_0.asm"
      0  1800					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_0", 72
     12  1800					      LIST	ON
      0  1800					      DEF	WHITE_BLANK_on_WHITE_SQUARE_0
      1  1800				   BANK_WHITE_BLANK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1800				   WHITE_BLANK_on_WHITE_SQUARE_0
      3  1800				   TEMPORARY_VAR SET	Overlay
      4  1800				   TEMPORARY_OFFSET SET	0
      5  1800				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1800				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_0
      7  1800					      SUBROUTINE
      3  1800		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  1818		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  1830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1848					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_1.asm"
      0  1848					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_1", 72
     12  1848					      LIST	ON
      0  1848					      DEF	WHITE_BLANK_on_WHITE_SQUARE_1
      1  1848				   BANK_WHITE_BLANK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1848				   WHITE_BLANK_on_WHITE_SQUARE_1
      3  1848				   TEMPORARY_VAR SET	Overlay
      4  1848				   TEMPORARY_OFFSET SET	0
      5  1848				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1848				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_1
      7  1848					      SUBROUTINE
      3  1848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1860		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  1878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1890					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_2.asm"
      0  1890					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_2", 72
     12  1890					      LIST	ON
      0  1890					      DEF	WHITE_BLANK_on_WHITE_SQUARE_2
      1  1890				   BANK_WHITE_BLANK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1890				   WHITE_BLANK_on_WHITE_SQUARE_2
      3  1890				   TEMPORARY_VAR SET	Overlay
      4  1890				   TEMPORARY_OFFSET SET	0
      5  1890				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1890				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_2
      7  1890					      SUBROUTINE
      3  1890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  18a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  18c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  18d8					      include	"gfx/WHITE_BLANK_on_WHITE_SQUARE_3.asm"
      0  18d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_WHITE_SQUARE_3", 72
     12  1900					      LIST	ON
      0  1900					      DEF	WHITE_BLANK_on_WHITE_SQUARE_3
      1  1900				   BANK_WHITE_BLANK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1900				   WHITE_BLANK_on_WHITE_SQUARE_3
      3  1900				   TEMPORARY_VAR SET	Overlay
      4  1900				   TEMPORARY_OFFSET SET	0
      5  1900				   VAR_BOUNDARY_WHITE_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1900				   FUNCTION_NAME SET	WHITE_BLANK_on_WHITE_SQUARE_3
      7  1900					      SUBROUTINE
      3  1900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1930		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1948					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_0.asm"
      0  1948					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_0", 72
     12  1948					      LIST	ON
      0  1948					      DEF	WHITE_PAWN_on_WHITE_SQUARE_0
      1  1948				   BANK_WHITE_PAWN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1948				   WHITE_PAWN_on_WHITE_SQUARE_0
      3  1948				   TEMPORARY_VAR SET	Overlay
      4  1948				   TEMPORARY_OFFSET SET	0
      5  1948				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1948				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_0
      7  1948					      SUBROUTINE
      3  1948		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1960		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1990					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_1.asm"
      0  1990					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_1", 72
     12  1990					      LIST	ON
      0  1990					      DEF	WHITE_PAWN_on_WHITE_SQUARE_1
      1  1990				   BANK_WHITE_PAWN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1990				   WHITE_PAWN_on_WHITE_SQUARE_1
      3  1990				   TEMPORARY_VAR SET	Overlay
      4  1990				   TEMPORARY_OFFSET SET	0
      5  1990				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1990				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_1
      7  1990					      SUBROUTINE
      3  1990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  19a8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  19c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  19d8					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_2.asm"
      0  19d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_2", 72
     12  1a00					      LIST	ON
      0  1a00					      DEF	WHITE_PAWN_on_WHITE_SQUARE_2
      1  1a00				   BANK_WHITE_PAWN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1a00				   WHITE_PAWN_on_WHITE_SQUARE_2
      3  1a00				   TEMPORARY_VAR SET	Overlay
      4  1a00				   TEMPORARY_OFFSET SET	0
      5  1a00				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1a00				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_2
      7  1a00					      SUBROUTINE
      3  1a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1a18		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a30		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1a48					      include	"gfx/WHITE_PAWN_on_WHITE_SQUARE_3.asm"
      0  1a48					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_WHITE_SQUARE_3", 72
     12  1a48					      LIST	ON
      0  1a48					      DEF	WHITE_PAWN_on_WHITE_SQUARE_3
      1  1a48				   BANK_WHITE_PAWN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1a48				   WHITE_PAWN_on_WHITE_SQUARE_3
      3  1a48				   TEMPORARY_VAR SET	Overlay
      4  1a48				   TEMPORARY_OFFSET SET	0
      5  1a48				   VAR_BOUNDARY_WHITE_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1a48				   FUNCTION_NAME SET	WHITE_PAWN_on_WHITE_SQUARE_3
      7  1a48					      SUBROUTINE
      3  1a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1a78		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1a90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  1a90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_0", 72
     12  1a90					      LIST	ON
      0  1a90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_0
      1  1a90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1a90				   WHITE_KNIGHT_on_WHITE_SQUARE_0
      3  1a90				   TEMPORARY_VAR SET	Overlay
      4  1a90				   TEMPORARY_OFFSET SET	0
      5  1a90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1a90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_0
      7  1a90					      SUBROUTINE
      3  1a90		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1aa8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1ad8					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  1ad8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_1", 72
     12  1b00					      LIST	ON
      0  1b00					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_1
      1  1b00				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1b00				   WHITE_KNIGHT_on_WHITE_SQUARE_1
      3  1b00				   TEMPORARY_VAR SET	Overlay
      4  1b00				   TEMPORARY_OFFSET SET	0
      5  1b00				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1b00				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_1
      7  1b00					      SUBROUTINE
      3  1b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b18		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1b48					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  1b48					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_2", 72
     12  1b48					      LIST	ON
      0  1b48					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_2
      1  1b48				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1b48				   WHITE_KNIGHT_on_WHITE_SQUARE_2
      3  1b48				   TEMPORARY_VAR SET	Overlay
      4  1b48				   TEMPORARY_OFFSET SET	0
      5  1b48				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1b48				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_2
      7  1b48					      SUBROUTINE
      3  1b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1b60		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1b78		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1b90					      include	"gfx/WHITE_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  1b90					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_WHITE_SQUARE_3", 72
     12  1b90					      LIST	ON
      0  1b90					      DEF	WHITE_KNIGHT_on_WHITE_SQUARE_3
      1  1b90				   BANK_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1b90				   WHITE_KNIGHT_on_WHITE_SQUARE_3
      3  1b90				   TEMPORARY_VAR SET	Overlay
      4  1b90				   TEMPORARY_OFFSET SET	0
      5  1b90				   VAR_BOUNDARY_WHITE_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1b90				   FUNCTION_NAME SET	WHITE_KNIGHT_on_WHITE_SQUARE_3
      7  1b90					      SUBROUTINE
      3  1b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1bc0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1bd8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_0.asm"
      0  1bd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_0", 72
     12  1c00					      LIST	ON
      0  1c00					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_0
      1  1c00				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1c00				   WHITE_BISHOP_on_WHITE_SQUARE_0
      3  1c00				   TEMPORARY_VAR SET	Overlay
      4  1c00				   TEMPORARY_OFFSET SET	0
      5  1c00				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1c00				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_0
      7  1c00					      SUBROUTINE
      3  1c00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$40,$20,$00,$00,$00	;PF0
      4  1c18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1c48					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_1.asm"
      0  1c48					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_1", 72
     12  1c48					      LIST	ON
      0  1c48					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_1
      1  1c48				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1c48				   WHITE_BISHOP_on_WHITE_SQUARE_1
      3  1c48				   TEMPORARY_VAR SET	Overlay
      4  1c48				   TEMPORARY_OFFSET SET	0
      5  1c48				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1c48				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_1
      7  1c48					      SUBROUTINE
      3  1c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1c60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$10,$20,$00,$00,$00	;PF1
      5  1c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1c90					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_2.asm"
      0  1c90					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_2", 72
     12  1c90					      LIST	ON
      0  1c90					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_2
      1  1c90				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1c90				   WHITE_BISHOP_on_WHITE_SQUARE_2
      3  1c90				   TEMPORARY_VAR SET	Overlay
      4  1c90				   TEMPORARY_OFFSET SET	0
      5  1c90				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1c90				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_2
      7  1c90					      SUBROUTINE
      3  1c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ca8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00	;PF1
      5  1cc0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$01,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1cd8					      include	"gfx/WHITE_BISHOP_on_WHITE_SQUARE_3.asm"
      0  1cd8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_WHITE_SQUARE_3", 72
     12  1d00					      LIST	ON
      0  1d00					      DEF	WHITE_BISHOP_on_WHITE_SQUARE_3
      1  1d00				   BANK_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1d00				   WHITE_BISHOP_on_WHITE_SQUARE_3
      3  1d00				   TEMPORARY_VAR SET	Overlay
      4  1d00				   TEMPORARY_OFFSET SET	0
      5  1d00				   VAR_BOUNDARY_WHITE_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1d00				   FUNCTION_NAME SET	WHITE_BISHOP_on_WHITE_SQUARE_3
      7  1d00					      SUBROUTINE
      3  1d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1d30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$20,$10,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1d48					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_0.asm"
      0  1d48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_0", 72
     12  1d48					      LIST	ON
      0  1d48					      DEF	WHITE_ROOK_on_WHITE_SQUARE_0
      1  1d48				   BANK_WHITE_ROOK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1d48				   WHITE_ROOK_on_WHITE_SQUARE_0
      3  1d48				   TEMPORARY_VAR SET	Overlay
      4  1d48				   TEMPORARY_OFFSET SET	0
      5  1d48				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1d48				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_0
      7  1d48					      SUBROUTINE
      3  1d48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1d60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1d90					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_1.asm"
      0  1d90					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_1", 72
     12  1d90					      LIST	ON
      0  1d90					      DEF	WHITE_ROOK_on_WHITE_SQUARE_1
      1  1d90				   BANK_WHITE_ROOK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1d90				   WHITE_ROOK_on_WHITE_SQUARE_1
      3  1d90				   TEMPORARY_VAR SET	Overlay
      4  1d90				   TEMPORARY_OFFSET SET	0
      5  1d90				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1d90				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_1
      7  1d90					      SUBROUTINE
      3  1d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1da8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1dd8					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_2.asm"
      0  1dd8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_2", 72
     12  1e00					      LIST	ON
      0  1e00					      DEF	WHITE_ROOK_on_WHITE_SQUARE_2
      1  1e00				   BANK_WHITE_ROOK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1e00				   WHITE_ROOK_on_WHITE_SQUARE_2
      3  1e00				   TEMPORARY_VAR SET	Overlay
      4  1e00				   TEMPORARY_OFFSET SET	0
      5  1e00				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1e00				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_2
      7  1e00					      SUBROUTINE
      3  1e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1e30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1e48					      include	"gfx/WHITE_ROOK_on_WHITE_SQUARE_3.asm"
      0  1e48					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_WHITE_SQUARE_3", 72
     12  1e48					      LIST	ON
      0  1e48					      DEF	WHITE_ROOK_on_WHITE_SQUARE_3
      1  1e48				   BANK_WHITE_ROOK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1e48				   WHITE_ROOK_on_WHITE_SQUARE_3
      3  1e48				   TEMPORARY_VAR SET	Overlay
      4  1e48				   TEMPORARY_OFFSET SET	0
      5  1e48				   VAR_BOUNDARY_WHITE_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1e48				   FUNCTION_NAME SET	WHITE_ROOK_on_WHITE_SQUARE_3
      7  1e48					      SUBROUTINE
      3  1e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1e78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  1e90					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_0.asm"
      0  1e90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_0", 72
     12  1e90					      LIST	ON
      0  1e90					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_0
      1  1e90				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  1e90				   WHITE_QUEEN_on_WHITE_SQUARE_0
      3  1e90				   TEMPORARY_VAR SET	Overlay
      4  1e90				   TEMPORARY_OFFSET SET	0
      5  1e90				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  1e90				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_0
      7  1e90					      SUBROUTINE
      3  1e90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1ea8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  1ed8					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_1.asm"
      0  1ed8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_1", 72
     12  1f00					      LIST	ON
      0  1f00					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_1
      1  1f00				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  1f00				   WHITE_QUEEN_on_WHITE_SQUARE_1
      3  1f00				   TEMPORARY_VAR SET	Overlay
      4  1f00				   TEMPORARY_OFFSET SET	0
      5  1f00				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  1f00				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_1
      7  1f00					      SUBROUTINE
      3  1f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f18		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  1f48					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_2.asm"
      0  1f48					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_2", 72
     12  1f48					      LIST	ON
      0  1f48					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_2
      1  1f48				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  1f48				   WHITE_QUEEN_on_WHITE_SQUARE_2
      3  1f48				   TEMPORARY_VAR SET	Overlay
      4  1f48				   TEMPORARY_OFFSET SET	0
      5  1f48				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  1f48				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_2
      7  1f48					      SUBROUTINE
      3  1f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1f60		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1f78		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  1f90					      include	"gfx/WHITE_QUEEN_on_WHITE_SQUARE_3.asm"
      0  1f90					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_WHITE_SQUARE_3", 72
     12  1f90					      LIST	ON
      0  1f90					      DEF	WHITE_QUEEN_on_WHITE_SQUARE_3
      1  1f90				   BANK_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  1f90				   WHITE_QUEEN_on_WHITE_SQUARE_3
      3  1f90				   TEMPORARY_VAR SET	Overlay
      4  1f90				   TEMPORARY_OFFSET SET	0
      5  1f90				   VAR_BOUNDARY_WHITE_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  1f90				   FUNCTION_NAME SET	WHITE_QUEEN_on_WHITE_SQUARE_3
      7  1f90					      SUBROUTINE
      3  1f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  1fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  1fc0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  1fd8					      CHECK_BANK_SIZE	"PIECE_0 (2K)"
      1  1fd8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_0 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  1fd8					      ECHO	"PIECE_0 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1fd8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  1fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1fd8				  -	      ERR
      6  1fd8					      ENDIF
      7  1fd8
      0  1fd8					      NEWBANK	PIECES_1
      1  27d8 ????				      SEG	PIECES_1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   PIECES_1   SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	PIECES_1
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2000					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_0.asm"
      0  2000					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_0", 72
     12  2000					      LIST	ON
      0  2000					      DEF	WHITE_KING_on_WHITE_SQUARE_0
      1  2000				   BANK_WHITE_KING_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2000				   WHITE_KING_on_WHITE_SQUARE_0
      3  2000				   TEMPORARY_VAR SET	Overlay
      4  2000				   TEMPORARY_OFFSET SET	0
      5  2000				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2000				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_0
      7  2000					      SUBROUTINE
      3  2000		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$00,$a0,$80,$40,$00,$00	;PF0
      4  2018		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2048					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_1.asm"
      0  2048					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_1", 72
     12  2048					      LIST	ON
      0  2048					      DEF	WHITE_KING_on_WHITE_SQUARE_1
      1  2048				   BANK_WHITE_KING_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2048				   WHITE_KING_on_WHITE_SQUARE_1
      3  2048				   TEMPORARY_VAR SET	Overlay
      4  2048				   TEMPORARY_OFFSET SET	0
      5  2048				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2048				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_1
      7  2048					      SUBROUTINE
      3  2048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2060		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$00,$28,$08,$10,$00,$00	;PF1
      5  2078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2090					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_2.asm"
      0  2090					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_2", 72
     12  2090					      LIST	ON
      0  2090					      DEF	WHITE_KING_on_WHITE_SQUARE_2
      1  2090				   BANK_WHITE_KING_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2090				   WHITE_KING_on_WHITE_SQUARE_2
      3  2090				   TEMPORARY_VAR SET	Overlay
      4  2090				   TEMPORARY_OFFSET SET	0
      5  2090				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2090				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_2
      7  2090					      SUBROUTINE
      3  2090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  20a8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$00,$01,$00,$00,$00,$00	;PF1
      5  20c0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$00,$02,$02,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  20d8					      include	"gfx/WHITE_KING_on_WHITE_SQUARE_3.asm"
      0  20d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_WHITE_SQUARE_3", 72
     12  2100					      LIST	ON
      0  2100					      DEF	WHITE_KING_on_WHITE_SQUARE_3
      1  2100				   BANK_WHITE_KING_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2100				   WHITE_KING_on_WHITE_SQUARE_3
      3  2100				   TEMPORARY_VAR SET	Overlay
      4  2100				   TEMPORARY_OFFSET SET	0
      5  2100				   VAR_BOUNDARY_WHITE_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2100				   FUNCTION_NAME SET	WHITE_KING_on_WHITE_SQUARE_3
      7  2100					      SUBROUTINE
      3  2100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2130		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$00,$50,$40,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2148					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_0.asm"
      0  2148					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_0", 72
     12  2148					      LIST	ON
      0  2148					      DEF	WHITE_BLANK_on_BLACK_SQUARE_0
      1  2148				   BANK_WHITE_BLANK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2148				   WHITE_BLANK_on_BLACK_SQUARE_0
      3  2148				   TEMPORARY_VAR SET	Overlay
      4  2148				   TEMPORARY_OFFSET SET	0
      5  2148				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2148				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_0
      7  2148					      SUBROUTINE
      3  2148		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2160		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2190					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_1.asm"
      0  2190					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_1", 72
     12  2190					      LIST	ON
      0  2190					      DEF	WHITE_BLANK_on_BLACK_SQUARE_1
      1  2190				   BANK_WHITE_BLANK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2190				   WHITE_BLANK_on_BLACK_SQUARE_1
      3  2190				   TEMPORARY_VAR SET	Overlay
      4  2190				   TEMPORARY_OFFSET SET	0
      5  2190				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2190				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_1
      7  2190					      SUBROUTINE
      3  2190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  21a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  21c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  21d8					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_2.asm"
      0  21d8					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_2", 72
     12  2200					      LIST	ON
      0  2200					      DEF	WHITE_BLANK_on_BLACK_SQUARE_2
      1  2200				   BANK_WHITE_BLANK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2200				   WHITE_BLANK_on_BLACK_SQUARE_2
      3  2200				   TEMPORARY_VAR SET	Overlay
      4  2200				   TEMPORARY_OFFSET SET	0
      5  2200				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2200				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_2
      7  2200					      SUBROUTINE
      3  2200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2218		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2230		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2248					      include	"gfx/WHITE_BLANK_on_BLACK_SQUARE_3.asm"
      0  2248					      OPTIONAL_PAGEBREAK	"WHITE_BLANK_on_BLACK_SQUARE_3", 72
     12  2248					      LIST	ON
      0  2248					      DEF	WHITE_BLANK_on_BLACK_SQUARE_3
      1  2248				   BANK_WHITE_BLANK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2248				   WHITE_BLANK_on_BLACK_SQUARE_3
      3  2248				   TEMPORARY_VAR SET	Overlay
      4  2248				   TEMPORARY_OFFSET SET	0
      5  2248				   VAR_BOUNDARY_WHITE_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2248				   FUNCTION_NAME SET	WHITE_BLANK_on_BLACK_SQUARE_3
      7  2248					      SUBROUTINE
      3  2248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2278		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2290					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_0.asm"
      0  2290					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_0", 72
     12  2290					      LIST	ON
      0  2290					      DEF	WHITE_PAWN_on_BLACK_SQUARE_0
      1  2290				   BANK_WHITE_PAWN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2290				   WHITE_PAWN_on_BLACK_SQUARE_0
      3  2290				   TEMPORARY_VAR SET	Overlay
      4  2290				   TEMPORARY_OFFSET SET	0
      5  2290				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2290				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_0
      7  2290					      SUBROUTINE
      3  2290		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$a0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  22a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  22c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  22d8					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_1.asm"
      0  22d8					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_1", 72
     12  2300					      LIST	ON
      0  2300					      DEF	WHITE_PAWN_on_BLACK_SQUARE_1
      1  2300				   BANK_WHITE_PAWN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2300				   WHITE_PAWN_on_BLACK_SQUARE_1
      3  2300				   TEMPORARY_VAR SET	Overlay
      4  2300				   TEMPORARY_OFFSET SET	0
      5  2300				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2300				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_1
      7  2300					      SUBROUTINE
      3  2300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2318		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$28,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2348					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_2.asm"
      0  2348					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_2", 72
     12  2348					      LIST	ON
      0  2348					      DEF	WHITE_PAWN_on_BLACK_SQUARE_2
      1  2348				   BANK_WHITE_PAWN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2348				   WHITE_PAWN_on_BLACK_SQUARE_2
      3  2348				   TEMPORARY_VAR SET	Overlay
      4  2348				   TEMPORARY_OFFSET SET	0
      5  2348				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2348				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_2
      7  2348					      SUBROUTINE
      3  2348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2360		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  2378		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$02,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2390					      include	"gfx/WHITE_PAWN_on_BLACK_SQUARE_3.asm"
      0  2390					      OPTIONAL_PAGEBREAK	"WHITE_PAWN_on_BLACK_SQUARE_3", 72
     12  2390					      LIST	ON
      0  2390					      DEF	WHITE_PAWN_on_BLACK_SQUARE_3
      1  2390				   BANK_WHITE_PAWN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2390				   WHITE_PAWN_on_BLACK_SQUARE_3
      3  2390				   TEMPORARY_VAR SET	Overlay
      4  2390				   TEMPORARY_OFFSET SET	0
      5  2390				   VAR_BOUNDARY_WHITE_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2390				   FUNCTION_NAME SET	WHITE_PAWN_on_BLACK_SQUARE_3
      7  2390					      SUBROUTINE
      3  2390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  23a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  23c0		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$50,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  23d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  23d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_0", 72
     12  2400					      LIST	ON
      0  2400					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_0
      1  2400				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2400				   WHITE_KNIGHT_on_BLACK_SQUARE_0
      3  2400				   TEMPORARY_VAR SET	Overlay
      4  2400				   TEMPORARY_OFFSET SET	0
      5  2400				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2400				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_0
      7  2400					      SUBROUTINE
      3  2400		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$f0,$e0,$e0,$f0,$f0,$40,$00	;PF0
      4  2418		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2448					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  2448					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_1", 72
     12  2448					      LIST	ON
      0  2448					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_1
      1  2448				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2448				   WHITE_KNIGHT_on_BLACK_SQUARE_1
      3  2448				   TEMPORARY_VAR SET	Overlay
      4  2448				   TEMPORARY_OFFSET SET	0
      5  2448				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2448				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_1
      7  2448					      SUBROUTINE
      3  2448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2460		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$78,$38,$3c,$7c,$7c,$14,$00	;PF1
      5  2478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2490					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  2490					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_2", 72
     12  2490					      LIST	ON
      0  2490					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_2
      1  2490				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2490				   WHITE_KNIGHT_on_BLACK_SQUARE_2
      3  2490				   TEMPORARY_VAR SET	Overlay
      4  2490				   TEMPORARY_OFFSET SET	0
      5  2490				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2490				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_2
      7  2490					      SUBROUTINE
      3  2490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  24a8		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$01,$03,$03,$00,$00	;PF1
      5  24c0		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$03,$03,$07,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  24d8					      include	"gfx/WHITE_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  24d8					      OPTIONAL_PAGEBREAK	"WHITE_KNIGHT_on_BLACK_SQUARE_3", 72
     12  2500					      LIST	ON
      0  2500					      DEF	WHITE_KNIGHT_on_BLACK_SQUARE_3
      1  2500				   BANK_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2500				   WHITE_KNIGHT_on_BLACK_SQUARE_3
      3  2500				   TEMPORARY_VAR SET	Overlay
      4  2500				   TEMPORARY_OFFSET SET	0
      5  2500				   VAR_BOUNDARY_WHITE_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2500				   FUNCTION_NAME SET	WHITE_KNIGHT_on_BLACK_SQUARE_3
      7  2500					      SUBROUTINE
      3  2500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2530		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$78,$70,$f0,$f8,$f8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2548					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_0.asm"
      0  2548					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_0", 72
     12  2548					      LIST	ON
      0  2548					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_0
      1  2548				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2548				   WHITE_BISHOP_on_BLACK_SQUARE_0
      3  2548				   TEMPORARY_VAR SET	Overlay
      4  2548				   TEMPORARY_OFFSET SET	0
      5  2548				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2548				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_0
      7  2548					      SUBROUTINE
      3  2548		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$b0,$d0,$e0,$40,$40	;PF0
      4  2560		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  2578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2590					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_1.asm"
      0  2590					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_1", 72
     12  2590					      LIST	ON
      0  2590					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_1
      1  2590				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2590				   WHITE_BISHOP_on_BLACK_SQUARE_1
      3  2590				   TEMPORARY_VAR SET	Overlay
      4  2590				   TEMPORARY_OFFSET SET	0
      5  2590				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2590				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_1
      7  2590					      SUBROUTINE
      3  2590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  25a8		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$6c,$5c,$38,$10,$10	;PF1
      5  25c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  25d8					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_2.asm"
      0  25d8					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_2", 72
     12  2600					      LIST	ON
      0  2600					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_2
      1  2600				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2600				   WHITE_BISHOP_on_BLACK_SQUARE_2
      3  2600				   TEMPORARY_VAR SET	Overlay
      4  2600				   TEMPORARY_OFFSET SET	0
      5  2600				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2600				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_2
      7  2600					      SUBROUTINE
      3  2600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2618		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00	;PF1
      5  2630		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$06,$07,$03,$01,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2648					      include	"gfx/WHITE_BISHOP_on_BLACK_SQUARE_3.asm"
      0  2648					      OPTIONAL_PAGEBREAK	"WHITE_BISHOP_on_BLACK_SQUARE_3", 72
     12  2648					      LIST	ON
      0  2648					      DEF	WHITE_BISHOP_on_BLACK_SQUARE_3
      1  2648				   BANK_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2648				   WHITE_BISHOP_on_BLACK_SQUARE_3
      3  2648				   TEMPORARY_VAR SET	Overlay
      4  2648				   TEMPORARY_OFFSET SET	0
      5  2648				   VAR_BOUNDARY_WHITE_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2648				   FUNCTION_NAME SET	WHITE_BISHOP_on_BLACK_SQUARE_3
      7  2648					      SUBROUTINE
      3  2648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2678		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$d8,$e8,$70,$20,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2690					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_0.asm"
      0  2690					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_0", 72
     12  2690					      LIST	ON
      0  2690					      DEF	WHITE_ROOK_on_BLACK_SQUARE_0
      1  2690				   BANK_WHITE_ROOK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2690				   WHITE_ROOK_on_BLACK_SQUARE_0
      3  2690				   TEMPORARY_VAR SET	Overlay
      4  2690				   TEMPORARY_OFFSET SET	0
      5  2690				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2690				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_0
      7  2690					      SUBROUTINE
      3  2690		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$f0,$50,$00	;PF0
      4  26a8		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  26c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  26d8					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_1.asm"
      0  26d8					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_1", 72
     12  2700					      LIST	ON
      0  2700					      DEF	WHITE_ROOK_on_BLACK_SQUARE_1
      1  2700				   BANK_WHITE_ROOK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2700				   WHITE_ROOK_on_BLACK_SQUARE_1
      3  2700				   TEMPORARY_VAR SET	Overlay
      4  2700				   TEMPORARY_OFFSET SET	0
      5  2700				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2700				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_1
      7  2700					      SUBROUTINE
      3  2700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2718		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$7c,$54,$00	;PF1
      5  2730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2748					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_2.asm"
      0  2748					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_2", 72
     12  2748					      LIST	ON
      0  2748					      DEF	WHITE_ROOK_on_BLACK_SQUARE_2
      1  2748				   BANK_WHITE_ROOK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2748				   WHITE_ROOK_on_BLACK_SQUARE_2
      3  2748				   TEMPORARY_VAR SET	Overlay
      4  2748				   TEMPORARY_OFFSET SET	0
      5  2748				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2748				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_2
      7  2748					      SUBROUTINE
      3  2748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2760		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$03,$02,$00	;PF1
      5  2778		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$07,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2790					      include	"gfx/WHITE_ROOK_on_BLACK_SQUARE_3.asm"
      0  2790					      OPTIONAL_PAGEBREAK	"WHITE_ROOK_on_BLACK_SQUARE_3", 72
     12  2790					      LIST	ON
      0  2790					      DEF	WHITE_ROOK_on_BLACK_SQUARE_3
      1  2790				   BANK_WHITE_ROOK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2790				   WHITE_ROOK_on_BLACK_SQUARE_3
      3  2790				   TEMPORARY_VAR SET	Overlay
      4  2790				   TEMPORARY_OFFSET SET	0
      5  2790				   VAR_BOUNDARY_WHITE_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2790				   FUNCTION_NAME SET	WHITE_ROOK_on_BLACK_SQUARE_3
      7  2790					      SUBROUTINE
      3  2790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  27a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  27c0		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$f8,$a8,$00	;PF2
------- FILE piece_graphics.asm
      0  27d8					      CHECK_BANK_SIZE	"PIECE_1 (2K)"
      1  27d8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_1 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  27d8					      ECHO	"PIECE_1 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27d8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  27d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27d8				  -	      ERR
      6  27d8					      ENDIF
      7  27d8
      0  27d8					      NEWBANK	PIECES_2
      1  2fd8 ????				      SEG	PIECES_2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   PIECES_2   SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	PIECES_2
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2800					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_0.asm"
      0  2800					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_0", 72
     12  2800					      LIST	ON
      0  2800					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_0
      1  2800				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2800				   WHITE_QUEEN_on_BLACK_SQUARE_0
      3  2800				   TEMPORARY_VAR SET	Overlay
      4  2800				   TEMPORARY_OFFSET SET	0
      5  2800				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2800				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_0
      7  2800					      SUBROUTINE
      3  2800		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  2818		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00,$80,$00	;PF1
      5  2830		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2848					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_1.asm"
      0  2848					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_1", 72
     12  2848					      LIST	ON
      0  2848					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_1
      1  2848				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2848				   WHITE_QUEEN_on_BLACK_SQUARE_1
      3  2848				   TEMPORARY_VAR SET	Overlay
      4  2848				   TEMPORARY_OFFSET SET	0
      5  2848				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2848				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_1
      7  2848					      SUBROUTINE
      3  2848		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2860		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$7c,$7c,$54,$00,$54,$00	;PF1
      5  2878		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  2890					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_2.asm"
      0  2890					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_2", 72
     12  2890					      LIST	ON
      0  2890					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_2
      1  2890				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2890				   WHITE_QUEEN_on_BLACK_SQUARE_2
      3  2890				   TEMPORARY_VAR SET	Overlay
      4  2890				   TEMPORARY_OFFSET SET	0
      5  2890				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2890				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_2
      7  2890					      SUBROUTINE
      3  2890		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  28a8		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  28c0		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$07,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  28d8					      include	"gfx/WHITE_QUEEN_on_BLACK_SQUARE_3.asm"
      0  28d8					      OPTIONAL_PAGEBREAK	"WHITE_QUEEN_on_BLACK_SQUARE_3", 72
     12  2900					      LIST	ON
      0  2900					      DEF	WHITE_QUEEN_on_BLACK_SQUARE_3
      1  2900				   BANK_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2900				   WHITE_QUEEN_on_BLACK_SQUARE_3
      3  2900				   TEMPORARY_VAR SET	Overlay
      4  2900				   TEMPORARY_OFFSET SET	0
      5  2900				   VAR_BOUNDARY_WHITE_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2900				   FUNCTION_NAME SET	WHITE_QUEEN_on_BLACK_SQUARE_3
      7  2900					      SUBROUTINE
      3  2900		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2918		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2930		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$f8,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  2948					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_0.asm"
      0  2948					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_0", 72
     12  2948					      LIST	ON
      0  2948					      DEF	WHITE_KING_on_BLACK_SQUARE_0
      1  2948				   BANK_WHITE_KING_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  2948				   WHITE_KING_on_BLACK_SQUARE_0
      3  2948				   TEMPORARY_VAR SET	Overlay
      4  2948				   TEMPORARY_OFFSET SET	0
      5  2948				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2948				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_0
      7  2948					      SUBROUTINE
      3  2948		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$00,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$f0,$50,$70,$b0,$e0,$40	;PF0
      4  2960		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$00,$00	;PF1
      5  2978		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  2990					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_1.asm"
      0  2990					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_1", 72
     12  2990					      LIST	ON
      0  2990					      DEF	WHITE_KING_on_BLACK_SQUARE_1
      1  2990				   BANK_WHITE_KING_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  2990				   WHITE_KING_on_BLACK_SQUARE_1
      3  2990				   TEMPORARY_VAR SET	Overlay
      4  2990				   TEMPORARY_OFFSET SET	0
      5  2990				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2990				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_1
      7  2990					      SUBROUTINE
      3  2990		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  29a8		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$00,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$7c,$54,$74,$6c,$38,$10	;PF1
      5  29c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  29d8					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_2.asm"
      0  29d8					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_2", 72
     12  2a00					      LIST	ON
      0  2a00					      DEF	WHITE_KING_on_BLACK_SQUARE_2
      1  2a00				   BANK_WHITE_KING_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  2a00				   WHITE_KING_on_BLACK_SQUARE_2
      3  2a00				   TEMPORARY_VAR SET	Overlay
      4  2a00				   TEMPORARY_OFFSET SET	0
      5  2a00				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2a00				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_2
      7  2a00					      SUBROUTINE
      3  2a00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a18		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$03,$02,$03,$03,$01,$00	;PF1
      5  2a30		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$00,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$07,$05,$05,$06,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/WHITE_KING_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  2a48					      include	"gfx/WHITE_KING_on_BLACK_SQUARE_3.asm"
      0  2a48					      OPTIONAL_PAGEBREAK	"WHITE_KING_on_BLACK_SQUARE_3", 72
     12  2a48					      LIST	ON
      0  2a48					      DEF	WHITE_KING_on_BLACK_SQUARE_3
      1  2a48				   BANK_WHITE_KING_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  2a48				   WHITE_KING_on_BLACK_SQUARE_3
      3  2a48				   TEMPORARY_VAR SET	Overlay
      4  2a48				   TEMPORARY_OFFSET SET	0
      5  2a48				   VAR_BOUNDARY_WHITE_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2a48				   FUNCTION_NAME SET	WHITE_KING_on_BLACK_SQUARE_3
      7  2a48					      SUBROUTINE
      3  2a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2a60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2a78		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$00,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$f8,$a8,$b8,$d8,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2a90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_0.asm"
      0  2a90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_0", 72
     12  2a90					      LIST	ON
      0  2a90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_0
      1  2a90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2a90				   BLACK_BLANK_on_WHITE_SQUARE_0
      3  2a90				   TEMPORARY_VAR SET	Overlay
      4  2a90				   TEMPORARY_OFFSET SET	0
      5  2a90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2a90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_0
      7  2a90					      SUBROUTINE
      3  2a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f0,$f0,$f0,$f0,$f0,$f0,$f0,$f0	;PF0
      4  2aa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$80,$80,$80,$80,$80	;PF1
      5  2ac0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2ad8					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_1.asm"
      0  2ad8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_1", 72
     12  2b00					      LIST	ON
      0  2b00					      DEF	BLACK_BLANK_on_WHITE_SQUARE_1
      1  2b00				   BANK_BLACK_BLANK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2b00				   BLACK_BLANK_on_WHITE_SQUARE_1
      3  2b00				   TEMPORARY_VAR SET	Overlay
      4  2b00				   TEMPORARY_OFFSET SET	0
      5  2b00				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2b00				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_1
      7  2b00					      SUBROUTINE
      3  2b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7c,$7c,$7c,$7c,$7c,$7c,$7c,$7c	;PF1
      5  2b30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2b48					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_2.asm"
      0  2b48					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_2", 72
     12  2b48					      LIST	ON
      0  2b48					      DEF	BLACK_BLANK_on_WHITE_SQUARE_2
      1  2b48				   BANK_BLACK_BLANK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2b48				   BLACK_BLANK_on_WHITE_SQUARE_2
      3  2b48				   TEMPORARY_VAR SET	Overlay
      4  2b48				   TEMPORARY_OFFSET SET	0
      5  2b48				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2b48				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_2
      7  2b48					      SUBROUTINE
      3  2b48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2b60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$03,$03,$03,$03,$03,$03,$03,$03	;PF1
      5  2b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$07,$07,$07,$07,$07,$07,$07,$07	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2b90					      include	"gfx/BLACK_BLANK_on_WHITE_SQUARE_3.asm"
      0  2b90					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_WHITE_SQUARE_3", 72
     12  2b90					      LIST	ON
      0  2b90					      DEF	BLACK_BLANK_on_WHITE_SQUARE_3
      1  2b90				   BANK_BLACK_BLANK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2b90				   BLACK_BLANK_on_WHITE_SQUARE_3
      3  2b90				   TEMPORARY_VAR SET	Overlay
      4  2b90				   TEMPORARY_OFFSET SET	0
      5  2b90				   VAR_BOUNDARY_BLACK_BLANK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2b90				   FUNCTION_NAME SET	BLACK_BLANK_on_WHITE_SQUARE_3
      7  2b90					      SUBROUTINE
      3  2b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ba8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$f8,$f8,$f8,$f8,$f8,$f8,$f8,$f8	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2bd8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_0.asm"
      0  2bd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_0", 72
     12  2c00					      LIST	ON
      0  2c00					      DEF	BLACK_PAWN_on_WHITE_SQUARE_0
      1  2c00				   BANK_BLACK_PAWN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2c00				   BLACK_PAWN_on_WHITE_SQUARE_0
      3  2c00				   TEMPORARY_VAR SET	Overlay
      4  2c00				   TEMPORARY_OFFSET SET	0
      5  2c00				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2c00				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_0
      7  2c00					      SUBROUTINE
      3  2c00		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$00,$00,$00,$e0,$40,$40,$e0,$40,$40,$00	;PF0
      4  2c18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2c30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2c48					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_1.asm"
      0  2c48					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_1", 72
     12  2c48					      LIST	ON
      0  2c48					      DEF	BLACK_PAWN_on_WHITE_SQUARE_1
      1  2c48				   BANK_BLACK_PAWN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2c48				   BLACK_PAWN_on_WHITE_SQUARE_1
      3  2c48				   TEMPORARY_VAR SET	Overlay
      4  2c48				   TEMPORARY_OFFSET SET	0
      5  2c48				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2c48				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_1
      7  2c48					      SUBROUTINE
      3  2c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2c60		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$00,$00,$00,$38,$10,$10,$38,$10,$10,$00	;PF1
      5  2c78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2c90					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_2.asm"
      0  2c90					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_2", 72
     12  2c90					      LIST	ON
      0  2c90					      DEF	BLACK_PAWN_on_WHITE_SQUARE_2
      1  2c90				   BANK_BLACK_PAWN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2c90				   BLACK_PAWN_on_WHITE_SQUARE_2
      3  2c90				   TEMPORARY_VAR SET	Overlay
      4  2c90				   TEMPORARY_OFFSET SET	0
      5  2c90				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2c90				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_2
      7  2c90					      SUBROUTINE
      3  2c90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2ca8		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00	;PF1
      5  2cc0		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$00,$00,$00,$03,$01,$01,$03,$01,$01,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2cd8					      include	"gfx/BLACK_PAWN_on_WHITE_SQUARE_3.asm"
      0  2cd8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_WHITE_SQUARE_3", 72
     12  2d00					      LIST	ON
      0  2d00					      DEF	BLACK_PAWN_on_WHITE_SQUARE_3
      1  2d00				   BANK_BLACK_PAWN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2d00				   BLACK_PAWN_on_WHITE_SQUARE_3
      3  2d00				   TEMPORARY_VAR SET	Overlay
      4  2d00				   TEMPORARY_OFFSET SET	0
      5  2d00				   VAR_BOUNDARY_BLACK_PAWN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2d00				   FUNCTION_NAME SET	BLACK_PAWN_on_WHITE_SQUARE_3
      7  2d00					      SUBROUTINE
      3  2d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2d18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2d30		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$00,$00,$00,$70,$20,$20,$70,$20,$20,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2d48					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_0.asm"
      0  2d48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_0", 72
     12  2d48					      LIST	ON
      0  2d48					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_0
      1  2d48				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2d48				   BLACK_KNIGHT_on_WHITE_SQUARE_0
      3  2d48				   TEMPORARY_VAR SET	Overlay
      4  2d48				   TEMPORARY_OFFSET SET	0
      5  2d48				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2d48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_0
      7  2d48					      SUBROUTINE
      3  2d48		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00	;PF0
      4  2d60		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$80,$00,$00,$80,$80,$80,$80,$00	;PF1
      5  2d78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2d90					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_1.asm"
      0  2d90					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_1", 72
     12  2d90					      LIST	ON
      0  2d90					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_1
      1  2d90				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2d90				   BLACK_KNIGHT_on_WHITE_SQUARE_1
      3  2d90				   TEMPORARY_VAR SET	Overlay
      4  2d90				   TEMPORARY_OFFSET SET	0
      5  2d90				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2d90				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_1
      7  2d90					      SUBROUTINE
      3  2d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2da8		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$7c,$70,$38,$1c,$7c,$6c,$14,$00	;PF1
      5  2dc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2dd8					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_2.asm"
      0  2dd8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_2", 72
     12  2e00					      LIST	ON
      0  2e00					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_2
      1  2e00				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2e00				   BLACK_KNIGHT_on_WHITE_SQUARE_2
      3  2e00				   TEMPORARY_VAR SET	Overlay
      4  2e00				   TEMPORARY_OFFSET SET	0
      5  2e00				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2e00				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_2
      7  2e00					      SUBROUTINE
      3  2e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e18		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00	;PF1
      5  2e30		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$07,$01,$03,$07,$07,$06,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2e48					      include	"gfx/BLACK_KNIGHT_on_WHITE_SQUARE_3.asm"
      0  2e48					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_WHITE_SQUARE_3", 72
     12  2e48					      LIST	ON
      0  2e48					      DEF	BLACK_KNIGHT_on_WHITE_SQUARE_3
      1  2e48				   BANK_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2e48				   BLACK_KNIGHT_on_WHITE_SQUARE_3
      3  2e48				   TEMPORARY_VAR SET	Overlay
      4  2e48				   TEMPORARY_OFFSET SET	0
      5  2e48				   VAR_BOUNDARY_BLACK_KNIGHT_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2e48				   FUNCTION_NAME SET	BLACK_KNIGHT_on_WHITE_SQUARE_3
      7  2e48					      SUBROUTINE
      3  2e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2e78		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$f8,$38,$70,$e0,$f8,$d8,$a0,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  2e90					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_0.asm"
      0  2e90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_0", 72
     12  2e90					      LIST	ON
      0  2e90					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_0
      1  2e90				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  2e90				   BLACK_BISHOP_on_WHITE_SQUARE_0
      3  2e90				   TEMPORARY_VAR SET	Overlay
      4  2e90				   TEMPORARY_OFFSET SET	0
      5  2e90				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  2e90				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_0
      7  2e90					      SUBROUTINE
      3  2e90		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$f0,$e0,$f0,$f0,$f0,$e0,$00,$40	;PF0
      4  2ea8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$80,$80,$00,$00,$00	;PF1
      5  2ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  2ed8					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_1.asm"
      0  2ed8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_1", 72
     12  2f00					      LIST	ON
      0  2f00					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_1
      1  2f00				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  2f00				   BLACK_BISHOP_on_WHITE_SQUARE_1
      3  2f00				   TEMPORARY_VAR SET	Overlay
      4  2f00				   TEMPORARY_OFFSET SET	0
      5  2f00				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  2f00				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_1
      7  2f00					      SUBROUTINE
      3  2f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f18		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$7c,$38,$78,$7c,$7c,$38,$00,$10	;PF1
      5  2f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  2f48					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_2.asm"
      0  2f48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_2", 72
     12  2f48					      LIST	ON
      0  2f48					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_2
      1  2f48				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  2f48				   BLACK_BISHOP_on_WHITE_SQUARE_2
      3  2f48				   TEMPORARY_VAR SET	Overlay
      4  2f48				   TEMPORARY_OFFSET SET	0
      5  2f48				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  2f48				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_2
      7  2f48					      SUBROUTINE
      3  2f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2f60		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$03,$01,$00,$00	;PF1
      5  2f78		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$07,$03,$03,$07,$07,$03,$00,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  2f90					      include	"gfx/BLACK_BISHOP_on_WHITE_SQUARE_3.asm"
      0  2f90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_WHITE_SQUARE_3", 72
     12  2f90					      LIST	ON
      0  2f90					      DEF	BLACK_BISHOP_on_WHITE_SQUARE_3
      1  2f90				   BANK_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  2f90				   BLACK_BISHOP_on_WHITE_SQUARE_3
      3  2f90				   TEMPORARY_VAR SET	Overlay
      4  2f90				   TEMPORARY_OFFSET SET	0
      5  2f90				   VAR_BOUNDARY_BLACK_BISHOP_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  2f90				   FUNCTION_NAME SET	BLACK_BISHOP_on_WHITE_SQUARE_3
      7  2f90					      SUBROUTINE
      3  2f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  2fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  2fc0		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$f8,$70,$78,$f8,$f8,$70,$00,$20	;PF2
------- FILE piece_graphics.asm
      0  2fd8					      CHECK_BANK_SIZE	"PIECE_2 (2K)"
      1  2fd8		       07 d8	   .TEMP      =	* - BANK_START
 PIECE_2 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  2fd8					      ECHO	"PIECE_2 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fd8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  2fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fd8				  -	      ERR
      6  2fd8					      ENDIF
      7  2fd8
      0  2fd8					      NEWBANK	PIECES_3
      1  37d8 ????				      SEG	PIECES_3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   PIECES_3   SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	PIECES_3
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  3000					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_0.asm"
      0  3000					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_0", 72
     12  3000					      LIST	ON
      0  3000					      DEF	BLACK_ROOK_on_WHITE_SQUARE_0
      1  3000				   BANK_BLACK_ROOK_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3000				   BLACK_ROOK_on_WHITE_SQUARE_0
      3  3000				   TEMPORARY_VAR SET	Overlay
      4  3000				   TEMPORARY_OFFSET SET	0
      5  3000				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3000				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_0
      7  3000					      SUBROUTINE
      3  3000		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$f0,$e0,$e0,$e0,$f0,$50,$50,$00	;PF0
      4  3018		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$80,$80,$80,$00	;PF1
      5  3030		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  3048					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_1.asm"
      0  3048					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_1", 72
     12  3048					      LIST	ON
      0  3048					      DEF	BLACK_ROOK_on_WHITE_SQUARE_1
      1  3048				   BANK_BLACK_ROOK_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3048				   BLACK_ROOK_on_WHITE_SQUARE_1
      3  3048				   TEMPORARY_VAR SET	Overlay
      4  3048				   TEMPORARY_OFFSET SET	0
      5  3048				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3048				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_1
      7  3048					      SUBROUTINE
      3  3048		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3060		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$7c,$38,$38,$38,$7c,$54,$54,$00	;PF1
      5  3078		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  3090					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_2.asm"
      0  3090					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_2", 72
     12  3090					      LIST	ON
      0  3090					      DEF	BLACK_ROOK_on_WHITE_SQUARE_2
      1  3090				   BANK_BLACK_ROOK_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3090				   BLACK_ROOK_on_WHITE_SQUARE_2
      3  3090				   TEMPORARY_VAR SET	Overlay
      4  3090				   TEMPORARY_OFFSET SET	0
      5  3090				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3090				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_2
      7  3090					      SUBROUTINE
      3  3090		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  30a8		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$03,$01,$01,$01,$03,$02,$02,$00	;PF1
      5  30c0		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$07,$03,$03,$03,$07,$05,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  30d8					      include	"gfx/BLACK_ROOK_on_WHITE_SQUARE_3.asm"
      0  30d8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_WHITE_SQUARE_3", 72
     12  3100					      LIST	ON
      0  3100					      DEF	BLACK_ROOK_on_WHITE_SQUARE_3
      1  3100				   BANK_BLACK_ROOK_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3100				   BLACK_ROOK_on_WHITE_SQUARE_3
      3  3100				   TEMPORARY_VAR SET	Overlay
      4  3100				   TEMPORARY_OFFSET SET	0
      5  3100				   VAR_BOUNDARY_BLACK_ROOK_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3100				   FUNCTION_NAME SET	BLACK_ROOK_on_WHITE_SQUARE_3
      7  3100					      SUBROUTINE
      3  3100		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3118		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3130		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$f8,$70,$70,$70,$f8,$a8,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  3148					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_0.asm"
      0  3148					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_0", 72
     12  3148					      LIST	ON
      0  3148					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_0
      1  3148				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3148				   BLACK_QUEEN_on_WHITE_SQUARE_0
      3  3148				   TEMPORARY_VAR SET	Overlay
      4  3148				   TEMPORARY_OFFSET SET	0
      5  3148				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3148				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_0
      7  3148					      SUBROUTINE
      3  3148		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$e0,$e0,$f0,$f0,$50,$00,$50,$00	;PF0
      4  3160		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$80,$80,$00,$80,$00	;PF1
      5  3178		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  3190					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_1.asm"
      0  3190					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_1", 72
     12  3190					      LIST	ON
      0  3190					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_1
      1  3190				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3190				   BLACK_QUEEN_on_WHITE_SQUARE_1
      3  3190				   TEMPORARY_VAR SET	Overlay
      4  3190				   TEMPORARY_OFFSET SET	0
      5  3190				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3190				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_1
      7  3190					      SUBROUTINE
      3  3190		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  31a8		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$38,$38,$78,$7c,$54,$00,$54,$00	;PF1
      5  31c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  31d8					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_2.asm"
      0  31d8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_2", 72
     12  3200					      LIST	ON
      0  3200					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_2
      1  3200				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3200				   BLACK_QUEEN_on_WHITE_SQUARE_2
      3  3200				   TEMPORARY_VAR SET	Overlay
      4  3200				   TEMPORARY_OFFSET SET	0
      5  3200				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3200				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_2
      7  3200					      SUBROUTINE
      3  3200		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3218		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$01,$01,$03,$03,$02,$00,$02,$00	;PF1
      5  3230		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$03,$03,$03,$07,$05,$00,$05,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  3248					      include	"gfx/BLACK_QUEEN_on_WHITE_SQUARE_3.asm"
      0  3248					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_WHITE_SQUARE_3", 72
     12  3248					      LIST	ON
      0  3248					      DEF	BLACK_QUEEN_on_WHITE_SQUARE_3
      1  3248				   BANK_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3248				   BLACK_QUEEN_on_WHITE_SQUARE_3
      3  3248				   TEMPORARY_VAR SET	Overlay
      4  3248				   TEMPORARY_OFFSET SET	0
      5  3248				   VAR_BOUNDARY_BLACK_QUEEN_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3248				   FUNCTION_NAME SET	BLACK_QUEEN_on_WHITE_SQUARE_3
      7  3248					      SUBROUTINE
      3  3248		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3260		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3278		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$70,$70,$78,$f8,$a8,$00,$a8,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_0.asm LEVEL 4 PASS 5
      0  3290					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_0.asm"
      0  3290					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_0", 72
     12  3290					      LIST	ON
      0  3290					      DEF	BLACK_KING_on_WHITE_SQUARE_0
      1  3290				   BANK_BLACK_KING_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3290				   BLACK_KING_on_WHITE_SQUARE_0
      3  3290				   TEMPORARY_VAR SET	Overlay
      4  3290				   TEMPORARY_OFFSET SET	0
      5  3290				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3290				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_0
      7  3290					      SUBROUTINE
      3  3290		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$e0,$e0,$50,$f0,$f0,$40,$e0,$40	;PF0
      4  32a8		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$80,$80,$00,$00,$00	;PF1
      5  32c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_1.asm LEVEL 4 PASS 5
      0  32d8					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_1.asm"
      0  32d8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_1", 72
     12  3300					      LIST	ON
      0  3300					      DEF	BLACK_KING_on_WHITE_SQUARE_1
      1  3300				   BANK_BLACK_KING_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3300				   BLACK_KING_on_WHITE_SQUARE_1
      3  3300				   TEMPORARY_VAR SET	Overlay
      4  3300				   TEMPORARY_OFFSET SET	0
      5  3300				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3300				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_1
      7  3300					      SUBROUTINE
      3  3300		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3318		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$38,$38,$54,$7c,$7c,$10,$38,$10	;PF1
      5  3330		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_2.asm LEVEL 4 PASS 5
      0  3348					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_2.asm"
      0  3348					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_2", 72
     12  3348					      LIST	ON
      0  3348					      DEF	BLACK_KING_on_WHITE_SQUARE_2
      1  3348				   BANK_BLACK_KING_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3348				   BLACK_KING_on_WHITE_SQUARE_2
      3  3348				   TEMPORARY_VAR SET	Overlay
      4  3348				   TEMPORARY_OFFSET SET	0
      5  3348				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3348				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_2
      7  3348					      SUBROUTINE
      3  3348		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3360		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$01,$01,$02,$03,$03,$00,$01,$00	;PF1
      5  3378		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$03,$03,$05,$07,$07,$01,$03,$01	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KING_on_WHITE_SQUARE_3.asm LEVEL 4 PASS 5
      0  3390					      include	"gfx/BLACK_KING_on_WHITE_SQUARE_3.asm"
      0  3390					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_WHITE_SQUARE_3", 72
     12  3390					      LIST	ON
      0  3390					      DEF	BLACK_KING_on_WHITE_SQUARE_3
      1  3390				   BANK_BLACK_KING_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3390				   BLACK_KING_on_WHITE_SQUARE_3
      3  3390				   TEMPORARY_VAR SET	Overlay
      4  3390				   TEMPORARY_OFFSET SET	0
      5  3390				   VAR_BOUNDARY_BLACK_KING_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3390				   FUNCTION_NAME SET	BLACK_KING_on_WHITE_SQUARE_3
      7  3390					      SUBROUTINE
      3  3390		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  33a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  33c0		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$70,$70,$a8,$f8,$f8,$20,$70,$20	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  33d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_0.asm"
      0  33d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_0", 72
     12  3400					      LIST	ON
      0  3400					      DEF	BLACK_BLANK_on_BLACK_SQUARE_0
      1  3400				   BANK_BLACK_BLANK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3400				   BLACK_BLANK_on_BLACK_SQUARE_0
      3  3400				   TEMPORARY_VAR SET	Overlay
      4  3400				   TEMPORARY_OFFSET SET	0
      5  3400				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3400				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_0
      7  3400					      SUBROUTINE
      3  3400		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  3448					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_1.asm"
      0  3448					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_1", 72
     12  3448					      LIST	ON
      0  3448					      DEF	BLACK_BLANK_on_BLACK_SQUARE_1
      1  3448				   BANK_BLACK_BLANK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3448				   BLACK_BLANK_on_BLACK_SQUARE_1
      3  3448				   TEMPORARY_VAR SET	Overlay
      4  3448				   TEMPORARY_OFFSET SET	0
      5  3448				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3448				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_1
      7  3448					      SUBROUTINE
      3  3448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3460		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  3490					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_2.asm"
      0  3490					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_2", 72
     12  3490					      LIST	ON
      0  3490					      DEF	BLACK_BLANK_on_BLACK_SQUARE_2
      1  3490				   BANK_BLACK_BLANK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3490				   BLACK_BLANK_on_BLACK_SQUARE_2
      3  3490				   TEMPORARY_VAR SET	Overlay
      4  3490				   TEMPORARY_OFFSET SET	0
      5  3490				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3490				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_2
      7  3490					      SUBROUTINE
      3  3490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  34a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  34c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  34d8					      include	"gfx/BLACK_BLANK_on_BLACK_SQUARE_3.asm"
      0  34d8					      OPTIONAL_PAGEBREAK	"BLACK_BLANK_on_BLACK_SQUARE_3", 72
     12  3500					      LIST	ON
      0  3500					      DEF	BLACK_BLANK_on_BLACK_SQUARE_3
      1  3500				   BANK_BLACK_BLANK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3500				   BLACK_BLANK_on_BLACK_SQUARE_3
      3  3500				   TEMPORARY_VAR SET	Overlay
      4  3500				   TEMPORARY_OFFSET SET	0
      5  3500				   VAR_BOUNDARY_BLACK_BLANK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3500				   FUNCTION_NAME SET	BLACK_BLANK_on_BLACK_SQUARE_3
      7  3500					      SUBROUTINE
      3  3500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3530		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  3548					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_0.asm"
      0  3548					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_0", 72
     12  3548					      LIST	ON
      0  3548					      DEF	BLACK_PAWN_on_BLACK_SQUARE_0
      1  3548				   BANK_BLACK_PAWN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3548				   BLACK_PAWN_on_BLACK_SQUARE_0
      3  3548				   TEMPORARY_VAR SET	Overlay
      4  3548				   TEMPORARY_OFFSET SET	0
      5  3548				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3548				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_0
      7  3548					      SUBROUTINE
      3  3548		       e0 e0 40 40*	      .byte.b	$e0,$e0,$40,$40,$e0,$40,$40,$00,$00,$e0,$40,$40,$e0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  3590					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_1.asm"
      0  3590					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_1", 72
     12  3590					      LIST	ON
      0  3590					      DEF	BLACK_PAWN_on_BLACK_SQUARE_1
      1  3590				   BANK_BLACK_PAWN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3590				   BLACK_PAWN_on_BLACK_SQUARE_1
      3  3590				   TEMPORARY_VAR SET	Overlay
      4  3590				   TEMPORARY_OFFSET SET	0
      5  3590				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3590				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_1
      7  3590					      SUBROUTINE
      3  3590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  35a8		       38 38 10 10*	      .byte.b	$38,$38,$10,$10,$38,$10,$10,$00,$00,$38,$10,$10,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  35c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  35d8					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_2.asm"
      0  35d8					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_2", 72
     12  3600					      LIST	ON
      0  3600					      DEF	BLACK_PAWN_on_BLACK_SQUARE_2
      1  3600				   BANK_BLACK_PAWN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3600				   BLACK_PAWN_on_BLACK_SQUARE_2
      3  3600				   TEMPORARY_VAR SET	Overlay
      4  3600				   TEMPORARY_OFFSET SET	0
      5  3600				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3600				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_2
      7  3600					      SUBROUTINE
      3  3600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3618		       01 01 00 00*	      .byte.b	$01,$01,$00,$00,$01,$00,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3630		       03 03 01 01*	      .byte.b	$03,$03,$01,$01,$03,$01,$01,$00,$00,$03,$01,$01,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  3648					      include	"gfx/BLACK_PAWN_on_BLACK_SQUARE_3.asm"
      0  3648					      OPTIONAL_PAGEBREAK	"BLACK_PAWN_on_BLACK_SQUARE_3", 72
     12  3648					      LIST	ON
      0  3648					      DEF	BLACK_PAWN_on_BLACK_SQUARE_3
      1  3648				   BANK_BLACK_PAWN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3648				   BLACK_PAWN_on_BLACK_SQUARE_3
      3  3648				   TEMPORARY_VAR SET	Overlay
      4  3648				   TEMPORARY_OFFSET SET	0
      5  3648				   VAR_BOUNDARY_BLACK_PAWN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3648				   FUNCTION_NAME SET	BLACK_PAWN_on_BLACK_SQUARE_3
      7  3648					      SUBROUTINE
      3  3648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3678		       70 70 20 20*	      .byte.b	$70,$70,$20,$20,$70,$20,$20,$00,$00,$70,$20,$20,$70,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm LEVEL 4 PASS 5
      0  3690					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_0.asm"
      0  3690					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_0", 72
     12  3690					      LIST	ON
      0  3690					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_0
      1  3690				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3690				   BLACK_KNIGHT_on_BLACK_SQUARE_0
      3  3690				   TEMPORARY_VAR SET	Overlay
      4  3690				   TEMPORARY_OFFSET SET	0
      5  3690				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3690				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_0
      7  3690					      SUBROUTINE
      3  3690		       f0 f0 e0 f0*	      .byte.b	$f0,$f0,$e0,$f0,$f0,$a0,$40,$00,$f0,$70,$e0,$c0,$f0,$b0,$40,$00,$00,$00,$00,$00,$00,$40,$00,$00	;PF0
      4  36a8		       80 00 80 80*	      .byte.b	$80,$00,$80,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  36c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm LEVEL 4 PASS 5
      0  36d8					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_1.asm"
      0  36d8					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_1", 72
     12  3700					      LIST	ON
      0  3700					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_1
      1  3700				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3700				   BLACK_KNIGHT_on_BLACK_SQUARE_1
      3  3700				   TEMPORARY_VAR SET	Overlay
      4  3700				   TEMPORARY_OFFSET SET	0
      5  3700				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3700				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_1
      7  3700					      SUBROUTINE
      3  3700		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3718		       7c 78 3c 7c*	      .byte.b	$7c,$78,$3c,$7c,$7c,$2c,$14,$00,$7c,$70,$38,$18,$78,$68,$14,$00,$00,$00,$00,$00,$00,$10,$00,$00	;PF1
      5  3730		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm LEVEL 4 PASS 5
      0  3748					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_2.asm"
      0  3748					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_2", 72
     12  3748					      LIST	ON
      0  3748					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_2
      1  3748				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3748				   BLACK_KNIGHT_on_BLACK_SQUARE_2
      3  3748				   TEMPORARY_VAR SET	Overlay
      4  3748				   TEMPORARY_OFFSET SET	0
      5  3748				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3748				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_2
      7  3748					      SUBROUTINE
      3  3748		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3760		       03 03 01 03*	      .byte.b	$03,$03,$01,$03,$03,$01,$00,$00,$03,$03,$01,$00,$03,$03,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3778		       07 03 07 07*	      .byte.b	$07,$03,$07,$07,$07,$06,$05,$00,$07,$01,$03,$03,$03,$02,$05,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF2
------- FILE piece_graphics.asm
------- FILE gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm LEVEL 4 PASS 5
      0  3790					      include	"gfx/BLACK_KNIGHT_on_BLACK_SQUARE_3.asm"
      0  3790					      OPTIONAL_PAGEBREAK	"BLACK_KNIGHT_on_BLACK_SQUARE_3", 72
     12  3790					      LIST	ON
      0  3790					      DEF	BLACK_KNIGHT_on_BLACK_SQUARE_3
      1  3790				   BANK_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3790				   BLACK_KNIGHT_on_BLACK_SQUARE_3
      3  3790				   TEMPORARY_VAR SET	Overlay
      4  3790				   TEMPORARY_OFFSET SET	0
      5  3790				   VAR_BOUNDARY_BLACK_KNIGHT_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3790				   FUNCTION_NAME SET	BLACK_KNIGHT_on_BLACK_SQUARE_3
      7  3790					      SUBROUTINE
      3  3790		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  37a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  37c0		       f8 78 f0 f8*	      .byte.b	$f8,$78,$f0,$f8,$f8,$d0,$a0,$00,$f8,$38,$70,$60,$78,$58,$a0,$00,$00,$00,$00,$00,$00,$20,$00,$00	;PF2
------- FILE piece_graphics.asm
      0  37d8					      CHECK_BANK_SIZE	"PIECES_3 (2K)"
      1  37d8		       07 d8	   .TEMP      =	* - BANK_START
 PIECES_3 (2K) (2K) SIZE =  $7d8 , FREE= $28
      2  37d8					      ECHO	"PIECES_3 (2K)", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  37d8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  37d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  37d8				  -	      ERR
      6  37d8					      ENDIF
      7  37d8
    107  37d8							;    NEWBANK PIECES_4
    108  37d8
    109  37d8							;    CHECK_BANK_SIZE "PIECES_4 (2K)"
    110  37d8
    111  37d8							;    NEWBANK PIECES_5
    112  37d8
    113  37d8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_0.asm"
    114  37d8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_1.asm"
    115  37d8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_2.asm"
    116  37d8							; include "gfx/BLACK_PROMOTE_on_BLACK_SQUARE_3.asm"
    117  37d8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_0.asm"
    118  37d8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_1.asm"
    119  37d8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_2.asm"
    120  37d8							; include "gfx/BLACK_PROMOTE_on_WHITE_SQUARE_3.asm"
    121  37d8
    122  37d8
    123  37d8				  -	      IF	0
    124  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    125  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    126  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    127  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    128  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    129  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    130  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    131  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    132  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    133  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    134  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    135  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    136  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    137  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    138  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    139  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    140  37d8					      ENDIF
    141  37d8
    142  37d8							;    CHECK_BANK_SIZE "PIECES_5 (2K)"
    143  37d8
    144  37d8				  -	      IF	0
    145  37d8				  -	      NEWBANK	PIECES_6
    146  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    147  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    148  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    149  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    150  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    151  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    152  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    153  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    154  37d8				  -
    155  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_0.asm"
    156  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_1.asm"
    157  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_2.asm"
    158  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_WHITE_SQUARE_3.asm"
    159  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    160  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    161  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    162  37d8				  -	      include	"gfx/WHITE_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    163  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    164  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    165  37d8				  -
    166  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    167  37d8				  -	      include	"gfx/WHITE_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    168  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    169  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    170  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    171  37d8				  -	      include	"gfx/WHITE_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    172  37d8				  -	      CHECK_BANK_SIZE	"PIECES_6 (2K)"
    173  37d8				  -
    174  37d8				  -
    175  37d8				  -	      NEWBANK	PIECES_7
    176  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    177  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    178  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    179  37d8				  -	      include	"gfx/WHITE_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    180  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    181  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    182  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    183  37d8				  -	      include	"gfx/WHITE_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    184  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    185  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    186  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    187  37d8				  -	      include	"gfx/WHITE_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    188  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_0.asm"
    189  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_1.asm"
    190  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_2.asm"
    191  37d8				  -	      include	"gfx/WHITE_MARKED_KING_on_BLACK_SQUARE_3.asm"
    192  37d8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_0.asm"
    193  37d8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_1.asm"
    194  37d8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_2.asm"
    195  37d8				  -	      include	"gfx/BLACK_MARKED_BLANK_on_WHITE_SQUARE_3.asm"
    196  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_0.asm"
    197  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_1.asm"
    198  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_2.asm"
    199  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_WHITE_SQUARE_3.asm"
    200  37d8				  -	      CHECK_BANK_SIZE	"PIECES_7 (2K)"
    201  37d8				  -
    202  37d8				  -
    203  37d8				  -	      NEWBANK	PIECES_8
    204  37d8				  -
    205  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_0.asm"
    206  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_1.asm"
    207  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_2.asm"
    208  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_WHITE_SQUARE_3.asm"
    209  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_0.asm"
    210  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_1.asm"
    211  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_2.asm"
    212  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_WHITE_SQUARE_3.asm"
    213  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_0.asm"
    214  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_1.asm"
    215  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_2.asm"
    216  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_WHITE_SQUARE_3.asm"
    217  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_0.asm"
    218  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_1.asm"
    219  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_2.asm"
    220  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_WHITE_SQUARE_3.asm"
    221  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_0.asm"
    222  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_1.asm"
    223  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_2.asm"
    224  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_WHITE_SQUARE_3.asm"
    225  37d8				  -
    226  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_0.asm"
    227  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_1.asm"
    228  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_2.asm"
    229  37d8				  -	      include	"gfx/BLACK_MARKED_PAWN_on_BLACK_SQUARE_3.asm"
    230  37d8				  -	      CHECK_BANK_SIZE	"PIECES_8 (2K)"
    231  37d8				  -
    232  37d8					      ENDIF
    233  37d8
    234  37d8							;    NEWBANK PIECES_9
    235  37d8
    236  37d8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_0.asm"
    237  37d8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_1.asm"
    238  37d8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_2.asm"
    239  37d8							; include "gfx/BLACK_MARKED_BLANK_on_BLACK_SQUARE_3.asm"
    240  37d8							; include "gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_0.asm"
    241  37d8
    242  37d8				  -	      IF	0
    243  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_1.asm"
    244  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_2.asm"
    245  37d8				  -	      include	"gfx/BLACK_MARKED_KNIGHT_on_BLACK_SQUARE_3.asm"
    246  37d8					      ENDIF
    247  37d8
    248  37d8							;    CHECK_BANK_SIZE "PIECES_9 (2K)"
    249  37d8
    250  37d8				  -	      IF	0
    251  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_0.asm"
    252  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_1.asm"
    253  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_2.asm"
    254  37d8				  -	      include	"gfx/BLACK_MARKED_BISHOP_on_BLACK_SQUARE_3.asm"
    255  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_0.asm"
    256  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_1.asm"
    257  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_2.asm"
    258  37d8				  -	      include	"gfx/BLACK_MARKED_ROOK_on_BLACK_SQUARE_3.asm"
    259  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_0.asm"
    260  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_1.asm"
    261  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_2.asm"
    262  37d8				  -	      include	"gfx/BLACK_MARKED_QUEEN_on_BLACK_SQUARE_3.asm"
    263  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_0.asm"
    264  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_1.asm"
    265  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_2.asm"
    266  37d8				  -	      include	"gfx/BLACK_MARKED_KING_on_BLACK_SQUARE_3.asm"
    267  37d8					      ENDIF
------- FILE BANK_CHESS_INCLUDES.asm
     38  37d8
     39  37d8							;    NEWBANK PIECE_VECTORS
     40  37d8							;    include "piece_vectors.asm"
     41  37d8							;    CHECK_BANK_SIZE "PIECE_VECTORS (2K)"
------- FILE ./chess.asm
------- FILE BANK_StateMachine.asm LEVEL 2 PASS 5
      0  37d8					      include	"BANK_StateMachine.asm"
      0  37d8					      NEWBANK	STATEMACHINE
      1  3fd8 ????				      SEG	STATEMACHINE
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   STATEMACHINE SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	STATEMACHINE
      2  3800
      3  3800
      4  3800							; Banks holding data (ply 0 doubles as WHITE, and ply 1 as BLACK)
      5  3800
      6  3800
      7  3800		       00 10	   CURSOR_MOVE_SPEED =	16
      8  3800		       00 14	   CAP_SPEED  =	20
      9  3800		       00 28	   HOLD_DELAY =	40
     10  3800
     11  3800
     12  3800							;---------------------------------------------------------------------------------------------------
     13  3800
     14  3800				   P	      SET	0
     15  3800					      MAC	ain
     16  3800				   AI_{1}     SET	P
     17  3800				   P	      SET	P+1
     18  3800					      ENDM
     19  3800
     20  3800					      MAC	lo
     21  3800					      .byte	<ai{1}
     22  3800					      ENDM
     23  3800
     24  3800					      MAC	hi
     25  3800					      .byte	>ai{1}
     26  3800					      ENDM
     27  3800
     28  3800					      MAC	bk
     29  3800					      .byte	BANK_ai{1}
     30  3800					      ENDM
     31  3800
     32  3800
     33  3800		       00 28	   ONCEPERFRAME =	40
     34  3800
     35  3800					      MAC	tabdef
     36  3800
     37  3800					      {1}	FlashComputerMove
     38  3800					      {1}	BeginSelectMovePhase
     39  3800					      {1}	SelectStartSquare
     40  3800					      {1}	StartSquareSelected
     41  3800					      {1}	DrawMoves
     42  3800					      {1}	ShowMoveCaptures
     43  3800					      {1}	SlowFlash
     44  3800					      {1}	UnDrawTargetSquares
     45  3800					      {1}	SelectDestinationSquare
     46  3800					      {1}	Quiescent
     47  3800					      {1}	ReselectDebounce
     48  3800					      {1}	StartMoveGen
     49  3800					      {1}	StepMoveGen
     50  3800					      {1}	StartClearBoard
     51  3800					      {1}	ClearEachRow
     52  3800					      {1}	DrawEntireBoard
     53  3800					      {1}	DrawPart2
     54  3800					      {1}	DrawPart3
     55  3800					      {1}	GenerateMoves
     56  3800					      {1}	ComputerMove
     57  3800					      {1}	MoveIsSelected
     58  3800					      {1}	WriteStartPieceBlank
     59  3800					      {1}	MarchToTargetA
     60  3800					      {1}	MarchA2
     61  3800					      {1}	MarchB
     62  3800					      {1}	MarchToTargetB
     63  3800					      {1}	MarchB2
     64  3800					      {1}	FinalFlash
     65  3800					      {1}	SpecialMoveFixup
     66  3800					      {1}	InCheckBackup
     67  3800					      {1}	InCheckDelay
     68  3800					      {1}	PromotePawnStart
     69  3800					      {1}	RollPromotionPiece
     70  3800					      {1}	ChoosePromotePiece
     71  3800					      {1}	ChooseDebounce
     72  3800					      {1}	CheckMate
     73  3800					      {1}	Draw
     74  3800					      {1}	DelayAfterMove
     75  3800					      {1}	DelayAfterMove2
     76  3800					      {1}	DelayAfterPlaced
     77  3800					      {1}	DelayAfterPlaced2
     78  3800
     79  3800					      ENDM		; {1} = macro to use
     80  3800
      0  3800					      TABDEF	AIN
      1  3800
      0  3800					      AIN	FlashComputerMove
      1  3800				   AI_FlashComputerMove SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	BeginSelectMovePhase
      1  3800				   AI_BeginSelectMovePhase SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	SelectStartSquare
      1  3800				   AI_SelectStartSquare SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	StartSquareSelected
      1  3800				   AI_StartSquareSelected SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DrawMoves
      1  3800				   AI_DrawMoves SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ShowMoveCaptures
      1  3800				   AI_ShowMoveCaptures SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	SlowFlash
      1  3800				   AI_SlowFlash SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	UnDrawTargetSquares
      1  3800				   AI_UnDrawTargetSquares SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	SelectDestinationSquare
      1  3800				   AI_SelectDestinationSquare SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	Quiescent
      1  3800				   AI_Quiescent SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ReselectDebounce
      1  3800				   AI_ReselectDebounce SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	StartMoveGen
      1  3800				   AI_StartMoveGen SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	StepMoveGen
      1  3800				   AI_StepMoveGen SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	StartClearBoard
      1  3800				   AI_StartClearBoard SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ClearEachRow
      1  3800				   AI_ClearEachRow SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DrawEntireBoard
      1  3800				   AI_DrawEntireBoard SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DrawPart2
      1  3800				   AI_DrawPart2 SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DrawPart3
      1  3800				   AI_DrawPart3 SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	GenerateMoves
      1  3800				   AI_GenerateMoves SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ComputerMove
      1  3800				   AI_ComputerMove SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MoveIsSelected
      1  3800				   AI_MoveIsSelected SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	WriteStartPieceBlank
      1  3800				   AI_WriteStartPieceBlank SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchToTargetA
      1  3800				   AI_MarchToTargetA SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchA2
      1  3800				   AI_MarchA2 SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchB
      1  3800				   AI_MarchB  SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchToTargetB
      1  3800				   AI_MarchToTargetB SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	MarchB2
      1  3800				   AI_MarchB2 SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	FinalFlash
      1  3800				   AI_FinalFlash SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	SpecialMoveFixup
      1  3800				   AI_SpecialMoveFixup SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	InCheckBackup
      1  3800				   AI_InCheckBackup SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	InCheckDelay
      1  3800				   AI_InCheckDelay SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	PromotePawnStart
      1  3800				   AI_PromotePawnStart SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	RollPromotionPiece
      1  3800				   AI_RollPromotionPiece SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ChoosePromotePiece
      1  3800				   AI_ChoosePromotePiece SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	ChooseDebounce
      1  3800				   AI_ChooseDebounce SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	CheckMate
      1  3800				   AI_CheckMate SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	Draw
      1  3800				   AI_Draw    SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DelayAfterMove
      1  3800				   AI_DelayAfterMove SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DelayAfterMove2
      1  3800				   AI_DelayAfterMove2 SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DelayAfterPlaced
      1  3800				   AI_DelayAfterPlaced SET	P
      2  3800				   P	      SET	P+1
      0  3800					      AIN	DelayAfterPlaced2
      1  3800				   AI_DelayAfterPlaced2 SET	P
      2  3800				   P	      SET	P+1
     43  3800
     82  3800
      0  3800					      DEF	AiVectorLO
      1  3800				   BANK_AiVectorLO SET	_CURRENT_BANK
      2  3800				   AiVectorLO
      3  3800				   TEMPORARY_VAR SET	Overlay
      4  3800				   TEMPORARY_OFFSET SET	0
      5  3800				   VAR_BOUNDARY_AiVectorLO SET	TEMPORARY_OFFSET
      6  3800				   FUNCTION_NAME SET	AiVectorLO
      7  3800					      SUBROUTINE
      0  3800					      TABDEF	LO
      1  3800
      0  3800					      LO	FlashComputerMove
      1  3800		       ca		      .byte.b	<aiFlashComputerMove
      0  3801					      LO	BeginSelectMovePhase
      1  3801		       ad		      .byte.b	<aiBeginSelectMovePhase
      0  3802					      LO	SelectStartSquare
      1  3802		       f2		      .byte.b	<aiSelectStartSquare
      0  3803					      LO	StartSquareSelected
      1  3803		       59		      .byte.b	<aiStartSquareSelected
      0  3804					      LO	DrawMoves
      1  3804		       74		      .byte.b	<aiDrawMoves
      0  3805					      LO	ShowMoveCaptures
      1  3805		       18		      .byte.b	<aiShowMoveCaptures
      0  3806					      LO	SlowFlash
      1  3806		       36		      .byte.b	<aiSlowFlash
      0  3807					      LO	UnDrawTargetSquares
      1  3807		       f6		      .byte.b	<aiUnDrawTargetSquares
      0  3808					      LO	SelectDestinationSquare
      1  3808		       89		      .byte.b	<aiSelectDestinationSquare
      0  3809					      LO	Quiescent
      1  3809		       e7		      .byte.b	<aiQuiescent
      0  380a					      LO	ReselectDebounce
      1  380a		       de		      .byte.b	<aiReselectDebounce
      0  380b					      LO	StartMoveGen
      1  380b		       8d		      .byte.b	<aiStartMoveGen
      0  380c					      LO	StepMoveGen
      1  380c		       c9		      .byte.b	<aiStepMoveGen
      0  380d					      LO	StartClearBoard
      1  380d		       85		      .byte.b	<aiStartClearBoard
      0  380e					      LO	ClearEachRow
      1  380e		       92		      .byte.b	<aiClearEachRow
      0  380f					      LO	DrawEntireBoard
      1  380f		       83		      .byte.b	<aiDrawEntireBoard
      0  3810					      LO	DrawPart2
      1  3810		       e0		      .byte.b	<aiDrawPart2
      0  3811					      LO	DrawPart3
      1  3811		       e3		      .byte.b	<aiDrawPart3
      0  3812					      LO	GenerateMoves
      1  3812		       b7		      .byte.b	<aiGenerateMoves
      0  3813					      LO	ComputerMove
      1  3813		       47		      .byte.b	<aiComputerMove
      0  3814					      LO	MoveIsSelected
      1  3814		       a4		      .byte.b	<aiMoveIsSelected
      0  3815					      LO	WriteStartPieceBlank
      1  3815		       b6		      .byte.b	<aiWriteStartPieceBlank
      0  3816					      LO	MarchToTargetA
      1  3816		       8c		      .byte.b	<aiMarchToTargetA
      0  3817					      LO	MarchA2
      1  3817		       db		      .byte.b	<aiMarchA2
      0  3818					      LO	MarchB
      1  3818		       fd		      .byte.b	<aiMarchB
      0  3819					      LO	MarchToTargetB
      1  3819		       2c		      .byte.b	<aiMarchToTargetB
      0  381a					      LO	MarchB2
      1  381a		       02		      .byte.b	<aiMarchB2
      0  381b					      LO	FinalFlash
      1  381b		       0d		      .byte.b	<aiFinalFlash
      0  381c					      LO	SpecialMoveFixup
      1  381c		       e6		      .byte.b	<aiSpecialMoveFixup
      0  381d					      LO	InCheckBackup
      1  381d		       92		      .byte.b	<aiInCheckBackup
      0  381e					      LO	InCheckDelay
      1  381e		       a0		      .byte.b	<aiInCheckDelay
      0  381f					      LO	PromotePawnStart
      1  381f		       07		      .byte.b	<aiPromotePawnStart
      0  3820					      LO	RollPromotionPiece
      1  3820		       27		      .byte.b	<aiRollPromotionPiece
      0  3821					      LO	ChoosePromotePiece
      1  3821		       6d		      .byte.b	<aiChoosePromotePiece
      0  3822					      LO	ChooseDebounce
      1  3822		       d8		      .byte.b	<aiChooseDebounce
      0  3823					      LO	CheckMate
      1  3823		       34		      .byte.b	<aiCheckMate
      0  3824					      LO	Draw
      1  3824		       2f		      .byte.b	<aiDraw
      0  3825					      LO	DelayAfterMove
      1  3825		       ea		      .byte.b	<aiDelayAfterMove
      0  3826					      LO	DelayAfterMove2
      1  3826		       f3		      .byte.b	<aiDelayAfterMove2
      0  3827					      LO	DelayAfterPlaced
      1  3827		       fc		      .byte.b	<aiDelayAfterPlaced
      0  3828					      LO	DelayAfterPlaced2
      1  3828		       0b		      .byte.b	<aiDelayAfterPlaced2
     43  3829
     85  3829
      0  3829					      DEF	AiVectorHI
      1  3829				   BANK_AiVectorHI SET	_CURRENT_BANK
      2  3829				   AiVectorHI
      3  3829				   TEMPORARY_VAR SET	Overlay
      4  3829				   TEMPORARY_OFFSET SET	0
      5  3829				   VAR_BOUNDARY_AiVectorHI SET	TEMPORARY_OFFSET
      6  3829				   FUNCTION_NAME SET	AiVectorHI
      7  3829					      SUBROUTINE
      0  3829					      TABDEF	HI
      1  3829
      0  3829					      HI	FlashComputerMove
      1  3829		       f0		      .byte.b	>aiFlashComputerMove
      0  382a					      HI	BeginSelectMovePhase
      1  382a		       f0		      .byte.b	>aiBeginSelectMovePhase
      0  382b					      HI	SelectStartSquare
      1  382b		       f0		      .byte.b	>aiSelectStartSquare
      0  382c					      HI	StartSquareSelected
      1  382c		       f1		      .byte.b	>aiStartSquareSelected
      0  382d					      HI	DrawMoves
      1  382d		       f1		      .byte.b	>aiDrawMoves
      0  382e					      HI	ShowMoveCaptures
      1  382e		       f2		      .byte.b	>aiShowMoveCaptures
      0  382f					      HI	SlowFlash
      1  382f		       f2		      .byte.b	>aiSlowFlash
      0  3830					      HI	UnDrawTargetSquares
      1  3830		       f1		      .byte.b	>aiUnDrawTargetSquares
      0  3831					      HI	SelectDestinationSquare
      1  3831		       f2		      .byte.b	>aiSelectDestinationSquare
      0  3832					      HI	Quiescent
      1  3832		       f2		      .byte.b	>aiQuiescent
      0  3833					      HI	ReselectDebounce
      1  3833		       f2		      .byte.b	>aiReselectDebounce
      0  3834					      HI	StartMoveGen
      1  3834		       f0		      .byte.b	>aiStartMoveGen
      0  3835					      HI	StepMoveGen
      1  3835		       f8		      .byte.b	>aiStepMoveGen
      0  3836					      HI	StartClearBoard
      1  3836		       f0		      .byte.b	>aiStartClearBoard
      0  3837					      HI	ClearEachRow
      1  3837		       f0		      .byte.b	>aiClearEachRow
      0  3838					      HI	DrawEntireBoard
      1  3838		       f8		      .byte.b	>aiDrawEntireBoard
      0  3839					      HI	DrawPart2
      1  3839		       f0		      .byte.b	>aiDrawPart2
      0  383a					      HI	DrawPart3
      1  383a		       f0		      .byte.b	>aiDrawPart3
      0  383b					      HI	GenerateMoves
      1  383b		       f8		      .byte.b	>aiGenerateMoves
      0  383c					      HI	ComputerMove
      1  383c		       f9		      .byte.b	>aiComputerMove
      0  383d					      HI	MoveIsSelected
      1  383d		       f0		      .byte.b	>aiMoveIsSelected
      0  383e					      HI	WriteStartPieceBlank
      1  383e		       f0		      .byte.b	>aiWriteStartPieceBlank
      0  383f					      HI	MarchToTargetA
      1  383f		       f0		      .byte.b	>aiMarchToTargetA
      0  3840					      HI	MarchA2
      1  3840		       f0		      .byte.b	>aiMarchA2
      0  3841					      HI	MarchB
      1  3841		       f0		      .byte.b	>aiMarchB
      0  3842					      HI	MarchToTargetB
      1  3842		       f1		      .byte.b	>aiMarchToTargetB
      0  3843					      HI	MarchB2
      1  3843		       f1		      .byte.b	>aiMarchB2
      0  3844					      HI	FinalFlash
      1  3844		       f1		      .byte.b	>aiFinalFlash
      0  3845					      HI	SpecialMoveFixup
      1  3845		       f9		      .byte.b	>aiSpecialMoveFixup
      0  3846					      HI	InCheckBackup
      1  3846		       f0		      .byte.b	>aiInCheckBackup
      0  3847					      HI	InCheckDelay
      1  3847		       f0		      .byte.b	>aiInCheckDelay
      0  3848					      HI	PromotePawnStart
      1  3848		       f3		      .byte.b	>aiPromotePawnStart
      0  3849					      HI	RollPromotionPiece
      1  3849		       f3		      .byte.b	>aiRollPromotionPiece
      0  384a					      HI	ChoosePromotePiece
      1  384a		       f3		      .byte.b	>aiChoosePromotePiece
      0  384b					      HI	ChooseDebounce
      1  384b		       f3		      .byte.b	>aiChooseDebounce
      0  384c					      HI	CheckMate
      1  384c		       f1		      .byte.b	>aiCheckMate
      0  384d					      HI	Draw
      1  384d		       f1		      .byte.b	>aiDraw
      0  384e					      HI	DelayAfterMove
      1  384e		       f3		      .byte.b	>aiDelayAfterMove
      0  384f					      HI	DelayAfterMove2
      1  384f		       f3		      .byte.b	>aiDelayAfterMove2
      0  3850					      HI	DelayAfterPlaced
      1  3850		       f3		      .byte.b	>aiDelayAfterPlaced
      0  3851					      HI	DelayAfterPlaced2
      1  3851		       f4		      .byte.b	>aiDelayAfterPlaced2
     43  3852
     88  3852
      0  3852					      DEF	AiVectorBANK
      1  3852				   BANK_AiVectorBANK SET	_CURRENT_BANK
      2  3852				   AiVectorBANK
      3  3852				   TEMPORARY_VAR SET	Overlay
      4  3852				   TEMPORARY_OFFSET SET	0
      5  3852				   VAR_BOUNDARY_AiVectorBANK SET	TEMPORARY_OFFSET
      6  3852				   FUNCTION_NAME SET	AiVectorBANK
      7  3852					      SUBROUTINE
      0  3852					      TABDEF	BK
      1  3852
      0  3852					      BK	FlashComputerMove
      1  3852		       07		      .byte.b	BANK_aiFlashComputerMove
      0  3853					      BK	BeginSelectMovePhase
      1  3853		       07		      .byte.b	BANK_aiBeginSelectMovePhase
      0  3854					      BK	SelectStartSquare
      1  3854		       07		      .byte.b	BANK_aiSelectStartSquare
      0  3855					      BK	StartSquareSelected
      1  3855		       07		      .byte.b	BANK_aiStartSquareSelected
      0  3856					      BK	DrawMoves
      1  3856		       07		      .byte.b	BANK_aiDrawMoves
      0  3857					      BK	ShowMoveCaptures
      1  3857		       07		      .byte.b	BANK_aiShowMoveCaptures
      0  3858					      BK	SlowFlash
      1  3858		       07		      .byte.b	BANK_aiSlowFlash
      0  3859					      BK	UnDrawTargetSquares
      1  3859		       07		      .byte.b	BANK_aiUnDrawTargetSquares
      0  385a					      BK	SelectDestinationSquare
      1  385a		       07		      .byte.b	BANK_aiSelectDestinationSquare
      0  385b					      BK	Quiescent
      1  385b		       07		      .byte.b	BANK_aiQuiescent
      0  385c					      BK	ReselectDebounce
      1  385c		       07		      .byte.b	BANK_aiReselectDebounce
      0  385d					      BK	StartMoveGen
      1  385d		       07		      .byte.b	BANK_aiStartMoveGen
      0  385e					      BK	StepMoveGen
      1  385e		       1f		      .byte.b	BANK_aiStepMoveGen
      0  385f					      BK	StartClearBoard
      1  385f		       00		      .byte.b	BANK_aiStartClearBoard
      0  3860					      BK	ClearEachRow
      1  3860		       00		      .byte.b	BANK_aiClearEachRow
      0  3861					      BK	DrawEntireBoard
      1  3861		       1f		      .byte.b	BANK_aiDrawEntireBoard
      0  3862					      BK	DrawPart2
      1  3862		       00		      .byte.b	BANK_aiDrawPart2
      0  3863					      BK	DrawPart3
      1  3863		       00		      .byte.b	BANK_aiDrawPart3
      0  3864					      BK	GenerateMoves
      1  3864		       1f		      .byte.b	BANK_aiGenerateMoves
      0  3865					      BK	ComputerMove
      1  3865		       1f		      .byte.b	BANK_aiComputerMove
      0  3866					      BK	MoveIsSelected
      1  3866		       00		      .byte.b	BANK_aiMoveIsSelected
      0  3867					      BK	WriteStartPieceBlank
      1  3867		       00		      .byte.b	BANK_aiWriteStartPieceBlank
      0  3868					      BK	MarchToTargetA
      1  3868		       0b		      .byte.b	BANK_aiMarchToTargetA
      0  3869					      BK	MarchA2
      1  3869		       0b		      .byte.b	BANK_aiMarchA2
      0  386a					      BK	MarchB
      1  386a		       00		      .byte.b	BANK_aiMarchB
      0  386b					      BK	MarchToTargetB
      1  386b		       0b		      .byte.b	BANK_aiMarchToTargetB
      0  386c					      BK	MarchB2
      1  386c		       0b		      .byte.b	BANK_aiMarchB2
      0  386d					      BK	FinalFlash
      1  386d		       00		      .byte.b	BANK_aiFinalFlash
      0  386e					      BK	SpecialMoveFixup
      1  386e		       1f		      .byte.b	BANK_aiSpecialMoveFixup
      0  386f					      BK	InCheckBackup
      1  386f		       07		      .byte.b	BANK_aiInCheckBackup
      0  3870					      BK	InCheckDelay
      1  3870		       07		      .byte.b	BANK_aiInCheckDelay
      0  3871					      BK	PromotePawnStart
      1  3871		       07		      .byte.b	BANK_aiPromotePawnStart
      0  3872					      BK	RollPromotionPiece
      1  3872		       07		      .byte.b	BANK_aiRollPromotionPiece
      0  3873					      BK	ChoosePromotePiece
      1  3873		       07		      .byte.b	BANK_aiChoosePromotePiece
      0  3874					      BK	ChooseDebounce
      1  3874		       07		      .byte.b	BANK_aiChooseDebounce
      0  3875					      BK	CheckMate
      1  3875		       00		      .byte.b	BANK_aiCheckMate
      0  3876					      BK	Draw
      1  3876		       00		      .byte.b	BANK_aiDraw
      0  3877					      BK	DelayAfterMove
      1  3877		       07		      .byte.b	BANK_aiDelayAfterMove
      0  3878					      BK	DelayAfterMove2
      1  3878		       07		      .byte.b	BANK_aiDelayAfterMove2
      0  3879					      BK	DelayAfterPlaced
      1  3879		       07		      .byte.b	BANK_aiDelayAfterPlaced
      0  387a					      BK	DelayAfterPlaced2
      1  387a		       07		      .byte.b	BANK_aiDelayAfterPlaced2
     43  387b
     91  387b
     92  387b
     93  387b							;---------------------------------------------------------------------------------------------------
     94  387b
      0  387b					      DEF	AiSetupVectors
      1  387b				   BANK_AiSetupVectors SET	_CURRENT_BANK
      2  387b				   AiSetupVectors
      3  387b				   TEMPORARY_VAR SET	Overlay
      4  387b				   TEMPORARY_OFFSET SET	0
      5  387b				   VAR_BOUNDARY_AiSetupVectors SET	TEMPORARY_OFFSET
      6  387b				   FUNCTION_NAME SET	AiSetupVectors
      7  387b					      SUBROUTINE
     96  387b					      SUBROUTINE
     97  387b
      0  387b					      REFER	AiStateMachine
      1  387b				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  387b				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  387b					      ENDIF
      0  387b					      VEND	AiSetupVectors
      1  387b				  -	      IFNCONST	AiSetupVectors
      2  387b				  -	      ECHO	"Incorrect VEND label", AiSetupVectors
      3  387b				  -	      ERR
      4  387b					      ENDIF
      5  387b		       00 a2	   VAREND_AiSetupVectors =	TEMPORARY_VAR
    100  387b
    101  387b							; State machine vector setup - points to current routine to execute
    102  387b
    103  387b		       a6 8c		      ldx	aiState
    104  387d		       bd 00 f0 	      lda	AiVectorLO,x
    105  3880		       85 ea		      sta	__ptr
    106  3882		       bd 29 f0 	      lda	AiVectorHI,x
    107  3885		       85 eb		      sta	__ptr+1
    108  3887
    109  3887		       bd 52 f0 	      lda	AiVectorBANK,x
    110  388a		       85 8b		      sta	savedBank
    111  388c
    112  388c		       60		      rts
    113  388d
    114  388d
    115  388d							;---------------------------------------------------------------------------------------------------
    116  388d
      0  388d					      DEF	aiStartMoveGen
      1  388d				   BANK_aiStartMoveGen SET	_CURRENT_BANK
      2  388d				   aiStartMoveGen
      3  388d				   TEMPORARY_VAR SET	Overlay
      4  388d				   TEMPORARY_OFFSET SET	0
      5  388d				   VAR_BOUNDARY_aiStartMoveGen SET	TEMPORARY_OFFSET
      6  388d				   FUNCTION_NAME SET	aiStartMoveGen
      7  388d					      SUBROUTINE
    118  388d					      SUBROUTINE
    119  388d
      0  388d					      REFER	AiStateMachine
      1  388d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  388d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  388d					      ENDIF
      0  388d					      VEND	aiStartMoveGen
      1  388d				  -	      IFNCONST	aiStartMoveGen
      2  388d				  -	      ECHO	"Incorrect VEND label", aiStartMoveGen
      3  388d				  -	      ERR
      4  388d					      ENDIF
      5  388d		       00 a2	   VAREND_aiStartMoveGen =	TEMPORARY_VAR
    122  388d
    123  388d							; To assist with castling, generate the moves for the opponent, giving us effectively
    124  388d							; a list of squares that are being attacked. The castling can't happen if the king is
    125  388d							; in check or if the squares it would have to move over are in check
    126  388d
    127  388d							; we don't need to worry about this if K has moved, or relevant R has moved or if
    128  388d							; the squares between are occupied. We can tell THAT by examining the movelist to see
    129  388d							; if there are K-moves marked "FLAG_CASTLE" - and the relevant squares
    130  388d
    131  388d							;inc currentPly
    132  388d							;jsr InitialiseMoveGeneration
    133  388d
      0  388d					      PHASE	AI_StepMoveGen
      1  388d		       a9 0c		      lda	#AI_StepMoveGen
      2  388f		       85 8c		      sta	aiState
    135  3891		       60		      rts
    136  3892
    137  3892
    138  3892							;---------------------------------------------------------------------------------------------------
    139  3892
      0  3892					      DEF	aiInCheckBackup
      1  3892				   BANK_aiInCheckBackup SET	_CURRENT_BANK
      2  3892				   aiInCheckBackup
      3  3892				   TEMPORARY_VAR SET	Overlay
      4  3892				   TEMPORARY_OFFSET SET	0
      5  3892				   VAR_BOUNDARY_aiInCheckBackup SET	TEMPORARY_OFFSET
      6  3892				   FUNCTION_NAME SET	aiInCheckBackup
      7  3892					      SUBROUTINE
    141  3892					      SUBROUTINE
    142  3892
      0  3892					      REFER	AiStateMachine
      1  3892				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3892				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3892					      ENDIF
      0  3892					      VEND	aiInCheckBackup
      1  3892				  -	      IFNCONST	aiInCheckBackup
      2  3892				  -	      ECHO	"Incorrect VEND label", aiInCheckBackup
      3  3892				  -	      ERR
      4  3892					      ENDIF
      5  3892		       00 a2	   VAREND_aiInCheckBackup =	TEMPORARY_VAR
    145  3892
    146  3892							; We're about to draw some large text on the screen
    147  3892							; Make a backup copy of all of the row bitmaps, so that we can restore once text is done
    148  3892
    149  3892		       c6 84		      dec	drawCount
    150  3894		       30 05		      bmi	.exit	; done all rows
    151  3896		       a4 84		      ldy	drawCount
    152  3898		       4c a2 fd 	      jmp	SAFE_BackupBitmaps
    153  389b
      0  389b				   .exit      PHASE	AI_InCheckDelay
      1  389b		       a9 1e		      lda	#AI_InCheckDelay
      2  389d		       85 8c		      sta	aiState
    155  389f		       60		      rts
    156  38a0
    157  38a0
    158  38a0							;---------------------------------------------------------------------------------------------------
    159  38a0
      0  38a0					      DEF	aiInCheckDelay
      1  38a0				   BANK_aiInCheckDelay SET	_CURRENT_BANK
      2  38a0				   aiInCheckDelay
      3  38a0				   TEMPORARY_VAR SET	Overlay
      4  38a0				   TEMPORARY_OFFSET SET	0
      5  38a0				   VAR_BOUNDARY_aiInCheckDelay SET	TEMPORARY_OFFSET
      6  38a0				   FUNCTION_NAME SET	aiInCheckDelay
      7  38a0					      SUBROUTINE
    161  38a0					      SUBROUTINE
    162  38a0
      0  38a0					      REFER	AiStateMachine
      1  38a0				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  38a0				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  38a0					      ENDIF
      0  38a0					      VEND	aiInCheckDelay
      1  38a0				  -	      IFNCONST	aiInCheckDelay
      2  38a0				  -	      ECHO	"Incorrect VEND label", aiInCheckDelay
      3  38a0				  -	      ERR
      4  38a0					      ENDIF
      5  38a0		       00 a2	   VAREND_aiInCheckDelay =	TEMPORARY_VAR
    165  38a0
    166  38a0		       c6 89		      dec	mdelay
    167  38a2		       d0 08		      bne	.exit
    168  38a4
    169  38a4		       a9 00		      lda	#0
    170  38a6		       85 49		      sta	COLUBK
    171  38a8
      0  38a8					      PHASE	AI_BeginSelectMovePhase
      1  38a8		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  38aa		       85 8c		      sta	aiState
    173  38ac		       60	   .exit      rts
    174  38ad
    175  38ad
    176  38ad							;---------------------------------------------------------------------------------------------------
    177  38ad
      0  38ad					      DEF	aiBeginSelectMovePhase
      1  38ad				   BANK_aiBeginSelectMovePhase SET	_CURRENT_BANK
      2  38ad				   aiBeginSelectMovePhase
      3  38ad				   TEMPORARY_VAR SET	Overlay
      4  38ad				   TEMPORARY_OFFSET SET	0
      5  38ad				   VAR_BOUNDARY_aiBeginSelectMovePhase SET	TEMPORARY_OFFSET
      6  38ad				   FUNCTION_NAME SET	aiBeginSelectMovePhase
      7  38ad					      SUBROUTINE
    179  38ad					      SUBROUTINE
    180  38ad
      0  38ad					      REFER	AiStateMachine
      1  38ad				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  38ad				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  38ad					      ENDIF
      0  38ad					      VEND	aiBeginSelectMovePhase
      1  38ad				  -	      IFNCONST	aiBeginSelectMovePhase
      2  38ad				  -	      ECHO	"Incorrect VEND label", aiBeginSelectMovePhase
      3  38ad				  -	      ERR
      4  38ad					      ENDIF
      5  38ad		       00 a2	   VAREND_aiBeginSelectMovePhase =	TEMPORARY_VAR
    183  38ad
    184  38ad		       a9 02		      lda	#$2
    185  38af		       85 46		      sta	COLUP0
    186  38b1		       a2 04		      ldx	#%100
    187  38b3		       86 4a		      stx	CTRLPF	; under
    188  38b5
    189  38b5		       a9 00		      lda	#0
    190  38b7		       85 89		      sta	mdelay	;?
    191  38b9		       85 8f		      sta	aiFlashPhase	; odd/even for flashing pieces
    192  38bb
    193  38bb		       a9 28		      lda	#CAP_SPEED*2
    194  38bd		       85 8d		      sta	aiFlashDelay
    195  38bf
    196  38bf		       a9 ff		      lda	#-1
    197  38c1		       85 85		      sta	fromX12
    198  38c3		       85 86		      sta	toX12
    199  38c5
    200  38c5							;lsr randomness
    201  38c5
      0  38c5					      PHASE	AI_FlashComputerMove
      1  38c5		       a9 00		      lda	#AI_FlashComputerMove
      2  38c7		       85 8c		      sta	aiState
    203  38c9		       60		      rts
    204  38ca
    205  38ca
    206  38ca							;---------------------------------------------------------------------------------------------------
    207  38ca
      0  38ca					      DEF	aiFlashComputerMove
      1  38ca				   BANK_aiFlashComputerMove SET	_CURRENT_BANK
      2  38ca				   aiFlashComputerMove
      3  38ca				   TEMPORARY_VAR SET	Overlay
      4  38ca				   TEMPORARY_OFFSET SET	0
      5  38ca				   VAR_BOUNDARY_aiFlashComputerMove SET	TEMPORARY_OFFSET
      6  38ca				   FUNCTION_NAME SET	aiFlashComputerMove
      7  38ca					      SUBROUTINE
    209  38ca					      SUBROUTINE
    210  38ca
    211  38ca
    212  38ca		       a5 80		      lda	squareToDraw
    213  38cc		       30 1f		      bmi	.initial	; startup - no computer move to show
    214  38ce
    215  38ce							; "squareToDraw" is the piece that should flash while human waits
    216  38ce
    217  38ce		       ad 80 02 	      lda	SWCHA
    218  38d1		       29 f0		      and	#$F0
    219  38d3		       c9 f0		      cmp	#$F0
    220  38d5		       f0 08		      beq	.nodir
    221  38d7
    222  38d7		       a9 01		      lda	#1
    223  38d9		       85 8d		      sta	aiFlashDelay
    224  38db		       25 8f		      and	aiFlashPhase
    225  38dd		       f0 0e		      beq	.initial
    226  38df
    227  38df		       c6 8d	   .nodir     dec	aiFlashDelay
    228  38e1		       d0 0e		      bne	.exit	; don't flash
    229  38e3		       a9 28		      lda	#CAP_SPEED*2
    230  38e5		       85 8d		      sta	aiFlashDelay
    231  38e7
    232  38e7		       e6 8f		      inc	aiFlashPhase
    233  38e9
    234  38e9		       20 40 fd 	      jsr	CopySinglePiece
    235  38ec		       60		      rts
    236  38ed
      0  38ed				   .initial   PHASE	AI_SelectStartSquare
      1  38ed		       a9 02		      lda	#AI_SelectStartSquare
      2  38ef		       85 8c		      sta	aiState
    238  38f1
    239  38f1		       60	   .exit      rts
    240  38f2
    241  38f2
    242  38f2							;---------------------------------------------------------------------------------------------------
    243  38f2
      0  38f2					      DEF	aiSelectStartSquare
      1  38f2				   BANK_aiSelectStartSquare SET	_CURRENT_BANK
      2  38f2				   aiSelectStartSquare
      3  38f2				   TEMPORARY_VAR SET	Overlay
      4  38f2				   TEMPORARY_OFFSET SET	0
      5  38f2				   VAR_BOUNDARY_aiSelectStartSquare SET	TEMPORARY_OFFSET
      6  38f2				   FUNCTION_NAME SET	aiSelectStartSquare
      7  38f2					      SUBROUTINE
    245  38f2					      SUBROUTINE
    246  38f2
      0  38f2					      REFER	AiStateMachine
      1  38f2				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  38f2				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  38f2					      ENDIF
      0  38f2					      VEND	aiSelectStartSquare
      1  38f2				  -	      IFNCONST	aiSelectStartSquare
      2  38f2				  -	      ECHO	"Incorrect VEND label", aiSelectStartSquare
      3  38f2				  -	      ERR
      4  38f2					      ENDIF
      5  38f2		       00 a2	   VAREND_aiSelectStartSquare =	TEMPORARY_VAR
    249  38f2
      0  38f2					      NEXT_RANDOM
      1  38f2		       a5 81		      lda	rnd
      2  38f4		       4a		      lsr
      3  38f5		       90 02		      bcc	.skipEOR
      4  38f7		       49 fe		      eor	#RND_EOR_VAL
      5  38f9		       85 81	   .skipEOR   sta	rnd
    251  38fb
    252  38fb		       20 5b f2 	      jsr	moveCursor
    253  38fe		       20 f4 fc 	      jsr	IsValidP_MoveFromSquare
    254  3901
    255  3901		       c6 8a		      dec	ccur	; pulse colour for valid squares
    256  3903		       20 26 f1 	      jsr	setCursorColours
    257  3906
    258  3906		       98		      tya
    259  3907		       05 4c		      ora	INPT4
    260  3909		       30 04		      bmi	.exit	; illegal square or no button press
    261  390b
      0  390b					      PHASE	AI_StartSquareSelected
      1  390b		       a9 03		      lda	#AI_StartSquareSelected
      2  390d		       85 8c		      sta	aiState
    263  390f
    264  390f		       60	   .exit      rts
    265  3910
    266  3910							;---------------------------------------------------------------------------------------------------
    267  3910
      0  3910					      DEF	setCursorPriority
      1  3910				   BANK_setCursorPriority SET	_CURRENT_BANK
      2  3910				   setCursorPriority
      3  3910				   TEMPORARY_VAR SET	Overlay
      4  3910				   TEMPORARY_OFFSET SET	0
      5  3910				   VAR_BOUNDARY_setCursorPriority SET	TEMPORARY_OFFSET
      6  3910				   FUNCTION_NAME SET	setCursorPriority
      7  3910					      SUBROUTINE
    269  3910					      SUBROUTINE
    270  3910
      0  3910					      REFER	moveCursor
      1  3910					      IF	VAREND_moveCursor > TEMPORARY_VAR
      2  3910				   TEMPORARY_VAR SET	VAREND_moveCursor
      3  3910					      ENDIF
      0  3910					      VEND	setCursorPriority
      1  3910				  -	      IFNCONST	setCursorPriority
      2  3910				  -	      ECHO	"Incorrect VEND label", setCursorPriority
      3  3910				  -	      ERR
      4  3910					      ENDIF
      5  3910		       00 a3	   VAREND_setCursorPriority =	TEMPORARY_VAR
    273  3910
    274  3910		       98		      tya
    275  3911		       48		      pha
    276  3912
    277  3912		       a2 04		      ldx	#%100
    278  3914
    279  3914		       a4 88		      ldy	cursorX12
    280  3916		       30 09		      bmi	.under
    281  3918		       20 dc fc 	      jsr	GetBoard
    282  391b		       c9 00		      cmp	#0
    283  391d		       d0 02		      bne	.under
    284  391f		       a2 00		      ldx	#0
    285  3921		       86 4a	   .under     stx	CTRLPF	; UNDER
    286  3923
    287  3923		       68		      pla
    288  3924		       a8		      tay
    289  3925		       60		      rts
    290  3926
    291  3926							;---------------------------------------------------------------------------------------------------
    292  3926
      0  3926					      DEF	setCursorColours
      1  3926				   BANK_setCursorColours SET	_CURRENT_BANK
      2  3926				   setCursorColours
      3  3926				   TEMPORARY_VAR SET	Overlay
      4  3926				   TEMPORARY_OFFSET SET	0
      5  3926				   VAR_BOUNDARY_setCursorColours SET	TEMPORARY_OFFSET
      6  3926				   FUNCTION_NAME SET	setCursorColours
      7  3926					      SUBROUTINE
    294  3926					      SUBROUTINE
    295  3926
      0  3926					      REFER	aiSelectStartSquare
      1  3926				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  3926				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  3926					      ENDIF
      0  3926					      REFER	aiDrawMoves
      1  3926				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  3926				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  3926					      ENDIF
      0  3926					      REFER	aiUnDrawTargetSquares
      1  3926				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  3926				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  3926					      ENDIF
      0  3926					      REFER	aiShowMoveCaptures
      1  3926				  -	      IF	VAREND_aiShowMoveCaptures > TEMPORARY_VAR
      2  3926				  -TEMPORARY_VAR SET	VAREND_aiShowMoveCaptures
      3  3926					      ENDIF
      0  3926					      REFER	aiSlowFlash
      1  3926				  -	      IF	VAREND_aiSlowFlash > TEMPORARY_VAR
      2  3926				  -TEMPORARY_VAR SET	VAREND_aiSlowFlash
      3  3926					      ENDIF
      0  3926					      REFER	aiSelectDestinationSquare
      1  3926				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  3926				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  3926					      ENDIF
      0  3926					      VEND	setCursorColours
      1  3926				  -	      IFNCONST	setCursorColours
      2  3926				  -	      ECHO	"Incorrect VEND label", setCursorColours
      3  3926				  -	      ERR
      4  3926					      ENDIF
      5  3926		       00 a2	   VAREND_setCursorColours =	TEMPORARY_VAR
    303  3926
    304  3926							; pass y=-1 if move is NOT in the movelist
    305  3926							; preserve y
    306  3926
    307  3926		       a9 44		      lda	#$44
    308  3928
    309  3928		       c0 ff		      cpy	#-1
    310  392a		       f0 0a		      beq	.writeCursorCol	; NOT in the movelist
    311  392c
    312  392c		       a5 8a		      lda	ccur
    313  392e		       4a		      lsr
    314  392f		       4a		      lsr
    315  3930		       4a		      lsr
    316  3931		       29 03		      and	#3
    317  3933		       18		      clc
    318  3934		       69 c0		      adc	#$C0	;COLOUR_LINE_1
    319  3936
    320  3936		       85 46	   .writeCursorCol sta	COLUP0
    321  3938		       60		      rts
    322  3939
    323  3939
    324  3939							;---------------------------------------------------------------------------------------------------
    325  3939
    326  3939							;	    RLDU RLD  RL U RL	R DU R D  R  U R     LDU  LD   L U  L	  DU   D     U
    327  3939							;	    0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    328  3939
      0  3939					      ALLOCATE	JoyCombined, 16
      0  3939					      OPTIONAL_PAGEBREAK	"Table", 16
     12  3939					      LIST	ON
      0  3939					      DEF	JoyCombined
      1  3939				   BANK_JoyCombined SET	_CURRENT_BANK
      2  3939				   JoyCombined
      3  3939				   TEMPORARY_VAR SET	Overlay
      4  3939				   TEMPORARY_OFFSET SET	0
      5  3939				   VAR_BOUNDARY_JoyCombined SET	TEMPORARY_OFFSET
      6  3939				   FUNCTION_NAME SET	JoyCombined
      7  3939					      SUBROUTINE
    330  3939		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1, -1, 0
    331  3949
      0  3949					      ALLOCATE	JoyMoveCursor, 16
      0  3949					      OPTIONAL_PAGEBREAK	"Table", 16
     12  3949					      LIST	ON
      0  3949					      DEF	JoyMoveCursor
      1  3949				   BANK_JoyMoveCursor SET	_CURRENT_BANK
      2  3949				   JoyMoveCursor
      3  3949				   TEMPORARY_VAR SET	Overlay
      4  3949				   TEMPORARY_OFFSET SET	0
      5  3949				   VAR_BOUNDARY_JoyMoveCursor SET	TEMPORARY_OFFSET
      6  3949				   FUNCTION_NAME SET	JoyMoveCursor
      7  3949					      SUBROUTINE
    333  3949		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, -9, 11, 1, 0, -11, 9, -1, 0, -10, 10, 0
    334  3959
    335  3959
    336  3959							;---------------------------------------------------------------------------------------------------
    337  3959
      0  3959					      DEF	aiStartSquareSelected
      1  3959				   BANK_aiStartSquareSelected SET	_CURRENT_BANK
      2  3959				   aiStartSquareSelected
      3  3959				   TEMPORARY_VAR SET	Overlay
      4  3959				   TEMPORARY_OFFSET SET	0
      5  3959				   VAR_BOUNDARY_aiStartSquareSelected SET	TEMPORARY_OFFSET
      6  3959				   FUNCTION_NAME SET	aiStartSquareSelected
      7  3959					      SUBROUTINE
    339  3959					      SUBROUTINE
    340  3959
      0  3959					      REFER	AiStateMachine
      1  3959				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3959				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3959					      ENDIF
      0  3959					      VEND	aiStartSquareSelected
      1  3959				  -	      IFNCONST	aiStartSquareSelected
      2  3959				  -	      ECHO	"Incorrect VEND label", aiStartSquareSelected
      3  3959				  -	      ERR
      4  3959					      ENDIF
      5  3959		       00 a2	   VAREND_aiStartSquareSelected =	TEMPORARY_VAR
    343  3959
    344  3959
    345  3959							; Mark all the valid moves for the selected piece on the board
    346  3959							; and then start pulsing the piece
    347  3959							; AND start choosing for selection of TO square
    348  3959
    349  3959							; Iterate the movelist and for all from squares which = drawPieceNumber
    350  3959							; then draw a BLANK at that square
    351  3959							; do 1 by one, when none found then increment state
    352  3959
    353  3959		       a5 88		      lda	cursorX12
    354  395b		       85 80		      sta	squareToDraw
    355  395d
    356  395d		       a9 0a		      lda	#10
    357  395f		       85 8d		      sta	aiFlashDelay
    358  3961
    359  3961		       a9 00		      lda	#0
    360  3963		       85 86		      sta	toX12	;aiToSquareX12
    361  3965		       85 8f		      sta	aiFlashPhase	; for debounce exit timing
    362  3967
    363  3967		       a9 ff		      lda	#-1
    364  3969		       85 8e		      sta	aiMoveIndex
    365  396b
    366  396b		       a9 28		      lda	#HOLD_DELAY
    367  396d		       85 89		      sta	mdelay	; hold-down delay before moves are shown
    368  396f
      0  396f					      PHASE	AI_DrawMoves
      1  396f		       a9 04		      lda	#AI_DrawMoves
      2  3971		       85 8c		      sta	aiState
    370  3973		       60		      rts
    371  3974
    372  3974
    373  3974							;---------------------------------------------------------------------------------------------------
    374  3974
      0  3974					      DEF	aiDrawMoves
      1  3974				   BANK_aiDrawMoves SET	_CURRENT_BANK
      2  3974				   aiDrawMoves
      3  3974				   TEMPORARY_VAR SET	Overlay
      4  3974				   TEMPORARY_OFFSET SET	0
      5  3974				   VAR_BOUNDARY_aiDrawMoves SET	TEMPORARY_OFFSET
      6  3974				   FUNCTION_NAME SET	aiDrawMoves
      7  3974					      SUBROUTINE
    376  3974					      SUBROUTINE
    377  3974
      0  3974					      REFER	AiStateMachine
      1  3974				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3974				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3974					      ENDIF
      0  3974					      VEND	aiDrawMoves
      1  3974				  -	      IFNCONST	aiDrawMoves
      2  3974				  -	      ECHO	"Incorrect VEND label", aiDrawMoves
      3  3974				  -	      ERR
      4  3974					      ENDIF
      5  3974		       00 a2	   VAREND_aiDrawMoves =	TEMPORARY_VAR
    380  3974
    381  3974		       c6 8a		      dec	ccur
    382  3976		       20 26 f1 	      jsr	setCursorColours
    383  3979
    384  3979		       c6 89		      dec	mdelay
    385  397b		       d0 21		      bne	.exit
    386  397d		       a9 01		      lda	#1	; larger number will slow the draw of available moves
    387  397f		       85 89		      sta	mdelay	; once triggered, runs always
    388  3981
    389  3981		       a5 8e		      lda	aiMoveIndex
    390  3983		       10 05		      bpl	.valid
    391  3985		       20 7c fd 	      jsr	SAFE_getMoveIndex
    392  3988		       85 8e		      sta	aiMoveIndex
    393  398a				   .valid
    394  398a
    395  398a		       20 ab f1 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    396  398d		       a5 8e		      lda	aiMoveIndex
    397  398f		       10 19		      bpl	.unsure	; still drawing in this phase
    398  3991
    399  3991		       a9 14		      lda	#CAP_SPEED
    400  3993		       85 89		      sta	mdelay
    401  3995
    402  3995		       a9 00		      lda	#0
    403  3997		       85 8f		      sta	aiFlashPhase	; controls odd/even exit of flashing
    404  3999
      0  3999					      PHASE	AI_ShowMoveCaptures
      1  3999		       a9 05		      lda	#AI_ShowMoveCaptures
      2  399b		       85 8c		      sta	aiState
    406  399d		       60		      rts
    407  399e
    408  399e				   .exit
    409  399e
    410  399e							; Initial piece selection has happened, but the button hasn't been released yet
    411  399e							; AND we're still in the waiting phase to see if the button was held long enough for move show
    412  399e
    413  399e		       a5 4c		      lda	INPT4
    414  39a0		       10 08		      bpl	.unsure	; button still pressed, so still unsure what to do
    415  39a2
    416  39a2							; Aha! Button released, so we know the selected piece and can start flashing it
    417  39a2							; and allowing movement of the selector to a destination square...
    418  39a2
    419  39a2		       a9 18		      lda	#6*4
    420  39a4		       85 8a		      sta	ccur	; bright green square for selection
    421  39a6
      0  39a6					      PHASE	AI_SelectDestinationSquare
      1  39a6		       a9 08		      lda	#AI_SelectDestinationSquare
      2  39a8		       85 8c		      sta	aiState
    423  39aa
    424  39aa		       60	   .unsure    rts
    425  39ab
    426  39ab
    427  39ab							;---------------------------------------------------------------------------------------------------
    428  39ab
      0  39ab					      DEF	SAFE_showMoveOptions
      1  39ab				   BANK_SAFE_showMoveOptions SET	_CURRENT_BANK
      2  39ab				   SAFE_showMoveOptions
      3  39ab				   TEMPORARY_VAR SET	Overlay
      4  39ab				   TEMPORARY_OFFSET SET	0
      5  39ab				   VAR_BOUNDARY_SAFE_showMoveOptions SET	TEMPORARY_OFFSET
      6  39ab				   FUNCTION_NAME SET	SAFE_showMoveOptions
      7  39ab					      SUBROUTINE
    430  39ab					      SUBROUTINE
    431  39ab
      0  39ab					      REFER	aiDrawMoves
      1  39ab				  -	      IF	VAREND_aiDrawMoves > TEMPORARY_VAR
      2  39ab				  -TEMPORARY_VAR SET	VAREND_aiDrawMoves
      3  39ab					      ENDIF
      0  39ab					      REFER	aiUnDrawTargetSquares
      1  39ab				  -	      IF	VAREND_aiUnDrawTargetSquares > TEMPORARY_VAR
      2  39ab				  -TEMPORARY_VAR SET	VAREND_aiUnDrawTargetSquares
      3  39ab					      ENDIF
      0  39ab					      VAR	__saveIdx, 1
      1  39ab		       00 a2	   __saveIdx  =	TEMPORARY_VAR
      2  39ab				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  39ab
      4  39ab				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  39ab				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  39ab				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  39ab					      ENDIF
      8  39ab				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  39ab				  -	      ECHO	"Temporary Variable", __saveIdx, "overflow!"
     10  39ab				  -	      ERR
     11  39ab					      ENDIF
     12  39ab					      LIST	ON
      0  39ab					      VAR	__piece, 1
      1  39ab		       00 a3	   __piece    =	TEMPORARY_VAR
      2  39ab				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  39ab
      4  39ab				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  39ab				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  39ab				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  39ab					      ENDIF
      8  39ab				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  39ab				  -	      ECHO	"Temporary Variable", __piece, "overflow!"
     10  39ab				  -	      ERR
     11  39ab					      ENDIF
     12  39ab					      LIST	ON
      0  39ab					      VEND	SAFE_showMoveOptions
      1  39ab				  -	      IFNCONST	SAFE_showMoveOptions
      2  39ab				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveOptions
      3  39ab				  -	      ERR
      4  39ab					      ENDIF
      5  39ab		       00 a4	   VAREND_SAFE_showMoveOptions =	TEMPORARY_VAR
    437  39ab
    438  39ab							; place a marker on the board for any square matching the piece
    439  39ab							; EXCEPT for squares which are occupied (we'll flash those later)
    440  39ab
    441  39ab		       a6 8e	   .next      ldx	aiMoveIndex
    442  39ad		       86 a2		      stx	__saveIdx
    443  39af		       30 40		      bmi	.skip
    444  39b1
    445  39b1		       ad 84 02 	      lda	INTIM
    446  39b4		       c9 2b		      cmp	#2+SPEEDOF_COPYSINGLEPIECE
    447  39b6		       90 39		      bcc	.skip
    448  39b8
    449  39b8		       c6 8e		      dec	aiMoveIndex
    450  39ba
    451  39ba		       20 b8 fd 	      jsr	GetP_MoveFrom
    452  39bd		       c5 85		      cmp	fromX12
    453  39bf		       d0 ea		      bne	.next
    454  39c1
    455  39c1		       20 c4 fd 	      jsr	GetP_MoveTo
    456  39c4		       85 80		      sta	squareToDraw
    457  39c6
    458  39c6		       20 d0 fd 	      jsr	GetP_MovePiece
    459  39c9		       85 a3		      sta	__piece
    460  39cb
    461  39cb							; If it's a pawn promote (duplicate "to" AND piece different (TODO) then skip others)
    462  39cb							; TODO this could/will fail on sorted lists. MMh.
    463  39cb
    464  39cb		       ca	   .sk	      dex
    465  39cc		       30 16		      bmi	.prom
    466  39ce		       20 c4 fd 	      jsr	GetP_MoveTo
    467  39d1		       c5 80		      cmp	squareToDraw
    468  39d3		       d0 0f		      bne	.prom
    469  39d5		       20 d0 fd 	      jsr	GetP_MovePiece
    470  39d8		       45 a3		      eor	__piece
    471  39da		       29 0f		      and	#PIECE_MASK
    472  39dc		       f0 06		      beq	.prom	; same piece type so not a promote
    473  39de
    474  39de		       c6 8e		      dec	aiMoveIndex
    475  39e0		       c6 8e		      dec	aiMoveIndex
    476  39e2		       c6 8e		      dec	aiMoveIndex
    477  39e4				   .prom
    478  39e4
    479  39e4		       a4 80		      ldy	squareToDraw
    480  39e6		       20 dc fc 	      jsr	GetBoard
    481  39e9		       29 0f		      and	#PIECE_MASK
    482  39eb		       d0 be		      bne	.next	; don't draw dots on captures - they are flashed later
    483  39ed
    484  39ed
    485  39ed							;lda INTIM
    486  39ed							;cmp #SPEEDOF_COPYSINGLEPIECE
    487  39ed							;bcc .skip
    488  39ed
    489  39ed							;lda aiMoveIndex
    490  39ed							;sta __saveIdx
    491  39ed
    492  39ed		       20 88 fd 	      jsr	markerDraw
    493  39f0		       60		      rts
    494  39f1
    495  39f1		       a5 a2	   .skip      lda	__saveIdx
    496  39f3		       85 8e		      sta	aiMoveIndex
    497  39f5		       60		      rts
    498  39f6
    499  39f6
    500  39f6							;---------------------------------------------------------------------------------------------------
    501  39f6
      0  39f6					      DEF	aiUnDrawTargetSquares
      1  39f6				   BANK_aiUnDrawTargetSquares SET	_CURRENT_BANK
      2  39f6				   aiUnDrawTargetSquares
      3  39f6				   TEMPORARY_VAR SET	Overlay
      4  39f6				   TEMPORARY_OFFSET SET	0
      5  39f6				   VAR_BOUNDARY_aiUnDrawTargetSquares SET	TEMPORARY_OFFSET
      6  39f6				   FUNCTION_NAME SET	aiUnDrawTargetSquares
      7  39f6					      SUBROUTINE
    503  39f6					      SUBROUTINE
    504  39f6
      0  39f6					      REFER	AiStateMachine
      1  39f6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  39f6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  39f6					      ENDIF
      0  39f6					      VEND	aiUnDrawTargetSquares
      1  39f6				  -	      IFNCONST	aiUnDrawTargetSquares
      2  39f6				  -	      ECHO	"Incorrect VEND label", aiUnDrawTargetSquares
      3  39f6				  -	      ERR
      4  39f6					      ENDIF
      5  39f6		       00 a2	   VAREND_aiUnDrawTargetSquares =	TEMPORARY_VAR
    507  39f6
    508  39f6
    509  39f6		       c6 8a		      dec	ccur
    510  39f8		       20 26 f1 	      jsr	setCursorColours
    511  39fb
    512  39fb		       c6 89		      dec	mdelay
    513  39fd		       d0 18		      bne	.exit
    514  39ff		       a9 01		      lda	#1
    515  3a01		       85 89		      sta	mdelay	; once triggered, runs always
    516  3a03
    517  3a03		       a5 8e		      lda	aiMoveIndex
    518  3a05		       10 05		      bpl	.valid
    519  3a07		       20 7c fd 	      jsr	SAFE_getMoveIndex
    520  3a0a		       85 8e		      sta	aiMoveIndex
    521  3a0c				   .valid
    522  3a0c
    523  3a0c		       20 ab f1 	      jsr	SAFE_showMoveOptions	; draw potential moves one at a time
    524  3a0f		       a5 8e		      lda	aiMoveIndex
    525  3a11		       10 04		      bpl	.exit	; still drawing in this phase
    526  3a13
      0  3a13					      PHASE	AI_SelectStartSquare
      1  3a13		       a9 02		      lda	#AI_SelectStartSquare
      2  3a15		       85 8c		      sta	aiState
    528  3a17
    529  3a17		       60	   .exit      rts
    530  3a18
    531  3a18
    532  3a18							;---------------------------------------------------------------------------------------------------
    533  3a18
    534  3a18
      0  3a18					      DEF	aiShowMoveCaptures
      1  3a18				   BANK_aiShowMoveCaptures SET	_CURRENT_BANK
      2  3a18				   aiShowMoveCaptures
      3  3a18				   TEMPORARY_VAR SET	Overlay
      4  3a18				   TEMPORARY_OFFSET SET	0
      5  3a18				   VAR_BOUNDARY_aiShowMoveCaptures SET	TEMPORARY_OFFSET
      6  3a18				   FUNCTION_NAME SET	aiShowMoveCaptures
      7  3a18					      SUBROUTINE
    536  3a18					      SUBROUTINE
    537  3a18
      0  3a18					      REFER	AiStateMachine
      1  3a18				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3a18				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3a18					      ENDIF
      0  3a18					      VEND	aiShowMoveCaptures
      1  3a18				  -	      IFNCONST	aiShowMoveCaptures
      2  3a18				  -	      ECHO	"Incorrect VEND label", aiShowMoveCaptures
      3  3a18				  -	      ERR
      4  3a18					      ENDIF
      5  3a18		       00 a2	   VAREND_aiShowMoveCaptures =	TEMPORARY_VAR
    540  3a18
    541  3a18							; draw/undraw ALL captured pieces
    542  3a18							; we should do this an even number of times so that pieces don't disappEOR
    543  3a18
    544  3a18		       c6 8a		      dec	ccur
    545  3a1a		       20 26 f1 	      jsr	setCursorColours
    546  3a1d
    547  3a1d		       c6 89		      dec	mdelay	; flash speed UNVARYING despite draw happening
    548  3a1f
    549  3a1f		       a5 8e		      lda	aiMoveIndex
    550  3a21		       10 05		      bpl	.valid	; guaranteed -1 on 1st call
    551  3a23		       20 7c fd 	      jsr	SAFE_getMoveIndex
    552  3a26		       85 8e		      sta	aiMoveIndex
    553  3a28				   .valid
    554  3a28
    555  3a28		       20 ac fd 	      jsr	SAFE_showMoveCaptures
    556  3a2b		       a5 8e		      lda	aiMoveIndex
    557  3a2d		       10 06		      bpl	.exit
    558  3a2f
    559  3a2f		       e6 8f		      inc	aiFlashPhase
    560  3a31
      0  3a31					      PHASE	AI_SlowFlash
      1  3a31		       a9 06		      lda	#AI_SlowFlash
      2  3a33		       85 8c		      sta	aiState
    562  3a35
    563  3a35		       60	   .exit      rts
    564  3a36
    565  3a36
    566  3a36							;---------------------------------------------------------------------------------------------------
    567  3a36
      0  3a36					      DEF	aiSlowFlash
      1  3a36				   BANK_aiSlowFlash SET	_CURRENT_BANK
      2  3a36				   aiSlowFlash
      3  3a36				   TEMPORARY_VAR SET	Overlay
      4  3a36				   TEMPORARY_OFFSET SET	0
      5  3a36				   VAR_BOUNDARY_aiSlowFlash SET	TEMPORARY_OFFSET
      6  3a36				   FUNCTION_NAME SET	aiSlowFlash
      7  3a36					      SUBROUTINE
    569  3a36					      SUBROUTINE
    570  3a36
      0  3a36					      REFER	AiStateMachine
      1  3a36				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3a36				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3a36					      ENDIF
      0  3a36					      VEND	aiSlowFlash
      1  3a36				  -	      IFNCONST	aiSlowFlash
      2  3a36				  -	      ECHO	"Incorrect VEND label", aiSlowFlash
      3  3a36				  -	      ERR
      4  3a36					      ENDIF
      5  3a36		       00 a2	   VAREND_aiSlowFlash =	TEMPORARY_VAR
    573  3a36
    574  3a36							; Joystick button is held down, so we're displaying the available moves
    575  3a36							; They have all been drawn, so now we "slow" flash any pieces that can be captures
    576  3a36
    577  3a36		       c6 8a		      dec	ccur
    578  3a38		       20 26 f1 	      jsr	setCursorColours
    579  3a3b
    580  3a3b		       a5 8f		      lda	aiFlashPhase
    581  3a3d		       29 01		      and	#1
    582  3a3f		       d0 04		      bne	.notEven	; only exit after even # EOR-draws
    583  3a41
    584  3a41		       a5 4c		      lda	INPT4
    585  3a43		       30 0d		      bmi	.butpress	; exit on button release
    586  3a45
    587  3a45				   .notEven
    588  3a45
    589  3a45							; Wait for delay to expire then back and flash 'em again
    590  3a45
    591  3a45		       c6 89		      dec	mdelay
    592  3a47		       10 08		      bpl	.slowWait
    593  3a49
    594  3a49		       a9 14		      lda	#CAP_SPEED
    595  3a4b		       85 89		      sta	mdelay
    596  3a4d
      0  3a4d					      PHASE	AI_ShowMoveCaptures	; go back and rEORdraw all captures again
      1  3a4d		       a9 05		      lda	#AI_ShowMoveCaptures
      2  3a4f		       85 8c		      sta	aiState
    598  3a51
    599  3a51		       60	   .slowWait  rts
    600  3a52
    601  3a52
    602  3a52		       a9 01	   .butpress  lda	#1
    603  3a54		       85 89		      sta	mdelay
    604  3a56
      0  3a56					      PHASE	AI_UnDrawTargetSquares
      1  3a56		       a9 07		      lda	#AI_UnDrawTargetSquares
      2  3a58		       85 8c		      sta	aiState
    606  3a5a		       60		      rts
    607  3a5b
    608  3a5b
    609  3a5b							;---------------------------------------------------------------------------------------------------
    610  3a5b
      0  3a5b					      DEF	moveCursor
      1  3a5b				   BANK_moveCursor SET	_CURRENT_BANK
      2  3a5b				   moveCursor
      3  3a5b				   TEMPORARY_VAR SET	Overlay
      4  3a5b				   TEMPORARY_OFFSET SET	0
      5  3a5b				   VAR_BOUNDARY_moveCursor SET	TEMPORARY_OFFSET
      6  3a5b				   FUNCTION_NAME SET	moveCursor
      7  3a5b					      SUBROUTINE
    612  3a5b					      SUBROUTINE
    613  3a5b
      0  3a5b					      REFER	aiSelectStartSquare
      1  3a5b				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  3a5b				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  3a5b					      ENDIF
      0  3a5b					      REFER	aiSelectDestinationSquare
      1  3a5b				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  3a5b				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  3a5b					      ENDIF
      0  3a5b					      VAR	__newCursor, 1
      1  3a5b		       00 a2	   __newCursor =	TEMPORARY_VAR
      2  3a5b				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  3a5b
      4  3a5b				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  3a5b				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  3a5b				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  3a5b					      ENDIF
      8  3a5b				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  3a5b				  -	      ECHO	"Temporary Variable", __newCursor, "overflow!"
     10  3a5b				  -	      ERR
     11  3a5b					      ENDIF
     12  3a5b					      LIST	ON
      0  3a5b					      VEND	moveCursor
      1  3a5b				  -	      IFNCONST	moveCursor
      2  3a5b				  -	      ECHO	"Incorrect VEND label", moveCursor
      3  3a5b				  -	      ERR
      4  3a5b					      ENDIF
      5  3a5b		       00 a3	   VAREND_moveCursor =	TEMPORARY_VAR
    618  3a5b
    619  3a5b							; Part (a) move cursor around the board waiting for joystick press
    620  3a5b
    621  3a5b		       a2 00		      ldx	#0	; delay
    622  3a5d
    623  3a5d		       ad 80 02 	      lda	SWCHA
    624  3a60		       4a		      lsr
    625  3a61		       4a		      lsr
    626  3a62		       4a		      lsr
    627  3a63		       4a		      lsr
    628  3a64		       a8		      tay
    629  3a65
    630  3a65		       c9 0f		      cmp	#15
    631  3a67		       f0 1a		      beq	.cursor	; nothing pressed - skip delays
    632  3a69
    633  3a69		       c6 89		      dec	mdelay
    634  3a6b		       10 1b		      bpl	.delaym
    635  3a6d
    636  3a6d		       18		      clc
    637  3a6e		       a5 88		      lda	cursorX12
    638  3a70		       79 49 f1 	      adc	JoyMoveCursor,y
    639  3a73		       85 a2		      sta	__newCursor
    640  3a75		       a8		      tay
    641  3a76		       20 d0 fc 	      jsr	GetValid
    642  3a79		       c9 ff		      cmp	#-1
    643  3a7b		       f0 04		      beq	.invalid
    644  3a7d		       a5 a2		      lda	__newCursor
    645  3a7f		       85 88		      sta	cursorX12
    646  3a81				   .invalid
    647  3a81
    648  3a81		       a2 10		      ldx	#CURSOR_MOVE_SPEED
    649  3a83		       86 89	   .cursor    stx	mdelay
    650  3a85		       20 10 f1 	      jsr	setCursorPriority
    651  3a88		       60	   .delaym    rts
    652  3a89
    653  3a89
    654  3a89							;---------------------------------------------------------------------------------------------------
    655  3a89
      0  3a89					      DEF	aiSelectDestinationSquare
      1  3a89				   BANK_aiSelectDestinationSquare SET	_CURRENT_BANK
      2  3a89				   aiSelectDestinationSquare
      3  3a89				   TEMPORARY_VAR SET	Overlay
      4  3a89				   TEMPORARY_OFFSET SET	0
      5  3a89				   VAR_BOUNDARY_aiSelectDestinationSquare SET	TEMPORARY_OFFSET
      6  3a89				   FUNCTION_NAME SET	aiSelectDestinationSquare
      7  3a89					      SUBROUTINE
    657  3a89					      SUBROUTINE
    658  3a89
      0  3a89					      REFER	AiStateMachine
      1  3a89				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3a89				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3a89					      ENDIF
      0  3a89					      VEND	aiSelectDestinationSquare
      1  3a89				  -	      IFNCONST	aiSelectDestinationSquare
      2  3a89				  -	      ECHO	"Incorrect VEND label", aiSelectDestinationSquare
      3  3a89				  -	      ERR
      4  3a89					      ENDIF
      5  3a89		       00 a2	   VAREND_aiSelectDestinationSquare =	TEMPORARY_VAR
    661  3a89
    662  3a89							; Piece is selected and now we're looking for a button press on a destination square
    663  3a89							; we flash the piece on-and-off while we're doing that
    664  3a89							; Flash the selected piece
    665  3a89
    666  3a89		       ad 84 02 	      lda	INTIM
    667  3a8c		       c9 28		      cmp	#ONCEPERFRAME
    668  3a8e		       90 0e		      bcc	.exit
    669  3a90
    670  3a90
    671  3a90		       c6 8d		      dec	aiFlashDelay
    672  3a92		       d0 0a		      bne	.exit	; don't flash
    673  3a94		       a9 14		      lda	#CAP_SPEED
    674  3a96		       85 8d		      sta	aiFlashDelay
    675  3a98
    676  3a98		       e6 8f		      inc	aiFlashPhase
    677  3a9a
    678  3a9a		       20 40 fd 	      jsr	CopySinglePiece
    679  3a9d		       60		      rts
    680  3a9e
    681  3a9e				   .exit
    682  3a9e		       20 5b f2 	      jsr	moveCursor
    683  3aa1
    684  3aa1		       ad 84 02 	      lda	INTIM
    685  3aa4		       c9 14		      cmp	#20
    686  3aa6		       90 35		      bcc	.noButton
    687  3aa8
    688  3aa8
    689  3aa8		       a4 88		      ldy	cursorX12
    690  3aaa		       84 86		      sty	toX12
    691  3aac
    692  3aac		       20 04 fd 	      jsr	GetPiece
    693  3aaf		       20 26 f1 	      jsr	setCursorColours
    694  3ab2
    695  3ab2
    696  3ab2							; y = valid square
    697  3ab2
    698  3ab2		       a5 4c		      lda	INPT4
    699  3ab4		       30 27		      bmi	.noButton
    700  3ab6
    701  3ab6		       a5 86		      lda	toX12
    702  3ab8		       c5 85		      cmp	fromX12
    703  3aba		       f0 0d		      beq	.cancel
    704  3abc
    705  3abc		       c0 ff		      cpy	#-1
    706  3abe		       f0 1d		      beq	.noButton	; not a valid square
    707  3ac0
    708  3ac0		       a5 8f		      lda	aiFlashPhase
    709  3ac2		       29 01		      and	#1
    710  3ac4		       f0 13		      beq	.done
    711  3ac6		       85 8d		      sta	aiFlashDelay	; EOR-phase incorrect - force quick fix to allow next-frame button detect
    712  3ac8		       60		      rts
    713  3ac9
    714  3ac9				   .cancel
    715  3ac9
    716  3ac9		       a5 8f		      lda	aiFlashPhase
    717  3acb		       29 01		      and	#1
    718  3acd		       f0 05		      beq	.doCancel
    719  3acf
    720  3acf							; EOR-phase incorrect - force quick fix to allow next-frame button detect
    721  3acf
    722  3acf		       a9 01		      lda	#1
    723  3ad1		       85 8d		      sta	aiFlashDelay
    724  3ad3		       60		      rts
    725  3ad4
    726  3ad4
      0  3ad4				   .doCancel  PHASE	AI_ReselectDebounce
      1  3ad4		       a9 0a		      lda	#AI_ReselectDebounce
      2  3ad6		       85 8c		      sta	aiState
    728  3ad8		       60		      rts
    729  3ad9
      0  3ad9				   .done      PHASE	AI_Quiescent	; destination selected!
      1  3ad9		       a9 09		      lda	#AI_Quiescent
      2  3adb		       85 8c		      sta	aiState
    731  3add		       60	   .noButton  rts
    732  3ade
    733  3ade
    734  3ade							;---------------------------------------------------------------------------------------------------
    735  3ade
      0  3ade					      DEF	aiReselectDebounce
      1  3ade				   BANK_aiReselectDebounce SET	_CURRENT_BANK
      2  3ade				   aiReselectDebounce
      3  3ade				   TEMPORARY_VAR SET	Overlay
      4  3ade				   TEMPORARY_OFFSET SET	0
      5  3ade				   VAR_BOUNDARY_aiReselectDebounce SET	TEMPORARY_OFFSET
      6  3ade				   FUNCTION_NAME SET	aiReselectDebounce
      7  3ade					      SUBROUTINE
    737  3ade					      SUBROUTINE
    738  3ade
      0  3ade					      REFER	AiStateMachine
      1  3ade				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3ade				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3ade					      ENDIF
      0  3ade					      VEND	aiReselectDebounce
      1  3ade				  -	      IFNCONST	aiReselectDebounce
      2  3ade				  -	      ECHO	"Incorrect VEND label", aiReselectDebounce
      3  3ade				  -	      ERR
      4  3ade					      ENDIF
      5  3ade		       00 a2	   VAREND_aiReselectDebounce =	TEMPORARY_VAR
    741  3ade
    742  3ade							; We've just cancelled the move. Wait for the button to be released
    743  3ade							; and then go back to selecting a piece to move
    744  3ade
    745  3ade		       a5 4c		      lda	INPT4
    746  3ae0		       10 04		      bpl	.exit	; button still pressed, so wait
    747  3ae2
      0  3ae2					      PHASE	AI_SelectStartSquare
      1  3ae2		       a9 02		      lda	#AI_SelectStartSquare
      2  3ae4		       85 8c		      sta	aiState
    749  3ae6		       60	   .exit      rts
    750  3ae7
    751  3ae7
    752  3ae7							;---------------------------------------------------------------------------------------------------
    753  3ae7
      0  3ae7					      DEF	aiQuiescent
      1  3ae7				   BANK_aiQuiescent SET	_CURRENT_BANK
      2  3ae7				   aiQuiescent
      3  3ae7				   TEMPORARY_VAR SET	Overlay
      4  3ae7				   TEMPORARY_OFFSET SET	0
      5  3ae7				   VAR_BOUNDARY_aiQuiescent SET	TEMPORARY_OFFSET
      6  3ae7				   FUNCTION_NAME SET	aiQuiescent
      7  3ae7					      SUBROUTINE
    755  3ae7					      SUBROUTINE
    756  3ae7
      0  3ae7					      REFER	AiStateMachine
      1  3ae7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3ae7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3ae7					      ENDIF
      0  3ae7					      VEND	aiQuiescent
      1  3ae7				  -	      IFNCONST	aiQuiescent
      2  3ae7				  -	      ECHO	"Incorrect VEND label", aiQuiescent
      3  3ae7				  -	      ERR
      4  3ae7					      ENDIF
      5  3ae7		       00 a2	   VAREND_aiQuiescent =	TEMPORARY_VAR
    759  3ae7
    760  3ae7							; Move has been selected
    761  3ae7
    762  3ae7		       a9 ff		      lda	#-1
    763  3ae9		       85 88		      sta	cursorX12
    764  3aeb
    765  3aeb		       a5 85		      lda	fromX12
    766  3aed		       85 87		      sta	originX12
    767  3aef		       20 04 fd 	      jsr	GetPiece	; from the movelist
    768  3af2
    769  3af2		       a4 85		      ldy	fromX12
    770  3af4		       20 dc fc 	      jsr	GetBoard	; get the piece from the board itself
    771  3af7
    772  3af7		       45 97		      eor	fromPiece
    773  3af9		       29 0f		      and	#PIECE_MASK	; if not the same piece board/movelist...
    774  3afb		       d0 05		      bne	.promote	; promote a pawn
    775  3afd
      0  3afd					      PHASE	AI_MoveIsSelected
      1  3afd		       a9 14		      lda	#AI_MoveIsSelected
      2  3aff		       85 8c		      sta	aiState
    777  3b01		       60		      rts
    778  3b02
      0  3b02				   .promote   PHASE	AI_PromotePawnStart
      1  3b02		       a9 1f		      lda	#AI_PromotePawnStart
      2  3b04		       85 8c		      sta	aiState
    780  3b06		       60		      rts
    781  3b07
    782  3b07
    783  3b07							;---------------------------------------------------------------------------------------------------
    784  3b07
      0  3b07					      DEF	aiPromotePawnStart
      1  3b07				   BANK_aiPromotePawnStart SET	_CURRENT_BANK
      2  3b07				   aiPromotePawnStart
      3  3b07				   TEMPORARY_VAR SET	Overlay
      4  3b07				   TEMPORARY_OFFSET SET	0
      5  3b07				   VAR_BOUNDARY_aiPromotePawnStart SET	TEMPORARY_OFFSET
      6  3b07				   FUNCTION_NAME SET	aiPromotePawnStart
      7  3b07					      SUBROUTINE
    786  3b07					      SUBROUTINE
    787  3b07
      0  3b07					      REFER	AiStateMachine
      1  3b07				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3b07				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3b07					      ENDIF
      0  3b07					      VEND	aiPromotePawnStart
      1  3b07				  -	      IFNCONST	aiPromotePawnStart
      2  3b07				  -	      ECHO	"Incorrect VEND label", aiPromotePawnStart
      3  3b07				  -	      ERR
      4  3b07					      ENDIF
      5  3b07		       00 a2	   VAREND_aiPromotePawnStart =	TEMPORARY_VAR
    790  3b07
    791  3b07
    792  3b07		       ad 84 02 	      lda	INTIM
    793  3b0a		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    794  3b0c		       90 18		      bcc	.exit
    795  3b0e
    796  3b0e		       a9 00		      lda	#0
    797  3b10		       85 8f		      sta	aiFlashPhase
    798  3b12		       85 8d		      sta	aiFlashDelay
    799  3b14
    800  3b14		       a4 86		      ldy	toX12
    801  3b16		       84 80		      sty	squareToDraw
    802  3b18
    803  3b18		       20 dc fc 	      jsr	GetBoard
    804  3b1b		       29 0f		      and	#PIECE_MASK
    805  3b1d		       f0 03		      beq	.empty
    806  3b1f
    807  3b1f		       20 40 fd 	      jsr	CopySinglePiece	; remove any capturable piece for display purposes
    808  3b22
      0  3b22				   .empty     PHASE	AI_RollPromotionPiece
      1  3b22		       a9 20		      lda	#AI_RollPromotionPiece
      2  3b24		       85 8c		      sta	aiState
    810  3b26		       60	   .exit      rts
    811  3b27
    812  3b27
    813  3b27							;---------------------------------------------------------------------------------------------------
    814  3b27
      0  3b27					      DEF	aiRollPromotionPiece
      1  3b27				   BANK_aiRollPromotionPiece SET	_CURRENT_BANK
      2  3b27				   aiRollPromotionPiece
      3  3b27				   TEMPORARY_VAR SET	Overlay
      4  3b27				   TEMPORARY_OFFSET SET	0
      5  3b27				   VAR_BOUNDARY_aiRollPromotionPiece SET	TEMPORARY_OFFSET
      6  3b27				   FUNCTION_NAME SET	aiRollPromotionPiece
      7  3b27					      SUBROUTINE
    816  3b27					      SUBROUTINE
    817  3b27
      0  3b27					      REFER	AiStateMachine
      1  3b27				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3b27				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3b27					      ENDIF
      0  3b27					      VEND	aiRollPromotionPiece
      1  3b27				  -	      IFNCONST	aiRollPromotionPiece
      2  3b27				  -	      ECHO	"Incorrect VEND label", aiRollPromotionPiece
      3  3b27				  -	      ERR
      4  3b27					      ENDIF
      5  3b27		       00 a2	   VAREND_aiRollPromotionPiece =	TEMPORARY_VAR
    820  3b27
    821  3b27							; Flash the '?' and wait for an UDLR move
    822  3b27
    823  3b27		       ad 84 02 	      lda	INTIM
    824  3b2a		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    825  3b2c		       90 28		      bcc	.exit
    826  3b2e
    827  3b2e		       ad 80 02 	      lda	SWCHA
    828  3b31		       29 f0		      and	#$F0
    829  3b33		       c9 f0		      cmp	#$F0
    830  3b35		       f0 0a		      beq	.nojoy
    831  3b37
    832  3b37		       a9 00		      lda	#0
    833  3b39		       85 8d		      sta	aiFlashDelay
    834  3b3b
    835  3b3b		       a5 8f		      lda	aiFlashPhase
    836  3b3d		       29 01		      and	#1
    837  3b3f		       f0 16		      beq	.even
    838  3b41
    839  3b41		       c6 8d	   .nojoy     dec	aiFlashDelay
    840  3b43		       10 11		      bpl	.exit
    841  3b45
    842  3b45		       a9 0a		      lda	#10
    843  3b47		       85 8d		      sta	aiFlashDelay
    844  3b49
    845  3b49		       a2 20		      ldx	#INDEX_WHITE_PROMOTE_on_WHITE_SQUARE_0
    846  3b4b		       a5 96		      lda	sideToMove
    847  3b4d		       10 02		      bpl	.wtm
    848  3b4f		       a2 68		      ldx	#INDEX_BLACK_PROMOTE_on_WHITE_SQUARE_0
    849  3b51				   .wtm
    850  3b51		       20 94 fd 	      jsr	showPromoteOptions
    851  3b54
    852  3b54		       e6 8f		      inc	aiFlashPhase
    853  3b56
    854  3b56		       60	   .exit      rts
    855  3b57
    856  3b57
    857  3b57		       a9 03	   .even      lda	#3	; QUEEN
    858  3b59		       85 97		      sta	fromPiece	; cycles as index to NBRQ
    859  3b5b
    860  3b5b		       e6 8f		      inc	aiFlashPhase
    861  3b5d
    862  3b5d
    863  3b5d		       a2 14		      ldx	#INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0	;TODO: fix for colour
    864  3b5f		       a5 96		      lda	sideToMove
    865  3b61		       10 02		      bpl	.whiteToMove
    866  3b63		       a2 5c		      ldx	#INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    867  3b65				   .whiteToMove
    868  3b65
    869  3b65		       20 94 fd 	      jsr	showPromoteOptions
    870  3b68
      0  3b68					      PHASE	AI_ChooseDebounce
      1  3b68		       a9 22		      lda	#AI_ChooseDebounce
      2  3b6a		       85 8c		      sta	aiState
    872  3b6c		       60		      rts
    873  3b6d
    874  3b6d
    875  3b6d							;---------------------------------------------------------------------------------------------------
    876  3b6d
      0  3b6d					      DEF	aiChoosePromotePiece
      1  3b6d				   BANK_aiChoosePromotePiece SET	_CURRENT_BANK
      2  3b6d				   aiChoosePromotePiece
      3  3b6d				   TEMPORARY_VAR SET	Overlay
      4  3b6d				   TEMPORARY_OFFSET SET	0
      5  3b6d				   VAR_BOUNDARY_aiChoosePromotePiece SET	TEMPORARY_OFFSET
      6  3b6d				   FUNCTION_NAME SET	aiChoosePromotePiece
      7  3b6d					      SUBROUTINE
    878  3b6d					      SUBROUTINE
    879  3b6d
      0  3b6d					      REFER	AiStateMachine
      1  3b6d				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3b6d				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3b6d					      ENDIF
      0  3b6d					      VEND	aiChoosePromotePiece
      1  3b6d				  -	      IFNCONST	aiChoosePromotePiece
      2  3b6d				  -	      ECHO	"Incorrect VEND label", aiChoosePromotePiece
      3  3b6d				  -	      ERR
      4  3b6d					      ENDIF
      5  3b6d		       00 a2	   VAREND_aiChoosePromotePiece =	TEMPORARY_VAR
    882  3b6d
    883  3b6d							; Question-mark phase has exited via joystick direction
    884  3b6d							; Now we cycle through the selectable pieces
    885  3b6d
    886  3b6d		       ad 84 02 	      lda	INTIM
    887  3b70		       c9 29		      cmp	#SPEEDOF_COPYSINGLEPIECE
    888  3b72		       90 40		      bcc	.exit
    889  3b74
    890  3b74		       a5 4c		      lda	INPT4
    891  3b76		       30 0a		      bmi	.nobut	; no press
    892  3b78
    893  3b78							; button pressed but make sure phase is correct for exit
    894  3b78
    895  3b78		       a9 00		      lda	#0
    896  3b7a		       85 8d		      sta	aiFlashDelay
    897  3b7c
    898  3b7c		       a5 8f		      lda	aiFlashPhase
    899  3b7e		       29 01		      and	#1
    900  3b80		       f0 33		      beq	.chosen	; button pressed --> selection made
    901  3b82
    902  3b82				   .nobut
    903  3b82		       ad 80 02 	      lda	SWCHA
    904  3b85		       29 f0		      and	#$F0
    905  3b87		       c9 f0		      cmp	#$F0
    906  3b89		       f0 17		      beq	.odd	; no direction pressed
    907  3b8b
    908  3b8b		       4a		      lsr
    909  3b8c		       4a		      lsr
    910  3b8d		       4a		      lsr
    911  3b8e		       4a		      lsr
    912  3b8f		       a8		      tay
    913  3b90
    914  3b90							; joystick but make sure phase is correct
    915  3b90
    916  3b90		       a5 8f		      lda	aiFlashPhase
    917  3b92		       4a		      lsr
    918  3b93		       b0 0d		      bcs	.odd	; must wait until piece undrawn
    919  3b95
    920  3b95							; cycle to the next promotable piece (N/B/R/Q)
    921  3b95							; TODO; use joy table for mod instead of just incrementing all the time
    922  3b95
    923  3b95							;clc
    924  3b95		       a5 97		      lda	fromPiece
    925  3b97		       79 39 f1 	      adc	JoyCombined,y
    926  3b9a		       29 03		      and	#3
    927  3b9c		       85 97		      sta	fromPiece
    928  3b9e
      0  3b9e					      PHASE	AI_ChooseDebounce	; wait for release
      1  3b9e		       a9 22		      lda	#AI_ChooseDebounce
      2  3ba0		       85 8c		      sta	aiState
    930  3ba2
    931  3ba2		       c6 8d	   .odd       dec	aiFlashDelay
    932  3ba4		       10 0e		      bpl	.exit
    933  3ba6
    934  3ba6		       a9 0a	   .force     lda	#10
    935  3ba8		       85 8d		      sta	aiFlashDelay
    936  3baa
    937  3baa		       e6 8f		      inc	aiFlashPhase
    938  3bac
    939  3bac		       a4 97		      ldy	fromPiece
    940  3bae		       be d0 f3 	      ldx	promotePiece,y
    941  3bb1		       20 94 fd 	      jsr	showPromoteOptions
    942  3bb4
    943  3bb4		       60	   .exit      rts
    944  3bb5
    945  3bb5
    946  3bb5				   .chosen
    947  3bb5		       a5 97		      lda	fromPiece
    948  3bb7		       29 0f		      and	#PIECE_MASK
    949  3bb9		       aa		      tax
    950  3bba
    951  3bba		       bd d4 f3 	      lda	promoteType,x
    952  3bbd		       85 97		      sta	fromPiece
    953  3bbf
    954  3bbf		       a4 86		      ldy	toX12
    955  3bc1		       20 dc fc 	      jsr	GetBoard
    956  3bc4		       29 0f		      and	#PIECE_MASK
    957  3bc6		       f0 03		      beq	.nothing
    958  3bc8
    959  3bc8		       20 40 fd 	      jsr	CopySinglePiece	; put back whatever was there to start
    960  3bcb
      0  3bcb				   .nothing   PHASE	AI_MoveIsSelected
      1  3bcb		       a9 14		      lda	#AI_MoveIsSelected
      2  3bcd		       85 8c		      sta	aiState
    962  3bcf		       60		      rts
    963  3bd0
      0  3bd0					      ALLOCATE	promotePiece, 4
      0  3bd0					      OPTIONAL_PAGEBREAK	"Table", 4
     12  3bd0					      LIST	ON
      0  3bd0					      DEF	promotePiece
      1  3bd0				   BANK_promotePiece SET	_CURRENT_BANK
      2  3bd0				   promotePiece
      3  3bd0				   TEMPORARY_VAR SET	Overlay
      4  3bd0				   TEMPORARY_OFFSET SET	0
      5  3bd0				   VAR_BOUNDARY_promotePiece SET	TEMPORARY_OFFSET
      6  3bd0				   FUNCTION_NAME SET	promotePiece
      7  3bd0					      SUBROUTINE
    965  3bd0		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    966  3bd1		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    967  3bd2		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    968  3bd3		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    969  3bd4
      0  3bd4					      ALLOCATE	promoteType,4
      0  3bd4					      OPTIONAL_PAGEBREAK	"Table", 4
     12  3bd4					      LIST	ON
      0  3bd4					      DEF	promoteType
      1  3bd4				   BANK_promoteType SET	_CURRENT_BANK
      2  3bd4				   promoteType
      3  3bd4				   TEMPORARY_VAR SET	Overlay
      4  3bd4				   TEMPORARY_OFFSET SET	0
      5  3bd4				   VAR_BOUNDARY_promoteType SET	TEMPORARY_OFFSET
      6  3bd4				   FUNCTION_NAME SET	promoteType
      7  3bd4					      SUBROUTINE
    971  3bd4		       03 04 05 06	      .byte.b	KNIGHT, BISHOP, ROOK, QUEEN
    972  3bd8
    973  3bd8
    974  3bd8							;---------------------------------------------------------------------------------------------------
    975  3bd8
      0  3bd8					      DEF	aiChooseDebounce
      1  3bd8				   BANK_aiChooseDebounce SET	_CURRENT_BANK
      2  3bd8				   aiChooseDebounce
      3  3bd8				   TEMPORARY_VAR SET	Overlay
      4  3bd8				   TEMPORARY_OFFSET SET	0
      5  3bd8				   VAR_BOUNDARY_aiChooseDebounce SET	TEMPORARY_OFFSET
      6  3bd8				   FUNCTION_NAME SET	aiChooseDebounce
      7  3bd8					      SUBROUTINE
    977  3bd8					      SUBROUTINE
    978  3bd8
      0  3bd8					      REFER	AiStateMachine
      1  3bd8				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  3bd8				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  3bd8					      ENDIF
      0  3bd8					      VEND	aiChooseDebounce
      1  3bd8				  -	      IFNCONST	aiChooseDebounce
      2  3bd8				  -	      ECHO	"Incorrect VEND label", aiChooseDebounce
      3  3bd8				  -	      ERR
      4  3bd8					      ENDIF
      5  3bd8		       00 a2	   VAREND_aiChooseDebounce =	TEMPORARY_VAR
    981  3bd8
    982  3bd8							; We've changed promotion piece, but wait for joystick to be released
    983  3bd8
    984  3bd8		       ad 80 02 	      lda	SWCHA
    985  3bdb		       29 f0		      and	#$F0
    986  3bdd		       c9 f0		      cmp	#$F0
    987  3bdf		       d0 08		      bne	.exit	; wait while joystick still pressed
    988  3be1
    989  3be1		       a9 01		      lda	#1
    990  3be3		       85 8d		      sta	aiFlashDelay
    991  3be5
      0  3be5					      PHASE	AI_ChoosePromotePiece
      1  3be5		       a9 21		      lda	#AI_ChoosePromotePiece
      2  3be7		       85 8c		      sta	aiState
    993  3be9		       60	   .exit      rts
    994  3bea
    995  3bea
    996  3bea							;---------------------------------------------------------------------------------------------------
    997  3bea
      0  3bea					      DEF	aiDelayAfterMove
      1  3bea				   BANK_aiDelayAfterMove SET	_CURRENT_BANK
      2  3bea				   aiDelayAfterMove
      3  3bea				   TEMPORARY_VAR SET	Overlay
      4  3bea				   TEMPORARY_OFFSET SET	0
      5  3bea				   VAR_BOUNDARY_aiDelayAfterMove SET	TEMPORARY_OFFSET
      6  3bea				   FUNCTION_NAME SET	aiDelayAfterMove
      7  3bea					      SUBROUTINE
    999  3bea					      SUBROUTINE
   1000  3bea
      0  3bea					      VEND	aiDelayAfterMove
      1  3bea				  -	      IFNCONST	aiDelayAfterMove
      2  3bea				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  3bea				  -	      ERR
      4  3bea					      ENDIF
      5  3bea		       00 a2	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
   1002  3bea
   1003  3bea		       a9 32		      lda	#50
   1004  3bec		       85 8d		      sta	aiFlashDelay
      0  3bee					      PHASE	AI_DelayAfterMove2
      1  3bee		       a9 26		      lda	#AI_DelayAfterMove2
      2  3bf0		       85 8c		      sta	aiState
   1006  3bf2		       60	   .exit      rts
   1007  3bf3
   1008  3bf3
   1009  3bf3							;---------------------------------------------------------------------------------------------------
   1010  3bf3
      0  3bf3					      DEF	aiDelayAfterMove2
      1  3bf3				   BANK_aiDelayAfterMove2 SET	_CURRENT_BANK
      2  3bf3				   aiDelayAfterMove2
      3  3bf3				   TEMPORARY_VAR SET	Overlay
      4  3bf3				   TEMPORARY_OFFSET SET	0
      5  3bf3				   VAR_BOUNDARY_aiDelayAfterMove2 SET	TEMPORARY_OFFSET
      6  3bf3				   FUNCTION_NAME SET	aiDelayAfterMove2
      7  3bf3					      SUBROUTINE
   1012  3bf3					      SUBROUTINE
   1013  3bf3
      0  3bf3					      VEND	aiDelayAfterMove
      1  3bf3				  -	      IFNCONST	aiDelayAfterMove
      2  3bf3				  -	      ECHO	"Incorrect VEND label", aiDelayAfterMove
      3  3bf3				  -	      ERR
      4  3bf3					      ENDIF
      5  3bf3		       00 a2	   VAREND_aiDelayAfterMove =	TEMPORARY_VAR
   1015  3bf3
   1016  3bf3		       c6 8d		      dec	aiFlashDelay
   1017  3bf5		       d0 04		      bne	.exit
      0  3bf7					      PHASE	AI_MoveIsSelected
      1  3bf7		       a9 14		      lda	#AI_MoveIsSelected
      2  3bf9		       85 8c		      sta	aiState
   1019  3bfb		       60	   .exit      rts
   1020  3bfc
   1021  3bfc
   1022  3bfc							;---------------------------------------------------------------------------------------------------
   1023  3bfc
      0  3bfc					      DEF	aiDelayAfterPlaced
      1  3bfc				   BANK_aiDelayAfterPlaced SET	_CURRENT_BANK
      2  3bfc				   aiDelayAfterPlaced
      3  3bfc				   TEMPORARY_VAR SET	Overlay
      4  3bfc				   TEMPORARY_OFFSET SET	0
      5  3bfc				   VAR_BOUNDARY_aiDelayAfterPlaced SET	TEMPORARY_OFFSET
      6  3bfc				   FUNCTION_NAME SET	aiDelayAfterPlaced
      7  3bfc					      SUBROUTINE
   1025  3bfc					      SUBROUTINE
   1026  3bfc
      0  3bfc					      VEND	aiDelayAfterPlaced
      1  3bfc				  -	      IFNCONST	aiDelayAfterPlaced
      2  3bfc				  -	      ECHO	"Incorrect VEND label", aiDelayAfterPlaced
      3  3bfc				  -	      ERR
      4  3bfc					      ENDIF
      5  3bfc		       00 a2	   VAREND_aiDelayAfterPlaced =	TEMPORARY_VAR
   1028  3bfc
   1029  3bfc		       a2 4b		      ldx	#75	; delay after human move
   1030  3bfe		       a5 96		      lda	sideToMove
   1031  3c00		       30 02		      bmi	.computer
   1032  3c02		       a2 01		      ldx	#1	; delay after computer move
   1033  3c04		       86 8d	   .computer  stx	aiFlashDelay
   1034  3c06
      0  3c06					      PHASE	AI_DelayAfterPlaced2
      1  3c06		       a9 28		      lda	#AI_DelayAfterPlaced2
      2  3c08		       85 8c		      sta	aiState
   1036  3c0a		       60		      rts
   1037  3c0b
   1038  3c0b
   1039  3c0b							;---------------------------------------------------------------------------------------------------
   1040  3c0b
      0  3c0b					      DEF	aiDelayAfterPlaced2
      1  3c0b				   BANK_aiDelayAfterPlaced2 SET	_CURRENT_BANK
      2  3c0b				   aiDelayAfterPlaced2
      3  3c0b				   TEMPORARY_VAR SET	Overlay
      4  3c0b				   TEMPORARY_OFFSET SET	0
      5  3c0b				   VAR_BOUNDARY_aiDelayAfterPlaced2 SET	TEMPORARY_OFFSET
      6  3c0b				   FUNCTION_NAME SET	aiDelayAfterPlaced2
      7  3c0b					      SUBROUTINE
   1042  3c0b					      SUBROUTINE
   1043  3c0b
   1044  3c0b		       20 e5 f9 	      jsr	debug
   1045  3c0e
   1046  3c0e		       c6 8d		      dec	aiFlashDelay
   1047  3c10		       d0 04		      bne	.exit
      0  3c12					      PHASE	AI_GenerateMoves
      1  3c12		       a9 12		      lda	#AI_GenerateMoves
      2  3c14		       85 8c		      sta	aiState
   1049  3c16		       60	   .exit      rts
   1050  3c17
   1051  3c17
   1052  3c17							;---------------------------------------------------------------------------------------------------
   1053  3c17
   1054  3d00		       00 00 00 00*	      align	256
      0  3d00					      DEF	PositionSprites
      1  3d00				   BANK_PositionSprites SET	_CURRENT_BANK
      2  3d00				   PositionSprites
      3  3d00				   TEMPORARY_VAR SET	Overlay
      4  3d00				   TEMPORARY_OFFSET SET	0
      5  3d00				   VAR_BOUNDARY_PositionSprites SET	TEMPORARY_OFFSET
      6  3d00				   FUNCTION_NAME SET	PositionSprites
      7  3d00					      SUBROUTINE
   1056  3d00					      SUBROUTINE
   1057  3d00
      0  3d00					      REFER	Reset
      1  3d00				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  3d00				  -TEMPORARY_VAR SET	VAREND_Reset
      3  3d00					      ENDIF
      0  3d00					      VEND	PositionSprites
      1  3d00				  -	      IFNCONST	PositionSprites
      2  3d00				  -	      ECHO	"Incorrect VEND label", PositionSprites
      3  3d00				  -	      ERR
      4  3d00					      ENDIF
      5  3d00		       00 a2	   VAREND_PositionSprites =	TEMPORARY_VAR
   1060  3d00
   1061  3d00
   1062  3d00		       a5 88		      lda	cursorX12
   1063  3d02		       38		      sec
   1064  3d03		       e9 0a	   .sub10     sbc	#10
   1065  3d05		       b0 fc		      bcs	.sub10
   1066  3d07		       69 08		      adc	#8
   1067  3d09		       a8		      tay
   1068  3d0a
   1069  3d0a		       85 42		      sta	WSYNC	; 00	  Sync to start of scanline.
   1070  3d0c
   1071  3d0c		       b9 30 f5 	      lda	colToPixel,y
   1072  3d0f
   1073  3d0f		       38		      sec		; 02	  Set the carry flag so no borrow will be applied during the division.
   1074  3d10		       e9 0f	   .divideby15 sbc	#15	; 04	  Waste the necessary amount of time dividing X-pos by 15!
   1075  3d12		       b0 fc		      bcs	.divideby15	; 06/07  11/16/21/26/31/36/41/46/51/56/61/66
   1076  3d14
   1077  3d14		       a8		      tay
   1078  3d15		       b9 30 f4 	      lda	fineAdjustTable,y	; 13 -> Consume 5 cycles by guaranteeing we cross a page boundary
   1079  3d18		       85 60		      sta	HMP0
   1080  3d1a		       85 50		      sta	RESP0	; 21/ 26/31/36/41/46/51/56/61/66/71 - Set the rough position.
   1081  3d1c
   1082  3d1c		       85 42		      sta	WSYNC
   1083  3d1e		       85 6a		      sta	HMOVE
   1084  3d20
   1085  3d20		       60		      rts
   1086  3d21
   1087  3d21							; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
   1088  3d21							; fine adjustment value. This table is on a page boundary to guarantee the processor
   1089  3d21							; will cross a page boundary and waste a cycle in order to be at the precise position
   1090  3d21							; for a RESP0,x write
   1091  3d21
   1092  3d21				   fineAdjustBegin
   1093  3d21
   1094  3d21		       70		      DC.B	%01110000	; Left 7
   1095  3d22		       60		      DC.B	%01100000	; Left 6
   1096  3d23		       50		      DC.B	%01010000	; Left 5
   1097  3d24		       40		      DC.B	%01000000	; Left 4
   1098  3d25		       30		      DC.B	%00110000	; Left 3
   1099  3d26		       20		      DC.B	%00100000	; Left 2
   1100  3d27		       10		      DC.B	%00010000	; Left 1
   1101  3d28		       00		      DC.B	%00000000	; No movement.
   1102  3d29		       f0		      DC.B	%11110000	; Right 1
   1103  3d2a		       e0		      DC.B	%11100000	; Right 2
   1104  3d2b		       d0		      DC.B	%11010000	; Right 3
   1105  3d2c		       c0		      DC.B	%11000000	; Right 4
   1106  3d2d		       b0		      DC.B	%10110000	; Right 5
   1107  3d2e		       a0		      DC.B	%10100000	; Right 6
   1108  3d2f		       90		      DC.B	%10010000	; Right 7
   1109  3d30
   1110  3d30		       f4 30	   fineAdjustTable EQU	fineAdjustBegin - %11110001	; NOTE: %11110001 = -15
   1111  3d30
   1112  3d30
      0  3d30					      ALLOCATE	colToPixel, 8
      0  3d30					      OPTIONAL_PAGEBREAK	"Table", 8
     12  3d30					      LIST	ON
      0  3d30					      DEF	colToPixel
      1  3d30				   BANK_colToPixel SET	_CURRENT_BANK
      2  3d30				   colToPixel
      3  3d30				   TEMPORARY_VAR SET	Overlay
      4  3d30				   TEMPORARY_OFFSET SET	0
      5  3d30				   VAR_BOUNDARY_colToPixel SET	TEMPORARY_OFFSET
      6  3d30				   FUNCTION_NAME SET	colToPixel
      7  3d30					      SUBROUTINE
   1114  3d30		       00 14 28 3c*	      .byte.b	0,20,40,60,80,100,120,140
   1115  3d38
   1116  3d38							;---------------------------------------------------------------------------------------------------
   1117  3d38
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  3d38					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_0.asm"
      0  3d38					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_0", 72
     12  3d38					      LIST	ON
      0  3d38					      DEF	BLACK_MARKER_on_BLACK_SQUARE_0
      1  3d38				   BANK_BLACK_MARKER_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  3d38				   BLACK_MARKER_on_BLACK_SQUARE_0
      3  3d38				   TEMPORARY_VAR SET	Overlay
      4  3d38				   TEMPORARY_OFFSET SET	0
      5  3d38				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3d38				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_0
      7  3d38					      SUBROUTINE
      3  3d38		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d50		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3d68		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  3d80					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_1.asm"
      0  3d80					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_1", 72
     12  3d80					      LIST	ON
      0  3d80					      DEF	BLACK_MARKER_on_BLACK_SQUARE_1
      1  3d80				   BANK_BLACK_MARKER_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  3d80				   BLACK_MARKER_on_BLACK_SQUARE_1
      3  3d80				   TEMPORARY_VAR SET	Overlay
      4  3d80				   TEMPORARY_OFFSET SET	0
      5  3d80				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3d80				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_1
      7  3d80					      SUBROUTINE
      3  3d80		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3d98		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3db0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  3dc8					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_2.asm"
      0  3dc8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_2", 72
     12  3e00					      LIST	ON
      0  3e00					      DEF	BLACK_MARKER_on_BLACK_SQUARE_2
      1  3e00				   BANK_BLACK_MARKER_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  3e00				   BLACK_MARKER_on_BLACK_SQUARE_2
      3  3e00				   TEMPORARY_VAR SET	Overlay
      4  3e00				   TEMPORARY_OFFSET SET	0
      5  3e00				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3e00				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_2
      7  3e00					      SUBROUTINE
      3  3e00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e30		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  3e48					      include	"gfx/BLACK_MARKER_on_BLACK_SQUARE_3.asm"
      0  3e48					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_BLACK_SQUARE_3", 72
     12  3e48					      LIST	ON
      0  3e48					      DEF	BLACK_MARKER_on_BLACK_SQUARE_3
      1  3e48				   BANK_BLACK_MARKER_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  3e48				   BLACK_MARKER_on_BLACK_SQUARE_3
      3  3e48				   TEMPORARY_VAR SET	Overlay
      4  3e48				   TEMPORARY_OFFSET SET	0
      5  3e48				   VAR_BOUNDARY_BLACK_MARKER_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3e48				   FUNCTION_NAME SET	BLACK_MARKER_on_BLACK_SQUARE_3
      7  3e48					      SUBROUTINE
      3  3e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3e60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3e78		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  3e90					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_0.asm"
      0  3e90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_0", 72
     12  3e90					      LIST	ON
      0  3e90					      DEF	BLACK_MARKER_on_WHITE_SQUARE_0
      1  3e90				   BANK_BLACK_MARKER_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  3e90				   BLACK_MARKER_on_WHITE_SQUARE_0
      3  3e90				   TEMPORARY_VAR SET	Overlay
      4  3e90				   TEMPORARY_OFFSET SET	0
      5  3e90				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  3e90				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_0
      7  3e90					      SUBROUTINE
      3  3e90		       00 00 00 40*	      .byte.b	$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00,$00,$00,$00,$40,$40,$00,$00,$00	;PF0
      4  3ea8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3ec0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  3ed8					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_1.asm"
      0  3ed8					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_1", 72
     12  3f00					      LIST	ON
      0  3f00					      DEF	BLACK_MARKER_on_WHITE_SQUARE_1
      1  3f00				   BANK_BLACK_MARKER_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  3f00				   BLACK_MARKER_on_WHITE_SQUARE_1
      3  3f00				   TEMPORARY_VAR SET	Overlay
      4  3f00				   TEMPORARY_OFFSET SET	0
      5  3f00				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  3f00				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_1
      7  3f00					      SUBROUTINE
      3  3f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f18		       00 00 00 10*	      .byte.b	$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00,$00,$00,$00,$10,$10,$00,$00,$00	;PF1
      5  3f30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  3f48					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_2.asm"
      0  3f48					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_2", 72
     12  3f48					      LIST	ON
      0  3f48					      DEF	BLACK_MARKER_on_WHITE_SQUARE_2
      1  3f48				   BANK_BLACK_MARKER_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  3f48				   BLACK_MARKER_on_WHITE_SQUARE_2
      3  3f48				   TEMPORARY_VAR SET	Overlay
      4  3f48				   TEMPORARY_OFFSET SET	0
      5  3f48				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  3f48				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_2
      7  3f48					      SUBROUTINE
      3  3f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3f78		       00 00 00 01*	      .byte.b	$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
------- FILE gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  3f90					      include	"gfx/BLACK_MARKER_on_WHITE_SQUARE_3.asm"
      0  3f90					      OPTIONAL_PAGEBREAK	"BLACK_MARKER_on_WHITE_SQUARE_3", 72
     12  3f90					      LIST	ON
      0  3f90					      DEF	BLACK_MARKER_on_WHITE_SQUARE_3
      1  3f90				   BANK_BLACK_MARKER_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  3f90				   BLACK_MARKER_on_WHITE_SQUARE_3
      3  3f90				   TEMPORARY_VAR SET	Overlay
      4  3f90				   TEMPORARY_OFFSET SET	0
      5  3f90				   VAR_BOUNDARY_BLACK_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  3f90				   FUNCTION_NAME SET	BLACK_MARKER_on_WHITE_SQUARE_3
      7  3f90					      SUBROUTINE
      3  3f90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  3fa8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  3fc0		       00 00 00 20*	      .byte.b	$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00,$00,$00,$00,$20,$20,$00,$00,$00	;PF2
------- FILE BANK_StateMachine.asm
   1126  3fd8
   1127  3fd8							;---------------------------------------------------------------------------------------------------
   1128  3fd8
      0  3fd8					      CHECK_BANK_SIZE	"BANK_StateMachine"
      1  3fd8		       07 d8	   .TEMP      =	* - BANK_START
 BANK_StateMachine (2K) SIZE =  $7d8 , FREE= $28
      2  3fd8					      ECHO	"BANK_StateMachine", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3fd8				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  3fd8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3fd8				  -	      ERR
      6  3fd8					      ENDIF
      7  3fd8
   1130  3fd8
   1131  3fd8
   1132  3fd8							;---------------------------------------------------------------------------------------------------
   1133  3fd8
   1134  3fd8							; EOF
------- FILE ./chess.asm
------- FILE BANK_TEXT_OVERLAYS.asm LEVEL 2 PASS 5
      0  3fd8					      include	"BANK_TEXT_OVERLAYS.asm"
      0  3fd8					      NEWBANK	TEXT_OVERLAYS
      1  4002 ????				      SEG	TEXT_OVERLAYS
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   TEXT_OVERLAYS SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	TEXT_OVERLAYS
      2  4000
      3  4000
      4  4000
      5  4000
      6  4000				   sample
      7  4000		       48 aa		      .byte.b	72,%10101010
      8  4002
      9  4002
     10  4002
     11  4002							;EOF
------- FILE ./chess.asm
------- FILE BANK_PLIST.asm LEVEL 2 PASS 5
      0  4002					      include	"BANK_PLIST.asm"
      0  4002					      NEWRAMBANK	RAM_PIECELIST
      1  4002
      2  4002
      3  4002
      4 U2000 ????				      SEG.U	RAM_PIECELIST
      5 U2000					      ORG	ORIGIN_RAM
      6 U2000					      RORG	RAM_3E
      7 U2000				   BANK_START SET	*
      8 U2000				   RAMBANK_RAM_PIECELIST SET	ORIGIN_RAM / RAM_SIZE
      9 U2000				   _CURRENT_RAMBANK SET	RAMBANK_RAM_PIECELIST
     10 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U2000					      NEWBANK	ROM_PIECELIST
      1  4820 ????				      SEG	ROM_PIECELIST
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   ROM_PIECELIST SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	ROM_PIECELIST
      3  4800
      4  4800
      5  4800
      6  4800							; We have 16 white pieces, followed by 16 black pieces
      7  4800
      8  4800
      0  4800					      VARIABLE	PiecePointer, 32
      0  4800					      OPTIONAL_PAGEBREAK	"Variable", 32
     12  4800					      LIST	ON
      2  4800		       00 00 00 00*PiecePointer ds	32
     10  4820
     11  4820
     12  4820
     13  4820
     14  4820
      0  4820					      CHECK_BANK_SIZE	"BANK_PIECELIST"
      1  4820		       00 20	   .TEMP      =	* - BANK_START
 BANK_PIECELIST (2K) SIZE =  $20 , FREE= $7e0
      2  4820					      ECHO	"BANK_PIECELIST", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4820				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  4820				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4820				  -	      ERR
      6  4820					      ENDIF
      7  4820
     16  4820
     17  4820							;---------------------------------------------------------------------------------------------------
     18  4820							; EOF
------- FILE ./chess.asm
    604  4820
------- FILE titleScreen.asm LEVEL 2 PASS 5
      0  4820					      include	"titleScreen.asm"
      0  4820					      NEWBANK	TITLESCREEN
      1  57c0 ????				      SEG	TITLESCREEN
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   TITLESCREEN SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	TITLESCREEN
      2  5000
      3  5000				   OverscanTime2
      4  5000		       1a 1a		      .byte.b	26, 26
      5  5002		       20 20		      .byte.b	32, 32
      6  5004
      7  5004							;colvec
      8  5004							;    .word colr_ntsc2, colr_pal
      9  5004
     10  5004
     11  5004		       32 32	   VBlankTime .byte.b	50,50
     12  5006
      0  5006					      DEF	TitleScreen
      1  5006				   BANK_TitleScreen SET	_CURRENT_BANK
      2  5006				   TitleScreen
      3  5006				   TEMPORARY_VAR SET	Overlay
      4  5006				   TEMPORARY_OFFSET SET	0
      5  5006				   VAR_BOUNDARY_TitleScreen SET	TEMPORARY_OFFSET
      6  5006				   FUNCTION_NAME SET	TitleScreen
      7  5006					      SUBROUTINE
     14  5006					      SUBROUTINE
     15  5006
      0  5006					      VAR	__colour_table, 2
      1  5006		       00 a2	   __colour_table =	TEMPORARY_VAR
      2  5006				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  5006
      4  5006				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5006				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5006				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5006					      ENDIF
      8  5006				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5006				  -	      ECHO	"Temporary Variable", __colour_table, "overflow!"
     10  5006				  -	      ERR
     11  5006					      ENDIF
     12  5006					      LIST	ON
     17  5006
     18  5006							; Start of new frame
     19  5006
     20  5006							; Start of vertical blank processing
     21  5006
     22  5006				   TitleSequence
     23  5006
     24  5006		       a9 00		      lda	#%00000000
     25  5008		       85 4a		      sta	CTRLPF
     26  500a		       85 49		      sta	COLUBK
     27  500c
     28  500c		       a2 00		      ldx	#0	;Platform
     29  500e		       a9 00		      lda	#<colr_ntsc2	;colvec,x
     30  5010		       85 a2		      sta	__colour_table
     31  5012		       a9 f1		      lda	#>colr_ntsc2	;colvec+1,x
     32  5014		       85 a3		      sta	__colour_table+1
     33  5016
     34  5016							;		  sta rndHi
     35  5016							;		  sta rnd
     36  5016
     37  5016
     38  5016				  -	      IF	0
     39  5016				  -	      lda	#0
     40  5016				  -	      sta	digit
     41  5016				  -	      lda	#$10
     42  5016				  -	      sta	digit+1
     43  5016				  -	      lda	#$20
     44  5016				  -	      sta	digit+2
     45  5016					      ENDIF
     46  5016
     47  5016
     48  5016
     49  5016
     50  5016							;RESYNC
     51  5016
     52  5016				   RestartFrame0
     53  5016
     54  5016				  -	      IF	0
     55  5016				  -	      ldx	#2
     56  5016				  -rollcols   clc
     57  5016				  -	      lda	digit+2
     58  5016				  -	      adc	#$10
     59  5016				  -	      sta	digit+2
     60  5016				  -	      bcc	finxc
     61  5016				  -	      dex
     62  5016				  -	      bpl	rollcols
     63  5016				  -finxc
     64  5016					      ENDIF
     65  5016
      0  5016					      DEF	RestartFrame
      1  5016				   BANK_RestartFrame SET	_CURRENT_BANK
      2  5016				   RestartFrame
      3  5016				   TEMPORARY_VAR SET	Overlay
      4  5016				   TEMPORARY_OFFSET SET	0
      5  5016				   VAR_BOUNDARY_RestartFrame SET	TEMPORARY_OFFSET
      6  5016				   FUNCTION_NAME SET	RestartFrame
      7  5016					      SUBROUTINE
     67  5016		       a9 00		      LDA	#0
     68  5018		       a9 0e		      lda	#%1110	; VSYNC ON
     69  501a		       85 42	   .loopVSync2 sta	WSYNC
     70  501c		       85 40		      sta	VSYNC
     71  501e		       4a		      lsr
     72  501f		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     73  5021
     74  5021							;------------------------------------------------------------------
     75  5021
     76  5021		       a6 9a		      ldx	Platform
     77  5023		       bc 04 f0 	      ldy	VBlankTime,x
     78  5026		       8c 96 02 	      sty	TIM64T
     79  5029
     80  5029
     81  5029				  -	      IF	0
     82  5029				  -	      lda	SWCHB
     83  5029				  -	      rol
     84  5029				  -	      rol
     85  5029				  -	      rol
     86  5029				  -	      and	#%11
     87  5029				  -	      eor	#PAL
     88  5029				  -	      cmp	Platform
     89  5029				  -	      beq	platOK
     90  5029				  -	      sta	Platform
     91  5029				  -	      jmp	TitleSequence
     92  5029				  -platOK
     93  5029					      ENDIF
     94  5029
     95  5029		       e6 81	   k2	      inc	rnd
     96  502b		       f0 fc		      beq	k2
     97  502d
     98  502d
     99  502d		       85 42	   VerticalBlank sta	WSYNC
    100  502f		       ad 84 02 	      lda	INTIM
    101  5032		       d0 f9		      bne	VerticalBlank
    102  5034		       85 41		      sta	VBLANK
    103  5036
    104  5036							;sta COLUBK
    105  5036
    106  5036							;------------------------------------------------------------------
    107  5036
    108  5036							; Do X scanlines of color-changing (our picture)
    109  5036
    110  5036		       a0 d1		      ldy	#210-1	; this counts our scanline number
    111  5038		       a2 03	   SokoLogo   ldx	#3
    112  503a		       b1 a2	   triplet    lda	(__colour_table),y
    113  503c							;    eor digit-1,x
    114  503c		       85 42		      sta	WSYNC
    115  503e		       85 48		      sta	COLUPF	; 3
    116  5040
    117  5040		       b9 b0 f2 	      lda	COL_0,y	; 5
    118  5043		       85 4d		      sta	PF0	; 3   @11
    119  5045		       b9 88 f3 	      lda	COL_1,y	; 5
    120  5048		       85 4e		      sta	PF1	; 3   @19
    121  504a		       b9 60 f4 	      lda	COL_2,y	; 5
    122  504d		       85 4f		      sta	PF2	; 3   @27
    123  504f
    124  504f		       b9 38 f5 	      lda	COL_3,y	; 5
    125  5052		       85 4d		      sta	PF0	; 3   @35
      0  5054					      SLEEP	2	; @37
      1  5054				   .CYCLES    SET	2
      2  5054
      3  5054				  -	      IF	.CYCLES < 2
      4  5054				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  5054				  -	      ERR
      6  5054					      ENDIF
      7  5054
      8  5054				  -	      IF	.CYCLES & 1
      9  5054				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  5054				  -	      nop	0
     11  5054				  -	      ELSE
     12  5054				  -	      bit	VSYNC
     13  5054				  -	      ENDIF
     14  5054				  -.CYCLES    SET	.CYCLES - 3
     15  5054					      ENDIF
     16  5054
     17  5054					      REPEAT	.CYCLES / 2
     18  5054		       ea		      nop
     19  5055					      REPEND
    127  5055		       b9 10 f6 	      lda	COL_4,y	; 5
    128  5058		       85 4e		      sta	PF1	; 3   @45
      0  505a					      SLEEP	3	; @45
      1  505a				   .CYCLES    SET	3
      2  505a
      3  505a				  -	      IF	.CYCLES < 2
      4  505a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  505a				  -	      ERR
      6  505a					      ENDIF
      7  505a
      8  505a					      IF	.CYCLES & 1
      9  505a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  505a		       04 00		      nop	0
     11  505c				  -	      ELSE
     12  505c				  -	      bit	VSYNC
     13  505c					      ENDIF
     14  505c				   .CYCLES    SET	.CYCLES - 3
     15  505c					      ENDIF
     16  505c
     17  505c				  -	      REPEAT	.CYCLES / 2
     18  505c				  -	      nop
     19  505c					      REPEND
    130  505c		       b9 e8 f6 	      lda	COL_5,y	; 5
    131  505f		       85 4f		      sta	PF2	; 3
    132  5061
    133  5061		       88		      dey		; 2
    134  5062		       ca		      dex		; 2
    135  5063		       d0 d5		      bne	triplet	; 2(3)
    136  5065
    137  5065		       c0 ff		      cpy	#-1	; 2
    138  5067		       d0 cf		      bne	SokoLogo	; 2(3)
    139  5069
    140  5069							;lda #0
    141  5069							;sta PF0
    142  5069							;sta PF1
    143  5069							;sta PF2
    144  5069
    145  5069		       a6 9a		      ldx	Platform
    146  506b		       bd 00 f0 	      lda	OverscanTime2,x
    147  506e		       8d 96 02 	      sta	TIM64T
    148  5071
    149  5071				  -	      IF	0
    150  5071				  -	      sta	WSYNC
    151  5071				  -	      sta	WSYNC
    152  5071				  -	      sta	WSYNC
    153  5071				  -	      sta	WSYNC
    154  5071				  -	      sta	WSYNC
    155  5071				  -	      SLEEP	8
    156  5071				  -	      jsr	SokoScreen
    157  5071				  -
    158  5071				  -	      lda	#0
    159  5071				  -	      sta	BoardScrollX
    160  5071				  -	      sta	BoardScrollY
    161  5071					      ENDIF
    162  5071
    163  5071							;		ldy #63
    164  5071							;bot2		 sta WSYNC
    165  5071							;		dey
    166  5071							;		bpl bot2
    167  5071
    168  5071							;--------------------------------------------------------------------------
    169  5071
    170  5071		       a9 00		      lda	#0
    171  5073		       85 4d		      sta	PF0
    172  5075		       85 4e		      sta	PF1
    173  5077		       85 4f		      sta	PF2
    174  5079
    175  5079
      0  5079					      NEXT_RANDOM
      1  5079		       a5 81		      lda	rnd
      2  507b		       4a		      lsr
      3  507c		       90 02		      bcc	.skipEOR
      4  507e		       49 fe		      eor	#RND_EOR_VAL
      5  5080		       85 81	   .skipEOR   sta	rnd
    177  5082
    178  5082							; D1 VBLANK turns off beam
    179  5082							; It needs to be turned on 37 scanlines later
    180  5082
    181  5082				   oscan
    182  5082		       ad 84 02 	      lda	INTIM
    183  5085		       d0 fb		      bne	oscan
    184  5087
    185  5087		       a9 42		      lda	#%01000010	; bit6 is not required
    186  5089		       85 41		      sta	VBLANK	; end of screen - enter blanking
    187  508b
    188  508b				  -	      IF	0
    189  508b				  -	      inc	rnd
    190  508b				  -	      bne	rdd
    191  508b				  -	      inc	rndHi
    192  508b				  -rdd
    193  508b				  -
    194  508b				  -	      dec	digitick
    195  508b				  -	      bpl	ret2
    196  508b				  -	      lda	#40
    197  508b				  -	      sta	digitick
    198  508b				  -
    199  508b				  -	      jsr	Random
    200  508b				  -	      and	#3
    201  508b				  -	      beq	ret2
    202  508b				  -	      tax
    203  508b				  -	      jsr	Random
    204  508b				  -	      and	#$F0
    205  508b				  -	      sta	digit-1,x
    206  508b				  -	      jmp	RestartFrame0
    207  508b				  -
    208  508b				  -ret2
    209  508b					      ENDIF
    210  508b
    211  508b
    212  508b		       a5 4c		      lda	INPT4
    213  508d		       10 03		      bpl	ret
    214  508f
    215  508f		       4c 16 f0 	      jmp	RestartFrame
    216  5092
    217  5092				   ret
    218  5092		       60		      rts
    219  5093
    220  5093
    221  5093
    222  5093					      MAC	lumtable
    223  5093							; {4} MIN LUM 1
    224  5093							; {5} MIN LUM 2
    225  5093							; {6} MIN LUM 3
    226  5093
    227  5093				   .LUM1      SET	{4}*256
    228  5093				   .LUM2      SET	{5}*256
    229  5093				   .LUM3      SET	{6}*256
    230  5093
    231  5093				   .STEP1     =	(256*({7}-{4}))/72
    232  5093				   .STEP2     =	(256*({8}-{5}))/72
    233  5093				   .STEP3     =	(256*({9}-{6}))/72
    234  5093
    235  5093					      REPEAT	72
    236  5093					      .byte	{1}+(.LUM1/256)
    237  5093					      .byte	{2}+(.LUM2/256)
    238  5093					      .byte	{3}+(.LUM3/256)
    239  5093
    240  5093							;    ECHO {1}+(.LUM1/256)
    241  5093							;    ECHO {2}+(.LUM1/256)
    242  5093							;    ECHO {3}+(.LUM1/256)
    243  5093
    244  5093				   .LUM1      SET	.LUM1 + .STEP1
    245  5093				   .LUM2      SET	.LUM2 + .STEP2
    246  5093				   .LUM3      SET	.LUM3 + .STEP3
    247  5093					      REPEND
    248  5093					      ENDM		;{1}{2}{3} base colours
    249  5093
    250  5093							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
    251  5093							;    OPTIONAL_PAGEBREAK "colr_ntsc", 72*3
    252  5093
    253  5100		       00 00 00 00*	      align	256
    254  5100							;    ECHO "NTSC LUMS"
    255  5100				   colr_ntsc2
      0  5100					      LUMTABLE	$40,$20,$90,$4,$6,$8,$4,$6,$8
      1  5100
      2  5100
      3  5100
      4  5100
      5  5100				   .LUM1      SET	$4*256
      6  5100				   .LUM2      SET	$6*256
      7  5100				   .LUM3      SET	$8*256
      8  5100
      9  5100		       00 00	   .STEP1     =	(256*($4-$4))/72
     10  5100		       00 00	   .STEP2     =	(256*($6-$6))/72
     11  5100		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  5100
     13  5100					      REPEAT	72
     14  5100		       44		      .byte.b	$40+(.LUM1/256)
     15  5101		       26		      .byte.b	$20+(.LUM2/256)
     16  5102		       98		      .byte.b	$90+(.LUM3/256)
     17  5103
     18  5103
     19  5103
     20  5103
     21  5103
     22  5103				   .LUM1      SET	.LUM1 + .STEP1
     23  5103				   .LUM2      SET	.LUM2 + .STEP2
     24  5103				   .LUM3      SET	.LUM3 + .STEP3
     13  5103					      REPEND
     14  5103		       44		      .byte.b	$40+(.LUM1/256)
     15  5104		       26		      .byte.b	$20+(.LUM2/256)
     16  5105		       98		      .byte.b	$90+(.LUM3/256)
     17  5106
     18  5106
     19  5106
     20  5106
     21  5106
     22  5106				   .LUM1      SET	.LUM1 + .STEP1
     23  5106				   .LUM2      SET	.LUM2 + .STEP2
     24  5106				   .LUM3      SET	.LUM3 + .STEP3
     13  5106					      REPEND
     14  5106		       44		      .byte.b	$40+(.LUM1/256)
     15  5107		       26		      .byte.b	$20+(.LUM2/256)
     16  5108		       98		      .byte.b	$90+(.LUM3/256)
     17  5109
     18  5109
     19  5109
     20  5109
     21  5109
     22  5109				   .LUM1      SET	.LUM1 + .STEP1
     23  5109				   .LUM2      SET	.LUM2 + .STEP2
     24  5109				   .LUM3      SET	.LUM3 + .STEP3
     13  5109					      REPEND
     14  5109		       44		      .byte.b	$40+(.LUM1/256)
     15  510a		       26		      .byte.b	$20+(.LUM2/256)
     16  510b		       98		      .byte.b	$90+(.LUM3/256)
     17  510c
     18  510c
     19  510c
     20  510c
     21  510c
     22  510c				   .LUM1      SET	.LUM1 + .STEP1
     23  510c				   .LUM2      SET	.LUM2 + .STEP2
     24  510c				   .LUM3      SET	.LUM3 + .STEP3
     13  510c					      REPEND
     14  510c		       44		      .byte.b	$40+(.LUM1/256)
     15  510d		       26		      .byte.b	$20+(.LUM2/256)
     16  510e		       98		      .byte.b	$90+(.LUM3/256)
     17  510f
     18  510f
     19  510f
     20  510f
     21  510f
     22  510f				   .LUM1      SET	.LUM1 + .STEP1
     23  510f				   .LUM2      SET	.LUM2 + .STEP2
     24  510f				   .LUM3      SET	.LUM3 + .STEP3
     13  510f					      REPEND
     14  510f		       44		      .byte.b	$40+(.LUM1/256)
     15  5110		       26		      .byte.b	$20+(.LUM2/256)
     16  5111		       98		      .byte.b	$90+(.LUM3/256)
     17  5112
     18  5112
     19  5112
     20  5112
     21  5112
     22  5112				   .LUM1      SET	.LUM1 + .STEP1
     23  5112				   .LUM2      SET	.LUM2 + .STEP2
     24  5112				   .LUM3      SET	.LUM3 + .STEP3
     13  5112					      REPEND
     14  5112		       44		      .byte.b	$40+(.LUM1/256)
     15  5113		       26		      .byte.b	$20+(.LUM2/256)
     16  5114		       98		      .byte.b	$90+(.LUM3/256)
     17  5115
     18  5115
     19  5115
     20  5115
     21  5115
     22  5115				   .LUM1      SET	.LUM1 + .STEP1
     23  5115				   .LUM2      SET	.LUM2 + .STEP2
     24  5115				   .LUM3      SET	.LUM3 + .STEP3
     13  5115					      REPEND
     14  5115		       44		      .byte.b	$40+(.LUM1/256)
     15  5116		       26		      .byte.b	$20+(.LUM2/256)
     16  5117		       98		      .byte.b	$90+(.LUM3/256)
     17  5118
     18  5118
     19  5118
     20  5118
     21  5118
     22  5118				   .LUM1      SET	.LUM1 + .STEP1
     23  5118				   .LUM2      SET	.LUM2 + .STEP2
     24  5118				   .LUM3      SET	.LUM3 + .STEP3
     13  5118					      REPEND
     14  5118		       44		      .byte.b	$40+(.LUM1/256)
     15  5119		       26		      .byte.b	$20+(.LUM2/256)
     16  511a		       98		      .byte.b	$90+(.LUM3/256)
     17  511b
     18  511b
     19  511b
     20  511b
     21  511b
     22  511b				   .LUM1      SET	.LUM1 + .STEP1
     23  511b				   .LUM2      SET	.LUM2 + .STEP2
     24  511b				   .LUM3      SET	.LUM3 + .STEP3
     13  511b					      REPEND
     14  511b		       44		      .byte.b	$40+(.LUM1/256)
     15  511c		       26		      .byte.b	$20+(.LUM2/256)
     16  511d		       98		      .byte.b	$90+(.LUM3/256)
     17  511e
     18  511e
     19  511e
     20  511e
     21  511e
     22  511e				   .LUM1      SET	.LUM1 + .STEP1
     23  511e				   .LUM2      SET	.LUM2 + .STEP2
     24  511e				   .LUM3      SET	.LUM3 + .STEP3
     13  511e					      REPEND
     14  511e		       44		      .byte.b	$40+(.LUM1/256)
     15  511f		       26		      .byte.b	$20+(.LUM2/256)
     16  5120		       98		      .byte.b	$90+(.LUM3/256)
     17  5121
     18  5121
     19  5121
     20  5121
     21  5121
     22  5121				   .LUM1      SET	.LUM1 + .STEP1
     23  5121				   .LUM2      SET	.LUM2 + .STEP2
     24  5121				   .LUM3      SET	.LUM3 + .STEP3
     13  5121					      REPEND
     14  5121		       44		      .byte.b	$40+(.LUM1/256)
     15  5122		       26		      .byte.b	$20+(.LUM2/256)
     16  5123		       98		      .byte.b	$90+(.LUM3/256)
     17  5124
     18  5124
     19  5124
     20  5124
     21  5124
     22  5124				   .LUM1      SET	.LUM1 + .STEP1
     23  5124				   .LUM2      SET	.LUM2 + .STEP2
     24  5124				   .LUM3      SET	.LUM3 + .STEP3
     13  5124					      REPEND
     14  5124		       44		      .byte.b	$40+(.LUM1/256)
     15  5125		       26		      .byte.b	$20+(.LUM2/256)
     16  5126		       98		      .byte.b	$90+(.LUM3/256)
     17  5127
     18  5127
     19  5127
     20  5127
     21  5127
     22  5127				   .LUM1      SET	.LUM1 + .STEP1
     23  5127				   .LUM2      SET	.LUM2 + .STEP2
     24  5127				   .LUM3      SET	.LUM3 + .STEP3
     13  5127					      REPEND
     14  5127		       44		      .byte.b	$40+(.LUM1/256)
     15  5128		       26		      .byte.b	$20+(.LUM2/256)
     16  5129		       98		      .byte.b	$90+(.LUM3/256)
     17  512a
     18  512a
     19  512a
     20  512a
     21  512a
     22  512a				   .LUM1      SET	.LUM1 + .STEP1
     23  512a				   .LUM2      SET	.LUM2 + .STEP2
     24  512a				   .LUM3      SET	.LUM3 + .STEP3
     13  512a					      REPEND
     14  512a		       44		      .byte.b	$40+(.LUM1/256)
     15  512b		       26		      .byte.b	$20+(.LUM2/256)
     16  512c		       98		      .byte.b	$90+(.LUM3/256)
     17  512d
     18  512d
     19  512d
     20  512d
     21  512d
     22  512d				   .LUM1      SET	.LUM1 + .STEP1
     23  512d				   .LUM2      SET	.LUM2 + .STEP2
     24  512d				   .LUM3      SET	.LUM3 + .STEP3
     13  512d					      REPEND
     14  512d		       44		      .byte.b	$40+(.LUM1/256)
     15  512e		       26		      .byte.b	$20+(.LUM2/256)
     16  512f		       98		      .byte.b	$90+(.LUM3/256)
     17  5130
     18  5130
     19  5130
     20  5130
     21  5130
     22  5130				   .LUM1      SET	.LUM1 + .STEP1
     23  5130				   .LUM2      SET	.LUM2 + .STEP2
     24  5130				   .LUM3      SET	.LUM3 + .STEP3
     13  5130					      REPEND
     14  5130		       44		      .byte.b	$40+(.LUM1/256)
     15  5131		       26		      .byte.b	$20+(.LUM2/256)
     16  5132		       98		      .byte.b	$90+(.LUM3/256)
     17  5133
     18  5133
     19  5133
     20  5133
     21  5133
     22  5133				   .LUM1      SET	.LUM1 + .STEP1
     23  5133				   .LUM2      SET	.LUM2 + .STEP2
     24  5133				   .LUM3      SET	.LUM3 + .STEP3
     13  5133					      REPEND
     14  5133		       44		      .byte.b	$40+(.LUM1/256)
     15  5134		       26		      .byte.b	$20+(.LUM2/256)
     16  5135		       98		      .byte.b	$90+(.LUM3/256)
     17  5136
     18  5136
     19  5136
     20  5136
     21  5136
     22  5136				   .LUM1      SET	.LUM1 + .STEP1
     23  5136				   .LUM2      SET	.LUM2 + .STEP2
     24  5136				   .LUM3      SET	.LUM3 + .STEP3
     13  5136					      REPEND
     14  5136		       44		      .byte.b	$40+(.LUM1/256)
     15  5137		       26		      .byte.b	$20+(.LUM2/256)
     16  5138		       98		      .byte.b	$90+(.LUM3/256)
     17  5139
     18  5139
     19  5139
     20  5139
     21  5139
     22  5139				   .LUM1      SET	.LUM1 + .STEP1
     23  5139				   .LUM2      SET	.LUM2 + .STEP2
     24  5139				   .LUM3      SET	.LUM3 + .STEP3
     13  5139					      REPEND
     14  5139		       44		      .byte.b	$40+(.LUM1/256)
     15  513a		       26		      .byte.b	$20+(.LUM2/256)
     16  513b		       98		      .byte.b	$90+(.LUM3/256)
     17  513c
     18  513c
     19  513c
     20  513c
     21  513c
     22  513c				   .LUM1      SET	.LUM1 + .STEP1
     23  513c				   .LUM2      SET	.LUM2 + .STEP2
     24  513c				   .LUM3      SET	.LUM3 + .STEP3
     13  513c					      REPEND
     14  513c		       44		      .byte.b	$40+(.LUM1/256)
     15  513d		       26		      .byte.b	$20+(.LUM2/256)
     16  513e		       98		      .byte.b	$90+(.LUM3/256)
     17  513f
     18  513f
     19  513f
     20  513f
     21  513f
     22  513f				   .LUM1      SET	.LUM1 + .STEP1
     23  513f				   .LUM2      SET	.LUM2 + .STEP2
     24  513f				   .LUM3      SET	.LUM3 + .STEP3
     13  513f					      REPEND
     14  513f		       44		      .byte.b	$40+(.LUM1/256)
     15  5140		       26		      .byte.b	$20+(.LUM2/256)
     16  5141		       98		      .byte.b	$90+(.LUM3/256)
     17  5142
     18  5142
     19  5142
     20  5142
     21  5142
     22  5142				   .LUM1      SET	.LUM1 + .STEP1
     23  5142				   .LUM2      SET	.LUM2 + .STEP2
     24  5142				   .LUM3      SET	.LUM3 + .STEP3
     13  5142					      REPEND
     14  5142		       44		      .byte.b	$40+(.LUM1/256)
     15  5143		       26		      .byte.b	$20+(.LUM2/256)
     16  5144		       98		      .byte.b	$90+(.LUM3/256)
     17  5145
     18  5145
     19  5145
     20  5145
     21  5145
     22  5145				   .LUM1      SET	.LUM1 + .STEP1
     23  5145				   .LUM2      SET	.LUM2 + .STEP2
     24  5145				   .LUM3      SET	.LUM3 + .STEP3
     13  5145					      REPEND
     14  5145		       44		      .byte.b	$40+(.LUM1/256)
     15  5146		       26		      .byte.b	$20+(.LUM2/256)
     16  5147		       98		      .byte.b	$90+(.LUM3/256)
     17  5148
     18  5148
     19  5148
     20  5148
     21  5148
     22  5148				   .LUM1      SET	.LUM1 + .STEP1
     23  5148				   .LUM2      SET	.LUM2 + .STEP2
     24  5148				   .LUM3      SET	.LUM3 + .STEP3
     13  5148					      REPEND
     14  5148		       44		      .byte.b	$40+(.LUM1/256)
     15  5149		       26		      .byte.b	$20+(.LUM2/256)
     16  514a		       98		      .byte.b	$90+(.LUM3/256)
     17  514b
     18  514b
     19  514b
     20  514b
     21  514b
     22  514b				   .LUM1      SET	.LUM1 + .STEP1
     23  514b				   .LUM2      SET	.LUM2 + .STEP2
     24  514b				   .LUM3      SET	.LUM3 + .STEP3
     13  514b					      REPEND
     14  514b		       44		      .byte.b	$40+(.LUM1/256)
     15  514c		       26		      .byte.b	$20+(.LUM2/256)
     16  514d		       98		      .byte.b	$90+(.LUM3/256)
     17  514e
     18  514e
     19  514e
     20  514e
     21  514e
     22  514e				   .LUM1      SET	.LUM1 + .STEP1
     23  514e				   .LUM2      SET	.LUM2 + .STEP2
     24  514e				   .LUM3      SET	.LUM3 + .STEP3
     13  514e					      REPEND
     14  514e		       44		      .byte.b	$40+(.LUM1/256)
     15  514f		       26		      .byte.b	$20+(.LUM2/256)
     16  5150		       98		      .byte.b	$90+(.LUM3/256)
     17  5151
     18  5151
     19  5151
     20  5151
     21  5151
     22  5151				   .LUM1      SET	.LUM1 + .STEP1
     23  5151				   .LUM2      SET	.LUM2 + .STEP2
     24  5151				   .LUM3      SET	.LUM3 + .STEP3
     13  5151					      REPEND
     14  5151		       44		      .byte.b	$40+(.LUM1/256)
     15  5152		       26		      .byte.b	$20+(.LUM2/256)
     16  5153		       98		      .byte.b	$90+(.LUM3/256)
     17  5154
     18  5154
     19  5154
     20  5154
     21  5154
     22  5154				   .LUM1      SET	.LUM1 + .STEP1
     23  5154				   .LUM2      SET	.LUM2 + .STEP2
     24  5154				   .LUM3      SET	.LUM3 + .STEP3
     13  5154					      REPEND
     14  5154		       44		      .byte.b	$40+(.LUM1/256)
     15  5155		       26		      .byte.b	$20+(.LUM2/256)
     16  5156		       98		      .byte.b	$90+(.LUM3/256)
     17  5157
     18  5157
     19  5157
     20  5157
     21  5157
     22  5157				   .LUM1      SET	.LUM1 + .STEP1
     23  5157				   .LUM2      SET	.LUM2 + .STEP2
     24  5157				   .LUM3      SET	.LUM3 + .STEP3
     13  5157					      REPEND
     14  5157		       44		      .byte.b	$40+(.LUM1/256)
     15  5158		       26		      .byte.b	$20+(.LUM2/256)
     16  5159		       98		      .byte.b	$90+(.LUM3/256)
     17  515a
     18  515a
     19  515a
     20  515a
     21  515a
     22  515a				   .LUM1      SET	.LUM1 + .STEP1
     23  515a				   .LUM2      SET	.LUM2 + .STEP2
     24  515a				   .LUM3      SET	.LUM3 + .STEP3
     13  515a					      REPEND
     14  515a		       44		      .byte.b	$40+(.LUM1/256)
     15  515b		       26		      .byte.b	$20+(.LUM2/256)
     16  515c		       98		      .byte.b	$90+(.LUM3/256)
     17  515d
     18  515d
     19  515d
     20  515d
     21  515d
     22  515d				   .LUM1      SET	.LUM1 + .STEP1
     23  515d				   .LUM2      SET	.LUM2 + .STEP2
     24  515d				   .LUM3      SET	.LUM3 + .STEP3
     13  515d					      REPEND
     14  515d		       44		      .byte.b	$40+(.LUM1/256)
     15  515e		       26		      .byte.b	$20+(.LUM2/256)
     16  515f		       98		      .byte.b	$90+(.LUM3/256)
     17  5160
     18  5160
     19  5160
     20  5160
     21  5160
     22  5160				   .LUM1      SET	.LUM1 + .STEP1
     23  5160				   .LUM2      SET	.LUM2 + .STEP2
     24  5160				   .LUM3      SET	.LUM3 + .STEP3
     13  5160					      REPEND
     14  5160		       44		      .byte.b	$40+(.LUM1/256)
     15  5161		       26		      .byte.b	$20+(.LUM2/256)
     16  5162		       98		      .byte.b	$90+(.LUM3/256)
     17  5163
     18  5163
     19  5163
     20  5163
     21  5163
     22  5163				   .LUM1      SET	.LUM1 + .STEP1
     23  5163				   .LUM2      SET	.LUM2 + .STEP2
     24  5163				   .LUM3      SET	.LUM3 + .STEP3
     13  5163					      REPEND
     14  5163		       44		      .byte.b	$40+(.LUM1/256)
     15  5164		       26		      .byte.b	$20+(.LUM2/256)
     16  5165		       98		      .byte.b	$90+(.LUM3/256)
     17  5166
     18  5166
     19  5166
     20  5166
     21  5166
     22  5166				   .LUM1      SET	.LUM1 + .STEP1
     23  5166				   .LUM2      SET	.LUM2 + .STEP2
     24  5166				   .LUM3      SET	.LUM3 + .STEP3
     13  5166					      REPEND
     14  5166		       44		      .byte.b	$40+(.LUM1/256)
     15  5167		       26		      .byte.b	$20+(.LUM2/256)
     16  5168		       98		      .byte.b	$90+(.LUM3/256)
     17  5169
     18  5169
     19  5169
     20  5169
     21  5169
     22  5169				   .LUM1      SET	.LUM1 + .STEP1
     23  5169				   .LUM2      SET	.LUM2 + .STEP2
     24  5169				   .LUM3      SET	.LUM3 + .STEP3
     13  5169					      REPEND
     14  5169		       44		      .byte.b	$40+(.LUM1/256)
     15  516a		       26		      .byte.b	$20+(.LUM2/256)
     16  516b		       98		      .byte.b	$90+(.LUM3/256)
     17  516c
     18  516c
     19  516c
     20  516c
     21  516c
     22  516c				   .LUM1      SET	.LUM1 + .STEP1
     23  516c				   .LUM2      SET	.LUM2 + .STEP2
     24  516c				   .LUM3      SET	.LUM3 + .STEP3
     13  516c					      REPEND
     14  516c		       44		      .byte.b	$40+(.LUM1/256)
     15  516d		       26		      .byte.b	$20+(.LUM2/256)
     16  516e		       98		      .byte.b	$90+(.LUM3/256)
     17  516f
     18  516f
     19  516f
     20  516f
     21  516f
     22  516f				   .LUM1      SET	.LUM1 + .STEP1
     23  516f				   .LUM2      SET	.LUM2 + .STEP2
     24  516f				   .LUM3      SET	.LUM3 + .STEP3
     13  516f					      REPEND
     14  516f		       44		      .byte.b	$40+(.LUM1/256)
     15  5170		       26		      .byte.b	$20+(.LUM2/256)
     16  5171		       98		      .byte.b	$90+(.LUM3/256)
     17  5172
     18  5172
     19  5172
     20  5172
     21  5172
     22  5172				   .LUM1      SET	.LUM1 + .STEP1
     23  5172				   .LUM2      SET	.LUM2 + .STEP2
     24  5172				   .LUM3      SET	.LUM3 + .STEP3
     13  5172					      REPEND
     14  5172		       44		      .byte.b	$40+(.LUM1/256)
     15  5173		       26		      .byte.b	$20+(.LUM2/256)
     16  5174		       98		      .byte.b	$90+(.LUM3/256)
     17  5175
     18  5175
     19  5175
     20  5175
     21  5175
     22  5175				   .LUM1      SET	.LUM1 + .STEP1
     23  5175				   .LUM2      SET	.LUM2 + .STEP2
     24  5175				   .LUM3      SET	.LUM3 + .STEP3
     13  5175					      REPEND
     14  5175		       44		      .byte.b	$40+(.LUM1/256)
     15  5176		       26		      .byte.b	$20+(.LUM2/256)
     16  5177		       98		      .byte.b	$90+(.LUM3/256)
     17  5178
     18  5178
     19  5178
     20  5178
     21  5178
     22  5178				   .LUM1      SET	.LUM1 + .STEP1
     23  5178				   .LUM2      SET	.LUM2 + .STEP2
     24  5178				   .LUM3      SET	.LUM3 + .STEP3
     13  5178					      REPEND
     14  5178		       44		      .byte.b	$40+(.LUM1/256)
     15  5179		       26		      .byte.b	$20+(.LUM2/256)
     16  517a		       98		      .byte.b	$90+(.LUM3/256)
     17  517b
     18  517b
     19  517b
     20  517b
     21  517b
     22  517b				   .LUM1      SET	.LUM1 + .STEP1
     23  517b				   .LUM2      SET	.LUM2 + .STEP2
     24  517b				   .LUM3      SET	.LUM3 + .STEP3
     13  517b					      REPEND
     14  517b		       44		      .byte.b	$40+(.LUM1/256)
     15  517c		       26		      .byte.b	$20+(.LUM2/256)
     16  517d		       98		      .byte.b	$90+(.LUM3/256)
     17  517e
     18  517e
     19  517e
     20  517e
     21  517e
     22  517e				   .LUM1      SET	.LUM1 + .STEP1
     23  517e				   .LUM2      SET	.LUM2 + .STEP2
     24  517e				   .LUM3      SET	.LUM3 + .STEP3
     13  517e					      REPEND
     14  517e		       44		      .byte.b	$40+(.LUM1/256)
     15  517f		       26		      .byte.b	$20+(.LUM2/256)
     16  5180		       98		      .byte.b	$90+(.LUM3/256)
     17  5181
     18  5181
     19  5181
     20  5181
     21  5181
     22  5181				   .LUM1      SET	.LUM1 + .STEP1
     23  5181				   .LUM2      SET	.LUM2 + .STEP2
     24  5181				   .LUM3      SET	.LUM3 + .STEP3
     13  5181					      REPEND
     14  5181		       44		      .byte.b	$40+(.LUM1/256)
     15  5182		       26		      .byte.b	$20+(.LUM2/256)
     16  5183		       98		      .byte.b	$90+(.LUM3/256)
     17  5184
     18  5184
     19  5184
     20  5184
     21  5184
     22  5184				   .LUM1      SET	.LUM1 + .STEP1
     23  5184				   .LUM2      SET	.LUM2 + .STEP2
     24  5184				   .LUM3      SET	.LUM3 + .STEP3
     13  5184					      REPEND
     14  5184		       44		      .byte.b	$40+(.LUM1/256)
     15  5185		       26		      .byte.b	$20+(.LUM2/256)
     16  5186		       98		      .byte.b	$90+(.LUM3/256)
     17  5187
     18  5187
     19  5187
     20  5187
     21  5187
     22  5187				   .LUM1      SET	.LUM1 + .STEP1
     23  5187				   .LUM2      SET	.LUM2 + .STEP2
     24  5187				   .LUM3      SET	.LUM3 + .STEP3
     13  5187					      REPEND
     14  5187		       44		      .byte.b	$40+(.LUM1/256)
     15  5188		       26		      .byte.b	$20+(.LUM2/256)
     16  5189		       98		      .byte.b	$90+(.LUM3/256)
     17  518a
     18  518a
     19  518a
     20  518a
     21  518a
     22  518a				   .LUM1      SET	.LUM1 + .STEP1
     23  518a				   .LUM2      SET	.LUM2 + .STEP2
     24  518a				   .LUM3      SET	.LUM3 + .STEP3
     13  518a					      REPEND
     14  518a		       44		      .byte.b	$40+(.LUM1/256)
     15  518b		       26		      .byte.b	$20+(.LUM2/256)
     16  518c		       98		      .byte.b	$90+(.LUM3/256)
     17  518d
     18  518d
     19  518d
     20  518d
     21  518d
     22  518d				   .LUM1      SET	.LUM1 + .STEP1
     23  518d				   .LUM2      SET	.LUM2 + .STEP2
     24  518d				   .LUM3      SET	.LUM3 + .STEP3
     13  518d					      REPEND
     14  518d		       44		      .byte.b	$40+(.LUM1/256)
     15  518e		       26		      .byte.b	$20+(.LUM2/256)
     16  518f		       98		      .byte.b	$90+(.LUM3/256)
     17  5190
     18  5190
     19  5190
     20  5190
     21  5190
     22  5190				   .LUM1      SET	.LUM1 + .STEP1
     23  5190				   .LUM2      SET	.LUM2 + .STEP2
     24  5190				   .LUM3      SET	.LUM3 + .STEP3
     13  5190					      REPEND
     14  5190		       44		      .byte.b	$40+(.LUM1/256)
     15  5191		       26		      .byte.b	$20+(.LUM2/256)
     16  5192		       98		      .byte.b	$90+(.LUM3/256)
     17  5193
     18  5193
     19  5193
     20  5193
     21  5193
     22  5193				   .LUM1      SET	.LUM1 + .STEP1
     23  5193				   .LUM2      SET	.LUM2 + .STEP2
     24  5193				   .LUM3      SET	.LUM3 + .STEP3
     13  5193					      REPEND
     14  5193		       44		      .byte.b	$40+(.LUM1/256)
     15  5194		       26		      .byte.b	$20+(.LUM2/256)
     16  5195		       98		      .byte.b	$90+(.LUM3/256)
     17  5196
     18  5196
     19  5196
     20  5196
     21  5196
     22  5196				   .LUM1      SET	.LUM1 + .STEP1
     23  5196				   .LUM2      SET	.LUM2 + .STEP2
     24  5196				   .LUM3      SET	.LUM3 + .STEP3
     13  5196					      REPEND
     14  5196		       44		      .byte.b	$40+(.LUM1/256)
     15  5197		       26		      .byte.b	$20+(.LUM2/256)
     16  5198		       98		      .byte.b	$90+(.LUM3/256)
     17  5199
     18  5199
     19  5199
     20  5199
     21  5199
     22  5199				   .LUM1      SET	.LUM1 + .STEP1
     23  5199				   .LUM2      SET	.LUM2 + .STEP2
     24  5199				   .LUM3      SET	.LUM3 + .STEP3
     13  5199					      REPEND
     14  5199		       44		      .byte.b	$40+(.LUM1/256)
     15  519a		       26		      .byte.b	$20+(.LUM2/256)
     16  519b		       98		      .byte.b	$90+(.LUM3/256)
     17  519c
     18  519c
     19  519c
     20  519c
     21  519c
     22  519c				   .LUM1      SET	.LUM1 + .STEP1
     23  519c				   .LUM2      SET	.LUM2 + .STEP2
     24  519c				   .LUM3      SET	.LUM3 + .STEP3
     13  519c					      REPEND
     14  519c		       44		      .byte.b	$40+(.LUM1/256)
     15  519d		       26		      .byte.b	$20+(.LUM2/256)
     16  519e		       98		      .byte.b	$90+(.LUM3/256)
     17  519f
     18  519f
     19  519f
     20  519f
     21  519f
     22  519f				   .LUM1      SET	.LUM1 + .STEP1
     23  519f				   .LUM2      SET	.LUM2 + .STEP2
     24  519f				   .LUM3      SET	.LUM3 + .STEP3
     13  519f					      REPEND
     14  519f		       44		      .byte.b	$40+(.LUM1/256)
     15  51a0		       26		      .byte.b	$20+(.LUM2/256)
     16  51a1		       98		      .byte.b	$90+(.LUM3/256)
     17  51a2
     18  51a2
     19  51a2
     20  51a2
     21  51a2
     22  51a2				   .LUM1      SET	.LUM1 + .STEP1
     23  51a2				   .LUM2      SET	.LUM2 + .STEP2
     24  51a2				   .LUM3      SET	.LUM3 + .STEP3
     13  51a2					      REPEND
     14  51a2		       44		      .byte.b	$40+(.LUM1/256)
     15  51a3		       26		      .byte.b	$20+(.LUM2/256)
     16  51a4		       98		      .byte.b	$90+(.LUM3/256)
     17  51a5
     18  51a5
     19  51a5
     20  51a5
     21  51a5
     22  51a5				   .LUM1      SET	.LUM1 + .STEP1
     23  51a5				   .LUM2      SET	.LUM2 + .STEP2
     24  51a5				   .LUM3      SET	.LUM3 + .STEP3
     13  51a5					      REPEND
     14  51a5		       44		      .byte.b	$40+(.LUM1/256)
     15  51a6		       26		      .byte.b	$20+(.LUM2/256)
     16  51a7		       98		      .byte.b	$90+(.LUM3/256)
     17  51a8
     18  51a8
     19  51a8
     20  51a8
     21  51a8
     22  51a8				   .LUM1      SET	.LUM1 + .STEP1
     23  51a8				   .LUM2      SET	.LUM2 + .STEP2
     24  51a8				   .LUM3      SET	.LUM3 + .STEP3
     13  51a8					      REPEND
     14  51a8		       44		      .byte.b	$40+(.LUM1/256)
     15  51a9		       26		      .byte.b	$20+(.LUM2/256)
     16  51aa		       98		      .byte.b	$90+(.LUM3/256)
     17  51ab
     18  51ab
     19  51ab
     20  51ab
     21  51ab
     22  51ab				   .LUM1      SET	.LUM1 + .STEP1
     23  51ab				   .LUM2      SET	.LUM2 + .STEP2
     24  51ab				   .LUM3      SET	.LUM3 + .STEP3
     13  51ab					      REPEND
     14  51ab		       44		      .byte.b	$40+(.LUM1/256)
     15  51ac		       26		      .byte.b	$20+(.LUM2/256)
     16  51ad		       98		      .byte.b	$90+(.LUM3/256)
     17  51ae
     18  51ae
     19  51ae
     20  51ae
     21  51ae
     22  51ae				   .LUM1      SET	.LUM1 + .STEP1
     23  51ae				   .LUM2      SET	.LUM2 + .STEP2
     24  51ae				   .LUM3      SET	.LUM3 + .STEP3
     13  51ae					      REPEND
     14  51ae		       44		      .byte.b	$40+(.LUM1/256)
     15  51af		       26		      .byte.b	$20+(.LUM2/256)
     16  51b0		       98		      .byte.b	$90+(.LUM3/256)
     17  51b1
     18  51b1
     19  51b1
     20  51b1
     21  51b1
     22  51b1				   .LUM1      SET	.LUM1 + .STEP1
     23  51b1				   .LUM2      SET	.LUM2 + .STEP2
     24  51b1				   .LUM3      SET	.LUM3 + .STEP3
     13  51b1					      REPEND
     14  51b1		       44		      .byte.b	$40+(.LUM1/256)
     15  51b2		       26		      .byte.b	$20+(.LUM2/256)
     16  51b3		       98		      .byte.b	$90+(.LUM3/256)
     17  51b4
     18  51b4
     19  51b4
     20  51b4
     21  51b4
     22  51b4				   .LUM1      SET	.LUM1 + .STEP1
     23  51b4				   .LUM2      SET	.LUM2 + .STEP2
     24  51b4				   .LUM3      SET	.LUM3 + .STEP3
     13  51b4					      REPEND
     14  51b4		       44		      .byte.b	$40+(.LUM1/256)
     15  51b5		       26		      .byte.b	$20+(.LUM2/256)
     16  51b6		       98		      .byte.b	$90+(.LUM3/256)
     17  51b7
     18  51b7
     19  51b7
     20  51b7
     21  51b7
     22  51b7				   .LUM1      SET	.LUM1 + .STEP1
     23  51b7				   .LUM2      SET	.LUM2 + .STEP2
     24  51b7				   .LUM3      SET	.LUM3 + .STEP3
     13  51b7					      REPEND
     14  51b7		       44		      .byte.b	$40+(.LUM1/256)
     15  51b8		       26		      .byte.b	$20+(.LUM2/256)
     16  51b9		       98		      .byte.b	$90+(.LUM3/256)
     17  51ba
     18  51ba
     19  51ba
     20  51ba
     21  51ba
     22  51ba				   .LUM1      SET	.LUM1 + .STEP1
     23  51ba				   .LUM2      SET	.LUM2 + .STEP2
     24  51ba				   .LUM3      SET	.LUM3 + .STEP3
     13  51ba					      REPEND
     14  51ba		       44		      .byte.b	$40+(.LUM1/256)
     15  51bb		       26		      .byte.b	$20+(.LUM2/256)
     16  51bc		       98		      .byte.b	$90+(.LUM3/256)
     17  51bd
     18  51bd
     19  51bd
     20  51bd
     21  51bd
     22  51bd				   .LUM1      SET	.LUM1 + .STEP1
     23  51bd				   .LUM2      SET	.LUM2 + .STEP2
     24  51bd				   .LUM3      SET	.LUM3 + .STEP3
     13  51bd					      REPEND
     14  51bd		       44		      .byte.b	$40+(.LUM1/256)
     15  51be		       26		      .byte.b	$20+(.LUM2/256)
     16  51bf		       98		      .byte.b	$90+(.LUM3/256)
     17  51c0
     18  51c0
     19  51c0
     20  51c0
     21  51c0
     22  51c0				   .LUM1      SET	.LUM1 + .STEP1
     23  51c0				   .LUM2      SET	.LUM2 + .STEP2
     24  51c0				   .LUM3      SET	.LUM3 + .STEP3
     13  51c0					      REPEND
     14  51c0		       44		      .byte.b	$40+(.LUM1/256)
     15  51c1		       26		      .byte.b	$20+(.LUM2/256)
     16  51c2		       98		      .byte.b	$90+(.LUM3/256)
     17  51c3
     18  51c3
     19  51c3
     20  51c3
     21  51c3
     22  51c3				   .LUM1      SET	.LUM1 + .STEP1
     23  51c3				   .LUM2      SET	.LUM2 + .STEP2
     24  51c3				   .LUM3      SET	.LUM3 + .STEP3
     13  51c3					      REPEND
     14  51c3		       44		      .byte.b	$40+(.LUM1/256)
     15  51c4		       26		      .byte.b	$20+(.LUM2/256)
     16  51c5		       98		      .byte.b	$90+(.LUM3/256)
     17  51c6
     18  51c6
     19  51c6
     20  51c6
     21  51c6
     22  51c6				   .LUM1      SET	.LUM1 + .STEP1
     23  51c6				   .LUM2      SET	.LUM2 + .STEP2
     24  51c6				   .LUM3      SET	.LUM3 + .STEP3
     13  51c6					      REPEND
     14  51c6		       44		      .byte.b	$40+(.LUM1/256)
     15  51c7		       26		      .byte.b	$20+(.LUM2/256)
     16  51c8		       98		      .byte.b	$90+(.LUM3/256)
     17  51c9
     18  51c9
     19  51c9
     20  51c9
     21  51c9
     22  51c9				   .LUM1      SET	.LUM1 + .STEP1
     23  51c9				   .LUM2      SET	.LUM2 + .STEP2
     24  51c9				   .LUM3      SET	.LUM3 + .STEP3
     13  51c9					      REPEND
     14  51c9		       44		      .byte.b	$40+(.LUM1/256)
     15  51ca		       26		      .byte.b	$20+(.LUM2/256)
     16  51cb		       98		      .byte.b	$90+(.LUM3/256)
     17  51cc
     18  51cc
     19  51cc
     20  51cc
     21  51cc
     22  51cc				   .LUM1      SET	.LUM1 + .STEP1
     23  51cc				   .LUM2      SET	.LUM2 + .STEP2
     24  51cc				   .LUM3      SET	.LUM3 + .STEP3
     13  51cc					      REPEND
     14  51cc		       44		      .byte.b	$40+(.LUM1/256)
     15  51cd		       26		      .byte.b	$20+(.LUM2/256)
     16  51ce		       98		      .byte.b	$90+(.LUM3/256)
     17  51cf
     18  51cf
     19  51cf
     20  51cf
     21  51cf
     22  51cf				   .LUM1      SET	.LUM1 + .STEP1
     23  51cf				   .LUM2      SET	.LUM2 + .STEP2
     24  51cf				   .LUM3      SET	.LUM3 + .STEP3
     13  51cf					      REPEND
     14  51cf		       44		      .byte.b	$40+(.LUM1/256)
     15  51d0		       26		      .byte.b	$20+(.LUM2/256)
     16  51d1		       98		      .byte.b	$90+(.LUM3/256)
     17  51d2
     18  51d2
     19  51d2
     20  51d2
     21  51d2
     22  51d2				   .LUM1      SET	.LUM1 + .STEP1
     23  51d2				   .LUM2      SET	.LUM2 + .STEP2
     24  51d2				   .LUM3      SET	.LUM3 + .STEP3
     13  51d2					      REPEND
     14  51d2		       44		      .byte.b	$40+(.LUM1/256)
     15  51d3		       26		      .byte.b	$20+(.LUM2/256)
     16  51d4		       98		      .byte.b	$90+(.LUM3/256)
     17  51d5
     18  51d5
     19  51d5
     20  51d5
     21  51d5
     22  51d5				   .LUM1      SET	.LUM1 + .STEP1
     23  51d5				   .LUM2      SET	.LUM2 + .STEP2
     24  51d5				   .LUM3      SET	.LUM3 + .STEP3
     13  51d5					      REPEND
     14  51d5		       44		      .byte.b	$40+(.LUM1/256)
     15  51d6		       26		      .byte.b	$20+(.LUM2/256)
     16  51d7		       98		      .byte.b	$90+(.LUM3/256)
     17  51d8
     18  51d8
     19  51d8
     20  51d8
     21  51d8
     22  51d8				   .LUM1      SET	.LUM1 + .STEP1
     23  51d8				   .LUM2      SET	.LUM2 + .STEP2
     24  51d8				   .LUM3      SET	.LUM3 + .STEP3
     25  51d8					      REPEND
    257  51d8							;colr_ntsc   LUMTABLE $70,$40,$a0,$A,$2,$E,$8,$E,$8
    258  51d8
    259  51d8							;    ECHO "PAL LUMS"
    260  51d8							;    OPTIONAL_PAGEBREAK "colr_pal", 72*3
      0  51d8				   colr_pal   LUMTABLE	$60, $80, $10, $6,$4,$8,$6,$4,$8
      1  51d8
      2  51d8
      3  51d8
      4  51d8
      5  51d8				   .LUM1      SET	$6*256
      6  51d8				   .LUM2      SET	$4*256
      7  51d8				   .LUM3      SET	$8*256
      8  51d8
      9  51d8		       00 00	   .STEP1     =	(256*($6-$6))/72
     10  51d8		       00 00	   .STEP2     =	(256*($4-$4))/72
     11  51d8		       00 00	   .STEP3     =	(256*($8-$8))/72
     12  51d8
     13  51d8					      REPEAT	72
     14  51d8		       66		      .byte.b	$60+(.LUM1/256)
     15  51d9		       84		      .byte.b	$80+(.LUM2/256)
     16  51da		       18		      .byte.b	$10+(.LUM3/256)
     17  51db
     18  51db
     19  51db
     20  51db
     21  51db
     22  51db				   .LUM1      SET	.LUM1 + .STEP1
     23  51db				   .LUM2      SET	.LUM2 + .STEP2
     24  51db				   .LUM3      SET	.LUM3 + .STEP3
     13  51db					      REPEND
     14  51db		       66		      .byte.b	$60+(.LUM1/256)
     15  51dc		       84		      .byte.b	$80+(.LUM2/256)
     16  51dd		       18		      .byte.b	$10+(.LUM3/256)
     17  51de
     18  51de
     19  51de
     20  51de
     21  51de
     22  51de				   .LUM1      SET	.LUM1 + .STEP1
     23  51de				   .LUM2      SET	.LUM2 + .STEP2
     24  51de				   .LUM3      SET	.LUM3 + .STEP3
     13  51de					      REPEND
     14  51de		       66		      .byte.b	$60+(.LUM1/256)
     15  51df		       84		      .byte.b	$80+(.LUM2/256)
     16  51e0		       18		      .byte.b	$10+(.LUM3/256)
     17  51e1
     18  51e1
     19  51e1
     20  51e1
     21  51e1
     22  51e1				   .LUM1      SET	.LUM1 + .STEP1
     23  51e1				   .LUM2      SET	.LUM2 + .STEP2
     24  51e1				   .LUM3      SET	.LUM3 + .STEP3
     13  51e1					      REPEND
     14  51e1		       66		      .byte.b	$60+(.LUM1/256)
     15  51e2		       84		      .byte.b	$80+(.LUM2/256)
     16  51e3		       18		      .byte.b	$10+(.LUM3/256)
     17  51e4
     18  51e4
     19  51e4
     20  51e4
     21  51e4
     22  51e4				   .LUM1      SET	.LUM1 + .STEP1
     23  51e4				   .LUM2      SET	.LUM2 + .STEP2
     24  51e4				   .LUM3      SET	.LUM3 + .STEP3
     13  51e4					      REPEND
     14  51e4		       66		      .byte.b	$60+(.LUM1/256)
     15  51e5		       84		      .byte.b	$80+(.LUM2/256)
     16  51e6		       18		      .byte.b	$10+(.LUM3/256)
     17  51e7
     18  51e7
     19  51e7
     20  51e7
     21  51e7
     22  51e7				   .LUM1      SET	.LUM1 + .STEP1
     23  51e7				   .LUM2      SET	.LUM2 + .STEP2
     24  51e7				   .LUM3      SET	.LUM3 + .STEP3
     13  51e7					      REPEND
     14  51e7		       66		      .byte.b	$60+(.LUM1/256)
     15  51e8		       84		      .byte.b	$80+(.LUM2/256)
     16  51e9		       18		      .byte.b	$10+(.LUM3/256)
     17  51ea
     18  51ea
     19  51ea
     20  51ea
     21  51ea
     22  51ea				   .LUM1      SET	.LUM1 + .STEP1
     23  51ea				   .LUM2      SET	.LUM2 + .STEP2
     24  51ea				   .LUM3      SET	.LUM3 + .STEP3
     13  51ea					      REPEND
     14  51ea		       66		      .byte.b	$60+(.LUM1/256)
     15  51eb		       84		      .byte.b	$80+(.LUM2/256)
     16  51ec		       18		      .byte.b	$10+(.LUM3/256)
     17  51ed
     18  51ed
     19  51ed
     20  51ed
     21  51ed
     22  51ed				   .LUM1      SET	.LUM1 + .STEP1
     23  51ed				   .LUM2      SET	.LUM2 + .STEP2
     24  51ed				   .LUM3      SET	.LUM3 + .STEP3
     13  51ed					      REPEND
     14  51ed		       66		      .byte.b	$60+(.LUM1/256)
     15  51ee		       84		      .byte.b	$80+(.LUM2/256)
     16  51ef		       18		      .byte.b	$10+(.LUM3/256)
     17  51f0
     18  51f0
     19  51f0
     20  51f0
     21  51f0
     22  51f0				   .LUM1      SET	.LUM1 + .STEP1
     23  51f0				   .LUM2      SET	.LUM2 + .STEP2
     24  51f0				   .LUM3      SET	.LUM3 + .STEP3
     13  51f0					      REPEND
     14  51f0		       66		      .byte.b	$60+(.LUM1/256)
     15  51f1		       84		      .byte.b	$80+(.LUM2/256)
     16  51f2		       18		      .byte.b	$10+(.LUM3/256)
     17  51f3
     18  51f3
     19  51f3
     20  51f3
     21  51f3
     22  51f3				   .LUM1      SET	.LUM1 + .STEP1
     23  51f3				   .LUM2      SET	.LUM2 + .STEP2
     24  51f3				   .LUM3      SET	.LUM3 + .STEP3
     13  51f3					      REPEND
     14  51f3		       66		      .byte.b	$60+(.LUM1/256)
     15  51f4		       84		      .byte.b	$80+(.LUM2/256)
     16  51f5		       18		      .byte.b	$10+(.LUM3/256)
     17  51f6
     18  51f6
     19  51f6
     20  51f6
     21  51f6
     22  51f6				   .LUM1      SET	.LUM1 + .STEP1
     23  51f6				   .LUM2      SET	.LUM2 + .STEP2
     24  51f6				   .LUM3      SET	.LUM3 + .STEP3
     13  51f6					      REPEND
     14  51f6		       66		      .byte.b	$60+(.LUM1/256)
     15  51f7		       84		      .byte.b	$80+(.LUM2/256)
     16  51f8		       18		      .byte.b	$10+(.LUM3/256)
     17  51f9
     18  51f9
     19  51f9
     20  51f9
     21  51f9
     22  51f9				   .LUM1      SET	.LUM1 + .STEP1
     23  51f9				   .LUM2      SET	.LUM2 + .STEP2
     24  51f9				   .LUM3      SET	.LUM3 + .STEP3
     13  51f9					      REPEND
     14  51f9		       66		      .byte.b	$60+(.LUM1/256)
     15  51fa		       84		      .byte.b	$80+(.LUM2/256)
     16  51fb		       18		      .byte.b	$10+(.LUM3/256)
     17  51fc
     18  51fc
     19  51fc
     20  51fc
     21  51fc
     22  51fc				   .LUM1      SET	.LUM1 + .STEP1
     23  51fc				   .LUM2      SET	.LUM2 + .STEP2
     24  51fc				   .LUM3      SET	.LUM3 + .STEP3
     13  51fc					      REPEND
     14  51fc		       66		      .byte.b	$60+(.LUM1/256)
     15  51fd		       84		      .byte.b	$80+(.LUM2/256)
     16  51fe		       18		      .byte.b	$10+(.LUM3/256)
     17  51ff
     18  51ff
     19  51ff
     20  51ff
     21  51ff
     22  51ff				   .LUM1      SET	.LUM1 + .STEP1
     23  51ff				   .LUM2      SET	.LUM2 + .STEP2
     24  51ff				   .LUM3      SET	.LUM3 + .STEP3
     13  51ff					      REPEND
     14  51ff		       66		      .byte.b	$60+(.LUM1/256)
     15  5200		       84		      .byte.b	$80+(.LUM2/256)
     16  5201		       18		      .byte.b	$10+(.LUM3/256)
     17  5202
     18  5202
     19  5202
     20  5202
     21  5202
     22  5202				   .LUM1      SET	.LUM1 + .STEP1
     23  5202				   .LUM2      SET	.LUM2 + .STEP2
     24  5202				   .LUM3      SET	.LUM3 + .STEP3
     13  5202					      REPEND
     14  5202		       66		      .byte.b	$60+(.LUM1/256)
     15  5203		       84		      .byte.b	$80+(.LUM2/256)
     16  5204		       18		      .byte.b	$10+(.LUM3/256)
     17  5205
     18  5205
     19  5205
     20  5205
     21  5205
     22  5205				   .LUM1      SET	.LUM1 + .STEP1
     23  5205				   .LUM2      SET	.LUM2 + .STEP2
     24  5205				   .LUM3      SET	.LUM3 + .STEP3
     13  5205					      REPEND
     14  5205		       66		      .byte.b	$60+(.LUM1/256)
     15  5206		       84		      .byte.b	$80+(.LUM2/256)
     16  5207		       18		      .byte.b	$10+(.LUM3/256)
     17  5208
     18  5208
     19  5208
     20  5208
     21  5208
     22  5208				   .LUM1      SET	.LUM1 + .STEP1
     23  5208				   .LUM2      SET	.LUM2 + .STEP2
     24  5208				   .LUM3      SET	.LUM3 + .STEP3
     13  5208					      REPEND
     14  5208		       66		      .byte.b	$60+(.LUM1/256)
     15  5209		       84		      .byte.b	$80+(.LUM2/256)
     16  520a		       18		      .byte.b	$10+(.LUM3/256)
     17  520b
     18  520b
     19  520b
     20  520b
     21  520b
     22  520b				   .LUM1      SET	.LUM1 + .STEP1
     23  520b				   .LUM2      SET	.LUM2 + .STEP2
     24  520b				   .LUM3      SET	.LUM3 + .STEP3
     13  520b					      REPEND
     14  520b		       66		      .byte.b	$60+(.LUM1/256)
     15  520c		       84		      .byte.b	$80+(.LUM2/256)
     16  520d		       18		      .byte.b	$10+(.LUM3/256)
     17  520e
     18  520e
     19  520e
     20  520e
     21  520e
     22  520e				   .LUM1      SET	.LUM1 + .STEP1
     23  520e				   .LUM2      SET	.LUM2 + .STEP2
     24  520e				   .LUM3      SET	.LUM3 + .STEP3
     13  520e					      REPEND
     14  520e		       66		      .byte.b	$60+(.LUM1/256)
     15  520f		       84		      .byte.b	$80+(.LUM2/256)
     16  5210		       18		      .byte.b	$10+(.LUM3/256)
     17  5211
     18  5211
     19  5211
     20  5211
     21  5211
     22  5211				   .LUM1      SET	.LUM1 + .STEP1
     23  5211				   .LUM2      SET	.LUM2 + .STEP2
     24  5211				   .LUM3      SET	.LUM3 + .STEP3
     13  5211					      REPEND
     14  5211		       66		      .byte.b	$60+(.LUM1/256)
     15  5212		       84		      .byte.b	$80+(.LUM2/256)
     16  5213		       18		      .byte.b	$10+(.LUM3/256)
     17  5214
     18  5214
     19  5214
     20  5214
     21  5214
     22  5214				   .LUM1      SET	.LUM1 + .STEP1
     23  5214				   .LUM2      SET	.LUM2 + .STEP2
     24  5214				   .LUM3      SET	.LUM3 + .STEP3
     13  5214					      REPEND
     14  5214		       66		      .byte.b	$60+(.LUM1/256)
     15  5215		       84		      .byte.b	$80+(.LUM2/256)
     16  5216		       18		      .byte.b	$10+(.LUM3/256)
     17  5217
     18  5217
     19  5217
     20  5217
     21  5217
     22  5217				   .LUM1      SET	.LUM1 + .STEP1
     23  5217				   .LUM2      SET	.LUM2 + .STEP2
     24  5217				   .LUM3      SET	.LUM3 + .STEP3
     13  5217					      REPEND
     14  5217		       66		      .byte.b	$60+(.LUM1/256)
     15  5218		       84		      .byte.b	$80+(.LUM2/256)
     16  5219		       18		      .byte.b	$10+(.LUM3/256)
     17  521a
     18  521a
     19  521a
     20  521a
     21  521a
     22  521a				   .LUM1      SET	.LUM1 + .STEP1
     23  521a				   .LUM2      SET	.LUM2 + .STEP2
     24  521a				   .LUM3      SET	.LUM3 + .STEP3
     13  521a					      REPEND
     14  521a		       66		      .byte.b	$60+(.LUM1/256)
     15  521b		       84		      .byte.b	$80+(.LUM2/256)
     16  521c		       18		      .byte.b	$10+(.LUM3/256)
     17  521d
     18  521d
     19  521d
     20  521d
     21  521d
     22  521d				   .LUM1      SET	.LUM1 + .STEP1
     23  521d				   .LUM2      SET	.LUM2 + .STEP2
     24  521d				   .LUM3      SET	.LUM3 + .STEP3
     13  521d					      REPEND
     14  521d		       66		      .byte.b	$60+(.LUM1/256)
     15  521e		       84		      .byte.b	$80+(.LUM2/256)
     16  521f		       18		      .byte.b	$10+(.LUM3/256)
     17  5220
     18  5220
     19  5220
     20  5220
     21  5220
     22  5220				   .LUM1      SET	.LUM1 + .STEP1
     23  5220				   .LUM2      SET	.LUM2 + .STEP2
     24  5220				   .LUM3      SET	.LUM3 + .STEP3
     13  5220					      REPEND
     14  5220		       66		      .byte.b	$60+(.LUM1/256)
     15  5221		       84		      .byte.b	$80+(.LUM2/256)
     16  5222		       18		      .byte.b	$10+(.LUM3/256)
     17  5223
     18  5223
     19  5223
     20  5223
     21  5223
     22  5223				   .LUM1      SET	.LUM1 + .STEP1
     23  5223				   .LUM2      SET	.LUM2 + .STEP2
     24  5223				   .LUM3      SET	.LUM3 + .STEP3
     13  5223					      REPEND
     14  5223		       66		      .byte.b	$60+(.LUM1/256)
     15  5224		       84		      .byte.b	$80+(.LUM2/256)
     16  5225		       18		      .byte.b	$10+(.LUM3/256)
     17  5226
     18  5226
     19  5226
     20  5226
     21  5226
     22  5226				   .LUM1      SET	.LUM1 + .STEP1
     23  5226				   .LUM2      SET	.LUM2 + .STEP2
     24  5226				   .LUM3      SET	.LUM3 + .STEP3
     13  5226					      REPEND
     14  5226		       66		      .byte.b	$60+(.LUM1/256)
     15  5227		       84		      .byte.b	$80+(.LUM2/256)
     16  5228		       18		      .byte.b	$10+(.LUM3/256)
     17  5229
     18  5229
     19  5229
     20  5229
     21  5229
     22  5229				   .LUM1      SET	.LUM1 + .STEP1
     23  5229				   .LUM2      SET	.LUM2 + .STEP2
     24  5229				   .LUM3      SET	.LUM3 + .STEP3
     13  5229					      REPEND
     14  5229		       66		      .byte.b	$60+(.LUM1/256)
     15  522a		       84		      .byte.b	$80+(.LUM2/256)
     16  522b		       18		      .byte.b	$10+(.LUM3/256)
     17  522c
     18  522c
     19  522c
     20  522c
     21  522c
     22  522c				   .LUM1      SET	.LUM1 + .STEP1
     23  522c				   .LUM2      SET	.LUM2 + .STEP2
     24  522c				   .LUM3      SET	.LUM3 + .STEP3
     13  522c					      REPEND
     14  522c		       66		      .byte.b	$60+(.LUM1/256)
     15  522d		       84		      .byte.b	$80+(.LUM2/256)
     16  522e		       18		      .byte.b	$10+(.LUM3/256)
     17  522f
     18  522f
     19  522f
     20  522f
     21  522f
     22  522f				   .LUM1      SET	.LUM1 + .STEP1
     23  522f				   .LUM2      SET	.LUM2 + .STEP2
     24  522f				   .LUM3      SET	.LUM3 + .STEP3
     13  522f					      REPEND
     14  522f		       66		      .byte.b	$60+(.LUM1/256)
     15  5230		       84		      .byte.b	$80+(.LUM2/256)
     16  5231		       18		      .byte.b	$10+(.LUM3/256)
     17  5232
     18  5232
     19  5232
     20  5232
     21  5232
     22  5232				   .LUM1      SET	.LUM1 + .STEP1
     23  5232				   .LUM2      SET	.LUM2 + .STEP2
     24  5232				   .LUM3      SET	.LUM3 + .STEP3
     13  5232					      REPEND
     14  5232		       66		      .byte.b	$60+(.LUM1/256)
     15  5233		       84		      .byte.b	$80+(.LUM2/256)
     16  5234		       18		      .byte.b	$10+(.LUM3/256)
     17  5235
     18  5235
     19  5235
     20  5235
     21  5235
     22  5235				   .LUM1      SET	.LUM1 + .STEP1
     23  5235				   .LUM2      SET	.LUM2 + .STEP2
     24  5235				   .LUM3      SET	.LUM3 + .STEP3
     13  5235					      REPEND
     14  5235		       66		      .byte.b	$60+(.LUM1/256)
     15  5236		       84		      .byte.b	$80+(.LUM2/256)
     16  5237		       18		      .byte.b	$10+(.LUM3/256)
     17  5238
     18  5238
     19  5238
     20  5238
     21  5238
     22  5238				   .LUM1      SET	.LUM1 + .STEP1
     23  5238				   .LUM2      SET	.LUM2 + .STEP2
     24  5238				   .LUM3      SET	.LUM3 + .STEP3
     13  5238					      REPEND
     14  5238		       66		      .byte.b	$60+(.LUM1/256)
     15  5239		       84		      .byte.b	$80+(.LUM2/256)
     16  523a		       18		      .byte.b	$10+(.LUM3/256)
     17  523b
     18  523b
     19  523b
     20  523b
     21  523b
     22  523b				   .LUM1      SET	.LUM1 + .STEP1
     23  523b				   .LUM2      SET	.LUM2 + .STEP2
     24  523b				   .LUM3      SET	.LUM3 + .STEP3
     13  523b					      REPEND
     14  523b		       66		      .byte.b	$60+(.LUM1/256)
     15  523c		       84		      .byte.b	$80+(.LUM2/256)
     16  523d		       18		      .byte.b	$10+(.LUM3/256)
     17  523e
     18  523e
     19  523e
     20  523e
     21  523e
     22  523e				   .LUM1      SET	.LUM1 + .STEP1
     23  523e				   .LUM2      SET	.LUM2 + .STEP2
     24  523e				   .LUM3      SET	.LUM3 + .STEP3
     13  523e					      REPEND
     14  523e		       66		      .byte.b	$60+(.LUM1/256)
     15  523f		       84		      .byte.b	$80+(.LUM2/256)
     16  5240		       18		      .byte.b	$10+(.LUM3/256)
     17  5241
     18  5241
     19  5241
     20  5241
     21  5241
     22  5241				   .LUM1      SET	.LUM1 + .STEP1
     23  5241				   .LUM2      SET	.LUM2 + .STEP2
     24  5241				   .LUM3      SET	.LUM3 + .STEP3
     13  5241					      REPEND
     14  5241		       66		      .byte.b	$60+(.LUM1/256)
     15  5242		       84		      .byte.b	$80+(.LUM2/256)
     16  5243		       18		      .byte.b	$10+(.LUM3/256)
     17  5244
     18  5244
     19  5244
     20  5244
     21  5244
     22  5244				   .LUM1      SET	.LUM1 + .STEP1
     23  5244				   .LUM2      SET	.LUM2 + .STEP2
     24  5244				   .LUM3      SET	.LUM3 + .STEP3
     13  5244					      REPEND
     14  5244		       66		      .byte.b	$60+(.LUM1/256)
     15  5245		       84		      .byte.b	$80+(.LUM2/256)
     16  5246		       18		      .byte.b	$10+(.LUM3/256)
     17  5247
     18  5247
     19  5247
     20  5247
     21  5247
     22  5247				   .LUM1      SET	.LUM1 + .STEP1
     23  5247				   .LUM2      SET	.LUM2 + .STEP2
     24  5247				   .LUM3      SET	.LUM3 + .STEP3
     13  5247					      REPEND
     14  5247		       66		      .byte.b	$60+(.LUM1/256)
     15  5248		       84		      .byte.b	$80+(.LUM2/256)
     16  5249		       18		      .byte.b	$10+(.LUM3/256)
     17  524a
     18  524a
     19  524a
     20  524a
     21  524a
     22  524a				   .LUM1      SET	.LUM1 + .STEP1
     23  524a				   .LUM2      SET	.LUM2 + .STEP2
     24  524a				   .LUM3      SET	.LUM3 + .STEP3
     13  524a					      REPEND
     14  524a		       66		      .byte.b	$60+(.LUM1/256)
     15  524b		       84		      .byte.b	$80+(.LUM2/256)
     16  524c		       18		      .byte.b	$10+(.LUM3/256)
     17  524d
     18  524d
     19  524d
     20  524d
     21  524d
     22  524d				   .LUM1      SET	.LUM1 + .STEP1
     23  524d				   .LUM2      SET	.LUM2 + .STEP2
     24  524d				   .LUM3      SET	.LUM3 + .STEP3
     13  524d					      REPEND
     14  524d		       66		      .byte.b	$60+(.LUM1/256)
     15  524e		       84		      .byte.b	$80+(.LUM2/256)
     16  524f		       18		      .byte.b	$10+(.LUM3/256)
     17  5250
     18  5250
     19  5250
     20  5250
     21  5250
     22  5250				   .LUM1      SET	.LUM1 + .STEP1
     23  5250				   .LUM2      SET	.LUM2 + .STEP2
     24  5250				   .LUM3      SET	.LUM3 + .STEP3
     13  5250					      REPEND
     14  5250		       66		      .byte.b	$60+(.LUM1/256)
     15  5251		       84		      .byte.b	$80+(.LUM2/256)
     16  5252		       18		      .byte.b	$10+(.LUM3/256)
     17  5253
     18  5253
     19  5253
     20  5253
     21  5253
     22  5253				   .LUM1      SET	.LUM1 + .STEP1
     23  5253				   .LUM2      SET	.LUM2 + .STEP2
     24  5253				   .LUM3      SET	.LUM3 + .STEP3
     13  5253					      REPEND
     14  5253		       66		      .byte.b	$60+(.LUM1/256)
     15  5254		       84		      .byte.b	$80+(.LUM2/256)
     16  5255		       18		      .byte.b	$10+(.LUM3/256)
     17  5256
     18  5256
     19  5256
     20  5256
     21  5256
     22  5256				   .LUM1      SET	.LUM1 + .STEP1
     23  5256				   .LUM2      SET	.LUM2 + .STEP2
     24  5256				   .LUM3      SET	.LUM3 + .STEP3
     13  5256					      REPEND
     14  5256		       66		      .byte.b	$60+(.LUM1/256)
     15  5257		       84		      .byte.b	$80+(.LUM2/256)
     16  5258		       18		      .byte.b	$10+(.LUM3/256)
     17  5259
     18  5259
     19  5259
     20  5259
     21  5259
     22  5259				   .LUM1      SET	.LUM1 + .STEP1
     23  5259				   .LUM2      SET	.LUM2 + .STEP2
     24  5259				   .LUM3      SET	.LUM3 + .STEP3
     13  5259					      REPEND
     14  5259		       66		      .byte.b	$60+(.LUM1/256)
     15  525a		       84		      .byte.b	$80+(.LUM2/256)
     16  525b		       18		      .byte.b	$10+(.LUM3/256)
     17  525c
     18  525c
     19  525c
     20  525c
     21  525c
     22  525c				   .LUM1      SET	.LUM1 + .STEP1
     23  525c				   .LUM2      SET	.LUM2 + .STEP2
     24  525c				   .LUM3      SET	.LUM3 + .STEP3
     13  525c					      REPEND
     14  525c		       66		      .byte.b	$60+(.LUM1/256)
     15  525d		       84		      .byte.b	$80+(.LUM2/256)
     16  525e		       18		      .byte.b	$10+(.LUM3/256)
     17  525f
     18  525f
     19  525f
     20  525f
     21  525f
     22  525f				   .LUM1      SET	.LUM1 + .STEP1
     23  525f				   .LUM2      SET	.LUM2 + .STEP2
     24  525f				   .LUM3      SET	.LUM3 + .STEP3
     13  525f					      REPEND
     14  525f		       66		      .byte.b	$60+(.LUM1/256)
     15  5260		       84		      .byte.b	$80+(.LUM2/256)
     16  5261		       18		      .byte.b	$10+(.LUM3/256)
     17  5262
     18  5262
     19  5262
     20  5262
     21  5262
     22  5262				   .LUM1      SET	.LUM1 + .STEP1
     23  5262				   .LUM2      SET	.LUM2 + .STEP2
     24  5262				   .LUM3      SET	.LUM3 + .STEP3
     13  5262					      REPEND
     14  5262		       66		      .byte.b	$60+(.LUM1/256)
     15  5263		       84		      .byte.b	$80+(.LUM2/256)
     16  5264		       18		      .byte.b	$10+(.LUM3/256)
     17  5265
     18  5265
     19  5265
     20  5265
     21  5265
     22  5265				   .LUM1      SET	.LUM1 + .STEP1
     23  5265				   .LUM2      SET	.LUM2 + .STEP2
     24  5265				   .LUM3      SET	.LUM3 + .STEP3
     13  5265					      REPEND
     14  5265		       66		      .byte.b	$60+(.LUM1/256)
     15  5266		       84		      .byte.b	$80+(.LUM2/256)
     16  5267		       18		      .byte.b	$10+(.LUM3/256)
     17  5268
     18  5268
     19  5268
     20  5268
     21  5268
     22  5268				   .LUM1      SET	.LUM1 + .STEP1
     23  5268				   .LUM2      SET	.LUM2 + .STEP2
     24  5268				   .LUM3      SET	.LUM3 + .STEP3
     13  5268					      REPEND
     14  5268		       66		      .byte.b	$60+(.LUM1/256)
     15  5269		       84		      .byte.b	$80+(.LUM2/256)
     16  526a		       18		      .byte.b	$10+(.LUM3/256)
     17  526b
     18  526b
     19  526b
     20  526b
     21  526b
     22  526b				   .LUM1      SET	.LUM1 + .STEP1
     23  526b				   .LUM2      SET	.LUM2 + .STEP2
     24  526b				   .LUM3      SET	.LUM3 + .STEP3
     13  526b					      REPEND
     14  526b		       66		      .byte.b	$60+(.LUM1/256)
     15  526c		       84		      .byte.b	$80+(.LUM2/256)
     16  526d		       18		      .byte.b	$10+(.LUM3/256)
     17  526e
     18  526e
     19  526e
     20  526e
     21  526e
     22  526e				   .LUM1      SET	.LUM1 + .STEP1
     23  526e				   .LUM2      SET	.LUM2 + .STEP2
     24  526e				   .LUM3      SET	.LUM3 + .STEP3
     13  526e					      REPEND
     14  526e		       66		      .byte.b	$60+(.LUM1/256)
     15  526f		       84		      .byte.b	$80+(.LUM2/256)
     16  5270		       18		      .byte.b	$10+(.LUM3/256)
     17  5271
     18  5271
     19  5271
     20  5271
     21  5271
     22  5271				   .LUM1      SET	.LUM1 + .STEP1
     23  5271				   .LUM2      SET	.LUM2 + .STEP2
     24  5271				   .LUM3      SET	.LUM3 + .STEP3
     13  5271					      REPEND
     14  5271		       66		      .byte.b	$60+(.LUM1/256)
     15  5272		       84		      .byte.b	$80+(.LUM2/256)
     16  5273		       18		      .byte.b	$10+(.LUM3/256)
     17  5274
     18  5274
     19  5274
     20  5274
     21  5274
     22  5274				   .LUM1      SET	.LUM1 + .STEP1
     23  5274				   .LUM2      SET	.LUM2 + .STEP2
     24  5274				   .LUM3      SET	.LUM3 + .STEP3
     13  5274					      REPEND
     14  5274		       66		      .byte.b	$60+(.LUM1/256)
     15  5275		       84		      .byte.b	$80+(.LUM2/256)
     16  5276		       18		      .byte.b	$10+(.LUM3/256)
     17  5277
     18  5277
     19  5277
     20  5277
     21  5277
     22  5277				   .LUM1      SET	.LUM1 + .STEP1
     23  5277				   .LUM2      SET	.LUM2 + .STEP2
     24  5277				   .LUM3      SET	.LUM3 + .STEP3
     13  5277					      REPEND
     14  5277		       66		      .byte.b	$60+(.LUM1/256)
     15  5278		       84		      .byte.b	$80+(.LUM2/256)
     16  5279		       18		      .byte.b	$10+(.LUM3/256)
     17  527a
     18  527a
     19  527a
     20  527a
     21  527a
     22  527a				   .LUM1      SET	.LUM1 + .STEP1
     23  527a				   .LUM2      SET	.LUM2 + .STEP2
     24  527a				   .LUM3      SET	.LUM3 + .STEP3
     13  527a					      REPEND
     14  527a		       66		      .byte.b	$60+(.LUM1/256)
     15  527b		       84		      .byte.b	$80+(.LUM2/256)
     16  527c		       18		      .byte.b	$10+(.LUM3/256)
     17  527d
     18  527d
     19  527d
     20  527d
     21  527d
     22  527d				   .LUM1      SET	.LUM1 + .STEP1
     23  527d				   .LUM2      SET	.LUM2 + .STEP2
     24  527d				   .LUM3      SET	.LUM3 + .STEP3
     13  527d					      REPEND
     14  527d		       66		      .byte.b	$60+(.LUM1/256)
     15  527e		       84		      .byte.b	$80+(.LUM2/256)
     16  527f		       18		      .byte.b	$10+(.LUM3/256)
     17  5280
     18  5280
     19  5280
     20  5280
     21  5280
     22  5280				   .LUM1      SET	.LUM1 + .STEP1
     23  5280				   .LUM2      SET	.LUM2 + .STEP2
     24  5280				   .LUM3      SET	.LUM3 + .STEP3
     13  5280					      REPEND
     14  5280		       66		      .byte.b	$60+(.LUM1/256)
     15  5281		       84		      .byte.b	$80+(.LUM2/256)
     16  5282		       18		      .byte.b	$10+(.LUM3/256)
     17  5283
     18  5283
     19  5283
     20  5283
     21  5283
     22  5283				   .LUM1      SET	.LUM1 + .STEP1
     23  5283				   .LUM2      SET	.LUM2 + .STEP2
     24  5283				   .LUM3      SET	.LUM3 + .STEP3
     13  5283					      REPEND
     14  5283		       66		      .byte.b	$60+(.LUM1/256)
     15  5284		       84		      .byte.b	$80+(.LUM2/256)
     16  5285		       18		      .byte.b	$10+(.LUM3/256)
     17  5286
     18  5286
     19  5286
     20  5286
     21  5286
     22  5286				   .LUM1      SET	.LUM1 + .STEP1
     23  5286				   .LUM2      SET	.LUM2 + .STEP2
     24  5286				   .LUM3      SET	.LUM3 + .STEP3
     13  5286					      REPEND
     14  5286		       66		      .byte.b	$60+(.LUM1/256)
     15  5287		       84		      .byte.b	$80+(.LUM2/256)
     16  5288		       18		      .byte.b	$10+(.LUM3/256)
     17  5289
     18  5289
     19  5289
     20  5289
     21  5289
     22  5289				   .LUM1      SET	.LUM1 + .STEP1
     23  5289				   .LUM2      SET	.LUM2 + .STEP2
     24  5289				   .LUM3      SET	.LUM3 + .STEP3
     13  5289					      REPEND
     14  5289		       66		      .byte.b	$60+(.LUM1/256)
     15  528a		       84		      .byte.b	$80+(.LUM2/256)
     16  528b		       18		      .byte.b	$10+(.LUM3/256)
     17  528c
     18  528c
     19  528c
     20  528c
     21  528c
     22  528c				   .LUM1      SET	.LUM1 + .STEP1
     23  528c				   .LUM2      SET	.LUM2 + .STEP2
     24  528c				   .LUM3      SET	.LUM3 + .STEP3
     13  528c					      REPEND
     14  528c		       66		      .byte.b	$60+(.LUM1/256)
     15  528d		       84		      .byte.b	$80+(.LUM2/256)
     16  528e		       18		      .byte.b	$10+(.LUM3/256)
     17  528f
     18  528f
     19  528f
     20  528f
     21  528f
     22  528f				   .LUM1      SET	.LUM1 + .STEP1
     23  528f				   .LUM2      SET	.LUM2 + .STEP2
     24  528f				   .LUM3      SET	.LUM3 + .STEP3
     13  528f					      REPEND
     14  528f		       66		      .byte.b	$60+(.LUM1/256)
     15  5290		       84		      .byte.b	$80+(.LUM2/256)
     16  5291		       18		      .byte.b	$10+(.LUM3/256)
     17  5292
     18  5292
     19  5292
     20  5292
     21  5292
     22  5292				   .LUM1      SET	.LUM1 + .STEP1
     23  5292				   .LUM2      SET	.LUM2 + .STEP2
     24  5292				   .LUM3      SET	.LUM3 + .STEP3
     13  5292					      REPEND
     14  5292		       66		      .byte.b	$60+(.LUM1/256)
     15  5293		       84		      .byte.b	$80+(.LUM2/256)
     16  5294		       18		      .byte.b	$10+(.LUM3/256)
     17  5295
     18  5295
     19  5295
     20  5295
     21  5295
     22  5295				   .LUM1      SET	.LUM1 + .STEP1
     23  5295				   .LUM2      SET	.LUM2 + .STEP2
     24  5295				   .LUM3      SET	.LUM3 + .STEP3
     13  5295					      REPEND
     14  5295		       66		      .byte.b	$60+(.LUM1/256)
     15  5296		       84		      .byte.b	$80+(.LUM2/256)
     16  5297		       18		      .byte.b	$10+(.LUM3/256)
     17  5298
     18  5298
     19  5298
     20  5298
     21  5298
     22  5298				   .LUM1      SET	.LUM1 + .STEP1
     23  5298				   .LUM2      SET	.LUM2 + .STEP2
     24  5298				   .LUM3      SET	.LUM3 + .STEP3
     13  5298					      REPEND
     14  5298		       66		      .byte.b	$60+(.LUM1/256)
     15  5299		       84		      .byte.b	$80+(.LUM2/256)
     16  529a		       18		      .byte.b	$10+(.LUM3/256)
     17  529b
     18  529b
     19  529b
     20  529b
     21  529b
     22  529b				   .LUM1      SET	.LUM1 + .STEP1
     23  529b				   .LUM2      SET	.LUM2 + .STEP2
     24  529b				   .LUM3      SET	.LUM3 + .STEP3
     13  529b					      REPEND
     14  529b		       66		      .byte.b	$60+(.LUM1/256)
     15  529c		       84		      .byte.b	$80+(.LUM2/256)
     16  529d		       18		      .byte.b	$10+(.LUM3/256)
     17  529e
     18  529e
     19  529e
     20  529e
     21  529e
     22  529e				   .LUM1      SET	.LUM1 + .STEP1
     23  529e				   .LUM2      SET	.LUM2 + .STEP2
     24  529e				   .LUM3      SET	.LUM3 + .STEP3
     13  529e					      REPEND
     14  529e		       66		      .byte.b	$60+(.LUM1/256)
     15  529f		       84		      .byte.b	$80+(.LUM2/256)
     16  52a0		       18		      .byte.b	$10+(.LUM3/256)
     17  52a1
     18  52a1
     19  52a1
     20  52a1
     21  52a1
     22  52a1				   .LUM1      SET	.LUM1 + .STEP1
     23  52a1				   .LUM2      SET	.LUM2 + .STEP2
     24  52a1				   .LUM3      SET	.LUM3 + .STEP3
     13  52a1					      REPEND
     14  52a1		       66		      .byte.b	$60+(.LUM1/256)
     15  52a2		       84		      .byte.b	$80+(.LUM2/256)
     16  52a3		       18		      .byte.b	$10+(.LUM3/256)
     17  52a4
     18  52a4
     19  52a4
     20  52a4
     21  52a4
     22  52a4				   .LUM1      SET	.LUM1 + .STEP1
     23  52a4				   .LUM2      SET	.LUM2 + .STEP2
     24  52a4				   .LUM3      SET	.LUM3 + .STEP3
     13  52a4					      REPEND
     14  52a4		       66		      .byte.b	$60+(.LUM1/256)
     15  52a5		       84		      .byte.b	$80+(.LUM2/256)
     16  52a6		       18		      .byte.b	$10+(.LUM3/256)
     17  52a7
     18  52a7
     19  52a7
     20  52a7
     21  52a7
     22  52a7				   .LUM1      SET	.LUM1 + .STEP1
     23  52a7				   .LUM2      SET	.LUM2 + .STEP2
     24  52a7				   .LUM3      SET	.LUM3 + .STEP3
     13  52a7					      REPEND
     14  52a7		       66		      .byte.b	$60+(.LUM1/256)
     15  52a8		       84		      .byte.b	$80+(.LUM2/256)
     16  52a9		       18		      .byte.b	$10+(.LUM3/256)
     17  52aa
     18  52aa
     19  52aa
     20  52aa
     21  52aa
     22  52aa				   .LUM1      SET	.LUM1 + .STEP1
     23  52aa				   .LUM2      SET	.LUM2 + .STEP2
     24  52aa				   .LUM3      SET	.LUM3 + .STEP3
     13  52aa					      REPEND
     14  52aa		       66		      .byte.b	$60+(.LUM1/256)
     15  52ab		       84		      .byte.b	$80+(.LUM2/256)
     16  52ac		       18		      .byte.b	$10+(.LUM3/256)
     17  52ad
     18  52ad
     19  52ad
     20  52ad
     21  52ad
     22  52ad				   .LUM1      SET	.LUM1 + .STEP1
     23  52ad				   .LUM2      SET	.LUM2 + .STEP2
     24  52ad				   .LUM3      SET	.LUM3 + .STEP3
     13  52ad					      REPEND
     14  52ad		       66		      .byte.b	$60+(.LUM1/256)
     15  52ae		       84		      .byte.b	$80+(.LUM2/256)
     16  52af		       18		      .byte.b	$10+(.LUM3/256)
     17  52b0
     18  52b0
     19  52b0
     20  52b0
     21  52b0
     22  52b0				   .LUM1      SET	.LUM1 + .STEP1
     23  52b0				   .LUM2      SET	.LUM2 + .STEP2
     24  52b0				   .LUM3      SET	.LUM3 + .STEP3
     25  52b0					      REPEND
    262  52b0							;colr_pal	  LUMTABLE $90, $20, $60, $6,$A,$a,$C,$6,$8
    263  52b0
------- FILE titleData.asm LEVEL 3 PASS 5
      0  52b0					      include	"titleData.asm"
      1  52b0				   COL_0
      2  52b0		       00		      .byte.b	0	;R (71)
      3  52b1		       00		      .byte.b	0	;G
      4  52b2		       00		      .byte.b	0	;B
      5  52b3		       40		      .byte.b	64	;R (70)
      6  52b4		       40		      .byte.b	64	;G
      7  52b5		       00		      .byte.b	0	;B
      8  52b6		       00		      .byte.b	0	;R (69)
      9  52b7		       00		      .byte.b	0	;G
     10  52b8		       00		      .byte.b	0	;B
     11  52b9		       00		      .byte.b	0	;R (68)
     12  52ba		       80		      .byte.b	128	;G
     13  52bb		       00		      .byte.b	0	;B
     14  52bc		       00		      .byte.b	0	;R (67)
     15  52bd		       20		      .byte.b	32	;G
     16  52be		       00		      .byte.b	0	;B
     17  52bf		       80		      .byte.b	128	;R (66)
     18  52c0		       80		      .byte.b	128	;G
     19  52c1		       00		      .byte.b	0	;B
     20  52c2		       c0		      .byte.b	192	;R (65)
     21  52c3		       c0		      .byte.b	192	;G
     22  52c4		       00		      .byte.b	0	;B
     23  52c5		       40		      .byte.b	64	;R (64)
     24  52c6		       c0		      .byte.b	192	;G
     25  52c7		       00		      .byte.b	0	;B
     26  52c8		       00		      .byte.b	0	;R (63)
     27  52c9		       a0		      .byte.b	160	;G
     28  52ca		       00		      .byte.b	0	;B
     29  52cb		       10		      .byte.b	16	;R (62)
     30  52cc		       70		      .byte.b	112	;G
     31  52cd		       00		      .byte.b	0	;B
     32  52ce		       00		      .byte.b	0	;R (61)
     33  52cf		       80		      .byte.b	128	;G
     34  52d0		       40		      .byte.b	64	;B
     35  52d1		       00		      .byte.b	0	;R (60)
     36  52d2		       c0		      .byte.b	192	;G
     37  52d3		       00		      .byte.b	0	;B
     38  52d4		       00		      .byte.b	0	;R (59)
     39  52d5		       c0		      .byte.b	192	;G
     40  52d6		       00		      .byte.b	0	;B
     41  52d7		       00		      .byte.b	0	;R (58)
     42  52d8		       40		      .byte.b	64	;G
     43  52d9		       00		      .byte.b	0	;B
     44  52da		       00		      .byte.b	0	;R (57)
     45  52db		       c0		      .byte.b	192	;G
     46  52dc		       00		      .byte.b	0	;B
     47  52dd		       00		      .byte.b	0	;R (56)
     48  52de		       60		      .byte.b	96	;G
     49  52df		       00		      .byte.b	0	;B
     50  52e0		       00		      .byte.b	0	;R (55)
     51  52e1		       80		      .byte.b	128	;G
     52  52e2		       00		      .byte.b	0	;B
     53  52e3		       00		      .byte.b	0	;R (54)
     54  52e4		       40		      .byte.b	64	;G
     55  52e5		       00		      .byte.b	0	;B
     56  52e6		       00		      .byte.b	0	;R (53)
     57  52e7		       80		      .byte.b	128	;G
     58  52e8		       00		      .byte.b	0	;B
     59  52e9		       00		      .byte.b	0	;R (52)
     60  52ea		       80		      .byte.b	128	;G
     61  52eb		       00		      .byte.b	0	;B
     62  52ec		       00		      .byte.b	0	;R (51)
     63  52ed		       10		      .byte.b	16	;G
     64  52ee		       00		      .byte.b	0	;B
     65  52ef		       00		      .byte.b	0	;R (50)
     66  52f0		       00		      .byte.b	0	;G
     67  52f1		       00		      .byte.b	0	;B
     68  52f2		       00		      .byte.b	0	;R (49)
     69  52f3		       00		      .byte.b	0	;G
     70  52f4		       00		      .byte.b	0	;B
     71  52f5		       00		      .byte.b	0	;R (48)
     72  52f6		       00		      .byte.b	0	;G
     73  52f7		       00		      .byte.b	0	;B
     74  52f8		       00		      .byte.b	0	;R (47)
     75  52f9		       00		      .byte.b	0	;G
     76  52fa		       00		      .byte.b	0	;B
     77  52fb		       00		      .byte.b	0	;R (46)
     78  52fc		       40		      .byte.b	64	;G
     79  52fd		       00		      .byte.b	0	;B
     80  52fe		       00		      .byte.b	0	;R (45)
     81  52ff		       00		      .byte.b	0	;G
     82  5300		       00		      .byte.b	0	;B
     83  5301		       00		      .byte.b	0	;R (44)
     84  5302		       00		      .byte.b	0	;G
     85  5303		       00		      .byte.b	0	;B
     86  5304		       00		      .byte.b	0	;R (43)
     87  5305		       00		      .byte.b	0	;G
     88  5306		       00		      .byte.b	0	;B
     89  5307		       00		      .byte.b	0	;R (42)
     90  5308		       40		      .byte.b	64	;G
     91  5309		       00		      .byte.b	0	;B
     92  530a		       00		      .byte.b	0	;R (41)
     93  530b		       00		      .byte.b	0	;G
     94  530c		       00		      .byte.b	0	;B
     95  530d		       00		      .byte.b	0	;R (40)
     96  530e		       00		      .byte.b	0	;G
     97  530f		       00		      .byte.b	0	;B
     98  5310		       00		      .byte.b	0	;R (39)
     99  5311		       20		      .byte.b	32	;G
    100  5312		       00		      .byte.b	0	;B
    101  5313		       00		      .byte.b	0	;R (38)
    102  5314		       00		      .byte.b	0	;G
    103  5315		       00		      .byte.b	0	;B
    104  5316		       00		      .byte.b	0	;R (37)
    105  5317		       10		      .byte.b	16	;G
    106  5318		       00		      .byte.b	0	;B
    107  5319		       00		      .byte.b	0	;R (36)
    108  531a		       00		      .byte.b	0	;G
    109  531b		       00		      .byte.b	0	;B
    110  531c		       00		      .byte.b	0	;R (35)
    111  531d		       40		      .byte.b	64	;G
    112  531e		       00		      .byte.b	0	;B
    113  531f		       00		      .byte.b	0	;R (34)
    114  5320		       20		      .byte.b	32	;G
    115  5321		       00		      .byte.b	0	;B
    116  5322		       00		      .byte.b	0	;R (33)
    117  5323		       00		      .byte.b	0	;G
    118  5324		       00		      .byte.b	0	;B
    119  5325		       00		      .byte.b	0	;R (32)
    120  5326		       00		      .byte.b	0	;G
    121  5327		       00		      .byte.b	0	;B
    122  5328		       00		      .byte.b	0	;R (31)
    123  5329		       20		      .byte.b	32	;G
    124  532a		       00		      .byte.b	0	;B
    125  532b		       00		      .byte.b	0	;R (30)
    126  532c		       00		      .byte.b	0	;G
    127  532d		       00		      .byte.b	0	;B
    128  532e		       00		      .byte.b	0	;R (29)
    129  532f		       80		      .byte.b	128	;G
    130  5330		       00		      .byte.b	0	;B
    131  5331		       00		      .byte.b	0	;R (28)
    132  5332		       00		      .byte.b	0	;G
    133  5333		       00		      .byte.b	0	;B
    134  5334		       00		      .byte.b	0	;R (27)
    135  5335		       20		      .byte.b	32	;G
    136  5336		       00		      .byte.b	0	;B
    137  5337		       00		      .byte.b	0	;R (26)
    138  5338		       00		      .byte.b	0	;G
    139  5339		       00		      .byte.b	0	;B
    140  533a		       00		      .byte.b	0	;R (25)
    141  533b		       00		      .byte.b	0	;G
    142  533c		       00		      .byte.b	0	;B
    143  533d		       00		      .byte.b	0	;R (24)
    144  533e		       20		      .byte.b	32	;G
    145  533f		       00		      .byte.b	0	;B
    146  5340		       00		      .byte.b	0	;R (23)
    147  5341		       00		      .byte.b	0	;G
    148  5342		       00		      .byte.b	0	;B
    149  5343		       00		      .byte.b	0	;R (22)
    150  5344		       00		      .byte.b	0	;G
    151  5345		       00		      .byte.b	0	;B
    152  5346		       00		      .byte.b	0	;R (21)
    153  5347		       20		      .byte.b	32	;G
    154  5348		       00		      .byte.b	0	;B
    155  5349		       00		      .byte.b	0	;R (20)
    156  534a		       00		      .byte.b	0	;G
    157  534b		       00		      .byte.b	0	;B
    158  534c		       00		      .byte.b	0	;R (19)
    159  534d		       00		      .byte.b	0	;G
    160  534e		       00		      .byte.b	0	;B
    161  534f		       00		      .byte.b	0	;R (18)
    162  5350		       00		      .byte.b	0	;G
    163  5351		       00		      .byte.b	0	;B
    164  5352		       00		      .byte.b	0	;R (17)
    165  5353		       80		      .byte.b	128	;G
    166  5354		       00		      .byte.b	0	;B
    167  5355		       00		      .byte.b	0	;R (16)
    168  5356		       00		      .byte.b	0	;G
    169  5357		       00		      .byte.b	0	;B
    170  5358		       00		      .byte.b	0	;R (15)
    171  5359		       10		      .byte.b	16	;G
    172  535a		       00		      .byte.b	0	;B
    173  535b		       00		      .byte.b	0	;R (14)
    174  535c		       00		      .byte.b	0	;G
    175  535d		       00		      .byte.b	0	;B
    176  535e		       00		      .byte.b	0	;R (13)
    177  535f		       00		      .byte.b	0	;G
    178  5360		       00		      .byte.b	0	;B
    179  5361		       00		      .byte.b	0	;R (12)
    180  5362		       80		      .byte.b	128	;G
    181  5363		       00		      .byte.b	0	;B
    182  5364		       00		      .byte.b	0	;R (11)
    183  5365		       00		      .byte.b	0	;G
    184  5366		       00		      .byte.b	0	;B
    185  5367		       00		      .byte.b	0	;R (10)
    186  5368		       00		      .byte.b	0	;G
    187  5369		       00		      .byte.b	0	;B
    188  536a		       00		      .byte.b	0	;R (9)
    189  536b		       80		      .byte.b	128	;G
    190  536c		       00		      .byte.b	0	;B
    191  536d		       00		      .byte.b	0	;R (8)
    192  536e		       00		      .byte.b	0	;G
    193  536f		       00		      .byte.b	0	;B
    194  5370		       00		      .byte.b	0	;R (7)
    195  5371		       20		      .byte.b	32	;G
    196  5372		       00		      .byte.b	0	;B
    197  5373		       00		      .byte.b	0	;R (6)
    198  5374		       00		      .byte.b	0	;G
    199  5375		       00		      .byte.b	0	;B
    200  5376		       00		      .byte.b	0	;R (5)
    201  5377		       10		      .byte.b	16	;G
    202  5378		       00		      .byte.b	0	;B
    203  5379		       00		      .byte.b	0	;R (4)
    204  537a		       00		      .byte.b	0	;G
    205  537b		       00		      .byte.b	0	;B
    206  537c		       00		      .byte.b	0	;R (3)
    207  537d		       00		      .byte.b	0	;G
    208  537e		       00		      .byte.b	0	;B
    209  537f		       00		      .byte.b	0	;R (2)
    210  5380		       40		      .byte.b	64	;G
    211  5381		       00		      .byte.b	0	;B
    212  5382		       00		      .byte.b	0	;R (1)
    213  5383		       00		      .byte.b	0	;G
    214  5384		       00		      .byte.b	0	;B
    215  5385		       00		      .byte.b	0	;R (0)
    216  5386		       00		      .byte.b	0	;G
    217  5387		       00		      .byte.b	0	;B
    218  5388				   COL_1
    219  5388		       80		      .byte.b	128	;R (71)
    220  5389		       80		      .byte.b	128	;G
    221  538a		       00		      .byte.b	0	;B
    222  538b		       10		      .byte.b	16	;R (70)
    223  538c		       14		      .byte.b	20	;G
    224  538d		       00		      .byte.b	0	;B
    225  538e		       00		      .byte.b	0	;R (69)
    226  538f		       41		      .byte.b	65	;G
    227  5390		       00		      .byte.b	0	;B
    228  5391		       00		      .byte.b	0	;R (68)
    229  5392		       08		      .byte.b	8	;G
    230  5393		       00		      .byte.b	0	;B
    231  5394		       20		      .byte.b	32	;R (67)
    232  5395		       20		      .byte.b	32	;G
    233  5396		       00		      .byte.b	0	;B
    234  5397		       63		      .byte.b	99	;R (66)
    235  5398		       6b		      .byte.b	107	;G
    236  5399		       00		      .byte.b	0	;B
    237  539a		       ff		      .byte.b	255	;R (65)
    238  539b		       f5		      .byte.b	245	;G
    239  539c		       00		      .byte.b	0	;B
    240  539d		       80		      .byte.b	128	;R (64)
    241  539e		       fb		      .byte.b	251	;G
    242  539f		       04		      .byte.b	4	;B
    243  53a0		       00		      .byte.b	0	;R (63)
    244  53a1		       b7		      .byte.b	183	;G
    245  53a2		       00		      .byte.b	0	;B
    246  53a3		       00		      .byte.b	0	;R (62)
    247  53a4		       b5		      .byte.b	181	;G
    248  53a5		       00		      .byte.b	0	;B
    249  53a6		       00		      .byte.b	0	;R (61)
    250  53a7		       ef		      .byte.b	239	;G
    251  53a8		       10		      .byte.b	16	;B
    252  53a9		       00		      .byte.b	0	;R (60)
    253  53aa		       bd		      .byte.b	189	;G
    254  53ab		       42		      .byte.b	66	;B
    255  53ac		       00		      .byte.b	0	;R (59)
    256  53ad		       77		      .byte.b	119	;G
    257  53ae		       00		      .byte.b	0	;B
    258  53af		       00		      .byte.b	0	;R (58)
    259  53b0		       ee		      .byte.b	238	;G
    260  53b1		       00		      .byte.b	0	;B
    261  53b2		       00		      .byte.b	0	;R (57)
    262  53b3		       9b		      .byte.b	155	;G
    263  53b4		       00		      .byte.b	0	;B
    264  53b5		       00		      .byte.b	0	;R (56)
    265  53b6		       f2		      .byte.b	242	;G
    266  53b7		       00		      .byte.b	0	;B
    267  53b8		       00		      .byte.b	0	;R (55)
    268  53b9		       40		      .byte.b	64	;G
    269  53ba		       00		      .byte.b	0	;B
    270  53bb		       00		      .byte.b	0	;R (54)
    271  53bc		       df		      .byte.b	223	;G
    272  53bd		       00		      .byte.b	0	;B
    273  53be		       10		      .byte.b	16	;R (53)
    274  53bf		       69		      .byte.b	105	;G
    275  53c0		       10		      .byte.b	16	;B
    276  53c1		       00		      .byte.b	0	;R (52)
    277  53c2		       4b		      .byte.b	75	;G
    278  53c3		       00		      .byte.b	0	;B
    279  53c4		       00		      .byte.b	0	;R (51)
    280  53c5		       b0		      .byte.b	176	;G
    281  53c6		       00		      .byte.b	0	;B
    282  53c7		       00		      .byte.b	0	;R (50)
    283  53c8		       a7		      .byte.b	167	;G
    284  53c9		       00		      .byte.b	0	;B
    285  53ca		       00		      .byte.b	0	;R (49)
    286  53cb		       7d		      .byte.b	125	;G
    287  53cc		       02		      .byte.b	2	;B
    288  53cd		       00		      .byte.b	0	;R (48)
    289  53ce		       db		      .byte.b	219	;G
    290  53cf		       20		      .byte.b	32	;B
    291  53d0		       00		      .byte.b	0	;R (47)
    292  53d1		       6d		      .byte.b	109	;G
    293  53d2		       00		      .byte.b	0	;B
    294  53d3		       00		      .byte.b	0	;R (46)
    295  53d4		       ea		      .byte.b	234	;G
    296  53d5		       00		      .byte.b	0	;B
    297  53d6		       00		      .byte.b	0	;R (45)
    298  53d7		       13		      .byte.b	19	;G
    299  53d8		       00		      .byte.b	0	;B
    300  53d9		       00		      .byte.b	0	;R (44)
    301  53da		       7e		      .byte.b	126	;G
    302  53db		       01		      .byte.b	1	;B
    303  53dc		       22		      .byte.b	34	;R (43)
    304  53dd		       77		      .byte.b	119	;G
    305  53de		       08		      .byte.b	8	;B
    306  53df		       04		      .byte.b	4	;R (42)
    307  53e0		       5f		      .byte.b	95	;G
    308  53e1		       00		      .byte.b	0	;B
    309  53e2		       00		      .byte.b	0	;R (41)
    310  53e3		       6f		      .byte.b	111	;G
    311  53e4		       00		      .byte.b	0	;B
    312  53e5		       00		      .byte.b	0	;R (40)
    313  53e6		       b5		      .byte.b	181	;G
    314  53e7		       00		      .byte.b	0	;B
    315  53e8		       00		      .byte.b	0	;R (39)
    316  53e9		       5b		      .byte.b	91	;G
    317  53ea		       00		      .byte.b	0	;B
    318  53eb		       00		      .byte.b	0	;R (38)
    319  53ec		       57		      .byte.b	87	;G
    320  53ed		       00		      .byte.b	0	;B
    321  53ee		       20		      .byte.b	32	;R (37)
    322  53ef		       4d		      .byte.b	77	;G
    323  53f0		       22		      .byte.b	34	;B
    324  53f1		       00		      .byte.b	0	;R (36)
    325  53f2		       55		      .byte.b	85	;G
    326  53f3		       00		      .byte.b	0	;B
    327  53f4		       01		      .byte.b	1	;R (35)
    328  53f5		       56		      .byte.b	86	;G
    329  53f6		       00		      .byte.b	0	;B
    330  53f7		       02		      .byte.b	2	;R (34)
    331  53f8		       57		      .byte.b	87	;G
    332  53f9		       00		      .byte.b	0	;B
    333  53fa		       00		      .byte.b	0	;R (33)
    334  53fb		       2a		      .byte.b	42	;G
    335  53fc		       01		      .byte.b	1	;B
    336  53fd		       01		      .byte.b	1	;R (32)
    337  53fe		       ab		      .byte.b	171	;G
    338  53ff		       00		      .byte.b	0	;B
    339  5400		       22		      .byte.b	34	;R (31)
    340  5401		       17		      .byte.b	23	;G
    341  5402		       20		      .byte.b	32	;B
    342  5403		       00		      .byte.b	0	;R (30)
    343  5404		       55		      .byte.b	85	;G
    344  5405		       02		      .byte.b	2	;B
    345  5406		       22		      .byte.b	34	;R (29)
    346  5407		       17		      .byte.b	23	;G
    347  5408		       20		      .byte.b	32	;B
    348  5409		       00		      .byte.b	0	;R (28)
    349  540a		       2b		      .byte.b	43	;G
    350  540b		       00		      .byte.b	0	;B
    351  540c		       00		      .byte.b	0	;R (27)
    352  540d		       95		      .byte.b	149	;G
    353  540e		       02		      .byte.b	2	;B
    354  540f		       00		      .byte.b	0	;R (26)
    355  5410		       17		      .byte.b	23	;G
    356  5411		       00		      .byte.b	0	;B
    357  5412		       00		      .byte.b	0	;R (25)
    358  5413		       2d		      .byte.b	45	;G
    359  5414		       00		      .byte.b	0	;B
    360  5415		       00		      .byte.b	0	;R (24)
    361  5416		       b4		      .byte.b	180	;G
    362  5417		       00		      .byte.b	0	;B
    363  5418		       00		      .byte.b	0	;R (23)
    364  5419		       0a		      .byte.b	10	;G
    365  541a		       00		      .byte.b	0	;B
    366  541b		       10		      .byte.b	16	;R (22)
    367  541c		       3c		      .byte.b	60	;G
    368  541d		       00		      .byte.b	0	;B
    369  541e		       10		      .byte.b	16	;R (21)
    370  541f		       98		      .byte.b	152	;G
    371  5420		       00		      .byte.b	0	;B
    372  5421		       10		      .byte.b	16	;R (20)
    373  5422		       1a		      .byte.b	26	;G
    374  5423		       00		      .byte.b	0	;B
    375  5424		       00		      .byte.b	0	;R (19)
    376  5425		       14		      .byte.b	20	;G
    377  5426		       00		      .byte.b	0	;B
    378  5427		       00		      .byte.b	0	;R (18)
    379  5428		       5a		      .byte.b	90	;G
    380  5429		       00		      .byte.b	0	;B
    381  542a		       00		      .byte.b	0	;R (17)
    382  542b		       09		      .byte.b	9	;G
    383  542c		       00		      .byte.b	0	;B
    384  542d		       08		      .byte.b	8	;R (16)
    385  542e		       1d		      .byte.b	29	;G
    386  542f		       00		      .byte.b	0	;B
    387  5430		       00		      .byte.b	0	;R (15)
    388  5431		       1a		      .byte.b	26	;G
    389  5432		       00		      .byte.b	0	;B
    390  5433		       20		      .byte.b	32	;R (14)
    391  5434		       ba		      .byte.b	186	;G
    392  5435		       00		      .byte.b	0	;B
    393  5436		       00		      .byte.b	0	;R (13)
    394  5437		       12		      .byte.b	18	;G
    395  5438		       00		      .byte.b	0	;B
    396  5439		       00		      .byte.b	0	;R (12)
    397  543a		       1a		      .byte.b	26	;G
    398  543b		       00		      .byte.b	0	;B
    399  543c		       00		      .byte.b	0	;R (11)
    400  543d		       2d		      .byte.b	45	;G
    401  543e		       10		      .byte.b	16	;B
    402  543f		       10		      .byte.b	16	;R (10)
    403  5440		       3b		      .byte.b	59	;G
    404  5441		       00		      .byte.b	0	;B
    405  5442		       24		      .byte.b	36	;R (9)
    406  5443		       39		      .byte.b	57	;G
    407  5444		       04		      .byte.b	4	;B
    408  5445		       20		      .byte.b	32	;R (8)
    409  5446		       35		      .byte.b	53	;G
    410  5447		       00		      .byte.b	0	;B
    411  5448		       00		      .byte.b	0	;R (7)
    412  5449		       3d		      .byte.b	61	;G
    413  544a		       00		      .byte.b	0	;B
    414  544b		       00		      .byte.b	0	;R (6)
    415  544c		       32		      .byte.b	50	;G
    416  544d		       00		      .byte.b	0	;B
    417  544e		       00		      .byte.b	0	;R (5)
    418  544f		       98		      .byte.b	152	;G
    419  5450		       00		      .byte.b	0	;B
    420  5451		       00		      .byte.b	0	;R (4)
    421  5452		       12		      .byte.b	18	;G
    422  5453		       00		      .byte.b	0	;B
    423  5454		       00		      .byte.b	0	;R (3)
    424  5455		       20		      .byte.b	32	;G
    425  5456		       00		      .byte.b	0	;B
    426  5457		       01		      .byte.b	1	;R (2)
    427  5458		       49		      .byte.b	73	;G
    428  5459		       00		      .byte.b	0	;B
    429  545a		       20		      .byte.b	32	;R (1)
    430  545b		       20		      .byte.b	32	;G
    431  545c		       00		      .byte.b	0	;B
    432  545d		       00		      .byte.b	0	;R (0)
    433  545e		       00		      .byte.b	0	;G
    434  545f		       00		      .byte.b	0	;B
    435  5460				   COL_2
    436  5460		       14		      .byte.b	20	;R (71)
    437  5461		       14		      .byte.b	20	;G
    438  5462		       00		      .byte.b	0	;B
    439  5463		       40		      .byte.b	64	;R (70)
    440  5464		       42		      .byte.b	66	;G
    441  5465		       00		      .byte.b	0	;B
    442  5466		       a8		      .byte.b	168	;R (69)
    443  5467		       a8		      .byte.b	168	;G
    444  5468		       00		      .byte.b	0	;B
    445  5469		       fd		      .byte.b	253	;R (68)
    446  546a		       1d		      .byte.b	29	;G
    447  546b		       00		      .byte.b	0	;B
    448  546c		       f0		      .byte.b	240	;R (67)
    449  546d		       44		      .byte.b	68	;G
    450  546e		       08		      .byte.b	8	;B
    451  546f		       ff		      .byte.b	255	;R (66)
    452  5470		       2f		      .byte.b	47	;G
    453  5471		       00		      .byte.b	0	;B
    454  5472		       ff		      .byte.b	255	;R (65)
    455  5473		       0e		      .byte.b	14	;G
    456  5474		       00		      .byte.b	0	;B
    457  5475		       f8		      .byte.b	248	;R (64)
    458  5476		       0f		      .byte.b	15	;G
    459  5477		       00		      .byte.b	0	;B
    460  5478		       f8		      .byte.b	248	;R (63)
    461  5479		       2e		      .byte.b	46	;G
    462  547a		       00		      .byte.b	0	;B
    463  547b		       f8		      .byte.b	248	;R (62)
    464  547c		       1e		      .byte.b	30	;G
    465  547d		       01		      .byte.b	1	;B
    466  547e		       74		      .byte.b	116	;R (61)
    467  547f		       23		      .byte.b	35	;G
    468  5480		       88		      .byte.b	136	;B
    469  5481		       fc		      .byte.b	252	;R (60)
    470  5482		       0f		      .byte.b	15	;G
    471  5483		       00		      .byte.b	0	;B
    472  5484		       f8		      .byte.b	248	;R (59)
    473  5485		       06		      .byte.b	6	;G
    474  5486		       01		      .byte.b	1	;B
    475  5487		       f8		      .byte.b	248	;R (58)
    476  5488		       8f		      .byte.b	143	;G
    477  5489		       00		      .byte.b	0	;B
    478  548a		       e8		      .byte.b	232	;R (57)
    479  548b		       0e		      .byte.b	14	;G
    480  548c		       10		      .byte.b	16	;B
    481  548d		       e0		      .byte.b	224	;R (56)
    482  548e		       97		      .byte.b	151	;G
    483  548f		       00		      .byte.b	0	;B
    484  5490		       f0		      .byte.b	240	;R (55)
    485  5491		       3a		      .byte.b	58	;G
    486  5492		       00		      .byte.b	0	;B
    487  5493		       e0		      .byte.b	224	;R (54)
    488  5494		       bb		      .byte.b	187	;G
    489  5495		       04		      .byte.b	4	;B
    490  5496		       e0		      .byte.b	224	;R (53)
    491  5497		       3e		      .byte.b	62	;G
    492  5498		       00		      .byte.b	0	;B
    493  5499		       c0		      .byte.b	192	;R (52)
    494  549a		       2a		      .byte.b	42	;G
    495  549b		       00		      .byte.b	0	;B
    496  549c		       80		      .byte.b	128	;R (51)
    497  549d		       3f		      .byte.b	63	;G
    498  549e		       40		      .byte.b	64	;B
    499  549f		       f5		      .byte.b	245	;R (50)
    500  54a0		       3f		      .byte.b	63	;G
    501  54a1		       00		      .byte.b	0	;B
    502  54a2		       e8		      .byte.b	232	;R (49)
    503  54a3		       7f		      .byte.b	127	;G
    504  54a4		       00		      .byte.b	0	;B
    505  54a5		       e0		      .byte.b	224	;R (48)
    506  54a6		       7a		      .byte.b	122	;G
    507  54a7		       04		      .byte.b	4	;B
    508  54a8		       c0		      .byte.b	192	;R (47)
    509  54a9		       5f		      .byte.b	95	;G
    510  54aa		       00		      .byte.b	0	;B
    511  54ab		       90		      .byte.b	144	;R (46)
    512  54ac		       dd		      .byte.b	221	;G
    513  54ad		       02		      .byte.b	2	;B
    514  54ae		       84		      .byte.b	132	;R (45)
    515  54af		       9f		      .byte.b	159	;G
    516  54b0		       00		      .byte.b	0	;B
    517  54b1		       c4		      .byte.b	196	;R (44)
    518  54b2		       cf		      .byte.b	207	;G
    519  54b3		       00		      .byte.b	0	;B
    520  54b4		       c5		      .byte.b	197	;R (43)
    521  54b5		       1f		      .byte.b	31	;G
    522  54b6		       00		      .byte.b	0	;B
    523  54b7		       d4		      .byte.b	212	;R (42)
    524  54b8		       9f		      .byte.b	159	;G
    525  54b9		       20		      .byte.b	32	;B
    526  54ba		       c8		      .byte.b	200	;R (41)
    527  54bb		       1e		      .byte.b	30	;G
    528  54bc		       01		      .byte.b	1	;B
    529  54bd		       c8		      .byte.b	200	;R (40)
    530  54be		       5f		      .byte.b	95	;G
    531  54bf		       00		      .byte.b	0	;B
    532  54c0		       cd		      .byte.b	205	;R (39)
    533  54c1		       5e		      .byte.b	94	;G
    534  54c2		       00		      .byte.b	0	;B
    535  54c3		       c7		      .byte.b	199	;R (38)
    536  54c4		       5b		      .byte.b	91	;G
    537  54c5		       00		      .byte.b	0	;B
    538  54c6		       8b		      .byte.b	139	;R (37)
    539  54c7		       1c		      .byte.b	28	;G
    540  54c8		       00		      .byte.b	0	;B
    541  54c9		       81		      .byte.b	129	;R (36)
    542  54ca		       9a		      .byte.b	154	;G
    543  54cb		       04		      .byte.b	4	;B
    544  54cc		       8e		      .byte.b	142	;R (35)
    545  54cd		       9d		      .byte.b	157	;G
    546  54ce		       00		      .byte.b	0	;B
    547  54cf		       2b		      .byte.b	43	;R (34)
    548  54d0		       36		      .byte.b	54	;G
    549  54d1		       00		      .byte.b	0	;B
    550  54d2		       3a		      .byte.b	58	;R (33)
    551  54d3		       0d		      .byte.b	13	;G
    552  54d4		       00		      .byte.b	0	;B
    553  54d5		       3e		      .byte.b	62	;R (32)
    554  54d6		       85		      .byte.b	133	;G
    555  54d7		       40		      .byte.b	64	;B
    556  54d8		       fa		      .byte.b	250	;R (31)
    557  54d9		       17		      .byte.b	23	;G
    558  54da		       00		      .byte.b	0	;B
    559  54db		       ff		      .byte.b	255	;R (30)
    560  54dc		       03		      .byte.b	3	;G
    561  54dd		       00		      .byte.b	0	;B
    562  54de		       fc		      .byte.b	252	;R (29)
    563  54df		       93		      .byte.b	147	;G
    564  54e0		       00		      .byte.b	0	;B
    565  54e1		       f7		      .byte.b	247	;R (28)
    566  54e2		       81		      .byte.b	129	;G
    567  54e3		       08		      .byte.b	8	;B
    568  54e4		       ff		      .byte.b	255	;R (27)
    569  54e5		       03		      .byte.b	3	;G
    570  54e6		       00		      .byte.b	0	;B
    571  54e7		       fe		      .byte.b	254	;R (26)
    572  54e8		       2b		      .byte.b	43	;G
    573  54e9		       00		      .byte.b	0	;B
    574  54ea		       fe		      .byte.b	254	;R (25)
    575  54eb		       0a		      .byte.b	10	;G
    576  54ec		       00		      .byte.b	0	;B
    577  54ed		       fc		      .byte.b	252	;R (24)
    578  54ee		       4f		      .byte.b	79	;G
    579  54ef		       00		      .byte.b	0	;B
    580  54f0		       fc		      .byte.b	252	;R (23)
    581  54f1		       55		      .byte.b	85	;G
    582  54f2		       00		      .byte.b	0	;B
    583  54f3		       f8		      .byte.b	248	;R (22)
    584  54f4		       45		      .byte.b	69	;G
    585  54f5		       00		      .byte.b	0	;B
    586  54f6		       e8		      .byte.b	232	;R (21)
    587  54f7		       05		      .byte.b	5	;G
    588  54f8		       10		      .byte.b	16	;B
    589  54f9		       f8		      .byte.b	248	;R (20)
    590  54fa		       5b		      .byte.b	91	;G
    591  54fb		       00		      .byte.b	0	;B
    592  54fc		       f8		      .byte.b	248	;R (19)
    593  54fd		       1d		      .byte.b	29	;G
    594  54fe		       00		      .byte.b	0	;B
    595  54ff		       f0		      .byte.b	240	;R (18)
    596  5500		       55		      .byte.b	85	;G
    597  5501		       00		      .byte.b	0	;B
    598  5502		       f0		      .byte.b	240	;R (17)
    599  5503		       16		      .byte.b	22	;G
    600  5504		       00		      .byte.b	0	;B
    601  5505		       f0		      .byte.b	240	;R (16)
    602  5506		       b2		      .byte.b	178	;G
    603  5507		       00		      .byte.b	0	;B
    604  5508		       e0		      .byte.b	224	;R (15)
    605  5509		       0e		      .byte.b	14	;G
    606  550a		       10		      .byte.b	16	;B
    607  550b		       f0		      .byte.b	240	;R (14)
    608  550c		       93		      .byte.b	147	;G
    609  550d		       00		      .byte.b	0	;B
    610  550e		       e0		      .byte.b	224	;R (13)
    611  550f		       25		      .byte.b	37	;G
    612  5510		       00		      .byte.b	0	;B
    613  5511		       c0		      .byte.b	192	;R (12)
    614  5512		       e5		      .byte.b	229	;G
    615  5513		       00		      .byte.b	0	;B
    616  5514		       80		      .byte.b	128	;R (11)
    617  5515		       0e		      .byte.b	14	;G
    618  5516		       00		      .byte.b	0	;B
    619  5517		       c0		      .byte.b	192	;R (10)
    620  5518		       ca		      .byte.b	202	;G
    621  5519		       00		      .byte.b	0	;B
    622  551a		       84		      .byte.b	132	;R (9)
    623  551b		       8e		      .byte.b	142	;G
    624  551c		       00		      .byte.b	0	;B
    625  551d		       00		      .byte.b	0	;R (8)
    626  551e		       8e		      .byte.b	142	;G
    627  551f		       00		      .byte.b	0	;B
    628  5520		       00		      .byte.b	0	;R (7)
    629  5521		       15		      .byte.b	21	;G
    630  5522		       00		      .byte.b	0	;B
    631  5523		       00		      .byte.b	0	;R (6)
    632  5524		       14		      .byte.b	20	;G
    633  5525		       00		      .byte.b	0	;B
    634  5526		       00		      .byte.b	0	;R (5)
    635  5527		       14		      .byte.b	20	;G
    636  5528		       00		      .byte.b	0	;B
    637  5529		       00		      .byte.b	0	;R (4)
    638  552a		       0a		      .byte.b	10	;G
    639  552b		       00		      .byte.b	0	;B
    640  552c		       00		      .byte.b	0	;R (3)
    641  552d		       10		      .byte.b	16	;G
    642  552e		       00		      .byte.b	0	;B
    643  552f		       08		      .byte.b	8	;R (2)
    644  5530		       88		      .byte.b	136	;G
    645  5531		       00		      .byte.b	0	;B
    646  5532		       40		      .byte.b	64	;R (1)
    647  5533		       42		      .byte.b	66	;G
    648  5534		       00		      .byte.b	0	;B
    649  5535		       00		      .byte.b	0	;R (0)
    650  5536		       00		      .byte.b	0	;G
    651  5537		       00		      .byte.b	0	;B
    652  5538				   COL_3
    653  5538		       90		      .byte.b	144	;R (71)
    654  5539		       90		      .byte.b	144	;G
    655  553a		       00		      .byte.b	0	;B
    656  553b		       40		      .byte.b	64	;R (70)
    657  553c		       40		      .byte.b	64	;G
    658  553d		       00		      .byte.b	0	;B
    659  553e		       b0		      .byte.b	176	;R (69)
    660  553f		       b0		      .byte.b	176	;G
    661  5540		       00		      .byte.b	0	;B
    662  5541		       d0		      .byte.b	208	;R (68)
    663  5542		       00		      .byte.b	0	;G
    664  5543		       20		      .byte.b	32	;B
    665  5544		       f0		      .byte.b	240	;R (67)
    666  5545		       00		      .byte.b	0	;G
    667  5546		       00		      .byte.b	0	;B
    668  5547		       f0		      .byte.b	240	;R (66)
    669  5548		       d0		      .byte.b	208	;G
    670  5549		       00		      .byte.b	0	;B
    671  554a		       f0		      .byte.b	240	;R (65)
    672  554b		       00		      .byte.b	0	;G
    673  554c		       00		      .byte.b	0	;B
    674  554d		       f0		      .byte.b	240	;R (64)
    675  554e		       00		      .byte.b	0	;G
    676  554f		       00		      .byte.b	0	;B
    677  5550		       f0		      .byte.b	240	;R (63)
    678  5551		       50		      .byte.b	80	;G
    679  5552		       00		      .byte.b	0	;B
    680  5553		       f0		      .byte.b	240	;R (62)
    681  5554		       00		      .byte.b	0	;G
    682  5555		       00		      .byte.b	0	;B
    683  5556		       f0		      .byte.b	240	;R (61)
    684  5557		       a0		      .byte.b	160	;G
    685  5558		       00		      .byte.b	0	;B
    686  5559		       f0		      .byte.b	240	;R (60)
    687  555a		       00		      .byte.b	0	;G
    688  555b		       00		      .byte.b	0	;B
    689  555c		       f0		      .byte.b	240	;R (59)
    690  555d		       d0		      .byte.b	208	;G
    691  555e		       00		      .byte.b	0	;B
    692  555f		       f0		      .byte.b	240	;R (58)
    693  5560		       c0		      .byte.b	192	;G
    694  5561		       00		      .byte.b	0	;B
    695  5562		       f0		      .byte.b	240	;R (57)
    696  5563		       90		      .byte.b	144	;G
    697  5564		       00		      .byte.b	0	;B
    698  5565		       f0		      .byte.b	240	;R (56)
    699  5566		       80		      .byte.b	128	;G
    700  5567		       00		      .byte.b	0	;B
    701  5568		       f0		      .byte.b	240	;R (55)
    702  5569		       40		      .byte.b	64	;G
    703  556a		       00		      .byte.b	0	;B
    704  556b		       70		      .byte.b	112	;R (54)
    705  556c		       00		      .byte.b	0	;G
    706  556d		       80		      .byte.b	128	;B
    707  556e		       d0		      .byte.b	208	;R (53)
    708  556f		       00		      .byte.b	0	;G
    709  5570		       20		      .byte.b	32	;B
    710  5571		       f0		      .byte.b	240	;R (52)
    711  5572		       80		      .byte.b	128	;G
    712  5573		       00		      .byte.b	0	;B
    713  5574		       f0		      .byte.b	240	;R (51)
    714  5575		       00		      .byte.b	0	;G
    715  5576		       00		      .byte.b	0	;B
    716  5577		       f0		      .byte.b	240	;R (50)
    717  5578		       a0		      .byte.b	160	;G
    718  5579		       00		      .byte.b	0	;B
    719  557a		       f0		      .byte.b	240	;R (49)
    720  557b		       80		      .byte.b	128	;G
    721  557c		       00		      .byte.b	0	;B
    722  557d		       f0		      .byte.b	240	;R (48)
    723  557e		       40		      .byte.b	64	;G
    724  557f		       00		      .byte.b	0	;B
    725  5580		       f0		      .byte.b	240	;R (47)
    726  5581		       20		      .byte.b	32	;G
    727  5582		       00		      .byte.b	0	;B
    728  5583		       f0		      .byte.b	240	;R (46)
    729  5584		       00		      .byte.b	0	;G
    730  5585		       00		      .byte.b	0	;B
    731  5586		       f0		      .byte.b	240	;R (45)
    732  5587		       80		      .byte.b	128	;G
    733  5588		       00		      .byte.b	0	;B
    734  5589		       f0		      .byte.b	240	;R (44)
    735  558a		       00		      .byte.b	0	;G
    736  558b		       00		      .byte.b	0	;B
    737  558c		       f0		      .byte.b	240	;R (43)
    738  558d		       40		      .byte.b	64	;G
    739  558e		       00		      .byte.b	0	;B
    740  558f		       f0		      .byte.b	240	;R (42)
    741  5590		       00		      .byte.b	0	;G
    742  5591		       00		      .byte.b	0	;B
    743  5592		       f0		      .byte.b	240	;R (41)
    744  5593		       20		      .byte.b	32	;G
    745  5594		       00		      .byte.b	0	;B
    746  5595		       f0		      .byte.b	240	;R (40)
    747  5596		       20		      .byte.b	32	;G
    748  5597		       00		      .byte.b	0	;B
    749  5598		       f0		      .byte.b	240	;R (39)
    750  5599		       50		      .byte.b	80	;G
    751  559a		       00		      .byte.b	0	;B
    752  559b		       f0		      .byte.b	240	;R (38)
    753  559c		       10		      .byte.b	16	;G
    754  559d		       00		      .byte.b	0	;B
    755  559e		       70		      .byte.b	112	;R (37)
    756  559f		       80		      .byte.b	128	;G
    757  55a0		       80		      .byte.b	128	;B
    758  55a1		       f0		      .byte.b	240	;R (36)
    759  55a2		       50		      .byte.b	80	;G
    760  55a3		       00		      .byte.b	0	;B
    761  55a4		       f0		      .byte.b	240	;R (35)
    762  55a5		       00		      .byte.b	0	;G
    763  55a6		       00		      .byte.b	0	;B
    764  55a7		       f0		      .byte.b	240	;R (34)
    765  55a8		       40		      .byte.b	64	;G
    766  55a9		       00		      .byte.b	0	;B
    767  55aa		       f0		      .byte.b	240	;R (33)
    768  55ab		       10		      .byte.b	16	;G
    769  55ac		       00		      .byte.b	0	;B
    770  55ad		       f0		      .byte.b	240	;R (32)
    771  55ae		       b0		      .byte.b	176	;G
    772  55af		       00		      .byte.b	0	;B
    773  55b0		       e0		      .byte.b	224	;R (31)
    774  55b1		       00		      .byte.b	0	;G
    775  55b2		       10		      .byte.b	16	;B
    776  55b3		       e0		      .byte.b	224	;R (30)
    777  55b4		       40		      .byte.b	64	;G
    778  55b5		       00		      .byte.b	0	;B
    779  55b6		       e0		      .byte.b	224	;R (29)
    780  55b7		       20		      .byte.b	32	;G
    781  55b8		       00		      .byte.b	0	;B
    782  55b9		       c0		      .byte.b	192	;R (28)
    783  55ba		       00		      .byte.b	0	;G
    784  55bb		       00		      .byte.b	0	;B
    785  55bc		       c0		      .byte.b	192	;R (27)
    786  55bd		       10		      .byte.b	16	;G
    787  55be		       00		      .byte.b	0	;B
    788  55bf		       c0		      .byte.b	192	;R (26)
    789  55c0		       40		      .byte.b	64	;G
    790  55c1		       10		      .byte.b	16	;B
    791  55c2		       90		      .byte.b	144	;R (25)
    792  55c3		       00		      .byte.b	0	;G
    793  55c4		       00		      .byte.b	0	;B
    794  55c5		       f0		      .byte.b	240	;R (24)
    795  55c6		       60		      .byte.b	96	;G
    796  55c7		       00		      .byte.b	0	;B
    797  55c8		       f0		      .byte.b	240	;R (23)
    798  55c9		       00		      .byte.b	0	;G
    799  55ca		       00		      .byte.b	0	;B
    800  55cb		       f0		      .byte.b	240	;R (22)
    801  55cc		       40		      .byte.b	64	;G
    802  55cd		       00		      .byte.b	0	;B
    803  55ce		       f0		      .byte.b	240	;R (21)
    804  55cf		       10		      .byte.b	16	;G
    805  55d0		       00		      .byte.b	0	;B
    806  55d1		       f0		      .byte.b	240	;R (20)
    807  55d2		       00		      .byte.b	0	;G
    808  55d3		       00		      .byte.b	0	;B
    809  55d4		       f0		      .byte.b	240	;R (19)
    810  55d5		       60		      .byte.b	96	;G
    811  55d6		       00		      .byte.b	0	;B
    812  55d7		       f0		      .byte.b	240	;R (18)
    813  55d8		       20		      .byte.b	32	;G
    814  55d9		       00		      .byte.b	0	;B
    815  55da		       f0		      .byte.b	240	;R (17)
    816  55db		       50		      .byte.b	80	;G
    817  55dc		       00		      .byte.b	0	;B
    818  55dd		       f0		      .byte.b	240	;R (16)
    819  55de		       40		      .byte.b	64	;G
    820  55df		       00		      .byte.b	0	;B
    821  55e0		       f0		      .byte.b	240	;R (15)
    822  55e1		       80		      .byte.b	128	;G
    823  55e2		       00		      .byte.b	0	;B
    824  55e3		       f0		      .byte.b	240	;R (14)
    825  55e4		       40		      .byte.b	64	;G
    826  55e5		       00		      .byte.b	0	;B
    827  55e6		       f0		      .byte.b	240	;R (13)
    828  55e7		       00		      .byte.b	0	;G
    829  55e8		       00		      .byte.b	0	;B
    830  55e9		       f0		      .byte.b	240	;R (12)
    831  55ea		       10		      .byte.b	16	;G
    832  55eb		       00		      .byte.b	0	;B
    833  55ec		       f0		      .byte.b	240	;R (11)
    834  55ed		       50		      .byte.b	80	;G
    835  55ee		       00		      .byte.b	0	;B
    836  55ef		       f0		      .byte.b	240	;R (10)
    837  55f0		       00		      .byte.b	0	;G
    838  55f1		       00		      .byte.b	0	;B
    839  55f2		       f0		      .byte.b	240	;R (9)
    840  55f3		       b0		      .byte.b	176	;G
    841  55f4		       00		      .byte.b	0	;B
    842  55f5		       f0		      .byte.b	240	;R (8)
    843  55f6		       90		      .byte.b	144	;G
    844  55f7		       00		      .byte.b	0	;B
    845  55f8		       e0		      .byte.b	224	;R (7)
    846  55f9		       e0		      .byte.b	224	;G
    847  55fa		       00		      .byte.b	0	;B
    848  55fb		       f0		      .byte.b	240	;R (6)
    849  55fc		       d0		      .byte.b	208	;G
    850  55fd		       00		      .byte.b	0	;B
    851  55fe		       60		      .byte.b	96	;R (5)
    852  55ff		       00		      .byte.b	0	;G
    853  5600		       00		      .byte.b	0	;B
    854  5601		       60		      .byte.b	96	;R (4)
    855  5602		       40		      .byte.b	64	;G
    856  5603		       00		      .byte.b	0	;B
    857  5604		       40		      .byte.b	64	;R (3)
    858  5605		       50		      .byte.b	80	;G
    859  5606		       00		      .byte.b	0	;B
    860  5607		       00		      .byte.b	0	;R (2)
    861  5608		       00		      .byte.b	0	;G
    862  5609		       00		      .byte.b	0	;B
    863  560a		       00		      .byte.b	0	;R (1)
    864  560b		       80		      .byte.b	128	;G
    865  560c		       00		      .byte.b	0	;B
    866  560d		       00		      .byte.b	0	;R (0)
    867  560e		       00		      .byte.b	0	;G
    868  560f		       00		      .byte.b	0	;B
    869  5610				   COL_4
    870  5610		       25		      .byte.b	37	;R (71)
    871  5611		       25		      .byte.b	37	;G
    872  5612		       00		      .byte.b	0	;B
    873  5613		       48		      .byte.b	72	;R (70)
    874  5614		       48		      .byte.b	72	;G
    875  5615		       00		      .byte.b	0	;B
    876  5616		       25		      .byte.b	37	;R (69)
    877  5617		       25		      .byte.b	37	;G
    878  5618		       88		      .byte.b	136	;B
    879  5619		       ff		      .byte.b	255	;R (68)
    880  561a		       00		      .byte.b	0	;G
    881  561b		       00		      .byte.b	0	;B
    882  561c		       ff		      .byte.b	255	;R (67)
    883  561d		       04		      .byte.b	4	;G
    884  561e		       00		      .byte.b	0	;B
    885  561f		       ef		      .byte.b	239	;R (66)
    886  5620		       40		      .byte.b	64	;G
    887  5621		       10		      .byte.b	16	;B
    888  5622		       ff		      .byte.b	255	;R (65)
    889  5623		       00		      .byte.b	0	;G
    890  5624		       00		      .byte.b	0	;B
    891  5625		       ff		      .byte.b	255	;R (64)
    892  5626		       02		      .byte.b	2	;G
    893  5627		       00		      .byte.b	0	;B
    894  5628		       ff		      .byte.b	255	;R (63)
    895  5629		       20		      .byte.b	32	;G
    896  562a		       00		      .byte.b	0	;B
    897  562b		       ff		      .byte.b	255	;R (62)
    898  562c		       a5		      .byte.b	165	;G
    899  562d		       00		      .byte.b	0	;B
    900  562e		       ff		      .byte.b	255	;R (61)
    901  562f		       09		      .byte.b	9	;G
    902  5630		       00		      .byte.b	0	;B
    903  5631		       ff		      .byte.b	255	;R (60)
    904  5632		       00		      .byte.b	0	;G
    905  5633		       00		      .byte.b	0	;B
    906  5634		       7f		      .byte.b	127	;R (59)
    907  5635		       42		      .byte.b	66	;G
    908  5636		       80		      .byte.b	128	;B
    909  5637		       ff		      .byte.b	255	;R (58)
    910  5638		       88		      .byte.b	136	;G
    911  5639		       00		      .byte.b	0	;B
    912  563a		       ff		      .byte.b	255	;R (57)
    913  563b		       40		      .byte.b	64	;G
    914  563c		       00		      .byte.b	0	;B
    915  563d		       ff		      .byte.b	255	;R (56)
    916  563e		       09		      .byte.b	9	;G
    917  563f		       00		      .byte.b	0	;B
    918  5640		       7f		      .byte.b	127	;R (55)
    919  5641		       01		      .byte.b	1	;G
    920  5642		       80		      .byte.b	128	;B
    921  5643		       ff		      .byte.b	255	;R (54)
    922  5644		       91		      .byte.b	145	;G
    923  5645		       00		      .byte.b	0	;B
    924  5646		       fe		      .byte.b	254	;R (53)
    925  5647		       81		      .byte.b	129	;G
    926  5648		       00		      .byte.b	0	;B
    927  5649		       fe		      .byte.b	254	;R (52)
    928  564a		       20		      .byte.b	32	;G
    929  564b		       00		      .byte.b	0	;B
    930  564c		       ff		      .byte.b	255	;R (51)
    931  564d		       03		      .byte.b	3	;G
    932  564e		       00		      .byte.b	0	;B
    933  564f		       ff		      .byte.b	255	;R (50)
    934  5650		       83		      .byte.b	131	;G
    935  5651		       00		      .byte.b	0	;B
    936  5652		       fe		      .byte.b	254	;R (49)
    937  5653		       90		      .byte.b	144	;G
    938  5654		       00		      .byte.b	0	;B
    939  5655		       fe		      .byte.b	254	;R (48)
    940  5656		       83		      .byte.b	131	;G
    941  5657		       00		      .byte.b	0	;B
    942  5658		       7e		      .byte.b	126	;R (47)
    943  5659		       12		      .byte.b	18	;G
    944  565a		       80		      .byte.b	128	;B
    945  565b		       fc		      .byte.b	252	;R (46)
    946  565c		       00		      .byte.b	0	;G
    947  565d		       00		      .byte.b	0	;B
    948  565e		       fe		      .byte.b	254	;R (45)
    949  565f		       07		      .byte.b	7	;G
    950  5660		       00		      .byte.b	0	;B
    951  5661		       ef		      .byte.b	239	;R (44)
    952  5662		       03		      .byte.b	3	;G
    953  5663		       10		      .byte.b	16	;B
    954  5664		       ff		      .byte.b	255	;R (43)
    955  5665		       40		      .byte.b	64	;G
    956  5666		       00		      .byte.b	0	;B
    957  5667		       ff		      .byte.b	255	;R (42)
    958  5668		       01		      .byte.b	1	;G
    959  5669		       00		      .byte.b	0	;B
    960  566a		       ff		      .byte.b	255	;R (41)
    961  566b		       01		      .byte.b	1	;G
    962  566c		       00		      .byte.b	0	;B
    963  566d		       bf		      .byte.b	191	;R (40)
    964  566e		       01		      .byte.b	1	;G
    965  566f		       40		      .byte.b	64	;B
    966  5670		       f7		      .byte.b	247	;R (39)
    967  5671		       80		      .byte.b	128	;G
    968  5672		       08		      .byte.b	8	;B
    969  5673		       ff		      .byte.b	255	;R (38)
    970  5674		       40		      .byte.b	64	;G
    971  5675		       00		      .byte.b	0	;B
    972  5676		       ff		      .byte.b	255	;R (37)
    973  5677		       00		      .byte.b	0	;G
    974  5678		       00		      .byte.b	0	;B
    975  5679		       ff		      .byte.b	255	;R (36)
    976  567a		       40		      .byte.b	64	;G
    977  567b		       00		      .byte.b	0	;B
    978  567c		       ff		      .byte.b	255	;R (35)
    979  567d		       a1		      .byte.b	161	;G
    980  567e		       00		      .byte.b	0	;B
    981  567f		       7f		      .byte.b	127	;R (34)
    982  5680		       05		      .byte.b	5	;G
    983  5681		       80		      .byte.b	128	;B
    984  5682		       ff		      .byte.b	255	;R (33)
    985  5683		       21		      .byte.b	33	;G
    986  5684		       00		      .byte.b	0	;B
    987  5685		       bf		      .byte.b	191	;R (32)
    988  5686		       40		      .byte.b	64	;G
    989  5687		       40		      .byte.b	64	;B
    990  5688		       ff		      .byte.b	255	;R (31)
    991  5689		       61		      .byte.b	97	;G
    992  568a		       00		      .byte.b	0	;B
    993  568b		       7f		      .byte.b	127	;R (30)
    994  568c		       81		      .byte.b	129	;G
    995  568d		       80		      .byte.b	128	;B
    996  568e		       f7		      .byte.b	247	;R (29)
    997  568f		       60		      .byte.b	96	;G
    998  5690		       08		      .byte.b	8	;B
    999  5691		       ff		      .byte.b	255	;R (28)
   1000  5692		       81		      .byte.b	129	;G
   1001  5693		       00		      .byte.b	0	;B
   1002  5694		       ef		      .byte.b	239	;R (27)
   1003  5695		       40		      .byte.b	64	;G
   1004  5696		       10		      .byte.b	16	;B
   1005  5697		       ff		      .byte.b	255	;R (26)
   1006  5698		       60		      .byte.b	96	;G
   1007  5699		       00		      .byte.b	0	;B
   1008  569a		       ff		      .byte.b	255	;R (25)
   1009  569b		       18		      .byte.b	24	;G
   1010  569c		       00		      .byte.b	0	;B
   1011  569d		       ff		      .byte.b	255	;R (24)
   1012  569e		       20		      .byte.b	32	;G
   1013  569f		       00		      .byte.b	0	;B
   1014  56a0		       ff		      .byte.b	255	;R (23)
   1015  56a1		       8a		      .byte.b	138	;G
   1016  56a2		       00		      .byte.b	0	;B
   1017  56a3		       f7		      .byte.b	247	;R (22)
   1018  56a4		       10		      .byte.b	16	;G
   1019  56a5		       08		      .byte.b	8	;B
   1020  56a6		       ff		      .byte.b	255	;R (21)
   1021  56a7		       04		      .byte.b	4	;G
   1022  56a8		       00		      .byte.b	0	;B
   1023  56a9		       df		      .byte.b	223	;R (20)
   1024  56aa		       10		      .byte.b	16	;G
   1025  56ab		       20		      .byte.b	32	;B
   1026  56ac		       ff		      .byte.b	255	;R (19)
   1027  56ad		       90		      .byte.b	144	;G
   1028  56ae		       00		      .byte.b	0	;B
   1029  56af		       ff		      .byte.b	255	;R (18)
   1030  56b0		       12		      .byte.b	18	;G
   1031  56b1		       00		      .byte.b	0	;B
   1032  56b2		       ff		      .byte.b	255	;R (17)
   1033  56b3		       00		      .byte.b	0	;G
   1034  56b4		       00		      .byte.b	0	;B
   1035  56b5		       ff		      .byte.b	255	;R (16)
   1036  56b6		       45		      .byte.b	69	;G
   1037  56b7		       00		      .byte.b	0	;B
   1038  56b8		       ff		      .byte.b	255	;R (15)
   1039  56b9		       10		      .byte.b	16	;G
   1040  56ba		       00		      .byte.b	0	;B
   1041  56bb		       ff		      .byte.b	255	;R (14)
   1042  56bc		       23		      .byte.b	35	;G
   1043  56bd		       00		      .byte.b	0	;B
   1044  56be		       fc		      .byte.b	252	;R (13)
   1045  56bf		       12		      .byte.b	18	;G
   1046  56c0		       00		      .byte.b	0	;B
   1047  56c1		       fc		      .byte.b	252	;R (12)
   1048  56c2		       20		      .byte.b	32	;G
   1049  56c3		       00		      .byte.b	0	;B
   1050  56c4		       fe		      .byte.b	254	;R (11)
   1051  56c5		       46		      .byte.b	70	;G
   1052  56c6		       00		      .byte.b	0	;B
   1053  56c7		       f8		      .byte.b	248	;R (10)
   1054  56c8		       48		      .byte.b	72	;G
   1055  56c9		       00		      .byte.b	0	;B
   1056  56ca		       f0		      .byte.b	240	;R (9)
   1057  56cb		       04		      .byte.b	4	;G
   1058  56cc		       00		      .byte.b	0	;B
   1059  56cd		       e0		      .byte.b	224	;R (8)
   1060  56ce		       20		      .byte.b	32	;G
   1061  56cf		       00		      .byte.b	0	;B
   1062  56d0		       e0		      .byte.b	224	;R (7)
   1063  56d1		       29		      .byte.b	41	;G
   1064  56d2		       00		      .byte.b	0	;B
   1065  56d3		       e0		      .byte.b	224	;R (6)
   1066  56d4		       20		      .byte.b	32	;G
   1067  56d5		       00		      .byte.b	0	;B
   1068  56d6		       e0		      .byte.b	224	;R (5)
   1069  56d7		       84		      .byte.b	132	;G
   1070  56d8		       00		      .byte.b	0	;B
   1071  56d9		       60		      .byte.b	96	;R (4)
   1072  56da		       40		      .byte.b	64	;G
   1073  56db		       00		      .byte.b	0	;B
   1074  56dc		       00		      .byte.b	0	;R (3)
   1075  56dd		       88		      .byte.b	136	;G
   1076  56de		       00		      .byte.b	0	;B
   1077  56df		       00		      .byte.b	0	;R (2)
   1078  56e0		       11		      .byte.b	17	;G
   1079  56e1		       00		      .byte.b	0	;B
   1080  56e2		       24		      .byte.b	36	;R (1)
   1081  56e3		       24		      .byte.b	36	;G
   1082  56e4		       00		      .byte.b	0	;B
   1083  56e5		       00		      .byte.b	0	;R (0)
   1084  56e6		       00		      .byte.b	0	;G
   1085  56e7		       00		      .byte.b	0	;B
   1086  56e8				   COL_5
   1087  56e8		       02		      .byte.b	2	;R (71)
   1088  56e9		       12		      .byte.b	18	;G
   1089  56ea		       00		      .byte.b	0	;B
   1090  56eb		       00		      .byte.b	0	;R (70)
   1091  56ec		       00		      .byte.b	0	;G
   1092  56ed		       00		      .byte.b	0	;B
   1093  56ee		       00		      .byte.b	0	;R (69)
   1094  56ef		       02		      .byte.b	2	;G
   1095  56f0		       00		      .byte.b	0	;B
   1096  56f1		       03		      .byte.b	3	;R (68)
   1097  56f2		       12		      .byte.b	18	;G
   1098  56f3		       00		      .byte.b	0	;B
   1099  56f4		       0b		      .byte.b	11	;R (67)
   1100  56f5		       09		      .byte.b	9	;G
   1101  56f6		       00		      .byte.b	0	;B
   1102  56f7		       07		      .byte.b	7	;R (66)
   1103  56f8		       05		      .byte.b	5	;G
   1104  56f9		       00		      .byte.b	0	;B
   1105  56fa		       03		      .byte.b	3	;R (65)
   1106  56fb		       06		      .byte.b	6	;G
   1107  56fc		       00		      .byte.b	0	;B
   1108  56fd		       01		      .byte.b	1	;R (64)
   1109  56fe		       20		      .byte.b	32	;G
   1110  56ff		       00		      .byte.b	0	;B
   1111  5700		       03		      .byte.b	3	;R (63)
   1112  5701		       03		      .byte.b	3	;G
   1113  5702		       00		      .byte.b	0	;B
   1114  5703		       03		      .byte.b	3	;R (62)
   1115  5704		       0a		      .byte.b	10	;G
   1116  5705		       00		      .byte.b	0	;B
   1117  5706		       03		      .byte.b	3	;R (61)
   1118  5707		       02		      .byte.b	2	;G
   1119  5708		       00		      .byte.b	0	;B
   1120  5709		       03		      .byte.b	3	;R (60)
   1121  570a		       00		      .byte.b	0	;G
   1122  570b		       00		      .byte.b	0	;B
   1123  570c		       03		      .byte.b	3	;R (59)
   1124  570d		       0a		      .byte.b	10	;G
   1125  570e		       00		      .byte.b	0	;B
   1126  570f		       03		      .byte.b	3	;R (58)
   1127  5710		       02		      .byte.b	2	;G
   1128  5711		       00		      .byte.b	0	;B
   1129  5712		       01		      .byte.b	1	;R (57)
   1130  5713		       03		      .byte.b	3	;G
   1131  5714		       00		      .byte.b	0	;B
   1132  5715		       01		      .byte.b	1	;R (56)
   1133  5716		       01		      .byte.b	1	;G
   1134  5717		       00		      .byte.b	0	;B
   1135  5718		       00		      .byte.b	0	;R (55)
   1136  5719		       25		      .byte.b	37	;G
   1137  571a		       00		      .byte.b	0	;B
   1138  571b		       00		      .byte.b	0	;R (54)
   1139  571c		       00		      .byte.b	0	;G
   1140  571d		       00		      .byte.b	0	;B
   1141  571e		       00		      .byte.b	0	;R (53)
   1142  571f		       20		      .byte.b	32	;G
   1143  5720		       00		      .byte.b	0	;B
   1144  5721		       00		      .byte.b	0	;R (52)
   1145  5722		       08		      .byte.b	8	;G
   1146  5723		       00		      .byte.b	0	;B
   1147  5724		       00		      .byte.b	0	;R (51)
   1148  5725		       02		      .byte.b	2	;G
   1149  5726		       00		      .byte.b	0	;B
   1150  5727		       00		      .byte.b	0	;R (50)
   1151  5728		       40		      .byte.b	64	;G
   1152  5729		       00		      .byte.b	0	;B
   1153  572a		       00		      .byte.b	0	;R (49)
   1154  572b		       11		      .byte.b	17	;G
   1155  572c		       00		      .byte.b	0	;B
   1156  572d		       00		      .byte.b	0	;R (48)
   1157  572e		       00		      .byte.b	0	;G
   1158  572f		       00		      .byte.b	0	;B
   1159  5730		       00		      .byte.b	0	;R (47)
   1160  5731		       20		      .byte.b	32	;G
   1161  5732		       00		      .byte.b	0	;B
   1162  5733		       00		      .byte.b	0	;R (46)
   1163  5734		       08		      .byte.b	8	;G
   1164  5735		       00		      .byte.b	0	;B
   1165  5736		       00		      .byte.b	0	;R (45)
   1166  5737		       00		      .byte.b	0	;G
   1167  5738		       00		      .byte.b	0	;B
   1168  5739		       00		      .byte.b	0	;R (44)
   1169  573a		       24		      .byte.b	36	;G
   1170  573b		       00		      .byte.b	0	;B
   1171  573c		       00		      .byte.b	0	;R (43)
   1172  573d		       00		      .byte.b	0	;G
   1173  573e		       00		      .byte.b	0	;B
   1174  573f		       00		      .byte.b	0	;R (42)
   1175  5740		       04		      .byte.b	4	;G
   1176  5741		       00		      .byte.b	0	;B
   1177  5742		       00		      .byte.b	0	;R (41)
   1178  5743		       21		      .byte.b	33	;G
   1179  5744		       00		      .byte.b	0	;B
   1180  5745		       01		      .byte.b	1	;R (40)
   1181  5746		       01		      .byte.b	1	;G
   1182  5747		       00		      .byte.b	0	;B
   1183  5748		       01		      .byte.b	1	;R (39)
   1184  5749		       25		      .byte.b	37	;G
   1185  574a		       00		      .byte.b	0	;B
   1186  574b		       01		      .byte.b	1	;R (38)
   1187  574c		       01		      .byte.b	1	;G
   1188  574d		       00		      .byte.b	0	;B
   1189  574e		       03		      .byte.b	3	;R (37)
   1190  574f		       23		      .byte.b	35	;G
   1191  5750		       00		      .byte.b	0	;B
   1192  5751		       03		      .byte.b	3	;R (36)
   1193  5752		       13		      .byte.b	19	;G
   1194  5753		       00		      .byte.b	0	;B
   1195  5754		       01		      .byte.b	1	;R (35)
   1196  5755		       02		      .byte.b	2	;G
   1197  5756		       00		      .byte.b	0	;B
   1198  5757		       01		      .byte.b	1	;R (34)
   1199  5758		       10		      .byte.b	16	;G
   1200  5759		       00		      .byte.b	0	;B
   1201  575a		       03		      .byte.b	3	;R (33)
   1202  575b		       02		      .byte.b	2	;G
   1203  575c		       00		      .byte.b	0	;B
   1204  575d		       01		      .byte.b	1	;R (32)
   1205  575e		       08		      .byte.b	8	;G
   1206  575f		       00		      .byte.b	0	;B
   1207  5760		       03		      .byte.b	3	;R (31)
   1208  5761		       20		      .byte.b	32	;G
   1209  5762		       00		      .byte.b	0	;B
   1210  5763		       03		      .byte.b	3	;R (30)
   1211  5764		       00		      .byte.b	0	;G
   1212  5765		       00		      .byte.b	0	;B
   1213  5766		       03		      .byte.b	3	;R (29)
   1214  5767		       10		      .byte.b	16	;G
   1215  5768		       00		      .byte.b	0	;B
   1216  5769		       03		      .byte.b	3	;R (28)
   1217  576a		       00		      .byte.b	0	;G
   1218  576b		       00		      .byte.b	0	;B
   1219  576c		       07		      .byte.b	7	;R (27)
   1220  576d		       0e		      .byte.b	14	;G
   1221  576e		       00		      .byte.b	0	;B
   1222  576f		       03		      .byte.b	3	;R (26)
   1223  5770		       41		      .byte.b	65	;G
   1224  5771		       00		      .byte.b	0	;B
   1225  5772		       07		      .byte.b	7	;R (25)
   1226  5773		       04		      .byte.b	4	;G
   1227  5774		       00		      .byte.b	0	;B
   1228  5775		       03		      .byte.b	3	;R (24)
   1229  5776		       21		      .byte.b	33	;G
   1230  5777		       00		      .byte.b	0	;B
   1231  5778		       03		      .byte.b	3	;R (23)
   1232  5779		       04		      .byte.b	4	;G
   1233  577a		       00		      .byte.b	0	;B
   1234  577b		       03		      .byte.b	3	;R (22)
   1235  577c		       02		      .byte.b	2	;G
   1236  577d		       00		      .byte.b	0	;B
   1237  577e		       03		      .byte.b	3	;R (21)
   1238  577f		       26		      .byte.b	38	;G
   1239  5780		       00		      .byte.b	0	;B
   1240  5781		       01		      .byte.b	1	;R (20)
   1241  5782		       01		      .byte.b	1	;G
   1242  5783		       00		      .byte.b	0	;B
   1243  5784		       00		      .byte.b	0	;R (19)
   1244  5785		       21		      .byte.b	33	;G
   1245  5786		       00		      .byte.b	0	;B
   1246  5787		       01		      .byte.b	1	;R (18)
   1247  5788		       09		      .byte.b	9	;G
   1248  5789		       00		      .byte.b	0	;B
   1249  578a		       23		      .byte.b	35	;R (17)
   1250  578b		       22		      .byte.b	34	;G
   1251  578c		       00		      .byte.b	0	;B
   1252  578d		       01		      .byte.b	1	;R (16)
   1253  578e		       01		      .byte.b	1	;G
   1254  578f		       00		      .byte.b	0	;B
   1255  5790		       00		      .byte.b	0	;R (15)
   1256  5791		       29		      .byte.b	41	;G
   1257  5792		       00		      .byte.b	0	;B
   1258  5793		       00		      .byte.b	0	;R (14)
   1259  5794		       00		      .byte.b	0	;G
   1260  5795		       00		      .byte.b	0	;B
   1261  5796		       00		      .byte.b	0	;R (13)
   1262  5797		       04		      .byte.b	4	;G
   1263  5798		       00		      .byte.b	0	;B
   1264  5799		       00		      .byte.b	0	;R (12)
   1265  579a		       20		      .byte.b	32	;G
   1266  579b		       00		      .byte.b	0	;B
   1267  579c		       10		      .byte.b	16	;R (11)
   1268  579d		       12		      .byte.b	18	;G
   1269  579e		       00		      .byte.b	0	;B
   1270  579f		       00		      .byte.b	0	;R (10)
   1271  57a0		       00		      .byte.b	0	;G
   1272  57a1		       00		      .byte.b	0	;B
   1273  57a2		       00		      .byte.b	0	;R (9)
   1274  57a3		       21		      .byte.b	33	;G
   1275  57a4		       00		      .byte.b	0	;B
   1276  57a5		       00		      .byte.b	0	;R (8)
   1277  57a6		       08		      .byte.b	8	;G
   1278  57a7		       00		      .byte.b	0	;B
   1279  57a8		       00		      .byte.b	0	;R (7)
   1280  57a9		       20		      .byte.b	32	;G
   1281  57aa		       00		      .byte.b	0	;B
   1282  57ab		       00		      .byte.b	0	;R (6)
   1283  57ac		       04		      .byte.b	4	;G
   1284  57ad		       00		      .byte.b	0	;B
   1285  57ae		       20		      .byte.b	32	;R (5)
   1286  57af		       20		      .byte.b	32	;G
   1287  57b0		       00		      .byte.b	0	;B
   1288  57b1		       00		      .byte.b	0	;R (4)
   1289  57b2		       09		      .byte.b	9	;G
   1290  57b3		       00		      .byte.b	0	;B
   1291  57b4		       00		      .byte.b	0	;R (3)
   1292  57b5		       00		      .byte.b	0	;G
   1293  57b6		       00		      .byte.b	0	;B
   1294  57b7		       00		      .byte.b	0	;R (2)
   1295  57b8		       48		      .byte.b	72	;G
   1296  57b9		       00		      .byte.b	0	;B
   1297  57ba		       02		      .byte.b	2	;R (1)
   1298  57bb		       02		      .byte.b	2	;G
   1299  57bc		       00		      .byte.b	0	;B
   1300  57bd		       00		      .byte.b	0	;R (0)
   1301  57be		       00		      .byte.b	0	;G
   1302  57bf		       00		      .byte.b	0	;B
------- FILE titleScreen.asm
    265  57c0							;    include "pizza.asm"
    266  57c0
      0  57c0					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  57c0		       07 c0	   .TEMP      =	* - BANK_START
 TITLESCREEN (2K) SIZE =  $7c0 , FREE= $40
      2  57c0					      ECHO	"TITLESCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  57c0				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  57c0				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  57c0				  -	      ERR
      6  57c0					      ENDIF
      7  57c0
------- FILE ./chess.asm
------- FILE BANK_RECON.asm LEVEL 2 PASS 5
      0  57c0					      include	"BANK_RECON.asm"
      0  57c0					      NEWBANK	RECON
      1  5f90 ????				      SEG	RECON
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   RECON      SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	RECON
      2  5800
      3  5800							;---------------------------------------------------------------------------------------------------
      4  5800
      0  5800					      DEF	InitPieceList
      1  5800				   BANK_InitPieceList SET	_CURRENT_BANK
      2  5800				   InitPieceList
      3  5800				   TEMPORARY_VAR SET	Overlay
      4  5800				   TEMPORARY_OFFSET SET	0
      5  5800				   VAR_BOUNDARY_InitPieceList SET	TEMPORARY_OFFSET
      6  5800				   FUNCTION_NAME SET	InitPieceList
      7  5800					      SUBROUTINE
      6  5800					      SUBROUTINE
      7  5800
------- FILE setup_board.asm LEVEL 3 PASS 5
      0  5800					      include	"setup_board.asm"
      1  5800
      2  5800					      IF	!TEST_POSITION
      3  5800
      4  5800		       06 19		      .byte.b	WHITE|Q, 25
      5  5802		       04 18		      .byte.b	WHITE|B, 24
      6  5804		       04 1b		      .byte.b	WHITE|B, 27
      7  5806		       05 16		      .byte.b	WHITE|R, 22
      8  5808		       05 1d		      .byte.b	WHITE|R, 29
      9  580a		       03 17		      .byte.b	WHITE|N, 23
     10  580c		       03 1c		      .byte.b	WHITE|N, 28
     11  580e
     12  580e		       01 23		      .byte.b	WHITE|WP, 35
     13  5810		       01 24		      .byte.b	WHITE|WP, 36
     14  5812		       01 22		      .byte.b	WHITE|WP, 34
     15  5814		       01 25		      .byte.b	WHITE|WP, 37
     16  5816		       01 21		      .byte.b	WHITE|WP, 33
     17  5818		       01 26		      .byte.b	WHITE|WP, 38
     18  581a		       01 20		      .byte.b	WHITE|WP, 32
     19  581c		       01 27		      .byte.b	WHITE|WP, 39
     20  581e
     21  581e		       07 1a		      .byte.b	WHITE|K, 26
     22  5820
     23  5820		       86 5f		      .byte.b	BLACK|Q, 95
     24  5822		       84 5e		      .byte.b	BLACK|B, 94
     25  5824		       84 61		      .byte.b	BLACK|B, 97
     26  5826		       85 5c		      .byte.b	BLACK|R, 92
     27  5828		       85 63		      .byte.b	BLACK|R, 99
     28  582a		       83 5d		      .byte.b	BLACK|N, 93
     29  582c		       83 62		      .byte.b	BLACK|N, 98
     30  582e
     31  582e		       82 55		      .byte.b	BLACK|BP, 85
     32  5830		       82 56		      .byte.b	BLACK|BP, 86
     33  5832		       82 54		      .byte.b	BLACK|BP, 84
     34  5834		       82 57		      .byte.b	BLACK|BP, 87
     35  5836		       82 53		      .byte.b	BLACK|BP, 83
     36  5838		       82 58		      .byte.b	BLACK|BP, 88
     37  583a		       82 52		      .byte.b	BLACK|BP, 82
     38  583c		       82 59		      .byte.b	BLACK|BP, 89
     39  583e
     40  583e		       87 60		      .byte.b	BLACK|K, 96
     41  5840
     42  5840		       00		      .byte.b	0	;end
     43  5841
     44  5841				  -	      ELSE		; test position...
     45  5841				  -
     46  5841				  -
     47  5841				  -	      IF	0
     48  5841				  -
     49  5841				  -	      .byte	WHITE|K, 28
     50  5841				  -	      .byte	WHITE|WP, 37
     51  5841				  -	      .byte	WHITE|WP, 38
     52  5841				  -	      .byte	WHITE|WP, 53
     53  5841				  -	      .byte	WHITE|WP, 49
     54  5841				  -	      .byte	WHITE|WP, 32
     55  5841				  -	      .byte	WHITE|R, 27
     56  5841				  -	      .byte	WHITE|B, 46
     57  5841				  -	      .byte	WHITE|R, 54
     58  5841				  -
     59  5841				  -	      .byte	BLACK|BP, 56
     60  5841				  -	      .byte	BLACK|BP, 87
     61  5841				  -	      .byte	BLACK|BP, 88
     62  5841				  -	      .byte	BLACK|BP, 89
     63  5841				  -	      .byte	BLACK|BP, 84
     64  5841				  -	      .byte	BLACK|B, 66
     65  5841				  -	      .byte	BLACK|R, 69
     66  5841				  -	      .byte	BLACK|K, 98
     67  5841				  -
     68  5841				  -	      .byte	BLACK|R, 92
     69  5841				  -
     70  5841				  -
     71  5841				  -
     72  5841				  -	      ENDIF
     73  5841				  -
     74  5841				  -
     75  5841				  -	      IF	1
     76  5841				  -			; En passant test
     77  5841				  -
     78  5841				  -	      .byte	BLACK|BP, 88
     79  5841				  -	      .byte	BLACK|BP, 86
     80  5841				  -
     81  5841				  -	      .byte	WHITE|WP, 67
     82  5841				  -	      .byte	WHITE|K, 52
     83  5841				  -
     84  5841				  -
     85  5841				  -	      ENDIF
     86  5841				  -
     87  5841				  -
     88  5841				  -
     89  5841				  -
     90  5841				  -	      IF	0
     91  5841				  -
     92  5841				  -
     93  5841				  -			;.byte BLACK|R, 97
     94  5841				  -	      .byte	BLACK|K, 98
     95  5841				  -	      .byte	BLACK|BP, 87
     96  5841				  -	      .byte	BLACK|BP, 88
     97  5841				  -	      .byte	BLACK|BP, 89
     98  5841				  -			;    .byte BLACK|B, 76
     99  5841				  -
    100  5841				  -
    101  5841				  -	      .byte	WHITE|R,28
    102  5841				  -	      .byte	WHITE|Q,58
    103  5841				  -			;   .byte WHITE|N,65
    104  5841				  -	      ENDIF
    105  5841				  -
    106  5841				  -	      IF	0
    107  5841				  -			;.byte WHITE|WP, 56
    108  5841				  -
    109  5841				  -
    110  5841				  -	      .byte	BLACK|K, 98
    111  5841				  -
    112  5841				  -
    113  5841				  -	      .byte	WHITE|R,29
    114  5841				  -	      .byte	WHITE|Q,49
    115  5841				  -	      .byte	WHITE|N,65
    116  5841				  -	      ENDIF
    117  5841				  -	      .byte	0	;end
    118  5841				  -
    119  5841					      ENDIF
    120  5841
    121  5841
------- FILE BANK_RECON.asm
      9  5841
     10  5841
     11  5841							;---------------------------------------------------------------------------------------------------
     12  5841
      0  5841					      DEF	UNSAFE_showMoveCaptures
      1  5841				   BANK_UNSAFE_showMoveCaptures SET	_CURRENT_BANK
      2  5841				   UNSAFE_showMoveCaptures
      3  5841				   TEMPORARY_VAR SET	Overlay
      4  5841				   TEMPORARY_OFFSET SET	0
      5  5841				   VAR_BOUNDARY_UNSAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      6  5841				   FUNCTION_NAME SET	UNSAFE_showMoveCaptures
      7  5841					      SUBROUTINE
     14  5841					      SUBROUTINE
     15  5841
      0  5841					      REFER	SAFE_showMoveCaptures
      1  5841				  -	      IF	VAREND_SAFE_showMoveCaptures > TEMPORARY_VAR
      2  5841				  -TEMPORARY_VAR SET	VAREND_SAFE_showMoveCaptures
      3  5841					      ENDIF
      0  5841					      VAR	__toSquareX12, 1
      1  5841		       00 a2	   __toSquareX12 =	TEMPORARY_VAR
      2  5841				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5841
      4  5841				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5841				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5841				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5841					      ENDIF
      8  5841				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5841				  -	      ECHO	"Temporary Variable", __toSquareX12, "overflow!"
     10  5841				  -	      ERR
     11  5841					      ENDIF
     12  5841					      LIST	ON
      0  5841					      VAR	__fromPiece, 1
      1  5841		       00 a3	   __fromPiece =	TEMPORARY_VAR
      2  5841				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5841
      4  5841				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5841				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5841				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5841					      ENDIF
      8  5841				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5841				  -	      ECHO	"Temporary Variable", __fromPiece, "overflow!"
     10  5841				  -	      ERR
     11  5841					      ENDIF
     12  5841					      LIST	ON
      0  5841					      VAR	__aiMoveIndex, 1
      1  5841		       00 a4	   __aiMoveIndex =	TEMPORARY_VAR
      2  5841				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5841
      4  5841				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5841				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5841				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5841					      ENDIF
      8  5841				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5841				  -	      ECHO	"Temporary Variable", __aiMoveIndex, "overflow!"
     10  5841				  -	      ERR
     11  5841					      ENDIF
     12  5841					      LIST	ON
      0  5841					      VEND	UNSAFE_showMoveCaptures
      1  5841				  -	      IFNCONST	UNSAFE_showMoveCaptures
      2  5841				  -	      ECHO	"Incorrect VEND label", UNSAFE_showMoveCaptures
      3  5841				  -	      ERR
      4  5841					      ENDIF
      5  5841		       00 a5	   VAREND_UNSAFE_showMoveCaptures =	TEMPORARY_VAR
     21  5841
     22  5841							; place a marker on the board for any square matching the piece
     23  5841							; EXCEPT for squares which are occupied (we'll flash those later)
     24  5841							; x = movelist item # being checked
     25  5841
     26  5841		       a5 8b		      lda	savedBank
     27  5843		       48		      pha
     28  5844
     29  5844		       a9 0b		      lda	#BANK_UNSAFE_showMoveCaptures
     30  5846		       85 8b		      sta	savedBank
     31  5848
     32  5848
     33  5848		       a6 8e	   .next      ldx	aiMoveIndex
     34  584a		       86 a4		      stx	__aiMoveIndex
     35  584c		       30 3a		      bmi	.skip	; no moves in list
     36  584e
     37  584e		       ad 84 02 	      lda	INTIM
     38  5851		       c9 14		      cmp	#20
     39  5853		       90 33		      bcc	.skip
     40  5855
     41  5855		       c6 8e		      dec	aiMoveIndex
     42  5857
     43  5857		       20 b8 fd 	      jsr	GetP_MoveFrom
     44  585a		       c5 85		      cmp	fromX12
     45  585c		       d0 ea		      bne	.next
     46  585e
     47  585e
     48  585e		       20 c4 fd 	      jsr	GetP_MoveTo
     49  5861		       85 a2		      sta	__toSquareX12
     50  5863		       a8		      tay
     51  5864		       20 dc fc 	      jsr	GetBoard
     52  5867		       29 0f		      and	#PIECE_MASK
     53  5869		       f0 dd		      beq	.next
     54  586b
     55  586b							; There's something on the board at destination, so it's a capture
     56  586b							; Let's see if we are doing a pawn promote...
     57  586b
     58  586b		       a4 85		      ldy	fromX12
     59  586d		       20 dc fc 	      jsr	GetBoard
     60  5870		       85 a3		      sta	__fromPiece
     61  5872
     62  5872		       20 d0 fd 	      jsr	GetP_MovePiece
     63  5875		       45 a3		      eor	__fromPiece
     64  5877		       29 0f		      and	#PIECE_MASK
     65  5879		       f0 06		      beq	.legit	; from == to, so not a promote
     66  587b
     67  587b							; Have detected a promotion duplicate - skip all 3 of them
     68  587b
     69  587b		       c6 8e		      dec	aiMoveIndex	; skip "KBRQ" promotes
     70  587d		       c6 8e		      dec	aiMoveIndex
     71  587f		       c6 8e		      dec	aiMoveIndex
     72  5881
     73  5881				   .legit
     74  5881
     75  5881							;TIMECHECK COPYSINGLEPIECE, restoreIndex     ; not enough time to draw
     76  5881
     77  5881		       a5 a2		      lda	__toSquareX12
     78  5883		       85 80		      sta	squareToDraw
     79  5885
     80  5885		       20 40 fd 	      jsr	CopySinglePiece
     81  5888
     82  5888		       68	   .skip      pla
     83  5889		       85 8b		      sta	savedBank
     84  588b		       60		      rts
     85  588c
     86  588c
     87  588c							;---------------------------------------------------------------------------------------------------
     88  588c
      0  588c					      DEF	aiMarchToTargetA
      1  588c				   BANK_aiMarchToTargetA SET	_CURRENT_BANK
      2  588c				   aiMarchToTargetA
      3  588c				   TEMPORARY_VAR SET	Overlay
      4  588c				   TEMPORARY_OFFSET SET	0
      5  588c				   VAR_BOUNDARY_aiMarchToTargetA SET	TEMPORARY_OFFSET
      6  588c				   FUNCTION_NAME SET	aiMarchToTargetA
      7  588c					      SUBROUTINE
     90  588c					      SUBROUTINE
     91  588c
      0  588c					      REFER	AiStateMachine
      1  588c				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  588c				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  588c					      ENDIF
      0  588c					      VAR	__fromRow, 1
      1  588c		       00 a2	   __fromRow  =	TEMPORARY_VAR
      2  588c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  588c
      4  588c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  588c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  588c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  588c					      ENDIF
      8  588c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  588c				  -	      ECHO	"Temporary Variable", __fromRow, "overflow!"
     10  588c				  -	      ERR
     11  588c					      ENDIF
     12  588c					      LIST	ON
      0  588c					      VAR	__boardIndex, 1
      1  588c		       00 a3	   __boardIndex =	TEMPORARY_VAR
      2  588c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  588c
      4  588c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  588c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  588c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  588c					      ENDIF
      8  588c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  588c				  -	      ECHO	"Temporary Variable", __boardIndex, "overflow!"
     10  588c				  -	      ERR
     11  588c					      ENDIF
     12  588c					      LIST	ON
      0  588c					      VAR	__fromCol, 1
      1  588c		       00 a4	   __fromCol  =	TEMPORARY_VAR
      2  588c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  588c
      4  588c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  588c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  588c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  588c					      ENDIF
      8  588c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  588c				  -	      ECHO	"Temporary Variable", __fromCol, "overflow!"
     10  588c				  -	      ERR
     11  588c					      ENDIF
     12  588c					      LIST	ON
      0  588c					      VAR	__toCol, 1
      1  588c		       00 a5	   __toCol    =	TEMPORARY_VAR
      2  588c				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  588c
      4  588c				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  588c				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  588c				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  588c					      ENDIF
      8  588c				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  588c				  -	      ECHO	"Temporary Variable", __toCol, "overflow!"
     10  588c				  -	      ERR
     11  588c					      ENDIF
     12  588c					      LIST	ON
      0  588c					      VEND	aiMarchToTargetA
      1  588c				  -	      IFNCONST	aiMarchToTargetA
      2  588c				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetA
      3  588c				  -	      ERR
      4  588c					      ENDIF
      5  588c		       00 a6	   VAREND_aiMarchToTargetA =	TEMPORARY_VAR
     98  588c
     99  588c
    100  588c							; Now we calculate move to new square
    101  588c
    102  588c		       a5 85		      lda	fromX12
    103  588e		       c5 86		      cmp	toX12
    104  5890		       f0 44		      beq	.unmovedx
    105  5892		       85 83		      sta	lastSquareX12
    106  5894
    107  5894		       38		      sec
    108  5895		       a2 fd		      ldx	#-3
    109  5897		       e9 0a	   .sub10     sbc	#10
    110  5899		       e8		      inx
    111  589a		       b0 fb		      bcs	.sub10
    112  589c		       69 08		      adc	#8
    113  589e		       85 a4		      sta	__fromCol
    114  58a0		       86 a2		      stx	__fromRow
    115  58a2
    116  58a2		       a5 86		      lda	toX12
    117  58a4		       38		      sec
    118  58a5		       a2 fd		      ldx	#-3
    119  58a7		       e9 0a	   .sub10b    sbc	#10
    120  58a9		       e8		      inx
    121  58aa		       b0 fb		      bcs	.sub10b
    122  58ac		       69 08		      adc	#8
    123  58ae		       85 a5		      sta	__toCol
    124  58b0
    125  58b0
    126  58b0		       e4 a2		      cpx	__fromRow
    127  58b2		       f0 13		      beq	.rowDone
    128  58b4
    129  58b4		       b0 0a		      bcs	.incRow
    130  58b6
    131  58b6		       38		      sec
    132  58b7		       a5 85		      lda	fromX12
    133  58b9		       e9 0a		      sbc	#10
    134  58bb		       85 85		      sta	fromX12
    135  58bd		       4c c7 f0 	      jmp	.rowDone
    136  58c0
    137  58c0		       18	   .incRow    clc
    138  58c1		       a5 85		      lda	fromX12
    139  58c3		       69 0a		      adc	#10
    140  58c5		       85 85		      sta	fromX12
    141  58c7
    142  58c7				   .rowDone
    143  58c7
    144  58c7		       a5 a5		      lda	__toCol
    145  58c9		       c5 a4		      cmp	__fromCol
    146  58cb		       f0 09		      beq	.colDone
    147  58cd
    148  58cd		       b0 05		      bcs	.incCol
    149  58cf
    150  58cf		       c6 85		      dec	fromX12
    151  58d1		       4c d6 f0 	      jmp	.colDone
    152  58d4
    153  58d4		       e6 85	   .incCol    inc	fromX12
    154  58d6				   .colDone
    155  58d6				   .unmovedx
    156  58d6
      0  58d6					      PHASE	AI_MarchA2
      1  58d6		       a9 17		      lda	#AI_MarchA2
      2  58d8		       85 8c		      sta	aiState
    158  58da		       60		      rts
    159  58db
    160  58db
      0  58db					      DEF	aiMarchA2
      1  58db				   BANK_aiMarchA2 SET	_CURRENT_BANK
      2  58db				   aiMarchA2
      3  58db				   TEMPORARY_VAR SET	Overlay
      4  58db				   TEMPORARY_OFFSET SET	0
      5  58db				   VAR_BOUNDARY_aiMarchA2 SET	TEMPORARY_OFFSET
      6  58db				   FUNCTION_NAME SET	aiMarchA2
      7  58db					      SUBROUTINE
    162  58db					      SUBROUTINE
    163  58db
    164  58db
    165  58db							; erase object in new sqare --> blank
    166  58db
    167  58db		       a4 85		      ldy	fromX12
    168  58dd		       84 80		      sty	squareToDraw
    169  58df
    170  58df		       20 dc fc 	      jsr	GetBoard
    171  58e2		       c9 00		      cmp	#0
    172  58e4		       f0 03		      beq	.skipbl
    173  58e6		       20 40 fd 	      jsr	CopySinglePiece	; erase next square along --> blank
    174  58e9
    175  58e9				   .skipbl
    176  58e9		       a4 85		      ldy	fromX12
    177  58eb		       84 a3		      sty	__boardIndex
    178  58ed
    179  58ed		       20 dc fc 	      jsr	GetBoard
    180  58f0		       85 98		      sta	lastPiece	; what we are overwriting
    181  58f2		       a5 97		      lda	fromPiece
    182  58f4		       09 40		      ora	#FLAG_MOVED	; prevents usage in castling for K/R
    183  58f6		       29 df		      and	#~FLAG_ENPASSANT
    184  58f8		       a4 a3		      ldy	__boardIndex
    185  58fa		       20 e8 fc 	      jsr	PutBoard
    186  58fd
      0  58fd					      PHASE	AI_MarchB
      1  58fd		       a9 18		      lda	#AI_MarchB
      2  58ff		       85 8c		      sta	aiState
    188  5901		       60		      rts
    189  5902
    190  5902							;---------------------------------------------------------------------------------------------------
    191  5902
      0  5902					      DEF	aiMarchB2
      1  5902				   BANK_aiMarchB2 SET	_CURRENT_BANK
      2  5902				   aiMarchB2
      3  5902				   TEMPORARY_VAR SET	Overlay
      4  5902				   TEMPORARY_OFFSET SET	0
      5  5902				   VAR_BOUNDARY_aiMarchB2 SET	TEMPORARY_OFFSET
      6  5902				   FUNCTION_NAME SET	aiMarchB2
      7  5902					      SUBROUTINE
    193  5902					      SUBROUTINE
    194  5902
      0  5902					      REFER	AiStateMachine
      1  5902				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  5902				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  5902					      ENDIF
      0  5902					      VEND	aiMarchB2
      1  5902				  -	      IFNCONST	aiMarchB2
      2  5902				  -	      ECHO	"Incorrect VEND label", aiMarchB2
      3  5902				  -	      ERR
      4  5902					      ENDIF
      5  5902		       00 a2	   VAREND_aiMarchB2 =	TEMPORARY_VAR
    197  5902
    198  5902		       a4 83		      ldy	lastSquareX12
    199  5904		       84 80		      sty	squareToDraw
    200  5906
    201  5906		       20 dc fc 	      jsr	GetBoard
    202  5909		       c9 00		      cmp	#0
    203  590b		       f0 03		      beq	.skipbl2
    204  590d
    205  590d		       20 40 fd 	      jsr	CopySinglePiece	; draw previous piece back in old position
    206  5910				   .skipbl2
    207  5910
    208  5910		       a5 85		      lda	fromX12
    209  5912		       c5 86		      cmp	toX12
    210  5914		       f0 09		      beq	xhalt
    211  5916
    212  5916		       a9 00		      lda	#0	; inter-move segment speed (can be 0)
    213  5918		       85 82		      sta	drawDelay
      0  591a					      PHASE	AI_MarchToTargetA
      1  591a		       a9 16		      lda	#AI_MarchToTargetA
      2  591c		       85 8c		      sta	aiState
    215  591e
    216  591e		       60		      rts
    217  591f
    218  591f				   xhalt
    219  591f
    220  591f							;??? jsr FinaliseMove
    221  591f
    222  591f		       a9 04		      lda	#4	; on/off count
    223  5921		       85 84		      sta	drawCount	; flashing for piece about to move
    224  5923		       a9 00		      lda	#0
    225  5925		       85 82		      sta	drawDelay
    226  5927
      0  5927					      PHASE	AI_FinalFlash
      1  5927		       a9 1b		      lda	#AI_FinalFlash
      2  5929		       85 8c		      sta	aiState
    228  592b		       60		      rts
    229  592c
    230  592c
    231  592c							;---------------------------------------------------------------------------------------------------
    232  592c
      0  592c					      DEF	aiMarchToTargetB
      1  592c				   BANK_aiMarchToTargetB SET	_CURRENT_BANK
      2  592c				   aiMarchToTargetB
      3  592c				   TEMPORARY_VAR SET	Overlay
      4  592c				   TEMPORARY_OFFSET SET	0
      5  592c				   VAR_BOUNDARY_aiMarchToTargetB SET	TEMPORARY_OFFSET
      6  592c				   FUNCTION_NAME SET	aiMarchToTargetB
      7  592c					      SUBROUTINE
    234  592c					      SUBROUTINE
    235  592c
      0  592c					      REFER	AiStateMachine
      1  592c				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  592c				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  592c					      ENDIF
      0  592c					      VEND	aiMarchToTargetB
      1  592c				  -	      IFNCONST	aiMarchToTargetB
      2  592c				  -	      ECHO	"Incorrect VEND label", aiMarchToTargetB
      3  592c				  -	      ERR
      4  592c					      ENDIF
      5  592c		       00 a2	   VAREND_aiMarchToTargetB =	TEMPORARY_VAR
    238  592c
    239  592c							; now we want to undraw the piece in the old square
    240  592c
    241  592c		       a5 83		      lda	lastSquareX12
    242  592e		       85 80		      sta	squareToDraw
    243  5930
    244  5930		       20 40 fd 	      jsr	CopySinglePiece	; erase whatever was on the previous square (completely blank)
    245  5933
    246  5933		       a4 83		      ldy	lastSquareX12
    247  5935		       a5 99		      lda	previousPiece
    248  5937		       20 e8 fc 	      jsr	PutBoard
    249  593a
    250  593a		       a5 98		      lda	lastPiece
    251  593c		       85 99		      sta	previousPiece
    252  593e
      0  593e					      PHASE	AI_MarchB2
      1  593e		       a9 1a		      lda	#AI_MarchB2
      2  5940		       85 8c		      sta	aiState
    254  5942		       60		      rts
    255  5943
    256  5943
    257  5943							;---------------------------------------------------------------------------------------------------
    258  5943
      0  5943					      DEF	CopySetupForMarker
      1  5943				   BANK_CopySetupForMarker SET	_CURRENT_BANK
      2  5943				   CopySetupForMarker
      3  5943				   TEMPORARY_VAR SET	Overlay
      4  5943				   TEMPORARY_OFFSET SET	0
      5  5943				   VAR_BOUNDARY_CopySetupForMarker SET	TEMPORARY_OFFSET
      6  5943				   FUNCTION_NAME SET	CopySetupForMarker
      7  5943					      SUBROUTINE
    260  5943					      SUBROUTINE
    261  5943
      0  5943					      REFER	markerDraw
      1  5943					      IF	VAREND_markerDraw > TEMPORARY_VAR
      2  5943				   TEMPORARY_VAR SET	VAREND_markerDraw
      3  5943					      ENDIF
      0  5943					      REFER	showPromoteOptions
      1  5943				  -	      IF	VAREND_showPromoteOptions > TEMPORARY_VAR
      2  5943				  -TEMPORARY_VAR SET	VAREND_showPromoteOptions
      3  5943					      ENDIF
      0  5943					      VAR	__pieceColour, 1
      1  5943		       00 a4	   __pieceColour =	TEMPORARY_VAR
      2  5943				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5943
      4  5943				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5943				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5943				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5943					      ENDIF
      8  5943				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5943				  -	      ECHO	"Temporary Variable", __pieceColour, "overflow!"
     10  5943				  -	      ERR
     11  5943					      ENDIF
     12  5943					      LIST	ON
      0  5943					      VAR	__oddeven, 1
      1  5943		       00 a5	   __oddeven  =	TEMPORARY_VAR
      2  5943				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5943
      4  5943				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5943				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5943				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5943					      ENDIF
      8  5943				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5943				  -	      ECHO	"Temporary Variable", __oddeven, "overflow!"
     10  5943				  -	      ERR
     11  5943					      ENDIF
     12  5943					      LIST	ON
      0  5943					      VAR	__pmcol, 1
      1  5943		       00 a6	   __pmcol    =	TEMPORARY_VAR
      2  5943				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  5943
      4  5943				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  5943				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  5943				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  5943					      ENDIF
      8  5943				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  5943				  -	      ECHO	"Temporary Variable", __pmcol, "overflow!"
     10  5943				  -	      ERR
     11  5943					      ENDIF
     12  5943					      LIST	ON
      0  5943					      VEND	CopySetupForMarker
      1  5943				  -	      IFNCONST	CopySetupForMarker
      2  5943				  -	      ECHO	"Incorrect VEND label", CopySetupForMarker
      3  5943				  -	      ERR
      4  5943					      ENDIF
      5  5943		       00 a7	   VAREND_CopySetupForMarker =	TEMPORARY_VAR
    268  5943
    269  5943		       a5 80		      lda	squareToDraw
    270  5945		       38		      sec
    271  5946		       a0 0a		      ldy	#10
    272  5948		       e9 0a	   .sub10     sbc	#10
    273  594a		       88		      dey
    274  594b		       b0 fb		      bcs	.sub10
    275  594d		       84 a5		      sty	__oddeven
    276  594f		       69 08		      adc	#8
    277  5951		       85 a6		      sta	__pmcol
    278  5953		       65 a5		      adc	__oddeven
    279  5955
    280  5955		       29 01		      and	#1
    281  5957		       49 01		      eor	#1
    282  5959		       f0 02		      beq	.white
    283  595b		       a9 24		      lda	#36
    284  595d				   .white
    285  595d		       85 a4		      sta	__pieceColour	; actually SQUARE black/white
    286  595f
    287  595f		       8a		      txa
    288  5960		       18		      clc
    289  5961		       65 a4		      adc	__pieceColour
    290  5963		       85 a4		      sta	__pieceColour
    291  5965
    292  5965		       a5 a6		      lda	__pmcol
    293  5967		       29 03		      and	#3
    294  5969
    295  5969		       18		      clc
    296  596a		       65 a4		      adc	__pieceColour
    297  596c		       a8		      tay
    298  596d		       60		      rts
    299  596e
    300  596e							;---------------------------------------------------------------------------------------------------
    301  596e
      0  596e					      DEF	CopySetup
      1  596e				   BANK_CopySetup SET	_CURRENT_BANK
      2  596e				   CopySetup
      3  596e				   TEMPORARY_VAR SET	Overlay
      4  596e				   TEMPORARY_OFFSET SET	0
      5  596e				   VAR_BOUNDARY_CopySetup SET	TEMPORARY_OFFSET
      6  596e				   FUNCTION_NAME SET	CopySetup
      7  596e					      SUBROUTINE
    303  596e					      SUBROUTINE
    304  596e
      0  596e					      REFER	CopySinglePiece
      1  596e					      IF	VAREND_CopySinglePiece > TEMPORARY_VAR
      2  596e				   TEMPORARY_VAR SET	VAREND_CopySinglePiece
      3  596e					      ENDIF
      0  596e					      VAR	__tmp, 1
      1  596e		       00 ae	   __tmp      =	TEMPORARY_VAR
      2  596e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  596e
      4  596e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  596e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  596e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  596e					      ENDIF
      8  596e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  596e				  -	      ECHO	"Temporary Variable", __tmp, "overflow!"
     10  596e				  -	      ERR
     11  596e					      ENDIF
     12  596e					      LIST	ON
      0  596e					      VAR	__shiftx, 1
      1  596e		       00 af	   __shiftx   =	TEMPORARY_VAR
      2  596e				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  596e
      4  596e				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  596e				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  596e				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  596e					      ENDIF
      8  596e				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  596e				  -	      ECHO	"Temporary Variable", __shiftx, "overflow!"
     10  596e				  -	      ERR
     11  596e					      ENDIF
     12  596e					      LIST	ON
      0  596e					      VEND	CopySetup
      1  596e				  -	      IFNCONST	CopySetup
      2  596e				  -	      ECHO	"Incorrect VEND label", CopySetup
      3  596e				  -	      ERR
      4  596e					      ENDIF
      5  596e		       00 b0	   VAREND_CopySetup =	TEMPORARY_VAR
    309  596e
    310  596e		       a5 8b		      lda	savedBank
    311  5970		       48		      pha
    312  5971		       a9 0b		      lda	#BANK_CopySetup
    313  5973		       85 8b		      sta	savedBank
    314  5975
    315  5975							; figure colouration of square
    316  5975
    317  5975		       a5 80		      lda	squareToDraw
    318  5977
    319  5977				  -	      IF	DIAGNOSTICS
    320  5977				  -			; Catch out-of-range piece square
    321  5977				  -			; will not catch off left/right edge
    322  5977				  -
    323  5977				  -.fail      cmp	#100
    324  5977				  -	      bcs	.fail
    325  5977				  -	      cmp	#22
    326  5977				  -	      bcc	.fail
    327  5977					      ENDIF
    328  5977
    329  5977
    330  5977		       a2 0a		      ldx	#10
    331  5979		       38		      sec
    332  597a		       e9 0a	   .sub10     sbc	#10
    333  597c		       ca		      dex
    334  597d		       b0 fb		      bcs	.sub10
    335  597f		       69 08		      adc	#8
    336  5981		       85 af		      sta	__shiftx
    337  5983				  -	      IF	DIAGNOSTICS
    338  5983				  -.fail2     cmp	#8
    339  5983				  -	      bcs	.fail2
    340  5983				  -	      cpx	#8
    341  5983				  -	      bcs	.fail2
    342  5983					      ENDIF
    343  5983		       86 ae		      stx	__tmp
    344  5985		       65 ae		      adc	__tmp
    345  5987
    346  5987
    347  5987
    348  5987
    349  5987		       29 01		      and	#1
    350  5989							;eor #1
    351  5989		       f0 02		      beq	.white
    352  598b		       a9 24		      lda	#36
    353  598d		       85 a4	   .white     sta	__pieceColour	; actually SQUARE black/white
    354  598f
    355  598f							; PieceColour = 0 for white square, 36 for black square
    356  598f
    357  598f							;lda #RAMBANK_BOARD
    358  598f							;sta SET_BANK_RAM
    359  598f
    360  598f		       a4 80		      ldy	squareToDraw
    361  5991		       20 dc fc 	      jsr	GetBoard	;lda Board,x
    362  5994		       0a		      asl
    363  5995		       90 02		      bcc	.blackAdjust
    364  5997		       09 10		      ora	#16
    365  5999		       4a	   .blackAdjust lsr
    366  599a		       29 0f		      and	#%1111
    367  599c		       aa		      tax
    368  599d
    369  599d		       a5 af		      lda	__shiftx
    370  599f		       29 03		      and	#3	; shift position in P
    371  59a1
    372  59a1		       18		      clc
    373  59a2		       7d ad f1 	      adc	PieceToShape,x
    374  59a5		       18		      clc
    375  59a6		       65 a4		      adc	__pieceColour
    376  59a8		       a8		      tay
    377  59a9
    378  59a9		       68		      pla
    379  59aa		       85 8b		      sta	savedBank
    380  59ac		       60		      rts
    381  59ad
    382  59ad				   PieceToShape
    383  59ad
    384  59ad		       00		      .byte.b	INDEX_WHITE_BLANK_on_WHITE_SQUARE_0
    385  59ae		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    386  59af		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    387  59b0		       08		      .byte.b	INDEX_WHITE_KNIGHT_on_WHITE_SQUARE_0
    388  59b1		       0c		      .byte.b	INDEX_WHITE_BISHOP_on_WHITE_SQUARE_0
    389  59b2		       10		      .byte.b	INDEX_WHITE_ROOK_on_WHITE_SQUARE_0
    390  59b3		       14		      .byte.b	INDEX_WHITE_QUEEN_on_WHITE_SQUARE_0
    391  59b4		       18		      .byte.b	INDEX_WHITE_KING_on_WHITE_SQUARE_0
    392  59b5
    393  59b5		       48		      .byte.b	INDEX_BLACK_BLANK_on_WHITE_SQUARE_0
    394  59b6		       04		      .byte.b	INDEX_WHITE_PAWN_on_WHITE_SQUARE_0
    395  59b7		       4c		      .byte.b	INDEX_BLACK_PAWN_on_WHITE_SQUARE_0
    396  59b8		       50		      .byte.b	INDEX_BLACK_KNIGHT_on_WHITE_SQUARE_0
    397  59b9		       54		      .byte.b	INDEX_BLACK_BISHOP_on_WHITE_SQUARE_0
    398  59ba		       58		      .byte.b	INDEX_BLACK_ROOK_on_WHITE_SQUARE_0
    399  59bb		       5c		      .byte.b	INDEX_BLACK_QUEEN_on_WHITE_SQUARE_0
    400  59bc		       60		      .byte.b	INDEX_BLACK_KING_on_WHITE_SQUARE_0
    401  59bd
    402  59bd							;---------------------------------------------------------------------------------------------------
    403  59bd
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  59bd					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_0.asm"
      0  59bd					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_0", 72
     12  5a00					      LIST	ON
      0  5a00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_0
      1  5a00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  5a00				   BLACK_BISHOP_on_BLACK_SQUARE_0
      3  5a00				   TEMPORARY_VAR SET	Overlay
      4  5a00				   TEMPORARY_OFFSET SET	0
      5  5a00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5a00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_0
      7  5a00					      SUBROUTINE
      3  5a00		       f0 e0 f0 b0*	      .byte.b	$f0,$e0,$f0,$b0,$d0,$e0,$40,$40,$f0,$60,$f0,$b0,$d0,$e0,$00,$40,$00,$00,$00,$00,$00,$00,$40,$00	;PF0
      4  5a18		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5a30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  5a48					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_1.asm"
      0  5a48					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_1", 72
     12  5a48					      LIST	ON
      0  5a48					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_1
      1  5a48				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5a48				   BLACK_BISHOP_on_BLACK_SQUARE_1
      3  5a48				   TEMPORARY_VAR SET	Overlay
      4  5a48				   TEMPORARY_OFFSET SET	0
      5  5a48				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5a48				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_1
      7  5a48					      SUBROUTINE
      3  5a48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5a60		       78 38 7c 6c*	      .byte.b	$78,$38,$7c,$6c,$5c,$38,$10,$10,$7c,$30,$78,$68,$58,$38,$00,$10,$00,$00,$00,$00,$00,$00,$10,$00	;PF1
      5  5a78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5a90					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_2.asm"
      0  5a90					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_2", 72
     12  5a90					      LIST	ON
      0  5a90					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_2
      1  5a90				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5a90				   BLACK_BISHOP_on_BLACK_SQUARE_2
      3  5a90				   TEMPORARY_VAR SET	Overlay
      4  5a90				   TEMPORARY_OFFSET SET	0
      5  5a90				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5a90				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_2
      7  5a90					      SUBROUTINE
      3  5a90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5aa8		       03 01 03 03*	      .byte.b	$03,$01,$03,$03,$02,$01,$00,$00,$03,$01,$03,$03,$02,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5ac0		       03 03 07 06*	      .byte.b	$03,$03,$07,$06,$07,$03,$01,$01,$07,$01,$03,$02,$03,$03,$00,$01,$00,$00,$00,$00,$00,$00,$01,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  5ad8					      include	"gfx/BLACK_BISHOP_on_BLACK_SQUARE_3.asm"
      0  5ad8					      OPTIONAL_PAGEBREAK	"BLACK_BISHOP_on_BLACK_SQUARE_3", 72
     12  5b00					      LIST	ON
      0  5b00					      DEF	BLACK_BISHOP_on_BLACK_SQUARE_3
      1  5b00				   BANK_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5b00				   BLACK_BISHOP_on_BLACK_SQUARE_3
      3  5b00				   TEMPORARY_VAR SET	Overlay
      4  5b00				   TEMPORARY_OFFSET SET	0
      5  5b00				   VAR_BOUNDARY_BLACK_BISHOP_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5b00				   FUNCTION_NAME SET	BLACK_BISHOP_on_BLACK_SQUARE_3
      7  5b00					      SUBROUTINE
      3  5b00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5b18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b30		       78 70 f8 d8*	      .byte.b	$78,$70,$f8,$d8,$e8,$70,$20,$20,$f8,$30,$78,$58,$68,$70,$00,$20,$00,$00,$00,$00,$00,$00,$20,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  5b48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_0.asm"
      0  5b48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_0", 72
     12  5b48					      LIST	ON
      0  5b48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_0
      1  5b48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  5b48				   BLACK_ROOK_on_BLACK_SQUARE_0
      3  5b48				   TEMPORARY_VAR SET	Overlay
      4  5b48				   TEMPORARY_OFFSET SET	0
      5  5b48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5b48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_0
      7  5b48					      SUBROUTINE
      3  5b48		       f0 e0 e0 e0*	      .byte.b	$f0,$e0,$e0,$e0,$f0,$50,$50,$00,$f0,$60,$60,$60,$f0,$50,$00,$00,$00,$00,$00,$00,$00,$a0,$00,$00	;PF0
      4  5b60		       00 00 00 80*	      .byte.b	$00,$00,$00,$80,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5b78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  5b90					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_1.asm"
      0  5b90					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_1", 72
     12  5b90					      LIST	ON
      0  5b90					      DEF	BLACK_ROOK_on_BLACK_SQUARE_1
      1  5b90				   BANK_BLACK_ROOK_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5b90				   BLACK_ROOK_on_BLACK_SQUARE_1
      3  5b90				   TEMPORARY_VAR SET	Overlay
      4  5b90				   TEMPORARY_OFFSET SET	0
      5  5b90				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5b90				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_1
      7  5b90					      SUBROUTINE
      3  5b90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ba8		       78 38 38 3c*	      .byte.b	$78,$38,$38,$3c,$7c,$54,$54,$00,$7c,$30,$30,$30,$78,$50,$00,$00,$00,$00,$00,$00,$00,$28,$00,$00	;PF1
      5  5bc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5bd8					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_2.asm"
      0  5bd8					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_2", 72
     12  5c00					      LIST	ON
      0  5c00					      DEF	BLACK_ROOK_on_BLACK_SQUARE_2
      1  5c00				   BANK_BLACK_ROOK_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5c00				   BLACK_ROOK_on_BLACK_SQUARE_2
      3  5c00				   TEMPORARY_VAR SET	Overlay
      4  5c00				   TEMPORARY_OFFSET SET	0
      5  5c00				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5c00				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_2
      7  5c00					      SUBROUTINE
      3  5c00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c18		       03 01 01 01*	      .byte.b	$03,$01,$01,$01,$03,$02,$02,$00,$03,$01,$01,$01,$03,$02,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00	;PF1
      5  5c30		       03 03 03 07*	      .byte.b	$03,$03,$03,$07,$07,$05,$05,$00,$07,$01,$01,$01,$03,$01,$00,$00,$00,$00,$00,$00,$00,$02,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  5c48					      include	"gfx/BLACK_ROOK_on_BLACK_SQUARE_3.asm"
      0  5c48					      OPTIONAL_PAGEBREAK	"BLACK_ROOK_on_BLACK_SQUARE_3", 72
     12  5c48					      LIST	ON
      0  5c48					      DEF	BLACK_ROOK_on_BLACK_SQUARE_3
      1  5c48				   BANK_BLACK_ROOK_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5c48				   BLACK_ROOK_on_BLACK_SQUARE_3
      3  5c48				   TEMPORARY_VAR SET	Overlay
      4  5c48				   TEMPORARY_OFFSET SET	0
      5  5c48				   VAR_BOUNDARY_BLACK_ROOK_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5c48				   FUNCTION_NAME SET	BLACK_ROOK_on_BLACK_SQUARE_3
      7  5c48					      SUBROUTINE
      3  5c48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5c60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5c78		       78 70 70 f0*	      .byte.b	$78,$70,$70,$f0,$f8,$a8,$a8,$00,$f8,$30,$30,$30,$78,$28,$00,$00,$00,$00,$00,$00,$00,$50,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  5c90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_0.asm"
      0  5c90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_0", 72
     12  5c90					      LIST	ON
      0  5c90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_0
      1  5c90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  5c90				   BLACK_QUEEN_on_BLACK_SQUARE_0
      3  5c90				   TEMPORARY_VAR SET	Overlay
      4  5c90				   TEMPORARY_OFFSET SET	0
      5  5c90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5c90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_0
      7  5c90					      SUBROUTINE
      3  5c90		       e0 e0 f0 f0*	      .byte.b	$e0,$e0,$f0,$f0,$50,$00,$50,$00,$e0,$40,$f0,$f0,$50,$00,$50,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ca8		       00 00 80 80*	      .byte.b	$00,$00,$80,$80,$80,$00,$80,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5cc0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  5cd8					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_1.asm"
      0  5cd8					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_1", 72
     12  5d00					      LIST	ON
      0  5d00					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_1
      1  5d00				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5d00				   BLACK_QUEEN_on_BLACK_SQUARE_1
      3  5d00				   TEMPORARY_VAR SET	Overlay
      4  5d00				   TEMPORARY_OFFSET SET	0
      5  5d00				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5d00				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_1
      7  5d00					      SUBROUTINE
      3  5d00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5d18		       38 38 7c 7c*	      .byte.b	$38,$38,$7c,$7c,$54,$00,$54,$00,$38,$10,$78,$78,$50,$00,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5d48					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_2.asm"
      0  5d48					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_2", 72
     12  5d48					      LIST	ON
      0  5d48					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_2
      1  5d48				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5d48				   BLACK_QUEEN_on_BLACK_SQUARE_2
      3  5d48				   TEMPORARY_VAR SET	Overlay
      4  5d48				   TEMPORARY_OFFSET SET	0
      5  5d48				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5d48				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_2
      7  5d48					      SUBROUTINE
      3  5d48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5d60		       01 01 03 03*	      .byte.b	$01,$01,$03,$03,$02,$00,$02,$00,$01,$00,$03,$03,$02,$00,$02,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5d78		       03 03 07 07*	      .byte.b	$03,$03,$07,$07,$05,$00,$05,$00,$03,$01,$03,$03,$01,$00,$05,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  5d90					      include	"gfx/BLACK_QUEEN_on_BLACK_SQUARE_3.asm"
      0  5d90					      OPTIONAL_PAGEBREAK	"BLACK_QUEEN_on_BLACK_SQUARE_3", 72
     12  5d90					      LIST	ON
      0  5d90					      DEF	BLACK_QUEEN_on_BLACK_SQUARE_3
      1  5d90				   BANK_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5d90				   BLACK_QUEEN_on_BLACK_SQUARE_3
      3  5d90				   TEMPORARY_VAR SET	Overlay
      4  5d90				   TEMPORARY_OFFSET SET	0
      5  5d90				   VAR_BOUNDARY_BLACK_QUEEN_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5d90				   FUNCTION_NAME SET	BLACK_QUEEN_on_BLACK_SQUARE_3
      7  5d90					      SUBROUTINE
      3  5d90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5da8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5dc0		       70 70 f8 f8*	      .byte.b	$70,$70,$f8,$f8,$a8,$00,$a8,$00,$70,$20,$78,$78,$28,$00,$a8,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  5dd8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_0.asm"
      0  5dd8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_0", 72
     12  5e00					      LIST	ON
      0  5e00					      DEF	BLACK_KING_on_BLACK_SQUARE_0
      1  5e00				   BANK_BLACK_KING_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  5e00				   BLACK_KING_on_BLACK_SQUARE_0
      3  5e00				   TEMPORARY_VAR SET	Overlay
      4  5e00				   TEMPORARY_OFFSET SET	0
      5  5e00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  5e00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_0
      7  5e00					      SUBROUTINE
      3  5e00		       e0 f0 50 50*	      .byte.b	$e0,$f0,$50,$50,$f0,$40,$e0,$40,$e0,$60,$50,$50,$70,$40,$e0,$40,$00,$00,$a0,$00,$00,$b0,$00,$00	;PF0
      4  5e18		       00 80 80 80*	      .byte.b	$00,$80,$80,$80,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$00,$00	;PF1
      5  5e30		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  5e48					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_1.asm"
      0  5e48					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_1", 72
     12  5e48					      LIST	ON
      0  5e48					      DEF	BLACK_KING_on_BLACK_SQUARE_1
      1  5e48				   BANK_BLACK_KING_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  5e48				   BLACK_KING_on_BLACK_SQUARE_1
      3  5e48				   TEMPORARY_VAR SET	Overlay
      4  5e48				   TEMPORARY_OFFSET SET	0
      5  5e48				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  5e48				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_1
      7  5e48					      SUBROUTINE
      3  5e48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5e60		       38 7c 54 54*	      .byte.b	$38,$7c,$54,$54,$7c,$10,$38,$10,$38,$30,$50,$50,$70,$10,$38,$10,$00,$00,$28,$00,$00,$6c,$00,$00	;PF1
      5  5e78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  5e90					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_2.asm"
      0  5e90					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_2", 72
     12  5e90					      LIST	ON
      0  5e90					      DEF	BLACK_KING_on_BLACK_SQUARE_2
      1  5e90				   BANK_BLACK_KING_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  5e90				   BLACK_KING_on_BLACK_SQUARE_2
      3  5e90				   TEMPORARY_VAR SET	Overlay
      4  5e90				   TEMPORARY_OFFSET SET	0
      5  5e90				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  5e90				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_2
      7  5e90					      SUBROUTINE
      3  5e90		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5ea8		       01 03 02 02*	      .byte.b	$01,$03,$02,$02,$03,$00,$01,$00,$01,$01,$02,$02,$03,$00,$01,$00,$00,$00,$01,$00,$00,$03,$00,$00	;PF1
      5  5ec0		       03 07 05 05*	      .byte.b	$03,$07,$05,$05,$07,$01,$03,$01,$03,$01,$01,$01,$01,$01,$03,$01,$00,$00,$02,$00,$00,$06,$00,$00	;PF2
------- FILE BANK_RECON.asm
------- FILE gfx/BLACK_KING_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  5ed8					      include	"gfx/BLACK_KING_on_BLACK_SQUARE_3.asm"
      0  5ed8					      OPTIONAL_PAGEBREAK	"BLACK_KING_on_BLACK_SQUARE_3", 72
     12  5f00					      LIST	ON
      0  5f00					      DEF	BLACK_KING_on_BLACK_SQUARE_3
      1  5f00				   BANK_BLACK_KING_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  5f00				   BLACK_KING_on_BLACK_SQUARE_3
      3  5f00				   TEMPORARY_VAR SET	Overlay
      4  5f00				   TEMPORARY_OFFSET SET	0
      5  5f00				   VAR_BOUNDARY_BLACK_KING_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5f00				   FUNCTION_NAME SET	BLACK_KING_on_BLACK_SQUARE_3
      7  5f00					      SUBROUTINE
      3  5f00		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f18		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f30		       70 f8 a8 a8*	      .byte.b	$70,$f8,$a8,$a8,$f8,$20,$70,$20,$70,$30,$28,$28,$38,$20,$70,$20,$00,$00,$50,$00,$00,$d8,$00,$00	;PF2
------- FILE BANK_RECON.asm
    420  5f48
    421  5f48
------- FILE gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  5f48					      include	"gfx/WHITE_MARKER_on_WHITE_SQUARE_3.asm"
      0  5f48					      OPTIONAL_PAGEBREAK	"WHITE_MARKER_on_WHITE_SQUARE_3", 72
     12  5f48					      LIST	ON
      0  5f48					      DEF	WHITE_MARKER_on_WHITE_SQUARE_3
      1  5f48				   BANK_WHITE_MARKER_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  5f48				   WHITE_MARKER_on_WHITE_SQUARE_3
      3  5f48				   TEMPORARY_VAR SET	Overlay
      4  5f48				   TEMPORARY_OFFSET SET	0
      5  5f48				   VAR_BOUNDARY_WHITE_MARKER_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  5f48				   FUNCTION_NAME SET	WHITE_MARKER_on_WHITE_SQUARE_3
      7  5f48					      SUBROUTINE
      3  5f48		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  5f60		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  5f78		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$70,$70,$70,$70,$70,$00,$00,$00,$70,$70,$70,$70,$70,$00,$00	;PF2
------- FILE BANK_RECON.asm
    423  5f90
      0  5f90					      CHECK_BANK_SIZE	"BANK_RECON"
      1  5f90		       07 90	   .TEMP      =	* - BANK_START
 BANK_RECON (2K) SIZE =  $790 , FREE= $70
      2  5f90					      ECHO	"BANK_RECON", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5f90				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  5f90				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5f90				  -	      ERR
      6  5f90					      ENDIF
      7  5f90
    425  5f90
    426  5f90							; EOF
------- FILE ./chess.asm
    607  5f90
    608  5f90							; The handlers for piece move generation
------- FILE Handler_BANK1.asm LEVEL 2 PASS 5
      0  5f90					      include	"Handler_BANK1.asm"
      1  5f90							; Copyright (C)2020 Andrew Davie
      2  5f90
      3  5f90							;---------------------------------------------------------------------------------------------------
      4  5f90
      0  5f90					      NEWRAMBANK	BOARD	; RAM bank for holding the following ROM shadow
      1  5f90
      2  5f90
      3  5f90
      4 U2400 ????				      SEG.U	BOARD
      5 U2400					      ORG	ORIGIN_RAM
      6 U2400					      RORG	RAM_3E
      7 U2400				   BANK_START SET	*
      8 U2400				   RAMBANK_BOARD SET	ORIGIN_RAM / RAM_SIZE
      9 U2400				   _CURRENT_RAMBANK SET	RAMBANK_BOARD
     10 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U2400					      NEWBANK	MOVES	; copy the following bank to RAMBANK_BOARD
      1  6690 ????				      SEG	MOVES
      2  6000					      ORG	ORIGIN
      3  6000					      RORG	$F000
      4  6000				   BANK_START SET	*
      5  6000				   MOVES      SET	ORIGIN / 2048
      6  6000				   ORIGIN     SET	ORIGIN + 2048
      7  6000				   _CURRENT_BANK SET	MOVES
      7  6000
      8  6000							; Board is a 10 x 12 object which simplifies the generation of moves
      9  6000							; The squares marked '░░░' are illegal. The ("X12") index of each square is the left
     10  6000							; number + the bottom number. Bottom left legal square (AS VISIBLE ON SCREEN) is #22
     11  6000
     12  6000							;     X12 numbering
     13  6000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     14  6000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     15  6000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     16  6000							; 90 ┃░░░┊░░░┊ 92┊ 93┊ 94┊ 95┊ 96┊ 97┊ 98┊ 99┃ 8 BLACK
     17  6000							; 80 ┃░░░┊░░░┊ 82┊ 83┊ 84┊ 85┊ 86┊ 87┊ 88┊ 89┃ 7 BLACK
     18  6000							; 70 ┃░░░┊░░░┊ 72┊ 73┊ 74┊ 75┊ 76┊ 77┊ 78┊ 79┃ 6
     19  6000							; 60 ┃░░░┊░░░┊ 62┊ 63┊ 64┊ 65┊ 66┊ 67┊ 68┊ 69┃ 5
     20  6000							; 50 ┃░░░┊░░░┊ 52┊ 53┊ 54┊ 55┊ 56┊ 57┊ 58┊ 59┃ 4
     21  6000							; 40 ┃░░░┊░░░┊ 42┊ 43┊ 44┊ 45┊ 46┊ 47┊ 48┊ 49┃ 3
     22  6000							; 30 ┃░░░┊░░░┊ 32┊ 33┊ 34┊ 35┊ 36┊ 37┊ 38┊ 39┃ 2 WHITE
     23  6000							; 20 ┃░░░┊░░░┊ 22┊ 23┊ 24┊ 25┊ 26┊ 27┊ 28┊ 29┃ 1 WHITE
     24  6000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     25  6000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     26  6000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     27  6000							;	0   1	2   3	4   5	6   7	8   9
     28  6000							;		A   B	C   D	E   F	G   H
     29  6000
     30  6000							;     HEX X12
     31  6000							;    ┏━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┯━━━┓
     32  6000							;110 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     33  6000							;100 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     34  6000							; 90 ┃░░░┊░░░┊$5C┊$5D┊$5E┊$5F┊$60┊$61┊$62┊$63┃ 8
     35  6000							; 80 ┃░░░┊░░░┊$52┊$53┊$54┊$55┊$56┊$57┊$58┊$59┃ 7
     36  6000							; 70 ┃░░░┊░░░┊$48┊$49┊$4A┊$4B┊$4C┊$4D┊$4E┊$4F┃ 6
     37  6000							; 60 ┃░░░┊░░░┊$3E┊$3F┊$40┊$41┊$42┊$43┊$44┊$45┃ 5
     38  6000							; 50 ┃░░░┊░░░┊$34┊$35┊$36┊$37┊$38┊$39┊$3A┊$3B┃ 4
     39  6000							; 40 ┃░░░┊░░░┊$2A┊$2B┊$2C┊$2D┊$2E┊$2F┊$30┊$31┃ 3
     40  6000							; 30 ┃░░░┊░░░┊$20┊$21┊$22┊$23┊$24┊$25┊$26|$27┃ 2
     41  6000							; 20 ┃░░░┊░░░┊$16┊$17┊$18┊$19┊$1A┊$1B┊$1C┊$1D┃ 1
     42  6000							; 10 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     43  6000							;  0 ┃░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┊░░░┃
     44  6000							;    ┗━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┷━━━┛
     45  6000							;	0   1	2   3	4   5	6   7	8   9
     46  6000							;		A   B	C   D	E   F	G   H
     47  6000
     48  6000
     49  6000							; We put a short buffer before 'ValidSquare' when it is at the start of the bank, so that
     50  6000							; the move indexing (ie., "ValidSquare+{1},x" won't drop off the beginning of the bank
     51  6000							; and sause "segfaults". 21 is the max offset (a knight move). These spare bytes can
     52  6000							; be re-used for something else - we just need to guarantee there are 21 of them there
     53  6000
      0  6000					      ALLOCATE	Valid, 120 + 80 + 32	;21
      0  6000					      OPTIONAL_PAGEBREAK	"Table", 120 + 80 + 32
     12  6000					      LIST	ON
      0  6000					      DEF	Valid
      1  6000				   BANK_Valid SET	_CURRENT_BANK
      2  6000				   Valid
      3  6000				   TEMPORARY_VAR SET	Overlay
      4  6000				   TEMPORARY_OFFSET SET	0
      5  6000				   VAR_BOUNDARY_Valid SET	TEMPORARY_OFFSET
      6  6000				   FUNCTION_NAME SET	Valid
      7  6000					      SUBROUTINE
     55  6000							;ds 21 		     ; so indexing of "ValidSquare-21,x" won't fail
     56  6000
     57  6000							;DEF PieceList
     58  6000							;ds 16
     59  6000
     60  6000					      MAC	handlevec
     61  6000					      .byte	{1}MoveReturn
     62  6000					      .byte	{1}MoveReturn	;byte {1}Handle_WHITE_PAWN	   ; 1
     63  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_BLACK_PAWN	    ; 2
     64  6000					      .byte	{1}Handle_KNIGHT	; 3
     65  6000					      .byte	{1}Handle_BISHOP	; 4
     66  6000					      .byte	{1}Handle_ROOK	; 5
     67  6000					      .byte	{1}Handle_QUEEN	; 6
     68  6000					      .byte	{1}Handle_KING	; 7
     69  6000
     70  6000					      .byte	{1}MoveReturn
     71  6000					      .byte	{1}Handle_WHITE_PAWN	; 1
     72  6000					      .byte	{1}Handle_BLACK_PAWN	; 2
     73  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_KNIGHT	    ; 3
     74  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_BISHOP	    ; 4
     75  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_ROOK		    ; 5
     76  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_QUEEN 	    ; 6
     77  6000					      .byte	{1}MoveReturn	;.byte {1}Handle_KING		    ; 7
     78  6000					      ENDM
     79  6000
     80  6000
     81  6000							;ALLOCATE Handlers, 32
     82  6000
     83  6000							;    .byte 0	  ; dummy to prevent page cross access on index 0
     84  6000
      0  6000				   HandlerVectorLO HANDLEVEC	<
      1  6000		       2b		      .byte.b	<MoveReturn
      2  6001		       2b		      .byte.b	<MoveReturn
      3  6002		       2b		      .byte.b	<MoveReturn
      4  6003		       ad		      .byte.b	<Handle_KNIGHT
      5  6004		       f5		      .byte.b	<Handle_BISHOP
      6  6005		       70		      .byte.b	<Handle_ROOK
      7  6006		       02		      .byte.b	<Handle_QUEEN
      8  6007		       eb		      .byte.b	<Handle_KING
      9  6008
     10  6008		       2b		      .byte.b	<MoveReturn
     11  6009		       2e		      .byte.b	<Handle_WHITE_PAWN
     12  600a		       02		      .byte.b	<Handle_BLACK_PAWN
     13  600b		       2b		      .byte.b	<MoveReturn
     14  600c		       2b		      .byte.b	<MoveReturn
     15  600d		       2b		      .byte.b	<MoveReturn
     16  600e		       2b		      .byte.b	<MoveReturn
     17  600f		       2b		      .byte.b	<MoveReturn
      0  6010				   HandlerVectorHI HANDLEVEC	>
      1  6010		       f9		      .byte.b	>MoveReturn
      2  6011		       f9		      .byte.b	>MoveReturn
      3  6012		       f9		      .byte.b	>MoveReturn
      4  6013		       fb		      .byte.b	>Handle_KNIGHT
      5  6014		       f1		      .byte.b	>Handle_BISHOP
      6  6015		       f2		      .byte.b	>Handle_ROOK
      7  6016		       f1		      .byte.b	>Handle_QUEEN
      8  6017		       f2		      .byte.b	>Handle_KING
      9  6018
     10  6018		       f9		      .byte.b	>MoveReturn
     11  6019		       fa		      .byte.b	>Handle_WHITE_PAWN
     12  601a		       fb		      .byte.b	>Handle_BLACK_PAWN
     13  601b		       f9		      .byte.b	>MoveReturn
     14  601c		       f9		      .byte.b	>MoveReturn
     15  601d		       f9		      .byte.b	>MoveReturn
     16  601e		       f9		      .byte.b	>MoveReturn
     17  601f		       f9		      .byte.b	>MoveReturn
     87  6020
     88  6020
     89  6020							; Note, we will never index INTO the above bytes - x will always be >= 22
     90  6020							; We just need to make sure that the actual indexing will not have an address before
     91  6020							; the index of outside the page.
     92  6020
      0  6020					      DEF	ValidSquare
      1  6020				   BANK_ValidSquare SET	_CURRENT_BANK
      2  6020				   ValidSquare
      3  6020				   TEMPORARY_VAR SET	Overlay
      4  6020				   TEMPORARY_OFFSET SET	0
      5  6020				   VAR_BOUNDARY_ValidSquare SET	TEMPORARY_OFFSET
      6  6020				   FUNCTION_NAME SET	ValidSquare
      7  6020					      SUBROUTINE
     94  6020
     95  6020
     96  6020							; Use this table to
     97  6020							;   a) Determine if a square is valid (-1 = NO)
     98  6020							;   b) Move pieces without addition.  e.g., "lda ValidSquareTable+10,x" will let you know
     99  6020							;	if a white pawn on square "x" can move "up" the board.
    100  6020
    101  6020		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    102  602a		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    103  6034		       ff ff 16 17*	      .byte.b	-1, -1, 22, 23, 24, 25, 26, 27, 28, 29
    104  603e		       ff ff 20 21*	      .byte.b	-1, -1, 32, 33, 34, 35, 36, 37, 38, 39
    105  6048		       ff ff 2a 2b*	      .byte.b	-1, -1, 42, 43, 44, 45, 46, 47, 48, 49
    106  6052		       ff ff 34 35*	      .byte.b	-1, -1, 52, 53, 54, 55, 56, 57, 58, 59
    107  605c		       ff ff 3e 3f*	      .byte.b	-1, -1, 62, 63, 64, 65, 66, 67, 68, 69
    108  6066		       ff ff 48 49*	      .byte.b	-1, -1, 72, 73, 74, 75, 76, 77, 78, 79
    109  6070		       ff ff 52 53*	      .byte.b	-1, -1, 82, 83, 84, 85, 86, 87, 88, 89
    110  607a		       ff ff 5c 5d*	      .byte.b	-1, -1, 92, 93, 94, 95, 96, 97, 98, 99	; CONTINUES...
    111  6084
      0  6084					      DEF	Board
      1  6084				   BANK_Board SET	_CURRENT_BANK
      2  6084				   Board
      3  6084				   TEMPORARY_VAR SET	Overlay
      4  6084				   TEMPORARY_OFFSET SET	0
      5  6084				   VAR_BOUNDARY_Board SET	TEMPORARY_OFFSET
      6  6084				   FUNCTION_NAME SET	Board
      7  6084					      SUBROUTINE
    113  6084
    114  6084							; A 10X10... we should never write using invalid square
    115  6084							; ON COPY TO RAM BANK, 'BOARD' SELF-INITIALISES TO THE FOLLOWING VALUES
    116  6084							; FROM THEN ON IT'S WRITEABLE (REMEMBER TO +RAM_WRITE) FOR MODIFICATIONS
    117  6084
    118  6084		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
    119  608e		       ff ff ff ff*	      .byte.b	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1	; shared with above table
    120  6098
    121  6098					      REPEAT	8
    122  6098		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  6098					      REPEND
    122  60a2		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60a2					      REPEND
    122  60ac		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60ac					      REPEND
    122  60b6		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60b6					      REPEND
    122  60c0		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60c0					      REPEND
    122  60ca		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60ca					      REPEND
    122  60d4		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    121  60d4					      REPEND
    122  60de		       ff ff 00 00*	      .byte.b	-1, -1, 0, 0, 0, 0, 0, 0, 0, 0
    123  60e8					      REPEND
    124  60e8
    125  60e8							; DON'T OVERSTEP BOUNDS WHEN WRITING BOARD - MAXIMUM INDEX = 99
    126  60e8
    127  60e8
      0  60e8					      DEF	handleIt
      1  60e8				   BANK_handleIt SET	_CURRENT_BANK
      2  60e8				   handleIt
      3  60e8				   TEMPORARY_VAR SET	Overlay
      4  60e8				   TEMPORARY_OFFSET SET	0
      5  60e8				   VAR_BOUNDARY_handleIt SET	TEMPORARY_OFFSET
      6  60e8				   FUNCTION_NAME SET	handleIt
      7  60e8					      SUBROUTINE
    129  60e8					      SUBROUTINE
    130  60e8
    131  60e8
    132  60e8		       86 93		      stx	currentSquare
    133  60ea
    134  60ea		       45 96		      eor	sideToMove
    135  60ec		       29 ef		      and	#~FLAG_CASTLE	; todo: better part of the move, mmh?
    136  60ee		       85 92		      sta	currentPiece
    137  60f0		       29 0f		      and	#PIECE_MASK
    138  60f2		       05 b2		      ora	__pieceFilter
    139  60f4		       a8		      tay
    140  60f5
    141  60f5		       b9 10 f0 	      lda	HandlerVectorHI,y
    142  60f8		       85 af		      sta	__vector+1
    143  60fa		       b9 00 f0 	      lda	HandlerVectorLO,y
    144  60fd		       85 ae		      sta	__vector
    145  60ff		       6c ae 00 	      jmp	(__vector)
    146  6102
    147  6102
    148  6102							;---------------------------------------------------------------------------------------------------
    149  6102
------- FILE Handler_QUEEN.asm LEVEL 3 PASS 5
      0  6102					      include	"Handler_QUEEN.asm"
      1  6102							; Copyright (C)2020 Andrew Davie
      2  6102
      3  6102							;---------------------------------------------------------------------------------------------------
      4  6102							; QUEEN
      5  6102							;---------------------------------------------------------------------------------------------------
      6  6102
      0  6102					      DEF	Handle_QUEEN
      1  6102				   BANK_Handle_QUEEN SET	_CURRENT_BANK
      2  6102				   Handle_QUEEN
      3  6102				   TEMPORARY_VAR SET	Overlay
      4  6102				   TEMPORARY_OFFSET SET	0
      5  6102				   VAR_BOUNDARY_Handle_QUEEN SET	TEMPORARY_OFFSET
      6  6102				   FUNCTION_NAME SET	Handle_QUEEN
      7  6102					      SUBROUTINE
      8  6102					      SUBROUTINE
      9  6102
      0  6102					      REFER	GenerateAllMoves
      1  6102					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6102				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6102					      ENDIF
      0  6102					      VEND	Handle_QUEEN
      1  6102				  -	      IFNCONST	Handle_QUEEN
      2  6102				  -	      ECHO	"Incorrect VEND label", Handle_QUEEN
      3  6102				  -	      ERR
      4  6102					      ENDIF
      5  6102		       00 b3	   VAREND_Handle_QUEEN =	TEMPORARY_VAR
     12  6102
     13  6102							; Pass...
     14  6102							; x = currentSquare (square the piece is on)
     15  6102							; currentPiece (with flags/colour attached)
     16  6102
      0  6102					      MOVE_TOWARDS	_DOWN+_LEFT
      1  6102					      SUBROUTINE
      2  6102
      3  6102
      4  6102
      5  6102		       a9 00		      lda	#0
      6  6104		       85 9e		      sta	capture
      7  6106
      8  6106		       a6 93		      ldx	currentSquare
      9  6108		       d0 03		      bne	.project
     10  610a
     11  610a		       20 56 fc    .empty     jsr	AddMove
     12  610d		       bc 15 f0    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6110		       30 0e		      bmi	.invalid
     14  6112		       b9 84 f0 	      lda	Board,y
     15  6115		       f0 f3		      beq	.empty
     16  6117		       85 9e		      sta	capture
     17  6119		       45 92		      eor	currentPiece
     18  611b		       10 03		      bpl	.invalid
     19  611d		       20 56 fc 	      jsr	AddMove
     20  6120
     21  6120				   .invalid
      0  6120					      MOVE_TOWARDS	_DOWN
      1  6120					      SUBROUTINE
      2  6120
      3  6120
      4  6120
      5  6120		       a9 00		      lda	#0
      6  6122		       85 9e		      sta	capture
      7  6124
      8  6124		       a6 93		      ldx	currentSquare
      9  6126		       d0 03		      bne	.project
     10  6128
     11  6128		       20 56 fc    .empty     jsr	AddMove
     12  612b		       bc 16 f0    .project   ldy	ValidSquare+_DOWN,x
     13  612e		       30 0e		      bmi	.invalid
     14  6130		       b9 84 f0 	      lda	Board,y
     15  6133		       f0 f3		      beq	.empty
     16  6135		       85 9e		      sta	capture
     17  6137		       45 92		      eor	currentPiece
     18  6139		       10 03		      bpl	.invalid
     19  613b		       20 56 fc 	      jsr	AddMove
     20  613e
     21  613e				   .invalid
      0  613e					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  613e					      SUBROUTINE
      2  613e
      3  613e
      4  613e
      5  613e		       a9 00		      lda	#0
      6  6140		       85 9e		      sta	capture
      7  6142
      8  6142		       a6 93		      ldx	currentSquare
      9  6144		       d0 03		      bne	.project
     10  6146
     11  6146		       20 56 fc    .empty     jsr	AddMove
     12  6149		       bc 17 f0    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  614c		       30 0e		      bmi	.invalid
     14  614e		       b9 84 f0 	      lda	Board,y
     15  6151		       f0 f3		      beq	.empty
     16  6153		       85 9e		      sta	capture
     17  6155		       45 92		      eor	currentPiece
     18  6157		       10 03		      bpl	.invalid
     19  6159		       20 56 fc 	      jsr	AddMove
     20  615c
     21  615c				   .invalid
      0  615c					      MOVE_TOWARDS	_RIGHT
      1  615c					      SUBROUTINE
      2  615c
      3  615c
      4  615c
      5  615c		       a9 00		      lda	#0
      6  615e		       85 9e		      sta	capture
      7  6160
      8  6160		       a6 93		      ldx	currentSquare
      9  6162		       d0 03		      bne	.project
     10  6164
     11  6164		       20 56 fc    .empty     jsr	AddMove
     12  6167		       bc 21 f0    .project   ldy	ValidSquare+_RIGHT,x
     13  616a		       30 0e		      bmi	.invalid
     14  616c		       b9 84 f0 	      lda	Board,y
     15  616f		       f0 f3		      beq	.empty
     16  6171		       85 9e		      sta	capture
     17  6173		       45 92		      eor	currentPiece
     18  6175		       10 03		      bpl	.invalid
     19  6177		       20 56 fc 	      jsr	AddMove
     20  617a
     21  617a				   .invalid
      0  617a					      MOVE_TOWARDS	_UP+_RIGHT
      1  617a					      SUBROUTINE
      2  617a
      3  617a
      4  617a
      5  617a		       a9 00		      lda	#0
      6  617c		       85 9e		      sta	capture
      7  617e
      8  617e		       a6 93		      ldx	currentSquare
      9  6180		       d0 03		      bne	.project
     10  6182
     11  6182		       20 56 fc    .empty     jsr	AddMove
     12  6185		       bc 2b f0    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  6188		       30 0e		      bmi	.invalid
     14  618a		       b9 84 f0 	      lda	Board,y
     15  618d		       f0 f3		      beq	.empty
     16  618f		       85 9e		      sta	capture
     17  6191		       45 92		      eor	currentPiece
     18  6193		       10 03		      bpl	.invalid
     19  6195		       20 56 fc 	      jsr	AddMove
     20  6198
     21  6198				   .invalid
      0  6198					      MOVE_TOWARDS	_UP
      1  6198					      SUBROUTINE
      2  6198
      3  6198
      4  6198
      5  6198		       a9 00		      lda	#0
      6  619a		       85 9e		      sta	capture
      7  619c
      8  619c		       a6 93		      ldx	currentSquare
      9  619e		       d0 03		      bne	.project
     10  61a0
     11  61a0		       20 56 fc    .empty     jsr	AddMove
     12  61a3		       bc 2a f0    .project   ldy	ValidSquare+_UP,x
     13  61a6		       30 0e		      bmi	.invalid
     14  61a8		       b9 84 f0 	      lda	Board,y
     15  61ab		       f0 f3		      beq	.empty
     16  61ad		       85 9e		      sta	capture
     17  61af		       45 92		      eor	currentPiece
     18  61b1		       10 03		      bpl	.invalid
     19  61b3		       20 56 fc 	      jsr	AddMove
     20  61b6
     21  61b6				   .invalid
      0  61b6					      MOVE_TOWARDS	_UP+_LEFT
      1  61b6					      SUBROUTINE
      2  61b6
      3  61b6
      4  61b6
      5  61b6		       a9 00		      lda	#0
      6  61b8		       85 9e		      sta	capture
      7  61ba
      8  61ba		       a6 93		      ldx	currentSquare
      9  61bc		       d0 03		      bne	.project
     10  61be
     11  61be		       20 56 fc    .empty     jsr	AddMove
     12  61c1		       bc 29 f0    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  61c4		       30 0e		      bmi	.invalid
     14  61c6		       b9 84 f0 	      lda	Board,y
     15  61c9		       f0 f3		      beq	.empty
     16  61cb		       85 9e		      sta	capture
     17  61cd		       45 92		      eor	currentPiece
     18  61cf		       10 03		      bpl	.invalid
     19  61d1		       20 56 fc 	      jsr	AddMove
     20  61d4
     21  61d4				   .invalid
      0  61d4					      MOVE_TOWARDS	_LEFT
      1  61d4					      SUBROUTINE
      2  61d4
      3  61d4
      4  61d4
      5  61d4		       a9 00		      lda	#0
      6  61d6		       85 9e		      sta	capture
      7  61d8
      8  61d8		       a6 93		      ldx	currentSquare
      9  61da		       d0 03		      bne	.project
     10  61dc
     11  61dc		       20 56 fc    .empty     jsr	AddMove
     12  61df		       bc 1f f0    .project   ldy	ValidSquare+_LEFT,x
     13  61e2		       30 0e		      bmi	.invalid
     14  61e4		       b9 84 f0 	      lda	Board,y
     15  61e7		       f0 f3		      beq	.empty
     16  61e9		       85 9e		      sta	capture
     17  61eb		       45 92		      eor	currentPiece
     18  61ed		       10 03		      bpl	.invalid
     19  61ef		       20 56 fc 	      jsr	AddMove
     20  61f2
     21  61f2				   .invalid
     25  61f2
     26  61f2		       4c 2b f9 	      jmp	MoveReturn
     27  61f5
     28  61f5							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_BISHOP.asm LEVEL 3 PASS 5
      0  61f5					      include	"Handler_BISHOP.asm"
      1  61f5							; Copyright (C)2020 Andrew Davie
      2  61f5
      3  61f5							;---------------------------------------------------------------------------------------------------
      4  61f5							; BISHOP
      5  61f5							;---------------------------------------------------------------------------------------------------
      6  61f5
      0  61f5					      DEF	Handle_BISHOP
      1  61f5				   BANK_Handle_BISHOP SET	_CURRENT_BANK
      2  61f5				   Handle_BISHOP
      3  61f5				   TEMPORARY_VAR SET	Overlay
      4  61f5				   TEMPORARY_OFFSET SET	0
      5  61f5				   VAR_BOUNDARY_Handle_BISHOP SET	TEMPORARY_OFFSET
      6  61f5				   FUNCTION_NAME SET	Handle_BISHOP
      7  61f5					      SUBROUTINE
      8  61f5					      SUBROUTINE
      9  61f5
      0  61f5					      REFER	GenerateAllMoves
      1  61f5					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  61f5				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  61f5					      ENDIF
      0  61f5					      VEND	Handle_BISHOP
      1  61f5				  -	      IFNCONST	Handle_BISHOP
      2  61f5				  -	      ECHO	"Incorrect VEND label", Handle_BISHOP
      3  61f5				  -	      ERR
      4  61f5					      ENDIF
      5  61f5		       00 b3	   VAREND_Handle_BISHOP =	TEMPORARY_VAR
     12  61f5
     13  61f5							; x = currentSquare (square the piece is on)
     14  61f5							; currentPiece (with flags/colour attached)
     15  61f5
      0  61f5					      MOVE_TOWARDS	_DOWN+_LEFT
      1  61f5					      SUBROUTINE
      2  61f5
      3  61f5
      4  61f5
      5  61f5		       a9 00		      lda	#0
      6  61f7		       85 9e		      sta	capture
      7  61f9
      8  61f9		       a6 93		      ldx	currentSquare
      9  61fb		       d0 03		      bne	.project
     10  61fd
     11  61fd		       20 56 fc    .empty     jsr	AddMove
     12  6200		       bc 15 f0    .project   ldy	ValidSquare+_DOWN+_LEFT,x
     13  6203		       30 0e		      bmi	.invalid
     14  6205		       b9 84 f0 	      lda	Board,y
     15  6208		       f0 f3		      beq	.empty
     16  620a		       85 9e		      sta	capture
     17  620c		       45 92		      eor	currentPiece
     18  620e		       10 03		      bpl	.invalid
     19  6210		       20 56 fc 	      jsr	AddMove
     20  6213
     21  6213				   .invalid
      0  6213					      MOVE_TOWARDS	_DOWN+_RIGHT
      1  6213					      SUBROUTINE
      2  6213
      3  6213
      4  6213
      5  6213		       a9 00		      lda	#0
      6  6215		       85 9e		      sta	capture
      7  6217
      8  6217		       a6 93		      ldx	currentSquare
      9  6219		       d0 03		      bne	.project
     10  621b
     11  621b		       20 56 fc    .empty     jsr	AddMove
     12  621e		       bc 17 f0    .project   ldy	ValidSquare+_DOWN+_RIGHT,x
     13  6221		       30 0e		      bmi	.invalid
     14  6223		       b9 84 f0 	      lda	Board,y
     15  6226		       f0 f3		      beq	.empty
     16  6228		       85 9e		      sta	capture
     17  622a		       45 92		      eor	currentPiece
     18  622c		       10 03		      bpl	.invalid
     19  622e		       20 56 fc 	      jsr	AddMove
     20  6231
     21  6231				   .invalid
      0  6231					      MOVE_TOWARDS	_UP+_LEFT
      1  6231					      SUBROUTINE
      2  6231
      3  6231
      4  6231
      5  6231		       a9 00		      lda	#0
      6  6233		       85 9e		      sta	capture
      7  6235
      8  6235		       a6 93		      ldx	currentSquare
      9  6237		       d0 03		      bne	.project
     10  6239
     11  6239		       20 56 fc    .empty     jsr	AddMove
     12  623c		       bc 29 f0    .project   ldy	ValidSquare+_UP+_LEFT,x
     13  623f		       30 0e		      bmi	.invalid
     14  6241		       b9 84 f0 	      lda	Board,y
     15  6244		       f0 f3		      beq	.empty
     16  6246		       85 9e		      sta	capture
     17  6248		       45 92		      eor	currentPiece
     18  624a		       10 03		      bpl	.invalid
     19  624c		       20 56 fc 	      jsr	AddMove
     20  624f
     21  624f				   .invalid
      0  624f					      MOVE_TOWARDS	_UP+_RIGHT
      1  624f					      SUBROUTINE
      2  624f
      3  624f
      4  624f
      5  624f		       a9 00		      lda	#0
      6  6251		       85 9e		      sta	capture
      7  6253
      8  6253		       a6 93		      ldx	currentSquare
      9  6255		       d0 03		      bne	.project
     10  6257
     11  6257		       20 56 fc    .empty     jsr	AddMove
     12  625a		       bc 2b f0    .project   ldy	ValidSquare+_UP+_RIGHT,x
     13  625d		       30 0e		      bmi	.invalid
     14  625f		       b9 84 f0 	      lda	Board,y
     15  6262		       f0 f3		      beq	.empty
     16  6264		       85 9e		      sta	capture
     17  6266		       45 92		      eor	currentPiece
     18  6268		       10 03		      bpl	.invalid
     19  626a		       20 56 fc 	      jsr	AddMove
     20  626d
     21  626d				   .invalid
     20  626d
     21  626d		       4c 2b f9 	      jmp	MoveReturn
     22  6270
     23  6270							;---------------------------------------------------------------------------------------------------
     24  6270							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_ROOK.asm LEVEL 3 PASS 5
      0  6270					      include	"Handler_ROOK.asm"
      1  6270							; Copyright (C)2020 Andrew Davie
      2  6270							; Rook move handler
      3  6270
      4  6270							;---------------------------------------------------------------------------------------------------
      5  6270							; ROOK
      6  6270							;---------------------------------------------------------------------------------------------------
      7  6270
      0  6270					      DEF	Handle_ROOK
      1  6270				   BANK_Handle_ROOK SET	_CURRENT_BANK
      2  6270				   Handle_ROOK
      3  6270				   TEMPORARY_VAR SET	Overlay
      4  6270				   TEMPORARY_OFFSET SET	0
      5  6270				   VAR_BOUNDARY_Handle_ROOK SET	TEMPORARY_OFFSET
      6  6270				   FUNCTION_NAME SET	Handle_ROOK
      7  6270					      SUBROUTINE
      9  6270					      SUBROUTINE
     10  6270
      0  6270					      REFER	GenerateAllMoves
      1  6270					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6270				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6270					      ENDIF
      0  6270					      VEND	Handle_ROOK
      1  6270				  -	      IFNCONST	Handle_ROOK
      2  6270				  -	      ECHO	"Incorrect VEND label", Handle_ROOK
      3  6270				  -	      ERR
      4  6270					      ENDIF
      5  6270		       00 b3	   VAREND_Handle_ROOK =	TEMPORARY_VAR
     13  6270
     14  6270							; Pass...
     15  6270							; x = currentSquare (square the piece is on)
     16  6270							; currentPiece (with flags/colour attached)
     17  6270
      0  6270					      MOVE_TOWARDS	_DOWN
      1  6270					      SUBROUTINE
      2  6270
      3  6270
      4  6270
      5  6270		       a9 00		      lda	#0
      6  6272		       85 9e		      sta	capture
      7  6274
      8  6274		       a6 93		      ldx	currentSquare
      9  6276		       d0 03		      bne	.project
     10  6278
     11  6278		       20 56 fc    .empty     jsr	AddMove
     12  627b		       bc 16 f0    .project   ldy	ValidSquare+_DOWN,x
     13  627e		       30 0e		      bmi	.invalid
     14  6280		       b9 84 f0 	      lda	Board,y
     15  6283		       f0 f3		      beq	.empty
     16  6285		       85 9e		      sta	capture
     17  6287		       45 92		      eor	currentPiece
     18  6289		       10 03		      bpl	.invalid
     19  628b		       20 56 fc 	      jsr	AddMove
     20  628e
     21  628e				   .invalid
      0  628e					      MOVE_TOWARDS	_RIGHT
      1  628e					      SUBROUTINE
      2  628e
      3  628e
      4  628e
      5  628e		       a9 00		      lda	#0
      6  6290		       85 9e		      sta	capture
      7  6292
      8  6292		       a6 93		      ldx	currentSquare
      9  6294		       d0 03		      bne	.project
     10  6296
     11  6296		       20 56 fc    .empty     jsr	AddMove
     12  6299		       bc 21 f0    .project   ldy	ValidSquare+_RIGHT,x
     13  629c		       30 0e		      bmi	.invalid
     14  629e		       b9 84 f0 	      lda	Board,y
     15  62a1		       f0 f3		      beq	.empty
     16  62a3		       85 9e		      sta	capture
     17  62a5		       45 92		      eor	currentPiece
     18  62a7		       10 03		      bpl	.invalid
     19  62a9		       20 56 fc 	      jsr	AddMove
     20  62ac
     21  62ac				   .invalid
      0  62ac					      MOVE_TOWARDS	_UP
      1  62ac					      SUBROUTINE
      2  62ac
      3  62ac
      4  62ac
      5  62ac		       a9 00		      lda	#0
      6  62ae		       85 9e		      sta	capture
      7  62b0
      8  62b0		       a6 93		      ldx	currentSquare
      9  62b2		       d0 03		      bne	.project
     10  62b4
     11  62b4		       20 56 fc    .empty     jsr	AddMove
     12  62b7		       bc 2a f0    .project   ldy	ValidSquare+_UP,x
     13  62ba		       30 0e		      bmi	.invalid
     14  62bc		       b9 84 f0 	      lda	Board,y
     15  62bf		       f0 f3		      beq	.empty
     16  62c1		       85 9e		      sta	capture
     17  62c3		       45 92		      eor	currentPiece
     18  62c5		       10 03		      bpl	.invalid
     19  62c7		       20 56 fc 	      jsr	AddMove
     20  62ca
     21  62ca				   .invalid
      0  62ca					      MOVE_TOWARDS	_LEFT
      1  62ca					      SUBROUTINE
      2  62ca
      3  62ca
      4  62ca
      5  62ca		       a9 00		      lda	#0
      6  62cc		       85 9e		      sta	capture
      7  62ce
      8  62ce		       a6 93		      ldx	currentSquare
      9  62d0		       d0 03		      bne	.project
     10  62d2
     11  62d2		       20 56 fc    .empty     jsr	AddMove
     12  62d5		       bc 1f f0    .project   ldy	ValidSquare+_LEFT,x
     13  62d8		       30 0e		      bmi	.invalid
     14  62da		       b9 84 f0 	      lda	Board,y
     15  62dd		       f0 f3		      beq	.empty
     16  62df		       85 9e		      sta	capture
     17  62e1		       45 92		      eor	currentPiece
     18  62e3		       10 03		      bpl	.invalid
     19  62e5		       20 56 fc 	      jsr	AddMove
     20  62e8
     21  62e8				   .invalid
     22  62e8
     23  62e8		       4c 2b f9 	      jmp	MoveReturn
     24  62eb
     25  62eb							;---------------------------------------------------------------------------------------------------
     26  62eb							; EOF
------- FILE Handler_BANK1.asm
------- FILE Handler_KING.asm LEVEL 3 PASS 5
      0  62eb					      include	"Handler_KING.asm"
      1  62eb							; Copyright (C)2020 Andrew Davie
      2  62eb
      3  62eb							;---------------------------------------------------------------------------------------------------
      4  62eb							; KING
      5  62eb							; This is the move handler for a KING
      6  62eb							; "Check" is detected in the next ply of the search.
      7  62eb
      8  62eb
      9  62eb							;---------------------------------------------------------------------------------------------------
     10  62eb
     11  62eb							; MACRO - Castling
     12  62eb
     13  62eb		       00 03	   KINGSIDE   =	3
     14  62eb		       ff ff ff fc QUEENSIDE  =	-4
     15  62eb
     16  62eb					      MAC	castle
     17  62eb							; {1} = "KINGSIDE" or "QUEENSIDE"
     18  62eb
     19  62eb					      ldx	currentSquare
     20  62eb					      lda	Board+{1},x	; kingside/queenside R position
     21  62eb					      and	#PIECE_MASK|FLAG_MOVED
     22  62eb					      cmp	#ROOK
     23  62eb					      bne	.noCastle	; not a R that hasn't moved
     24  62eb
     25  62eb							; It's a R and it *HAS* to be correct colour because it hasn't moved!
     26  62eb							; AND the K hasn't moved (earlier check), so check for vacant squares between K and R
     27  62eb
     28  62eb					      IF	{1} = QUEENSIDE
     29  62eb					      lda	Board-3,x	; N pos
     30  62eb					      ora	Board-2,x	; B pos
     31  62eb					      ora	Board-1,x	; Q pos
     32  62eb					      bne	.noCastle	; not vacant?
     33  62eb
     34  62eb					      ENDIF
     35  62eb
     36  62eb					      IF	{1} = KINGSIDE
     37  62eb					      lda	Board+2,x	; N pos
     38  62eb					      ora	Board+1,x	; B pos
     39  62eb					      bne	.noCastle	; not vacant?
     40  62eb					      ENDIF
     41  62eb
     42  62eb							; appropriate N/B/(Q) squares are vacant so we proceed...
     43  62eb
     44  62eb							; FINALLY -- king can castle
     45  62eb							; note: when we actually DO the move we MUST insert "Phantom" kings onto the board over the
     46  62eb							; squares the king traverses so that "check" (and thus illegal moves) can be detected on the
     47  62eb							; next move. Castling will be detected by K moving > 1 square. (TODO: FIX?? not CASTLE flag??)
     48  62eb
     49  62eb					      lda	currentPiece
     50  62eb					      ora	#FLAG_CASTLE	; flag it's a castling move
     51  62eb					      sta	currentPiece
     52  62eb
     53  62eb					      IF	{1} = KINGSIDE
     54  62eb					      ldy	ValidSquare+2,x
     55  62eb					      ENDIF
     56  62eb
     57  62eb					      IF	{1} = QUEENSIDE
     58  62eb					      ldy	ValidSquare-2,x
     59  62eb					      ENDIF
     60  62eb
     61  62eb					      jsr	AddMove	; 57
     62  62eb
     63  62eb				   .noCastle
     64  62eb					      ENDM
     65  62eb
     66  62eb
     67  62eb							;---------------------------------------------------------------------------------------------------
     68  62eb
      0  62eb					      DEF	Handle_KING
      1  62eb				   BANK_Handle_KING SET	_CURRENT_BANK
      2  62eb				   Handle_KING
      3  62eb				   TEMPORARY_VAR SET	Overlay
      4  62eb				   TEMPORARY_OFFSET SET	0
      5  62eb				   VAR_BOUNDARY_Handle_KING SET	TEMPORARY_OFFSET
      6  62eb				   FUNCTION_NAME SET	Handle_KING
      7  62eb					      SUBROUTINE
     70  62eb					      SUBROUTINE
     71  62eb
      0  62eb					      REFER	GenerateAllMoves
      1  62eb					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  62eb				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  62eb					      ENDIF
      0  62eb					      VEND	Handle_KING
      1  62eb				  -	      IFNCONST	Handle_KING
      2  62eb				  -	      ECHO	"Incorrect VEND label", Handle_KING
      3  62eb				  -	      ERR
      4  62eb					      ENDIF
      5  62eb		       00 b3	   VAREND_Handle_KING =	TEMPORARY_VAR
     74  62eb
     75  62eb							; x = currentSquare (square the KING is on)
     76  62eb							; currentPiece (KING of course, but with flags/colour attached)
     77  62eb
      0  62eb					      MOVE_TO	_DOWN+_LEFT
      1  62eb					      SUBROUTINE
      2  62eb		       bc 15 f0 	      ldy	ValidSquare+_DOWN+_LEFT,x
      3  62ee		       30 0e		      bmi	.invalid
      4  62f0		       b9 84 f0 	      lda	Board,y
      5  62f3		       85 9e		      sta	capture
      6  62f5		       f0 04		      beq	.squareEmpty
      7  62f7		       45 92		      eor	currentPiece
      8  62f9		       10 03		      bpl	.invalid
      9  62fb		       20 56 fc    .squareEmpty jsr	AddMove
     10  62fe				   .invalid
      0  62fe					      MOVE_TO_X	_DOWN
      1  62fe		       a6 93		      ldx	currentSquare
      0  6300					      MOVE_TO	_DOWN
      1  6300					      SUBROUTINE
      2  6300		       bc 16 f0 	      ldy	ValidSquare+_DOWN,x
      3  6303		       30 0e		      bmi	.invalid
      4  6305		       b9 84 f0 	      lda	Board,y
      5  6308		       85 9e		      sta	capture
      6  630a		       f0 04		      beq	.squareEmpty
      7  630c		       45 92		      eor	currentPiece
      8  630e		       10 03		      bpl	.invalid
      9  6310		       20 56 fc    .squareEmpty jsr	AddMove
     10  6313				   .invalid
      0  6313					      MOVE_TO_X	_DOWN+_RIGHT
      1  6313		       a6 93		      ldx	currentSquare
      0  6315					      MOVE_TO	_DOWN+_RIGHT
      1  6315					      SUBROUTINE
      2  6315		       bc 17 f0 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      3  6318		       30 0e		      bmi	.invalid
      4  631a		       b9 84 f0 	      lda	Board,y
      5  631d		       85 9e		      sta	capture
      6  631f		       f0 04		      beq	.squareEmpty
      7  6321		       45 92		      eor	currentPiece
      8  6323		       10 03		      bpl	.invalid
      9  6325		       20 56 fc    .squareEmpty jsr	AddMove
     10  6328				   .invalid
      0  6328					      MOVE_TO_X	_RIGHT
      1  6328		       a6 93		      ldx	currentSquare
      0  632a					      MOVE_TO	_RIGHT
      1  632a					      SUBROUTINE
      2  632a		       bc 21 f0 	      ldy	ValidSquare+_RIGHT,x
      3  632d		       30 0e		      bmi	.invalid
      4  632f		       b9 84 f0 	      lda	Board,y
      5  6332		       85 9e		      sta	capture
      6  6334		       f0 04		      beq	.squareEmpty
      7  6336		       45 92		      eor	currentPiece
      8  6338		       10 03		      bpl	.invalid
      9  633a		       20 56 fc    .squareEmpty jsr	AddMove
     10  633d				   .invalid
      0  633d					      MOVE_TO_X	_UP+_RIGHT
      1  633d		       a6 93		      ldx	currentSquare
      0  633f					      MOVE_TO	_UP+_RIGHT
      1  633f					      SUBROUTINE
      2  633f		       bc 2b f0 	      ldy	ValidSquare+_UP+_RIGHT,x
      3  6342		       30 0e		      bmi	.invalid
      4  6344		       b9 84 f0 	      lda	Board,y
      5  6347		       85 9e		      sta	capture
      6  6349		       f0 04		      beq	.squareEmpty
      7  634b		       45 92		      eor	currentPiece
      8  634d		       10 03		      bpl	.invalid
      9  634f		       20 56 fc    .squareEmpty jsr	AddMove
     10  6352				   .invalid
      0  6352					      MOVE_TO_X	_UP
      1  6352		       a6 93		      ldx	currentSquare
      0  6354					      MOVE_TO	_UP
      1  6354					      SUBROUTINE
      2  6354		       bc 2a f0 	      ldy	ValidSquare+_UP,x
      3  6357		       30 0e		      bmi	.invalid
      4  6359		       b9 84 f0 	      lda	Board,y
      5  635c		       85 9e		      sta	capture
      6  635e		       f0 04		      beq	.squareEmpty
      7  6360		       45 92		      eor	currentPiece
      8  6362		       10 03		      bpl	.invalid
      9  6364		       20 56 fc    .squareEmpty jsr	AddMove
     10  6367				   .invalid
      0  6367					      MOVE_TO_X	_UP+_LEFT
      1  6367		       a6 93		      ldx	currentSquare
      0  6369					      MOVE_TO	_UP+_LEFT
      1  6369					      SUBROUTINE
      2  6369		       bc 29 f0 	      ldy	ValidSquare+_UP+_LEFT,x
      3  636c		       30 0e		      bmi	.invalid
      4  636e		       b9 84 f0 	      lda	Board,y
      5  6371		       85 9e		      sta	capture
      6  6373		       f0 04		      beq	.squareEmpty
      7  6375		       45 92		      eor	currentPiece
      8  6377		       10 03		      bpl	.invalid
      9  6379		       20 56 fc    .squareEmpty jsr	AddMove
     10  637c				   .invalid
      0  637c					      MOVE_TO_X	_LEFT
      1  637c		       a6 93		      ldx	currentSquare
      0  637e					      MOVE_TO	_LEFT
      1  637e					      SUBROUTINE
      2  637e		       bc 1f f0 	      ldy	ValidSquare+_LEFT,x
      3  6381		       30 0e		      bmi	.invalid
      4  6383		       b9 84 f0 	      lda	Board,y
      5  6386		       85 9e		      sta	capture
      6  6388		       f0 04		      beq	.squareEmpty
      7  638a		       45 92		      eor	currentPiece
      8  638c		       10 03		      bpl	.invalid
      9  638e		       20 56 fc    .squareEmpty jsr	AddMove
     10  6391				   .invalid
     86  6391
     87  6391							;IF CASTLING_ENABLED
     88  6391
     89  6391		       24 92		      bit	currentPiece
     90  6393		       70 41		      bvs	.exit	; king has moved, so no castling
     91  6395
      0  6395					      CASTLE	KINGSIDE
      1  6395
      2  6395
      3  6395		       a6 93		      ldx	currentSquare
      4  6397		       bd 87 f0 	      lda	Board+KINGSIDE,x
      5  639a		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  639c		       c9 05		      cmp	#ROOK
      7  639e		       d0 14		      bne	.noCastle
      8  63a0
      9  63a0
     10  63a0
     11  63a0
     12  63a0				  -	      IF	KINGSIDE = QUEENSIDE
     13  63a0				  -	      lda	Board-3,x
     14  63a0				  -	      ora	Board-2,x
     15  63a0				  -	      ora	Board-1,x
     16  63a0				  -	      bne	.noCastle
     17  63a0				  -
     18  63a0					      ENDIF
     19  63a0
     20  63a0					      IF	KINGSIDE = KINGSIDE
     21  63a0		       bd 86 f0 	      lda	Board+2,x
     22  63a3		       1d 85 f0 	      ora	Board+1,x
     23  63a6		       d0 0c		      bne	.noCastle
     24  63a8					      ENDIF
     25  63a8
     26  63a8
     27  63a8
     28  63a8
     29  63a8
     30  63a8
     31  63a8
     32  63a8
     33  63a8		       a5 92		      lda	currentPiece
     34  63aa		       09 10		      ora	#FLAG_CASTLE
     35  63ac		       85 92		      sta	currentPiece
     36  63ae
     37  63ae					      IF	KINGSIDE = KINGSIDE
     38  63ae		       bc 22 f0 	      ldy	ValidSquare+2,x
     39  63b1					      ENDIF
     40  63b1
     41  63b1				  -	      IF	KINGSIDE = QUEENSIDE
     42  63b1				  -	      ldy	ValidSquare-2,x
     43  63b1					      ENDIF
     44  63b1
     45  63b1		       20 56 fc 	      jsr	AddMove
     46  63b4
     47  63b4				   .noCastle
      0  63b4					      CASTLE	QUEENSIDE
      1  63b4
      2  63b4
      3  63b4		       a6 93		      ldx	currentSquare
      4  63b6		       bd 80 f0 	      lda	Board+QUEENSIDE,x
      5  63b9		       29 4f		      and	#PIECE_MASK|FLAG_MOVED
      6  63bb		       c9 05		      cmp	#ROOK
      7  63bd		       d0 17		      bne	.noCastle
      8  63bf
      9  63bf
     10  63bf
     11  63bf
     12  63bf					      IF	QUEENSIDE = QUEENSIDE
     13  63bf		       bd 81 f0 	      lda	Board-3,x
     14  63c2		       1d 82 f0 	      ora	Board-2,x
     15  63c5		       1d 83 f0 	      ora	Board-1,x
     16  63c8		       d0 0c		      bne	.noCastle
     17  63ca
     18  63ca					      ENDIF
     19  63ca
     20  63ca				  -	      IF	QUEENSIDE = KINGSIDE
     21  63ca				  -	      lda	Board+2,x
     22  63ca				  -	      ora	Board+1,x
     23  63ca				  -	      bne	.noCastle
     24  63ca					      ENDIF
     25  63ca
     26  63ca
     27  63ca
     28  63ca
     29  63ca
     30  63ca
     31  63ca
     32  63ca
     33  63ca		       a5 92		      lda	currentPiece
     34  63cc		       09 10		      ora	#FLAG_CASTLE
     35  63ce		       85 92		      sta	currentPiece
     36  63d0
     37  63d0				  -	      IF	QUEENSIDE = KINGSIDE
     38  63d0				  -	      ldy	ValidSquare+2,x
     39  63d0					      ENDIF
     40  63d0
     41  63d0					      IF	QUEENSIDE = QUEENSIDE
     42  63d0		       bc 1e f0 	      ldy	ValidSquare-2,x
     43  63d3					      ENDIF
     44  63d3
     45  63d3		       20 56 fc 	      jsr	AddMove
     46  63d6
     47  63d6				   .noCastle
     94  63d6
     95  63d6							;ENDIF
     96  63d6
     97  63d6		       4c 2b f9    .exit      jmp	MoveReturn
     98  63d9
     99  63d9							;---------------------------------------------------------------------------------------------------
    100  63d9							; EOF
------- FILE Handler_BANK1.asm
    154  63d9
    155  63d9							;---------------------------------------------------------------------------------------------------
    156  63d9
      0  63d9					      CHECK_HALF_BANK_SIZE	"HANDLER_BANK1 -- 1K"
      1  63d9
      2  63d9
      3  63d9		       03 d9	   .TEMP      =	* - BANK_START
 HANDLER_BANK1 -- 1K (1K) SIZE =  $3d9 , FREE= $27
      4  63d9					      ECHO	"HANDLER_BANK1 -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  63d9				  -	      IF	( .TEMP ) > ROM_BANK_SIZE/2
      6  63d9				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  63d9				  -	      ERR
      8  63d9					      ENDIF
    158  63d9
    159  63d9
    160  63d9							; There is space here (1K) for use as ROM
    161  63d9							; but NOT when the above bank is switched in as RAM, of course!
    162  63d9
    163  63d9
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm LEVEL 3 PASS 5
      0  63d9					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_0.asm"
      0  63d9					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_0", 72
     12  6400					      LIST	ON
      0  6400					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_0
      1  6400				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	_CURRENT_BANK
      2  6400				   WHITE_PROMOTE_on_BLACK_SQUARE_0
      3  6400				   TEMPORARY_VAR SET	Overlay
      4  6400				   TEMPORARY_OFFSET SET	0
      5  6400				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_0 SET	TEMPORARY_OFFSET
      6  6400				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_0
      7  6400					      SUBROUTINE
      3  6400		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40	;PF0
      4  6418		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6430		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm LEVEL 3 PASS 5
      0  6448					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_1.asm"
      0  6448					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_1", 72
     12  6448					      LIST	ON
      0  6448					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_1
      1  6448				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	_CURRENT_BANK
      2  6448				   WHITE_PROMOTE_on_BLACK_SQUARE_1
      3  6448				   TEMPORARY_VAR SET	Overlay
      4  6448				   TEMPORARY_OFFSET SET	0
      5  6448				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_1 SET	TEMPORARY_OFFSET
      6  6448				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_1
      7  6448					      SUBROUTINE
      3  6448		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6460		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10	;PF1
      5  6478		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm LEVEL 3 PASS 5
      0  6490					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_2.asm"
      0  6490					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_2", 72
     12  6490					      LIST	ON
      0  6490					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_2
      1  6490				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	_CURRENT_BANK
      2  6490				   WHITE_PROMOTE_on_BLACK_SQUARE_2
      3  6490				   TEMPORARY_VAR SET	Overlay
      4  6490				   TEMPORARY_OFFSET SET	0
      5  6490				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_2 SET	TEMPORARY_OFFSET
      6  6490				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_2
      7  6490					      SUBROUTINE
      3  6490		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  64a8		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00	;PF1
      5  64c0		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm LEVEL 3 PASS 5
      0  64d8					      include	"gfx/WHITE_PROMOTE_on_BLACK_SQUARE_3.asm"
      0  64d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_BLACK_SQUARE_3", 72
     12  6500					      LIST	ON
      0  6500					      DEF	WHITE_PROMOTE_on_BLACK_SQUARE_3
      1  6500				   BANK_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	_CURRENT_BANK
      2  6500				   WHITE_PROMOTE_on_BLACK_SQUARE_3
      3  6500				   TEMPORARY_VAR SET	Overlay
      4  6500				   TEMPORARY_OFFSET SET	0
      5  6500				   VAR_BOUNDARY_WHITE_PROMOTE_on_BLACK_SQUARE_3 SET	TEMPORARY_OFFSET
      6  6500				   FUNCTION_NAME SET	WHITE_PROMOTE_on_BLACK_SQUARE_3
      7  6500					      SUBROUTINE
      3  6500		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6518		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6530		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm LEVEL 3 PASS 5
      0  6548					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_0.asm"
      0  6548					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_0", 72
     12  6548					      LIST	ON
      0  6548					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_0
      1  6548				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	_CURRENT_BANK
      2  6548				   WHITE_PROMOTE_on_WHITE_SQUARE_0
      3  6548				   TEMPORARY_VAR SET	Overlay
      4  6548				   TEMPORARY_OFFSET SET	0
      5  6548				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_0 SET	TEMPORARY_OFFSET
      6  6548				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_0
      7  6548					      SUBROUTINE
      3  6548		       40 00 40 c0*	      .byte.b	$40,$00,$40,$c0,$80,$a0,$e0,$40,$40,$00,$40,$c0,$80,$a0,$e0,$40,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6560		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6578		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm LEVEL 3 PASS 5
      0  6590					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_1.asm"
      0  6590					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_1", 72
     12  6590					      LIST	ON
      0  6590					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_1
      1  6590				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	_CURRENT_BANK
      2  6590				   WHITE_PROMOTE_on_WHITE_SQUARE_1
      3  6590				   TEMPORARY_VAR SET	Overlay
      4  6590				   TEMPORARY_OFFSET SET	0
      5  6590				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_1 SET	TEMPORARY_OFFSET
      6  6590				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_1
      7  6590					      SUBROUTINE
      3  6590		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  65a8		       10 00 10 18*	      .byte.b	$10,$00,$10,$18,$08,$28,$38,$10,$10,$00,$10,$18,$08,$28,$38,$10,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  65c0		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm LEVEL 3 PASS 5
      0  65d8					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_2.asm"
      0  65d8					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_2", 72
     12  6600					      LIST	ON
      0  6600					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_2
      1  6600				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	_CURRENT_BANK
      2  6600				   WHITE_PROMOTE_on_WHITE_SQUARE_2
      3  6600				   TEMPORARY_VAR SET	Overlay
      4  6600				   TEMPORARY_OFFSET SET	0
      5  6600				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_2 SET	TEMPORARY_OFFSET
      6  6600				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_2
      7  6600					      SUBROUTINE
      3  6600		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6618		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$01,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6630		       01 00 01 03*	      .byte.b	$01,$00,$01,$03,$02,$02,$03,$01,$01,$00,$01,$03,$02,$02,$03,$01,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
------- FILE gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm LEVEL 3 PASS 5
      0  6648					      include	"gfx/WHITE_PROMOTE_on_WHITE_SQUARE_3.asm"
      0  6648					      OPTIONAL_PAGEBREAK	"WHITE_PROMOTE_on_WHITE_SQUARE_3", 72
     12  6648					      LIST	ON
      0  6648					      DEF	WHITE_PROMOTE_on_WHITE_SQUARE_3
      1  6648				   BANK_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	_CURRENT_BANK
      2  6648				   WHITE_PROMOTE_on_WHITE_SQUARE_3
      3  6648				   TEMPORARY_VAR SET	Overlay
      4  6648				   TEMPORARY_OFFSET SET	0
      5  6648				   VAR_BOUNDARY_WHITE_PROMOTE_on_WHITE_SQUARE_3 SET	TEMPORARY_OFFSET
      6  6648				   FUNCTION_NAME SET	WHITE_PROMOTE_on_WHITE_SQUARE_3
      7  6648					      SUBROUTINE
      3  6648		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF0
      4  6660		       00 00 00 00*	      .byte.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	;PF1
      5  6678		       20 00 20 60*	      .byte.b	$20,$00,$20,$60,$40,$50,$70,$20,$20,$00,$20,$60,$40,$50,$70,$20,$00,$00,$00,$00,$00,$00,$00,$00	;PF2
------- FILE Handler_BANK1.asm
    172  6690
    173  6690							;---------------------------------------------------------------------------------------------------
    174  6690
      0  6690					      CHECK_BANK_SIZE	"HANDLER_BANK_1 -- full 2K"
      1  6690		       06 90	   .TEMP      =	* - BANK_START
 HANDLER_BANK_1 -- full 2K (2K) SIZE =  $690 , FREE= $170
      2  6690					      ECHO	"HANDLER_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  6690				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  6690				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  6690				  -	      ERR
      6  6690					      ENDIF
      7  6690
    176  6690
    177  6690							;---------------------------------------------------------------------------------------------------
    178  6690							; EOF
------- FILE ./chess.asm
------- FILE BANK_PLY.asm LEVEL 2 PASS 5
      0  6690					      include	"BANK_PLY.asm"
      1  6690							; Copyright (C)2020 Andrew Davie
      2  6690							; andrew@taswegian.com
      3  6690
      4  6690
      5  6690							;---------------------------------------------------------------------------------------------------
      6  6690							; Define the RAM banks
      7  6690							; A "PLY" bank represents all the data required on any single ply of the search tree.
      8  6690							; The banks are organised sequentially, PLY_BANKS of them starting at RAMBANK_PLY
      9  6690							; The startup code copies the ROM shadow into each of these PLY banks, and from then on
     10  6690							; they act as independant switchable banks usable for data on each ply during the search.
     11  6690							; A ply will hold the move list for that position
     12  6690
     13  6690
      0  6690					      NEWRAMBANK	PLY	; RAM bank for holding the following ROM shadow
      1  6690
      2  6690
      3  6690
      4 U2800 ????				      SEG.U	PLY
      5 U2800					      ORG	ORIGIN_RAM
      6 U2800					      RORG	RAM_3E
      7 U2800				   BANK_START SET	*
      8 U2800				   RAMBANK_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2800				   _CURRENT_RAMBANK SET	RAMBANK_PLY
     10 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U2800					      REPEAT	PLY_BANKS-1
      0 U2800					      NEWRAMBANK	.DUMMY_PLY
      1 U2800
      2 U2800
      3 U2800
      4 U5800 ????				      SEG.U	.DUMMY_PLY
      5 U2c00					      ORG	ORIGIN_RAM
      6 U2c00					      RORG	RAM_3E
      7 U2c00				   BANK_START SET	*
      8 U2c00				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U2c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U2c00					      REPEND
      0 U2c00					      NEWRAMBANK	.DUMMY_PLY
      1 U2c00
      2 U2c00
      3 U2c00
      4 U2c00					      SEG.U	.DUMMY_PLY
      5 U3000					      ORG	ORIGIN_RAM
      6 U3000					      RORG	RAM_3E
      7 U3000				   BANK_START SET	*
      8 U3000				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U3000					      REPEND
      0 U3000					      NEWRAMBANK	.DUMMY_PLY
      1 U3000
      2 U3000
      3 U3000
      4 U3000					      SEG.U	.DUMMY_PLY
      5 U3400					      ORG	ORIGIN_RAM
      6 U3400					      RORG	RAM_3E
      7 U3400				   BANK_START SET	*
      8 U3400				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U3400					      REPEND
      0 U3400					      NEWRAMBANK	.DUMMY_PLY
      1 U3400
      2 U3400
      3 U3400
      4 U3400					      SEG.U	.DUMMY_PLY
      5 U3800					      ORG	ORIGIN_RAM
      6 U3800					      RORG	RAM_3E
      7 U3800				   BANK_START SET	*
      8 U3800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U3800					      REPEND
      0 U3800					      NEWRAMBANK	.DUMMY_PLY
      1 U3800
      2 U3800
      3 U3800
      4 U3800					      SEG.U	.DUMMY_PLY
      5 U3c00					      ORG	ORIGIN_RAM
      6 U3c00					      RORG	RAM_3E
      7 U3c00				   BANK_START SET	*
      8 U3c00				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U3c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U3c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U3c00					      REPEND
      0 U3c00					      NEWRAMBANK	.DUMMY_PLY
      1 U3c00
      2 U3c00
      3 U3c00
      4 U3c00					      SEG.U	.DUMMY_PLY
      5 U4000					      ORG	ORIGIN_RAM
      6 U4000					      RORG	RAM_3E
      7 U4000				   BANK_START SET	*
      8 U4000				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U4000					      REPEND
      0 U4000					      NEWRAMBANK	.DUMMY_PLY
      1 U4000
      2 U4000
      3 U4000
      4 U4000					      SEG.U	.DUMMY_PLY
      5 U4400					      ORG	ORIGIN_RAM
      6 U4400					      RORG	RAM_3E
      7 U4400				   BANK_START SET	*
      8 U4400				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U4400					      REPEND
      0 U4400					      NEWRAMBANK	.DUMMY_PLY
      1 U4400
      2 U4400
      3 U4400
      4 U4400					      SEG.U	.DUMMY_PLY
      5 U4800					      ORG	ORIGIN_RAM
      6 U4800					      RORG	RAM_3E
      7 U4800				   BANK_START SET	*
      8 U4800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U4800					      REPEND
      0 U4800					      NEWRAMBANK	.DUMMY_PLY
      1 U4800
      2 U4800
      3 U4800
      4 U4800					      SEG.U	.DUMMY_PLY
      5 U4c00					      ORG	ORIGIN_RAM
      6 U4c00					      RORG	RAM_3E
      7 U4c00				   BANK_START SET	*
      8 U4c00				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U4c00				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U4c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U4c00					      REPEND
      0 U4c00					      NEWRAMBANK	.DUMMY_PLY
      1 U4c00
      2 U4c00
      3 U4c00
      4 U4c00					      SEG.U	.DUMMY_PLY
      5 U5000					      ORG	ORIGIN_RAM
      6 U5000					      RORG	RAM_3E
      7 U5000				   BANK_START SET	*
      8 U5000				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U5000				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U5000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U5000					      REPEND
      0 U5000					      NEWRAMBANK	.DUMMY_PLY
      1 U5000
      2 U5000
      3 U5000
      4 U5000					      SEG.U	.DUMMY_PLY
      5 U5400					      ORG	ORIGIN_RAM
      6 U5400					      RORG	RAM_3E
      7 U5400				   BANK_START SET	*
      8 U5400				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U5400				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U5400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     15 U5400					      REPEND
      0 U5400					      NEWRAMBANK	.DUMMY_PLY
      1 U5400
      2 U5400
      3 U5400
      4 U5400					      SEG.U	.DUMMY_PLY
      5 U5800					      ORG	ORIGIN_RAM
      6 U5800					      RORG	RAM_3E
      7 U5800				   BANK_START SET	*
      8 U5800				   RAMBANK_.DUMMY_PLY SET	ORIGIN_RAM / RAM_SIZE
      9 U5800				   _CURRENT_RAMBANK SET	RAMBANK_.DUMMY_PLY
     10 U5800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
     17 U5800					      REPEND
     18 U5800
     19 U5800
     20 U5800							;---------------------------------------------------------------------------------------------------
     21 U5800							; and now the ROM shadow - this is copied to ALL of the RAM ply banks
     22 U5800
      0 U5800					      NEWBANK	BANK_PLY	; ROM SHADOW
      1  6bd5 ????				      SEG	BANK_PLY
      2  6800					      ORG	ORIGIN
      3  6800					      RORG	$F000
      4  6800				   BANK_START SET	*
      5  6800				   BANK_PLY   SET	ORIGIN / 2048
      6  6800				   ORIGIN     SET	ORIGIN + 2048
      7  6800				   _CURRENT_BANK SET	BANK_PLY
     24  6800
     25  6800							;---------------------------------------------------------------------------------------------------
     26  6800							; The piece-lists
     27  6800							; ONLY the very first bank piecelist is used - all other banks switch to the first for
     28  6800							; piecelist usage. Note that this initialisation (below) comes from the shadow ROM/RAM copy
     29  6800							; but this needs to be initialised programatically on new game.
     30  6800
     31  6800							; We have TWO piecelists, in different banks
     32  6800							; WHITE pieces in bank BANK_PLY
     33  6800							; BLACK pieces in bank BANK_PLY+1
     34  6800
      0  6800					      VARIABLE	savedEvaluation, 2	; THIS node's evaluation - used for reverting moves!
      0  6800					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  6800					      LIST	ON
      2  6800		       00 00	   savedEvaluation ds	2
     36  6802
     37  6802							;---------------------------------------------------------------------------------------------------
     38  6802
     39  6802		       00 46	   MAX_MOVES  =	70
     40  6802
      0  6802					      VARIABLE	MoveFrom, MAX_MOVES
      0  6802					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  6802					      LIST	ON
      2  6802		       00 00 00 00*MoveFrom   ds	MAX_MOVES
      0  6848					      VARIABLE	MoveTo, MAX_MOVES
      0  6848					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  6848					      LIST	ON
      2  6848		       00 00 00 00*MoveTo     ds	MAX_MOVES
      0  688e					      VARIABLE	MovePiece, MAX_MOVES
      0  688e					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  688e					      LIST	ON
      2  688e		       00 00 00 00*MovePiece  ds	MAX_MOVES
      0  68d4					      VARIABLE	MoveCapture, MAX_MOVES
      0  68d4					      OPTIONAL_PAGEBREAK	"Variable", MAX_MOVES
     12  6900					      LIST	ON
      2  6900		       00 00 00 00*MoveCapture ds	MAX_MOVES
     45  6946
      0  6946					      VARIABLE	kingSquare, 3	; traversing squares for castle/check
      0  6946					      OPTIONAL_PAGEBREAK	"Variable", 3
     12  6946					      LIST	ON
      2  6946		       00 00 00    kingSquare ds	3
     47  6949
     48  6949							;---------------------------------------------------------------------------------------------------
     49  6949
     50  6949							; The X12 square at which a pawn CAN be taken en-passant. Normally 0.
     51  6949							; This is set/cleared whenever a move is made. The flag is indicated in the move description.
     52  6949
      0  6949					      VARIABLE	enPassantSquare, 1
      0  6949					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6949					      LIST	ON
      2  6949		       00	   enPassantSquare ds	1
      0  694a					      VARIABLE	capturedPiece, 1
      0  694a					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694a					      LIST	ON
      2  694a		       00	   capturedPiece ds	1
      0  694b					      VARIABLE	originalPiece, 1
      0  694b					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694b					      LIST	ON
      2  694b		       00	   originalPiece ds	1
      0  694c					      VARIABLE	secondaryPiece, 1	; original piece on secondary (castle, enpassant)
      0  694c					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694c					      LIST	ON
      2  694c		       00	   secondaryPiece ds	1
      0  694d					      VARIABLE	secondarySquare, 1	; original square of secondary piece
      0  694d					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694d					      LIST	ON
      2  694d		       00	   secondarySquare ds	1
      0  694e					      VARIABLE	secondaryBlank, 1	; square to blank on secondary
      0  694e					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694e					      LIST	ON
      2  694e		       00	   secondaryBlank ds	1
     59  694f
     60  694f							;---------------------------------------------------------------------------------------------------
     61  694f							; Move tables hold piece moves for this current ply
     62  694f
      0  694f					      VARIABLE	moveIndex, 1	; points to first available 'slot' for move storage
      0  694f					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  694f					      LIST	ON
      2  694f		       00	   moveIndex  ds	1
      0  6950					      VARIABLE	movePtr, 1
      0  6950					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6950					      LIST	ON
      2  6950		       00	   movePtr    ds	1
      0  6951					      VARIABLE	bestMove, 1
      0  6951					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6951					      LIST	ON
      2  6951		       00	   bestMove   ds	1
      0  6952					      VARIABLE	alpha, 2
      0  6952					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  6952					      LIST	ON
      2  6952		       00 00	   alpha      ds	2
      0  6954					      VARIABLE	beta, 2
      0  6954					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  6954					      LIST	ON
      2  6954		       00 00	   beta       ds	2
      0  6956					      VARIABLE	value, 2
      0  6956					      OPTIONAL_PAGEBREAK	"Variable", 2
     12  6956					      LIST	ON
      2  6956		       00 00	   value      ds	2
      0  6958					      VARIABLE	depthLeft, 1
      0  6958					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6958					      LIST	ON
      2  6958		       00	   depthLeft  ds	1
      0  6959					      VARIABLE	restorePiece, 1
      0  6959					      OPTIONAL_PAGEBREAK	"Variable", 1
     12  6959					      LIST	ON
      2  6959		       00	   restorePiece ds	1
     71  695a
     72  695a							;---------------------------------------------------------------------------------------------------
     73  695a
      0  695a					      DEF	NewPlyInitialise
      1  695a				   BANK_NewPlyInitialise SET	_CURRENT_BANK
      2  695a				   NewPlyInitialise
      3  695a				   TEMPORARY_VAR SET	Overlay
      4  695a				   TEMPORARY_OFFSET SET	0
      5  695a				   VAR_BOUNDARY_NewPlyInitialise SET	TEMPORARY_OFFSET
      6  695a				   FUNCTION_NAME SET	NewPlyInitialise
      7  695a					      SUBROUTINE
     75  695a					      SUBROUTINE
     76  695a
      0  695a					      REFER	GenerateAllMoves
      1  695a					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  695a				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  695a					      ENDIF
      0  695a					      REFER	negaMax
      1  695a				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  695a				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  695a					      ENDIF
      0  695a					      VEND	NewPlyInitialise
      1  695a				  -	      IFNCONST	NewPlyInitialise
      2  695a				  -	      ECHO	"Incorrect VEND label", NewPlyInitialise
      3  695a				  -	      ERR
      4  695a					      ENDIF
      5  695a		       00 b3	   VAREND_NewPlyInitialise =	TEMPORARY_VAR
     80  695a
     81  695a							; This MUST be called at the start of a new ply
     82  695a							; It initialises the movelist to empty
     83  695a							; x must be preserved
     84  695a
     85  695a							; note that 'alpha' and 'beta' are set externally!!
     86  695a
     87  695a		       a9 ff		      lda	#-1
      0  695c					      sta@PLY	moveIndex	; no valid moves
      1  695c		       8d 4f f5 	      sta	[RAM]+moveIndex
      0  695f					      sta@PLY	bestMove
      1  695f		       8d 51 f5 	      sta	[RAM]+bestMove
     90  6962
     91  6962		       a5 94		      lda	enPassantPawn	; flag/square from last actual move made
      0  6964					      sta@PLY	enPassantSquare	; used for backtracking, to reset the flag
      1  6964		       8d 49 f5 	      sta	[RAM]+enPassantSquare
     93  6967
     94  6967
     95  6967							; The value of the material (signed, 16-bit) is restored to the saved value at the reversion
     96  6967							; of a move. It's quicker to restore than to re-sum. So we save the current evaluation at the
     97  6967							; start of each new ply.
     98  6967
     99  6967		       a5 90		      lda	Evaluation
      0  6969					      sta@PLY	savedEvaluation
      1  6969		       8d 00 f4 	      sta	[RAM]+savedEvaluation
    101  696c		       a5 91		      lda	Evaluation+1
      0  696e					      sta@PLY	savedEvaluation+1
      1  696e		       8d 01 f4 	      sta	[RAM]+savedEvaluation+1
    103  6971
    104  6971		       60		      rts
    105  6972
    106  6972
    107  6972							;---------------------------------------------------------------------------------------------------
    108  6972
      0  6972					      DEF	CheckMoveListFromSquare
      1  6972				   BANK_CheckMoveListFromSquare SET	_CURRENT_BANK
      2  6972				   CheckMoveListFromSquare
      3  6972				   TEMPORARY_VAR SET	Overlay
      4  6972				   TEMPORARY_OFFSET SET	0
      5  6972				   VAR_BOUNDARY_CheckMoveListFromSquare SET	TEMPORARY_OFFSET
      6  6972				   FUNCTION_NAME SET	CheckMoveListFromSquare
      7  6972					      SUBROUTINE
    110  6972					      SUBROUTINE
    111  6972
      0  6972					      REFER	IsValidP_MoveFromSquare
      1  6972				  -	      IF	VAREND_IsValidP_MoveFromSquare > TEMPORARY_VAR
      2  6972				  -TEMPORARY_VAR SET	VAREND_IsValidP_MoveFromSquare
      3  6972					      ENDIF
      0  6972					      VEND	CheckMoveListFromSquare
      1  6972				  -	      IFNCONST	CheckMoveListFromSquare
      2  6972				  -	      ECHO	"Incorrect VEND label", CheckMoveListFromSquare
      3  6972				  -	      ERR
      4  6972					      ENDIF
      5  6972		       00 a2	   VAREND_CheckMoveListFromSquare =	TEMPORARY_VAR
    114  6972
    115  6972							; X12 in A
    116  6972							; y = -1 on return if NOT FOUND
    117  6972
      0  6972					      ldy@RAM	moveIndex
      1  6972		       ac 4f f1 	      ldy	moveIndex
    119  6975		       30 08		      bmi	.exit
    120  6977
    121  6977		       d9 02 f0    .scan      cmp	MoveFrom,y
    122  697a		       f0 04		      beq	.scanned
    123  697c		       88		      dey
    124  697d		       10 f8		      bpl	.scan
    125  697f		       60	   .exit      rts
    126  6980
      0  6980				   .scanned   lda@PLY	MovePiece,y
      1  6980		       b9 8e f0 	      lda	MovePiece,y
    128  6983		       85 97		      sta	fromPiece
    129  6985		       60		      rts
    130  6986
    131  6986
    132  6986							;---------------------------------------------------------------------------------------------------
    133  6986
      0  6986					      DEF	GetPieceGivenFromToSquares
      1  6986				   BANK_GetPieceGivenFromToSquares SET	_CURRENT_BANK
      2  6986				   GetPieceGivenFromToSquares
      3  6986				   TEMPORARY_VAR SET	Overlay
      4  6986				   TEMPORARY_OFFSET SET	0
      5  6986				   VAR_BOUNDARY_GetPieceGivenFromToSquares SET	TEMPORARY_OFFSET
      6  6986				   FUNCTION_NAME SET	GetPieceGivenFromToSquares
      7  6986					      SUBROUTINE
    135  6986					      SUBROUTINE
    136  6986
      0  6986					      REFER	GetPiece
      1  6986				  -	      IF	VAREND_GetPiece > TEMPORARY_VAR
      2  6986				  -TEMPORARY_VAR SET	VAREND_GetPiece
      3  6986					      ENDIF
      0  6986					      VEND	GetPieceGivenFromToSquares
      1  6986				  -	      IFNCONST	GetPieceGivenFromToSquares
      2  6986				  -	      ECHO	"Incorrect VEND label", GetPieceGivenFromToSquares
      3  6986				  -	      ERR
      4  6986					      ENDIF
      5  6986		       00 a2	   VAREND_GetPieceGivenFromToSquares =	TEMPORARY_VAR
    139  6986
    140  6986							; returns piece in A+fromPiece
    141  6986							; or Y=-1 if not found
    142  6986
    143  6986							; We need to get the piece from the movelist because it contains flags (e.g., castling) about
    144  6986							; the move. We need to do from/to checks because moves can have multiple origin/desinations.
    145  6986							; This fixes the move with/without castle flag
    146  6986
    147  6986
      0  6986					      ldy@PLY	moveIndex
      1  6986		       ac 4f f1 	      ldy	moveIndex
    149  6989							;bmi .fail		  ; shouldn't happen
    150  6989		       a5 85	   .scan      lda	fromX12
      0  698b					      cmp@PLY	MoveFrom,y
      1  698b		       d9 02 f0 	      cmp	MoveFrom,y
    152  698e		       d0 07		      bne	.next
    153  6990		       a5 86		      lda	toX12
      0  6992					      cmp@PLY	MoveTo,y
      1  6992		       d9 48 f0 	      cmp	MoveTo,y
    155  6995		       f0 04		      beq	.found
    156  6997		       88	   .next      dey
    157  6998		       10 ef		      bpl	.scan
    158  699a		       60	   .fail      rts
    159  699b
      0  699b				   .found     lda@PLY	MovePiece,y
      1  699b		       b9 8e f0 	      lda	MovePiece,y
    161  699e		       85 97		      sta	fromPiece
    162  69a0		       60		      rts
    163  69a1
    164  69a1
    165  69a1
    166  69a1							;---------------------------------------------------------------------------------------------------
    167  69a1
      0  69a1					      DEF	selectmove
      1  69a1				   BANK_selectmove SET	_CURRENT_BANK
      2  69a1				   selectmove
      3  69a1				   TEMPORARY_VAR SET	Overlay
      4  69a1				   TEMPORARY_OFFSET SET	0
      5  69a1				   VAR_BOUNDARY_selectmove SET	TEMPORARY_OFFSET
      6  69a1				   FUNCTION_NAME SET	selectmove
      7  69a1					      SUBROUTINE
    169  69a1					      SUBROUTINE
    170  69a1
      0  69a1					      COMMON_VARS_ALPHABETA
      1  69a1
      0  69a1					      VAR	__thinkbar, 1
      1  69a1		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  69a1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  69a1
      4  69a1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a1					      ENDIF
      8  69a1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a1				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  69a1				  -	      ERR
     11  69a1					      ENDIF
     12  69a1					      LIST	ON
      0  69a1					      VAR	__toggle, 1
      1  69a1		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  69a1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  69a1
      4  69a1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a1					      ENDIF
      8  69a1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a1				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  69a1				  -	      ERR
     11  69a1					      ENDIF
     12  69a1					      LIST	ON
      4  69a1
      0  69a1					      VAR	__bestMove, 1
      1  69a1		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  69a1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  69a1
      4  69a1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a1					      ENDIF
      8  69a1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a1				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  69a1				  -	      ERR
     11  69a1					      ENDIF
     12  69a1					      LIST	ON
      0  69a1					      VAR	__alpha, 2
      1  69a1		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  69a1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  69a1
      4  69a1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a1					      ENDIF
      8  69a1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a1				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  69a1				  -	      ERR
     11  69a1					      ENDIF
     12  69a1					      LIST	ON
      0  69a1					      VAR	__beta, 2
      1  69a1		       00 a7	   __beta     =	TEMPORARY_VAR
      2  69a1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  69a1
      4  69a1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a1					      ENDIF
      8  69a1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a1				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  69a1				  -	      ERR
     11  69a1					      ENDIF
     12  69a1					      LIST	ON
      0  69a1					      VAR	__negaMax, 2
      1  69a1		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  69a1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  69a1
      4  69a1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a1					      ENDIF
      8  69a1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a1				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  69a1				  -	      ERR
     11  69a1					      ENDIF
     12  69a1					      LIST	ON
      0  69a1					      VAR	__value, 2
      1  69a1		       00 ab	   __value    =	TEMPORARY_VAR
      2  69a1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  69a1
      4  69a1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a1					      ENDIF
      8  69a1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a1				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  69a1				  -	      ERR
     11  69a1					      ENDIF
     12  69a1					      LIST	ON
     10  69a1
      0  69a1					      VAR	__quiesceCapOnly, 1
      1  69a1		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  69a1				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  69a1
      4  69a1				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  69a1				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  69a1				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  69a1					      ENDIF
      8  69a1				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  69a1				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  69a1				  -	      ERR
     11  69a1					      ENDIF
     12  69a1					      LIST	ON
     12  69a1
      0  69a1					      REFER	aiComputerMove
      1  69a1				  -	      IF	VAREND_aiComputerMove > TEMPORARY_VAR
      2  69a1				  -TEMPORARY_VAR SET	VAREND_aiComputerMove
      3  69a1					      ENDIF
      0  69a1					      VEND	selectmove
      1  69a1				  -	      IFNCONST	selectmove
      2  69a1				  -	      ECHO	"Incorrect VEND label", selectmove
      3  69a1				  -	      ERR
      4  69a1					      ENDIF
      5  69a1		       00 ae	   VAREND_selectmove =	TEMPORARY_VAR
    174  69a1
    175  69a1
    176  69a1
    177  69a1							; RAM bank already switched in!!!
    178  69a1							; returns with RAM bank switched
    179  69a1
    180  69a1
    181  69a1				  -	      IF	DIAGNOSTICS
    182  69a1				  -
    183  69a1				  -	      lda	#0
    184  69a1				  -	      sta	positionCount
    185  69a1				  -	      sta	positionCount+1
    186  69a1				  -	      sta	positionCount+2
    187  69a1				  -			;sta maxPly
    188  69a1					      ENDIF
    189  69a1
    190  69a1
    191  69a1		       a9 00		      lda	#<INFINITY
    192  69a3		       85 a7		      sta	__beta
    193  69a5		       a9 70		      lda	#>INFINITY
    194  69a7		       85 a8		      sta	__beta+1
    195  69a9
    196  69a9		       a9 00		      lda	#<-INFINITY
    197  69ab		       85 a5		      sta	__alpha
    198  69ad		       a9 90		      lda	#>-INFINITY
    199  69af		       85 a6		      sta	__alpha+1	; player tries to maximise
    200  69b1
    201  69b1		       a2 05		      ldx	#SEARCH_DEPTH
    202  69b3		       a9 00		      lda	#0	; no captured piece
    203  69b5		       85 ad		      sta	__quiesceCapOnly	; ALL moves to be generated
    204  69b7
    205  69b7		       20 c4 fe 	      jsr	negaMax
    206  69ba
    207  69ba							;NEGEVAL		 ;????
    208  69ba
    209  69ba
    210  69ba							;lda #0
    211  69ba							;sta COLUPF			  ; hide any thinkbars
    212  69ba
      0  69ba					      ldx@PLY	bestMove
      1  69ba		       ae 51 f1 	      ldx	bestMove
    214  69bd		       30 28		      bmi	.nomove
    215  69bf
    216  69bf							; Generate player's moves in reply
    217  69bf							; Make the computer move, list player moves (PLY+1), unmake computer move
    218  69bf
    219  69bf
      0  69bf					      stx@PLY	movePtr
      1  69bf		       8e 50 f5 	      stx	[RAM]+movePtr
    221  69c2		       20 dc fd 	      jsr	MakeMove
    222  69c5
    223  69c5		       20 d2 f8 	      jsr	ListPlayerMoves
    224  69c8
    225  69c8		       a9 0a		      lda	#RAMBANK_PLY
    226  69ca		       85 3e		      sta	SET_BANK_RAM
    227  69cc
    228  69cc		       20 4f fe 	      jsr	unmakeMove
    229  69cf
    230  69cf							; Grab the computer move details for the UI animation
    231  69cf
    232  69cf		       a9 0a		      lda	#RAMBANK_PLY
    233  69d1		       85 3e		      sta	SET_BANK_RAM
    234  69d3
      0  69d3					      ldx@PLY	bestMove
      1  69d3		       ae 51 f1 	      ldx	bestMove
      0  69d6					      lda@PLY	MoveTo,x
      1  69d6		       bd 48 f0 	      lda	MoveTo,x
    237  69d9		       85 86		      sta	toX12
      0  69db					      lda@PLY	MoveFrom,x
      1  69db		       bd 02 f0 	      lda	MoveFrom,x
    239  69de		       85 87		      sta	originX12
    240  69e0		       85 85		      sta	fromX12
      0  69e2					      lda@PLY	MovePiece,x
      1  69e2		       bd 8e f0 	      lda	MovePiece,x
    242  69e5		       85 97		      sta	fromPiece
    243  69e7
    244  69e7				   .nomove
    245  69e7		       60		      rts
    246  69e8
    247  69e8
    248  69e8							;---------------------------------------------------------------------------------------------------
    249  69e8
      0  69e8					      DEF	GenCastleMoveForRook
      1  69e8				   BANK_GenCastleMoveForRook SET	_CURRENT_BANK
      2  69e8				   GenCastleMoveForRook
      3  69e8				   TEMPORARY_VAR SET	Overlay
      4  69e8				   TEMPORARY_OFFSET SET	0
      5  69e8				   VAR_BOUNDARY_GenCastleMoveForRook SET	TEMPORARY_OFFSET
      6  69e8				   FUNCTION_NAME SET	GenCastleMoveForRook
      7  69e8					      SUBROUTINE
    251  69e8					      SUBROUTINE
    252  69e8
      0  69e8					      REFER	MakeMove
      1  69e8					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  69e8				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  69e8					      ENDIF
      0  69e8					      REFER	CastleFixupDraw
      1  69e8				  -	      IF	VAREND_CastleFixupDraw > TEMPORARY_VAR
      2  69e8				  -TEMPORARY_VAR SET	VAREND_CastleFixupDraw
      3  69e8					      ENDIF
      0  69e8					      VEND	GenCastleMoveForRook
      1  69e8				  -	      IFNCONST	GenCastleMoveForRook
      2  69e8				  -	      ECHO	"Incorrect VEND label", GenCastleMoveForRook
      3  69e8				  -	      ERR
      4  69e8					      ENDIF
      5  69e8		       00 b0	   VAREND_GenCastleMoveForRook =	TEMPORARY_VAR
    256  69e8
    257  69e8		       18		      clc
    258  69e9
    259  69e9		       a5 97		      lda	fromPiece
    260  69eb		       29 10		      and	#FLAG_CASTLE
    261  69ed		       f0 2b		      beq	.exit	; NOT involved in castle!
    262  69ef
    263  69ef		       a2 04		      ldx	#4
    264  69f1		       a5 85		      lda	fromX12	; *destination*
    265  69f3		       18	   .findCast  clc
    266  69f4		       ca		      dex
    267  69f5		       30 23		      bmi	.exit
    268  69f7		       dd 2c f2 	      cmp	KSquare,x
    269  69fa		       d0 f7		      bne	.findCast
    270  69fc
    271  69fc		       bd 34 f2 	      lda	RSquareEnd,x
    272  69ff		       85 86		      sta	toX12
      0  6a01					      sta@PLY	secondaryBlank
      1  6a01		       8d 4e f5 	      sta	[RAM]+secondaryBlank
    274  6a04		       bc 30 f2 	      ldy	RSquareStart,x
    275  6a07		       84 85		      sty	fromX12
    276  6a09		       84 87		      sty	originX12
      0  6a0b					      sty@PLY	secondarySquare
      1  6a0b		       8c 4d f5 	      sty	[RAM]+secondarySquare
    278  6a0e
    279  6a0e		       a5 97		      lda	fromPiece
    280  6a10		       29 80		      and	#128	; colour bit
    281  6a12		       09 05		      ora	#ROOK	; preserve colour
    282  6a14		       85 97		      sta	fromPiece
      0  6a16					      sta@PLY	secondaryPiece
      1  6a16		       8d 4c f5 	      sta	[RAM]+secondaryPiece
    284  6a19
    285  6a19		       38		      sec
    286  6a1a		       60	   .exit      rts
    287  6a1b
    288  6a1b
    289  6a1b							;---------------------------------------------------------------------------------------------------
    290  6a1b
      0  6a1b					      DEF	CastleFixupDraw
      1  6a1b				   BANK_CastleFixupDraw SET	_CURRENT_BANK
      2  6a1b				   CastleFixupDraw
      3  6a1b				   TEMPORARY_VAR SET	Overlay
      4  6a1b				   TEMPORARY_OFFSET SET	0
      5  6a1b				   VAR_BOUNDARY_CastleFixupDraw SET	TEMPORARY_OFFSET
      6  6a1b				   FUNCTION_NAME SET	CastleFixupDraw
      7  6a1b					      SUBROUTINE
    292  6a1b					      SUBROUTINE
    293  6a1b
      0  6a1b					      REFER	aiSpecialMoveFixup
      1  6a1b					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  6a1b				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  6a1b					      ENDIF
      0  6a1b					      VEND	CastleFixupDraw
      1  6a1b				  -	      IFNCONST	CastleFixupDraw
      2  6a1b				  -	      ECHO	"Incorrect VEND label", CastleFixupDraw
      3  6a1b				  -	      ERR
      4  6a1b					      ENDIF
      5  6a1b		       00 ae	   VAREND_CastleFixupDraw =	TEMPORARY_VAR
    296  6a1b
    297  6a1b							; fixup any castling issues
    298  6a1b							; at this point the king has finished his two-square march
    299  6a1b							; based on the finish square, we determine which rook we're interacting with
    300  6a1b							; and generate a 'move' for the rook to position on the other side of the king
    301  6a1b
    302  6a1b
    303  6a1b					      IF	CASTLING_ENABLED
    304  6a1b		       20 e8 f1 	      jsr	GenCastleMoveForRook
    305  6a1e		       b0 07		      bcs	.phase
    306  6a20					      ENDIF
    307  6a20
      0  6a20					      SWAP
      1  6a20		       a5 96		      lda	sideToMove
      2  6a22		       49 81		      eor	#SWAP_SIDE
      3  6a24		       85 96		      sta	sideToMove
    309  6a26		       60		      rts
    310  6a27
    311  6a27				   .phase
    312  6a27
    313  6a27							; in this siutation (castle, rook moving) we do not change sides yet!
    314  6a27
      0  6a27					      PHASE	AI_MoveIsSelected
      1  6a27		       a9 14		      lda	#AI_MoveIsSelected
      2  6a29		       85 8c		      sta	aiState
    316  6a2b		       60		      rts
    317  6a2c
    318  6a2c
    319  6a2c
    320  6a2c		       18 1c 5e 62 KSquare    .byte.b	24,28,94,98
    321  6a30		       16 1d 5c 63 RSquareStart .byte.b	22,29,92,99
    322  6a34		       19 1b 5f 61 RSquareEnd .byte.b	25,27,95,97
    323  6a38
    324  6a38
    325  6a38							;---------------------------------------------------------------------------------------------------
    326  6a38
    327  6a38					      MAC	xchg
    328  6a38					      lda@PLY	{1},x
    329  6a38					      sta	__xchg
    330  6a38					      lda@PLY	{1},y
    331  6a38					      sta@PLY	{1},x
    332  6a38					      lda	__xchg
    333  6a38					      sta@PLY	{1},y
    334  6a38					      ENDM		;{name}
    335  6a38
    336  6a38
      0  6a38					      DEF	Sort
      1  6a38				   BANK_Sort  SET	_CURRENT_BANK
      2  6a38				   Sort
      3  6a38				   TEMPORARY_VAR SET	Overlay
      4  6a38				   TEMPORARY_OFFSET SET	0
      5  6a38				   VAR_BOUNDARY_Sort SET	TEMPORARY_OFFSET
      6  6a38				   FUNCTION_NAME SET	Sort
      7  6a38					      SUBROUTINE
    338  6a38					      SUBROUTINE
    339  6a38
      0  6a38					      REFER	GenerateAllMoves
      1  6a38					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  6a38				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  6a38					      ENDIF
      0  6a38					      VAR	__xchg, 1
      1  6a38		       00 b3	   __xchg     =	TEMPORARY_VAR
      2  6a38				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6a38
      4  6a38				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6a38				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6a38				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6a38					      ENDIF
      8  6a38				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6a38				  -	      ECHO	"Temporary Variable", __xchg, "overflow!"
     10  6a38				  -	      ERR
     11  6a38					      ENDIF
     12  6a38					      LIST	ON
      0  6a38					      VEND	Sort
      1  6a38				  -	      IFNCONST	Sort
      2  6a38				  -	      ECHO	"Incorrect VEND label", Sort
      3  6a38				  -	      ERR
      4  6a38					      ENDIF
      5  6a38		       00 b4	   VAREND_Sort =	TEMPORARY_VAR
    343  6a38
    344  6a38							;lda currentPly
    345  6a38							;sta savedBank 	  ; ??
    346  6a38
    347  6a38		       a5 ad		      lda	__quiesceCapOnly
    348  6a3a		       30 51		      bmi	.exit	; only caps present so already sorted!
    349  6a3c
      0  6a3c					      ldx@PLY	moveIndex
      1  6a3c		       ae 4f f1 	      ldx	moveIndex
      0  6a3f					      ldy@PLY	moveIndex
      1  6a3f		       ac 4f f1 	      ldy	moveIndex
    352  6a42		       88	   .next      dey
    353  6a43		       30 48		      bmi	.exit
    354  6a45
      0  6a45					      lda@PLY	MoveCapture,y
      1  6a45		       b9 00 f1 	      lda	MoveCapture,y
    356  6a48		       f0 f8		      beq	.next
    357  6a4a
      0  6a4a					      XCHG	MoveFrom
      0  6a4a					      lda@PLY	MoveFrom,x
      1  6a4a		       bd 02 f0 	      lda	MoveFrom,x
      2  6a4d		       85 b3		      sta	__xchg
      0  6a4f					      lda@PLY	MoveFrom,y
      1  6a4f		       b9 02 f0 	      lda	MoveFrom,y
      0  6a52					      sta@PLY	MoveFrom,x
      1  6a52		       9d 02 f4 	      sta	[RAM]+MoveFrom,x
      5  6a55		       a5 b3		      lda	__xchg
      0  6a57					      sta@PLY	MoveFrom,y
      1  6a57		       99 02 f4 	      sta	[RAM]+MoveFrom,y
      0  6a5a					      XCHG	MoveTo
      0  6a5a					      lda@PLY	MoveTo,x
      1  6a5a		       bd 48 f0 	      lda	MoveTo,x
      2  6a5d		       85 b3		      sta	__xchg
      0  6a5f					      lda@PLY	MoveTo,y
      1  6a5f		       b9 48 f0 	      lda	MoveTo,y
      0  6a62					      sta@PLY	MoveTo,x
      1  6a62		       9d 48 f4 	      sta	[RAM]+MoveTo,x
      5  6a65		       a5 b3		      lda	__xchg
      0  6a67					      sta@PLY	MoveTo,y
      1  6a67		       99 48 f4 	      sta	[RAM]+MoveTo,y
      0  6a6a					      XCHG	MovePiece
      0  6a6a					      lda@PLY	MovePiece,x
      1  6a6a		       bd 8e f0 	      lda	MovePiece,x
      2  6a6d		       85 b3		      sta	__xchg
      0  6a6f					      lda@PLY	MovePiece,y
      1  6a6f		       b9 8e f0 	      lda	MovePiece,y
      0  6a72					      sta@PLY	MovePiece,x
      1  6a72		       9d 8e f4 	      sta	[RAM]+MovePiece,x
      5  6a75		       a5 b3		      lda	__xchg
      0  6a77					      sta@PLY	MovePiece,y
      1  6a77		       99 8e f4 	      sta	[RAM]+MovePiece,y
      0  6a7a					      XCHG	MoveCapture
      0  6a7a					      lda@PLY	MoveCapture,x
      1  6a7a		       bd 00 f1 	      lda	MoveCapture,x
      2  6a7d		       85 b3		      sta	__xchg
      0  6a7f					      lda@PLY	MoveCapture,y
      1  6a7f		       b9 00 f1 	      lda	MoveCapture,y
      0  6a82					      sta@PLY	MoveCapture,x
      1  6a82		       9d 00 f5 	      sta	[RAM]+MoveCapture,x
      5  6a85		       a5 b3		      lda	__xchg
      0  6a87					      sta@PLY	MoveCapture,y
      1  6a87		       99 00 f5 	      sta	[RAM]+MoveCapture,y
    362  6a8a
    363  6a8a		       ca		      dex
    364  6a8b		       10 b5		      bpl	.next
    365  6a8d
    366  6a8d				   .exit
    367  6a8d
    368  6a8d
    369  6a8d
    370  6a8d
    371  6a8d							; Scan for capture of king
    372  6a8d
      0  6a8d					      ldx@PLY	moveIndex
      1  6a8d		       ae 4f f1 	      ldx	moveIndex
    374  6a90
      0  6a90				   .scanCheck lda@PLY	MoveCapture,x
      1  6a90		       bd 00 f1 	      lda	MoveCapture,x
    376  6a93		       f0 0b		      beq	.check	; since they're sorted with captures "first" we can exit
    377  6a95		       29 0f		      and	#PIECE_MASK
    378  6a97		       c9 07		      cmp	#KING
    379  6a99		       f0 05		      beq	.check
    380  6a9b		       ca		      dex
    381  6a9c		       10 f2		      bpl	.scanCheck
    382  6a9e
    383  6a9e		       a9 00		      lda	#0
    384  6aa0		       85 9f	   .check     sta	flagCheck
    385  6aa2		       60		      rts
    386  6aa3
    387  6aa3
    388  6aa3							;---------------------------------------------------------------------------------------------------
    389  6aa3							; QUIESCE!
    390  6aa3
    391  6aa3							;int Quiesce( int alpha, int beta ) {
    392  6aa3							;    int stand_pat = Evaluate();
    393  6aa3							;    if( stand_pat >= beta )
    394  6aa3							;	  return beta;
    395  6aa3							;    if( alpha < stand_pat )
    396  6aa3							;	  alpha = stand_pat;
    397  6aa3
    398  6aa3							;    until( every_capture_has_been_examined )	{
    399  6aa3							;	  MakeCapture();
    400  6aa3							;	  score = -Quiesce( -beta, -alpha );
    401  6aa3							;	  TakeBackMove();
    402  6aa3
    403  6aa3							;	  if( score >= beta )
    404  6aa3							;	      return beta;
    405  6aa3							;	  if( score > alpha )
    406  6aa3							;	     alpha = score;
    407  6aa3							;    }
    408  6aa3							;    return alpha;
    409  6aa3							;}
    410  6aa3
    411  6aa3
      0  6aa3					      DEF	quiesce
      1  6aa3				   BANK_quiesce SET	_CURRENT_BANK
      2  6aa3				   quiesce
      3  6aa3				   TEMPORARY_VAR SET	Overlay
      4  6aa3				   TEMPORARY_OFFSET SET	0
      5  6aa3				   VAR_BOUNDARY_quiesce SET	TEMPORARY_OFFSET
      6  6aa3				   FUNCTION_NAME SET	quiesce
      7  6aa3					      SUBROUTINE
    413  6aa3					      SUBROUTINE
    414  6aa3
    415  6aa3							; pass...
    416  6aa3							; x = depthleft
    417  6aa3							; SET_BANK_RAM      --> current ply
    418  6aa3							; __alpha[2] = param alpha
    419  6aa3							; __beta[2] = param beta
    420  6aa3
    421  6aa3
      0  6aa3					      COMMON_VARS_ALPHABETA
      1  6aa3
      0  6aa3					      VAR	__thinkbar, 1
      1  6aa3		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  6aa3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6aa3
      4  6aa3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aa3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aa3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aa3					      ENDIF
      8  6aa3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aa3				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  6aa3				  -	      ERR
     11  6aa3					      ENDIF
     12  6aa3					      LIST	ON
      0  6aa3					      VAR	__toggle, 1
      1  6aa3		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  6aa3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6aa3
      4  6aa3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aa3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aa3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aa3					      ENDIF
      8  6aa3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aa3				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  6aa3				  -	      ERR
     11  6aa3					      ENDIF
     12  6aa3					      LIST	ON
      4  6aa3
      0  6aa3					      VAR	__bestMove, 1
      1  6aa3		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  6aa3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6aa3
      4  6aa3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aa3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aa3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aa3					      ENDIF
      8  6aa3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aa3				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  6aa3				  -	      ERR
     11  6aa3					      ENDIF
     12  6aa3					      LIST	ON
      0  6aa3					      VAR	__alpha, 2
      1  6aa3		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  6aa3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6aa3
      4  6aa3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aa3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aa3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aa3					      ENDIF
      8  6aa3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aa3				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  6aa3				  -	      ERR
     11  6aa3					      ENDIF
     12  6aa3					      LIST	ON
      0  6aa3					      VAR	__beta, 2
      1  6aa3		       00 a7	   __beta     =	TEMPORARY_VAR
      2  6aa3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6aa3
      4  6aa3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aa3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aa3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aa3					      ENDIF
      8  6aa3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aa3				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  6aa3				  -	      ERR
     11  6aa3					      ENDIF
     12  6aa3					      LIST	ON
      0  6aa3					      VAR	__negaMax, 2
      1  6aa3		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  6aa3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6aa3
      4  6aa3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aa3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aa3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aa3					      ENDIF
      8  6aa3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aa3				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  6aa3				  -	      ERR
     11  6aa3					      ENDIF
     12  6aa3					      LIST	ON
      0  6aa3					      VAR	__value, 2
      1  6aa3		       00 ab	   __value    =	TEMPORARY_VAR
      2  6aa3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  6aa3
      4  6aa3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aa3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aa3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aa3					      ENDIF
      8  6aa3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aa3				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  6aa3				  -	      ERR
     11  6aa3					      ENDIF
     12  6aa3					      LIST	ON
     10  6aa3
      0  6aa3					      VAR	__quiesceCapOnly, 1
      1  6aa3		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  6aa3				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  6aa3
      4  6aa3				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  6aa3				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  6aa3				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  6aa3					      ENDIF
      8  6aa3				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  6aa3				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  6aa3				  -	      ERR
     11  6aa3					      ENDIF
     12  6aa3					      LIST	ON
     12  6aa3
      0  6aa3					      REFER	selectmove
      1  6aa3				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  6aa3				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  6aa3					      ENDIF
      0  6aa3					      REFER	negaMax
      1  6aa3				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  6aa3				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  6aa3					      ENDIF
      0  6aa3					      VEND	quiesce
      1  6aa3				  -	      IFNCONST	quiesce
      2  6aa3				  -	      ECHO	"Incorrect VEND label", quiesce
      3  6aa3				  -	      ERR
      4  6aa3					      ENDIF
      5  6aa3		       00 ae	   VAREND_quiesce =	TEMPORARY_VAR
    426  6aa3
    427  6aa3		       a5 95		      lda	currentPly
    428  6aa5		       c9 16		      cmp	#MAX_PLY_DEPTH_BANK -1
    429  6aa7		       b0 43		      bcs	.retBeta
    430  6aa9
    431  6aa9							; The 'thinkbar' pattern...
    432  6aa9
    433  6aa9		       a9 00		      lda	#0
    434  6aab		       a4 4c		      ldy	INPT4
    435  6aad		       30 14		      bmi	.doThink
    436  6aaf
    437  6aaf		       a5 a2		      lda	__thinkbar
    438  6ab1		       0a		      asl
    439  6ab2		       0a		      asl
    440  6ab3		       0a		      asl
    441  6ab4		       0a		      asl
    442  6ab5		       09 02		      ora	#2
    443  6ab7		       85 48		      sta	COLUPF
    444  6ab9
    445  6ab9		       e6 a2		      inc	__thinkbar
    446  6abb		       a5 a2		      lda	__thinkbar
    447  6abd		       29 0f		      and	#15
    448  6abf		       a8		      tay
    449  6ac0		       b9 a9 f3 	      lda	SynapsePattern2,y
    450  6ac3
    451  6ac3		       85 4e	   .doThink   sta	PF1
    452  6ac5		       85 4f		      sta	PF2
    453  6ac7
    454  6ac7							; ^
    455  6ac7
    456  6ac7		       a5 a7		      lda	__beta
      0  6ac9					      sta@PLY	beta
      1  6ac9		       8d 54 f5 	      sta	[RAM]+beta
    458  6acc		       a5 a8		      lda	__beta+1
      0  6ace					      sta@PLY	beta+1
      1  6ace		       8d 55 f5 	      sta	[RAM]+beta+1
    460  6ad1
    461  6ad1		       a5 a5		      lda	__alpha
      0  6ad3					      sta@PLY	alpha
      1  6ad3		       8d 52 f5 	      sta	[RAM]+alpha
    463  6ad6		       a5 a6		      lda	__alpha+1
      0  6ad8					      sta@PLY	alpha+1
      1  6ad8		       8d 53 f5 	      sta	[RAM]+alpha+1
    465  6adb
    466  6adb
    467  6adb							;    int stand_pat = Evaluate();
    468  6adb							;    if( stand_pat >= beta )
    469  6adb							;	  return beta;
    470  6adb
    471  6adb		       38		      sec
    472  6adc		       a5 90		      lda	Evaluation
      0  6ade					      sbc@PLY	beta
      1  6ade		       ed 54 f1 	      sbc	beta
    474  6ae1		       a5 91		      lda	Evaluation+1
      0  6ae3					      sbc@PLY	beta+1
      1  6ae3		       ed 55 f1 	      sbc	beta+1
    476  6ae6		       50 02		      bvc	.spat0
    477  6ae8		       49 80		      eor	#$80
    478  6aea		       30 0b	   .spat0     bmi	.norb	;pl .retBeta			 ; branch if stand_pat >= beta
    479  6aec
    480  6aec		       ad 54 f1    .retBeta   lda	beta
    481  6aef		       85 a9		      sta	__negaMax
    482  6af1		       ad 55 f1 	      lda	beta+1
    483  6af4		       85 aa		      sta	__negaMax+1
    484  6af6
    485  6af6		       60	   .abort     rts
    486  6af7
    487  6af7				   .norb
    488  6af7
    489  6af7
    490  6af7							;    if( alpha < stand_pat )
    491  6af7							;	  alpha = stand_pat;
    492  6af7
    493  6af7		       38		      sec
    494  6af8		       ad 52 f1 	      lda	alpha
    495  6afb		       e5 90		      sbc	Evaluation
    496  6afd		       ad 53 f1 	      lda	alpha+1
    497  6b00		       e5 91		      sbc	Evaluation+1
    498  6b02		       50 02		      bvc	.spat1
    499  6b04		       49 80		      eor	#$80
    500  6b06		       10 0a	   .spat1     bpl	.alpha	; branch if alpha >= stand_pat
    501  6b08
    502  6b08							; alpha < stand_pat
    503  6b08
    504  6b08		       a5 90		      lda	Evaluation
      0  6b0a					      sta@PLY	alpha
      1  6b0a		       8d 52 f5 	      sta	[RAM]+alpha
    506  6b0d		       a5 91		      lda	Evaluation+1
      0  6b0f					      sta@PLY	alpha+1
      1  6b0f		       8d 53 f5 	      sta	[RAM]+alpha+1
    508  6b12
    509  6b12				   .alpha
    510  6b12		       20 07 f9 	      jsr	GenerateAllMoves
    511  6b15		       a5 9f		      lda	flagCheck
    512  6b17		       d0 dd		      bne	.abort	; pure abort
    513  6b19
      0  6b19					      ldx@PLY	moveIndex
      1  6b19		       ae 4f f1 	      ldx	moveIndex
    515  6b1c		       30 7a		      bmi	.exit
    516  6b1e
      0  6b1e				   .forChild  stx@PLY	movePtr
      1  6b1e		       8e 50 f5 	      stx	[RAM]+movePtr
    518  6b21
    519  6b21							; The movelist has captures ONLY (ref: __quiesceCapOnly != 0)
    520  6b21
    521  6b21		       20 dc fd 	      jsr	MakeMove
    522  6b24
    523  6b24		       38		      sec
    524  6b25		       a9 00		      lda	#0
      0  6b27					      sbc@PLY	beta
      1  6b27		       ed 54 f1 	      sbc	beta
    526  6b2a		       85 a5		      sta	__alpha
    527  6b2c		       a9 00		      lda	#0
      0  6b2e					      sbc@PLY	beta+1
      1  6b2e		       ed 55 f1 	      sbc	beta+1
    529  6b31		       85 a6		      sta	__alpha+1
    530  6b33
    531  6b33		       38		      sec
    532  6b34		       a9 00		      lda	#0
      0  6b36					      sbc@PLY	alpha
      1  6b36		       ed 52 f1 	      sbc	alpha
    534  6b39		       85 a7		      sta	__beta
    535  6b3b		       a9 00		      lda	#0
      0  6b3d					      sbc@PLY	alpha+1
      1  6b3d		       ed 53 f1 	      sbc	alpha+1
    537  6b40		       85 a8		      sta	__beta+1
    538  6b42
    539  6b42		       e6 95		      inc	currentPly
    540  6b44		       a5 95		      lda	currentPly
    541  6b46		       85 3e		      sta	SET_BANK_RAM	; self-switch
    542  6b48
    543  6b48		       20 a3 f2 	      jsr	quiesce
    544  6b4b
    545  6b4b		       c6 95		      dec	currentPly
    546  6b4d		       a5 95		      lda	currentPly
    547  6b4f		       85 3e		      sta	SET_BANK_RAM
    548  6b51
    549  6b51		       20 4f fe 	      jsr	unmakeMove
    550  6b54
    551  6b54		       a5 9f		      lda	flagCheck	; don't consider moves which leave us in check
    552  6b56		       d0 4b		      bne	.inCheck
    553  6b58
    554  6b58		       38		      sec
    555  6b59							;lda #0			 ; already 0
    556  6b59		       e5 a9		      sbc	__negaMax
    557  6b5b		       85 a9		      sta	__negaMax
    558  6b5d		       a9 00		      lda	#0
    559  6b5f		       e5 aa		      sbc	__negaMax+1
    560  6b61		       85 aa		      sta	__negaMax+1	; -negaMax(...)
    561  6b63
    562  6b63
    563  6b63
    564  6b63							;	  if( score >= beta )
    565  6b63							;	      return beta;
    566  6b63
    567  6b63
    568  6b63		       38		      sec
    569  6b64		       a5 a9		      lda	__negaMax
      0  6b66					      sbc@PLY	beta
      1  6b66		       ed 54 f1 	      sbc	beta
    571  6b69		       a5 aa		      lda	__negaMax+1
      0  6b6b					      sbc@PLY	beta+1
      1  6b6b		       ed 55 f1 	      sbc	beta+1
    573  6b6e		       50 02		      bvc	.lab0
    574  6b70		       49 80		      eor	#$80
    575  6b72		       30 03	   .lab0      bmi	.nrb2	; .retBeta		       ; branch if score >= beta
    576  6b74		       4c ec f2 	      jmp	.retBeta
    577  6b77				   .nrb2
    578  6b77
    579  6b77							;	  if( score > alpha )
    580  6b77							;	     alpha = score;
    581  6b77							;    }
    582  6b77
    583  6b77		       38		      sec
      0  6b78					      lda@PLY	alpha
      1  6b78		       ad 52 f1 	      lda	alpha
    585  6b7b		       e5 a9		      sbc	__negaMax
      0  6b7d					      lda@PLY	alpha+1
      1  6b7d		       ad 53 f1 	      lda	alpha+1
    587  6b80		       e5 aa		      sbc	__negaMax+1
    588  6b82		       50 02		      bvc	.lab2
    589  6b84		       49 80		      eor	#$80
    590  6b86		       10 0a	   .lab2      bpl	.nextMove	; alpha >= score
    591  6b88
    592  6b88							; score > alpha
    593  6b88
    594  6b88		       a5 a9		      lda	__negaMax
      0  6b8a					      sta@PLY	alpha
      1  6b8a		       8d 52 f5 	      sta	[RAM]+alpha
    596  6b8d		       a5 aa		      lda	__negaMax+1
      0  6b8f					      sta@PLY	alpha+1
      1  6b8f		       8d 53 f5 	      sta	[RAM]+alpha+1
    598  6b92
      0  6b92				   .nextMove  ldx@PLY	movePtr
      1  6b92		       ae 50 f1 	      ldx	movePtr
    600  6b95		       ca		      dex
    601  6b96		       10 86		      bpl	.forChild
    602  6b98
    603  6b98							;    return alpha;
    604  6b98
    605  6b98				   .exit
      0  6b98					      lda@PLY	alpha
      1  6b98		       ad 52 f1 	      lda	alpha
    607  6b9b		       85 a9		      sta	__negaMax
      0  6b9d					      lda@PLY	alpha+1
      1  6b9d		       ad 53 f1 	      lda	alpha+1
    609  6ba0		       85 aa		      sta	__negaMax+1
    610  6ba2		       60		      rts
    611  6ba3
    612  6ba3		       a9 00	   .inCheck   lda	#0
    613  6ba5		       85 9f		      sta	flagCheck
    614  6ba7		       f0 e9		      beq	.nextMove
    615  6ba9
    616  6ba9
    617  6ba9
    618  6ba9				   SynapsePattern2
    619  6ba9
    620  6ba9		       c1		      .byte.b	%11000001
    621  6baa		       60		      .byte.b	%01100000
    622  6bab		       30		      .byte.b	%00110000
    623  6bac		       18		      .byte.b	%00011000
    624  6bad		       0c		      .byte.b	%00001100
    625  6bae		       06		      .byte.b	%00000110
    626  6baf		       83		      .byte.b	%10000011
    627  6bb0		       c1		      .byte.b	%11000001
    628  6bb1
    629  6bb1		       83		      .byte.b	%10000011
    630  6bb2		       06		      .byte.b	%00000110
    631  6bb3		       0c		      .byte.b	%00001100
    632  6bb4		       18		      .byte.b	%00011000
    633  6bb5		       30		      .byte.b	%00110000
    634  6bb6		       60		      .byte.b	%01100000
    635  6bb7		       c1		      .byte.b	%11000001
    636  6bb8		       83		      .byte.b	%10000011
    637  6bb9
    638  6bb9
    639  6bb9							;---------------------------------------------------------------------------------------------------
    640  6bb9
      0  6bb9					      DEF	AddMovePly
      1  6bb9				   BANK_AddMovePly SET	_CURRENT_BANK
      2  6bb9				   AddMovePly
      3  6bb9				   TEMPORARY_VAR SET	Overlay
      4  6bb9				   TEMPORARY_OFFSET SET	0
      5  6bb9				   VAR_BOUNDARY_AddMovePly SET	TEMPORARY_OFFSET
      6  6bb9				   FUNCTION_NAME SET	AddMovePly
      7  6bb9					      SUBROUTINE
    642  6bb9					      SUBROUTINE
    643  6bb9
      0  6bb9					      REFER	AddMove
      1  6bb9				  -	      IF	VAREND_AddMove > TEMPORARY_VAR
      2  6bb9				  -TEMPORARY_VAR SET	VAREND_AddMove
      3  6bb9					      ENDIF
      0  6bb9					      VEND	AddMovePly
      1  6bb9				  -	      IFNCONST	AddMovePly
      2  6bb9				  -	      ECHO	"Incorrect VEND label", AddMovePly
      3  6bb9				  -	      ERR
      4  6bb9					      ENDIF
      5  6bb9		       00 a2	   VAREND_AddMovePly =	TEMPORARY_VAR
    646  6bb9
    647  6bb9		       98		      tya
    648  6bba
      0  6bba					      ldy@PLY	moveIndex
      1  6bba		       ac 4f f1 	      ldy	moveIndex
    650  6bbd		       c8		      iny
      0  6bbe					      sty@PLY	moveIndex
      1  6bbe		       8c 4f f5 	      sty	[RAM]+moveIndex
    652  6bc1
      0  6bc1					      sta@PLY	MoveTo,y
      1  6bc1		       99 48 f4 	      sta	[RAM]+MoveTo,y
    654  6bc4		       aa		      tax		; used for continuation of sliding moves
    655  6bc5		       a5 93		      lda	currentSquare
      0  6bc7					      sta@PLY	MoveFrom,y
      1  6bc7		       99 02 f4 	      sta	[RAM]+MoveFrom,y
    657  6bca		       a5 92		      lda	currentPiece
      0  6bcc					      sta@PLY	MovePiece,y
      1  6bcc		       99 8e f4 	      sta	[RAM]+MovePiece,y
    659  6bcf		       a5 9e		      lda	capture
      0  6bd1					      sta@PLY	MoveCapture,y
      1  6bd1		       99 00 f5 	      sta	[RAM]+MoveCapture,y
    661  6bd4
    662  6bd4		       60		      rts
    663  6bd5
    664  6bd5
    665  6bd5							;---------------------------------------------------------------------------------------------------
    666  6bd5
      0  6bd5					      CHECK_HALF_BANK_SIZE	"PLY -- 1K"
      1  6bd5
      2  6bd5
      3  6bd5		       03 d5	   .TEMP      =	* - BANK_START
 PLY -- 1K (1K) SIZE =  $3d5 , FREE= $2b
      4  6bd5					      ECHO	"PLY -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  6bd5				  -	      IF	( .TEMP ) > ROM_BANK_SIZE/2
      6  6bd5				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  6bd5				  -	      ERR
      8  6bd5					      ENDIF
    668  6bd5
    669  6bd5							;---------------------------------------------------------------------------------------------------
    670  6bd5
    671  6bd5							; There is space here (1K) for use as ROM
    672  6bd5							; but NOT when the above bank is switched in as RAM, of course!
    673  6bd5
    674  6bd5
    675  6bd5
    676  6bd5
    677  6bd5							;---------------------------------------------------------------------------------------------------
    678  6bd5							; EOF
------- FILE ./chess.asm
------- FILE BANK_EVAL.asm LEVEL 2 PASS 5
      0  6bd5					      include	"BANK_EVAL.asm"
      0  6bd5					      NEWRAMBANK	BANK_EVAL
      1  6bd5
      2  6bd5
      3  6bd5
      4 U5c00 ????				      SEG.U	BANK_EVAL
      5 U5c00					      ORG	ORIGIN_RAM
      6 U5c00					      RORG	RAM_3E
      7 U5c00				   BANK_START SET	*
      8 U5c00				   RAMBANK_BANK_EVAL SET	ORIGIN_RAM / RAM_SIZE
      9 U5c00				   _CURRENT_RAMBANK SET	RAMBANK_BANK_EVAL
     10 U5c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U5c00					      NEWBANK	EVAL
      1  7366 ????				      SEG	EVAL
      2  7000					      ORG	ORIGIN
      3  7000					      RORG	$F000
      4  7000				   BANK_START SET	*
      5  7000				   EVAL       SET	ORIGIN / 2048
      6  7000				   ORIGIN     SET	ORIGIN + 2048
      7  7000				   _CURRENT_BANK SET	EVAL
      3  7000
      4  7000
      5  7000							; see https://www.chessprogramming.org/Simplified_Evaluation_Function
      6  7000
      7  7000
      8  7000
      9  7000					      MAC	vequ
     10  7000				   VALUE_{1}  =	{2}
     11  7000					      ENDM
     12  7000
     13  7000					      MAC	lobyte
     14  7000					      .byte	<{2}
     15  7000					      ENDM
     16  7000
     17  7000					      MAC	hibyte
     18  7000					      .byte	>{2}
     19  7000					      ENDM
     20  7000
     21  7000
     22  7000					      MAC	valuetable
     23  7000					      {1}	BLANK, 0
     24  7000					      {1}	PAWN, 100	; white
     25  7000					      {1}	PAWN, 100	; black
     26  7000					      {1}	KNIGHT, 320
     27  7000					      {1}	BISHOP, 375
     28  7000					      {1}	ROOK, 575
     29  7000					      {1}	QUEEN, 900
     30  7000					      {1}	KING, 10000
     31  7000					      ENDM
     32  7000
     33  7000
      0  7000					      VALUETABLE	VEQU
      0  7000					      VEQU	BLANK, 0
      1  7000		       00 00	   VALUE_BLANK =	0
      0  7000					      VEQU	PAWN, 100
      1  7000		       00 64	   VALUE_PAWN =	100
      0  7000					      VEQU	PAWN, 100
      1  7000		       00 64	   VALUE_PAWN =	100
      0  7000					      VEQU	KNIGHT, 320
      1  7000		       01 40	   VALUE_KNIGHT =	320
      0  7000					      VEQU	BISHOP, 375
      1  7000		       01 77	   VALUE_BISHOP =	375
      0  7000					      VEQU	ROOK, 575
      1  7000		       02 3f	   VALUE_ROOK =	575
      0  7000					      VEQU	QUEEN, 900
      1  7000		       03 84	   VALUE_QUEEN =	900
      0  7000					      VEQU	KING, 10000
      1  7000		       27 10	   VALUE_KING =	10000
     35  7000
      0  7000					      DEF	PieceValueLO
      1  7000				   BANK_PieceValueLO SET	_CURRENT_BANK
      2  7000				   PieceValueLO
      3  7000				   TEMPORARY_VAR SET	Overlay
      4  7000				   TEMPORARY_OFFSET SET	0
      5  7000				   VAR_BOUNDARY_PieceValueLO SET	TEMPORARY_OFFSET
      6  7000				   FUNCTION_NAME SET	PieceValueLO
      7  7000					      SUBROUTINE
      0  7000					      VALUETABLE	LOBYTE
      0  7000					      LOBYTE	BLANK, 0
      1  7000		       00		      .byte.b	<0
      0  7001					      LOBYTE	PAWN, 100
      1  7001		       64		      .byte.b	<100
      0  7002					      LOBYTE	PAWN, 100
      1  7002		       64		      .byte.b	<100
      0  7003					      LOBYTE	KNIGHT, 320
      1  7003		       40		      .byte.b	<320
      0  7004					      LOBYTE	BISHOP, 375
      1  7004		       77		      .byte.b	<375
      0  7005					      LOBYTE	ROOK, 575
      1  7005		       3f		      .byte.b	<575
      0  7006					      LOBYTE	QUEEN, 900
      1  7006		       84		      .byte.b	<900
      0  7007					      LOBYTE	KING, 10000
      1  7007		       10		      .byte.b	<10000
     38  7008
      0  7008					      DEF	PieceValueHI
      1  7008				   BANK_PieceValueHI SET	_CURRENT_BANK
      2  7008				   PieceValueHI
      3  7008				   TEMPORARY_VAR SET	Overlay
      4  7008				   TEMPORARY_OFFSET SET	0
      5  7008				   VAR_BOUNDARY_PieceValueHI SET	TEMPORARY_OFFSET
      6  7008				   FUNCTION_NAME SET	PieceValueHI
      7  7008					      SUBROUTINE
      0  7008					      VALUETABLE	HIBYTE
      0  7008					      HIBYTE	BLANK, 0
      1  7008		       00		      .byte.b	>0
      0  7009					      HIBYTE	PAWN, 100
      1  7009		       00		      .byte.b	>100
      0  700a					      HIBYTE	PAWN, 100
      1  700a		       00		      .byte.b	>100
      0  700b					      HIBYTE	KNIGHT, 320
      1  700b		       01		      .byte.b	>320
      0  700c					      HIBYTE	BISHOP, 375
      1  700c		       01		      .byte.b	>375
      0  700d					      HIBYTE	ROOK, 575
      1  700d		       02		      .byte.b	>575
      0  700e					      HIBYTE	QUEEN, 900
      1  700e		       03		      .byte.b	>900
      0  700f					      HIBYTE	KING, 10000
      1  700f		       27		      .byte.b	>10000
     41  7010
     42  7010							;---------------------------------------------------------------------------------------------------
     43  7010
      0  7010					      DEF	EnPassantRemovePiece
      1  7010				   BANK_EnPassantRemovePiece SET	_CURRENT_BANK
      2  7010				   EnPassantRemovePiece
      3  7010				   TEMPORARY_VAR SET	Overlay
      4  7010				   TEMPORARY_OFFSET SET	0
      5  7010				   VAR_BOUNDARY_EnPassantRemovePiece SET	TEMPORARY_OFFSET
      6  7010				   FUNCTION_NAME SET	EnPassantRemovePiece
      7  7010					      SUBROUTINE
     45  7010					      SUBROUTINE
     46  7010
      0  7010					      REFER	MakeMove
      1  7010					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  7010				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  7010					      ENDIF
     48  7010					      IF	ENPASSANT_ENABLED
      0  7010					      REFER	EnPassantCheck
      1  7010				  -	      IF	VAREND_EnPassantCheck > TEMPORARY_VAR
      2  7010				  -TEMPORARY_VAR SET	VAREND_EnPassantCheck
      3  7010					      ENDIF
     50  7010					      ENDIF
      0  7010					      VAR	__y, 1
      1  7010		       00 b0	   __y	      =	TEMPORARY_VAR
      2  7010				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7010
      4  7010				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7010				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7010				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7010					      ENDIF
      8  7010				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7010				  -	      ECHO	"Temporary Variable", __y, "overflow!"
     10  7010				  -	      ERR
     11  7010					      ENDIF
     12  7010					      LIST	ON
      0  7010					      VAR	__col, 1
      1  7010		       00 b1	   __col      =	TEMPORARY_VAR
      2  7010				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7010
      4  7010				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7010				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7010				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7010					      ENDIF
      8  7010				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7010				  -	      ECHO	"Temporary Variable", __col, "overflow!"
     10  7010				  -	      ERR
     11  7010					      ENDIF
     12  7010					      LIST	ON
      0  7010					      VEND	EnPassantRemovePiece
      1  7010				  -	      IFNCONST	EnPassantRemovePiece
      2  7010				  -	      ECHO	"Incorrect VEND label", EnPassantRemovePiece
      3  7010				  -	      ERR
      4  7010					      ENDIF
      5  7010		       00 b2	   VAREND_EnPassantRemovePiece =	TEMPORARY_VAR
     54  7010
     55  7010
     56  7010							; Based on piece square, adjust material and position value with piece deleted
     57  7010							; y = piece square
     58  7010
     59  7010		       84 b0		      sty	__y
     60  7012
     61  7012		       20 dc fc 	      jsr	GetBoard
     62  7015		       85 b1		      sta	__col
     63  7017		       20 26 f0 	      jsr	AddPieceMaterialValue	; adding for opponent = taking
     64  701a
     65  701a		       a5 b1		      lda	__col
     66  701c		       a4 b0		      ldy	__y
     67  701e		       20 39 f0 	      jsr	AddPiecePositionValue	; adding for opponent = taking
     68  7021
     69  7021		       a5 95		      lda	currentPly
     70  7023		       85 3e		      sta	SET_BANK_RAM
     71  7025		       60		      rts
     72  7026
     73  7026
     74  7026							;---------------------------------------------------------------------------------------------------
     75  7026
      0  7026					      DEF	AddPieceMaterialValue
      1  7026				   BANK_AddPieceMaterialValue SET	_CURRENT_BANK
      2  7026				   AddPieceMaterialValue
      3  7026				   TEMPORARY_VAR SET	Overlay
      4  7026				   TEMPORARY_OFFSET SET	0
      5  7026				   VAR_BOUNDARY_AddPieceMaterialValue SET	TEMPORARY_OFFSET
      6  7026				   FUNCTION_NAME SET	AddPieceMaterialValue
      7  7026					      SUBROUTINE
     77  7026					      SUBROUTINE
     78  7026
      0  7026					      REFER	AdjustMaterialPositionalValue
      1  7026					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  7026				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  7026					      ENDIF
      0  7026					      REFER	InitialisePieceSquares
      1  7026				  -	      IF	VAREND_InitialisePieceSquares > TEMPORARY_VAR
      2  7026				  -TEMPORARY_VAR SET	VAREND_InitialisePieceSquares
      3  7026					      ENDIF
      0  7026					      REFER	EnPassantRemovePiece
      1  7026				  -	      IF	VAREND_EnPassantRemovePiece > TEMPORARY_VAR
      2  7026				  -TEMPORARY_VAR SET	VAREND_EnPassantRemovePiece
      3  7026					      ENDIF
      0  7026					      VEND	AddPieceMaterialValue
      1  7026				  -	      IFNCONST	AddPieceMaterialValue
      2  7026				  -	      ECHO	"Incorrect VEND label", AddPieceMaterialValue
      3  7026				  -	      ERR
      4  7026					      ENDIF
      5  7026		       00 b2	   VAREND_AddPieceMaterialValue =	TEMPORARY_VAR
     83  7026
     84  7026							; Adjust the material score based on the piece
     85  7026							; a = piece type + flags
     86  7026
     87  7026		       29 0f		      and	#PIECE_MASK
     88  7028		       a8		      tay
     89  7029
     90  7029		       18		      clc
     91  702a		       b9 00 f0 	      lda	PieceValueLO,y
     92  702d		       65 90		      adc	Evaluation
     93  702f		       85 90		      sta	Evaluation
     94  7031		       b9 08 f0 	      lda	PieceValueHI,y
     95  7034		       65 91		      adc	Evaluation+1
     96  7036		       85 91		      sta	Evaluation+1
     97  7038		       60		      rts
     98  7039
     99  7039
    100  7039							;---------------------------------------------------------------------------------------------------
    101  7039
      0  7039					      DEF	AddPiecePositionValue
      1  7039				   BANK_AddPiecePositionValue SET	_CURRENT_BANK
      2  7039				   AddPiecePositionValue
      3  7039				   TEMPORARY_VAR SET	Overlay
      4  7039				   TEMPORARY_OFFSET SET	0
      5  7039				   VAR_BOUNDARY_AddPiecePositionValue SET	TEMPORARY_OFFSET
      6  7039				   FUNCTION_NAME SET	AddPiecePositionValue
      7  7039					      SUBROUTINE
    103  7039					      SUBROUTINE
    104  7039
      0  7039					      REFER	AdjustMaterialPositionalValue
      1  7039					      IF	VAREND_AdjustMaterialPositionalValue > TEMPORARY_VAR
      2  7039				   TEMPORARY_VAR SET	VAREND_AdjustMaterialPositionalValue
      3  7039					      ENDIF
      0  7039					      REFER	negaMax
      1  7039				  -	      IF	VAREND_negaMax > TEMPORARY_VAR
      2  7039				  -TEMPORARY_VAR SET	VAREND_negaMax
      3  7039					      ENDIF
      0  7039					      REFER	quiesce
      1  7039				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  7039				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  7039					      ENDIF
      0  7039					      VAR	__valPtr, 2
      1  7039		       00 b2	   __valPtr   =	TEMPORARY_VAR
      2  7039				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  7039
      4  7039				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7039				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7039				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7039					      ENDIF
      8  7039				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7039				  -	      ECHO	"Temporary Variable", __valPtr, "overflow!"
     10  7039				  -	      ERR
     11  7039					      ENDIF
     12  7039					      LIST	ON
      0  7039					      VEND	AddPiecePositionValue
      1  7039				  -	      IFNCONST	AddPiecePositionValue
      2  7039				  -	      ECHO	"Incorrect VEND label", AddPiecePositionValue
      3  7039				  -	      ERR
      4  7039					      ENDIF
      5  7039		       00 b4	   VAREND_AddPiecePositionValue =	TEMPORARY_VAR
    110  7039
    111  7039
    112  7039							; adds value of square piece is on to the evaluation
    113  7039							; note to do the subtraction as -( -x + val) == x - val
    114  7039
    115  7039							; y = square
    116  7039							; a = piece type (+flags)
    117  7039
    118  7039
    119  7039
    120  7039		       c9 80		      cmp	#128	; black = CS
    121  703b		       29 0f		      and	#PIECE_MASK
    122  703d		       aa		      tax
    123  703e
    124  703e							; black pieces flip rows so we can use the same eval tables
    125  703e
    126  703e		       98		      tya
    127  703f		       90 03		      bcc	.white
    128  7041		       b9 72 f0 	      lda	FlipSquareIndex,y
    129  7044							;clc
    130  7044				   .white
    131  7044		       7d d6 f0 	      adc	PosValVecLO,x
    132  7047		       85 b2		      sta	__valPtr
    133  7049		       bd de f0 	      lda	PosValVecHI,x
    134  704c		       69 00		      adc	#0
    135  704e		       85 b3		      sta	__valPtr+1
    136  7050
    137  7050		       a0 00		      ldy	#0
    138  7052		       b1 b2		      lda	(__valPtr),y
    139  7054
    140  7054							;clc
    141  7054		       65 90		      adc	Evaluation
    142  7056		       85 90		      sta	Evaluation
    143  7058		       90 02		      bcc	.noH
    144  705a		       e6 91		      inc	Evaluation+1
    145  705c		       60	   .noH       rts
    146  705d
    147  705d
    148  705d
      0  705d					      DEF	IncVal
      1  705d				   BANK_IncVal SET	_CURRENT_BANK
      2  705d				   IncVal
      3  705d				   TEMPORARY_VAR SET	Overlay
      4  705d				   TEMPORARY_OFFSET SET	0
      5  705d				   VAR_BOUNDARY_IncVal SET	TEMPORARY_OFFSET
      6  705d				   FUNCTION_NAME SET	IncVal
      7  705d					      SUBROUTINE
    150  705d					      SUBROUTINE
    151  705d
    152  705d		       a2 63		      ldx	#99
    153  705f		       18	   .higher    clc
      0  7060					      lda@RAM	PositionalValue_PAWN_BLACK,x
      1  7060		       bd 36 f1 	      lda	PositionalValue_PAWN_BLACK,x
    155  7063		       69 0a		      adc	#10
    156  7065		       c9 7f		      cmp	#$7F
    157  7067		       90 02		      bcc	.norm
    158  7069		       a9 7f		      lda	#$7f
      0  706b				   .norm      sta@RAM	PositionalValue_PAWN_BLACK,x
      1  706b		       9d 36 f5 	      sta	[RAM]+PositionalValue_PAWN_BLACK,x
    160  706e		       ca		      dex
    161  706f		       10 ee		      bpl	.higher
    162  7071		       60		      rts
    163  7072
    164  7072							;---------------------------------------------------------------------------------------------------
    165  7072
      0  7072					      ALLOCATE	FlipSquareIndex, 100
      0  7072					      OPTIONAL_PAGEBREAK	"Table", 100
     12  7072					      LIST	ON
      0  7072					      DEF	FlipSquareIndex
      1  7072				   BANK_FlipSquareIndex SET	_CURRENT_BANK
      2  7072				   FlipSquareIndex
      3  7072				   TEMPORARY_VAR SET	Overlay
      4  7072				   TEMPORARY_OFFSET SET	0
      5  7072				   VAR_BOUNDARY_FlipSquareIndex SET	TEMPORARY_OFFSET
      6  7072				   FUNCTION_NAME SET	FlipSquareIndex
      7  7072					      SUBROUTINE
    167  7072
    168  7072		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    169  707c		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0,0,0
    170  7086
    171  7086				   .SQBASE    SET	90-1
    172  7086					      REPEAT	8
    173  7086		       00 00		      .byte.b	0,0
    174  7086				   .SQX       SET	2
    175  7088					      REPEAT	8
    176  7088		       5b		      .byte.b	(.SQBASE+.SQX)
    177  7088				   .SQX       SET	.SQX + 1
    175  7088					      REPEND
    176  7089		       5c		      .byte.b	(.SQBASE+.SQX)
    177  7089				   .SQX       SET	.SQX + 1
    175  7089					      REPEND
    176  708a		       5d		      .byte.b	(.SQBASE+.SQX)
    177  708a				   .SQX       SET	.SQX + 1
    175  708a					      REPEND
    176  708b		       5e		      .byte.b	(.SQBASE+.SQX)
    177  708b				   .SQX       SET	.SQX + 1
    175  708b					      REPEND
    176  708c		       5f		      .byte.b	(.SQBASE+.SQX)
    177  708c				   .SQX       SET	.SQX + 1
    175  708c					      REPEND
    176  708d		       60		      .byte.b	(.SQBASE+.SQX)
    177  708d				   .SQX       SET	.SQX + 1
    175  708d					      REPEND
    176  708e		       61		      .byte.b	(.SQBASE+.SQX)
    177  708e				   .SQX       SET	.SQX + 1
    175  708e					      REPEND
    176  708f		       62		      .byte.b	(.SQBASE+.SQX)
    177  708f				   .SQX       SET	.SQX + 1
    178  7090					      REPEND
    179  7090				   .SQBASE    SET	.SQBASE - 10
    172  7090					      REPEND
    173  7090		       00 00		      .byte.b	0,0
    174  7090				   .SQX       SET	2
    175  7092					      REPEAT	8
    176  7092		       51		      .byte.b	(.SQBASE+.SQX)
    177  7092				   .SQX       SET	.SQX + 1
    175  7092					      REPEND
    176  7093		       52		      .byte.b	(.SQBASE+.SQX)
    177  7093				   .SQX       SET	.SQX + 1
    175  7093					      REPEND
    176  7094		       53		      .byte.b	(.SQBASE+.SQX)
    177  7094				   .SQX       SET	.SQX + 1
    175  7094					      REPEND
    176  7095		       54		      .byte.b	(.SQBASE+.SQX)
    177  7095				   .SQX       SET	.SQX + 1
    175  7095					      REPEND
    176  7096		       55		      .byte.b	(.SQBASE+.SQX)
    177  7096				   .SQX       SET	.SQX + 1
    175  7096					      REPEND
    176  7097		       56		      .byte.b	(.SQBASE+.SQX)
    177  7097				   .SQX       SET	.SQX + 1
    175  7097					      REPEND
    176  7098		       57		      .byte.b	(.SQBASE+.SQX)
    177  7098				   .SQX       SET	.SQX + 1
    175  7098					      REPEND
    176  7099		       58		      .byte.b	(.SQBASE+.SQX)
    177  7099				   .SQX       SET	.SQX + 1
    178  709a					      REPEND
    179  709a				   .SQBASE    SET	.SQBASE - 10
    172  709a					      REPEND
    173  709a		       00 00		      .byte.b	0,0
    174  709a				   .SQX       SET	2
    175  709c					      REPEAT	8
    176  709c		       47		      .byte.b	(.SQBASE+.SQX)
    177  709c				   .SQX       SET	.SQX + 1
    175  709c					      REPEND
    176  709d		       48		      .byte.b	(.SQBASE+.SQX)
    177  709d				   .SQX       SET	.SQX + 1
    175  709d					      REPEND
    176  709e		       49		      .byte.b	(.SQBASE+.SQX)
    177  709e				   .SQX       SET	.SQX + 1
    175  709e					      REPEND
    176  709f		       4a		      .byte.b	(.SQBASE+.SQX)
    177  709f				   .SQX       SET	.SQX + 1
    175  709f					      REPEND
    176  70a0		       4b		      .byte.b	(.SQBASE+.SQX)
    177  70a0				   .SQX       SET	.SQX + 1
    175  70a0					      REPEND
    176  70a1		       4c		      .byte.b	(.SQBASE+.SQX)
    177  70a1				   .SQX       SET	.SQX + 1
    175  70a1					      REPEND
    176  70a2		       4d		      .byte.b	(.SQBASE+.SQX)
    177  70a2				   .SQX       SET	.SQX + 1
    175  70a2					      REPEND
    176  70a3		       4e		      .byte.b	(.SQBASE+.SQX)
    177  70a3				   .SQX       SET	.SQX + 1
    178  70a4					      REPEND
    179  70a4				   .SQBASE    SET	.SQBASE - 10
    172  70a4					      REPEND
    173  70a4		       00 00		      .byte.b	0,0
    174  70a4				   .SQX       SET	2
    175  70a6					      REPEAT	8
    176  70a6		       3d		      .byte.b	(.SQBASE+.SQX)
    177  70a6				   .SQX       SET	.SQX + 1
    175  70a6					      REPEND
    176  70a7		       3e		      .byte.b	(.SQBASE+.SQX)
    177  70a7				   .SQX       SET	.SQX + 1
    175  70a7					      REPEND
    176  70a8		       3f		      .byte.b	(.SQBASE+.SQX)
    177  70a8				   .SQX       SET	.SQX + 1
    175  70a8					      REPEND
    176  70a9		       40		      .byte.b	(.SQBASE+.SQX)
    177  70a9				   .SQX       SET	.SQX + 1
    175  70a9					      REPEND
    176  70aa		       41		      .byte.b	(.SQBASE+.SQX)
    177  70aa				   .SQX       SET	.SQX + 1
    175  70aa					      REPEND
    176  70ab		       42		      .byte.b	(.SQBASE+.SQX)
    177  70ab				   .SQX       SET	.SQX + 1
    175  70ab					      REPEND
    176  70ac		       43		      .byte.b	(.SQBASE+.SQX)
    177  70ac				   .SQX       SET	.SQX + 1
    175  70ac					      REPEND
    176  70ad		       44		      .byte.b	(.SQBASE+.SQX)
    177  70ad				   .SQX       SET	.SQX + 1
    178  70ae					      REPEND
    179  70ae				   .SQBASE    SET	.SQBASE - 10
    172  70ae					      REPEND
    173  70ae		       00 00		      .byte.b	0,0
    174  70ae				   .SQX       SET	2
    175  70b0					      REPEAT	8
    176  70b0		       33		      .byte.b	(.SQBASE+.SQX)
    177  70b0				   .SQX       SET	.SQX + 1
    175  70b0					      REPEND
    176  70b1		       34		      .byte.b	(.SQBASE+.SQX)
    177  70b1				   .SQX       SET	.SQX + 1
    175  70b1					      REPEND
    176  70b2		       35		      .byte.b	(.SQBASE+.SQX)
    177  70b2				   .SQX       SET	.SQX + 1
    175  70b2					      REPEND
    176  70b3		       36		      .byte.b	(.SQBASE+.SQX)
    177  70b3				   .SQX       SET	.SQX + 1
    175  70b3					      REPEND
    176  70b4		       37		      .byte.b	(.SQBASE+.SQX)
    177  70b4				   .SQX       SET	.SQX + 1
    175  70b4					      REPEND
    176  70b5		       38		      .byte.b	(.SQBASE+.SQX)
    177  70b5				   .SQX       SET	.SQX + 1
    175  70b5					      REPEND
    176  70b6		       39		      .byte.b	(.SQBASE+.SQX)
    177  70b6				   .SQX       SET	.SQX + 1
    175  70b6					      REPEND
    176  70b7		       3a		      .byte.b	(.SQBASE+.SQX)
    177  70b7				   .SQX       SET	.SQX + 1
    178  70b8					      REPEND
    179  70b8				   .SQBASE    SET	.SQBASE - 10
    172  70b8					      REPEND
    173  70b8		       00 00		      .byte.b	0,0
    174  70b8				   .SQX       SET	2
    175  70ba					      REPEAT	8
    176  70ba		       29		      .byte.b	(.SQBASE+.SQX)
    177  70ba				   .SQX       SET	.SQX + 1
    175  70ba					      REPEND
    176  70bb		       2a		      .byte.b	(.SQBASE+.SQX)
    177  70bb				   .SQX       SET	.SQX + 1
    175  70bb					      REPEND
    176  70bc		       2b		      .byte.b	(.SQBASE+.SQX)
    177  70bc				   .SQX       SET	.SQX + 1
    175  70bc					      REPEND
    176  70bd		       2c		      .byte.b	(.SQBASE+.SQX)
    177  70bd				   .SQX       SET	.SQX + 1
    175  70bd					      REPEND
    176  70be		       2d		      .byte.b	(.SQBASE+.SQX)
    177  70be				   .SQX       SET	.SQX + 1
    175  70be					      REPEND
    176  70bf		       2e		      .byte.b	(.SQBASE+.SQX)
    177  70bf				   .SQX       SET	.SQX + 1
    175  70bf					      REPEND
    176  70c0		       2f		      .byte.b	(.SQBASE+.SQX)
    177  70c0				   .SQX       SET	.SQX + 1
    175  70c0					      REPEND
    176  70c1		       30		      .byte.b	(.SQBASE+.SQX)
    177  70c1				   .SQX       SET	.SQX + 1
    178  70c2					      REPEND
    179  70c2				   .SQBASE    SET	.SQBASE - 10
    172  70c2					      REPEND
    173  70c2		       00 00		      .byte.b	0,0
    174  70c2				   .SQX       SET	2
    175  70c4					      REPEAT	8
    176  70c4		       1f		      .byte.b	(.SQBASE+.SQX)
    177  70c4				   .SQX       SET	.SQX + 1
    175  70c4					      REPEND
    176  70c5		       20		      .byte.b	(.SQBASE+.SQX)
    177  70c5				   .SQX       SET	.SQX + 1
    175  70c5					      REPEND
    176  70c6		       21		      .byte.b	(.SQBASE+.SQX)
    177  70c6				   .SQX       SET	.SQX + 1
    175  70c6					      REPEND
    176  70c7		       22		      .byte.b	(.SQBASE+.SQX)
    177  70c7				   .SQX       SET	.SQX + 1
    175  70c7					      REPEND
    176  70c8		       23		      .byte.b	(.SQBASE+.SQX)
    177  70c8				   .SQX       SET	.SQX + 1
    175  70c8					      REPEND
    176  70c9		       24		      .byte.b	(.SQBASE+.SQX)
    177  70c9				   .SQX       SET	.SQX + 1
    175  70c9					      REPEND
    176  70ca		       25		      .byte.b	(.SQBASE+.SQX)
    177  70ca				   .SQX       SET	.SQX + 1
    175  70ca					      REPEND
    176  70cb		       26		      .byte.b	(.SQBASE+.SQX)
    177  70cb				   .SQX       SET	.SQX + 1
    178  70cc					      REPEND
    179  70cc				   .SQBASE    SET	.SQBASE - 10
    172  70cc					      REPEND
    173  70cc		       00 00		      .byte.b	0,0
    174  70cc				   .SQX       SET	2
    175  70ce					      REPEAT	8
    176  70ce		       15		      .byte.b	(.SQBASE+.SQX)
    177  70ce				   .SQX       SET	.SQX + 1
    175  70ce					      REPEND
    176  70cf		       16		      .byte.b	(.SQBASE+.SQX)
    177  70cf				   .SQX       SET	.SQX + 1
    175  70cf					      REPEND
    176  70d0		       17		      .byte.b	(.SQBASE+.SQX)
    177  70d0				   .SQX       SET	.SQX + 1
    175  70d0					      REPEND
    176  70d1		       18		      .byte.b	(.SQBASE+.SQX)
    177  70d1				   .SQX       SET	.SQX + 1
    175  70d1					      REPEND
    176  70d2		       19		      .byte.b	(.SQBASE+.SQX)
    177  70d2				   .SQX       SET	.SQX + 1
    175  70d2					      REPEND
    176  70d3		       1a		      .byte.b	(.SQBASE+.SQX)
    177  70d3				   .SQX       SET	.SQX + 1
    175  70d3					      REPEND
    176  70d4		       1b		      .byte.b	(.SQBASE+.SQX)
    177  70d4				   .SQX       SET	.SQX + 1
    175  70d4					      REPEND
    176  70d5		       1c		      .byte.b	(.SQBASE+.SQX)
    177  70d5				   .SQX       SET	.SQX + 1
    178  70d6					      REPEND
    179  70d6				   .SQBASE    SET	.SQBASE - 10
    180  70d6					      REPEND
    181  70d6
    182  70d6
    183  70d6							;---------------------------------------------------------------------------------------------------
    184  70d6							; Vectors to the position value tables for each piece
    185  70d6
    186  70d6					      MAC	posval
    187  70d6					      .byte	0
    188  70d6					      .byte	{1}(PositionalValue_PAWN - 22)
    189  70d6					      .byte	{1}(PositionalValue_PAWN - 22)
    190  70d6					      .byte	{1}(PositionalValue_KNIGHT - 22)
    191  70d6					      .byte	{1}(PositionalValue_BISHOP - 22)
    192  70d6					      .byte	{1}(PositionalValue_ROOK - 22)
    193  70d6					      .byte	{1}(PositionalValue_QUEEN - 22)
    194  70d6					      .byte	{1}(PositionalValue_KING_MIDGAME - 22)
    195  70d6					      ENDM
    196  70d6
      0  70d6					      ALLOCATE	PosValVecLO, 8
      0  70d6					      OPTIONAL_PAGEBREAK	"Table", 8
     12  70d6					      LIST	ON
      0  70d6					      DEF	PosValVecLO
      1  70d6				   BANK_PosValVecLO SET	_CURRENT_BANK
      2  70d6				   PosValVecLO
      3  70d6				   TEMPORARY_VAR SET	Overlay
      4  70d6				   TEMPORARY_OFFSET SET	0
      5  70d6				   VAR_BOUNDARY_PosValVecLO SET	TEMPORARY_OFFSET
      6  70d6				   FUNCTION_NAME SET	PosValVecLO
      7  70d6					      SUBROUTINE
      0  70d6					      POSVAL	<
      1  70d6		       00		      .byte.b	0
      2  70d7		       d0		      .byte.b	<(PositionalValue_PAWN - 22)
      3  70d8		       d0		      .byte.b	<(PositionalValue_PAWN - 22)
      4  70d9		       70		      .byte.b	<(PositionalValue_KNIGHT - 22)
      5  70da		       c0		      .byte.b	<(PositionalValue_BISHOP - 22)
      6  70db		       10		      .byte.b	<(PositionalValue_ROOK - 22)
      7  70dc		       60		      .byte.b	<(PositionalValue_QUEEN - 22)
      8  70dd		       b0		      .byte.b	<(PositionalValue_KING_MIDGAME - 22)
      0  70de					      ALLOCATE	PosValVecHI, 8
      0  70de					      OPTIONAL_PAGEBREAK	"Table", 8
     12  70de					      LIST	ON
      0  70de					      DEF	PosValVecHI
      1  70de				   BANK_PosValVecHI SET	_CURRENT_BANK
      2  70de				   PosValVecHI
      3  70de				   TEMPORARY_VAR SET	Overlay
      4  70de				   TEMPORARY_OFFSET SET	0
      5  70de				   VAR_BOUNDARY_PosValVecHI SET	TEMPORARY_OFFSET
      6  70de				   FUNCTION_NAME SET	PosValVecHI
      7  70de					      SUBROUTINE
      0  70de					      POSVAL	>
      1  70de		       00		      .byte.b	0
      2  70df		       f0		      .byte.b	>(PositionalValue_PAWN - 22)
      3  70e0		       f0		      .byte.b	>(PositionalValue_PAWN - 22)
      4  70e1		       f1		      .byte.b	>(PositionalValue_KNIGHT - 22)
      5  70e2		       f1		      .byte.b	>(PositionalValue_BISHOP - 22)
      6  70e3		       f2		      .byte.b	>(PositionalValue_ROOK - 22)
      7  70e4		       f2		      .byte.b	>(PositionalValue_QUEEN - 22)
      8  70e5		       f2		      .byte.b	>(PositionalValue_KING_MIDGAME - 22)
    201  70e6
    202  70e6		       00 32	   BZ	      =	50
    203  70e6
    204  70e6					      MAC	pval
    205  70e6					      .byte	BZ + {1}
    206  70e6					      .byte	BZ + {2}
    207  70e6					      .byte	BZ + {3}
    208  70e6					      .byte	BZ + {4}
    209  70e6					      .byte	BZ + {5}
    210  70e6					      .byte	BZ + {6}
    211  70e6					      .byte	BZ + {7}
    212  70e6					      .byte	BZ + {8}
    213  70e6					      .byte	BZ
    214  70e6					      .byte	BZ
    215  70e6					      ENDM		;{ 10 entries }
    216  70e6
    217  70e6							;---------------------------------------------------------------------------------------------------
    218  70e6
    219  70e6				   PositionalValue_PAWN
    220  70e6
      0  70e6					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  70e6		       32		      .byte.b	BZ + 0
      2  70e7		       32		      .byte.b	BZ + 0
      3  70e8		       32		      .byte.b	BZ + 0
      4  70e9		       32		      .byte.b	BZ + 0
      5  70ea		       32		      .byte.b	BZ + 0
      6  70eb		       32		      .byte.b	BZ + 0
      7  70ec		       32		      .byte.b	BZ + 0
      8  70ed		       32		      .byte.b	BZ + 0
      9  70ee		       32		      .byte.b	BZ
     10  70ef		       32		      .byte.b	BZ
      0  70f0					      PVAL	15, 10, 0, -20, -20, 0, 10, 15
      1  70f0		       41		      .byte.b	BZ + 15
      2  70f1		       3c		      .byte.b	BZ + 10
      3  70f2		       32		      .byte.b	BZ + 0
      4  70f3		       1e		      .byte.b	BZ + -20
      5  70f4		       1e		      .byte.b	BZ + -20
      6  70f5		       32		      .byte.b	BZ + 0
      7  70f6		       3c		      .byte.b	BZ + 10
      8  70f7		       41		      .byte.b	BZ + 15
      9  70f8		       32		      .byte.b	BZ
     10  70f9		       32		      .byte.b	BZ
      0  70fa					      PVAL	5, -5, -10, 0, 0, -10, -5, 5
      1  70fa		       37		      .byte.b	BZ + 5
      2  70fb		       2d		      .byte.b	BZ + -5
      3  70fc		       28		      .byte.b	BZ + -10
      4  70fd		       32		      .byte.b	BZ + 0
      5  70fe		       32		      .byte.b	BZ + 0
      6  70ff		       28		      .byte.b	BZ + -10
      7  7100		       2d		      .byte.b	BZ + -5
      8  7101		       37		      .byte.b	BZ + 5
      9  7102		       32		      .byte.b	BZ
     10  7103		       32		      .byte.b	BZ
      0  7104					      PVAL	0, 0, 0, 10, 40, 0, 0, 0
      1  7104		       32		      .byte.b	BZ + 0
      2  7105		       32		      .byte.b	BZ + 0
      3  7106		       32		      .byte.b	BZ + 0
      4  7107		       3c		      .byte.b	BZ + 10
      5  7108		       5a		      .byte.b	BZ + 40
      6  7109		       32		      .byte.b	BZ + 0
      7  710a		       32		      .byte.b	BZ + 0
      8  710b		       32		      .byte.b	BZ + 0
      9  710c		       32		      .byte.b	BZ
     10  710d		       32		      .byte.b	BZ
      0  710e					      PVAL	15, 15, 20, 20, 50, 20, 15, 15
      1  710e		       41		      .byte.b	BZ + 15
      2  710f		       41		      .byte.b	BZ + 15
      3  7110		       46		      .byte.b	BZ + 20
      4  7111		       46		      .byte.b	BZ + 20
      5  7112		       64		      .byte.b	BZ + 50
      6  7113		       46		      .byte.b	BZ + 20
      7  7114		       41		      .byte.b	BZ + 15
      8  7115		       41		      .byte.b	BZ + 15
      9  7116		       32		      .byte.b	BZ
     10  7117		       32		      .byte.b	BZ
      0  7118					      PVAL	30, 30, 40, 50, 50, 40, 30, 30
      1  7118		       50		      .byte.b	BZ + 30
      2  7119		       50		      .byte.b	BZ + 30
      3  711a		       5a		      .byte.b	BZ + 40
      4  711b		       64		      .byte.b	BZ + 50
      5  711c		       64		      .byte.b	BZ + 50
      6  711d		       5a		      .byte.b	BZ + 40
      7  711e		       50		      .byte.b	BZ + 30
      8  711f		       50		      .byte.b	BZ + 30
      9  7120		       32		      .byte.b	BZ
     10  7121		       32		      .byte.b	BZ
      0  7122					      PVAL	40, 50, 60, 70, 70, 60, 50, 40
      1  7122		       5a		      .byte.b	BZ + 40
      2  7123		       64		      .byte.b	BZ + 50
      3  7124		       6e		      .byte.b	BZ + 60
      4  7125		       78		      .byte.b	BZ + 70
      5  7126		       78		      .byte.b	BZ + 70
      6  7127		       6e		      .byte.b	BZ + 60
      7  7128		       64		      .byte.b	BZ + 50
      8  7129		       5a		      .byte.b	BZ + 40
      9  712a		       32		      .byte.b	BZ
     10  712b		       32		      .byte.b	BZ
      0  712c					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  712c		       32		      .byte.b	BZ + 0
      2  712d		       32		      .byte.b	BZ + 0
      3  712e		       32		      .byte.b	BZ + 0
      4  712f		       32		      .byte.b	BZ + 0
      5  7130		       32		      .byte.b	BZ + 0
      6  7131		       32		      .byte.b	BZ + 0
      7  7132		       32		      .byte.b	BZ + 0
      8  7133		       32		      .byte.b	BZ + 0
      9  7134		       32		      .byte.b	BZ
     10  7135		       32		      .byte.b	BZ
    229  7136
    230  7136				   PositionalValue_PAWN_BLACK
    231  7136
      0  7136					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  7136		       32		      .byte.b	BZ + 0
      2  7137		       32		      .byte.b	BZ + 0
      3  7138		       32		      .byte.b	BZ + 0
      4  7139		       32		      .byte.b	BZ + 0
      5  713a		       32		      .byte.b	BZ + 0
      6  713b		       32		      .byte.b	BZ + 0
      7  713c		       32		      .byte.b	BZ + 0
      8  713d		       32		      .byte.b	BZ + 0
      9  713e		       32		      .byte.b	BZ
     10  713f		       32		      .byte.b	BZ
      0  7140					      PVAL	40, 50, 60, 70, 70, 60, 60, 40
      1  7140		       5a		      .byte.b	BZ + 40
      2  7141		       64		      .byte.b	BZ + 50
      3  7142		       6e		      .byte.b	BZ + 60
      4  7143		       78		      .byte.b	BZ + 70
      5  7144		       78		      .byte.b	BZ + 70
      6  7145		       6e		      .byte.b	BZ + 60
      7  7146		       6e		      .byte.b	BZ + 60
      8  7147		       5a		      .byte.b	BZ + 40
      9  7148		       32		      .byte.b	BZ
     10  7149		       32		      .byte.b	BZ
      0  714a					      PVAL	30, 30, 40, 50, 50, 40, 30, 30
      1  714a		       50		      .byte.b	BZ + 30
      2  714b		       50		      .byte.b	BZ + 30
      3  714c		       5a		      .byte.b	BZ + 40
      4  714d		       64		      .byte.b	BZ + 50
      5  714e		       64		      .byte.b	BZ + 50
      6  714f		       5a		      .byte.b	BZ + 40
      7  7150		       50		      .byte.b	BZ + 30
      8  7151		       50		      .byte.b	BZ + 30
      9  7152		       32		      .byte.b	BZ
     10  7153		       32		      .byte.b	BZ
      0  7154					      PVAL	15, 15, 10, 40, 40, 20, 15, 15
      1  7154		       41		      .byte.b	BZ + 15
      2  7155		       41		      .byte.b	BZ + 15
      3  7156		       3c		      .byte.b	BZ + 10
      4  7157		       5a		      .byte.b	BZ + 40
      5  7158		       5a		      .byte.b	BZ + 40
      6  7159		       46		      .byte.b	BZ + 20
      7  715a		       41		      .byte.b	BZ + 15
      8  715b		       41		      .byte.b	BZ + 15
      9  715c		       32		      .byte.b	BZ
     10  715d		       32		      .byte.b	BZ
      0  715e					      PVAL	0, 0, 0, 30, 30, 0, 0, 0
      1  715e		       32		      .byte.b	BZ + 0
      2  715f		       32		      .byte.b	BZ + 0
      3  7160		       32		      .byte.b	BZ + 0
      4  7161		       50		      .byte.b	BZ + 30
      5  7162		       50		      .byte.b	BZ + 30
      6  7163		       32		      .byte.b	BZ + 0
      7  7164		       32		      .byte.b	BZ + 0
      8  7165		       32		      .byte.b	BZ + 0
      9  7166		       32		      .byte.b	BZ
     10  7167		       32		      .byte.b	BZ
      0  7168					      PVAL	5, -5, -10, 0, 0, -10, -5, 5
      1  7168		       37		      .byte.b	BZ + 5
      2  7169		       2d		      .byte.b	BZ + -5
      3  716a		       28		      .byte.b	BZ + -10
      4  716b		       32		      .byte.b	BZ + 0
      5  716c		       32		      .byte.b	BZ + 0
      6  716d		       28		      .byte.b	BZ + -10
      7  716e		       2d		      .byte.b	BZ + -5
      8  716f		       37		      .byte.b	BZ + 5
      9  7170		       32		      .byte.b	BZ
     10  7171		       32		      .byte.b	BZ
      0  7172					      PVAL	15, 10, 0, -20, -20, 0, 10, 15
      1  7172		       41		      .byte.b	BZ + 15
      2  7173		       3c		      .byte.b	BZ + 10
      3  7174		       32		      .byte.b	BZ + 0
      4  7175		       1e		      .byte.b	BZ + -20
      5  7176		       1e		      .byte.b	BZ + -20
      6  7177		       32		      .byte.b	BZ + 0
      7  7178		       3c		      .byte.b	BZ + 10
      8  7179		       41		      .byte.b	BZ + 15
      9  717a		       32		      .byte.b	BZ
     10  717b		       32		      .byte.b	BZ
      0  717c					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  717c		       32		      .byte.b	BZ + 0
      2  717d		       32		      .byte.b	BZ + 0
      3  717e		       32		      .byte.b	BZ + 0
      4  717f		       32		      .byte.b	BZ + 0
      5  7180		       32		      .byte.b	BZ + 0
      6  7181		       32		      .byte.b	BZ + 0
      7  7182		       32		      .byte.b	BZ + 0
      8  7183		       32		      .byte.b	BZ + 0
      9  7184		       32		      .byte.b	BZ
     10  7185		       32		      .byte.b	BZ
    240  7186
    241  7186							;---------------------------------------------------------------------------------------------------
    242  7186
    243  7186				   PositionalValue_KNIGHT
    244  7186
      0  7186					      PVAL	-50, -40, -30, -30, -30, -30, -40, -50
      1  7186		       00		      .byte.b	BZ + -50
      2  7187		       0a		      .byte.b	BZ + -40
      3  7188		       14		      .byte.b	BZ + -30
      4  7189		       14		      .byte.b	BZ + -30
      5  718a		       14		      .byte.b	BZ + -30
      6  718b		       14		      .byte.b	BZ + -30
      7  718c		       0a		      .byte.b	BZ + -40
      8  718d		       00		      .byte.b	BZ + -50
      9  718e		       32		      .byte.b	BZ
     10  718f		       32		      .byte.b	BZ
      0  7190					      PVAL	-40, -20, 0, 5, 5, 0, -20, -40
      1  7190		       0a		      .byte.b	BZ + -40
      2  7191		       1e		      .byte.b	BZ + -20
      3  7192		       32		      .byte.b	BZ + 0
      4  7193		       37		      .byte.b	BZ + 5
      5  7194		       37		      .byte.b	BZ + 5
      6  7195		       32		      .byte.b	BZ + 0
      7  7196		       1e		      .byte.b	BZ + -20
      8  7197		       0a		      .byte.b	BZ + -40
      9  7198		       32		      .byte.b	BZ
     10  7199		       32		      .byte.b	BZ
      0  719a					      PVAL	-30, 0, 20, 15, 15, 20, 0, -30
      1  719a		       14		      .byte.b	BZ + -30
      2  719b		       32		      .byte.b	BZ + 0
      3  719c		       46		      .byte.b	BZ + 20
      4  719d		       41		      .byte.b	BZ + 15
      5  719e		       41		      .byte.b	BZ + 15
      6  719f		       46		      .byte.b	BZ + 20
      7  71a0		       32		      .byte.b	BZ + 0
      8  71a1		       14		      .byte.b	BZ + -30
      9  71a2		       32		      .byte.b	BZ
     10  71a3		       32		      .byte.b	BZ
      0  71a4					      PVAL	-30, 0, 15, 30, 30, 15, 0, -30
      1  71a4		       14		      .byte.b	BZ + -30
      2  71a5		       32		      .byte.b	BZ + 0
      3  71a6		       41		      .byte.b	BZ + 15
      4  71a7		       50		      .byte.b	BZ + 30
      5  71a8		       50		      .byte.b	BZ + 30
      6  71a9		       41		      .byte.b	BZ + 15
      7  71aa		       32		      .byte.b	BZ + 0
      8  71ab		       14		      .byte.b	BZ + -30
      9  71ac		       32		      .byte.b	BZ
     10  71ad		       32		      .byte.b	BZ
      0  71ae					      PVAL	-30, 5, 15, 30, 30, 15, 5, -30
      1  71ae		       14		      .byte.b	BZ + -30
      2  71af		       37		      .byte.b	BZ + 5
      3  71b0		       41		      .byte.b	BZ + 15
      4  71b1		       50		      .byte.b	BZ + 30
      5  71b2		       50		      .byte.b	BZ + 30
      6  71b3		       41		      .byte.b	BZ + 15
      7  71b4		       37		      .byte.b	BZ + 5
      8  71b5		       14		      .byte.b	BZ + -30
      9  71b6		       32		      .byte.b	BZ
     10  71b7		       32		      .byte.b	BZ
      0  71b8					      PVAL	-30, 0, 10, 15, 15, 10, 0, -30
      1  71b8		       14		      .byte.b	BZ + -30
      2  71b9		       32		      .byte.b	BZ + 0
      3  71ba		       3c		      .byte.b	BZ + 10
      4  71bb		       41		      .byte.b	BZ + 15
      5  71bc		       41		      .byte.b	BZ + 15
      6  71bd		       3c		      .byte.b	BZ + 10
      7  71be		       32		      .byte.b	BZ + 0
      8  71bf		       14		      .byte.b	BZ + -30
      9  71c0		       32		      .byte.b	BZ
     10  71c1		       32		      .byte.b	BZ
      0  71c2					      PVAL	-40, -20, 30, 0, 0, 30, -20, -40
      1  71c2		       0a		      .byte.b	BZ + -40
      2  71c3		       1e		      .byte.b	BZ + -20
      3  71c4		       50		      .byte.b	BZ + 30
      4  71c5		       32		      .byte.b	BZ + 0
      5  71c6		       32		      .byte.b	BZ + 0
      6  71c7		       50		      .byte.b	BZ + 30
      7  71c8		       1e		      .byte.b	BZ + -20
      8  71c9		       0a		      .byte.b	BZ + -40
      9  71ca		       32		      .byte.b	BZ
     10  71cb		       32		      .byte.b	BZ
      0  71cc					      PVAL	-50, -20, -30, -30, -30, -30, -20, -50
      1  71cc		       00		      .byte.b	BZ + -50
      2  71cd		       1e		      .byte.b	BZ + -20
      3  71ce		       14		      .byte.b	BZ + -30
      4  71cf		       14		      .byte.b	BZ + -30
      5  71d0		       14		      .byte.b	BZ + -30
      6  71d1		       14		      .byte.b	BZ + -30
      7  71d2		       1e		      .byte.b	BZ + -20
      8  71d3		       00		      .byte.b	BZ + -50
      9  71d4		       32		      .byte.b	BZ
     10  71d5		       32		      .byte.b	BZ
    253  71d6
    254  71d6
    255  71d6							;---------------------------------------------------------------------------------------------------
    256  71d6
    257  71d6				   PositionalValue_BISHOP
    258  71d6
      0  71d6					      PVAL	-20, -10, -50, -10, -10, -50, -10, -20
      1  71d6		       1e		      .byte.b	BZ + -20
      2  71d7		       28		      .byte.b	BZ + -10
      3  71d8		       00		      .byte.b	BZ + -50
      4  71d9		       28		      .byte.b	BZ + -10
      5  71da		       28		      .byte.b	BZ + -10
      6  71db		       00		      .byte.b	BZ + -50
      7  71dc		       28		      .byte.b	BZ + -10
      8  71dd		       1e		      .byte.b	BZ + -20
      9  71de		       32		      .byte.b	BZ
     10  71df		       32		      .byte.b	BZ
      0  71e0					      PVAL	-10, 5, 0, 0, 0, 0, 5, -10
      1  71e0		       28		      .byte.b	BZ + -10
      2  71e1		       37		      .byte.b	BZ + 5
      3  71e2		       32		      .byte.b	BZ + 0
      4  71e3		       32		      .byte.b	BZ + 0
      5  71e4		       32		      .byte.b	BZ + 0
      6  71e5		       32		      .byte.b	BZ + 0
      7  71e6		       37		      .byte.b	BZ + 5
      8  71e7		       28		      .byte.b	BZ + -10
      9  71e8		       32		      .byte.b	BZ
     10  71e9		       32		      .byte.b	BZ
      0  71ea					      PVAL	-10, 10, 10, 10, 10, 10, 10, -10
      1  71ea		       28		      .byte.b	BZ + -10
      2  71eb		       3c		      .byte.b	BZ + 10
      3  71ec		       3c		      .byte.b	BZ + 10
      4  71ed		       3c		      .byte.b	BZ + 10
      5  71ee		       3c		      .byte.b	BZ + 10
      6  71ef		       3c		      .byte.b	BZ + 10
      7  71f0		       3c		      .byte.b	BZ + 10
      8  71f1		       28		      .byte.b	BZ + -10
      9  71f2		       32		      .byte.b	BZ
     10  71f3		       32		      .byte.b	BZ
      0  71f4					      PVAL	-10, 0, 10, 20, 20, 10, 0, -10
      1  71f4		       28		      .byte.b	BZ + -10
      2  71f5		       32		      .byte.b	BZ + 0
      3  71f6		       3c		      .byte.b	BZ + 10
      4  71f7		       46		      .byte.b	BZ + 20
      5  71f8		       46		      .byte.b	BZ + 20
      6  71f9		       3c		      .byte.b	BZ + 10
      7  71fa		       32		      .byte.b	BZ + 0
      8  71fb		       28		      .byte.b	BZ + -10
      9  71fc		       32		      .byte.b	BZ
     10  71fd		       32		      .byte.b	BZ
      0  71fe					      PVAL	-10, 5, 5, 20, 20, 5, 5, -10
      1  71fe		       28		      .byte.b	BZ + -10
      2  71ff		       37		      .byte.b	BZ + 5
      3  7200		       37		      .byte.b	BZ + 5
      4  7201		       46		      .byte.b	BZ + 20
      5  7202		       46		      .byte.b	BZ + 20
      6  7203		       37		      .byte.b	BZ + 5
      7  7204		       37		      .byte.b	BZ + 5
      8  7205		       28		      .byte.b	BZ + -10
      9  7206		       32		      .byte.b	BZ
     10  7207		       32		      .byte.b	BZ
      0  7208					      PVAL	-10, 0, 5, 10, 10, 5, 0, -10
      1  7208		       28		      .byte.b	BZ + -10
      2  7209		       32		      .byte.b	BZ + 0
      3  720a		       37		      .byte.b	BZ + 5
      4  720b		       3c		      .byte.b	BZ + 10
      5  720c		       3c		      .byte.b	BZ + 10
      6  720d		       37		      .byte.b	BZ + 5
      7  720e		       32		      .byte.b	BZ + 0
      8  720f		       28		      .byte.b	BZ + -10
      9  7210		       32		      .byte.b	BZ
     10  7211		       32		      .byte.b	BZ
      0  7212					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  7212		       28		      .byte.b	BZ + -10
      2  7213		       32		      .byte.b	BZ + 0
      3  7214		       32		      .byte.b	BZ + 0
      4  7215		       32		      .byte.b	BZ + 0
      5  7216		       32		      .byte.b	BZ + 0
      6  7217		       32		      .byte.b	BZ + 0
      7  7218		       32		      .byte.b	BZ + 0
      8  7219		       28		      .byte.b	BZ + -10
      9  721a		       32		      .byte.b	BZ
     10  721b		       32		      .byte.b	BZ
      0  721c					      PVAL	-20, -10, -10, -10, -10, -10, -10, -20
      1  721c		       1e		      .byte.b	BZ + -20
      2  721d		       28		      .byte.b	BZ + -10
      3  721e		       28		      .byte.b	BZ + -10
      4  721f		       28		      .byte.b	BZ + -10
      5  7220		       28		      .byte.b	BZ + -10
      6  7221		       28		      .byte.b	BZ + -10
      7  7222		       28		      .byte.b	BZ + -10
      8  7223		       1e		      .byte.b	BZ + -20
      9  7224		       32		      .byte.b	BZ
     10  7225		       32		      .byte.b	BZ
    267  7226
    268  7226
    269  7226							;---------------------------------------------------------------------------------------------------
    270  7226
    271  7226				   PositionalValue_ROOK
    272  7226
      0  7226					      PVAL	-120, -10, 10, 25, 25, 10, -10, -200
      1  7226		       ba		      .byte.b	BZ + -120
      2  7227		       28		      .byte.b	BZ + -10
      3  7228		       3c		      .byte.b	BZ + 10
      4  7229		       4b		      .byte.b	BZ + 25
      5  722a		       4b		      .byte.b	BZ + 25
      6  722b		       3c		      .byte.b	BZ + 10
      7  722c		       28		      .byte.b	BZ + -10
      8  722d		       6a		      .byte.b	BZ + -200
      9  722e		       32		      .byte.b	BZ
     10  722f		       32		      .byte.b	BZ
      0  7230					      PVAL	-75, 0, 0, 0, 0, 0, 0, -200
      1  7230		       e7		      .byte.b	BZ + -75
      2  7231		       32		      .byte.b	BZ + 0
      3  7232		       32		      .byte.b	BZ + 0
      4  7233		       32		      .byte.b	BZ + 0
      5  7234		       32		      .byte.b	BZ + 0
      6  7235		       32		      .byte.b	BZ + 0
      7  7236		       32		      .byte.b	BZ + 0
      8  7237		       6a		      .byte.b	BZ + -200
      9  7238		       32		      .byte.b	BZ
     10  7239		       32		      .byte.b	BZ
      0  723a					      PVAL	-75, 0, 0, 0, 0, 0, 0, -150
      1  723a		       e7		      .byte.b	BZ + -75
      2  723b		       32		      .byte.b	BZ + 0
      3  723c		       32		      .byte.b	BZ + 0
      4  723d		       32		      .byte.b	BZ + 0
      5  723e		       32		      .byte.b	BZ + 0
      6  723f		       32		      .byte.b	BZ + 0
      7  7240		       32		      .byte.b	BZ + 0
      8  7241		       9c		      .byte.b	BZ + -150
      9  7242		       32		      .byte.b	BZ
     10  7243		       32		      .byte.b	BZ
      0  7244					      PVAL	-50, 0, 0, 0, 0, 0, 0, -100
      1  7244		       00		      .byte.b	BZ + -50
      2  7245		       32		      .byte.b	BZ + 0
      3  7246		       32		      .byte.b	BZ + 0
      4  7247		       32		      .byte.b	BZ + 0
      5  7248		       32		      .byte.b	BZ + 0
      6  7249		       32		      .byte.b	BZ + 0
      7  724a		       32		      .byte.b	BZ + 0
      8  724b		       ce		      .byte.b	BZ + -100
      9  724c		       32		      .byte.b	BZ
     10  724d		       32		      .byte.b	BZ
      0  724e					      PVAL	-5, 0, 0, 0, 0, 0, 0, -50
      1  724e		       2d		      .byte.b	BZ + -5
      2  724f		       32		      .byte.b	BZ + 0
      3  7250		       32		      .byte.b	BZ + 0
      4  7251		       32		      .byte.b	BZ + 0
      5  7252		       32		      .byte.b	BZ + 0
      6  7253		       32		      .byte.b	BZ + 0
      7  7254		       32		      .byte.b	BZ + 0
      8  7255		       00		      .byte.b	BZ + -50
      9  7256		       32		      .byte.b	BZ
     10  7257		       32		      .byte.b	BZ
      0  7258					      PVAL	-5, 0, 30, 30, 30, 30, 0, -5
      1  7258		       2d		      .byte.b	BZ + -5
      2  7259		       32		      .byte.b	BZ + 0
      3  725a		       50		      .byte.b	BZ + 30
      4  725b		       50		      .byte.b	BZ + 30
      5  725c		       50		      .byte.b	BZ + 30
      6  725d		       50		      .byte.b	BZ + 30
      7  725e		       32		      .byte.b	BZ + 0
      8  725f		       2d		      .byte.b	BZ + -5
      9  7260		       32		      .byte.b	BZ
     10  7261		       32		      .byte.b	BZ
      0  7262					      PVAL	5, 10, 50, 50, 50, 50, 10, 5
      1  7262		       37		      .byte.b	BZ + 5
      2  7263		       3c		      .byte.b	BZ + 10
      3  7264		       64		      .byte.b	BZ + 50
      4  7265		       64		      .byte.b	BZ + 50
      5  7266		       64		      .byte.b	BZ + 50
      6  7267		       64		      .byte.b	BZ + 50
      7  7268		       3c		      .byte.b	BZ + 10
      8  7269		       37		      .byte.b	BZ + 5
      9  726a		       32		      .byte.b	BZ
     10  726b		       32		      .byte.b	BZ
      0  726c					      PVAL	0, 0, 0, 0, 0, 0, 0, 0
      1  726c		       32		      .byte.b	BZ + 0
      2  726d		       32		      .byte.b	BZ + 0
      3  726e		       32		      .byte.b	BZ + 0
      4  726f		       32		      .byte.b	BZ + 0
      5  7270		       32		      .byte.b	BZ + 0
      6  7271		       32		      .byte.b	BZ + 0
      7  7272		       32		      .byte.b	BZ + 0
      8  7273		       32		      .byte.b	BZ + 0
      9  7274		       32		      .byte.b	BZ
     10  7275		       32		      .byte.b	BZ
    281  7276
    282  7276
    283  7276							;---------------------------------------------------------------------------------------------------
    284  7276
    285  7276				   PositionalValue_QUEEN
    286  7276
      0  7276					      PVAL	-20, -10, -5, -5, -5, -10, -10, -20
      1  7276		       1e		      .byte.b	BZ + -20
      2  7277		       28		      .byte.b	BZ + -10
      3  7278		       2d		      .byte.b	BZ + -5
      4  7279		       2d		      .byte.b	BZ + -5
      5  727a		       2d		      .byte.b	BZ + -5
      6  727b		       28		      .byte.b	BZ + -10
      7  727c		       28		      .byte.b	BZ + -10
      8  727d		       1e		      .byte.b	BZ + -20
      9  727e		       32		      .byte.b	BZ
     10  727f		       32		      .byte.b	BZ
      0  7280					      PVAL	-10, 0, 5, 0, 0, 0, 0, -10
      1  7280		       28		      .byte.b	BZ + -10
      2  7281		       32		      .byte.b	BZ + 0
      3  7282		       37		      .byte.b	BZ + 5
      4  7283		       32		      .byte.b	BZ + 0
      5  7284		       32		      .byte.b	BZ + 0
      6  7285		       32		      .byte.b	BZ + 0
      7  7286		       32		      .byte.b	BZ + 0
      8  7287		       28		      .byte.b	BZ + -10
      9  7288		       32		      .byte.b	BZ
     10  7289		       32		      .byte.b	BZ
      0  728a					      PVAL	-10, 5, 5, 5, 5, 25, 0, -10
      1  728a		       28		      .byte.b	BZ + -10
      2  728b		       37		      .byte.b	BZ + 5
      3  728c		       37		      .byte.b	BZ + 5
      4  728d		       37		      .byte.b	BZ + 5
      5  728e		       37		      .byte.b	BZ + 5
      6  728f		       4b		      .byte.b	BZ + 25
      7  7290		       32		      .byte.b	BZ + 0
      8  7291		       28		      .byte.b	BZ + -10
      9  7292		       32		      .byte.b	BZ
     10  7293		       32		      .byte.b	BZ
      0  7294					      PVAL	-10, 0, 5, 25, 25, 25, 0, -10
      1  7294		       28		      .byte.b	BZ + -10
      2  7295		       32		      .byte.b	BZ + 0
      3  7296		       37		      .byte.b	BZ + 5
      4  7297		       4b		      .byte.b	BZ + 25
      5  7298		       4b		      .byte.b	BZ + 25
      6  7299		       4b		      .byte.b	BZ + 25
      7  729a		       32		      .byte.b	BZ + 0
      8  729b		       28		      .byte.b	BZ + -10
      9  729c		       32		      .byte.b	BZ
     10  729d		       32		      .byte.b	BZ
      0  729e					      PVAL	-5, 0, 15, 55, 55, 55, 0, -5
      1  729e		       2d		      .byte.b	BZ + -5
      2  729f		       32		      .byte.b	BZ + 0
      3  72a0		       41		      .byte.b	BZ + 15
      4  72a1		       69		      .byte.b	BZ + 55
      5  72a2		       69		      .byte.b	BZ + 55
      6  72a3		       69		      .byte.b	BZ + 55
      7  72a4		       32		      .byte.b	BZ + 0
      8  72a5		       2d		      .byte.b	BZ + -5
      9  72a6		       32		      .byte.b	BZ
     10  72a7		       32		      .byte.b	BZ
      0  72a8					      PVAL	-10, 0, 25, 75, 75, 75, 0, -10
      1  72a8		       28		      .byte.b	BZ + -10
      2  72a9		       32		      .byte.b	BZ + 0
      3  72aa		       4b		      .byte.b	BZ + 25
      4  72ab		       7d		      .byte.b	BZ + 75
      5  72ac		       7d		      .byte.b	BZ + 75
      6  72ad		       7d		      .byte.b	BZ + 75
      7  72ae		       32		      .byte.b	BZ + 0
      8  72af		       28		      .byte.b	BZ + -10
      9  72b0		       32		      .byte.b	BZ
     10  72b1		       32		      .byte.b	BZ
      0  72b2					      PVAL	-10, 0, 0, 0, 0, 0, 0, -10
      1  72b2		       28		      .byte.b	BZ + -10
      2  72b3		       32		      .byte.b	BZ + 0
      3  72b4		       32		      .byte.b	BZ + 0
      4  72b5		       32		      .byte.b	BZ + 0
      5  72b6		       32		      .byte.b	BZ + 0
      6  72b7		       32		      .byte.b	BZ + 0
      7  72b8		       32		      .byte.b	BZ + 0
      8  72b9		       28		      .byte.b	BZ + -10
      9  72ba		       32		      .byte.b	BZ
     10  72bb		       32		      .byte.b	BZ
      0  72bc					      PVAL	-20, -10, -10, -5, -5, -10, -10, -20
      1  72bc		       1e		      .byte.b	BZ + -20
      2  72bd		       28		      .byte.b	BZ + -10
      3  72be		       28		      .byte.b	BZ + -10
      4  72bf		       2d		      .byte.b	BZ + -5
      5  72c0		       2d		      .byte.b	BZ + -5
      6  72c1		       28		      .byte.b	BZ + -10
      7  72c2		       28		      .byte.b	BZ + -10
      8  72c3		       1e		      .byte.b	BZ + -20
      9  72c4		       32		      .byte.b	BZ
     10  72c5		       32		      .byte.b	BZ
    295  72c6
    296  72c6
    297  72c6							;---------------------------------------------------------------------------------------------------
    298  72c6
    299  72c6				   PositionalValue_KING_MIDGAME
    300  72c6
      0  72c6					      PVAL	0, 0, 30, -20, 0, 10, 40, 10
      1  72c6		       32		      .byte.b	BZ + 0
      2  72c7		       32		      .byte.b	BZ + 0
      3  72c8		       50		      .byte.b	BZ + 30
      4  72c9		       1e		      .byte.b	BZ + -20
      5  72ca		       32		      .byte.b	BZ + 0
      6  72cb		       3c		      .byte.b	BZ + 10
      7  72cc		       5a		      .byte.b	BZ + 40
      8  72cd		       3c		      .byte.b	BZ + 10
      9  72ce		       32		      .byte.b	BZ
     10  72cf		       32		      .byte.b	BZ
      0  72d0					      PVAL	20, 20, 0, -10, -10, 0, 20, 20
      1  72d0		       46		      .byte.b	BZ + 20
      2  72d1		       46		      .byte.b	BZ + 20
      3  72d2		       32		      .byte.b	BZ + 0
      4  72d3		       28		      .byte.b	BZ + -10
      5  72d4		       28		      .byte.b	BZ + -10
      6  72d5		       32		      .byte.b	BZ + 0
      7  72d6		       46		      .byte.b	BZ + 20
      8  72d7		       46		      .byte.b	BZ + 20
      9  72d8		       32		      .byte.b	BZ
     10  72d9		       32		      .byte.b	BZ
      0  72da					      PVAL	-10, -20, -20, -20, -20, -20, -20, -10
      1  72da		       28		      .byte.b	BZ + -10
      2  72db		       1e		      .byte.b	BZ + -20
      3  72dc		       1e		      .byte.b	BZ + -20
      4  72dd		       1e		      .byte.b	BZ + -20
      5  72de		       1e		      .byte.b	BZ + -20
      6  72df		       1e		      .byte.b	BZ + -20
      7  72e0		       1e		      .byte.b	BZ + -20
      8  72e1		       28		      .byte.b	BZ + -10
      9  72e2		       32		      .byte.b	BZ
     10  72e3		       32		      .byte.b	BZ
      0  72e4					      PVAL	-20, -30, -30, -40, -40, -30, -30, -20
      1  72e4		       1e		      .byte.b	BZ + -20
      2  72e5		       14		      .byte.b	BZ + -30
      3  72e6		       14		      .byte.b	BZ + -30
      4  72e7		       0a		      .byte.b	BZ + -40
      5  72e8		       0a		      .byte.b	BZ + -40
      6  72e9		       14		      .byte.b	BZ + -30
      7  72ea		       14		      .byte.b	BZ + -30
      8  72eb		       1e		      .byte.b	BZ + -20
      9  72ec		       32		      .byte.b	BZ
     10  72ed		       32		      .byte.b	BZ
      0  72ee					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  72ee		       14		      .byte.b	BZ + -30
      2  72ef		       0a		      .byte.b	BZ + -40
      3  72f0		       0a		      .byte.b	BZ + -40
      4  72f1		       00		      .byte.b	BZ + -50
      5  72f2		       00		      .byte.b	BZ + -50
      6  72f3		       0a		      .byte.b	BZ + -40
      7  72f4		       0a		      .byte.b	BZ + -40
      8  72f5		       14		      .byte.b	BZ + -30
      9  72f6		       32		      .byte.b	BZ
     10  72f7		       32		      .byte.b	BZ
      0  72f8					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  72f8		       14		      .byte.b	BZ + -30
      2  72f9		       0a		      .byte.b	BZ + -40
      3  72fa		       0a		      .byte.b	BZ + -40
      4  72fb		       00		      .byte.b	BZ + -50
      5  72fc		       00		      .byte.b	BZ + -50
      6  72fd		       0a		      .byte.b	BZ + -40
      7  72fe		       0a		      .byte.b	BZ + -40
      8  72ff		       14		      .byte.b	BZ + -30
      9  7300		       32		      .byte.b	BZ
     10  7301		       32		      .byte.b	BZ
      0  7302					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  7302		       14		      .byte.b	BZ + -30
      2  7303		       0a		      .byte.b	BZ + -40
      3  7304		       0a		      .byte.b	BZ + -40
      4  7305		       00		      .byte.b	BZ + -50
      5  7306		       00		      .byte.b	BZ + -50
      6  7307		       0a		      .byte.b	BZ + -40
      7  7308		       0a		      .byte.b	BZ + -40
      8  7309		       14		      .byte.b	BZ + -30
      9  730a		       32		      .byte.b	BZ
     10  730b		       32		      .byte.b	BZ
      0  730c					      PVAL	-30, -40, -40, -50, -50, -40, -40, -30
      1  730c		       14		      .byte.b	BZ + -30
      2  730d		       0a		      .byte.b	BZ + -40
      3  730e		       0a		      .byte.b	BZ + -40
      4  730f		       00		      .byte.b	BZ + -50
      5  7310		       00		      .byte.b	BZ + -50
      6  7311		       0a		      .byte.b	BZ + -40
      7  7312		       0a		      .byte.b	BZ + -40
      8  7313		       14		      .byte.b	BZ + -30
      9  7314		       32		      .byte.b	BZ
     10  7315		       32		      .byte.b	BZ
    309  7316
    310  7316
    311  7316							;---------------------------------------------------------------------------------------------------
    312  7316
    313  7316				   PositionalValue_KING_ENDGAME
    314  7316
      0  7316					      PVAL	-50, -30, -30, -30, -30, -30, -30, -50
      1  7316		       00		      .byte.b	BZ + -50
      2  7317		       14		      .byte.b	BZ + -30
      3  7318		       14		      .byte.b	BZ + -30
      4  7319		       14		      .byte.b	BZ + -30
      5  731a		       14		      .byte.b	BZ + -30
      6  731b		       14		      .byte.b	BZ + -30
      7  731c		       14		      .byte.b	BZ + -30
      8  731d		       00		      .byte.b	BZ + -50
      9  731e		       32		      .byte.b	BZ
     10  731f		       32		      .byte.b	BZ
      0  7320					      PVAL	-30, -30, 0, 0, 0, 0, -30, -30
      1  7320		       14		      .byte.b	BZ + -30
      2  7321		       14		      .byte.b	BZ + -30
      3  7322		       32		      .byte.b	BZ + 0
      4  7323		       32		      .byte.b	BZ + 0
      5  7324		       32		      .byte.b	BZ + 0
      6  7325		       32		      .byte.b	BZ + 0
      7  7326		       14		      .byte.b	BZ + -30
      8  7327		       14		      .byte.b	BZ + -30
      9  7328		       32		      .byte.b	BZ
     10  7329		       32		      .byte.b	BZ
      0  732a					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  732a		       14		      .byte.b	BZ + -30
      2  732b		       28		      .byte.b	BZ + -10
      3  732c		       46		      .byte.b	BZ + 20
      4  732d		       50		      .byte.b	BZ + 30
      5  732e		       50		      .byte.b	BZ + 30
      6  732f		       46		      .byte.b	BZ + 20
      7  7330		       28		      .byte.b	BZ + -10
      8  7331		       14		      .byte.b	BZ + -30
      9  7332		       32		      .byte.b	BZ
     10  7333		       32		      .byte.b	BZ
      0  7334					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  7334		       14		      .byte.b	BZ + -30
      2  7335		       28		      .byte.b	BZ + -10
      3  7336		       50		      .byte.b	BZ + 30
      4  7337		       5a		      .byte.b	BZ + 40
      5  7338		       5a		      .byte.b	BZ + 40
      6  7339		       50		      .byte.b	BZ + 30
      7  733a		       28		      .byte.b	BZ + -10
      8  733b		       14		      .byte.b	BZ + -30
      9  733c		       32		      .byte.b	BZ
     10  733d		       32		      .byte.b	BZ
      0  733e					      PVAL	-30, -10, 30, 40, 40, 30, -10, -30
      1  733e		       14		      .byte.b	BZ + -30
      2  733f		       28		      .byte.b	BZ + -10
      3  7340		       50		      .byte.b	BZ + 30
      4  7341		       5a		      .byte.b	BZ + 40
      5  7342		       5a		      .byte.b	BZ + 40
      6  7343		       50		      .byte.b	BZ + 30
      7  7344		       28		      .byte.b	BZ + -10
      8  7345		       14		      .byte.b	BZ + -30
      9  7346		       32		      .byte.b	BZ
     10  7347		       32		      .byte.b	BZ
      0  7348					      PVAL	-30, -10, 20, 30, 30, 20, -10, -30
      1  7348		       14		      .byte.b	BZ + -30
      2  7349		       28		      .byte.b	BZ + -10
      3  734a		       46		      .byte.b	BZ + 20
      4  734b		       50		      .byte.b	BZ + 30
      5  734c		       50		      .byte.b	BZ + 30
      6  734d		       46		      .byte.b	BZ + 20
      7  734e		       28		      .byte.b	BZ + -10
      8  734f		       14		      .byte.b	BZ + -30
      9  7350		       32		      .byte.b	BZ
     10  7351		       32		      .byte.b	BZ
      0  7352					      PVAL	-30, -20, -10, 0, 0, -10, -20, -30
      1  7352		       14		      .byte.b	BZ + -30
      2  7353		       1e		      .byte.b	BZ + -20
      3  7354		       28		      .byte.b	BZ + -10
      4  7355		       32		      .byte.b	BZ + 0
      5  7356		       32		      .byte.b	BZ + 0
      6  7357		       28		      .byte.b	BZ + -10
      7  7358		       1e		      .byte.b	BZ + -20
      8  7359		       14		      .byte.b	BZ + -30
      9  735a		       32		      .byte.b	BZ
     10  735b		       32		      .byte.b	BZ
      0  735c					      PVAL	-50, -40, -30, -20,- 20, -30, -40, -50
      1  735c		       00		      .byte.b	BZ + -50
      2  735d		       0a		      .byte.b	BZ + -40
      3  735e		       14		      .byte.b	BZ + -30
      4  735f		       1e		      .byte.b	BZ + -20
      5  7360		       1e		      .byte.b	BZ + - 20
      6  7361		       14		      .byte.b	BZ + -30
      7  7362		       0a		      .byte.b	BZ + -40
      8  7363		       00		      .byte.b	BZ + -50
      9  7364		       32		      .byte.b	BZ
     10  7365		       32		      .byte.b	BZ
    323  7366
    324  7366
      0  7366					      CHECK_BANK_SIZE	"BANK_EVAL"
      1  7366		       03 66	   .TEMP      =	* - BANK_START
 BANK_EVAL (2K) SIZE =  $366 , FREE= $49a
      2  7366					      ECHO	"BANK_EVAL", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  7366				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  7366				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  7366				  -	      ERR
      6  7366					      ENDIF
      7  7366
    326  7366
    327  7366							;---------------------------------------------------------------------------------------------------
    328  7366							; EOF
------- FILE ./chess.asm
------- FILE BANK_SPEAK.asm LEVEL 2 PASS 5
      0  7366					      include	"BANK_SPEAK.asm"
      0  7366					      NEWBANK	SPEAK
      1  7876 ????				      SEG	SPEAK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   SPEAK      SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	SPEAK
      2  7800
      3  7800							;
      4  7800							; speakjet.inc
      5  7800							;
      6  7800							;
      7  7800							; AtariVox Speech Synth Driver
      8  7800							;
      9  7800							; By Alex Herbert, 2004
     10  7800							;
     11  7800
     12  7800
     13  7800
     14  7800
     15  7800							; Constants
     16  7800
     17  7800
     18  7800		       00 01	   SERIAL_OUTMASK equ	$01
     19  7800		       00 02	   SERIAL_RDYMASK equ	$02
     20  7800
     21  7800
     22  7800
     23  7800							;---------------------------------------------------------------------------------------------------
     24  7800
     25  7800					      mac	speak
     26  7800
     27  7800					      lda	#<{1}
     28  7800					      sta	speech_addr
     29  7800					      lda	#>{1}
     30  7800					      sta	speech_addr+1
     31  7800
     32  7800					      endm
     33  7800
     34  7800
     35  7800							;---------------------------------------------------------------------------------------------------
     36  7800
      0  7800					      DEF	ShutYourMouth
      1  7800				   BANK_ShutYourMouth SET	_CURRENT_BANK
      2  7800				   ShutYourMouth
      3  7800				   TEMPORARY_VAR SET	Overlay
      4  7800				   TEMPORARY_OFFSET SET	0
      5  7800				   VAR_BOUNDARY_ShutYourMouth SET	TEMPORARY_OFFSET
      6  7800				   FUNCTION_NAME SET	ShutYourMouth
      7  7800					      SUBROUTINE
     38  7800					      SUBROUTINE
     39  7800
      0  7800					      REFER	Reset
      1  7800				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  7800				  -TEMPORARY_VAR SET	VAREND_Reset
      3  7800					      ENDIF
      0  7800					      VEND	ShutYourMouth
      1  7800				  -	      IFNCONST	ShutYourMouth
      2  7800				  -	      ECHO	"Incorrect VEND label", ShutYourMouth
      3  7800				  -	      ERR
      4  7800					      ENDIF
      5  7800		       00 a2	   VAREND_ShutYourMouth =	TEMPORARY_VAR
     42  7800
      0  7800					      SPEAK	silence_speech
      1  7800
      2  7800		       a9 74		      lda	#<silence_speech
      3  7802		       85 9b		      sta	speech_addr
      4  7804		       a9 f0		      lda	#>silence_speech
      5  7806		       85 9c		      sta	speech_addr+1
      6  7808
     44  7808		       60		      rts
     45  7809
     46  7809
     47  7809							;---------------------------------------------------------------------------------------------------
     48  7809
      0  7809					      DEF	GameSpeak
      1  7809				   BANK_GameSpeak SET	_CURRENT_BANK
      2  7809				   GameSpeak
      3  7809				   TEMPORARY_VAR SET	Overlay
      4  7809				   TEMPORARY_OFFSET SET	0
      5  7809				   VAR_BOUNDARY_GameSpeak SET	TEMPORARY_OFFSET
      6  7809				   FUNCTION_NAME SET	GameSpeak
      7  7809					      SUBROUTINE
     50  7809					      SUBROUTINE
     51  7809
      0  7809					      REFER	Reset
      1  7809				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  7809				  -TEMPORARY_VAR SET	VAREND_Reset
      3  7809					      ENDIF
      0  7809					      VAR	__speak_temp, 1
      1  7809		       00 a2	   __speak_temp =	TEMPORARY_VAR
      2  7809				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  7809
      4  7809				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  7809				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  7809				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  7809					      ENDIF
      8  7809				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  7809				  -	      ECHO	"Temporary Variable", __speak_temp, "overflow!"
     10  7809				  -	      ERR
     11  7809					      ENDIF
     12  7809					      LIST	ON
      0  7809					      VEND	GameSpeak
      1  7809				  -	      IFNCONST	GameSpeak
      2  7809				  -	      ECHO	"Incorrect VEND label", GameSpeak
      3  7809				  -	      ERR
      4  7809					      ENDIF
      5  7809		       00 a3	   VAREND_GameSpeak =	TEMPORARY_VAR
     55  7809
     56  7809		       a0 00		      ldy	#0
     57  780b		       b1 9b		      lda	(speech_addr),y
     58  780d		       c9 ff		      cmp	#$ff
     59  780f		       d0 08		      bne	.talk
     60  7811
      0  7811					      SPEAK	left_speech
      1  7811
      2  7811		       a9 4a		      lda	#<left_speech
      3  7813		       85 9b		      sta	speech_addr
      4  7815		       a9 f0		      lda	#>left_speech
      5  7817		       85 9c		      sta	speech_addr+1
      6  7819
     62  7819
     63  7819
     64  7819				   .talk
     65  7819
     66  7819							; check buffer-full status
     67  7819
     68  7819		       ad 80 02 	      lda	SWCHA
     69  781c		       29 02		      and	#SERIAL_RDYMASK
     70  781e		       f0 29		      beq	.speech_done
     71  7820
     72  7820		       a0 00		      ldy	#0
     73  7822		       b1 9b		      lda	(speech_addr),y
     74  7824
     75  7824		       49 ff		      eor	#$ff
     76  7826		       f0 21		      beq	.speech_done
     77  7828		       85 a2		      sta	__speak_temp
     78  782a
     79  782a		       e6 9b		      inc	speech_addr
     80  782c		       d0 02		      bne	.incaddr_skip
     81  782e		       e6 9c		      inc	speech_addr+1
     82  7830				   .incaddr_skip
     83  7830
     84  7830		       38		      sec		; start bit
     85  7831				   .byteout_loop
     86  7831
     87  7831							; put carry flag into bit 0 of SWACNT, perserving other bits
     88  7831
     89  7831		       ad 81 02 	      lda	SWACNT	; 4
     90  7834		       29 fe		      and	#$fe	; 2 6
     91  7836		       69 00		      adc	#$00	; 2 8
     92  7838		       8d 81 02 	      sta	SWACNT	; 4 12
     93  783b
     94  783b							; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
     95  783b
     96  783b		       c0 09		      cpy	#$09	; 2 14
     97  783d		       f0 0a		      beq	.speech_done	; 2 16
     98  783f		       c8		      iny		; 2 18
     99  7840
    100  7840
    101  7840		       a2 07		      ldx	#$07	; 2 20
    102  7842		       ca	   .delay_loop dex		; { 2
    103  7843		       d0 fd		      bne	.delay_loop	;   3
    104  7845							; } = 7 * 5 - 1 = 34
    105  7845							; @54
    106  7845
    107  7845		       46 a2		      lsr	__speak_temp	; 5 59
    108  7847		       10 e8		      bpl	.byteout_loop	; 3 62 cycles for loop
    109  7849
    110  7849		       60	   .speech_done rts
    111  784a
    112  784a
    113  784a							;---------------------------------------------------------------------------------------------------
    114  784a
    115  784a							; Speech Data
    116  784a
    117  784a							;Dec. SpeakJet Use
    118  784a							;----- ------------------
    119  784a							;000 Pause 0
    120  784a							;001 Pause 1
    121  784a							;002 Pause 2
    122  784a							;003 Pause 3
    123  784a							;004 Pause 4
    124  784a							;005 Pause 5
    125  784a							;006 Pause 6
    126  784a							;007 Play Next Sound Fast
    127  784a							;008 Play Next Sound Slow
    128  784a							;014 Play Next Sound High Tone
    129  784a							;015 Play Next Sound Low Tone
    130  784a							;016 Wait
    131  784a							;020 Volume, X
    132  784a							;021 Speed, X
    133  784a							;022 Pitch, X
    134  784a							;023 Bend, X
    135  784a							;024 PortCtr, X
    136  784a							;025 Port, X
    137  784a							;026 Repeat, X
    138  784a							;028 Call Phrase, X
    139  784a							;029 Goto Phrase, X
    140  784a							;030 Delay, X
    141  784a							;031 Reset Defaults
    142  784a							;--------------------------------------------------------
    143  784a							;032 Reserved
    144  784a							;- to -
    145  784a							;127
    146  784a							;--------------------------------------------------------
    147  784a							;128 127 Sound codes
    148  784a							;- to -
    149  784a							;254
    150  784a							;--------------------------------------------------------
    151  784a							;255 End of Phrase.
    152  784a
    153  784a
    154  784a
    155  784a				   left_speech
    156  784a
    157  784a
    158  784a		       1f		      dc.b	31
    159  784b							;	  dc.b $ff
    160  784b
    161  784b
    162  784b
    163  784b
    164  784b
    165  784b
    166  784b
    167  784b		       15 74		      dc.b	21,116	; speed 116
    168  784d		       17 04		      dc.b	23,4	; bend, 4
    169  784f		       16 37		      dc.b	22,55	; pitch, 55
    170  7851		       b6		      dc.b	182	;CH
    171  7852		       81		      dc.b	129	;IH
    172  7853		       c2		      dc.b	194	;KE
    173  7854		       83		      dc.b	131	;EH
    174  7855		       8d		      dc.b	141	;NE
    175  7856		       02		      dc.b	2	; pause 2
    176  7857		       02		      dc.b	2	; pause 2
    177  7858
    178  7858
    179  7858		       08		      dc.b	8	; play next sound slow
    180  7859		       ba		      dc.b	186	;FF
    181  785a		       07		      dc.b	7	; play fast
    182  785b		       9b		      dc.b	155	;OHIY
    183  785c		       04		      dc.b	4	; pause 4
    184  785d		       bf		      dc.b	191	;TT
    185  785e		       06		      dc.b	6	; pause 6
    186  785f		       91		      dc.b	145	;LE
    187  7860		       07		      dc.b	7	; fast
    188  7861		       88		      dc.b	136	;AW
    189  7862		       07		      dc.b	7	; fast
    190  7863		       9b		      dc.b	155	;OHIY
    191  7864		       c4		      dc.b	196	;EK
    192  7865		       06		      dc.b	6	; pause 6
    193  7866		       9a		      dc.b	154	;EYIY
    194  7867		       80		      dc.b	128	;IY
    195  7868		       06		      dc.b	6	; pause 6
    196  7869		       94		      dc.b	148	;GR?
    197  786a		       07		      dc.b	7	; fast
    198  786b		       89		      dc.b	137	;OW
    199  786c		       07		      dc.b	7	; fast
    200  786d		       a4		      dc.b	164	;OWW
    201  786e		       12		      dc.b	18	;???
    202  786f		       ab		      dc.b	171	;BO
    203  7870		       88		      dc.b	136	;AW
    204  7871		       bf		      dc.b	191	;TT
    205  7872		       1f		      dc.b	31	; reset defaults
    206  7873		       ff		      dc.b	$ff
    207  7874
    208  7874
    209  7874				   silence_speech
    210  7874
    211  7874
    212  7874
    213  7874		       1f		      dc.b	31	;31
    214  7875
    215  7875
    216  7875		       ff		      dc.b	$ff
    217  7876
      0  7876					      CHECK_BANK_SIZE	"BANK_SPEAK"
      1  7876		       00 76	   .TEMP      =	* - BANK_START
 BANK_SPEAK (2K) SIZE =  $76 , FREE= $78a
      2  7876					      ECHO	"BANK_SPEAK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  7876				  -	      IF	( .TEMP ) > ROM_BANK_SIZE
      4  7876				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  7876				  -	      ERR
      6  7876					      ENDIF
      7  7876
    219  7876
    220  7876				  -	      IF	0
    221  7876				  -typedef    enum
    222  7876				  -	      182
    223  7876				  -	      183	Pause0 = 0, ///< Pause 0ms
    224  7876				  -	      184	Pause1 = 1, ///< Pause 100ms
    225  7876				  -	      185	Pause2 = 2, ///< Pause 200ms
    226  7876				  -	      186	Pause3 = 3, ///< Pause 700ms
    227  7876				  -	      187	Pause4 = 4, ///< Pause 30ms
    228  7876				  -	      188	Pause5 = 5, ///< Pause 60ms
    229  7876				  -	      189	Pause6 = 6, ///< Pause 90ms
    230  7876				  -	      190	Fast = 7, ///< Next phoneme at 0.5 speed
    231  7876				  -	      191	Slow = 8, ///< Next phoneme at 1.5 speed
    232  7876				  -	      192	Stress = 14, ///< Next phoneme with some stress
    233  7876				  -	      193	Relax = 15, ///< Next phoneme with relaxation
    234  7876				  -	      194	Wait = 16, ///< Stops and waits for a Start (see manual)
    235  7876				  -	      195	Soft = 18, ///< Stops and waits for a Start (see manual)
    236  7876				  -	      196	Volume = 20, ///< Next octet is volume 0 to 127. Default 96
    237  7876				  -	      197	Speed = 21, ///< Next octet is speed 0 to 127. Default 114
    238  7876				  -	      198	Pitch = 22, ///< Next octet is pitch in Hz = to 255
    239  7876				  -	      199	Bend = 23, ///< Next octet is frequency bend to 15. Default is 5
    240  7876				  -	      200	PortCtr = 24, ///< Next octet is port control value. See manual. Default is 7
    241  7876				  -	      201	Port = 25, ///< Next octet is Port Output Value. See manual. Default is 0
    242  7876				  -	      202	Repeat = 26, ///< Next octet is repeat count. 0 to 255
    243  7876				  -	      203	CallPhrase = 28, ///< Next octet is EEPROM phrase to play and return. See manual.
    244  7876				  -	      204	GotoPhrase = 29, ///< Next octet is EEPROM phgrase to go to. See manual.
    245  7876				  -	      205	Delay = 30, ///< Next octet is delay in multiples of 10ms. 0 to 255.
    246  7876				  -	      206	Reset = 31, ///< Reset Volume Speed, Pitch, Bend to defaults.
    247  7876				  -	      207
    248  7876				  -	      208	// 32 to 127 reserved
    249  7876				  -	      209
    250  7876				  -	      210	// 128 to 254 Sound codes
    251  7876				  -	      211	// Phonemes, standard names
    252  7876				  -	      212	Phoneme_IY = 128, ///< 70ms Voiced Long Vowel
    253  7876				  -	      213	Phoneme_IH = 129, ///< 70ms Voiced Long Vowel
    254  7876				  -	      214	Phoneme_EY = 130, ///< 70ms Voiced Long Vowel
    255  7876				  -	      215	Phoneme_EH = 131, ///< 70ms Voiced Long Vowel
    256  7876				  -	      216	Phoneme_AY = 132, ///< 70ms Voiced Long Vowel
    257  7876				  -	      217	Phoneme_AX = 133, ///< 70ms Voiced Long Vowel
    258  7876				  -	      218	Phoneme_UX = 134, ///< 70ms Voiced Long Vowel
    259  7876				  -	      219	Phoneme_OH = 135, ///< 70ms Voiced Long Vowel
    260  7876				  -	      220	Phoneme_AW = 136, ///< 70ms Voiced Long Vowel
    261  7876				  -	      221	Phoneme_OW = 137, ///< 70ms Voiced Long Vowel
    262  7876				  -	      222	Phoneme_UH = 138, ///< 70ms Voiced Long Vowel
    263  7876				  -	      223	Phoneme_UW = 139, ///< 70ms Voiced Long Vowel
    264  7876				  -	      224	Phoneme_MM = 140, ///< 70ms Voiced Nasal
    265  7876				  -	      225	Phoneme_NE = 141, ///< 70ms Voiced Nasal
    266  7876				  -	      226	Phoneme_NO = 142, ///< 70ms Voiced Nasal
    267  7876				  -	      227	Phoneme_NGE = 143, ///< 70ms Voiced Nasal
    268  7876				  -	      228	Phoneme_NGO = 144, ///< 70ms Voiced Nasal
    269  7876				  -	      229	Phoneme_LE = 145, ///< 70ms Voiced Resonate
    270  7876				  -	      230	Phoneme_LO = 146, ///< 70ms Voiced Resonate
    271  7876				  -	      231	Phoneme_WW = 147, ///< 70ms Voiced Resonate
    272  7876				  -	      232	Phoneme_RR = 149, //148? ///< 70ms Voiced Resonate
    273  7876				  -	      233	Phoneme_IYRR = 149, ///< 200ms Voiced R Color Vowel
    274  7876				  -	      234	Phoneme_EYRR = 150, ///< 200ms Voiced R Color Vowel
    275  7876				  -	      235	Phoneme_AXRR = 151, ///< 190ms Voiced R Color Vowel
    276  7876				  -	      236	Phoneme_AWRR = 152, ///< 200ms Voiced R Color Vowel
    277  7876				  -	      237	Phoneme_OWRR = 153, ///< 185ms Voiced R Color Vowel
    278  7876				  -	      238	Phoneme_EYIY = 154, ///< 165ms Voiced Diphthong
    279  7876				  -	      239	Phoneme_OHIY = 155, ///< 200ms Voiced Diphthong
    280  7876				  -	      240	Phoneme_OWIY = 156, ///< 225ms Voiced Diphthong
    281  7876				  -	      241	Phoneme_OHIH = 157, ///< 185ms Voiced Diphthong
    282  7876				  -	      242	Phoneme_IYEH = 158, ///< 170ms Voiced Diphthong
    283  7876				  -	      243	Phoneme_EHLE = 159, ///< 140ms Voiced Diphthong
    284  7876				  -	      244	Phoneme_IYUW = 160, ///< 180ms Voiced Diphthong
    285  7876				  -	      245	Phoneme_AXUW = 161, ///< 170ms Voiced Diphthong
    286  7876				  -	      246	Phoneme_IHWW = 162, ///< 170ms Voiced Diphthong
    287  7876				  -	      247	Phoneme_AYWW = 163, ///< 200ms Voiced Diphthong
    288  7876				  -	      248	Phoneme_OWWW = 164, ///< 131ms Voiced Diphthong
    289  7876				  -	      249	Phoneme_JH = 165, ///< 70ms Voiced Affricate
    290  7876				  -	      250	Phoneme_VV = 166, ///< 70ms Voiced Fricative
    291  7876				  -	      251	Phoneme_ZZ = 167, ///< 70ms Voiced Fricative
    292  7876				  -	      252	Phoneme_ZH = 168, ///< 70ms Voiced Fricative
    293  7876				  -	      253	Phoneme_DH = 169, ///< 70ms Voiced Fricative
    294  7876				  -	      254	Phoneme_BE = 170, ///< 45ms Voiced Stop
    295  7876				  -	      255	Phoneme_BO = 171, ///< 45ms Voiced Stop
    296  7876				  -	      256	Phoneme_EB = 172, ///< 10ms Voiced Stop
    297  7876				  -	      257	Phoneme_OB = 173, ///< 10ms Voiced Stop
    298  7876				  -	      258	Phoneme_DE = 174, ///< 45ms Voiced Stop
    299  7876				  -	      259	Phoneme_DO = 174, ///< 45ms Voiced Stop
    300  7876				  -	      260	Phoneme_ED = 176, ///< 10ms Voiced Stop
    301  7876				  -	      261	Phoneme_OD = 177, ///< 10ms Voiced Stop
    302  7876				  -	      262	Phoneme_GE = 178, ///< 55ms Voiced Stop
    303  7876				  -	      263	Phoneme_GO = 179, ///< 55ms Voiced Stop
    304  7876				  -	      264	Phoneme_EG = 180, ///< 55ms Voiced Stop
    305  7876				  -	      265	Phoneme_OG = 181, ///< 55ms Voiced Stop
    306  7876				  -	      266	Phoneme_CH = 182, ///< 70ms Voiceless Affricate
    307  7876				  -	      267	Phoneme_HE = 183, ///< 70ms Voiceless Fricative
    308  7876				  -	      268	Phoneme_HO = 184, ///< 70ms Voiceless Fricative
    309  7876				  -	      269	Phoneme_WH = 185, ///< 70ms Voiceless Fricative
    310  7876				  -	      270	Phoneme_FF = 186, ///< 70ms Voiceless Fricative
    311  7876				  -	      271	Phoneme_SE = 187, ///< 40ms Voiceless Fricative
    312  7876				  -	      272	Phoneme_SO = 188, ///< 40ms Voiceless Fricative
    313  7876				  -	      273	Phoneme_SH = 189, ///< 50ms Voiceless Fricative
    314  7876				  -	      274	Phoneme_TH = 190, ///< 40ms Voiceless Fricative
    315  7876				  -	      275	Phoneme_TT = 191, ///< 50ms Voiceless Stop
    316  7876				  -	      276	Phoneme_TU = 192, ///< 70ms Voiceless Stop
    317  7876				  -	      277	Phoneme_TS = 193, ///< 170ms Voiceless Stop
    318  7876				  -	      278	Phoneme_KE = 194, ///< 55ms Voiceless Stop
    319  7876				  -	      279	Phoneme_KO = 195, ///< 55ms Voiceless Stop
    320  7876				  -	      280	Phoneme_EK = 196, ///< 55ms Voiceless Stop
    321  7876				  -	      281	Phoneme_OK = 197, ///< 45ms Voiceless Stop
    322  7876				  -	      282	Phoneme_PE = 198, ///< 99ms Voiceless Stop
    323  7876				  -	      283	Phoneme_PO = 199, ///< 99ms Voiceless Stop
    324  7876				  -	      284	// Robot sound
    325  7876				  -	      285	Sound_R0 = 200, ///< 80ms Robot
    326  7876				  -	      286	Sound_R1 = 201, ///< 80ms Robot
    327  7876				  -	      287	Sound_R2 = 202, ///< 80ms Robot
    328  7876				  -	      288	Sound_R3 = 203, ///< 80ms Robot
    329  7876				  -	      289	Sound_R4 = 204, ///< 80ms Robot
    330  7876				  -	      290	Sound_R5 = 205, ///< 80ms Robot
    331  7876				  -	      291	Sound_R6 = 206, ///< 80ms Robot
    332  7876				  -	      292	Sound_R7 = 207, ///< 80ms Robot
    333  7876				  -	      293	Sound_R8 = 208, ///< 80ms Robot
    334  7876				  -	      294	Sound_R9 = 209, ///< 80ms Robot
    335  7876				  -	      295	// Alarm sound
    336  7876				  -	      296	Sound_A0 = 210, ///< 300ms Alarm
    337  7876				  -	      297	Sound_A1 = 211, ///< 101ms Alarm
    338  7876				  -	      298	Sound_A2 = 212, ///< 102ms Alarm
    339  7876				  -	      299	Sound_A3 = 213, ///< 540ms Alarm
    340  7876				  -	      300	Sound_A4 = 214, ///< 530ms Alarm
    341  7876				  -	      301	Sound_A5 = 215, ///< 500ms Alarm
    342  7876				  -	      302	Sound_A6 = 216, ///< 135ms Alarm
    343  7876				  -	      303	Sound_A7 = 217, ///< 600ms Alarm
    344  7876				  -	      304	Sound_A8 = 218, ///< 300ms Alarm
    345  7876				  -	      305	Sound_A9 = 219, ///< 250ms Alarm
    346  7876				  -	      306	// Beeps
    347  7876				  -	      307	Sound_B0 = 220, ///< 200ms Beep
    348  7876				  -	      308	Sound_B1 = 221, ///< 270ms Beep
    349  7876				  -	      309	Sound_B2 = 222, ///< 280ms Beep
    350  7876				  -	      310	Sound_B3 = 223, ///< 260ms Beep
    351  7876				  -	      311	Sound_B4 = 224, ///< 300ms Beep
    352  7876				  -	      312	Sound_B5 = 225, ///< 100ms Beep
    353  7876				  -	      313	Sound_B6 = 226, ///< 104ms Beep
    354  7876				  -	      314	Sound_B7 = 227, ///< 100ms Beep
    355  7876				  -	      315	Sound_B8 = 228, ///< 270ms Beep
    356  7876				  -	      316	Sound_B9 = 229, ///< 262ms Beep
    357  7876				  -	      317	// Biological
    358  7876				  -	      318	Sound_C0 = 230, ///< 160ms Biological
    359  7876				  -	      319	Sound_C1 = 231, ///< 300ms Biological
    360  7876				  -	      320	Sound_C2 = 232, ///< 182ms Biological
    361  7876				  -	      321	Sound_C3 = 233, ///< 120ms Biological
    362  7876				  -	      322	Sound_C4 = 234, ///< 175ms Biological
    363  7876				  -	      323	Sound_C5 = 235, ///< 350ms Biological
    364  7876				  -	      324	Sound_C6 = 236, ///< 160ms Biological
    365  7876				  -	      325	Sound_C7 = 237, ///< 260ms Biological
    366  7876				  -	      326	Sound_C8 = 238, ///< 95ms Biological
    367  7876				  -	      327	Sound_C9 = 239, ///< 75ms Biological
    368  7876				  -	      328	// DTMF
    369  7876				  -	      329	DTMF_0 = 240, ///< DTMF 0 95ms
    370  7876				  -	      330	DTMF_1 = 241, ///< DTMF 1 95ms
    371  7876				  -	      331	DTMF_2 = 242, ///< DTMF 2 95ms
    372  7876				  -	      332	DTMF_3 = 243, ///< DTMF 3 95ms
    373  7876				  -	      333	DTMF_4 = 244, ///< DTMF 4 95ms
    374  7876				  -	      334	DTMF_5 = 245, ///< DTMF 5 95ms
    375  7876				  -	      335	DTMF_6 = 246, ///< DTMF 6 95ms
    376  7876				  -	      336	DTMF_7 = 247, ///< DTMF 7 95ms
    377  7876				  -	      337	DTMF_8 = 248, ///< DTMF 8 95ms
    378  7876				  -	      338	DTMF_9 = 249, ///< DTMF 9 95ms
    379  7876				  -	      339	DTMF_STAR = 250, ///< DTMF * 95ms
    380  7876				  -	      340	DTMF_HASH = 251, ///< DTMF # 95ms
    381  7876				  -	      341	// Miscellaneous
    382  7876				  -	      342	Sound_M0 = 252, ///< Sonar ping 125ms
    383  7876				  -	      343	Sound_M1 = 253, ///< Pistol shot 250ms
    384  7876				  -	      344	Sound_M2 = 254, ///< WOW 530ms
    385  7876				  -	      345
    386  7876				  -	      346	EndOfPhrase = 255, ///< End of phrase marker. Required at end of code arrays
    387  7876				  -	      347
    388  7876				  -	      348	CommandCodes	;
    389  7876				  -	      349
    390  7876				  -
    391  7876				  -ENDIF
------- FILE ./chess.asm
    613  7876
    614  7876							; MUST BE LAST...
------- FILE BANK_FIXED.asm LEVEL 2 PASS 5
      0  7876					      include	"BANK_FIXED.asm"
      1  7876							; Chess
      2  7876							; Copyright (c) 2019-2020 Andrew Davie
      3  7876							; andrew@taswegian.com
      4  7876
      5  7876
      6  7876							;---------------------------------------------------------------------------------------------------
      7  7876							;#########################################  FIXED BANK  ############################################
      8  7876							;---------------------------------------------------------------------------------------------------
      9  7876
     10  7876				   ORIGIN     SET	FIXED_BANK
     11  7876
      0  7876					      NEWBANK	THE_FIXED_BANK
      1  ffdf ????				      SEG	THE_FIXED_BANK
      2  f800					      ORG	ORIGIN
      3  f800					      RORG	$F000
      4  f800				   BANK_START SET	*
      5  f800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  f800				   ORIGIN     SET	ORIGIN + 2048
      7  f800				   _CURRENT_BANK SET	THE_FIXED_BANK
     13  f800					      RORG	$f800
     14  f800
     15  f800							;---------------------------------------------------------------------------------------------------
     16  f800
      0  f800					      DEF	Reset
      1  f800				   BANK_Reset SET	_CURRENT_BANK
      2  f800				   Reset
      3  f800				   TEMPORARY_VAR SET	Overlay
      4  f800				   TEMPORARY_OFFSET SET	0
      5  f800				   VAR_BOUNDARY_Reset SET	TEMPORARY_OFFSET
      6  f800				   FUNCTION_NAME SET	Reset
      7  f800					      SUBROUTINE
     18  f800					      SUBROUTINE
     19  f800
      0  f800					      VEND	Reset
      1  f800				  -	      IFNCONST	Reset
      2  f800				  -	      ECHO	"Incorrect VEND label", Reset
      3  f800				  -	      ERR
      4  f800					      ENDIF
      5  f800		       00 a2	   VAREND_Reset =	TEMPORARY_VAR
     21  f800
     22  f800		       a2 ff		      ldx	#$FF
     23  f802		       9a		      txs
     24  f803
      0  f803					      JSROM_SAFE	cartInit
      1  f803
      2  f803
      3  f803
      4  f803		       a9 00		      lda	#BANK_cartInit
      5  f805		       85 8b		      sta	savedBank
      6  f807		       85 3f		      sta	SET_BANK
      7  f809		       20 04 f0 	      jsr	cartInit
     26  f80c
     27  f80c							;JSROM TitleScreen
     28  f80c
     29  f80c							;JSROM ShutYourMouth
     30  f80c
     31  f80c							; Patch the final row's "loop" to a RTS
     32  f80c
     33  f80c		       a2 07		      ldx	#7
     34  f80e		       86 3e		      stx	SET_BANK_RAM
     35  f810		       a9 60		      lda	#$60	; "rts"
      0  f812					      sta@RAM	SELFMOD_RTS_ON_LAST_ROW
      1  f812		       8d 00 f6 	      sta	[RAM]+SELFMOD_RTS_ON_LAST_ROW
     37  f815
     38  f815		       20 6d fc 	      jsr	InitialisePieceSquares
     39  f818
     40  f818
     41  f818							;RESYNC
     42  f818				   .StartFrame
     43  f818
     44  f818
     45  f818							; START OF FRAME
     46  f818
     47  f818		       a9 0e		      lda	#%1110	; VSYNC ON
     48  f81a		       85 42	   .loopVSync3 sta	WSYNC
     49  f81c		       85 40		      sta	VSYNC
     50  f81e		       4a		      lsr
     51  f81f		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     52  f821
     53  f821		       85 41		      sta	VBLANK
     54  f823
     55  f823		       a0 2e		      ldy	#TIME_PART_1
     56  f825		       8c 96 02 	      sty	TIM64T
     57  f828
     58  f828							; LOTS OF PROCESSING TIME - USE IT
     59  f828
     60  f828		       20 71 f8 	      jsr	AiStateMachine
     61  f82b
     62  f82b
     63  f82b							;xx2 lda INTIM
     64  f82b							; beq xx2
     65  f82b
     66  f82b
     67  f82b				  -	      IF	ASSERTS
     68  f82b				  -			; Catch timer expired already
     69  f82b				  -			;		      bit TIMINT
     70  f82b				  -			;.whoops	      bmi .whoops
     71  f82b					      ENDIF
     72  f82b
     73  f82b
     74  f82b		       2c 85 02    .wait      bit	TIMINT
     75  f82e		       10 fb		      bpl	.wait
     76  f830
     77  f830
     78  f830							; START OF VISIBLE SCANLINES
     79  f830
     80  f830
      0  f830					      JSROM	longD
      1  f830
      2  f830		       a9 00		      lda	#BANK_longD
      3  f832		       85 3f		      sta	SET_BANK
      4  f834		       20 71 f0 	      jsr	longD
     82  f837
     83  f837		       86 3e		      stx	SET_BANK_RAM
     84  f839		       20 03 f2 	      jsr	DrawRow	; draw the ENTIRE visible screen!
     85  f83c
      0  f83c					      JSROM	tidySc
      1  f83c
      2  f83c		       a9 00		      lda	#BANK_tidySc
      3  f83e		       85 3f		      sta	SET_BANK
      4  f840		       20 5d f0 	      jsr	tidySc
     87  f843
     88  f843		       20 71 f8 	      jsr	AiStateMachine
     89  f846
     90  f846		       ad 84 02 	      lda	INTIM
     91  f849		       c9 14		      cmp	#20
     92  f84b		       90 1b		      bcc	.notnow
     93  f84d
      0  f84d					      JSROM	GameSpeak
      1  f84d
      2  f84d		       a9 0f		      lda	#BANK_GameSpeak
      3  f84f		       85 3f		      sta	SET_BANK
      4  f851		       20 09 f0 	      jsr	GameSpeak
      0  f854					      JSROM	PositionSprites
      1  f854
      2  f854		       a9 07		      lda	#BANK_PositionSprites
      3  f856		       85 3f		      sta	SET_BANK
      4  f858		       20 00 f5 	      jsr	PositionSprites
     96  f85b
     97  f85b
     98  f85b							; "draw" sprite shapes into row banks
     99  f85b
    100  f85b		       a2 07		      ldx	#7
    101  f85d		       86 3e	   zapem      stx	SET_BANK_RAM
    102  f85f		       20 a6 f2 	      jsr	WriteBlank
    103  f862		       ca		      dex
    104  f863		       10 f8		      bpl	zapem
    105  f865
    106  f865		       20 cf f2 	      jsr	WriteCursor
    107  f868				   .notnow
    108  f868
    109  f868							;    lda aiState
    110  f868							;    beq Waitforit
    111  f868							;    cmp #22
    112  f868							;    bcc Waitforit
    113  f868							;xx3 bit TIMINT
    114  f868							; bmi xx3
    115  f868
    116  f868		       2c 85 02    .waitTime  bit	TIMINT
    117  f86b		       10 fb		      bpl	.waitTime
    118  f86d
    119  f86d		       4c 18 f8 	      jmp	.StartFrame
    120  f870
    121  f870
    122  f870		       60	   _rts       rts
    123  f871
    124  f871
    125  f871							;---------------------------------------------------------------------------------------------------
    126  f871
      0  f871					      DEF	AiStateMachine
      1  f871				   BANK_AiStateMachine SET	_CURRENT_BANK
      2  f871				   AiStateMachine
      3  f871				   TEMPORARY_VAR SET	Overlay
      4  f871				   TEMPORARY_OFFSET SET	0
      5  f871				   VAR_BOUNDARY_AiStateMachine SET	TEMPORARY_OFFSET
      6  f871				   FUNCTION_NAME SET	AiStateMachine
      7  f871					      SUBROUTINE
    128  f871					      SUBROUTINE
    129  f871
      0  f871					      REFER	Reset
      1  f871				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  f871				  -TEMPORARY_VAR SET	VAREND_Reset
      3  f871					      ENDIF
      0  f871					      VEND	AiStateMachine
      1  f871				  -	      IFNCONST	AiStateMachine
      2  f871				  -	      ECHO	"Incorrect VEND label", AiStateMachine
      3  f871				  -	      ERR
      4  f871					      ENDIF
      5  f871		       00 a2	   VAREND_AiStateMachine =	TEMPORARY_VAR
    132  f871
      0  f871					      JSROM	AiSetupVectors
      1  f871
      2  f871		       a9 07		      lda	#BANK_AiSetupVectors
      3  f873		       85 3f		      sta	SET_BANK
      4  f875		       20 7b f0 	      jsr	AiSetupVectors
    134  f878		       85 3f		      sta	SET_BANK
    135  f87a		       6c ea 00 	      jmp	(__ptr)	; TODO: OR branch back to squeeze cycles
    136  f87d
    137  f87d
    138  f87d							;---------------------------------------------------------------------------------------------------
    139  f87d
      0  f87d					      DEF	CallClear
      1  f87d				   BANK_CallClear SET	_CURRENT_BANK
      2  f87d				   CallClear
      3  f87d				   TEMPORARY_VAR SET	Overlay
      4  f87d				   TEMPORARY_OFFSET SET	0
      5  f87d				   VAR_BOUNDARY_CallClear SET	TEMPORARY_OFFSET
      6  f87d				   FUNCTION_NAME SET	CallClear
      7  f87d					      SUBROUTINE
    141  f87d					      SUBROUTINE
    142  f87d
      0  f87d					      REFER	aiClearEachRow
      1  f87d				  -	      IF	VAREND_aiClearEachRow > TEMPORARY_VAR
      2  f87d				  -TEMPORARY_VAR SET	VAREND_aiClearEachRow
      3  f87d					      ENDIF
      0  f87d					      VEND	CallClear
      1  f87d				  -	      IFNCONST	CallClear
      2  f87d				  -	      ECHO	"Incorrect VEND label", CallClear
      3  f87d				  -	      ERR
      4  f87d					      ENDIF
      5  f87d		       00 a2	   VAREND_CallClear =	TEMPORARY_VAR
    145  f87d
    146  f87d							; No transient variable dependencies/calls
    147  f87d
    148  f87d		       84 3e		      sty	SET_BANK_RAM
    149  f87f		       20 90 f1 	      jsr	ClearRowBitmap
    150  f882		       60		      rts
    151  f883
    152  f883
    153  f883							;---------------------------------------------------------------------------------------------------
    154  f883
      0  f883					      DEF	aiDrawEntireBoard
      1  f883				   BANK_aiDrawEntireBoard SET	_CURRENT_BANK
      2  f883				   aiDrawEntireBoard
      3  f883				   TEMPORARY_VAR SET	Overlay
      4  f883				   TEMPORARY_OFFSET SET	0
      5  f883				   VAR_BOUNDARY_aiDrawEntireBoard SET	TEMPORARY_OFFSET
      6  f883				   FUNCTION_NAME SET	aiDrawEntireBoard
      7  f883					      SUBROUTINE
    156  f883					      SUBROUTINE
    157  f883
      0  f883					      REFER	AiStateMachine
      1  f883				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f883				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f883					      ENDIF
      0  f883					      VEND	aiDrawEntireBoard
      1  f883				  -	      IFNCONST	aiDrawEntireBoard
      2  f883				  -	      ECHO	"Incorrect VEND label", aiDrawEntireBoard
      3  f883				  -	      ERR
      4  f883					      ENDIF
      5  f883		       00 a2	   VAREND_aiDrawEntireBoard =	TEMPORARY_VAR
    160  f883
    161  f883
    162  f883		       ad 84 02 	      lda	INTIM
    163  f886		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    164  f888		       90 2c		      bcc	.exit
    165  f88a
    166  f88a		       a9 09		      lda	#RAMBANK_BOARD
    167  f88c		       85 3e		      sta	SET_BANK_RAM
    168  f88e		       a4 80		      ldy	squareToDraw
    169  f890		       b9 20 f0 	      lda	ValidSquare,y
    170  f893		       30 1d		      bmi	.isablank2
    171  f895
    172  f895		       b9 84 f0 	      lda	Board,y
    173  f898		       f0 13		      beq	.isablank
    174  f89a		       48		      pha
    175  f89b		       a9 00		      lda	#BLANK
      0  f89d					      sta@RAM	Board,y
      1  f89d		       99 84 f4 	      sta	[RAM]+Board,y
    177  f8a0
    178  f8a0		       20 40 fd 	      jsr	CopySinglePiece
    179  f8a3
    180  f8a3		       a9 09		      lda	#RAMBANK_BOARD
    181  f8a5		       85 3e		      sta	SET_BANK_RAM
    182  f8a7
    183  f8a7		       a4 80		      ldy	squareToDraw
    184  f8a9		       68		      pla
      0  f8aa					      sta@RAM	Board,y
      1  f8aa		       99 84 f4 	      sta	[RAM]+Board,y
    186  f8ad
      0  f8ad				   .isablank  PHASE	AI_DrawPart2
      1  f8ad		       a9 10		      lda	#AI_DrawPart2
      2  f8af		       85 8c		      sta	aiState
    188  f8b1		       60		      rts
    189  f8b2
      0  f8b2				   .isablank2 PHASE	AI_DrawPart3
      1  f8b2		       a9 11		      lda	#AI_DrawPart3
      2  f8b4		       85 8c		      sta	aiState
    191  f8b6		       60	   .exit      rts
    192  f8b7
    193  f8b7
    194  f8b7							;---------------------------------------------------------------------------------------------------
    195  f8b7
      0  f8b7					      DEF	aiGenerateMoves
      1  f8b7				   BANK_aiGenerateMoves SET	_CURRENT_BANK
      2  f8b7				   aiGenerateMoves
      3  f8b7				   TEMPORARY_VAR SET	Overlay
      4  f8b7				   TEMPORARY_OFFSET SET	0
      5  f8b7				   VAR_BOUNDARY_aiGenerateMoves SET	TEMPORARY_OFFSET
      6  f8b7				   FUNCTION_NAME SET	aiGenerateMoves
      7  f8b7					      SUBROUTINE
    197  f8b7					      SUBROUTINE
    198  f8b7
      0  f8b7					      REFER	AiStateMachine
      1  f8b7				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f8b7				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f8b7					      ENDIF
      0  f8b7					      VEND	aiGenerateMoves
      1  f8b7				  -	      IFNCONST	aiGenerateMoves
      2  f8b7				  -	      ECHO	"Incorrect VEND label", aiGenerateMoves
      3  f8b7				  -	      ERR
      4  f8b7					      ENDIF
      5  f8b7		       00 a2	   VAREND_aiGenerateMoves =	TEMPORARY_VAR
    201  f8b7
    202  f8b7							; Player comes here at the start of making a move
    203  f8b7							; This generates a valid movelist by calling 'negaMax' (removing illegal moves)
    204  f8b7
    205  f8b7		       a5 86		      lda	toX12
    206  f8b9		       85 80		      sta	squareToDraw	; for showing move (display square)
    207  f8bb
    208  f8bb		       a6 96		      ldx	sideToMove
    209  f8bd		       10 05		      bpl	.player
    210  f8bf
    211  f8bf
      0  f8bf				   .computer  PHASE	AI_ComputerMove	; computer select move
      1  f8bf		       a9 13		      lda	#AI_ComputerMove
      2  f8c1		       85 8c		      sta	aiState
    213  f8c3		       60		      rts
    214  f8c4
    215  f8c4
      0  f8c4				   .player    PHASE	AI_StartMoveGen
      1  f8c4		       a9 0b		      lda	#AI_StartMoveGen
      2  f8c6		       85 8c		      sta	aiState
    217  f8c8		       60		      rts
    218  f8c9
    219  f8c9
    220  f8c9							;---------------------------------------------------------------------------------------------------
    221  f8c9
      0  f8c9					      DEF	aiStepMoveGen
      1  f8c9				   BANK_aiStepMoveGen SET	_CURRENT_BANK
      2  f8c9				   aiStepMoveGen
      3  f8c9				   TEMPORARY_VAR SET	Overlay
      4  f8c9				   TEMPORARY_OFFSET SET	0
      5  f8c9				   VAR_BOUNDARY_aiStepMoveGen SET	TEMPORARY_OFFSET
      6  f8c9				   FUNCTION_NAME SET	aiStepMoveGen
      7  f8c9					      SUBROUTINE
    223  f8c9					      SUBROUTINE
    224  f8c9
      0  f8c9					      REFER	AiStateMachine
      1  f8c9				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f8c9				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f8c9					      ENDIF
      0  f8c9					      VEND	aiStepMoveGen
      1  f8c9				  -	      IFNCONST	aiStepMoveGen
      2  f8c9				  -	      ECHO	"Incorrect VEND label", aiStepMoveGen
      3  f8c9				  -	      ERR
      4  f8c9					      ENDIF
      5  f8c9		       00 a2	   VAREND_aiStepMoveGen =	TEMPORARY_VAR
    227  f8c9
    228  f8c9		       a5 87		      lda	originX12	; location of cursor (show move)
    229  f8cb		       85 88		      sta	cursorX12
      0  f8cd					      PHASE	AI_BeginSelectMovePhase
      1  f8cd		       a9 01		      lda	#AI_BeginSelectMovePhase
      2  f8cf		       85 8c		      sta	aiState
    231  f8d1		       60		      rts
    232  f8d2
    233  f8d2
    234  f8d2							;---------------------------------------------------------------------------------------------------
    235  f8d2
      0  f8d2					      DEF	ListPlayerMoves
      1  f8d2				   BANK_ListPlayerMoves SET	_CURRENT_BANK
      2  f8d2				   ListPlayerMoves
      3  f8d2				   TEMPORARY_VAR SET	Overlay
      4  f8d2				   TEMPORARY_OFFSET SET	0
      5  f8d2				   VAR_BOUNDARY_ListPlayerMoves SET	TEMPORARY_OFFSET
      6  f8d2				   FUNCTION_NAME SET	ListPlayerMoves
      7  f8d2					      SUBROUTINE
    237  f8d2					      SUBROUTINE
    238  f8d2
    239  f8d2
    240  f8d2		       a9 00		      lda	#0
    241  f8d4		       85 ad		      sta	__quiesceCapOnly	; gen ALL moves
    242  f8d6
    243  f8d6		       a9 0b		      lda	#RAMBANK_PLY+1
    244  f8d8		       85 95		      sta	currentPly
    245  f8da		       20 07 f9 	      jsr	GenerateAllMoves
    246  f8dd
      0  f8dd					      ldx@PLY	moveIndex
      1  f8dd		       ae 4f f1 	      ldx	moveIndex
      0  f8e0				   .scan      stx@PLY	movePtr
      1  f8e0		       8e 50 f5 	      stx	[RAM]+movePtr
    249  f8e3
    250  f8e3		       20 dc fd 	      jsr	MakeMove
    251  f8e6
    252  f8e6		       e6 95		      inc	currentPly
    253  f8e8		       20 07 f9 	      jsr	GenerateAllMoves
    254  f8eb
    255  f8eb		       c6 95		      dec	currentPly
    256  f8ed		       a5 95		      lda	currentPly
    257  f8ef		       85 3e		      sta	SET_BANK_RAM
    258  f8f1
    259  f8f1		       20 4f fe 	      jsr	unmakeMove
    260  f8f4
    261  f8f4		       a5 9f		      lda	flagCheck
    262  f8f6		       f0 08		      beq	.next
    263  f8f8
      0  f8f8					      ldx@PLY	movePtr
      1  f8f8		       ae 50 f1 	      ldx	movePtr
    265  f8fb		       a9 00		      lda	#0
      0  f8fd					      sta@PLY	MoveFrom,x	; invalidate move (still in check!)
      1  f8fd		       9d 02 f4 	      sta	[RAM]+MoveFrom,x
    267  f900
      0  f900				   .next      ldx@PLY	movePtr
      1  f900		       ae 50 f1 	      ldx	movePtr
    269  f903		       ca		      dex
    270  f904		       10 da		      bpl	.scan
    271  f906
    272  f906		       60		      rts
    273  f907
    274  f907
    275  f907							;---------------------------------------------------------------------------------------------------
    276  f907
      0  f907					      DEF	GenerateAllMoves
      1  f907				   BANK_GenerateAllMoves SET	_CURRENT_BANK
      2  f907				   GenerateAllMoves
      3  f907				   TEMPORARY_VAR SET	Overlay
      4  f907				   TEMPORARY_OFFSET SET	0
      5  f907				   VAR_BOUNDARY_GenerateAllMoves SET	TEMPORARY_OFFSET
      6  f907				   FUNCTION_NAME SET	GenerateAllMoves
      7  f907					      SUBROUTINE
    278  f907					      SUBROUTINE
    279  f907
      0  f907					      REFER	negaMax
      1  f907					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	VAREND_negaMax
      3  f907					      ENDIF
      0  f907					      REFER	quiesce
      1  f907				  -	      IF	VAREND_quiesce > TEMPORARY_VAR
      2  f907				  -TEMPORARY_VAR SET	VAREND_quiesce
      3  f907					      ENDIF
      0  f907					      REFER	aiStepMoveGen
      1  f907				  -	      IF	VAREND_aiStepMoveGen > TEMPORARY_VAR
      2  f907				  -TEMPORARY_VAR SET	VAREND_aiStepMoveGen
      3  f907					      ENDIF
      0  f907					      REFER	aiGenerateMoves
      1  f907				  -	      IF	VAREND_aiGenerateMoves > TEMPORARY_VAR
      2  f907				  -TEMPORARY_VAR SET	VAREND_aiGenerateMoves
      3  f907					      ENDIF
      0  f907					      REFER	selectmove
      1  f907				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  f907				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  f907					      ENDIF
      0  f907					      VAR	__vector, 2
      1  f907		       00 ae	   __vector   =	TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f907
      4  f907				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f907				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f907				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f907					      ENDIF
      8  f907				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f907				  -	      ECHO	"Temporary Variable", __vector, "overflow!"
     10  f907				  -	      ERR
     11  f907					      ENDIF
     12  f907					      LIST	ON
      0  f907					      VAR	__masker, 2
      1  f907		       00 b0	   __masker   =	TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f907
      4  f907				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f907				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f907				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f907					      ENDIF
      8  f907				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f907				  -	      ECHO	"Temporary Variable", __masker, "overflow!"
     10  f907				  -	      ERR
     11  f907					      ENDIF
     12  f907					      LIST	ON
      0  f907					      VAR	__pieceFilter, 1
      1  f907		       00 b2	   __pieceFilter =	TEMPORARY_VAR
      2  f907				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f907
      4  f907				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f907				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f907				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f907					      ENDIF
      8  f907				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f907				  -	      ECHO	"Temporary Variable", __pieceFilter, "overflow!"
     10  f907				  -	      ERR
     11  f907					      ENDIF
     12  f907					      LIST	ON
      0  f907					      VEND	GenerateAllMoves
      1  f907				  -	      IFNCONST	GenerateAllMoves
      2  f907				  -	      ECHO	"Incorrect VEND label", GenerateAllMoves
      3  f907				  -	      ERR
      4  f907					      ENDIF
      5  f907		       00 b3	   VAREND_GenerateAllMoves =	TEMPORARY_VAR
    289  f907
    290  f907							; Do the move generation in two passes - pawns then pieces
    291  f907							; This is an effort to get the alphabeta pruning happening with major pieces handled first in list
    292  f907
    293  f907		       a5 95		      lda	currentPly
    294  f909		       85 3e		      sta	SET_BANK_RAM
    295  f90b		       20 5a f1 	      jsr	NewPlyInitialise
    296  f90e
    297  f90e		       a9 08		      lda	#8	; pawns
    298  f910		       85 b2		      sta	__pieceFilter
    299  f912		       20 27 f9 	      jsr	MoveGenX
    300  f915		       a9 63		      lda	#99
    301  f917		       85 93		      sta	currentSquare
    302  f919		       a9 00		      lda	#0
    303  f91b		       85 b2		      sta	__pieceFilter
    304  f91d		       20 27 f9 	      jsr	MoveGenX
    305  f920
    306  f920		       a5 95		      lda	currentPly
    307  f922		       85 3e		      sta	SET_BANK_RAM
    308  f924		       4c 38 f2 	      jmp	Sort
    309  f927
    310  f927
    311  f927
      0  f927					      DEF	MoveGenX
      1  f927				   BANK_MoveGenX SET	_CURRENT_BANK
      2  f927				   MoveGenX
      3  f927				   TEMPORARY_VAR SET	Overlay
      4  f927				   TEMPORARY_OFFSET SET	0
      5  f927				   VAR_BOUNDARY_MoveGenX SET	TEMPORARY_OFFSET
      6  f927				   FUNCTION_NAME SET	MoveGenX
      7  f927					      SUBROUTINE
    313  f927					      SUBROUTINE
    314  f927
    315  f927		       a2 64		      ldx	#100
    316  f929		       d0 02		      bne	.next2
    317  f92b
    318  f92b		       a6 93	   MoveReturn ldx	currentSquare
    319  f92d
    320  f92d		       a9 09	   .next2     lda	#RAMBANK_BOARD
    321  f92f		       85 3e		      sta	SET_BANK_RAM
    322  f931
    323  f931		       ca	   .next      dex
    324  f932		       e0 16		      cpx	#22
    325  f934		       90 10		      bcc	.exit
    326  f936
    327  f936		       bd 84 f0 	      lda	Board,x
    328  f939		       f0 f6		      beq	.next
    329  f93b		       c9 ff		      cmp	#-1
    330  f93d		       f0 f2		      beq	.next
    331  f93f		       45 96		      eor	sideToMove
    332  f941		       30 ee		      bmi	.next
    333  f943
    334  f943		       4c e8 f0 	      jmp	handleIt
    335  f946
    336  f946
    337  f946				   .exit
    338  f946		       60		      rts
    339  f947
    340  f947
    341  f947
    342  f947
    343  f947							;---------------------------------------------------------------------------------------------------
    344  f947
      0  f947					      DEF	aiComputerMove
      1  f947				   BANK_aiComputerMove SET	_CURRENT_BANK
      2  f947				   aiComputerMove
      3  f947				   TEMPORARY_VAR SET	Overlay
      4  f947				   TEMPORARY_OFFSET SET	0
      5  f947				   VAR_BOUNDARY_aiComputerMove SET	TEMPORARY_OFFSET
      6  f947				   FUNCTION_NAME SET	aiComputerMove
      7  f947					      SUBROUTINE
    346  f947					      SUBROUTINE
    347  f947
      0  f947					      REFER	AiStateMachine
      1  f947				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f947				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f947					      ENDIF
      0  f947					      VEND	aiComputerMove
      1  f947				  -	      IFNCONST	aiComputerMove
      2  f947				  -	      ECHO	"Incorrect VEND label", aiComputerMove
      3  f947				  -	      ERR
      4  f947					      ENDIF
      5  f947		       00 a2	   VAREND_aiComputerMove =	TEMPORARY_VAR
    350  f947
    351  f947
    352  f947		       a9 0a		      lda	#RAMBANK_PLY
    353  f949		       85 95		      sta	currentPly
    354  f94b		       85 3e		      sta	SET_BANK_RAM	; switch in movelist
    355  f94d
    356  f94d		       a9 01		      lda	#1
    357  f94f		       85 4a		      sta	CTRLPF	; mirroring for thinkbars
    358  f951
    359  f951		       20 a1 f1 	      jsr	selectmove
    360  f954
    361  f954		       a9 00		      lda	#0
    362  f956		       85 4a		      sta	CTRLPF	; clear mirroring
    363  f958		       85 4e		      sta	PF1
    364  f95a		       85 4f		      sta	PF2
    365  f95c
      0  f95c					      lda@PLY	bestMove
      1  f95c		       ad 51 f1 	      lda	bestMove
    367  f95f		       10 17		      bpl	.notComputer
    368  f961
    369  f961							; Computer could not find a valid move. It's checkmate or stalemate. Find which...
    370  f961
      0  f961					      SWAP
      1  f961		       a5 96		      lda	sideToMove
      2  f963		       49 81		      eor	#SWAP_SIDE
      3  f965		       85 96		      sta	sideToMove
    372  f967		       20 07 f9 	      jsr	GenerateAllMoves
    373  f96a		       a5 9f		      lda	flagCheck
    374  f96c		       f0 05		      beq	.gameDrawn
    375  f96e
      0  f96e					      PHASE	AI_CheckMate
      1  f96e		       a9 23		      lda	#AI_CheckMate
      2  f970		       85 8c		      sta	aiState
    377  f972		       60		      rts
    378  f973
    379  f973
      0  f973				   .gameDrawn PHASE	AI_Draw
      1  f973		       a9 24		      lda	#AI_Draw
      2  f975		       85 8c		      sta	aiState
    381  f977		       60		      rts
    382  f978
    383  f978				   .notComputer
    384  f978
    385  f978
    386  f978		       a9 ff		      lda	#-1
    387  f97a		       85 88		      sta	cursorX12
    388  f97c
      0  f97c					      PHASE	AI_DelayAfterMove
      1  f97c		       a9 25		      lda	#AI_DelayAfterMove
      2  f97e		       85 8c		      sta	aiState
    390  f980		       60	   .halted    rts
    391  f981
    392  f981
    393  f981
    394  f981							;---------------------------------------------------------------------------------------------------
    395  f981
      0  f981					      DEF	AdjustMaterialPositionalValue
      1  f981				   BANK_AdjustMaterialPositionalValue SET	_CURRENT_BANK
      2  f981				   AdjustMaterialPositionalValue
      3  f981				   TEMPORARY_VAR SET	Overlay
      4  f981				   TEMPORARY_OFFSET SET	0
      5  f981				   VAR_BOUNDARY_AdjustMaterialPositionalValue SET	TEMPORARY_OFFSET
      6  f981				   FUNCTION_NAME SET	AdjustMaterialPositionalValue
      7  f981					      SUBROUTINE
    397  f981					      SUBROUTINE
    398  f981
    399  f981							; A move is about to be made, so  adjust material and positional values based on from/to and
    400  f981							; capture.
    401  f981
    402  f981							; First, nominate referencing subroutines so that local variables can be adjusted properly
    403  f981
      0  f981					      REFER	negaMax
      1  f981					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  f981				   TEMPORARY_VAR SET	VAREND_negaMax
      3  f981					      ENDIF
      0  f981					      REFER	MakeMove
      1  f981					      IF	VAREND_MakeMove > TEMPORARY_VAR
      2  f981				   TEMPORARY_VAR SET	VAREND_MakeMove
      3  f981					      ENDIF
      0  f981					      REFER	aiMoveIsSelected
      1  f981				  -	      IF	VAREND_aiMoveIsSelected > TEMPORARY_VAR
      2  f981				  -TEMPORARY_VAR SET	VAREND_aiMoveIsSelected
      3  f981					      ENDIF
      0  f981					      VAR	__originalPiece, 1
      1  f981		       00 b0	   __originalPiece =	TEMPORARY_VAR
      2  f981				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f981
      4  f981				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f981				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f981				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f981					      ENDIF
      8  f981				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f981				  -	      ECHO	"Temporary Variable", __originalPiece, "overflow!"
     10  f981				  -	      ERR
     11  f981					      ENDIF
     12  f981					      LIST	ON
      0  f981					      VAR	__capturedPiece, 1
      1  f981		       00 b1	   __capturedPiece =	TEMPORARY_VAR
      2  f981				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f981
      4  f981				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f981				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f981				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f981					      ENDIF
      8  f981				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f981				  -	      ECHO	"Temporary Variable", __capturedPiece, "overflow!"
     10  f981				  -	      ERR
     11  f981					      ENDIF
     12  f981					      LIST	ON
      0  f981					      VEND	AdjustMaterialPositionalValue
      1  f981				  -	      IFNCONST	AdjustMaterialPositionalValue
      2  f981				  -	      ECHO	"Incorrect VEND label", AdjustMaterialPositionalValue
      3  f981				  -	      ERR
      4  f981					      ENDIF
      5  f981		       00 b2	   VAREND_AdjustMaterialPositionalValue =	TEMPORARY_VAR
    410  f981
    411  f981							; fromPiece	 piece doing the move (promoted type)
    412  f981							; fromX12	 current square
    413  f981							; originX12	 starting square
    414  f981							; toX12	 ending square
    415  f981
    416  f981
    417  f981							; get the piece types from the board
    418  f981
    419  f981		       a9 09		      lda	#RAMBANK_BOARD
    420  f983		       85 3e		      sta	SET_BANK_RAM
    421  f985		       a4 87		      ldy	originX12
    422  f987		       b9 84 f0 	      lda	Board,y
    423  f98a		       85 b0		      sta	__originalPiece
    424  f98c		       a4 86		      ldy	toX12
    425  f98e		       b9 84 f0 	      lda	Board,y
    426  f991		       85 b1		      sta	__capturedPiece
    427  f993
    428  f993							; {
    429  f993							;   adjust the positional value  (originX12 --> fromX12)
    430  f993
    431  f993		       a9 17		      lda	#RAMBANK_BANK_EVAL	;BANK_AddPiecePositionValue
    432  f995		       85 3e		      sta	SET_BANK_RAM
    433  f997
    434  f997
    435  f997							;ldy toX12
    436  f997		       a5 97		      lda	fromPiece
    437  f999		       20 39 f0 	      jsr	AddPiecePositionValue	; add pos value for new position
    438  f99c
    439  f99c
    440  f99c		       a5 b0		      lda	__originalPiece
    441  f99e		       45 97		      eor	fromPiece	; the new piece
    442  f9a0		       29 0f		      and	#PIECE_MASK
    443  f9a2		       f0 05		      beq	.same1	; unchanged, so skip
    444  f9a4
    445  f9a4		       a5 97		      lda	fromPiece	; new piece
    446  f9a6							;and #PIECE_MASK
    447  f9a6							;tay
    448  f9a6		       20 26 f0 	      jsr	AddPieceMaterialValue
    449  f9a9
    450  f9a9				   .same1
    451  f9a9
    452  f9a9							; and now the 'subtracts'
    453  f9a9
      0  f9a9					      NEGEVAL
      1  f9a9
      2  f9a9		       38		      sec
      3  f9aa		       a9 00		      lda	#0
      4  f9ac		       e5 90		      sbc	Evaluation
      5  f9ae		       85 90		      sta	Evaluation
      6  f9b0		       a9 00		      lda	#0
      7  f9b2		       e5 91		      sbc	Evaluation+1
      8  f9b4		       85 91		      sta	Evaluation+1
    455  f9b6
    456  f9b6		       a4 87		      ldy	originX12
    457  f9b8		       a5 b0		      lda	__originalPiece
    458  f9ba		       20 39 f0 	      jsr	AddPiecePositionValue	; remove pos value for original position
    459  f9bd
    460  f9bd
    461  f9bd		       a5 b0		      lda	__originalPiece
    462  f9bf		       45 97		      eor	fromPiece	; the new piece
    463  f9c1		       29 0f		      and	#PIECE_MASK
    464  f9c3		       f0 05		      beq	.same2	; unchanged, so skip
    465  f9c5
    466  f9c5		       a5 b0		      lda	__originalPiece
    467  f9c7							;and #PIECE_MASK
    468  f9c7							;tay
    469  f9c7		       20 26 f0 	      jsr	AddPieceMaterialValue	; remove material for original type
    470  f9ca				   .same2
    471  f9ca
      0  f9ca					      NEGEVAL
      1  f9ca
      2  f9ca		       38		      sec
      3  f9cb		       a9 00		      lda	#0
      4  f9cd		       e5 90		      sbc	Evaluation
      5  f9cf		       85 90		      sta	Evaluation
      6  f9d1		       a9 00		      lda	#0
      7  f9d3		       e5 91		      sbc	Evaluation+1
      8  f9d5		       85 91		      sta	Evaluation+1
    473  f9d7
    474  f9d7							; If there's a capture, we adjust the material value
    475  f9d7
    476  f9d7							;		      lda __capturedPiece
    477  f9d7							;		      eor __originalPiece
    478  f9d7							;		      bpl .noCapture		      ; special-case capture rook castling onto king
    479  f9d7
    480  f9d7
    481  f9d7		       a5 b1		      lda	__capturedPiece
    482  f9d9		       29 0f		      and	#PIECE_MASK
    483  f9db		       f0 03		      beq	.noCapture
    484  f9dd							;tay
    485  f9dd		       20 26 f0 	      jsr	AddPieceMaterialValue	; -other colour = + my colour!
    486  f9e0				   .noCapture
    487  f9e0
    488  f9e0							; }
    489  f9e0		       a5 8b		      lda	savedBank
    490  f9e2		       85 3f		      sta	SET_BANK
    491  f9e4		       60		      rts
    492  f9e5
    493  f9e5
    494  f9e5							;---------------------------------------------------------------------------------------------------
    495  f9e5
      0  f9e5					      DEF	debug
      1  f9e5				   BANK_debug SET	_CURRENT_BANK
      2  f9e5				   debug
      3  f9e5				   TEMPORARY_VAR SET	Overlay
      4  f9e5				   TEMPORARY_OFFSET SET	0
      5  f9e5				   VAR_BOUNDARY_debug SET	TEMPORARY_OFFSET
      6  f9e5				   FUNCTION_NAME SET	debug
      7  f9e5					      SUBROUTINE
    497  f9e5					      SUBROUTINE
    498  f9e5
    499  f9e5							; Use this to trap breakpoints in "unknown" banks. Just "jsr debug" from wherever you want
    500  f9e5							; to catch the code, and put a breakpoint here instead. Then step, and you're at the place
    501  f9e5							; you wanted to see, without knowing the bank.
    502  f9e5
    503  f9e5		       60		      rts
    504  f9e6
    505  f9e6							;---------------------------------------------------------------------------------------------------
    506  f9e6
      0  f9e6					      DEF	aiSpecialMoveFixup
      1  f9e6				   BANK_aiSpecialMoveFixup SET	_CURRENT_BANK
      2  f9e6				   aiSpecialMoveFixup
      3  f9e6				   TEMPORARY_VAR SET	Overlay
      4  f9e6				   TEMPORARY_OFFSET SET	0
      5  f9e6				   VAR_BOUNDARY_aiSpecialMoveFixup SET	TEMPORARY_OFFSET
      6  f9e6				   FUNCTION_NAME SET	aiSpecialMoveFixup
      7  f9e6					      SUBROUTINE
    508  f9e6					      SUBROUTINE
    509  f9e6
      0  f9e6					      COMMON_VARS_ALPHABETA
      1  f9e6
      0  f9e6					      VAR	__thinkbar, 1
      1  f9e6		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  f9e6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f9e6
      4  f9e6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e6					      ENDIF
      8  f9e6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e6				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  f9e6				  -	      ERR
     11  f9e6					      ENDIF
     12  f9e6					      LIST	ON
      0  f9e6					      VAR	__toggle, 1
      1  f9e6		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  f9e6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f9e6
      4  f9e6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e6					      ENDIF
      8  f9e6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e6				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  f9e6				  -	      ERR
     11  f9e6					      ENDIF
     12  f9e6					      LIST	ON
      4  f9e6
      0  f9e6					      VAR	__bestMove, 1
      1  f9e6		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  f9e6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f9e6
      4  f9e6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e6					      ENDIF
      8  f9e6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e6				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  f9e6				  -	      ERR
     11  f9e6					      ENDIF
     12  f9e6					      LIST	ON
      0  f9e6					      VAR	__alpha, 2
      1  f9e6		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  f9e6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f9e6
      4  f9e6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e6					      ENDIF
      8  f9e6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e6				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  f9e6				  -	      ERR
     11  f9e6					      ENDIF
     12  f9e6					      LIST	ON
      0  f9e6					      VAR	__beta, 2
      1  f9e6		       00 a7	   __beta     =	TEMPORARY_VAR
      2  f9e6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f9e6
      4  f9e6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e6					      ENDIF
      8  f9e6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e6				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  f9e6				  -	      ERR
     11  f9e6					      ENDIF
     12  f9e6					      LIST	ON
      0  f9e6					      VAR	__negaMax, 2
      1  f9e6		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  f9e6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f9e6
      4  f9e6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e6					      ENDIF
      8  f9e6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e6				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  f9e6				  -	      ERR
     11  f9e6					      ENDIF
     12  f9e6					      LIST	ON
      0  f9e6					      VAR	__value, 2
      1  f9e6		       00 ab	   __value    =	TEMPORARY_VAR
      2  f9e6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  f9e6
      4  f9e6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e6					      ENDIF
      8  f9e6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e6				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  f9e6				  -	      ERR
     11  f9e6					      ENDIF
     12  f9e6					      LIST	ON
     10  f9e6
      0  f9e6					      VAR	__quiesceCapOnly, 1
      1  f9e6		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  f9e6				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  f9e6
      4  f9e6				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  f9e6				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  f9e6				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  f9e6					      ENDIF
      8  f9e6				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  f9e6				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  f9e6				  -	      ERR
     11  f9e6					      ENDIF
     12  f9e6					      LIST	ON
     12  f9e6
      0  f9e6					      REFER	AiStateMachine
      1  f9e6				  -	      IF	VAREND_AiStateMachine > TEMPORARY_VAR
      2  f9e6				  -TEMPORARY_VAR SET	VAREND_AiStateMachine
      3  f9e6					      ENDIF
      0  f9e6					      VEND	aiSpecialMoveFixup
      1  f9e6				  -	      IFNCONST	aiSpecialMoveFixup
      2  f9e6				  -	      ECHO	"Incorrect VEND label", aiSpecialMoveFixup
      3  f9e6				  -	      ERR
      4  f9e6					      ENDIF
      5  f9e6		       00 ae	   VAREND_aiSpecialMoveFixup =	TEMPORARY_VAR
    513  f9e6
    514  f9e6		       ad 84 02 	      lda	INTIM
    515  f9e9		       c9 2d		      cmp	#SPEEDOF_COPYSINGLEPIECE+4
    516  f9eb		       b0 01		      bcs	.cont
    517  f9ed		       60		      rts
    518  f9ee
    519  f9ee
    520  f9ee				   .cont
    521  f9ee
    522  f9ee
      0  f9ee					      PHASE	AI_DelayAfterPlaced
      1  f9ee		       a9 27		      lda	#AI_DelayAfterPlaced
      2  f9f0		       85 8c		      sta	aiState
    524  f9f2
    525  f9f2
    526  f9f2							; Special move fixup
    527  f9f2
    528  f9f2					      IF	ENPASSANT_ENABLED
    529  f9f2
    530  f9f2							; Handle en-passant captures
    531  f9f2							; The (dual-use) FLAG_ENPASSANT will have been cleared if it was set for a home-rank move
    532  f9f2							; but if we're here and the flag is still set, then it's an actual en-passant CAPTURE and we
    533  f9f2							; need to do the appropriate things...
    534  f9f2
    535  f9f2		       a9 01		      lda	#BANK_EnPassantCheck
    536  f9f4		       85 3f		      sta	SET_BANK
    537  f9f6		       20 00 f0 	      jsr	EnPassantCheck
    538  f9f9
    539  f9f9					      ENDIF
    540  f9f9
    541  f9f9
    542  f9f9		       a5 95		      lda	currentPly
    543  f9fb		       85 3e		      sta	SET_BANK_RAM
    544  f9fd		       20 1b f2 	      jsr	CastleFixupDraw
    545  fa00
    546  fa00		       a5 85		      lda	fromX12
    547  fa02		       85 80		      sta	squareToDraw
    548  fa04
    549  fa04		       60		      rts
    550  fa05
    551  fa05
    552  fa05							;---------------------------------------------------------------------------------------------------
    553  fa05
------- FILE Handler_PAWN.asm LEVEL 3 PASS 5
      0  fa05					      include	"Handler_PAWN.asm"
      1  fa05							; Copyright (C)2020 Andrew Davie
      2  fa05							; Pawn move handlers
      3  fa05
      4  fa05							;---------------------------------------------------------------------------------------------------
      5  fa05							; WHITE PAWN
      6  fa05							;---------------------------------------------------------------------------------------------------
      7  fa05
      8  fa05		       00 28	   WHITE_HOME_ROW =	40	; < this, on home row
      9  fa05		       00 52	   BLACK_HOME_ROW =	82	; >= this, on home row
     10  fa05
     11  fa05							;---------------------------------------------------------------------------------------------------
     12  fa05
     13  fa05					      MAC	en_passant
     14  fa05					      SUBROUTINE
     15  fa05							; {1} = _LEFT or _RIGHT
     16  fa05
     17  fa05					      ldx	currentSquare
     18  fa05					      ldy	ValidSquare+{1},x
     19  fa05					      cpy	enPassantPawn
     20  fa05					      bne	.invalid
     21  fa05					      ldy	ValidSquare+{1}+{2},x	; en-passant endpoint must be blank
     22  fa05					      lda	Board,y
     23  fa05					      bne	.invalid
     24  fa05					      jsr	AddMove	; the MOVE will need to deal with the details of en-passant??
     25  fa05				   .invalid
     26  fa05					      ENDM
     27  fa05
     28  fa05							;---------------------------------------------------------------------------------------------------
     29  fa05
     30  fa05					      MAC	promote_pawn
     31  fa05							;SUBROUTINE
     32  fa05
     33  fa05							;{1} = BLACK or WHITE
     34  fa05
     35  fa05
     36  fa05					      sty	__temp
     37  fa05					      lda	#{1}|QUEEN
     38  fa05					      sta	currentPiece
     39  fa05					      jsr	AddMove
     40  fa05
     41  fa05					      lda	#{1}|ROOK
     42  fa05					      sta	currentPiece
     43  fa05					      ldy	__temp
     44  fa05					      jsr	AddMove
     45  fa05
     46  fa05					      lda	#{1}|BISHOP
     47  fa05					      sta	currentPiece
     48  fa05					      ldy	__temp
     49  fa05					      jsr	AddMove
     50  fa05
     51  fa05					      lda	#{1}|KNIGHT
     52  fa05					      sta	currentPiece
     53  fa05					      ldy	__temp
     54  fa05					      jsr	AddMove
     55  fa05
     56  fa05					      IF	{1} = WHITE
     57  fa05					      lda	#WHITE|WP
     58  fa05					      ENDIF
     59  fa05					      IF	{1} = BLACK
     60  fa05					      lda	#BLACK|BP
     61  fa05					      ENDIF
     62  fa05					      sta	currentPiece
     63  fa05					      ENDM
     64  fa05
     65  fa05							;---------------------------------------------------------------------------------------------------
     66  fa05
     67  fa05					      MAC	move_or_promote_pawn
     68  fa05							;SUBROUTINE
     69  fa05							; {1} = BLACK or WHITE
     70  fa05
     71  fa05					      IF	{1} = WHITE
     72  fa05					      cpy	#90	; last rank?
     73  fa05					      bcc	.standard
     74  fa05					      jsr	PromoteWhitePawn
     75  fa05					      jmp	.pMoved
     76  fa05					      ENDIF
     77  fa05
     78  fa05					      IF	{1} = BLACK
     79  fa05					      cpy	#30	; last rank?
     80  fa05					      bcs	.standard
     81  fa05					      jsr	PromoteBlackPawn
     82  fa05					      jmp	.pMoved
     83  fa05					      ENDIF
     84  fa05
     85  fa05				   .standard  jsr	AddMove	; add +1UP move
     86  fa05				   .pMoved
     87  fa05
     88  fa05					      ENDM
     89  fa05
     90  fa05							;---------------------------------------------------------------------------------------------------
     91  fa05
     92  fa05					      MAC	take
     93  fa05							;SUBROUTINE
     94  fa05							; {1} = capture square offset
     95  fa05
     96  fa05					      ldx	currentSquare
     97  fa05					      ldy	ValidSquare+{1},x
     98  fa05					      bmi	.invalid2
     99  fa05					      lda	Board,y
    100  fa05					      beq	.invalid2	; square empty
    101  fa05					      sta	capture
    102  fa05					      eor	currentPiece
    103  fa05					      bpl	.invalid	; same colour
    104  fa05
    105  fa05					      MOVE_OR_PROMOTE_PAWN	{2}
    106  fa05
    107  fa05					      jmp	.invalid2
    108  fa05				   .invalid   inc	protecting
    109  fa05				   .invalid2
    110  fa05					      ENDM
    111  fa05
    112  fa05							;---------------------------------------------------------------------------------------------------
    113  fa05
      0  fa05					      DEF	PromoteWhitePawn
      1  fa05				   BANK_PromoteWhitePawn SET	_CURRENT_BANK
      2  fa05				   PromoteWhitePawn
      3  fa05				   TEMPORARY_VAR SET	Overlay
      4  fa05				   TEMPORARY_OFFSET SET	0
      5  fa05				   VAR_BOUNDARY_PromoteWhitePawn SET	TEMPORARY_OFFSET
      6  fa05				   FUNCTION_NAME SET	PromoteWhitePawn
      7  fa05					      SUBROUTINE
    115  fa05					      SUBROUTINE
    116  fa05
      0  fa05					      REFER	Handle_WHITE_PAWN
      1  fa05					      IF	VAREND_Handle_WHITE_PAWN > TEMPORARY_VAR
      2  fa05				   TEMPORARY_VAR SET	VAREND_Handle_WHITE_PAWN
      3  fa05					      ENDIF
      0  fa05					      VAR	__temp, 1
      1  fa05		       00 b3	   __temp     =	TEMPORARY_VAR
      2  fa05				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fa05
      4  fa05				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fa05				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fa05				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fa05					      ENDIF
      8  fa05				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fa05				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  fa05				  -	      ERR
     11  fa05					      ENDIF
     12  fa05					      LIST	ON
      0  fa05					      VEND	PromoteWhitePawn
      1  fa05				  -	      IFNCONST	PromoteWhitePawn
      2  fa05				  -	      ECHO	"Incorrect VEND label", PromoteWhitePawn
      3  fa05				  -	      ERR
      4  fa05					      ENDIF
      5  fa05		       00 b4	   VAREND_PromoteWhitePawn =	TEMPORARY_VAR
    120  fa05
      0  fa05					      PROMOTE_PAWN	WHITE
      1  fa05
      2  fa05
      3  fa05
      4  fa05
      5  fa05
      6  fa05		       84 b3		      sty	__temp
      7  fa07		       a9 06		      lda	#WHITE|QUEEN
      8  fa09		       85 92		      sta	currentPiece
      9  fa0b		       20 56 fc 	      jsr	AddMove
     10  fa0e
     11  fa0e		       a9 05		      lda	#WHITE|ROOK
     12  fa10		       85 92		      sta	currentPiece
     13  fa12		       a4 b3		      ldy	__temp
     14  fa14		       20 56 fc 	      jsr	AddMove
     15  fa17
     16  fa17		       a9 04		      lda	#WHITE|BISHOP
     17  fa19		       85 92		      sta	currentPiece
     18  fa1b		       a4 b3		      ldy	__temp
     19  fa1d		       20 56 fc 	      jsr	AddMove
     20  fa20
     21  fa20		       a9 03		      lda	#WHITE|KNIGHT
     22  fa22		       85 92		      sta	currentPiece
     23  fa24		       a4 b3		      ldy	__temp
     24  fa26		       20 56 fc 	      jsr	AddMove
     25  fa29
     26  fa29					      IF	WHITE = WHITE
     27  fa29		       a9 01		      lda	#WHITE|WP
     28  fa2b					      ENDIF
     29  fa2b				  -	      IF	WHITE = BLACK
     30  fa2b				  -	      lda	#BLACK|BP
     31  fa2b					      ENDIF
     32  fa2b		       85 92		      sta	currentPiece
    122  fa2d		       60		      rts
    123  fa2e
    124  fa2e							;---------------------------------------------------------------------------------------------------
    125  fa2e
      0  fa2e					      DEF	Handle_WHITE_PAWN
      1  fa2e				   BANK_Handle_WHITE_PAWN SET	_CURRENT_BANK
      2  fa2e				   Handle_WHITE_PAWN
      3  fa2e				   TEMPORARY_VAR SET	Overlay
      4  fa2e				   TEMPORARY_OFFSET SET	0
      5  fa2e				   VAR_BOUNDARY_Handle_WHITE_PAWN SET	TEMPORARY_OFFSET
      6  fa2e				   FUNCTION_NAME SET	Handle_WHITE_PAWN
      7  fa2e					      SUBROUTINE
    127  fa2e					      SUBROUTINE
    128  fa2e
      0  fa2e					      REFER	GenerateAllMoves
      1  fa2e					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  fa2e				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  fa2e					      ENDIF
      0  fa2e					      VEND	Handle_WHITE_PAWN
      1  fa2e				  -	      IFNCONST	Handle_WHITE_PAWN
      2  fa2e				  -	      ECHO	"Incorrect VEND label", Handle_WHITE_PAWN
      3  fa2e				  -	      ERR
      4  fa2e					      ENDIF
      5  fa2e		       00 b3	   VAREND_Handle_WHITE_PAWN =	TEMPORARY_VAR
    131  fa2e
    132  fa2e		       bc 2a f0 	      ldy	ValidSquare+_UP,x	; square above must be blank (WILL NOT EVER be off-board!)
    133  fa31		       b9 84 f0 	      lda	Board,y
    134  fa34		       d0 26		      bne	.pMoved	; occupied
    135  fa36		       85 9e		      sta	capture
    136  fa38
    137  fa38							; we may need to promote the pawn
    138  fa38							; All possibilites (Q/R/B/N) are added as individual moves
    139  fa38
      0  fa38					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  fa38
      2  fa38
      3  fa38
      4  fa38					      IF	WHITE = WHITE
      5  fa38		       c0 5a		      cpy	#90
      6  fa3a		       90 06		      bcc	.standard
      7  fa3c		       20 05 fa 	      jsr	PromoteWhitePawn
      8  fa3f		       4c 45 fa 	      jmp	.pMoved
      9  fa42					      ENDIF
     10  fa42
     11  fa42				  -	      IF	WHITE = BLACK
     12  fa42				  -	      cpy	#30
     13  fa42				  -	      bcs	.standard
     14  fa42				  -	      jsr	PromoteBlackPawn
     15  fa42				  -	      jmp	.pMoved
     16  fa42					      ENDIF
     17  fa42
     18  fa42		       20 56 fc    .standard  jsr	AddMove
     19  fa45				   .pMoved
     20  fa45
    141  fa45
    142  fa45							; the +2 move off the home rank...
    143  fa45
    144  fa45		       a6 93		      ldx	currentSquare
    145  fa47		       e0 28		      cpx	#WHITE_HOME_ROW
    146  fa49		       b0 11		      bcs	.pMoved	; pawn has moved so can't do +2
    147  fa4b		       bc 34 f0 	      ldy	ValidSquare+_UP+_UP,x	; WILL be a valid square
    148  fa4e		       b9 84 f0 	      lda	Board,y
    149  fa51		       d0 09		      bne	.pMoved	; destination square occupied
    150  fa53
    151  fa53		       a5 92		      lda	currentPiece
    152  fa55		       09 20		      ora	#FLAG_ENPASSANT
    153  fa57		       85 92		      sta	currentPiece	; GENERATE en-passant opportunity
    154  fa59
    155  fa59		       20 56 fc 	      jsr	AddMove	; add the +2UP move off home row
    156  fa5c
    157  fa5c				   .pMoved
    158  fa5c
    159  fa5c							; regular captures...
    160  fa5c
      0  fa5c					      TAKE	_UP+_LEFT, WHITE
      1  fa5c
      2  fa5c
      3  fa5c
      4  fa5c		       a6 93		      ldx	currentSquare
      5  fa5e		       bc 29 f0 	      ldy	ValidSquare+_UP+_LEFT,x
      6  fa61		       30 1d		      bmi	.invalid2
      7  fa63		       b9 84 f0 	      lda	Board,y
      8  fa66		       f0 18		      beq	.invalid2
      9  fa68		       85 9e		      sta	capture
     10  fa6a		       45 92		      eor	currentPiece
     11  fa6c		       10 10		      bpl	.invalid
     12  fa6e
      0  fa6e					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  fa6e
      2  fa6e
      3  fa6e
      4  fa6e					      IF	WHITE = WHITE
      5  fa6e		       c0 5a		      cpy	#90
      6  fa70		       90 06		      bcc	.standard
      7  fa72		       20 05 fa 	      jsr	PromoteWhitePawn
      8  fa75		       4c 7b fa 	      jmp	.pMoved
      9  fa78					      ENDIF
     10  fa78
     11  fa78				  -	      IF	WHITE = BLACK
     12  fa78				  -	      cpy	#30
     13  fa78				  -	      bcs	.standard
     14  fa78				  -	      jsr	PromoteBlackPawn
     15  fa78				  -	      jmp	.pMoved
     16  fa78					      ENDIF
     17  fa78
     18  fa78		       20 56 fc    .standard  jsr	AddMove
     19  fa7b				   .pMoved
     20  fa7b
     14  fa7b
     15  fa7b		       4c 80 fa 	      jmp	.invalid2
     16  fa7e		       e6 a0	   .invalid   inc	protecting
     17  fa80				   .invalid2
      0  fa80					      TAKE	_UP+_RIGHT, WHITE
      1  fa80
      2  fa80
      3  fa80
      4  fa80		       a6 93		      ldx	currentSquare
      5  fa82		       bc 2b f0 	      ldy	ValidSquare+_UP+_RIGHT,x
      6  fa85		       30 1d		      bmi	.invalid2
      7  fa87		       b9 84 f0 	      lda	Board,y
      8  fa8a		       f0 18		      beq	.invalid2
      9  fa8c		       85 9e		      sta	capture
     10  fa8e		       45 92		      eor	currentPiece
     11  fa90		       10 10		      bpl	.invalid
     12  fa92
      0  fa92					      MOVE_OR_PROMOTE_PAWN	WHITE
      1  fa92
      2  fa92
      3  fa92
      4  fa92					      IF	WHITE = WHITE
      5  fa92		       c0 5a		      cpy	#90
      6  fa94		       90 06		      bcc	.standard
      7  fa96		       20 05 fa 	      jsr	PromoteWhitePawn
      8  fa99		       4c 9f fa 	      jmp	.pMoved
      9  fa9c					      ENDIF
     10  fa9c
     11  fa9c				  -	      IF	WHITE = BLACK
     12  fa9c				  -	      cpy	#30
     13  fa9c				  -	      bcs	.standard
     14  fa9c				  -	      jsr	PromoteBlackPawn
     15  fa9c				  -	      jmp	.pMoved
     16  fa9c					      ENDIF
     17  fa9c
     18  fa9c		       20 56 fc    .standard  jsr	AddMove
     19  fa9f				   .pMoved
     20  fa9f
     14  fa9f
     15  fa9f		       4c a4 fa 	      jmp	.invalid2
     16  faa2		       e6 a0	   .invalid   inc	protecting
     17  faa4				   .invalid2
    163  faa4
    164  faa4
    165  faa4					      IF	ENPASSANT_ENABLED
    166  faa4							; en-passant captures...
    167  faa4
    168  faa4		       a5 94		      lda	enPassantPawn
    169  faa6		       f0 2e		      beq	.noEnPassant	; previous move (opponent) enpassant square?
    170  faa8
    171  faa8		       a5 92		      lda	currentPiece
    172  faaa		       09 20		      ora	#FLAG_ENPASSANT
    173  faac		       85 92		      sta	currentPiece	; CONSUME en-passant opportunity
    174  faae
      0  faae					      EN_PASSANT	_LEFT, _UP
      1  faae					      SUBROUTINE
      2  faae
      3  faae
      4  faae		       a6 93		      ldx	currentSquare
      5  fab0		       bc 1f f0 	      ldy	ValidSquare+_LEFT,x
      6  fab3		       c4 94		      cpy	enPassantPawn
      7  fab5		       d0 0b		      bne	.invalid
      8  fab7		       bc 29 f0 	      ldy	ValidSquare+_LEFT+_UP,x
      9  faba		       b9 84 f0 	      lda	Board,y
     10  fabd		       d0 03		      bne	.invalid
     11  fabf		       20 56 fc 	      jsr	AddMove
     12  fac2				   .invalid
      0  fac2					      EN_PASSANT	_RIGHT, _UP
      1  fac2					      SUBROUTINE
      2  fac2
      3  fac2
      4  fac2		       a6 93		      ldx	currentSquare
      5  fac4		       bc 21 f0 	      ldy	ValidSquare+_RIGHT,x
      6  fac7		       c4 94		      cpy	enPassantPawn
      7  fac9		       d0 0b		      bne	.invalid
      8  facb		       bc 2b f0 	      ldy	ValidSquare+_RIGHT+_UP,x
      9  face		       b9 84 f0 	      lda	Board,y
     10  fad1		       d0 03		      bne	.invalid
     11  fad3		       20 56 fc 	      jsr	AddMove
     12  fad6				   .invalid
    177  fad6
    178  fad6				   .noEnPassant
    179  fad6					      ENDIF
    180  fad6
    181  fad6		       4c 2b f9 	      jmp	MoveReturn
    182  fad9
    183  fad9
    184  fad9							;---------------------------------------------------------------------------------------------------
    185  fad9							; BLACK PAWN
    186  fad9							;---------------------------------------------------------------------------------------------------
    187  fad9
      0  fad9					      DEF	PromoteBlackPawn
      1  fad9				   BANK_PromoteBlackPawn SET	_CURRENT_BANK
      2  fad9				   PromoteBlackPawn
      3  fad9				   TEMPORARY_VAR SET	Overlay
      4  fad9				   TEMPORARY_OFFSET SET	0
      5  fad9				   VAR_BOUNDARY_PromoteBlackPawn SET	TEMPORARY_OFFSET
      6  fad9				   FUNCTION_NAME SET	PromoteBlackPawn
      7  fad9					      SUBROUTINE
    189  fad9					      SUBROUTINE
    190  fad9
      0  fad9					      REFER	Handle_BLACK_PAWN
      1  fad9					      IF	VAREND_Handle_BLACK_PAWN > TEMPORARY_VAR
      2  fad9				   TEMPORARY_VAR SET	VAREND_Handle_BLACK_PAWN
      3  fad9					      ENDIF
      0  fad9					      VAR	__temp, 1
      1  fad9		       00 b3	   __temp     =	TEMPORARY_VAR
      2  fad9				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fad9
      4  fad9				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fad9				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fad9				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fad9					      ENDIF
      8  fad9				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fad9				  -	      ECHO	"Temporary Variable", __temp, "overflow!"
     10  fad9				  -	      ERR
     11  fad9					      ENDIF
     12  fad9					      LIST	ON
      0  fad9					      VEND	PromoteBlackPawn
      1  fad9				  -	      IFNCONST	PromoteBlackPawn
      2  fad9				  -	      ECHO	"Incorrect VEND label", PromoteBlackPawn
      3  fad9				  -	      ERR
      4  fad9					      ENDIF
      5  fad9		       00 b4	   VAREND_PromoteBlackPawn =	TEMPORARY_VAR
    194  fad9
      0  fad9					      PROMOTE_PAWN	BLACK
      1  fad9
      2  fad9
      3  fad9
      4  fad9
      5  fad9
      6  fad9		       84 b3		      sty	__temp
      7  fadb		       a9 86		      lda	#BLACK|QUEEN
      8  fadd		       85 92		      sta	currentPiece
      9  fadf		       20 56 fc 	      jsr	AddMove
     10  fae2
     11  fae2		       a9 85		      lda	#BLACK|ROOK
     12  fae4		       85 92		      sta	currentPiece
     13  fae6		       a4 b3		      ldy	__temp
     14  fae8		       20 56 fc 	      jsr	AddMove
     15  faeb
     16  faeb		       a9 84		      lda	#BLACK|BISHOP
     17  faed		       85 92		      sta	currentPiece
     18  faef		       a4 b3		      ldy	__temp
     19  faf1		       20 56 fc 	      jsr	AddMove
     20  faf4
     21  faf4		       a9 83		      lda	#BLACK|KNIGHT
     22  faf6		       85 92		      sta	currentPiece
     23  faf8		       a4 b3		      ldy	__temp
     24  fafa		       20 56 fc 	      jsr	AddMove
     25  fafd
     26  fafd				  -	      IF	BLACK = WHITE
     27  fafd				  -	      lda	#WHITE|WP
     28  fafd					      ENDIF
     29  fafd					      IF	BLACK = BLACK
     30  fafd		       a9 82		      lda	#BLACK|BP
     31  faff					      ENDIF
     32  faff		       85 92		      sta	currentPiece
    196  fb01		       60		      rts
    197  fb02
      0  fb02					      DEF	Handle_BLACK_PAWN
      1  fb02				   BANK_Handle_BLACK_PAWN SET	_CURRENT_BANK
      2  fb02				   Handle_BLACK_PAWN
      3  fb02				   TEMPORARY_VAR SET	Overlay
      4  fb02				   TEMPORARY_OFFSET SET	0
      5  fb02				   VAR_BOUNDARY_Handle_BLACK_PAWN SET	TEMPORARY_OFFSET
      6  fb02				   FUNCTION_NAME SET	Handle_BLACK_PAWN
      7  fb02					      SUBROUTINE
    199  fb02					      SUBROUTINE
    200  fb02
      0  fb02					      REFER	GenerateAllMoves
      1  fb02					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  fb02				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  fb02					      ENDIF
      0  fb02					      VEND	Handle_BLACK_PAWN
      1  fb02				  -	      IFNCONST	Handle_BLACK_PAWN
      2  fb02				  -	      ECHO	"Incorrect VEND label", Handle_BLACK_PAWN
      3  fb02				  -	      ERR
      4  fb02					      ENDIF
      5  fb02		       00 b3	   VAREND_Handle_BLACK_PAWN =	TEMPORARY_VAR
    203  fb02
    204  fb02		       bc 16 f0 	      ldy	ValidSquare+_DOWN,x	; square below must be blank (WILL NOT EVER be off-board!)
    205  fb05		       b9 84 f0 	      lda	Board,y
    206  fb08		       d0 26		      bne	.pMoved	; occupied
    207  fb0a		       85 9e		      sta	capture
    208  fb0c
    209  fb0c							; we may need to promote the pawn
    210  fb0c							; All possibilites (Q/R/B/N) are added as individual moves
    211  fb0c
      0  fb0c					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  fb0c
      2  fb0c
      3  fb0c
      4  fb0c				  -	      IF	BLACK = WHITE
      5  fb0c				  -	      cpy	#90
      6  fb0c				  -	      bcc	.standard
      7  fb0c				  -	      jsr	PromoteWhitePawn
      8  fb0c				  -	      jmp	.pMoved
      9  fb0c					      ENDIF
     10  fb0c
     11  fb0c					      IF	BLACK = BLACK
     12  fb0c		       c0 1e		      cpy	#30
     13  fb0e		       b0 06		      bcs	.standard
     14  fb10		       20 d9 fa 	      jsr	PromoteBlackPawn
     15  fb13		       4c 19 fb 	      jmp	.pMoved
     16  fb16					      ENDIF
     17  fb16
     18  fb16		       20 56 fc    .standard  jsr	AddMove
     19  fb19				   .pMoved
     20  fb19
    213  fb19
    214  fb19							; the +2 move off the home rank...
    215  fb19
    216  fb19		       a6 93		      ldx	currentSquare
    217  fb1b		       e0 52		      cpx	#BLACK_HOME_ROW
    218  fb1d		       90 11		      bcc	.pMoved	; pawn has moved so can't do +2
    219  fb1f
    220  fb1f
    221  fb1f		       bc 0c f0 	      ldy	ValidSquare+_DOWN+_DOWN,x	; WILL be a valid square
    222  fb22		       b9 84 f0 	      lda	Board,y
    223  fb25		       d0 09		      bne	.pMoved	; destination square occupied
    224  fb27
    225  fb27		       a5 92		      lda	currentPiece
    226  fb29		       09 20		      ora	#FLAG_ENPASSANT
    227  fb2b		       85 92		      sta	currentPiece	; CAN en-passant
    228  fb2d
    229  fb2d		       20 56 fc 	      jsr	AddMove	; add the +2DOWN move off home row
    230  fb30
    231  fb30				   .pMoved
    232  fb30
    233  fb30							; regular captures... (with promotion)
    234  fb30
      0  fb30					      TAKE	_DOWN+_LEFT, BLACK
      1  fb30
      2  fb30
      3  fb30
      4  fb30		       a6 93		      ldx	currentSquare
      5  fb32		       bc 15 f0 	      ldy	ValidSquare+_DOWN+_LEFT,x
      6  fb35		       30 1d		      bmi	.invalid2
      7  fb37		       b9 84 f0 	      lda	Board,y
      8  fb3a		       f0 18		      beq	.invalid2
      9  fb3c		       85 9e		      sta	capture
     10  fb3e		       45 92		      eor	currentPiece
     11  fb40		       10 10		      bpl	.invalid
     12  fb42
      0  fb42					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  fb42
      2  fb42
      3  fb42
      4  fb42				  -	      IF	BLACK = WHITE
      5  fb42				  -	      cpy	#90
      6  fb42				  -	      bcc	.standard
      7  fb42				  -	      jsr	PromoteWhitePawn
      8  fb42				  -	      jmp	.pMoved
      9  fb42					      ENDIF
     10  fb42
     11  fb42					      IF	BLACK = BLACK
     12  fb42		       c0 1e		      cpy	#30
     13  fb44		       b0 06		      bcs	.standard
     14  fb46		       20 d9 fa 	      jsr	PromoteBlackPawn
     15  fb49		       4c 4f fb 	      jmp	.pMoved
     16  fb4c					      ENDIF
     17  fb4c
     18  fb4c		       20 56 fc    .standard  jsr	AddMove
     19  fb4f				   .pMoved
     20  fb4f
     14  fb4f
     15  fb4f		       4c 54 fb 	      jmp	.invalid2
     16  fb52		       e6 a0	   .invalid   inc	protecting
     17  fb54				   .invalid2
      0  fb54					      TAKE	_DOWN+_RIGHT, BLACK
      1  fb54
      2  fb54
      3  fb54
      4  fb54		       a6 93		      ldx	currentSquare
      5  fb56		       bc 17 f0 	      ldy	ValidSquare+_DOWN+_RIGHT,x
      6  fb59		       30 1d		      bmi	.invalid2
      7  fb5b		       b9 84 f0 	      lda	Board,y
      8  fb5e		       f0 18		      beq	.invalid2
      9  fb60		       85 9e		      sta	capture
     10  fb62		       45 92		      eor	currentPiece
     11  fb64		       10 10		      bpl	.invalid
     12  fb66
      0  fb66					      MOVE_OR_PROMOTE_PAWN	BLACK
      1  fb66
      2  fb66
      3  fb66
      4  fb66				  -	      IF	BLACK = WHITE
      5  fb66				  -	      cpy	#90
      6  fb66				  -	      bcc	.standard
      7  fb66				  -	      jsr	PromoteWhitePawn
      8  fb66				  -	      jmp	.pMoved
      9  fb66					      ENDIF
     10  fb66
     11  fb66					      IF	BLACK = BLACK
     12  fb66		       c0 1e		      cpy	#30
     13  fb68		       b0 06		      bcs	.standard
     14  fb6a		       20 d9 fa 	      jsr	PromoteBlackPawn
     15  fb6d		       4c 73 fb 	      jmp	.pMoved
     16  fb70					      ENDIF
     17  fb70
     18  fb70		       20 56 fc    .standard  jsr	AddMove
     19  fb73				   .pMoved
     20  fb73
     14  fb73
     15  fb73		       4c 78 fb 	      jmp	.invalid2
     16  fb76		       e6 a0	   .invalid   inc	protecting
     17  fb78				   .invalid2
    237  fb78
    238  fb78
    239  fb78					      IF	ENPASSANT_ENABLED
    240  fb78							; en-passant captures...
    241  fb78
    242  fb78		       a5 94		      lda	enPassantPawn
    243  fb7a		       f0 2e		      beq	.noEnPassant	; was last move en-passantable?
    244  fb7c
    245  fb7c		       a5 92		      lda	currentPiece
    246  fb7e		       09 20		      ora	#FLAG_ENPASSANT
    247  fb80		       85 92		      sta	currentPiece	; any en-passant move added will have flag set
    248  fb82
      0  fb82					      EN_PASSANT	_LEFT, _DOWN
      1  fb82					      SUBROUTINE
      2  fb82
      3  fb82
      4  fb82		       a6 93		      ldx	currentSquare
      5  fb84		       bc 1f f0 	      ldy	ValidSquare+_LEFT,x
      6  fb87		       c4 94		      cpy	enPassantPawn
      7  fb89		       d0 0b		      bne	.invalid
      8  fb8b		       bc 15 f0 	      ldy	ValidSquare+_LEFT+_DOWN,x
      9  fb8e		       b9 84 f0 	      lda	Board,y
     10  fb91		       d0 03		      bne	.invalid
     11  fb93		       20 56 fc 	      jsr	AddMove
     12  fb96				   .invalid
      0  fb96					      EN_PASSANT	_RIGHT, _DOWN
      1  fb96					      SUBROUTINE
      2  fb96
      3  fb96
      4  fb96		       a6 93		      ldx	currentSquare
      5  fb98		       bc 21 f0 	      ldy	ValidSquare+_RIGHT,x
      6  fb9b		       c4 94		      cpy	enPassantPawn
      7  fb9d		       d0 0b		      bne	.invalid
      8  fb9f		       bc 17 f0 	      ldy	ValidSquare+_RIGHT+_DOWN,x
      9  fba2		       b9 84 f0 	      lda	Board,y
     10  fba5		       d0 03		      bne	.invalid
     11  fba7		       20 56 fc 	      jsr	AddMove
     12  fbaa				   .invalid
    251  fbaa
    252  fbaa				   .noEnPassant
    253  fbaa					      ENDIF
    254  fbaa
    255  fbaa		       4c 2b f9 	      jmp	MoveReturn
    256  fbad
    257  fbad							; EOF
------- FILE BANK_FIXED.asm
------- FILE Handler_KNIGHT.asm LEVEL 3 PASS 5
      0  fbad					      include	"Handler_KNIGHT.asm"
      1  fbad							; Copyright (C)2020 Andrew Davie
      2  fbad							; Knight move handler
      3  fbad
      4  fbad							;---------------------------------------------------------------------------------------------------
      5  fbad							; KNIGHT
      6  fbad							;---------------------------------------------------------------------------------------------------
      7  fbad
      0  fbad					      DEF	Handle_KNIGHT
      1  fbad				   BANK_Handle_KNIGHT SET	_CURRENT_BANK
      2  fbad				   Handle_KNIGHT
      3  fbad				   TEMPORARY_VAR SET	Overlay
      4  fbad				   TEMPORARY_OFFSET SET	0
      5  fbad				   VAR_BOUNDARY_Handle_KNIGHT SET	TEMPORARY_OFFSET
      6  fbad				   FUNCTION_NAME SET	Handle_KNIGHT
      7  fbad					      SUBROUTINE
      9  fbad					      SUBROUTINE
     10  fbad
      0  fbad					      REFER	GenerateAllMoves
      1  fbad					      IF	VAREND_GenerateAllMoves > TEMPORARY_VAR
      2  fbad				   TEMPORARY_VAR SET	VAREND_GenerateAllMoves
      3  fbad					      ENDIF
      0  fbad					      VEND	Handle_KNIGHT
      1  fbad				  -	      IFNCONST	Handle_KNIGHT
      2  fbad				  -	      ECHO	"Incorrect VEND label", Handle_KNIGHT
      3  fbad				  -	      ERR
      4  fbad					      ENDIF
      5  fbad		       00 b3	   VAREND_Handle_KNIGHT =	TEMPORARY_VAR
     13  fbad
     14  fbad							; x = currentSquare (square the piece is on)
     15  fbad							; currentPiece (with flags/colour attached)
     16  fbad
      0  fbad					      MOVE_TO	_DOWN+_DOWN+_LEFT
      1  fbad					      SUBROUTINE
      2  fbad		       bc 0b f0 	      ldy	ValidSquare+_DOWN+_DOWN+_LEFT,x
      3  fbb0		       30 0e		      bmi	.invalid
      4  fbb2		       b9 84 f0 	      lda	Board,y
      5  fbb5		       85 9e		      sta	capture
      6  fbb7		       f0 04		      beq	.squareEmpty
      7  fbb9		       45 92		      eor	currentPiece
      8  fbbb		       10 03		      bpl	.invalid
      9  fbbd		       20 56 fc    .squareEmpty jsr	AddMove
     10  fbc0				   .invalid
      0  fbc0					      MOVE_TO_X	_DOWN+_DOWN+_RIGHT
      1  fbc0		       a6 93		      ldx	currentSquare
      0  fbc2					      MOVE_TO	_DOWN+_DOWN+_RIGHT
      1  fbc2					      SUBROUTINE
      2  fbc2		       bc 0d f0 	      ldy	ValidSquare+_DOWN+_DOWN+_RIGHT,x
      3  fbc5		       30 0e		      bmi	.invalid
      4  fbc7		       b9 84 f0 	      lda	Board,y
      5  fbca		       85 9e		      sta	capture
      6  fbcc		       f0 04		      beq	.squareEmpty
      7  fbce		       45 92		      eor	currentPiece
      8  fbd0		       10 03		      bpl	.invalid
      9  fbd2		       20 56 fc    .squareEmpty jsr	AddMove
     10  fbd5				   .invalid
      0  fbd5					      MOVE_TO_X	_UP+_UP+_LEFT
      1  fbd5		       a6 93		      ldx	currentSquare
      0  fbd7					      MOVE_TO	_UP+_UP+_LEFT
      1  fbd7					      SUBROUTINE
      2  fbd7		       bc 33 f0 	      ldy	ValidSquare+_UP+_UP+_LEFT,x
      3  fbda		       30 0e		      bmi	.invalid
      4  fbdc		       b9 84 f0 	      lda	Board,y
      5  fbdf		       85 9e		      sta	capture
      6  fbe1		       f0 04		      beq	.squareEmpty
      7  fbe3		       45 92		      eor	currentPiece
      8  fbe5		       10 03		      bpl	.invalid
      9  fbe7		       20 56 fc    .squareEmpty jsr	AddMove
     10  fbea				   .invalid
      0  fbea					      MOVE_TO_X	_UP+_UP+_RIGHT
      1  fbea		       a6 93		      ldx	currentSquare
      0  fbec					      MOVE_TO	_UP+_UP+_RIGHT
      1  fbec					      SUBROUTINE
      2  fbec		       bc 35 f0 	      ldy	ValidSquare+_UP+_UP+_RIGHT,x
      3  fbef		       30 0e		      bmi	.invalid
      4  fbf1		       b9 84 f0 	      lda	Board,y
      5  fbf4		       85 9e		      sta	capture
      6  fbf6		       f0 04		      beq	.squareEmpty
      7  fbf8		       45 92		      eor	currentPiece
      8  fbfa		       10 03		      bpl	.invalid
      9  fbfc		       20 56 fc    .squareEmpty jsr	AddMove
     10  fbff				   .invalid
     21  fbff
      0  fbff					      MOVE_TO_X	_DOWN+_LEFT+_LEFT
      1  fbff		       a6 93		      ldx	currentSquare
      0  fc01					      MOVE_TO	_DOWN+_LEFT+_LEFT
      1  fc01					      SUBROUTINE
      2  fc01		       bc 14 f0 	      ldy	ValidSquare+_DOWN+_LEFT+_LEFT,x
      3  fc04		       30 0e		      bmi	.invalid
      4  fc06		       b9 84 f0 	      lda	Board,y
      5  fc09		       85 9e		      sta	capture
      6  fc0b		       f0 04		      beq	.squareEmpty
      7  fc0d		       45 92		      eor	currentPiece
      8  fc0f		       10 03		      bpl	.invalid
      9  fc11		       20 56 fc    .squareEmpty jsr	AddMove
     10  fc14				   .invalid
      0  fc14					      MOVE_TO_X	_DOWN+_RIGHT+_RIGHT
      1  fc14		       a6 93		      ldx	currentSquare
      0  fc16					      MOVE_TO	_DOWN+_RIGHT+_RIGHT
      1  fc16					      SUBROUTINE
      2  fc16		       bc 18 f0 	      ldy	ValidSquare+_DOWN+_RIGHT+_RIGHT,x
      3  fc19		       30 0e		      bmi	.invalid
      4  fc1b		       b9 84 f0 	      lda	Board,y
      5  fc1e		       85 9e		      sta	capture
      6  fc20		       f0 04		      beq	.squareEmpty
      7  fc22		       45 92		      eor	currentPiece
      8  fc24		       10 03		      bpl	.invalid
      9  fc26		       20 56 fc    .squareEmpty jsr	AddMove
     10  fc29				   .invalid
      0  fc29					      MOVE_TO_X	_UP+_LEFT+_LEFT
      1  fc29		       a6 93		      ldx	currentSquare
      0  fc2b					      MOVE_TO	_UP+_LEFT+_LEFT
      1  fc2b					      SUBROUTINE
      2  fc2b		       bc 28 f0 	      ldy	ValidSquare+_UP+_LEFT+_LEFT,x
      3  fc2e		       30 0e		      bmi	.invalid
      4  fc30		       b9 84 f0 	      lda	Board,y
      5  fc33		       85 9e		      sta	capture
      6  fc35		       f0 04		      beq	.squareEmpty
      7  fc37		       45 92		      eor	currentPiece
      8  fc39		       10 03		      bpl	.invalid
      9  fc3b		       20 56 fc    .squareEmpty jsr	AddMove
     10  fc3e				   .invalid
      0  fc3e					      MOVE_TO_X	_UP+_RIGHT+_RIGHT
      1  fc3e		       a6 93		      ldx	currentSquare
      0  fc40					      MOVE_TO	_UP+_RIGHT+_RIGHT
      1  fc40					      SUBROUTINE
      2  fc40		       bc 2c f0 	      ldy	ValidSquare+_UP+_RIGHT+_RIGHT,x
      3  fc43		       30 0e		      bmi	.invalid
      4  fc45		       b9 84 f0 	      lda	Board,y
      5  fc48		       85 9e		      sta	capture
      6  fc4a		       f0 04		      beq	.squareEmpty
      7  fc4c		       45 92		      eor	currentPiece
      8  fc4e		       10 03		      bpl	.invalid
      9  fc50		       20 56 fc    .squareEmpty jsr	AddMove
     10  fc53				   .invalid
     26  fc53
     27  fc53		       4c 2b f9 	      jmp	MoveReturn
     28  fc56
     29  fc56							; EOF
------- FILE BANK_FIXED.asm
    556  fc56
    557  fc56							;---------------------------------------------------------------------------------------------------
    558  fc56
      0  fc56					      DEF	AddMove
      1  fc56				   BANK_AddMove SET	_CURRENT_BANK
      2  fc56				   AddMove
      3  fc56				   TEMPORARY_VAR SET	Overlay
      4  fc56				   TEMPORARY_OFFSET SET	0
      5  fc56				   VAR_BOUNDARY_AddMove SET	TEMPORARY_OFFSET
      6  fc56				   FUNCTION_NAME SET	AddMove
      7  fc56					      SUBROUTINE
    560  fc56					      SUBROUTINE
    561  fc56
      0  fc56					      VEND	AddMove
      1  fc56				  -	      IFNCONST	AddMove
      2  fc56				  -	      ECHO	"Incorrect VEND label", AddMove
      3  fc56				  -	      ERR
      4  fc56					      ENDIF
      5  fc56		       00 a2	   VAREND_AddMove =	TEMPORARY_VAR
    563  fc56
    564  fc56							; add square in y register to movelist as destination (X12 format)
    565  fc56							; [y]		     to square (X12)
    566  fc56							; currentSquare     from square (X12)
    567  fc56							; currentPiece      piece.
    568  fc56							;   ENPASSANT flag set if pawn double-moving off opening rank
    569  fc56							; capture	     captured piece
    570  fc56
    571  fc56		       a5 9e		      lda	capture
    572  fc58		       d0 04		      bne	.always
    573  fc5a		       a5 ad		      lda	__quiesceCapOnly
    574  fc5c		       d0 0c		      bne	.abort
    575  fc5e
    576  fc5e		       a5 95	   .always    lda	currentPly
    577  fc60		       85 3e		      sta	SET_BANK_RAM
    578  fc62		       20 b9 f3 	      jsr	AddMovePly
    579  fc65		       a9 09		      lda	#RAMBANK_BOARD
    580  fc67		       85 3e		      sta	SET_BANK_RAM
    581  fc69		       60		      rts
    582  fc6a
    583  fc6a		       98	   .abort     tya
    584  fc6b		       aa		      tax
    585  fc6c		       60		      rts
    586  fc6d
    587  fc6d							;---------------------------------------------------------------------------------------------------
    588  fc6d
      0  fc6d					      DEF	InitialisePieceSquares
      1  fc6d				   BANK_InitialisePieceSquares SET	_CURRENT_BANK
      2  fc6d				   InitialisePieceSquares
      3  fc6d				   TEMPORARY_VAR SET	Overlay
      4  fc6d				   TEMPORARY_OFFSET SET	0
      5  fc6d				   VAR_BOUNDARY_InitialisePieceSquares SET	TEMPORARY_OFFSET
      6  fc6d				   FUNCTION_NAME SET	InitialisePieceSquares
      7  fc6d					      SUBROUTINE
    590  fc6d					      SUBROUTINE
    591  fc6d
      0  fc6d					      REFER	Reset
      1  fc6d				  -	      IF	VAREND_Reset > TEMPORARY_VAR
      2  fc6d				  -TEMPORARY_VAR SET	VAREND_Reset
      3  fc6d					      ENDIF
      0  fc6d					      VAR	__initPiece, 1
      1  fc6d		       00 a2	   __initPiece =	TEMPORARY_VAR
      2  fc6d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fc6d
      4  fc6d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fc6d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fc6d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fc6d					      ENDIF
      8  fc6d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fc6d				  -	      ECHO	"Temporary Variable", __initPiece, "overflow!"
     10  fc6d				  -	      ERR
     11  fc6d					      ENDIF
     12  fc6d					      LIST	ON
      0  fc6d					      VAR	__initSquare, 1
      1  fc6d		       00 a3	   __initSquare =	TEMPORARY_VAR
      2  fc6d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fc6d
      4  fc6d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fc6d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fc6d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fc6d					      ENDIF
      8  fc6d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fc6d				  -	      ECHO	"Temporary Variable", __initSquare, "overflow!"
     10  fc6d				  -	      ERR
     11  fc6d					      ENDIF
     12  fc6d					      LIST	ON
      0  fc6d					      VAR	__initListPtr, 1
      1  fc6d		       00 a4	   __initListPtr =	TEMPORARY_VAR
      2  fc6d				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fc6d
      4  fc6d				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fc6d				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fc6d				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fc6d					      ENDIF
      8  fc6d				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fc6d				  -	      ECHO	"Temporary Variable", __initListPtr, "overflow!"
     10  fc6d				  -	      ERR
     11  fc6d					      ENDIF
     12  fc6d					      LIST	ON
      0  fc6d					      VEND	InitialisePieceSquares
      1  fc6d				  -	      IFNCONST	InitialisePieceSquares
      2  fc6d				  -	      ECHO	"Incorrect VEND label", InitialisePieceSquares
      3  fc6d				  -	      ERR
      4  fc6d					      ENDIF
      5  fc6d		       00 a5	   VAREND_InitialisePieceSquares =	TEMPORARY_VAR
    597  fc6d
      0  fc6d					      JSROM	InitPieceLists
      1  fc6d
      2  fc6d		       a9 00		      lda	#BANK_InitPieceLists
      3  fc6f		       85 3f		      sta	SET_BANK
      4  fc71		       20 39 f1 	      jsr	InitPieceLists
    599  fc74
    600  fc74		       a2 00		      ldx	#0
    601  fc76		       86 94		      stx	enPassantPawn	; no en-passant
    602  fc78							;stx maxPly
    603  fc78
    604  fc78							; Now setup the board/piecelists
    605  fc78
    606  fc78				   .fillPieceLists
    607  fc78		       a9 0b		      lda	#BANK_InitPieceList
    608  fc7a		       85 3f		      sta	SET_BANK
    609  fc7c
    610  fc7c		       bd 00 f0 	      lda	InitPieceList,x	; colour/-1
    611  fc7f		       f0 4c		      beq	.exit
    612  fc81		       85 b0		      sta	__originalPiece	; type
    613  fc83
    614  fc83		       bc 01 f0 	      ldy	InitPieceList+1,x	; square
    615  fc86		       84 a3		      sty	__initSquare
    616  fc88		       a9 09		      lda	#RAMBANK_BOARD
    617  fc8a		       85 3e		      sta	SET_BANK_RAM
    618  fc8c		       a5 b0		      lda	__originalPiece
      0  fc8e					      sta@RAM	Board,y
      1  fc8e		       99 84 f4 	      sta	[RAM]+Board,y
    620  fc91
    621  fc91		       10 0d		      bpl	.white
      0  fc93					      NEGEVAL
      1  fc93
      2  fc93		       38		      sec
      3  fc94		       a9 00		      lda	#0
      4  fc96		       e5 90		      sbc	Evaluation
      5  fc98		       85 90		      sta	Evaluation
      6  fc9a		       a9 00		      lda	#0
      7  fc9c		       e5 91		      sbc	Evaluation+1
      8  fc9e		       85 91		      sta	Evaluation+1
    623  fca0				   .white
    624  fca0
    625  fca0							; Add the material value of the piece to the evaluation
    626  fca0
    627  fca0		       a5 b0		      lda	__originalPiece
    628  fca2							;and #PIECE_MASK
    629  fca2							;tay
    630  fca2
    631  fca2							;		      ldy #BANK_AddPieceMaterialValue
    632  fca2							;		      sty SET_BANK
    633  fca2		       a9 17		      lda	#RAMBANK_BANK_EVAL	;BANK_AddPiecePositionValue
    634  fca4		       85 3e		      sta	SET_BANK_RAM
    635  fca6		       20 26 f0 	      jsr	AddPieceMaterialValue
    636  fca9
    637  fca9		       86 a4		      stx	__initListPtr
    638  fcab
    639  fcab							; add the positional value of the piece to the evaluation
    640  fcab
    641  fcab		       a4 a3		      ldy	__initSquare
    642  fcad		       a5 b0		      lda	__originalPiece
    643  fcaf
    644  fcaf		       a2 0e		      ldx	#BANK_AddPiecePositionValue
    645  fcb1		       86 3f		      stx	SET_BANK
    646  fcb3		       20 39 f0 	      jsr	AddPiecePositionValue
    647  fcb6
    648  fcb6
    649  fcb6
    650  fcb6		       a5 b0		      lda	__originalPiece	; type/colour
    651  fcb8		       10 0d		      bpl	.white2
      0  fcba					      NEGEVAL
      1  fcba
      2  fcba		       38		      sec
      3  fcbb		       a9 00		      lda	#0
      4  fcbd		       e5 90		      sbc	Evaluation
      5  fcbf		       85 90		      sta	Evaluation
      6  fcc1		       a9 00		      lda	#0
      7  fcc3		       e5 91		      sbc	Evaluation+1
      8  fcc5		       85 91		      sta	Evaluation+1
    653  fcc7				   .white2
    654  fcc7
    655  fcc7		       a6 a4		      ldx	__initListPtr
    656  fcc9		       e8		      inx
    657  fcca		       e8		      inx
    658  fccb		       10 ab		      bpl	.fillPieceLists
    659  fccd
    660  fccd				   .exit
    661  fccd
    662  fccd		       4c d2 f8 	      jmp	ListPlayerMoves
    663  fcd0
    664  fcd0							;---------------------------------------------------------------------------------------------------
    665  fcd0
      0  fcd0					      DEF	GetValid
      1  fcd0				   BANK_GetValid SET	_CURRENT_BANK
      2  fcd0				   GetValid
      3  fcd0				   TEMPORARY_VAR SET	Overlay
      4  fcd0				   TEMPORARY_OFFSET SET	0
      5  fcd0				   VAR_BOUNDARY_GetValid SET	TEMPORARY_OFFSET
      6  fcd0				   FUNCTION_NAME SET	GetValid
      7  fcd0					      SUBROUTINE
    667  fcd0		       a9 09		      lda	#RAMBANK_BOARD
    668  fcd2		       85 3e		      sta	SET_BANK_RAM
    669  fcd4		       b9 20 f0 	      lda	ValidSquare,y
    670  fcd7		       a4 8b		      ldy	savedBank
    671  fcd9		       84 3f		      sty	SET_BANK
    672  fcdb		       60		      rts
    673  fcdc
    674  fcdc
    675  fcdc							;---------------------------------------------------------------------------------------------------
    676  fcdc
      0  fcdc					      DEF	GetBoard
      1  fcdc				   BANK_GetBoard SET	_CURRENT_BANK
      2  fcdc				   GetBoard
      3  fcdc				   TEMPORARY_VAR SET	Overlay
      4  fcdc				   TEMPORARY_OFFSET SET	0
      5  fcdc				   VAR_BOUNDARY_GetBoard SET	TEMPORARY_OFFSET
      6  fcdc				   FUNCTION_NAME SET	GetBoard
      7  fcdc					      SUBROUTINE
    678  fcdc		       a9 09		      lda	#RAMBANK_BOARD
    679  fcde		       85 3e		      sta	SET_BANK_RAM
    680  fce0		       b9 84 f0 	      lda	Board,y
    681  fce3		       a4 8b		      ldy	savedBank
    682  fce5		       84 3f		      sty	SET_BANK
    683  fce7		       60		      rts
    684  fce8
    685  fce8							;---------------------------------------------------------------------------------------------------
    686  fce8
      0  fce8					      DEF	PutBoard
      1  fce8				   BANK_PutBoard SET	_CURRENT_BANK
      2  fce8				   PutBoard
      3  fce8				   TEMPORARY_VAR SET	Overlay
      4  fce8				   TEMPORARY_OFFSET SET	0
      5  fce8				   VAR_BOUNDARY_PutBoard SET	TEMPORARY_OFFSET
      6  fce8				   FUNCTION_NAME SET	PutBoard
      7  fce8					      SUBROUTINE
    688  fce8		       a2 09		      ldx	#RAMBANK_BOARD
    689  fcea		       86 3e		      stx	SET_BANK_RAM
      0  fcec					      sta@RAM	Board,y	; and what's actually moving there
      1  fcec		       99 84 f4 	      sta	[RAM]+Board,y
    691  fcef		       a6 8b		      ldx	savedBank
    692  fcf1		       86 3f		      stx	SET_BANK
    693  fcf3		       60		      rts
    694  fcf4
    695  fcf4
    696  fcf4							;---------------------------------------------------------------------------------------------------
    697  fcf4
      0  fcf4					      DEF	IsValidP_MoveFromSquare
      1  fcf4				   BANK_IsValidP_MoveFromSquare SET	_CURRENT_BANK
      2  fcf4				   IsValidP_MoveFromSquare
      3  fcf4				   TEMPORARY_VAR SET	Overlay
      4  fcf4				   TEMPORARY_OFFSET SET	0
      5  fcf4				   VAR_BOUNDARY_IsValidP_MoveFromSquare SET	TEMPORARY_OFFSET
      6  fcf4				   FUNCTION_NAME SET	IsValidP_MoveFromSquare
      7  fcf4					      SUBROUTINE
    699  fcf4					      SUBROUTINE
    700  fcf4
      0  fcf4					      REFER	aiSelectStartSquare
      1  fcf4				  -	      IF	VAREND_aiSelectStartSquare > TEMPORARY_VAR
      2  fcf4				  -TEMPORARY_VAR SET	VAREND_aiSelectStartSquare
      3  fcf4					      ENDIF
      0  fcf4					      VEND	IsValidP_MoveFromSquare
      1  fcf4				  -	      IFNCONST	IsValidP_MoveFromSquare
      2  fcf4				  -	      ECHO	"Incorrect VEND label", IsValidP_MoveFromSquare
      3  fcf4				  -	      ERR
      4  fcf4					      ENDIF
      5  fcf4		       00 a2	   VAREND_IsValidP_MoveFromSquare =	TEMPORARY_VAR
    703  fcf4
    704  fcf4							; Does the square exist in the movelist?
    705  fcf4							; Return: y = -1 if NOT FOUND
    706  fcf4
    707  fcf4		       a5 88		      lda	cursorX12
    708  fcf6		       85 85		      sta	fromX12
    709  fcf8
    710  fcf8		       a4 95		      ldy	currentPly
    711  fcfa		       84 3e		      sty	SET_BANK_RAM
    712  fcfc		       20 72 f1 	      jsr	CheckMoveListFromSquare
    713  fcff
    714  fcff		       a5 8b		      lda	savedBank
    715  fd01		       85 3f		      sta	SET_BANK
    716  fd03		       60		      rts
    717  fd04
    718  fd04
    719  fd04							;---------------------------------------------------------------------------------------------------
    720  fd04
      0  fd04					      DEF	GetPiece
      1  fd04				   BANK_GetPiece SET	_CURRENT_BANK
      2  fd04				   GetPiece
      3  fd04				   TEMPORARY_VAR SET	Overlay
      4  fd04				   TEMPORARY_OFFSET SET	0
      5  fd04				   VAR_BOUNDARY_GetPiece SET	TEMPORARY_OFFSET
      6  fd04				   FUNCTION_NAME SET	GetPiece
      7  fd04					      SUBROUTINE
    722  fd04					      SUBROUTINE
    723  fd04
      0  fd04					      REFER	aiSelectDestinationSquare
      1  fd04				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  fd04				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  fd04					      ENDIF
      0  fd04					      REFER	aiQuiescent
      1  fd04				  -	      IF	VAREND_aiQuiescent > TEMPORARY_VAR
      2  fd04				  -TEMPORARY_VAR SET	VAREND_aiQuiescent
      3  fd04					      ENDIF
      0  fd04					      VEND	GetPiece
      1  fd04				  -	      IFNCONST	GetPiece
      2  fd04				  -	      ECHO	"Incorrect VEND label", GetPiece
      3  fd04				  -	      ERR
      4  fd04					      ENDIF
      5  fd04		       00 a2	   VAREND_GetPiece =	TEMPORARY_VAR
    727  fd04
    728  fd04							; Retrieve the piece+flags from the movelist, given from/to squares
    729  fd04							; Required as moves have different flags but same origin squares (e.g., castling)
    730  fd04
    731  fd04		       a5 95		      lda	currentPly
    732  fd06		       85 3e		      sta	SET_BANK_RAM
    733  fd08
    734  fd08		       20 86 f1 	      jsr	GetPieceGivenFromToSquares
    735  fd0b
    736  fd0b		       a5 8b		      lda	savedBank
    737  fd0d		       85 3f		      sta	SET_BANK
    738  fd0f		       60		      rts
    739  fd10
    740  fd10
    741  fd10							;---------------------------------------------------------------------------------------------------
    742  fd10
    743  fd10
      0  fd10					      DEF	CopyShadowROMtoRAM
      1  fd10				   BANK_CopyShadowROMtoRAM SET	_CURRENT_BANK
      2  fd10				   CopyShadowROMtoRAM
      3  fd10				   TEMPORARY_VAR SET	Overlay
      4  fd10				   TEMPORARY_OFFSET SET	0
      5  fd10				   VAR_BOUNDARY_CopyShadowROMtoRAM SET	TEMPORARY_OFFSET
      6  fd10				   FUNCTION_NAME SET	CopyShadowROMtoRAM
      7  fd10					      SUBROUTINE
    745  fd10					      SUBROUTINE
    746  fd10
      0  fd10					      REFER	SetupBanks
      1  fd10					      IF	VAREND_SetupBanks > TEMPORARY_VAR
      2  fd10				   TEMPORARY_VAR SET	VAREND_SetupBanks
      3  fd10					      ENDIF
      0  fd10					      VAR	__destinationBank, 1
      1  fd10		       00 a3	   __destinationBank =	TEMPORARY_VAR
      2  fd10				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fd10
      4  fd10				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fd10				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fd10				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fd10					      ENDIF
      8  fd10				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fd10				  -	      ECHO	"Temporary Variable", __destinationBank, "overflow!"
     10  fd10				  -	      ERR
     11  fd10					      ENDIF
     12  fd10					      LIST	ON
      0  fd10					      VAR	__sourceBank, 1
      1  fd10		       00 a4	   __sourceBank =	TEMPORARY_VAR
      2  fd10				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fd10
      4  fd10				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fd10				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fd10				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fd10					      ENDIF
      8  fd10				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fd10				  -	      ECHO	"Temporary Variable", __sourceBank, "overflow!"
     10  fd10				  -	      ERR
     11  fd10					      ENDIF
     12  fd10					      LIST	ON
      0  fd10					      VEND	CopyShadowROMtoRAM
      1  fd10				  -	      IFNCONST	CopyShadowROMtoRAM
      2  fd10				  -	      ECHO	"Incorrect VEND label", CopyShadowROMtoRAM
      3  fd10				  -	      ERR
      4  fd10					      ENDIF
      5  fd10		       00 a5	   VAREND_CopyShadowROMtoRAM =	TEMPORARY_VAR
    751  fd10
    752  fd10							; Copy a whole 1K ROM SHADOW into a destination RAM 1K bank
    753  fd10							; used to setup callable RAM code from ROM templates
    754  fd10
    755  fd10							; x = source ROM bank
    756  fd10							; y = destination RAM bank (preserved)
    757  fd10
    758  fd10		       86 a4		      stx	__sourceBank
    759  fd12
    760  fd12		       a2 00		      ldx	#0
    761  fd14		       a5 a4	   .copyPage  lda	__sourceBank
    762  fd16		       85 3f		      sta	SET_BANK
    763  fd18
    764  fd18		       bd 00 f0 	      lda	$F000,x
    765  fd1b		       48		      pha
    766  fd1c		       bd 00 f1 	      lda	$F100,x
    767  fd1f		       48		      pha
    768  fd20		       bd 00 f2 	      lda	$F200,x
    769  fd23		       48		      pha
    770  fd24		       bd 00 f3 	      lda	$F300,x
    771  fd27
    772  fd27		       84 3e		      sty	SET_BANK_RAM
    773  fd29
      0  fd29					      sta@RAM	$F300,x
      1  fd29		       9d 00 f7 	      sta	[RAM]+$F300,x
    775  fd2c		       68		      pla
      0  fd2d					      sta@RAM	$F200,x
      1  fd2d		       9d 00 f6 	      sta	[RAM]+$F200,x
    777  fd30		       68		      pla
      0  fd31					      sta@RAM	$F100,x
      1  fd31		       9d 00 f5 	      sta	[RAM]+$F100,x
    779  fd34		       68		      pla
      0  fd35					      sta@RAM	$F000,x
      1  fd35		       9d 00 f4 	      sta	[RAM]+$F000,x
    781  fd38
    782  fd38		       ca		      dex
    783  fd39		       d0 d9		      bne	.copyPage
    784  fd3b
    785  fd3b		       a5 8b		      lda	savedBank
    786  fd3d		       85 3f		      sta	SET_BANK
    787  fd3f		       60		      rts
    788  fd40
    789  fd40
    790  fd40							;---------------------------------------------------------------------------------------------------
    791  fd40
      0  fd40					      DEF	CopySinglePiece
      1  fd40				   BANK_CopySinglePiece SET	_CURRENT_BANK
      2  fd40				   CopySinglePiece
      3  fd40				   TEMPORARY_VAR SET	Overlay
      4  fd40				   TEMPORARY_OFFSET SET	0
      5  fd40				   VAR_BOUNDARY_CopySinglePiece SET	TEMPORARY_OFFSET
      6  fd40				   FUNCTION_NAME SET	CopySinglePiece
      7  fd40					      SUBROUTINE
    793  fd40					      SUBROUTINE
      0  fd40					      TIMING	COPYSINGLEPIECE, (2600)
      1  fd40		       00 29	   SPEEDOF_COPYSINGLEPIECE =	((2600)/64) + 1
    795  fd40
      0  fd40					      REFER	aiDrawEntireBoard
      1  fd40				  -	      IF	VAREND_aiDrawEntireBoard > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiDrawEntireBoard
      3  fd40					      ENDIF
      0  fd40					      REFER	aiSpecialMoveFixup
      1  fd40					      IF	VAREND_aiSpecialMoveFixup > TEMPORARY_VAR
      2  fd40				   TEMPORARY_VAR SET	VAREND_aiSpecialMoveFixup
      3  fd40					      ENDIF
      0  fd40					      REFER	aiWriteStartPieceBlank
      1  fd40				  -	      IF	VAREND_aiWriteStartPieceBlank > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiWriteStartPieceBlank
      3  fd40					      ENDIF
      0  fd40					      REFER	aiDrawPart2
      1  fd40				  -	      IF	VAREND_aiDrawPart2 > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiDrawPart2
      3  fd40					      ENDIF
      0  fd40					      REFER	aiMarchB
      1  fd40				  -	      IF	VAREND_aiMarchB > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiMarchB
      3  fd40					      ENDIF
      0  fd40					      REFER	aiFinalFlash
      1  fd40				  -	      IF	VAREND_aiFinalFlash > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiFinalFlash
      3  fd40					      ENDIF
      0  fd40					      REFER	UNSAFE_showMoveCaptures
      1  fd40				  -	      IF	VAREND_UNSAFE_showMoveCaptures > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_UNSAFE_showMoveCaptures
      3  fd40					      ENDIF
      0  fd40					      REFER	aiMarchToTargetA
      1  fd40				  -	      IF	VAREND_aiMarchToTargetA > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetA
      3  fd40					      ENDIF
      0  fd40					      REFER	aiMarchB2
      1  fd40				  -	      IF	VAREND_aiMarchB2 > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiMarchB2
      3  fd40					      ENDIF
      0  fd40					      REFER	aiMarchToTargetB
      1  fd40				  -	      IF	VAREND_aiMarchToTargetB > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiMarchToTargetB
      3  fd40					      ENDIF
      0  fd40					      REFER	aiSelectDestinationSquare
      1  fd40				  -	      IF	VAREND_aiSelectDestinationSquare > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiSelectDestinationSquare
      3  fd40					      ENDIF
      0  fd40					      REFER	aiPromotePawnStart
      1  fd40				  -	      IF	VAREND_aiPromotePawnStart > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiPromotePawnStart
      3  fd40					      ENDIF
      0  fd40					      REFER	aiChoosePromotePiece
      1  fd40				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  fd40				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  fd40					      ENDIF
      0  fd40					      VEND	CopySinglePiece
      1  fd40				  -	      IFNCONST	CopySinglePiece
      2  fd40				  -	      ECHO	"Incorrect VEND label", CopySinglePiece
      3  fd40				  -	      ERR
      4  fd40					      ENDIF
      5  fd40		       00 ae	   VAREND_CopySinglePiece =	TEMPORARY_VAR
    810  fd40
    811  fd40							; WARNING: CANNOT USE VAR/OVERLAY IN ANY ROUTINE CALLING THIS!!
    812  fd40							; ALSO CAN'T USE IN THIS ROUTINE
    813  fd40							; This routine will STOMP on those vars due to __pieceShapeBuffer occupying whole overlay
    814  fd40							; @2150 max
    815  fd40							; = 33 TIM64T
    816  fd40
      0  fd40					      JSROM	CopySetup
      1  fd40
      2  fd40		       a9 0b		      lda	#BANK_CopySetup
      3  fd42		       85 3f		      sta	SET_BANK
      4  fd44		       20 6e f1 	      jsr	CopySetup
    818  fd47
      0  fd47					      DEF	InterceptMarkerCopy
      1  fd47				   BANK_InterceptMarkerCopy SET	_CURRENT_BANK
      2  fd47				   InterceptMarkerCopy
      3  fd47				   TEMPORARY_VAR SET	Overlay
      4  fd47				   TEMPORARY_OFFSET SET	0
      5  fd47				   VAR_BOUNDARY_InterceptMarkerCopy SET	TEMPORARY_OFFSET
      6  fd47				   FUNCTION_NAME SET	InterceptMarkerCopy
      7  fd47					      SUBROUTINE
    820  fd47					      SUBROUTINE
    821  fd47
    822  fd47
    823  fd47							; Copy a piece shape (3 PF bytes wide x 24 lines) to the RAM buffer
    824  fd47							; y = piece index
    825  fd47
    826  fd47		       a9 00		      lda	#BANK_PIECE_VECTOR_BANK
    827  fd49		       85 3f		      sta	SET_BANK
    828  fd4b
    829  fd4b		       b9 56 f1 	      lda	PIECE_VECTOR_LO,y
    830  fd4e		       85 ea		      sta	__ptr
    831  fd50		       b9 e6 f1 	      lda	PIECE_VECTOR_HI,y
    832  fd53		       85 eb		      sta	__ptr+1
    833  fd55		       b9 76 f2 	      lda	PIECE_VECTOR_BANK,y
    834  fd58		       85 3f		      sta	SET_BANK
    835  fd5a
    836  fd5a		       a0 47		      ldy	#PIECE_SHAPE_SIZE-1
    837  fd5c		       b1 ea	   .copy      lda	(__ptr),y
    838  fd5e		       99 a2 00 	      sta	__pieceShapeBuffer,y
    839  fd61		       88		      dey
    840  fd62		       10 f8		      bpl	.copy
    841  fd64
    842  fd64		       a5 80		      lda	squareToDraw
    843  fd66		       38		      sec
    844  fd67		       a2 0a		      ldx	#10
    845  fd69		       e9 0a	   .sub10     sbc	#10
    846  fd6b		       ca		      dex
    847  fd6c		       b0 fb		      bcs	.sub10
    848  fd6e
    849  fd6e		       86 3e		      stx	SET_BANK_RAM	; row
    850  fd70
    851  fd70		       69 08		      adc	#8
    852  fd72		       c9 04		      cmp	#4	; CS = right side of screen
    853  fd74
    854  fd74		       20 9b f1 	      jsr	CopyPieceToRowBitmap
    855  fd77
    856  fd77		       a5 8b		      lda	savedBank
    857  fd79		       85 3f		      sta	SET_BANK
    858  fd7b		       60		      rts
    859  fd7c
    860  fd7c
    861  fd7c							;---------------------------------------------------------------------------------------------------
    862  fd7c
      0  fd7c					      DEF	SAFE_getMoveIndex
      1  fd7c				   BANK_SAFE_getMoveIndex SET	_CURRENT_BANK
      2  fd7c				   SAFE_getMoveIndex
      3  fd7c				   TEMPORARY_VAR SET	Overlay
      4  fd7c				   TEMPORARY_OFFSET SET	0
      5  fd7c				   VAR_BOUNDARY_SAFE_getMoveIndex SET	TEMPORARY_OFFSET
      6  fd7c				   FUNCTION_NAME SET	SAFE_getMoveIndex
      7  fd7c					      SUBROUTINE
    864  fd7c					      SUBROUTINE
    865  fd7c
    866  fd7c		       a9 0b		      lda	#RAMBANK_PLY+1
    867  fd7e		       85 3e		      sta	SET_BANK_RAM
      0  fd80					      lda@PLY	moveIndex
      1  fd80		       ad 4f f1 	      lda	moveIndex
    869  fd83		       a6 8b		      ldx	savedBank
    870  fd85		       86 3f		      stx	SET_BANK
    871  fd87		       60		      rts
    872  fd88
    873  fd88
    874  fd88							;---------------------------------------------------------------------------------------------------
    875  fd88
      0  fd88					      DEF	markerDraw
      1  fd88				   BANK_markerDraw SET	_CURRENT_BANK
      2  fd88				   markerDraw
      3  fd88				   TEMPORARY_VAR SET	Overlay
      4  fd88				   TEMPORARY_OFFSET SET	0
      5  fd88				   VAR_BOUNDARY_markerDraw SET	TEMPORARY_OFFSET
      6  fd88				   FUNCTION_NAME SET	markerDraw
      7  fd88					      SUBROUTINE
    877  fd88					      SUBROUTINE
    878  fd88
      0  fd88					      REFER	SAFE_showMoveOptions
      1  fd88					      IF	VAREND_SAFE_showMoveOptions > TEMPORARY_VAR
      2  fd88				   TEMPORARY_VAR SET	VAREND_SAFE_showMoveOptions
      3  fd88					      ENDIF
      0  fd88					      VEND	markerDraw
      1  fd88				  -	      IFNCONST	markerDraw
      2  fd88				  -	      ECHO	"Incorrect VEND label", markerDraw
      3  fd88				  -	      ERR
      4  fd88					      ENDIF
      5  fd88		       00 a4	   VAREND_markerDraw =	TEMPORARY_VAR
    881  fd88
    882  fd88		       a2 1c		      ldx	#INDEX_WHITE_MARKER_on_WHITE_SQUARE_0
      0  fd8a					      JSROM	CopySetupForMarker
      1  fd8a
      2  fd8a		       a9 0b		      lda	#BANK_CopySetupForMarker
      3  fd8c		       85 3f		      sta	SET_BANK
      4  fd8e		       20 43 f1 	      jsr	CopySetupForMarker
    884  fd91		       4c 47 fd 	      jmp	InterceptMarkerCopy
    885  fd94
    886  fd94
    887  fd94							;---------------------------------------------------------------------------------------------------
    888  fd94
      0  fd94					      DEF	showPromoteOptions
      1  fd94				   BANK_showPromoteOptions SET	_CURRENT_BANK
      2  fd94				   showPromoteOptions
      3  fd94				   TEMPORARY_VAR SET	Overlay
      4  fd94				   TEMPORARY_OFFSET SET	0
      5  fd94				   VAR_BOUNDARY_showPromoteOptions SET	TEMPORARY_OFFSET
      6  fd94				   FUNCTION_NAME SET	showPromoteOptions
      7  fd94					      SUBROUTINE
    890  fd94					      SUBROUTINE
    891  fd94
      0  fd94					      REFER	aiRollPromotionPiece
      1  fd94				  -	      IF	VAREND_aiRollPromotionPiece > TEMPORARY_VAR
      2  fd94				  -TEMPORARY_VAR SET	VAREND_aiRollPromotionPiece
      3  fd94					      ENDIF
      0  fd94					      REFER	aiChoosePromotePiece
      1  fd94				  -	      IF	VAREND_aiChoosePromotePiece > TEMPORARY_VAR
      2  fd94				  -TEMPORARY_VAR SET	VAREND_aiChoosePromotePiece
      3  fd94					      ENDIF
      0  fd94					      VEND	showPromoteOptions
      1  fd94				  -	      IFNCONST	showPromoteOptions
      2  fd94				  -	      ECHO	"Incorrect VEND label", showPromoteOptions
      3  fd94				  -	      ERR
      4  fd94					      ENDIF
      5  fd94		       00 a2	   VAREND_showPromoteOptions =	TEMPORARY_VAR
    895  fd94
    896  fd94							; X = character shape # (?/N/B/R/Q)
    897  fd94
    898  fd94		       a4 86		      ldy	toX12
    899  fd96		       84 80		      sty	squareToDraw
    900  fd98
      0  fd98					      JSROM	CopySetupForMarker
      1  fd98
      2  fd98		       a9 0b		      lda	#BANK_CopySetupForMarker
      3  fd9a		       85 3f		      sta	SET_BANK
      4  fd9c		       20 43 f1 	      jsr	CopySetupForMarker
    902  fd9f		       4c 47 fd 	      jmp	InterceptMarkerCopy
    903  fda2
    904  fda2
    905  fda2							;---------------------------------------------------------------------------------------------------
    906  fda2
      0  fda2					      DEF	SAFE_BackupBitmaps
      1  fda2				   BANK_SAFE_BackupBitmaps SET	_CURRENT_BANK
      2  fda2				   SAFE_BackupBitmaps
      3  fda2				   TEMPORARY_VAR SET	Overlay
      4  fda2				   TEMPORARY_OFFSET SET	0
      5  fda2				   VAR_BOUNDARY_SAFE_BackupBitmaps SET	TEMPORARY_OFFSET
      6  fda2				   FUNCTION_NAME SET	SAFE_BackupBitmaps
      7  fda2					      SUBROUTINE
    908  fda2					      SUBROUTINE
    909  fda2
      0  fda2					      VEND	SAFE_BackupBitmaps
      1  fda2				  -	      IFNCONST	SAFE_BackupBitmaps
      2  fda2				  -	      ECHO	"Incorrect VEND label", SAFE_BackupBitmaps
      3  fda2				  -	      ERR
      4  fda2					      ENDIF
      5  fda2		       00 a2	   VAREND_SAFE_BackupBitmaps =	TEMPORARY_VAR
    911  fda2
    912  fda2		       84 3e		      sty	SET_BANK_RAM
    913  fda4		       20 f4 f2 	      jsr	SaveBitmap
    914  fda7		       a5 8b		      lda	savedBank
    915  fda9		       85 3f		      sta	SET_BANK
    916  fdab		       60		      rts
    917  fdac
    918  fdac
    919  fdac							;---------------------------------------------------------------------------------------------------
    920  fdac
      0  fdac					      DEF	SAFE_showMoveCaptures
      1  fdac				   BANK_SAFE_showMoveCaptures SET	_CURRENT_BANK
      2  fdac				   SAFE_showMoveCaptures
      3  fdac				   TEMPORARY_VAR SET	Overlay
      4  fdac				   TEMPORARY_OFFSET SET	0
      5  fdac				   VAR_BOUNDARY_SAFE_showMoveCaptures SET	TEMPORARY_OFFSET
      6  fdac				   FUNCTION_NAME SET	SAFE_showMoveCaptures
      7  fdac					      SUBROUTINE
    922  fdac					      SUBROUTINE
    923  fdac
      0  fdac					      VEND	SAFE_showMoveCaptures
      1  fdac				  -	      IFNCONST	SAFE_showMoveCaptures
      2  fdac				  -	      ECHO	"Incorrect VEND label", SAFE_showMoveCaptures
      3  fdac				  -	      ERR
      4  fdac					      ENDIF
      5  fdac		       00 a2	   VAREND_SAFE_showMoveCaptures =	TEMPORARY_VAR
    925  fdac
      0  fdac					      JSROM	UNSAFE_showMoveCaptures
      1  fdac
      2  fdac		       a9 0b		      lda	#BANK_UNSAFE_showMoveCaptures
      3  fdae		       85 3f		      sta	SET_BANK
      4  fdb0		       20 41 f0 	      jsr	UNSAFE_showMoveCaptures
    927  fdb3		       a5 8b		      lda	savedBank
    928  fdb5		       85 3f		      sta	SET_BANK
    929  fdb7		       60		      rts
    930  fdb8
    931  fdb8
    932  fdb8							;---------------------------------------------------------------------------------------------------
    933  fdb8
      0  fdb8					      DEF	GetP_MoveFrom
      1  fdb8				   BANK_GetP_MoveFrom SET	_CURRENT_BANK
      2  fdb8				   GetP_MoveFrom
      3  fdb8				   TEMPORARY_VAR SET	Overlay
      4  fdb8				   TEMPORARY_OFFSET SET	0
      5  fdb8				   VAR_BOUNDARY_GetP_MoveFrom SET	TEMPORARY_OFFSET
      6  fdb8				   FUNCTION_NAME SET	GetP_MoveFrom
      7  fdb8					      SUBROUTINE
    935  fdb8		       a9 0b		      lda	#RAMBANK_PLY+1
    936  fdba		       85 3e		      sta	SET_BANK_RAM
    937  fdbc		       a4 8b		      ldy	savedBank
      0  fdbe					      lda@PLY	MoveFrom,x
      1  fdbe		       bd 02 f0 	      lda	MoveFrom,x
    939  fdc1		       84 3f		      sty	SET_BANK
    940  fdc3		       60		      rts
    941  fdc4
    942  fdc4
    943  fdc4							;---------------------------------------------------------------------------------------------------
    944  fdc4
      0  fdc4					      DEF	GetP_MoveTo
      1  fdc4				   BANK_GetP_MoveTo SET	_CURRENT_BANK
      2  fdc4				   GetP_MoveTo
      3  fdc4				   TEMPORARY_VAR SET	Overlay
      4  fdc4				   TEMPORARY_OFFSET SET	0
      5  fdc4				   VAR_BOUNDARY_GetP_MoveTo SET	TEMPORARY_OFFSET
      6  fdc4				   FUNCTION_NAME SET	GetP_MoveTo
      7  fdc4					      SUBROUTINE
    946  fdc4					      SUBROUTINE
    947  fdc4
    948  fdc4		       a9 0b		      lda	#RAMBANK_PLY+1
    949  fdc6		       85 3e		      sta	SET_BANK_RAM
    950  fdc8		       a4 8b		      ldy	savedBank
      0  fdca					      lda@PLY	MoveTo,x
      1  fdca		       bd 48 f0 	      lda	MoveTo,x
    952  fdcd		       84 3f		      sty	SET_BANK
    953  fdcf		       60		      rts
    954  fdd0
    955  fdd0
    956  fdd0							;---------------------------------------------------------------------------------------------------
    957  fdd0
      0  fdd0					      DEF	GetP_MovePiece
      1  fdd0				   BANK_GetP_MovePiece SET	_CURRENT_BANK
      2  fdd0				   GetP_MovePiece
      3  fdd0				   TEMPORARY_VAR SET	Overlay
      4  fdd0				   TEMPORARY_OFFSET SET	0
      5  fdd0				   VAR_BOUNDARY_GetP_MovePiece SET	TEMPORARY_OFFSET
      6  fdd0				   FUNCTION_NAME SET	GetP_MovePiece
      7  fdd0					      SUBROUTINE
    959  fdd0					      SUBROUTINE
    960  fdd0
    961  fdd0		       a9 0b		      lda	#RAMBANK_PLY+1
    962  fdd2		       85 3e		      sta	SET_BANK_RAM
    963  fdd4		       a4 8b		      ldy	savedBank
      0  fdd6					      lda@PLY	MovePiece,x
      1  fdd6		       bd 8e f0 	      lda	MovePiece,x
    965  fdd9		       84 3f		      sty	SET_BANK
    966  fddb		       60		      rts
    967  fddc
    968  fddc
    969  fddc							;---------------------------------------------------------------------------------------------------
    970  fddc
      0  fddc					      DEF	MakeMove
      1  fddc				   BANK_MakeMove SET	_CURRENT_BANK
      2  fddc				   MakeMove
      3  fddc				   TEMPORARY_VAR SET	Overlay
      4  fddc				   TEMPORARY_OFFSET SET	0
      5  fddc				   VAR_BOUNDARY_MakeMove SET	TEMPORARY_OFFSET
      6  fddc				   FUNCTION_NAME SET	MakeMove
      7  fddc					      SUBROUTINE
    972  fddc					      SUBROUTINE
    973  fddc
      0  fddc					      REFER	negaMax
      1  fddc					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  fddc				   TEMPORARY_VAR SET	VAREND_negaMax
      3  fddc					      ENDIF
      0  fddc					      VAR	__capture, 1
      1  fddc		       00 ae	   __capture  =	TEMPORARY_VAR
      2  fddc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fddc
      4  fddc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fddc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fddc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fddc					      ENDIF
      8  fddc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fddc				  -	      ECHO	"Temporary Variable", __capture, "overflow!"
     10  fddc				  -	      ERR
     11  fddc					      ENDIF
     12  fddc					      LIST	ON
      0  fddc					      VAR	__restore, 1
      1  fddc		       00 af	   __restore  =	TEMPORARY_VAR
      2  fddc				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fddc
      4  fddc				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fddc				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fddc				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fddc					      ENDIF
      8  fddc				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fddc				  -	      ECHO	"Temporary Variable", __restore, "overflow!"
     10  fddc				  -	      ERR
     11  fddc					      ENDIF
     12  fddc					      LIST	ON
      0  fddc					      VEND	MakeMove
      1  fddc				  -	      IFNCONST	MakeMove
      2  fddc				  -	      ECHO	"Incorrect VEND label", MakeMove
      3  fddc				  -	      ERR
      4  fddc					      ENDIF
      5  fddc		       00 b0	   VAREND_MakeMove =	TEMPORARY_VAR
    978  fddc
    979  fddc							; Do a move without any GUI stuff
    980  fddc							; This function is ALWAYS paired with "unmakeMove" - a call to both will leave board
    981  fddc							; and all relevant flags in original state. This is NOT used for the visible move on the
    982  fddc							; screen.
    983  fddc
    984  fddc
    985  fddc							; fromPiece	 piece doing the move
    986  fddc							; fromX12	 current square X12
    987  fddc							; originX12	 starting square X12
    988  fddc							; toX12	 ending square X12
    989  fddc
    990  fddc
    991  fddc							; There are potentially "two" moves, with the following
    992  fddc							; a) Castling, moving both rook and king
    993  fddc							; b) en-Passant, capturing pawn on "odd" square
    994  fddc							; These both set "secondary" movers which are used for restoring during unmakeMove
    995  fddc
    996  fddc		       a9 00		      lda	#0
      0  fdde					      sta@PLY	secondaryPiece
      1  fdde		       8d 4c f5 	      sta	[RAM]+secondaryPiece
    998  fde1
      0  fde1					      ldx@PLY	movePtr
      1  fde1		       ae 50 f1 	      ldx	movePtr
      0  fde4					      lda@PLY	MoveFrom,x
      1  fde4		       bd 02 f0 	      lda	MoveFrom,x
   1001  fde7		       85 85		      sta	fromX12
   1002  fde9		       85 87		      sta	originX12
      0  fdeb					      lda@PLY	MoveTo,x
      1  fdeb		       bd 48 f0 	      lda	MoveTo,x
   1004  fdee		       85 86		      sta	toX12
      0  fdf0					      lda@PLY	MovePiece,x
      1  fdf0		       bd 8e f0 	      lda	MovePiece,x
   1006  fdf3		       85 97		      sta	fromPiece
   1007  fdf5
   1008  fdf5		       20 81 f9    .move      jsr	AdjustMaterialPositionalValue
   1009  fdf8
   1010  fdf8							; Modify the board
   1011  fdf8
   1012  fdf8		       a0 09		      ldy	#RAMBANK_BOARD
   1013  fdfa		       84 3e		      sty	SET_BANK_RAM
   1014  fdfc		       a4 87		      ldy	originX12
      0  fdfe					      lda@RAM	Board,y
      1  fdfe		       b9 84 f0 	      lda	Board,y
   1016  fe01		       85 af		      sta	__restore
   1017  fe03		       a9 00		      lda	#0
      0  fe05					      sta@RAM	Board,y
      1  fe05		       99 84 f4 	      sta	[RAM]+Board,y
   1019  fe08		       a4 86		      ldy	toX12
      0  fe0a					      lda@RAM	Board,y
      1  fe0a		       b9 84 f0 	      lda	Board,y
   1021  fe0d		       85 ae		      sta	__capture
   1022  fe0f		       a5 97		      lda	fromPiece
   1023  fe11		       29 8f		      and	#PIECE_MASK|FLAG_COLOUR
   1024  fe13		       09 40		      ora	#FLAG_MOVED
      0  fe15					      sta@RAM	Board,y
      1  fe15		       99 84 f4 	      sta	[RAM]+Board,y
   1026  fe18
   1027  fe18		       a5 95		      lda	currentPly
   1028  fe1a		       85 3e		      sta	SET_BANK_RAM
   1029  fe1c		       a5 ae		      lda	__capture
      0  fe1e					      sta@PLY	capturedPiece
      1  fe1e		       8d 4a f5 	      sta	[RAM]+capturedPiece
   1031  fe21		       a5 af		      lda	__restore
      0  fe23					      sta@PLY	restorePiece
      1  fe23		       8d 59 f5 	      sta	[RAM]+restorePiece
   1033  fe26
   1034  fe26					      IF	CASTLING_ENABLED
   1035  fe26
   1036  fe26							; If the FROM piece has the castle bit set (i.e., it's a king that's just moved 2 squares)
   1037  fe26							; then we find the appropriate ROOK, set the secondary piece "undo" information, and then
   1038  fe26							; redo the moving code (for the rook, this time).
   1039  fe26
   1040  fe26		       20 e8 f1 	      jsr	GenCastleMoveForRook
   1041  fe29		       b0 ca		      bcs	.move	; move the rook!
   1042  fe2b					      ENDIF
   1043  fe2b
   1044  fe2b
   1045  fe2b					      IF	ENPASSANT_ENABLED
      0  fe2b					      JSROM	EnPassantCheck
      1  fe2b
      2  fe2b		       a9 01		      lda	#BANK_EnPassantCheck
      3  fe2d		       85 3f		      sta	SET_BANK
      4  fe2f		       20 00 f0 	      jsr	EnPassantCheck
   1047  fe32		       f0 03		      beq	.notEnPassant
   1048  fe34		       20 10 f0 	      jsr	EnPassantRemovePiece	; y = origin X12
   1049  fe37				   .notEnPassant
   1050  fe37					      ENDIF
   1051  fe37
   1052  fe37							; Swap over sides
   1053  fe37
      0  fe37					      NEGEVAL
      1  fe37
      2  fe37		       38		      sec
      3  fe38		       a9 00		      lda	#0
      4  fe3a		       e5 90		      sbc	Evaluation
      5  fe3c		       85 90		      sta	Evaluation
      6  fe3e		       a9 00		      lda	#0
      7  fe40		       e5 91		      sbc	Evaluation+1
      8  fe42		       85 91		      sta	Evaluation+1
      0  fe44					      SWAP
      1  fe44		       a5 96		      lda	sideToMove
      2  fe46		       49 81		      eor	#SWAP_SIDE
      3  fe48		       85 96		      sta	sideToMove
   1056  fe4a
   1057  fe4a		       a5 95		      lda	currentPly
   1058  fe4c		       85 3e		      sta	SET_BANK_RAM
   1059  fe4e		       60		      rts
   1060  fe4f
   1061  fe4f
   1062  fe4f							;---------------------------------------------------------------------------------------------------
   1063  fe4f
      0  fe4f					      DEF	unmakeMove
      1  fe4f				   BANK_unmakeMove SET	_CURRENT_BANK
      2  fe4f				   unmakeMove
      3  fe4f				   TEMPORARY_VAR SET	Overlay
      4  fe4f				   TEMPORARY_OFFSET SET	0
      5  fe4f				   VAR_BOUNDARY_unmakeMove SET	TEMPORARY_OFFSET
      6  fe4f				   FUNCTION_NAME SET	unmakeMove
      7  fe4f					      SUBROUTINE
   1065  fe4f					      SUBROUTINE
   1066  fe4f
      0  fe4f					      REFER	negaMax
      1  fe4f					      IF	VAREND_negaMax > TEMPORARY_VAR
      2  fe4f				   TEMPORARY_VAR SET	VAREND_negaMax
      3  fe4f					      ENDIF
      0  fe4f					      VAR	__unmake_capture, 1
      1  fe4f		       00 ae	   __unmake_capture =	TEMPORARY_VAR
      2  fe4f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fe4f
      4  fe4f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe4f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe4f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe4f					      ENDIF
      8  fe4f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe4f				  -	      ECHO	"Temporary Variable", __unmake_capture, "overflow!"
     10  fe4f				  -	      ERR
     11  fe4f					      ENDIF
     12  fe4f					      LIST	ON
      0  fe4f					      VAR	__secondaryBlank, 1
      1  fe4f		       00 af	   __secondaryBlank =	TEMPORARY_VAR
      2  fe4f				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fe4f
      4  fe4f				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fe4f				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fe4f				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fe4f					      ENDIF
      8  fe4f				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fe4f				  -	      ECHO	"Temporary Variable", __secondaryBlank, "overflow!"
     10  fe4f				  -	      ERR
     11  fe4f					      ENDIF
     12  fe4f					      LIST	ON
      0  fe4f					      VEND	unmakeMove
      1  fe4f				  -	      IFNCONST	unmakeMove
      2  fe4f				  -	      ECHO	"Incorrect VEND label", unmakeMove
      3  fe4f				  -	      ERR
      4  fe4f					      ENDIF
      5  fe4f		       00 b0	   VAREND_unmakeMove =	TEMPORARY_VAR
   1071  fe4f
   1072  fe4f							; restore the board evaluation to what it was at the start of this ply
   1073  fe4f							; TODO: note: moved flag seems wrong on restoration
   1074  fe4f
      0  fe4f					      lda@PLY	savedEvaluation
      1  fe4f		       ad 00 f0 	      lda	savedEvaluation
   1076  fe52		       85 90		      sta	Evaluation
      0  fe54					      lda@PLY	savedEvaluation+1
      1  fe54		       ad 01 f0 	      lda	savedEvaluation+1
   1078  fe57		       85 91		      sta	Evaluation+1
   1079  fe59
   1080  fe59		       ae 50 f1 	      ldx	movePtr
      0  fe5c					      lda@PLY	MoveFrom,x
      1  fe5c		       bd 02 f0 	      lda	MoveFrom,x
   1082  fe5f		       85 85		      sta	fromX12
      0  fe61					      ldy@PLY	MoveTo,x
      1  fe61		       bc 48 f0 	      ldy	MoveTo,x
   1084  fe64
      0  fe64					      lda@PLY	restorePiece
      1  fe64		       ad 59 f1 	      lda	restorePiece
   1086  fe67		       48		      pha
      0  fe68					      lda@PLY	capturedPiece
      1  fe68		       ad 4a f1 	      lda	capturedPiece
   1088  fe6b
   1089  fe6b		       a2 09		      ldx	#RAMBANK_BOARD
   1090  fe6d		       86 3e		      stx	SET_BANK_RAM
      0  fe6f					      sta@RAM	Board,y
      1  fe6f		       99 84 f4 	      sta	[RAM]+Board,y
   1092  fe72		       a4 85		      ldy	fromX12
   1093  fe74		       68		      pla
      0  fe75					      sta@RAM	Board,y
      1  fe75		       99 84 f4 	      sta	[RAM]+Board,y
   1095  fe78
   1096  fe78
   1097  fe78		       a5 95		      lda	currentPly
   1098  fe7a		       85 3e		      sta	SET_BANK_RAM
   1099  fe7c
   1100  fe7c							; See if there are any 'secondary' pieces that moved
   1101  fe7c							; here we're dealing with reverting a castling or enPassant move
   1102  fe7c
      0  fe7c					      lda@PLY	secondaryPiece
      1  fe7c		       ad 4c f1 	      lda	secondaryPiece
   1104  fe7f		       f0 1a		      beq	.noSecondary
      0  fe81					      ldy@PLY	secondaryBlank
      1  fe81		       ac 4e f1 	      ldy	secondaryBlank
   1106  fe84		       84 af		      sty	__secondaryBlank
      0  fe86					      ldy@PLY	secondarySquare
      1  fe86		       ac 4d f1 	      ldy	secondarySquare
   1108  fe89
   1109  fe89
   1110  fe89		       a2 09		      ldx	#RAMBANK_BOARD
   1111  fe8b		       86 3e		      stx	SET_BANK_RAM
      0  fe8d					      sta@RAM	Board,y	; put piece back
      1  fe8d		       99 84 f4 	      sta	[RAM]+Board,y
   1113  fe90
   1114  fe90		       a4 af		      ldy	__secondaryBlank
   1115  fe92		       a9 00		      lda	#0
      0  fe94					      sta@RAM	Board,y	; blank piece origin
      1  fe94		       99 84 f4 	      sta	[RAM]+Board,y
   1117  fe97
   1118  fe97		       a5 95		      lda	currentPly
   1119  fe99		       85 3e		      sta	SET_BANK_RAM
   1120  fe9b
   1121  fe9b
   1122  fe9b				   .noSecondary
      0  fe9b					      SWAP
      1  fe9b		       a5 96		      lda	sideToMove
      2  fe9d		       49 81		      eor	#SWAP_SIDE
      3  fe9f		       85 96		      sta	sideToMove
   1124  fea1		       60		      rts
   1125  fea2
   1126  fea2
   1127  fea2							;---------------------------------------------------------------------------------------------------
   1128  fea2
   1129  fea2							;function negaMax(node, depth, α, β, color) is
   1130  fea2							;    if depth = 0 or node is a terminal node then
   1131  fea2							;	  return color × the heuristic value of node
   1132  fea2
   1133  fea2							;    childNodes := generateMoves(node)
   1134  fea2							;    childNodes := orderMoves(childNodes)
   1135  fea2							;    value := −∞
   1136  fea2							;    foreach child in childNodes do
   1137  fea2							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
   1138  fea2							;	  α := max(α, value)
   1139  fea2							;	  if α ≥ β then
   1140  fea2							;	      break (* cut-off *)
   1141  fea2							;    return value
   1142  fea2							;(* Initial call for Player A's root node *)
   1143  fea2							;negaMax(rootNode, depth, −∞, +∞, 1)
   1144  fea2
   1145  fea2
   1146  fea2					      SUBROUTINE
   1147  fea2
   1148  fea2		       a9 ff	   .doQ       lda	#-1
   1149  fea4		       85 ad		      sta	__quiesceCapOnly
   1150  fea6		       20 a3 f2 	      jsr	quiesce
   1151  fea9		       e6 ad		      inc	__quiesceCapOnly
   1152  feab		       60		      rts
   1153  feac
   1154  feac
      0  feac				   .exit      lda@PLY	value
      1  feac		       ad 56 f1 	      lda	value
   1156  feaf		       85 a9		      sta	__negaMax
      0  feb1					      lda@PLY	value+1
      1  feb1		       ad 57 f1 	      lda	value+1
   1158  feb4		       85 aa		      sta	__negaMax+1
   1159  feb6		       60		      rts
   1160  feb7
   1161  feb7
   1162  feb7		       c9 00	   .terminal  cmp	#0	; captured piece
   1163  feb9		       d0 e7		      bne	.doQ	; last move was capture, so quiesce
   1164  febb
   1165  febb		       a5 90		      lda	Evaluation
   1166  febd		       85 a9		      sta	__negaMax
   1167  febf		       a5 91		      lda	Evaluation+1
   1168  fec1		       85 aa		      sta	__negaMax+1
   1169  fec3
   1170  fec3		       60	   .inCheck2  rts
   1171  fec4
   1172  fec4
   1173  fec4
      0  fec4					      DEF	negaMax
      1  fec4				   BANK_negaMax SET	_CURRENT_BANK
      2  fec4				   negaMax
      3  fec4				   TEMPORARY_VAR SET	Overlay
      4  fec4				   TEMPORARY_OFFSET SET	0
      5  fec4				   VAR_BOUNDARY_negaMax SET	TEMPORARY_OFFSET
      6  fec4				   FUNCTION_NAME SET	negaMax
      7  fec4					      SUBROUTINE
   1175  fec4
   1176  fec4							; PARAMS depth-1, -beta, -alpha
   1177  fec4							; pased through temporary variables (__alpha, __beta) and X reg
   1178  fec4
   1179  fec4							; pass...
   1180  fec4							; x = depthleft
   1181  fec4							; a = captured piece
   1182  fec4							; SET_BANK_RAM      --> current ply
   1183  fec4							; __alpha[2] = param alpha
   1184  fec4							; __beta[2] = param beta
   1185  fec4
   1186  fec4
      0  fec4					      COMMON_VARS_ALPHABETA
      1  fec4
      0  fec4					      VAR	__thinkbar, 1
      1  fec4		       00 a2	   __thinkbar =	TEMPORARY_VAR
      2  fec4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fec4
      4  fec4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fec4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fec4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fec4					      ENDIF
      8  fec4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fec4				  -	      ECHO	"Temporary Variable", __thinkbar, "overflow!"
     10  fec4				  -	      ERR
     11  fec4					      ENDIF
     12  fec4					      LIST	ON
      0  fec4					      VAR	__toggle, 1
      1  fec4		       00 a3	   __toggle   =	TEMPORARY_VAR
      2  fec4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fec4
      4  fec4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fec4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fec4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fec4					      ENDIF
      8  fec4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fec4				  -	      ECHO	"Temporary Variable", __toggle, "overflow!"
     10  fec4				  -	      ERR
     11  fec4					      ENDIF
     12  fec4					      LIST	ON
      4  fec4
      0  fec4					      VAR	__bestMove, 1
      1  fec4		       00 a4	   __bestMove =	TEMPORARY_VAR
      2  fec4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fec4
      4  fec4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fec4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fec4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fec4					      ENDIF
      8  fec4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fec4				  -	      ECHO	"Temporary Variable", __bestMove, "overflow!"
     10  fec4				  -	      ERR
     11  fec4					      ENDIF
     12  fec4					      LIST	ON
      0  fec4					      VAR	__alpha, 2
      1  fec4		       00 a5	   __alpha    =	TEMPORARY_VAR
      2  fec4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  fec4
      4  fec4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fec4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fec4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fec4					      ENDIF
      8  fec4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fec4				  -	      ECHO	"Temporary Variable", __alpha, "overflow!"
     10  fec4				  -	      ERR
     11  fec4					      ENDIF
     12  fec4					      LIST	ON
      0  fec4					      VAR	__beta, 2
      1  fec4		       00 a7	   __beta     =	TEMPORARY_VAR
      2  fec4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  fec4
      4  fec4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fec4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fec4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fec4					      ENDIF
      8  fec4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fec4				  -	      ECHO	"Temporary Variable", __beta, "overflow!"
     10  fec4				  -	      ERR
     11  fec4					      ENDIF
     12  fec4					      LIST	ON
      0  fec4					      VAR	__negaMax, 2
      1  fec4		       00 a9	   __negaMax  =	TEMPORARY_VAR
      2  fec4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  fec4
      4  fec4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fec4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fec4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fec4					      ENDIF
      8  fec4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fec4				  -	      ECHO	"Temporary Variable", __negaMax, "overflow!"
     10  fec4				  -	      ERR
     11  fec4					      ENDIF
     12  fec4					      LIST	ON
      0  fec4					      VAR	__value, 2
      1  fec4		       00 ab	   __value    =	TEMPORARY_VAR
      2  fec4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 2
      3  fec4
      4  fec4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fec4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fec4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fec4					      ENDIF
      8  fec4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fec4				  -	      ECHO	"Temporary Variable", __value, "overflow!"
     10  fec4				  -	      ERR
     11  fec4					      ENDIF
     12  fec4					      LIST	ON
     10  fec4
      0  fec4					      VAR	__quiesceCapOnly, 1
      1  fec4		       00 ad	   __quiesceCapOnly =	TEMPORARY_VAR
      2  fec4				   TEMPORARY_VAR SET	TEMPORARY_VAR + TEMPORARY_OFFSET + 1
      3  fec4
      4  fec4				   OVERLAY_DELTA SET	TEMPORARY_VAR - Overlay
      5  fec4				  -	      IF	OVERLAY_DELTA > MAXIMUM_REQUIRED_OVERLAY_SIZE
      6  fec4				  -MAXIMUM_REQUIRED_OVERLAY_SIZE SET	OVERLAY_DELTA
      7  fec4					      ENDIF
      8  fec4				  -	      IF	OVERLAY_DELTA > OVERLAY_SIZE
      9  fec4				  -	      ECHO	"Temporary Variable", __quiesceCapOnly, "overflow!"
     10  fec4				  -	      ERR
     11  fec4					      ENDIF
     12  fec4					      LIST	ON
     12  fec4
      0  fec4					      REFER	selectmove
      1  fec4				  -	      IF	VAREND_selectmove > TEMPORARY_VAR
      2  fec4				  -TEMPORARY_VAR SET	VAREND_selectmove
      3  fec4					      ENDIF
      0  fec4					      VEND	negaMax
      1  fec4				  -	      IFNCONST	negaMax
      2  fec4				  -	      ECHO	"Incorrect VEND label", negaMax
      3  fec4				  -	      ERR
      4  fec4					      ENDIF
      5  fec4		       00 ae	   VAREND_negaMax =	TEMPORARY_VAR
   1190  fec4
   1191  fec4		       48		      pha
   1192  fec5
      0  fec5					      JSROM	ThinkBar
      1  fec5
      2  fec5		       a9 01		      lda	#BANK_ThinkBar
      3  fec7		       85 3f		      sta	SET_BANK
      4  fec9		       20 2b f0 	      jsr	ThinkBar
   1194  fecc		       a5 95		      lda	currentPly
   1195  fece		       85 3e		      sta	SET_BANK_RAM
   1196  fed0
   1197  fed0		       68		      pla
   1198  fed1		       ca		      dex
   1199  fed2		       30 e3		      bmi	.terminal
      0  fed4					      stx@PLY	depthLeft
      1  fed4		       8e 58 f5 	      stx	[RAM]+depthLeft
   1201  fed7
   1202  fed7		       a9 02		      lda	#$02	;COLOUR_LINE_1
   1203  fed9		       85 48		      sta	COLUPF
   1204  fedb
   1205  fedb
   1206  fedb							; Allow the player to force computer to select a move. Press the SELECT switch
   1207  fedb							; This may have issues if no move has been selected yet. Still... if you wanna cheat....
   1208  fedb
   1209  fedb		       ad 82 02 	      lda	SWCHB
   1210  fede		       29 02		      and	#2
   1211  fee0		       f0 ca		      beq	.exit	; SELECT abort
   1212  fee2
   1213  fee2
   1214  fee2		       a5 a5		      lda	__alpha
      0  fee4					      sta@PLY	alpha
      1  fee4		       8d 52 f5 	      sta	[RAM]+alpha
   1216  fee7		       a5 a6		      lda	__alpha+1
      0  fee9					      sta@PLY	alpha+1
      1  fee9		       8d 53 f5 	      sta	[RAM]+alpha+1
   1218  feec
   1219  feec		       a5 a7		      lda	__beta
      0  feee					      sta@PLY	beta
      1  feee		       8d 54 f5 	      sta	[RAM]+beta
   1221  fef1		       a5 a8		      lda	__beta+1
      0  fef3					      sta@PLY	beta+1
      1  fef3		       8d 55 f5 	      sta	[RAM]+beta+1
   1223  fef6
   1224  fef6
   1225  fef6					      IF	1
   1226  fef6		       a5 90		      lda	Evaluation
   1227  fef8		       65 a1		      adc	randomness
   1228  fefa		       85 90		      sta	Evaluation
   1229  fefc		       90 02		      bcc	.evh
   1230  fefe		       e6 91		      inc	Evaluation+1
   1231  ff00				   .evh
   1232  ff00					      ENDIF
   1233  ff00
   1234  ff00		       20 07 f9 	      jsr	GenerateAllMoves
   1235  ff03		       a5 9f		      lda	flagCheck
   1236  ff05		       d0 bc		      bne	.inCheck2	; OTHER guy in check
   1237  ff07
   1238  ff07					      IF	1
      0  ff07					      lda@PLY	moveIndex
      1  ff07		       ad 4f f1 	      lda	moveIndex
   1240  ff0a		       30 0f		      bmi	.none
   1241  ff0c		       4a		      lsr
   1242  ff0d		       4a		      lsr
   1243  ff0e		       4a		      lsr
   1244  ff0f		       4a		      lsr
   1245  ff10		       4a		      lsr
   1246  ff11		       65 90		      adc	Evaluation
   1247  ff13		       85 90		      sta	Evaluation
   1248  ff15		       a5 91		      lda	Evaluation+1
   1249  ff17		       69 00		      adc	#0
   1250  ff19		       85 91		      sta	Evaluation+1
   1251  ff1b				   .none
   1252  ff1b					      ENDIF
   1253  ff1b
   1254  ff1b
   1255  ff1b		       a9 00		      lda	#<-INFINITY
      0  ff1d					      sta@PLY	value
      1  ff1d		       8d 56 f5 	      sta	[RAM]+value
   1257  ff20		       a9 90		      lda	#>-INFINITY
      0  ff22					      sta@PLY	value+1
      1  ff22		       8d 57 f5 	      sta	[RAM]+value+1
   1259  ff25
      0  ff25					      ldx@PLY	moveIndex
      1  ff25		       ae 4f f1 	      ldx	moveIndex
   1261  ff28		       10 03		      bpl	.forChild
   1262  ff2a		       4c ac fe 	      jmp	.exit
   1263  ff2d
      0  ff2d				   .forChild  stx@PLY	movePtr
      1  ff2d		       8e 50 f5 	      stx	[RAM]+movePtr
   1265  ff30
   1266  ff30		       20 dc fd 	      jsr	MakeMove
   1267  ff33
   1268  ff33
   1269  ff33
   1270  ff33							;	  value := max(value, −negaMax(child, depth − 1, −β, −α, −color))
   1271  ff33
   1272  ff33							; PARAMS depth-1, -beta, -alpha
   1273  ff33							; pased through temporary variables (__alpha, __beta) and X reg
   1274  ff33
   1275  ff33		       38		      sec
   1276  ff34		       a9 00		      lda	#0
      0  ff36					      sbc@PLY	beta
      1  ff36		       ed 54 f1 	      sbc	beta
   1278  ff39		       85 a5		      sta	__alpha
   1279  ff3b		       a9 00		      lda	#0
      0  ff3d					      sbc@PLY	beta+1
      1  ff3d		       ed 55 f1 	      sbc	beta+1
   1281  ff40		       85 a6		      sta	__alpha+1
   1282  ff42
   1283  ff42		       38		      sec
   1284  ff43		       a9 00		      lda	#0
      0  ff45					      sbc@PLY	alpha
      1  ff45		       ed 52 f1 	      sbc	alpha
   1286  ff48		       85 a7		      sta	__beta
   1287  ff4a		       a9 00		      lda	#0
      0  ff4c					      sbc@PLY	alpha+1
      1  ff4c		       ed 53 f1 	      sbc	alpha+1
   1289  ff4f		       85 a8		      sta	__beta+1
   1290  ff51
   1291  ff51
      0  ff51					      ldx@PLY	depthLeft
      1  ff51		       ae 58 f1 	      ldx	depthLeft
      0  ff54					      lda@PLY	capturedPiece
      1  ff54		       ad 4a f1 	      lda	capturedPiece
   1294  ff57
   1295  ff57		       e6 95		      inc	currentPly
   1296  ff59		       a4 95		      ldy	currentPly
   1297  ff5b		       84 3e		      sty	SET_BANK_RAM	; self-switch
   1298  ff5d
   1299  ff5d		       20 c4 fe 	      jsr	negaMax
   1300  ff60
   1301  ff60		       c6 95		      dec	currentPly
   1302  ff62		       a5 95		      lda	currentPly
   1303  ff64		       85 3e		      sta	SET_BANK_RAM
   1304  ff66
   1305  ff66		       20 4f fe 	      jsr	unmakeMove
   1306  ff69
   1307  ff69		       38		      sec
   1308  ff6a		       a9 00		      lda	#0
   1309  ff6c		       e5 a9		      sbc	__negaMax
   1310  ff6e		       85 a9		      sta	__negaMax
   1311  ff70		       a9 00		      lda	#0
   1312  ff72		       e5 aa		      sbc	__negaMax+1
   1313  ff74		       85 aa		      sta	__negaMax+1	; -negaMax(...)
   1314  ff76
   1315  ff76		       a5 9f		      lda	flagCheck
   1316  ff78		       f0 06		      beq	.notCheck
   1317  ff7a
   1318  ff7a							; at this point we've determined that the move was illegal, because the next ply detected
   1319  ff7a							; a king capture. So, the move should be totally discounted
   1320  ff7a
   1321  ff7a		       a9 00		      lda	#0
   1322  ff7c		       85 9f		      sta	flagCheck	; so we don't retrigger in future - it's been handled!
   1323  ff7e		       f0 53		      beq	.nextMove	; unconditional - move is not considered!
   1324  ff80
   1325  ff80		       38	   .notCheck  sec
      0  ff81					      lda@PLY	value
      1  ff81		       ad 56 f1 	      lda	value
   1327  ff84		       e5 a9		      sbc	__negaMax
      0  ff86					      lda@PLY	value+1
      1  ff86		       ad 57 f1 	      lda	value+1
   1329  ff89		       e5 aa		      sbc	__negaMax+1
   1330  ff8b		       50 02		      bvc	.lab0
   1331  ff8d		       49 80		      eor	#$80
   1332  ff8f		       10 10	   .lab0      bpl	.lt0	; branch if value >= negaMax
   1333  ff91
   1334  ff91							; so, negaMax > value!
   1335  ff91
   1336  ff91		       a5 a9		      lda	__negaMax
      0  ff93					      sta@PLY	value
      1  ff93		       8d 56 f5 	      sta	[RAM]+value
   1338  ff96		       a5 aa		      lda	__negaMax+1
      0  ff98					      sta@PLY	value+1	; max(value, -negaMax)
      1  ff98		       8d 57 f5 	      sta	[RAM]+value+1
   1340  ff9b
      0  ff9b					      lda@PLY	movePtr
      1  ff9b		       ad 50 f1 	      lda	movePtr
      0  ff9e					      sta@PLY	bestMove
      1  ff9e		       8d 51 f5 	      sta	[RAM]+bestMove
   1343  ffa1				   .lt0
   1344  ffa1
   1345  ffa1							;	  α := max(α, value)
   1346  ffa1
   1347  ffa1		       38		      sec
      0  ffa2					      lda@PLY	value
      1  ffa2		       ad 56 f1 	      lda	value
      0  ffa5					      sbc@PLY	alpha
      1  ffa5		       ed 52 f1 	      sbc	alpha
      0  ffa8					      lda@PLY	value+1
      1  ffa8		       ad 57 f1 	      lda	value+1
      0  ffab					      sbc@PLY	alpha+1
      1  ffab		       ed 53 f1 	      sbc	alpha+1
   1352  ffae		       50 02		      bvc	.lab1
   1353  ffb0		       49 80		      eor	#$80
   1354  ffb2		       30 0c	   .lab1      bmi	.lt1	; value < alpha
   1355  ffb4
      0  ffb4					      lda@PLY	value
      1  ffb4		       ad 56 f1 	      lda	value
      0  ffb7					      sta@PLY	alpha
      1  ffb7		       8d 52 f5 	      sta	[RAM]+alpha
      0  ffba					      lda@PLY	value+1
      1  ffba		       ad 57 f1 	      lda	value+1
      0  ffbd					      sta@PLY	alpha+1	; alpha = max(alpha, value)
      1  ffbd		       8d 53 f5 	      sta	[RAM]+alpha+1
   1360  ffc0
   1361  ffc0				   .lt1
   1362  ffc0
   1363  ffc0							;	  if α ≥ β then
   1364  ffc0							;	      break (* cut-off *)
   1365  ffc0
   1366  ffc0		       38		      sec
      0  ffc1					      lda@PLY	alpha
      1  ffc1		       ad 52 f1 	      lda	alpha
      0  ffc4					      sbc@PLY	beta
      1  ffc4		       ed 54 f1 	      sbc	beta
      0  ffc7					      lda@PLY	alpha+1
      1  ffc7		       ad 53 f1 	      lda	alpha+1
      0  ffca					      sbc@PLY	beta+1
      1  ffca		       ed 55 f1 	      sbc	beta+1
   1371  ffcd		       50 02		      bvc	.lab2
   1372  ffcf		       49 80		      eor	#$80
   1373  ffd1		       10 09	   .lab2      bpl	.retrn	; alpha >= beta
   1374  ffd3
   1375  ffd3
      0  ffd3				   .nextMove  ldx@PLY	movePtr
      1  ffd3		       ae 50 f1 	      ldx	movePtr
   1377  ffd6		       ca	   .nextX     dex
   1378  ffd7		       30 03		      bmi	.retrn
   1379  ffd9		       4c 2d ff 	      jmp	.forChild
   1380  ffdc
   1381  ffdc		       4c ac fe    .retrn     jmp	.exit
   1382  ffdf
   1383  ffdf
   1384  ffdf							;---------------------------------------------------------------------------------------------------
   1385  ffdf
 FREE BYTES IN FIXED BANK =  $1d
   1386  ffdf					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFC - *
   1387  ffdf
   1388  ffdf							;---------------------------------------------------------------------------------------------------
   1389  ffdf							; The reset vectors
   1390  ffdf							; these must live in the fixed bank (last 2K of any ROM image in "3E" scheme)
   1391  ffdf
   1392  10000 ????				       SEG	InterruptVectors
   1393  fffc					      ORG	FIXED_BANK + $7FC
   1394  fffc					      RORG	$7ffC
   1395  fffc
   1396  fffc		       00 f8		      .word.w	Reset	; RESET
   1397  fffe		       00 f8		      .word.w	Reset	; IRQ	      (not used)
   1398  10000
   1399  10000							;---------------------------------------------------------------------------------------------------
   1400  10000							; EOF
------- FILE ./chess.asm
    616  10000
    617  10000							;END
